{"sha": "8e373b47872872a2ce61c5b02f4dd96d90d046ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMzczYjQ3ODcyODcyYTJjZTYxYzViMDJmNGRkOTZkOTBkMDQ2ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-30T02:41:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-30T02:41:38Z"}, "message": "Auto merge of #37965 - Mark-Simulacrum:trait-obj-to-exis-predicate, r=eddyb\n\nRefactor TraitObject to Slice<ExistentialPredicate>\n\nFor reference, the primary types changes in this PR are shown below. They may add in the understanding of what is discussed below, though they should not be required.\n\nWe change `TraitObject` into a list of `ExistentialPredicate`s to allow for a couple of things:\n - Principal (ExistentialPredicate::Trait) is now optional.\n - Region bounds are moved out of `TraitObject` into `TyDynamic`. This permits wrapping only the `ExistentialPredicate` list in `Binder`.\n - `BuiltinBounds` and `BuiltinBound` are removed entirely from the codebase, to permit future non-constrained auto traits. These are replaced with `ExistentialPredicate::AutoTrait`, which only requires a `DefId`. For the time being, only `Send` and `Sync` are supported; this constraint can be lifted in a future pull request.\n - Binder-related logic is extracted from `ExistentialPredicate` into the parent (`Binder<Slice<EP>>`), so `PolyX`s are inside `TraitObject` are replaced with `X`.\n\nThe code requires a sorting order for `ExistentialPredicate`s in the interned `Slice`. The sort order is asserted to be correct during interning, but the slices are not sorted at that point.\n\n1. `ExistentialPredicate::Trait` are defined as always equal; **This may be wrong; should we be comparing them and sorting them in some way?**\n1. `ExistentialPredicate::Projection`: Compared by `ExistentialProjection::sort_key`.\n1. `ExistentialPredicate::AutoTrait`: Compared by `TraitDef.def_path_hash`.\n\nConstruction of `ExistentialPredicate`s is conducted through `TyCtxt::mk_existential_predicates`, which interns a passed iterator as a `Slice`. There are no convenience functions to construct from a set of separate iterators; callers must pass an iterator chain. The lack of convenience functions is primarily due to few uses and the relative difficulty in defining a nice API due to optional parts and difficulty in recognizing which argument goes where. It is also true that the current situation isn't significantly better than 4 arguments to a constructor function; but the extra work is deemed unnecessary as of this time.\n\n```rust\n// before this PR\nstruct TraitObject<'tcx> {\n    pub principal: PolyExistentialTraitRef<'tcx>,\n    pub region_bound: &'tcx ty::Region,\n    pub builtin_bounds: BuiltinBounds,\n    pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n}\n\n// after\npub enum ExistentialPredicate<'tcx> {\n    // e.g. Iterator\n    Trait(ExistentialTraitRef<'tcx>),\n    // e.g. Iterator::Item = T\n    Projection(ExistentialProjection<'tcx>),\n    // e.g. Send\n    AutoTrait(DefId),\n}\n```", "tree": {"sha": "94e1ef5d9f0cc5ada6abf5ae75dcd1d4e7f28937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94e1ef5d9f0cc5ada6abf5ae75dcd1d4e7f28937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e373b47872872a2ce61c5b02f4dd96d90d046ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e373b47872872a2ce61c5b02f4dd96d90d046ee", "html_url": "https://github.com/rust-lang/rust/commit/8e373b47872872a2ce61c5b02f4dd96d90d046ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e373b47872872a2ce61c5b02f4dd96d90d046ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa0005f2d5a9081597867b383c9b2d0b21569b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0005f2d5a9081597867b383c9b2d0b21569b88", "html_url": "https://github.com/rust-lang/rust/commit/fa0005f2d5a9081597867b383c9b2d0b21569b88"}, {"sha": "8b82fd7a94313140d8c745bb8cc647a953e07d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b82fd7a94313140d8c745bb8cc647a953e07d9e", "html_url": "https://github.com/rust-lang/rust/commit/8b82fd7a94313140d8c745bb8cc647a953e07d9e"}], "stats": {"total": 1800, "additions": 896, "deletions": 904}, "files": [{"sha": "cf985a0d980b4a640e9d3018cf1740cc4ad2a447", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -140,7 +140,7 @@ DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n-                     rustc_const_eval rustc_errors\n+                     rustc_const_eval rustc_errors rustc_data_structures\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts test \\\n                 rustc_lint rustc_const_eval syntax_pos rustc_data_structures"}, {"sha": "19183892e4b0c16cb68629d14b3ad7212341e9d6", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyRef(..) |\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) |\n-            ty::TyTrait(..) |\n+            ty::TyDynamic(..) |\n             ty::TyClosure(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |"}, {"sha": "72ef987aefd5ca96f349186d992b460e1247023b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -24,6 +24,7 @@ use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n+use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n use ty::adjustment;\n@@ -1492,11 +1493,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+\n         // this can get called from typeck (by euv), and moves_by_default\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n+        !traits::type_known_to_meet_bound(self, ty, copy_def_id, span)\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)"}, {"sha": "c0ea8d6b1e38baa4400c1e58323eb11a08fc7a94", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -32,7 +32,6 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n-#![feature(enumset)]\n #![cfg_attr(stage0, feature(item_like_imports))]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "1efc211b8c35be608b29cfd05cf2b103c67607bc", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -90,31 +90,6 @@ impl LanguageItems {\n         self.require(OwnedBoxLangItem)\n     }\n \n-    pub fn from_builtin_kind(&self, bound: ty::BuiltinBound)\n-                             -> Result<DefId, String>\n-    {\n-        match bound {\n-            ty::BoundSend => self.require(SendTraitLangItem),\n-            ty::BoundSized => self.require(SizedTraitLangItem),\n-            ty::BoundCopy => self.require(CopyTraitLangItem),\n-            ty::BoundSync => self.require(SyncTraitLangItem),\n-        }\n-    }\n-\n-    pub fn to_builtin_kind(&self, id: DefId) -> Option<ty::BuiltinBound> {\n-        if Some(id) == self.send_trait() {\n-            Some(ty::BoundSend)\n-        } else if Some(id) == self.sized_trait() {\n-            Some(ty::BoundSized)\n-        } else if Some(id) == self.copy_trait() {\n-            Some(ty::BoundCopy)\n-        } else if Some(id) == self.sync_trait() {\n-            Some(ty::BoundSync)\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n         let def_id_kinds = [\n             (self.fn_trait(), ty::ClosureKind::Fn),\n@@ -381,3 +356,11 @@ language_item_table! {\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;\n }\n+\n+impl<'a, 'tcx, 'gcx> ty::TyCtxt<'a, 'tcx, 'gcx> {\n+    pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n+        self.lang_items.require(lang_item).unwrap_or_else(|msg| {\n+            self.sess.fatal(&msg)\n+        })\n+    }\n+}"}, {"sha": "58cb52e897786a5687a0fe6eb13ea2f1bfa1cd1a", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -225,14 +225,12 @@ fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyBox(..) | ty::TyRef(..) =>\n-            true,\n-        ty::TyAdt(def, _) =>\n-            def.is_fundamental(),\n-        ty::TyTrait(ref data) =>\n-            tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n-        _ =>\n-            false\n+        ty::TyBox(..) | ty::TyRef(..) => true,\n+        ty::TyAdt(def, _) => def.is_fundamental(),\n+        ty::TyDynamic(ref data, ..) => {\n+            data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n+        }\n+        _ => false\n     }\n }\n \n@@ -272,8 +270,8 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             krate == Some(LOCAL_CRATE)\n         }\n \n-        ty::TyTrait(ref tt) => {\n-            tt.principal.def_id().is_local()\n+        ty::TyDynamic(ref tt, ..) => {\n+            tt.principal().map_or(false, |p| p.def_id().is_local())\n         }\n \n         ty::TyError => {"}, {"sha": "2e8e45468ddcb2199f0cb417ee8ba45ff80db168", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n                 ty::TyArray(..) | ty::TySlice(..) => Some(6),\n                 ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n-                ty::TyTrait(..) => Some(8),\n+                ty::TyDynamic(..) => Some(8),\n                 ty::TyClosure(..) => Some(9),\n                 ty::TyTuple(..) => Some(10),\n                 ty::TyProjection(..) => Some(11),\n@@ -905,16 +905,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::StructInitializerSized => {\n                 err.note(\"structs must have a statically known size to be initialized\");\n             }\n-            ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n-                let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-                let trait_name = tcx.item_path_str(def_id);\n-                let name = tcx.local_var_name_str(var_id);\n-                err.note(\n-                    &format!(\"the closure that captures `{}` requires that all captured variables \\\n-                              implement the trait `{}`\",\n-                             name,\n-                             trait_name));\n-            }\n             ObligationCauseCode::FieldSized => {\n                 err.note(\"only the last field of a struct may have a dynamically sized type\");\n             }"}, {"sha": "23c28037a3c2d7b629f211c195446299032a6e0d", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -17,8 +17,8 @@ use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProce\n use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n-use util::common::ErrorReported;\n use util::nodemap::{FxHashSet, NodeMap};\n+use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -230,18 +230,21 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         normalized.value\n     }\n \n-    pub fn register_builtin_bound(&mut self,\n-                                  infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  builtin_bound: ty::BuiltinBound,\n-                                  cause: ObligationCause<'tcx>)\n+    pub fn register_bound(&mut self,\n+                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          def_id: DefId,\n+                          cause: ObligationCause<'tcx>)\n     {\n-        match infcx.tcx.predicate_for_builtin_bound(cause, builtin_bound, 0, ty) {\n-            Ok(predicate) => {\n-                self.register_predicate_obligation(infcx, predicate);\n-            }\n-            Err(ErrorReported) => { }\n-        }\n+        let trait_ref = ty::TraitRef {\n+            def_id: def_id,\n+            substs: infcx.tcx.mk_substs_trait(ty, &[]),\n+        };\n+        self.register_predicate_obligation(infcx, Obligation {\n+            cause: cause,\n+            recursion_depth: 0,\n+            predicate: trait_ref.to_predicate()\n+        });\n     }\n \n     pub fn register_region_obligation(&mut self,"}, {"sha": "5c5bf130c3ba401ee28b00499fddca56a754429d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -19,7 +19,7 @@ use hir;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use infer::InferCtxt;\n \n use std::rc::Rc;\n@@ -125,10 +125,6 @@ pub enum ObligationCauseCode<'tcx> {\n     ReturnType,                // Return type must be Sized\n     RepeatVec,                 // [T,..n] --> T must be Copy\n \n-    // Captures of variable the given id by a closure (span is the\n-    // span of the closure)\n-    ClosureCapture(ast::NodeId, Span, ty::BuiltinBound),\n-\n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n \n@@ -369,27 +365,30 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                        ty: Ty<'tcx>,\n-                                                        bound: ty::BuiltinBound,\n-                                                        span: Span)\n-                                                        -> bool\n+pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                ty: Ty<'tcx>,\n+                                                def_id: DefId,\n+                                                span: Span)\n+-> bool\n {\n-    debug!(\"type_known_to_meet_builtin_bound(ty={:?}, bound={:?})\",\n+    debug!(\"type_known_to_meet_bound(ty={:?}, bound={:?})\",\n            ty,\n-           bound);\n-\n-    let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n-    let obligation =\n-        infcx.tcx.predicate_for_builtin_bound(cause, bound, 0, ty);\n-    let obligation = match obligation {\n-        Ok(o) => o,\n-        Err(..) => return false\n+           infcx.tcx.item_path_str(def_id));\n+\n+    let trait_ref = ty::TraitRef {\n+        def_id: def_id,\n+        substs: infcx.tcx.mk_substs_trait(ty, &[]),\n     };\n+    let obligation = Obligation {\n+        cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+        recursion_depth: 0,\n+        predicate: trait_ref.to_predicate(),\n+    };\n+\n     let result = SelectionContext::new(infcx)\n         .evaluate_obligation_conservatively(&obligation);\n-    debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} => {:?}\",\n-           ty, bound, result);\n+    debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n+           ty, infcx.tcx.item_path_str(def_id), result);\n \n     if result && (ty.has_infer_types() || ty.has_closure_types()) {\n         // Because of inference \"guessing\", selection can sometimes claim\n@@ -404,22 +403,22 @@ pub fn type_known_to_meet_builtin_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'g\n         // anyhow).\n         let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n-        fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n+        fulfill_cx.register_bound(infcx, ty, def_id, cause);\n \n         // Note: we only assume something is `Copy` if we can\n         // *definitively* show that it implements `Copy`. Otherwise,\n         // assume it is move; linear is always ok.\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => {\n-                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n+                debug!(\"type_known_to_meet_bound: ty={:?} bound={} success\",\n                        ty,\n-                       bound);\n+                       infcx.tcx.item_path_str(def_id));\n                 true\n             }\n             Err(e) => {\n-                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n+                debug!(\"type_known_to_meet_bound: ty={:?} bound={} errors={:?}\",\n                        ty,\n-                       bound,\n+                       infcx.tcx.item_path_str(def_id),\n                        e);\n                 false\n             }"}, {"sha": "27b7adf0ef34a3887e7dc275fbfc29849ff7bc39", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -1123,15 +1123,15 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n-        ty::TyTrait(ref data) => data,\n+        ty::TyDynamic(ref data, ..) => data,\n         _ => {\n             span_bug!(\n                 obligation.cause.span,\n                 \"confirm_object_candidate called with non-object: {:?}\",\n                 object_ty)\n         }\n     };\n-    let env_predicates = data.projection_bounds.iter().map(|p| {\n+    let env_predicates = data.projection_bounds().map(|p| {\n         p.with_self_ty(selcx.tcx(), object_ty).to_predicate()\n     }).collect();\n     let env_predicate = {"}, {"sha": "38a228034dd055cff56c8e32303a9cb8169e1f9c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 82, "deletions": 95, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -41,6 +41,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n+use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n@@ -1091,40 +1092,31 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-            Some(ty::BoundCopy) => {\n-                debug!(\"obligation self ty is {:?}\",\n-                       obligation.predicate.0.self_ty());\n-\n-                // User-defined copy impls are permitted, but only for\n-                // structs and enums.\n-                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-\n-                // For other types, we'll use the builtin rules.\n-                let copy_conditions = self.copy_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-            }\n-            Some(ty::BoundSized) => {\n-                // Sized is never implementable by end-users, it is\n-                // always automatically computed.\n-                let sized_conditions = self.sized_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(sized_conditions,\n-                                                       &mut candidates)?;\n-            }\n-\n-            None if self.tcx().lang_items.unsize_trait() ==\n-                    Some(obligation.predicate.def_id()) => {\n-                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-            }\n-\n-            Some(ty::BoundSend) |\n-            Some(ty::BoundSync) |\n-            None => {\n-                self.assemble_closure_candidates(obligation, &mut candidates)?;\n-                self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-            }\n+        let def_id = obligation.predicate.def_id();\n+        if self.tcx().lang_items.copy_trait() == Some(def_id) {\n+            debug!(\"obligation self ty is {:?}\",\n+                   obligation.predicate.0.self_ty());\n+\n+            // User-defined copy impls are permitted, but only for\n+            // structs and enums.\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+\n+            // For other types, we'll use the builtin rules.\n+            let copy_conditions = self.copy_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+        } else if self.tcx().lang_items.sized_trait() == Some(def_id) {\n+            // Sized is never implementable by end-users, it is\n+            // always automatically computed.\n+            let sized_conditions = self.sized_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(sized_conditions,\n+                                                   &mut candidates)?;\n+         } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n+             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+         } else {\n+             self.assemble_closure_candidates(obligation, &mut candidates)?;\n+             self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+             self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+             self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n@@ -1445,7 +1437,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if self.tcx().trait_has_default_impl(def_id) {\n             match self_ty.sty {\n-                ty::TyTrait(..) => {\n+                ty::TyDynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. For most traits, this means we\n                     // conservatively say nothing; a candidate may be\n@@ -1515,20 +1507,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n-                ty::TyTrait(ref data) => {\n-                    match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-                        Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                            if data.builtin_bounds.contains(&bound) {\n-                                debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                                        pushing candidate\");\n-                                candidates.vec.push(BuiltinObjectCandidate);\n-                                return;\n-                            }\n-                        }\n-                        _ => {}\n+                ty::TyDynamic(ref data, ..) => {\n+                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n+                        debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                                    pushing candidate\");\n+                        candidates.vec.push(BuiltinObjectCandidate);\n+                        return;\n                     }\n \n-                    data.principal.with_self_ty(this.tcx(), self_ty)\n+                    match data.principal() {\n+                        Some(p) => p.with_self_ty(this.tcx(), self_ty),\n+                        None => return,\n+                    }\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1599,7 +1589,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n+            (&ty::TyDynamic(ref data_a, ..), &ty::TyDynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n                 // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n@@ -1611,12 +1601,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 //\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n-                data_a.principal.def_id() == data_b.principal.def_id() &&\n-                data_a.builtin_bounds.is_superset(&data_b.builtin_bounds)\n+                match (data_a.principal(), data_b.principal()) {\n+                    (Some(a), Some(b)) => a.def_id() == b.def_id() &&\n+                        data_b.auto_traits()\n+                            // All of a's auto traits need to be in b's auto traits.\n+                            .all(|b| data_a.auto_traits().any(|a| a == b)),\n+                    _ => false\n+                }\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyTrait(_)) => true,\n+            (_, &ty::TyDynamic(..)) => true,\n \n             // Ambiguous handling is below T -> Trait, because inference\n             // variables can still implement Unsize<Trait> and nested\n@@ -1768,7 +1763,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n+            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) => Never,\n \n             ty::TyTuple(tys) => {\n                 Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n@@ -1814,7 +1809,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyBox(_) | ty::TyTrait(..) | ty::TyStr | ty::TySlice(..) |\n+            ty::TyBox(_) | ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyClosure(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n@@ -1879,7 +1874,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Vec::new()\n             }\n \n-            ty::TyTrait(..) |\n+            ty::TyDynamic(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n             ty::TyAnon(..) |\n@@ -2165,10 +2160,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder, it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self_ty.sty {\n-            ty::TyTrait(ref data) => {\n+            ty::TyDynamic(ref data, ..) => {\n                 // OK to skip the binder, it is reintroduced below\n-                let input_types = data.principal.input_types();\n-                let assoc_types = data.projection_bounds.iter()\n+                let principal = data.principal().unwrap();\n+                let input_types = principal.input_types();\n+                let assoc_types = data.projection_bounds()\n                                       .map(|pb| pb.skip_binder().ty);\n                 let all_types: Vec<_> = input_types.chain(assoc_types)\n                                                    .collect();\n@@ -2300,8 +2296,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // case that results. -nmatsakis\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::TyTrait(ref data) => {\n-                data.principal.with_self_ty(self.tcx(), self_ty)\n+            ty::TyDynamic(ref data, ..) => {\n+                data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n                 span_bug!(obligation.cause.span,\n@@ -2469,14 +2465,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n+            (&ty::TyDynamic(ref data_a, r_a), &ty::TyDynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n-                let new_trait = tcx.mk_trait(ty::TraitObject {\n-                    principal: data_a.principal,\n-                    region_bound: data_b.region_bound,\n-                    builtin_bounds: data_b.builtin_bounds,\n-                    projection_bounds: data_a.projection_bounds.clone(),\n-                });\n+                // Binders reintroduced below in call to mk_existential_predicates.\n+                let principal = data_a.skip_binder().principal();\n+                let iter = principal.into_iter().map(ty::ExistentialPredicate::Trait)\n+                    .chain(data_a.skip_binder().projection_bounds()\n+                           .map(|x| ty::ExistentialPredicate::Projection(x)))\n+                    .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n+                let new_trait = tcx.mk_dynamic(\n+                    ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n@@ -2486,20 +2484,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let cause = ObligationCause::new(obligation.cause.span,\n                                                  obligation.cause.body_id,\n                                                  ObjectCastObligation(target));\n-                let outlives = ty::OutlivesPredicate(data_a.region_bound,\n-                                                     data_b.region_bound);\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyTrait(ref data)) => {\n+            (_, &ty::TyDynamic(ref data, r)) => {\n                 let mut object_dids =\n-                    data.builtin_bounds.iter().flat_map(|bound| {\n-                        tcx.lang_items.from_builtin_kind(bound).ok()\n-                    })\n-                    .chain(Some(data.principal.def_id()));\n+                    data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2515,33 +2509,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                        predicate));\n                 };\n \n-                // Create the obligation for casting from T to Trait.\n-                push(data.principal.with_self_ty(tcx, source).to_predicate());\n-\n-                // We can only make objects from sized types.\n-                let mut builtin_bounds = data.builtin_bounds;\n-                builtin_bounds.insert(ty::BoundSized);\n-\n-                // Create additional obligations for all the various builtin\n-                // bounds attached to the object cast. (In other words, if the\n-                // object type is Foo+Send, this would create an obligation\n-                // for the Send check.)\n-                for bound in &builtin_bounds {\n-                    if let Ok(tr) = tcx.trait_ref_for_builtin_bound(bound, source) {\n-                        push(tr.to_predicate());\n-                    } else {\n-                        return Err(Unimplemented);\n-                    }\n+                // Create obligations:\n+                //  - Casting T to Trait\n+                //  - For all the various builtin bounds attached to the object cast. (In other\n+                //  words, if the object type is Foo+Send, this would create an obligation for the\n+                //  Send check.)\n+                //  - Projection predicates\n+                for predicate in data.iter() {\n+                    push(predicate.with_self_ty(tcx, source));\n                 }\n \n-                // Create obligations for the projection predicates.\n-                for bound in &data.projection_bounds {\n-                    push(bound.with_self_ty(tcx, source).to_predicate());\n-                }\n+                // We can only make objects from sized types.\n+                let tr = ty::TraitRef {\n+                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    substs: tcx.mk_substs_trait(source, &[]),\n+                };\n+                push(tr.to_predicate());\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source, data.region_bound);\n+                let outlives = ty::OutlivesPredicate(source, r);\n                 push(ty::Binder(outlives).to_predicate());\n             }\n "}, {"sha": "dedb126d7ff6d6d40b5e304fa2385caed9fdf6b9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -190,9 +190,6 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::VariableType(id) => Some(super::VariableType(id)),\n             super::ReturnType => Some(super::ReturnType),\n             super::RepeatVec => Some(super::RepeatVec),\n-            super::ClosureCapture(node_id, span, bound) => {\n-                Some(super::ClosureCapture(node_id, span, bound))\n-            }\n             super::FieldSized => Some(super::FieldSized),\n             super::ConstSized => Some(super::ConstSized),\n             super::SharedStatic => Some(super::SharedStatic),\n@@ -507,7 +504,6 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::VariableType(_) |\n             super::ReturnType |\n             super::RepeatVec |\n-            super::ClosureCapture(..) |\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n@@ -552,7 +548,6 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::VariableType(_) |\n             super::ReturnType |\n             super::RepeatVec |\n-            super::ClosureCapture(..) |\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |"}, {"sha": "321936fe54be15c37df649761dbfc2ebe66eb002", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -12,7 +12,6 @@ use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use ty::outlives::Component;\n-use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n@@ -408,25 +407,6 @@ pub fn predicate_for_trait_ref<'tcx>(\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn trait_ref_for_builtin_bound(self,\n-        builtin_bound: ty::BuiltinBound,\n-        param_ty: Ty<'tcx>)\n-        -> Result<ty::TraitRef<'tcx>, ErrorReported>\n-    {\n-        match self.lang_items.from_builtin_kind(builtin_bound) {\n-            Ok(def_id) => {\n-                Ok(ty::TraitRef {\n-                    def_id: def_id,\n-                    substs: self.mk_substs_trait(param_ty, &[])\n-                })\n-            }\n-            Err(e) => {\n-                self.sess.err(&e);\n-                Err(ErrorReported)\n-            }\n-        }\n-    }\n-\n     pub fn predicate_for_trait_def(self,\n         cause: ObligationCause<'tcx>,\n         trait_def_id: DefId,\n@@ -442,17 +422,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n \n-    pub fn predicate_for_builtin_bound(self,\n-        cause: ObligationCause<'tcx>,\n-        builtin_bound: ty::BuiltinBound,\n-        recursion_depth: usize,\n-        param_ty: Ty<'tcx>)\n-        -> Result<PredicateObligation<'tcx>, ErrorReported>\n-    {\n-        let trait_ref = self.trait_ref_for_builtin_bound(builtin_bound, param_ty)?;\n-        Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n-    }\n-\n     /// Cast a trait reference into a reference to one of its super\n     /// traits; returns `None` if `target_trait_def_id` is not a\n     /// supertrait."}, {"sha": "8c3cb7929488064cb3982949452d352e121388bd", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     tc_ty(tcx, typ, cache).owned_pointer()\n                 }\n \n-                ty::TyTrait(_) => {\n+                ty::TyDynamic(..) => {\n                     TC::All - TC::InteriorParam\n                 }\n "}, {"sha": "c23ee489a28f41128e6d5714e25085d944ac6f5b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -29,7 +29,7 @@ use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n+use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -47,6 +47,7 @@ use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::iter;\n+use std::cmp::Ordering;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, keywords};\n@@ -63,6 +64,7 @@ pub struct CtxtArenas<'tcx> {\n     region: TypedArena<Region>,\n     stability: TypedArena<attr::Stability>,\n     layout: TypedArena<Layout>,\n+    existential_predicates: TypedArena<ExistentialPredicate<'tcx>>,\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n@@ -81,6 +83,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             region: TypedArena::new(),\n             stability: TypedArena::new(),\n             layout: TypedArena::new(),\n+            existential_predicates: TypedArena::new(),\n \n             generics: TypedArena::new(),\n             trait_def: TypedArena::new(),\n@@ -103,6 +106,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n     stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n     layout: RefCell<FxHashSet<&'tcx Layout>>,\n+    existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -115,7 +119,8 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             bare_fn: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             stability: RefCell::new(FxHashSet()),\n-            layout: RefCell::new(FxHashSet())\n+            layout: RefCell::new(FxHashSet()),\n+            existential_predicates: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -958,6 +963,27 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n+    type Lifted = &'tcx Slice<ExistentialPredicate<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+        -> Option<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(Slice::empty());\n+        }\n+        if let Some(&Interned(eps)) = tcx.interners.existential_predicates.borrow().get(&self[..]) {\n+            if *self as *const _ == eps as *const _ {\n+                return Some(eps);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n     type Lifted = &'tcx BareFnTy<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -1126,7 +1152,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         sty_debug_print!(\n             self,\n             TyAdt, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1200,6 +1226,13 @@ impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n+    for Interned<'tcx, Slice<ExistentialPredicate<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1297,6 +1330,7 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n     type_list: _intern_type_list(Ty),\n     substs: _intern_substs(Kind)\n );\n@@ -1437,24 +1471,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyFnPtr(fty))\n     }\n \n-    pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n-        obj.projection_bounds.sort_by_key(|b| b.sort_key(self));\n-        self.mk_ty(TyTrait(box obj))\n+    pub fn mk_dynamic(\n+        self,\n+        obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n+        reg: &'tcx ty::Region\n+    ) -> Ty<'tcx> {\n+        self.mk_ty(TyDynamic(obj, reg))\n     }\n \n     pub fn mk_projection(self,\n                          trait_ref: TraitRef<'tcx>,\n                          item_name: Name)\n-                         -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n-        let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n-        self.mk_ty(TyProjection(inner))\n-    }\n+        -> Ty<'tcx> {\n+            // take a copy of substs so that we own the vectors inside\n+            let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+            self.mk_ty(TyProjection(inner))\n+        }\n \n     pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>)\n-                      -> Ty<'tcx> {\n+        -> Ty<'tcx> {\n         self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n             substs: substs\n         })\n@@ -1501,6 +1538,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyAnon(def_id, substs))\n     }\n \n+    pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n+        -> &'tcx Slice<ExistentialPredicate<'tcx>> {\n+        assert!(!eps.is_empty());\n+        assert!(eps.windows(2).all(|w| w[0].cmp(self, &w[1]) != Ordering::Greater));\n+        self._intern_existential_predicates(eps)\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx Slice<Ty<'tcx>> {\n         if ts.len() == 0 {\n             Slice::empty()\n@@ -1517,6 +1561,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n+                                     &'tcx Slice<ExistentialPredicate<'tcx>>>>(self, iter: I)\n+                                     -> I::Output {\n+        iter.intern_with(|xs| self.intern_existential_predicates(xs))\n+    }\n+\n     pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n                         &'tcx Slice<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))"}, {"sha": "125ee0a02c814a7f77c67d76ac6654e8014a0362", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -45,12 +45,12 @@ pub enum TypeError<'tcx> {\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n-    BuiltinBoundsMismatch(ExpectedFound<ty::BuiltinBounds>),\n     VariadicMismatch(ExpectedFound<bool>),\n     CyclicTy,\n     ProjectionNameMismatched(ExpectedFound<Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n+    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -135,19 +135,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                                        format!(\"trait `{}`\",\n                                                tcx.item_path_str(values.found)))\n             }),\n-            BuiltinBoundsMismatch(values) => {\n-                if values.expected.is_empty() {\n-                    write!(f, \"expected no bounds, found `{}`\",\n-                           values.found)\n-                } else if values.found.is_empty() {\n-                    write!(f, \"expected bounds `{}`, found no bounds\",\n-                           values.expected)\n-                } else {\n-                    write!(f, \"expected bounds `{}`, found bounds `{}`\",\n-                           values.expected,\n-                           values.found)\n-                }\n-            }\n             IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n                        values.expected,\n@@ -178,6 +165,10 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.expected.ty,\n                        values.found.ty)\n             }\n+            ExistentialMismatch(ref values) => {\n+                report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n+                                       format!(\"trait `{}`\", values.found))\n+            }\n         }\n     }\n }\n@@ -214,8 +205,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             }\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n-            ty::TyTrait(ref inner) => {\n-                format!(\"trait {}\", tcx.item_path_str(inner.principal.def_id()))\n+            ty::TyDynamic(ref inner, ..) => {\n+                inner.principal().map_or_else(|| \"trait\".to_string(),\n+                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),"}, {"sha": "ade6cad6866df43a84ecb6341f48cbfce3ad58af", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n+use middle::lang_items::OwnedBoxLangItem;\n \n use self::SimplifiedType::*;\n \n@@ -59,8 +60,8 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(ArraySimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n-        ty::TyTrait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n+        ty::TyDynamic(ref trait_info, ..) => {\n+            trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we\n@@ -70,10 +71,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         }\n         ty::TyBox(_) => {\n             // treat like we would treat `Box`\n-            match tcx.lang_items.require_owned_box() {\n-                Ok(def_id) => Some(AdtSimplifiedType(def_id)),\n-                Err(msg) => tcx.sess.fatal(&msg),\n-            }\n+            Some(AdtSimplifiedType(tcx.require_lang_item(OwnedBoxLangItem)))\n         }\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))"}, {"sha": "2bcbccb7d0505933e55f6dddfe4ed61fd60a144f", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -121,16 +121,21 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyTrait(ref obj) => {\n+            &ty::TyDynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(obj.principal.skip_binder().substs);\n-                for projection_bound in &obj.projection_bounds {\n-                    let mut proj_computation = FlagComputation::new();\n-                    proj_computation.add_existential_projection(&projection_bound.0);\n-                    self.add_bound_computation(&proj_computation);\n+                for predicate in obj.skip_binder().iter() {\n+                    match *predicate {\n+                        ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n+                        ty::ExistentialPredicate::Projection(p) => {\n+                            let mut proj_computation = FlagComputation::new();\n+                            proj_computation.add_existential_projection(&p);\n+                            self.add_bound_computation(&proj_computation);\n+                        }\n+                        ty::ExistentialPredicate::AutoTrait(_) => {}\n+                    }\n                 }\n                 self.add_bound_computation(&computation);\n-                self.add_region(obj.region_bound);\n+                self.add_region(r);\n             }\n \n             &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {"}, {"sha": "440a3916786fa3224fb25ecf8bc6a002d6fa8c77", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -316,7 +316,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n         ty::TyAdt(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyTrait(ref data) => Some(data.principal.def_id()),\n+        ty::TyDynamic(data, ..) => data.principal().map(|p| p.def_id()),\n \n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) |"}, {"sha": "8646bccf1e9ed75d91856385a5d2b7e3865f0ffe", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -924,7 +924,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         ty::TySlice(_) | ty::TyStr => {\n                             Int(dl.ptr_sized_integer())\n                         }\n-                        ty::TyTrait(_) => Pointer,\n+                        ty::TyDynamic(..) => Pointer,\n                         _ => return Err(LayoutError::Unknown(unsized_part))\n                     };\n                     FatPointer { metadata: meta, non_zero: non_zero }\n@@ -963,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     non_zero: false\n                 }\n             }\n-            ty::TyTrait(_) => {\n+            ty::TyDynamic(..) => {\n                 let mut unit = Struct::new(dl, false);\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }"}, {"sha": "534c21bb3096fbfc8fb676beb2e4851c21db4cd0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -53,9 +53,8 @@ use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{BuiltinBound, BuiltinBounds};\n pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n-pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n+pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n@@ -68,11 +67,6 @@ pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n \n-pub use self::sty::BuiltinBound::Send as BoundSend;\n-pub use self::sty::BuiltinBound::Sized as BoundSized;\n-pub use self::sty::BuiltinBound::Copy as BoundCopy;\n-pub use self::sty::BuiltinBound::Sync as BoundSync;\n-\n pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, tls};\n pub use self::context::{CtxtArenas, Lift, Tables};\n@@ -1718,7 +1712,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 vec![]\n             }\n \n-            TyStr | TyTrait(..) | TySlice(_) | TyError => {\n+            TyStr | TyDynamic(..) | TySlice(_) | TyError => {\n                 // these are never sized - return the target type\n                 vec![ty]\n             }\n@@ -1884,18 +1878,14 @@ pub enum ClosureKind {\n \n impl<'a, 'tcx> ClosureKind {\n     pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n-        let result = match *self {\n-            ClosureKind::Fn => tcx.lang_items.require(FnTraitLangItem),\n+        match *self {\n+            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n             ClosureKind::FnMut => {\n-                tcx.lang_items.require(FnMutTraitLangItem)\n+                tcx.require_lang_item(FnMutTraitLangItem)\n             }\n             ClosureKind::FnOnce => {\n-                tcx.lang_items.require(FnOnceTraitLangItem)\n+                tcx.require_lang_item(FnOnceTraitLangItem)\n             }\n-        };\n-        match result {\n-            Ok(trait_did) => trait_did,\n-            Err(err) => tcx.sess.fatal(&err[..]),\n         }\n     }\n "}, {"sha": "eb384eec6a6f1e3b583fcf5e0f355a023f0c6158", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::TyTuple(..) |       // ...\n             ty::TyFnDef(..) |       // OutlivesFunction (*)\n             ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-            ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::TyDynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n             ty::TyError => {\n                 // (*) Bare functions and traits are both binders. In the\n                 // RFC, this means we would add the bound regions to the"}, {"sha": "8cb1483107ff119d3e0b5018fef3db5157a5a49b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -302,23 +302,6 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::BuiltinBounds {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::BuiltinBounds,\n-                           b: &ty::BuiltinBounds)\n-                           -> RelateResult<'tcx, ty::BuiltinBounds>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-    {\n-        // Two sets of builtin bounds are only relatable if they are\n-        // precisely the same (but see the coercion code).\n-        if a != b {\n-            Err(TypeError::BuiltinBoundsMismatch(expected_found(relation, a, b)))\n-        } else {\n-            Ok(*a)\n-        }\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::TraitRef<'tcx>,\n@@ -415,23 +398,15 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_adt(a_def, substs))\n         }\n \n-        (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n-        {\n-            let principal = relation.relate(&a_obj.principal, &b_obj.principal)?;\n-            let r =\n-                relation.with_cause(\n-                    Cause::ExistentialRegionBound,\n-                    |relation| relation.relate_with_variance(ty::Contravariant,\n-                                                             &a_obj.region_bound,\n-                                                             &b_obj.region_bound))?;\n-            let nb = relation.relate(&a_obj.builtin_bounds, &b_obj.builtin_bounds)?;\n-            let pb = relation.relate(&a_obj.projection_bounds, &b_obj.projection_bounds)?;\n-            Ok(tcx.mk_trait(ty::TraitObject {\n-                principal: principal,\n-                region_bound: r,\n-                builtin_bounds: nb,\n-                projection_bounds: pb\n-            }))\n+        (&ty::TyDynamic(ref a_obj, ref a_region), &ty::TyDynamic(ref b_obj, ref b_region)) => {\n+            let region_bound = relation.with_cause(Cause::ExistentialRegionBound,\n+                                                       |relation| {\n+                                                           relation.relate_with_variance(\n+                                                               ty::Contravariant,\n+                                                               a_region,\n+                                                               b_region)\n+                                                       })?;\n+            Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n         (&ty::TyClosure(a_id, a_substs),\n@@ -527,6 +502,31 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Self,\n+                           b: &Self)\n+        -> RelateResult<'tcx, Self>\n+            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+\n+        if a.len() != b.len() {\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n+        }\n+\n+        let tcx = relation.tcx();\n+        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n+            use ty::ExistentialPredicate::*;\n+            match (*ep_a, *ep_b) {\n+                (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n+                (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n+                (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)))\n+            }\n+        });\n+        Ok(tcx.mk_existential_predicates(v)?)\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::ClosureSubsts<'tcx>,"}, {"sha": "88de3575274cc4a8ea22ea69e49f1e275c48238a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -315,7 +315,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n-            BuiltinBoundsMismatch(x) => BuiltinBoundsMismatch(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy => CyclicTy,\n             ProjectionNameMismatched(x) => ProjectionNameMismatched(x),\n@@ -325,6 +324,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             TyParamDefaultMismatch(ref x) => {\n                 return tcx.lift(x).map(TyParamDefaultMismatch)\n             }\n+            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n         })\n     }\n }\n@@ -427,20 +427,33 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitObject {\n-            principal: self.principal.fold_with(folder),\n-            region_bound: self.region_bound.fold_with(folder),\n-            builtin_bounds: self.builtin_bounds,\n-            projection_bounds: self.projection_bounds.fold_with(folder),\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_existential_predicates(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self  {\n+        use ty::ExistentialPredicate::*;\n+        match *self {\n+            Trait(ref tr) => Trait(tr.fold_with(folder)),\n+            Projection(ref p) => Projection(p.fold_with(folder)),\n+            AutoTrait(did) => AutoTrait(did),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.principal.visit_with(visitor) ||\n-        self.region_bound.visit_with(visitor) ||\n-        self.projection_bounds.visit_with(visitor)\n+        match *self {\n+            ty::ExistentialPredicate::Trait(ref tr) => tr.visit_with(visitor),\n+            ty::ExistentialPredicate::Projection(ref p) => p.visit_with(visitor),\n+            ty::ExistentialPredicate::AutoTrait(_) => false,\n+        }\n     }\n }\n \n@@ -463,7 +476,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n             ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n-            ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n+            ty::TyDynamic(ref trait_ty, ref region) =>\n+                ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n             ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n             ty::TyFnDef(def_id, substs, f) => {\n                 ty::TyFnDef(def_id,\n@@ -500,7 +514,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyAdt(_, substs) => substs.visit_with(visitor),\n-            ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n+            ty::TyDynamic(ref trait_ty, ref reg) =>\n+                trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n@@ -703,16 +718,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeParameterDef {"}, {"sha": "667db5b673054e437330923fb54077e4222af13f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 146, "deletions": 105, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -14,13 +14,13 @@ use hir::def_id::DefId;\n \n use middle::region;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n-use util::common::ErrorReported;\n+use ty::subst::Kind;\n \n-use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::ops;\n+use std::iter;\n+use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::symbol::{keywords, InternedString};\n@@ -147,7 +147,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(&'tcx BareFnTy<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyTrait(Box<TraitObject<'tcx>>),\n+    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, &'tcx ty::Region),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -275,12 +275,104 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct TraitObject<'tcx> {\n-    pub principal: PolyExistentialTraitRef<'tcx>,\n-    pub region_bound: &'tcx ty::Region,\n-    pub builtin_bounds: BuiltinBounds,\n-    pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum ExistentialPredicate<'tcx> {\n+    // e.g. Iterator\n+    Trait(ExistentialTraitRef<'tcx>),\n+    // e.g. Iterator::Item = T\n+    Projection(ExistentialProjection<'tcx>),\n+    // e.g. Send\n+    AutoTrait(DefId),\n+}\n+\n+impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n+    pub fn cmp(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, other: &Self) -> Ordering {\n+        use self::ExistentialPredicate::*;\n+        match (*self, *other) {\n+            (Trait(_), Trait(_)) => Ordering::Equal,\n+            (Projection(ref a), Projection(ref b)) => a.sort_key(tcx).cmp(&b.sort_key(tcx)),\n+            (AutoTrait(ref a), AutoTrait(ref b)) =>\n+                tcx.lookup_trait_def(*a).def_path_hash.cmp(&tcx.lookup_trait_def(*b).def_path_hash),\n+            (Trait(_), _) => Ordering::Less,\n+            (Projection(_), Trait(_)) => Ordering::Greater,\n+            (Projection(_), _) => Ordering::Less,\n+            (AutoTrait(_), _) => Ordering::Greater,\n+        }\n+    }\n+\n+}\n+\n+impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::Predicate<'tcx> {\n+        use ty::ToPredicate;\n+        match *self.skip_binder() {\n+            ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n+            ExistentialPredicate::Projection(p) =>\n+                ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty))),\n+            ExistentialPredicate::AutoTrait(did) => {\n+                let trait_ref = Binder(ty::TraitRef {\n+                    def_id: did,\n+                    substs: tcx.mk_substs_trait(self_ty, &[]),\n+                });\n+                trait_ref.to_predicate()\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<ExistentialPredicate<'tcx>> {}\n+\n+impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n+    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n+        match self.get(0) {\n+            Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n+            _ => None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn projection_bounds<'a>(&'a self) ->\n+        impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            match *predicate {\n+                ExistentialPredicate::Projection(p) => Some(p),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            match *predicate {\n+                ExistentialPredicate::AutoTrait(d) => Some(d),\n+                _ => None\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+    pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n+        self.skip_binder().principal().map(Binder)\n+    }\n+\n+    #[inline]\n+    pub fn projection_bounds<'a>(&'a self) ->\n+        impl Iterator<Item=PolyExistentialProjection<'tcx>> + 'a {\n+        self.skip_binder().projection_bounds().map(Binder)\n+    }\n+\n+    #[inline]\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+        self.skip_binder().auto_traits()\n+    }\n+\n+    pub fn iter<'a>(&'a self)\n+        -> impl DoubleEndedIterator<Item=Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n+        self.skip_binder().iter().cloned().map(Binder)\n+    }\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n@@ -344,14 +436,30 @@ pub struct ExistentialTraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n+    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'b {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n         self.substs.types()\n     }\n+\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::TraitRef<'tcx>  {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: tcx.mk_substs(\n+                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned()))\n+        }\n+    }\n }\n \n pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n@@ -713,122 +821,53 @@ pub struct ExistentialProjection<'tcx> {\n \n pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n \n-impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n     pub fn item_name(&self) -> Name {\n-        self.0.item_name // safe to skip the binder to access a name\n+        self.item_name // safe to skip the binder to access a name\n     }\n \n     pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n         // We want something here that is stable across crate boundaries.\n         // The DefId isn't but the `deterministic_hash` of the corresponding\n         // DefPath is.\n-        let trait_def = tcx.lookup_trait_def(self.0.trait_ref.def_id);\n+        let trait_def = tcx.lookup_trait_def(self.trait_ref.def_id);\n         let def_path_hash = trait_def.def_path_hash;\n \n         // An `ast::Name` is also not stable (it's just an index into an\n         // interning table), so map to the corresponding `InternedString`.\n-        let item_name = self.0.item_name.as_str();\n+        let item_name = self.item_name.as_str();\n         (def_path_hash, item_name)\n     }\n \n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         self_ty: Ty<'tcx>)\n-                        -> ty::PolyProjectionPredicate<'tcx>\n+                        -> ty::ProjectionPredicate<'tcx>\n     {\n         // otherwise the escaping regions would be captured by the binders\n         assert!(!self_ty.has_escaping_regions());\n \n-        let trait_ref = self.map_bound(|proj| proj.trait_ref);\n-        self.map_bound(|proj| ty::ProjectionPredicate {\n+        ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {\n-                trait_ref: trait_ref.with_self_ty(tcx, self_ty).0,\n-                item_name: proj.item_name\n+                trait_ref: self.trait_ref.with_self_ty(tcx, self_ty),\n+                item_name: self.item_name\n             },\n-            ty: proj.ty\n-        })\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n-\n-impl<'a, 'gcx, 'tcx> BuiltinBounds {\n-    pub fn empty() -> BuiltinBounds {\n-        BuiltinBounds(EnumSet::new())\n-    }\n-\n-    pub fn iter(&self) -> enum_set::Iter<BuiltinBound> {\n-        self.into_iter()\n-    }\n-\n-    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         self_ty: Ty<'tcx>)\n-                         -> Vec<ty::Predicate<'tcx>> {\n-        self.iter().filter_map(|builtin_bound|\n-            match tcx.trait_ref_for_builtin_bound(builtin_bound, self_ty) {\n-                Ok(trait_ref) => Some(trait_ref.to_predicate()),\n-                Err(ErrorReported) => { None }\n-            }\n-        ).collect()\n+            ty: self.ty\n+        }\n     }\n }\n \n-impl ops::Deref for BuiltinBounds {\n-    type Target = EnumSet<BuiltinBound>;\n-    fn deref(&self) -> &Self::Target { &self.0 }\n-}\n-\n-impl ops::DerefMut for BuiltinBounds {\n-    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.0 }\n-}\n-\n-impl<'a> IntoIterator for &'a BuiltinBounds {\n-    type Item = BuiltinBound;\n-    type IntoIter = enum_set::Iter<BuiltinBound>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        (**self).into_iter()\n+impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+    pub fn item_name(&self) -> Name {\n+        self.skip_binder().item_name()\n     }\n-}\n-\n-#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n-           Debug, Copy)]\n-pub enum BuiltinBound {\n-    Send = 0,\n-    Sized = 1,\n-    Copy = 2,\n-    Sync = 3,\n-}\n \n-impl CLike for BuiltinBound {\n-    fn to_usize(&self) -> usize {\n-        *self as usize\n-    }\n-    fn from_usize(v: usize) -> BuiltinBound {\n-        match v {\n-            0 => BuiltinBound::Send,\n-            1 => BuiltinBound::Sized,\n-            2 => BuiltinBound::Copy,\n-            3 => BuiltinBound::Sync,\n-            _ => bug!(\"{} is not a valid BuiltinBound\", v)\n-        }\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+        self.skip_binder().sort_key(tcx)\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn try_add_builtin_trait(self,\n-                                 trait_def_id: DefId,\n-                                 builtin_bounds: &mut EnumSet<BuiltinBound>)\n-                                 -> bool\n-    {\n-        //! Checks whether `trait_ref` refers to one of the builtin\n-        //! traits, like `Send`, and adds the corresponding\n-        //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n-        //! is a builtin trait.\n-\n-        match self.lang_items.to_builtin_kind(trait_def_id) {\n-            Some(bound) => { builtin_bounds.insert(bound); true }\n-            None => false\n-        }\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::PolyProjectionPredicate<'tcx> {\n+        self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n }\n \n@@ -1088,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_trait(&self) -> bool {\n         match self.sty {\n-            TyTrait(..) => true,\n+            TyDynamic(..) => true,\n             _ => false\n         }\n     }\n@@ -1221,7 +1260,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n-            TyTrait(ref tt) => Some(tt.principal.def_id()),\n+            TyDynamic(ref tt, ..) => tt.principal().map(|p| p.def_id()),\n             TyAdt(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n@@ -1243,9 +1282,11 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyRef(region, _) => {\n                 vec![region]\n             }\n-            TyTrait(ref obj) => {\n-                let mut v = vec![obj.region_bound];\n-                v.extend(obj.principal.skip_binder().substs.regions());\n+            TyDynamic(ref obj, region) => {\n+                let mut v = vec![region];\n+                if let Some(p) = obj.principal() {\n+                    v.extend(p.skip_binder().substs.regions());\n+                }\n                 v\n             }\n             TyAdt(_, substs) | TyAnon(_, substs) => {"}, {"sha": "6ba4b8d2da77b8d9c2f40f787b80d4a2807de61d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -21,6 +21,7 @@ use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::nodemap::FxHashMap;\n+use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n@@ -531,9 +532,13 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 self.hash(f.sig.variadic());\n                 self.hash(f.sig.inputs().skip_binder().len());\n             }\n-            TyTrait(ref data) => {\n-                self.def_id(data.principal.def_id());\n-                self.hash(data.builtin_bounds);\n+            TyDynamic(ref data, ..) => {\n+                if let Some(p) = data.principal() {\n+                    self.def_id(p.def_id());\n+                }\n+                for d in data.auto_traits() {\n+                    self.def_id(d);\n+                }\n             }\n             TyTuple(tys) => {\n                 self.hash(tys.len());\n@@ -595,7 +600,7 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: &ParameterEnvironment<'tcx>,\n-                   bound: ty::BuiltinBound,\n+                   def_id: DefId,\n                    cache: &RefCell<FxHashMap<Ty<'tcx>, bool>>,\n                    span: Span) -> bool\n     {\n@@ -607,7 +612,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         let result =\n             tcx.infer_ctxt(None, Some(param_env.clone()), Reveal::ExactMatch)\n             .enter(|infcx| {\n-                traits::type_known_to_meet_builtin_bound(&infcx, self, bound, span)\n+                traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n             });\n         if self.has_param_types() || self.has_self_ty() {\n             cache.borrow_mut().insert(self, result);\n@@ -636,12 +641,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n-            TyArray(..) | TySlice(..) | TyTrait(..) | TyTuple(..) |\n+            TyArray(..) | TySlice(..) | TyDynamic(..) | TyTuple(..) |\n             TyClosure(..) | TyAdt(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| {\n-            !self.impls_bound(tcx, param_env, ty::BoundCopy, &param_env.is_copy_cache, span)\n-        });\n+            !self.impls_bound(tcx, param_env,\n+                              tcx.require_lang_item(lang_items::CopyTraitLangItem),\n+                              &param_env.is_copy_cache, span) });\n \n         if !self.has_param_types() && !self.has_self_ty() {\n             self.flags.set(self.flags.get() | if result {\n@@ -677,13 +683,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyTuple(..) | TyClosure(..) | TyNever => Some(true),\n \n-            TyStr | TyTrait(..) | TySlice(_) => Some(false),\n+            TyStr | TyDynamic(..) | TySlice(_) => Some(false),\n \n             TyAdt(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| {\n-            self.impls_bound(tcx, param_env, ty::BoundSized, &param_env.is_sized_cache, span)\n-        });\n+            self.impls_bound(tcx, param_env, tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                              &param_env.is_sized_cache, span) });\n \n         if !self.has_param_types() && !self.has_self_ty() {\n             self.flags.set(self.flags.get() | if result {"}, {"sha": "0848dcd2c8d213ec4f37bf3e930e2aee6b50cba4", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -92,11 +92,19 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyProjection(ref data) => {\n             stack.extend(data.trait_ref.substs.types().rev());\n         }\n-        ty::TyTrait(ref obj) => {\n-            stack.extend(obj.principal.input_types().rev());\n-            stack.extend(obj.projection_bounds.iter().map(|pred| {\n-                pred.0.ty\n-            }).rev());\n+        ty::TyDynamic(ref obj, ..) => {\n+            stack.extend(obj.iter().rev().flat_map(|predicate| {\n+                let (substs, opt_ty) = match *predicate.skip_binder() {\n+                    ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n+                    ty::ExistentialPredicate::Projection(p) =>\n+                        (p.trait_ref.substs, Some(p.ty)),\n+                    ty::ExistentialPredicate::AutoTrait(_) =>\n+                        // Empty iterator\n+                        (ty::Substs::empty(), None),\n+                };\n+\n+                substs.types().rev().chain(opt_ty)\n+            }));\n         }\n         ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n             stack.extend(substs.types().rev());"}, {"sha": "bab9964651dcacb4a1d48ff90e975542e9b5a26e", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -17,7 +17,7 @@ use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n use syntax::ast;\n use syntax_pos::Span;\n-use util::common::ErrorReported;\n+use middle::lang_items;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -282,14 +282,11 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n-            match self.infcx.tcx.trait_ref_for_builtin_bound(ty::BoundSized, subty) {\n-                Ok(trait_ref) => {\n-                    self.out.push(\n-                        traits::Obligation::new(cause,\n-                                                trait_ref.to_predicate()));\n-                }\n-                Err(ErrorReported) => { }\n-            }\n+            let trait_ref = ty::TraitRef {\n+                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n+            };\n+            self.out.push(traits::Obligation::new(cause, trait_ref.to_predicate()));\n         }\n     }\n \n@@ -298,7 +295,6 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n-        let tcx = self.infcx.tcx;\n         let mut subtys = ty0.walk();\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n@@ -377,12 +373,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // of whatever returned this exact `impl Trait`.\n                 }\n \n-                ty::TyTrait(ref data) => {\n+                ty::TyDynamic(data, r) => {\n                     // WfObject\n                     //\n                     // Here, we defer WF checking due to higher-ranked\n                     // regions. This is perhaps not ideal.\n-                    self.from_object_ty(ty, data);\n+                    self.from_object_ty(ty, data, r);\n \n                     // FIXME(#27579) RFC also considers adding trait\n                     // obligations that don't refer to Self and\n@@ -391,15 +387,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     let cause = self.cause(traits::MiscObligation);\n \n                     let component_traits =\n-                        data.builtin_bounds.iter().flat_map(|bound| {\n-                            tcx.lang_items.from_builtin_kind(bound).ok()\n-                        })\n-                        .chain(Some(data.principal.def_id()));\n+                        data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                     self.out.extend(\n-                        component_traits.map(|did| { traits::Obligation::new(\n+                        component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),\n                             ty::Predicate::ObjectSafe(did)\n-                        )})\n+                        ))\n                     );\n                 }\n \n@@ -456,7 +449,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .collect()\n     }\n \n-    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitObject<'tcx>) {\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>,\n+                      data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+                      region: &'tcx ty::Region) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -491,11 +486,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         if !data.has_escaping_regions() {\n             let implicit_bounds =\n-                object_region_bounds(self.infcx.tcx,\n-                                     data.principal,\n-                                     data.builtin_bounds);\n+                object_region_bounds(self.infcx.tcx, data);\n \n-            let explicit_bound = data.region_bound;\n+            let explicit_bound = region;\n \n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n@@ -514,17 +507,21 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    principal: ty::PolyExistentialTraitRef<'tcx>,\n-    others: ty::BuiltinBounds)\n+    existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n     -> Vec<&'tcx ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n-    let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.push(principal.with_self_ty(tcx, open_ty).to_predicate());\n+    let predicates = existential_predicates.iter().filter_map(|predicate| {\n+        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+            None\n+        } else {\n+            Some(predicate.with_self_ty(tcx, open_ty))\n+        }\n+    }).collect();\n \n     tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "d839df80a12acc25d4fd9630c64e1b187276b4f8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 33, "deletions": 111, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -16,9 +16,8 @@ use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyProjection, TyAnon};\n-use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n+use ty::{TyBox, TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -298,74 +297,31 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n     write!(f, \"{}\", new_value)\n }\n \n-/// This curious type is here to help pretty-print trait objects. In\n-/// a trait object, the projections are stored separately from the\n-/// main trait bound, but in fact we want to package them together\n-/// when printing out; they also have separate binders, but we want\n-/// them to share a binder when we print them out. (And the binder\n-/// pretty-printing logic is kind of clever and we don't want to\n-/// reproduce it.) So we just repackage up the structure somewhat.\n-///\n-/// Right now there is only one trait in an object that can have\n-/// projection bounds, so we just stuff them altogether. But in\n-/// reality we should eventually sort things out better.\n-#[derive(Clone, Debug)]\n-struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>,\n-                                 Vec<ty::ProjectionPredicate<'tcx>>);\n-\n-impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n-        parameterized(f, trait_ref.substs,\n-                      trait_ref.def_id,\n-                      projection_bounds)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n+impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Generate the main trait ref, including associated types.\n         ty::tls::with(|tcx| {\n             // Use a type that can't appear in defaults of type parameters.\n             let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n \n-            let principal = tcx.lift(&self.principal)\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            let projections = self.projection_bounds.iter().map(|p| {\n-                tcx.lift(p)\n-                    .expect(\"could not lift projection for printing\")\n-                    .with_self_ty(tcx, dummy_self).0\n-            }).collect();\n-\n-            let tap = ty::Binder(TraitAndProjections(principal, projections));\n-            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n-        })?;\n+            if let Some(p) = self.principal() {\n+                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                    .with_self_ty(tcx, dummy_self);\n+                let projections = self.projection_bounds().map(|p| {\n+                    tcx.lift(&p)\n+                        .expect(\"could not lift projection for printing\")\n+                        .with_self_ty(tcx, dummy_self)\n+                }).collect::<Vec<_>>();\n+                parameterized(f, principal.substs, principal.def_id, &projections)?;\n+            }\n \n-        // Builtin bounds.\n-        for bound in &self.builtin_bounds {\n-            write!(f, \" + {:?}\", bound)?;\n-        }\n+            // Builtin bounds.\n+            for did in self.auto_traits() {\n+                write!(f, \" + {}\", tcx.item_path_str(did))?;\n+            }\n \n-        // FIXME: It'd be nice to compute from context when this bound\n-        // is implied, but that's non-trivial -- we'd perhaps have to\n-        // use thread-local data of some kind? There are also\n-        // advantages to just showing the region, since it makes\n-        // people aware that it's there.\n-        let bound = self.region_bound.to_string();\n-        if !bound.is_empty() {\n-            write!(f, \" + {}\", bound)?;\n-        }\n+            Ok(())\n+        })?;\n \n         Ok(())\n     }\n@@ -453,41 +409,6 @@ impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitObject<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut empty = true;\n-        let mut maybe_continue = |f: &mut fmt::Formatter| {\n-            if empty {\n-                empty = false;\n-                Ok(())\n-            } else {\n-                write!(f, \" + \")\n-            }\n-        };\n-\n-        maybe_continue(f)?;\n-        write!(f, \"{:?}\", self.principal)?;\n-\n-        let region_str = format!(\"{:?}\", self.region_bound);\n-        if !region_str.is_empty() {\n-            maybe_continue(f)?;\n-            write!(f, \"{}\", region_str)?;\n-        }\n-\n-        for bound in &self.builtin_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", bound)?;\n-        }\n-\n-        for projection_bound in &self.projection_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", projection_bound)?;\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -677,19 +598,6 @@ impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     }\n }\n \n-impl fmt::Display for ty::BuiltinBounds {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut bounds = self.iter();\n-        if let Some(bound) = bounds.next() {\n-            write!(f, \"{:?}\", bound)?;\n-            for bound in bounds {\n-                write!(f, \" + {:?}\", bound)?;\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n impl fmt::Debug for ty::TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}t\", self.index)\n@@ -753,6 +661,12 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n+impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n@@ -872,7 +786,15 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     }\n                 })\n             }\n-            TyTrait(ref data) => write!(f, \"{}\", data),\n+            TyDynamic(data, r) => {\n+                write!(f, \"{}\", data)?;\n+                let r = r.to_string();\n+                if !r.is_empty() {\n+                    write!(f, \" + {}\", r)\n+                } else {\n+                    Ok(())\n+                }\n+            }\n             TyProjection(ref data) => write!(f, \"{}\", data),\n             TyAnon(def_id, substs) => {\n                 ty::tls::with(|tcx| {"}, {"sha": "49ef5dd7a1725235e2a2fac97171e8c9f6de0304", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -857,8 +857,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         let tcx = self.tcx;\n         let unit_temp = Lvalue::Local(self.patch.new_temp(tcx.mk_nil()));\n-        let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n-            .unwrap_or_else(|e| tcx.sess.fatal(&e));\n+        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n         let fty = tcx.item_type(free_func).subst(tcx, substs);\n "}, {"sha": "6e9467d63dd1f84d43158ca7f4fc1f71a234ec36", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -572,7 +572,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                            consider using a raw pointer instead\")\n             }\n \n-            ty::TyTrait(..) => {\n+            ty::TyDynamic(..) => {\n                 FfiUnsafe(\"found Rust trait type in foreign module, \\\n                            consider using a raw pointer instead\")\n             }"}, {"sha": "31ea24275559960a1410a5021f7ab50d3b2c0fa2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -416,6 +416,15 @@ impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx>\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n+    for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self)\n+        -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n+        Ok(self.tcx().mk_existential_predicates((0..self.read_usize()?)\n+                                                .map(|_| Decodable::decode(self)))?)\n+    }\n+}\n+\n impl<'a, 'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)"}, {"sha": "c02a1822d736961e39f3b894db8a097664245f76", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -783,8 +783,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               data: &FreeData<'tcx>,\n                               target: BasicBlock)\n                               -> TerminatorKind<'tcx> {\n-    let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n-                       .unwrap_or_else(|e| tcx.sess.fatal(&e));\n+    let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n     let substs = tcx.intern_substs(&[Kind::from(data.item_ty)]);\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {"}, {"sha": "893478a933182988d45c69552d0f65f412024290", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -28,6 +28,7 @@ use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::util::nodemap::DefIdMap;\n+use rustc::middle::lang_items;\n use syntax::abi::Abi;\n use syntax::feature_gate::UnstableFeatures;\n use syntax_pos::Span;\n@@ -1040,7 +1041,9 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n             tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                fulfillment_cx.register_bound(&infcx, ty,\n+                                              tcx.require_lang_item(lang_items::SyncTraitLangItem),\n+                                              cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n                     infcx.report_fulfillment_errors(&err);\n                 }"}, {"sha": "4020c45f59e1a963588b0a5c1bb9d777d2b9d39a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -71,7 +71,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n         let ty_def_id = match self.tcx.item_type(item_def_id).sty {\n             ty::TyAdt(adt, _) => adt.did,\n-            ty::TyTrait(ref obj) => obj.principal.def_id(),\n+            ty::TyDynamic(ref obj, ..) if obj.principal().is_some() =>\n+                obj.principal().unwrap().def_id(),\n             ty::TyProjection(ref proj) => proj.trait_ref.def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n@@ -359,7 +360,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n             ty::TyAdt(adt, _) => Some(adt.did),\n-            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n             ty::TyFnDef(def_id, ..) |\n             ty::TyAnon(def_id, _) => Some(def_id),\n@@ -938,7 +939,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n             ty::TyAdt(adt, _) => Some(adt.did),\n-            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => {\n                 if self.required_visibility == ty::Visibility::PrivateExternal {\n                     // Conservatively approximate the whole type alias as public without"}, {"sha": "f1126e6fd256c033d31f4c5256e48bc04c3b402f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -295,16 +295,14 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n-        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n+        (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::TyTrait(ref data)) => {\n-            let trait_ref = data.principal.with_self_ty(ccx.tcx(), source);\n-            let trait_ref = ccx.tcx().erase_regions(&trait_ref);\n-            consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n+        (_, &ty::TyDynamic(ref data, ..)) => {\n+            consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n                             Type::vtable_ptr(ccx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\","}, {"sha": "120e1a562ebea80be0bf135dd4bc07b9eaac2740", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -763,7 +763,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyFnDef(..) |\n         ty::TyFnPtr(_)  |\n         ty::TyNever     |\n-        ty::TyTrait(_)  => {\n+        ty::TyDynamic(..)  => {\n             /* nothing to do */\n         }\n         ty::TyAdt(adt_def, substs) => {\n@@ -1003,18 +1003,20 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n     assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n \n-    if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal.with_self_ty(scx.tcx(), impl_ty);\n-        let param_substs = scx.tcx().intern_substs(&[]);\n-\n-        // Walk all methods of the trait, including those of its supertraits\n-        let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n-        let methods = methods.filter_map(|method| method)\n-            .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs, param_substs))\n-            .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n-            .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n-        output.extend(methods);\n-\n+    if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n+        if let Some(principal) = trait_ty.principal() {\n+            let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n+            let param_substs = scx.tcx().intern_substs(&[]);\n+\n+            // Walk all methods of the trait, including those of its supertraits\n+            let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n+            let methods = methods.filter_map(|method| method)\n+                .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs,\n+                                                                  param_substs))\n+                .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+                .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n+            output.extend(methods);\n+        }\n         // Also add the destructor\n         let dg_type = glue::get_drop_glue_type(scx.tcx(), impl_ty);\n         output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));"}, {"sha": "c0d7c64bd192c8713e422040360ea6a50387346d", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -95,7 +95,8 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n+    vtables: RefCell<FxHashMap<(ty::Ty<'tcx>,\n+                                Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n@@ -800,7 +801,9 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().instances\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n+    pub fn vtables<'a>(&'a self)\n+        -> &'a RefCell<FxHashMap<(ty::Ty<'tcx>,\n+                                  Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>> {\n         &self.local().vtables\n     }\n "}, {"sha": "8bbe50af0651c6f4f7357266fb453a74f09ff784", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -431,8 +431,13 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n-    let def_id = match trait_type.sty {\n-        ty::TyTrait(ref data) => data.principal.def_id(),\n+    let containing_scope = match trait_type.sty {\n+        ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n+            let def_id = principal.def_id();\n+            get_namespace_and_span_for_item(cx, def_id).0\n+        } else {\n+            NO_SCOPE_METADATA\n+        },\n         _ => {\n             bug!(\"debuginfo: Unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\",\n@@ -444,8 +449,6 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let trait_type_name =\n         compute_debuginfo_type_name(cx, trait_object_type, false);\n \n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n-\n     let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n     let file_metadata = unknown_file_metadata(cx);\n \n@@ -520,7 +523,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyStr => {\n             fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n         }\n-        ty::TyTrait(..) => {\n+        ty::TyDynamic(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n@@ -535,7 +538,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 ty::TyStr => {\n                     vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n                 }\n-                ty::TyTrait(..) => {\n+                ty::TyDynamic(..) => {\n                     MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                         false)"}, {"sha": "80e6bd7aa29840528f16526205f4716a0d36cbad", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -93,11 +93,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_debuginfo_type_name(cx, inner_type, true, output);\n             output.push(']');\n         },\n-        ty::TyTrait(ref trait_data) => {\n-            let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n-                &trait_data.principal);\n-            push_item_name(cx, principal.def_id, false, output);\n-            push_type_params(cx, principal.substs, output);\n+        ty::TyDynamic(ref trait_data, ..) => {\n+            if let Some(principal) = trait_data.principal() {\n+                let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n+                    &principal);\n+                push_item_name(cx, principal.def_id, false, output);\n+                push_type_params(cx, principal.substs, output);\n+            }\n         },\n         ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n         ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {"}, {"sha": "06d0b1e19828e4f912fdc0e4b6f780a996d5ec3e", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -394,7 +394,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n             (size, align)\n         }\n-        ty::TyTrait(..) => {\n+        ty::TyDynamic(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n             let info = bcx.pointercast(info, Type::int(bcx.ccx()).ptr_to());\n@@ -463,7 +463,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n             }\n         }\n-        ty::TyTrait(..) => {\n+        ty::TyDynamic(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any."}, {"sha": "aa9b900fa465396573edae7f1f02801a0de67667", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -110,42 +110,48 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            ty: ty::Ty<'tcx>,\n+                            trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n                             -> ValueRef\n {\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n+    debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n \n     // Check the cache.\n-    if let Some(&val) = ccx.vtables().borrow().get(&trait_ref) {\n+    if let Some(&val) = ccx.vtables().borrow().get(&(ty, trait_ref)) {\n         return val;\n     }\n \n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n-    let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n-        opt_mth.map_or(nullptr, |(def_id, substs)| {\n-            Callee::def(ccx, def_id, substs).reify(ccx)\n-        })\n-    });\n \n-    let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n+    let size_ty = sizing_type_of(ccx, ty);\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let align = align_of(ccx, trait_ref.self_ty());\n+    let align = align_of(ccx, ty);\n \n-    let components: Vec<_> = [\n+    let mut components: Vec<_> = [\n         // Generate a destructor for the vtable.\n-        glue::get_drop_glue(ccx, trait_ref.self_ty()),\n+        glue::get_drop_glue(ccx, ty),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n-    ].iter().cloned().chain(methods).collect();\n+    ].iter().cloned().collect();\n+\n+    if let Some(trait_ref) = trait_ref {\n+        let trait_ref = trait_ref.with_self_ty(tcx, ty);\n+        let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n+            opt_mth.map_or(nullptr, |(def_id, substs)| {\n+                Callee::def(ccx, def_id, substs).reify(ccx)\n+            })\n+        });\n+        components.extend(methods);\n+    }\n \n     let vtable_const = C_struct(ccx, &components, false);\n     let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n     let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n \n-    ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n+    ccx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "322c5eb6e182a135c7397849b0c645cb9930517f", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -36,6 +36,7 @@ use glue;\n use abi::{Abi, FnType};\n use back::symbol_names;\n use std::fmt::Write;\n+use std::iter;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n@@ -410,7 +411,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n             ty::TyAdt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n-                self.push_type_params(substs, &[], output);\n+                self.push_type_params(substs, iter::empty(), output);\n             },\n             ty::TyTuple(component_types) => {\n                 output.push('(');\n@@ -457,11 +458,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 self.push_type_name(inner_type, output);\n                 output.push(']');\n             },\n-            ty::TyTrait(ref trait_data) => {\n-                self.push_def_path(trait_data.principal.def_id(), output);\n-                self.push_type_params(trait_data.principal.skip_binder().substs,\n-                                      &trait_data.projection_bounds,\n-                                      output);\n+            ty::TyDynamic(ref trait_data, ..) => {\n+                if let Some(principal) = trait_data.principal() {\n+                    self.push_def_path(principal.def_id(), output);\n+                    self.push_type_params(principal.skip_binder().substs,\n+                        trait_data.projection_bounds(),\n+                        output);\n+                }\n             },\n             ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n             ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -511,7 +514,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.item_generics(self.tcx.closure_base_def_id(def_id));\n                 let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n-                self.push_type_params(substs, &[], output);\n+                self.push_type_params(substs, iter::empty(), output);\n             }\n             ty::TyError |\n             ty::TyInfer(_) |\n@@ -551,11 +554,14 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n         output.pop();\n     }\n \n-    pub fn push_type_params(&self,\n+    fn push_type_params<I>(&self,\n                             substs: &Substs<'tcx>,\n-                            projections: &[ty::PolyExistentialProjection<'tcx>],\n-                            output: &mut String) {\n-        if substs.types().next().is_none() && projections.is_empty() {\n+                            projections: I,\n+                            output: &mut String)\n+        where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>>\n+    {\n+        let mut projections = projections.peekable();\n+        if substs.types().next().is_none() && projections.peek().is_none() {\n             return;\n         }\n \n@@ -585,6 +591,6 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                                    instance: Instance<'tcx>,\n                                    output: &mut String) {\n         self.push_def_path(instance.def, output);\n-        self.push_type_params(instance.substs, &[], output);\n+        self.push_type_params(instance.substs, iter::empty(), output);\n     }\n }"}, {"sha": "22c405fe254a62c400d818d54e51de617f67c405", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -95,7 +95,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyAnon(..) | ty::TyError => {\n             bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n         }\n-        ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => bug!()\n+        ty::TySlice(_) | ty::TyDynamic(..) | ty::TyStr => bug!()\n     };\n \n     debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n@@ -148,7 +148,7 @@ fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type\n         ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n             Type::uint_from_ty(ccx, ast::UintTy::Us)\n         }\n-        ty::TyTrait(_) => Type::vtable_ptr(ccx),\n+        ty::TyDynamic(..) => Type::vtable_ptr(ccx),\n         _ => bug!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n                           unsized_part, ty)\n     }\n@@ -258,7 +258,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       // fat pointers is of the right type (e.g. for array accesses), even\n       // when taking the address of an unsized field in a struct.\n       ty::TySlice(ty) => in_memory_type_of(cx, ty),\n-      ty::TyStr | ty::TyTrait(..) => Type::i8(cx),\n+      ty::TyStr | ty::TyDynamic(..) => Type::i8(cx),\n \n       ty::TyFnDef(..) => Type::nil(cx),\n       ty::TyFnPtr(f) => {"}, {"sha": "9f3887a87686acd8f730cfda6cb23719100ec51f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 106, "deletions": 84, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -49,6 +49,7 @@\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use rustc_const_eval::eval_length;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir::{self, SelfKind};\n use hir::def::Def;\n use hir::def_id::DefId;\n@@ -69,6 +70,7 @@ use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use std::cell::RefCell;\n+use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::symbol::{Symbol, keywords};\n@@ -960,7 +962,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                    ty.id,\n                                                    path.segments.last().unwrap(),\n                                                    span,\n-                                                   partition_bounds(tcx, span, bounds))\n+                                                   partition_bounds(bounds))\n                 } else {\n                     struct_span_err!(tcx.sess, ty.span, E0172,\n                                      \"expected a reference to a trait\")\n@@ -1043,17 +1045,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                         trait_segment,\n                                                         &mut projection_bounds);\n \n-        let PartitionedBounds { builtin_bounds,\n-                                trait_bounds,\n+        let PartitionedBounds { trait_bounds,\n                                 region_bounds } =\n             partitioned_bounds;\n \n+        let (auto_traits, trait_bounds) = split_auto_traits(tcx, trait_bounds);\n+\n         if !trait_bounds.is_empty() {\n             let b = &trait_bounds[0];\n             let span = b.trait_ref.path.span;\n             struct_span_err!(self.tcx().sess, span, E0225,\n-                             \"only the builtin traits can be used as closure or object bounds\")\n-                .span_label(span, &format!(\"non-builtin trait used as bounds\"))\n+                \"only Send/Sync traits can be used as additional traits in a trait object\")\n+                .span_label(span, &format!(\"non-Send/Sync additional trait\"))\n                 .emit();\n         }\n \n@@ -1070,30 +1073,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     ty: b.ty\n                 }\n             })\n-        }).collect();\n-\n-        let region_bound =\n-            self.compute_object_lifetime_bound(span,\n-                                               &region_bounds,\n-                                               existential_principal,\n-                                               builtin_bounds);\n-\n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n-                tcx.mk_region(match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n-                                  \"the lifetime bound for this object type cannot be deduced \\\n-                                   from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                })\n-            }\n-        };\n-\n-        debug!(\"region_bound: {:?}\", region_bound);\n+        });\n \n         // ensure the super predicates and stop if we encountered an error\n         if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n@@ -1135,12 +1115,37 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         .emit();\n         }\n \n-        let ty = tcx.mk_trait(ty::TraitObject {\n-            principal: existential_principal,\n-            region_bound: region_bound,\n-            builtin_bounds: builtin_bounds,\n-            projection_bounds: existential_projections\n-        });\n+        let mut v =\n+            iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n+            .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n+            .chain(existential_projections\n+                   .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n+            .collect::<AccumulateVec<[_; 8]>>();\n+        v.sort_by(|a, b| a.cmp(tcx, b));\n+        let existential_predicates = ty::Binder(tcx.mk_existential_predicates(v.into_iter()));\n+\n+        let region_bound = self.compute_object_lifetime_bound(span,\n+                                                              &region_bounds,\n+                                                              existential_predicates);\n+\n+        let region_bound = match region_bound {\n+            Some(r) => r,\n+            None => {\n+                tcx.mk_region(match rscope.object_lifetime_default(span) {\n+                    Some(r) => r,\n+                    None => {\n+                        span_err!(self.tcx().sess, span, E0228,\n+                                  \"the lifetime bound for this object type cannot be deduced \\\n+                                   from context; please supply an explicit bound\");\n+                        ty::ReStatic\n+                    }\n+                })\n+            }\n+        };\n+\n+        debug!(\"region_bound: {:?}\", region_bound);\n+\n+        let ty = tcx.mk_dynamic(existential_predicates, region_bound);\n         debug!(\"trait_object_type: {:?}\", ty);\n         ty\n     }\n@@ -1439,7 +1444,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                path_id,\n                                                path.segments.last().unwrap(),\n                                                span,\n-                                               partition_bounds(tcx, span, &[]))\n+                                               partition_bounds(&[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n@@ -1893,7 +1898,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         ast_bounds: &[hir::TyParamBound])\n         -> Ty<'tcx>\n     {\n-        let mut partitioned_bounds = partition_bounds(self.tcx(), span, &ast_bounds[..]);\n+        let mut partitioned_bounds = partition_bounds(ast_bounds);\n \n         let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n             partitioned_bounds.trait_bounds.remove(0)\n@@ -1922,38 +1927,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n         explicit_region_bounds: &[&hir::Lifetime],\n-        principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n-        builtin_bounds: ty::BuiltinBounds)\n+        existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n         debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-               principal_trait_ref={:?}, builtin_bounds={:?})\",\n+               existential_predicates={:?})\",\n                explicit_region_bounds,\n-               principal_trait_ref,\n-               builtin_bounds);\n+               existential_predicates);\n \n         if explicit_region_bounds.len() > 1 {\n             span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n                 \"only a single explicit lifetime bound is permitted\");\n         }\n \n-        if !explicit_region_bounds.is_empty() {\n+        if let Some(&r) = explicit_region_bounds.get(0) {\n             // Explicitly specified region bound. Use that.\n-            let r = explicit_region_bounds[0];\n             return Some(ast_region_to_region(tcx, r));\n         }\n \n-        if let Err(ErrorReported) =\n-                self.ensure_super_predicates(span, principal_trait_ref.def_id()) {\n-            return Some(tcx.mk_region(ty::ReStatic));\n+        if let Some(principal) = existential_predicates.principal() {\n+            if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n+                return Some(tcx.mk_region(ty::ReStatic));\n+            }\n         }\n \n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds =\n-            object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n+            object_region_bounds(tcx, existential_predicates);\n \n         // If there are no derived region bounds, then report back that we\n         // can find no region bound. The caller will use the default.\n@@ -1980,46 +1983,62 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n }\n \n pub struct PartitionedBounds<'a> {\n-    pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<&'a hir::PolyTraitRef>,\n     pub region_bounds: Vec<&'a hir::Lifetime>,\n }\n \n-/// Divides a list of bounds from the AST into three groups: builtin bounds (Copy, Sized etc),\n-/// general trait bounds, and region bounds.\n-pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            _span: Span,\n-                                            ast_bounds: &'b [hir::TyParamBound])\n-                                            -> PartitionedBounds<'b>\n+/// Divides a list of general trait bounds into two groups: builtin bounds (Sync/Send) and the\n+/// remaining general trait bounds.\n+fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                         trait_bounds: Vec<&'b hir::PolyTraitRef>)\n+    -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n+{\n+    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.into_iter().partition(|bound| {\n+        match bound.trait_ref.path.def {\n+            Def::Trait(trait_did) => {\n+                // Checks whether `trait_did` refers to one of the builtin\n+                // traits, like `Send`, and adds it to `auto_traits` if so.\n+                if Some(trait_did) == tcx.lang_items.send_trait() ||\n+                    Some(trait_did) == tcx.lang_items.sync_trait() {\n+                    let segments = &bound.trait_ref.path.segments;\n+                    let parameters = &segments[segments.len() - 1].parameters;\n+                    if !parameters.types().is_empty() {\n+                        check_type_argument_count(tcx, bound.trait_ref.path.span,\n+                                                  parameters.types().len(), &[]);\n+                    }\n+                    if !parameters.lifetimes().is_empty() {\n+                        report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n+                                                     parameters.lifetimes().len(), 0);\n+                    }\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false\n+        }\n+    });\n+\n+    let auto_traits = auto_traits.into_iter().map(|tr| {\n+        if let Def::Trait(trait_did) = tr.trait_ref.path.def {\n+            trait_did\n+        } else {\n+            unreachable!()\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    (auto_traits, trait_bounds)\n+}\n+\n+/// Divides a list of bounds from the AST into two groups: general trait bounds and region bounds\n+pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(ast_bounds: &'b [hir::TyParamBound])\n+    -> PartitionedBounds<'b>\n {\n-    let mut builtin_bounds = ty::BuiltinBounds::empty();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                match b.trait_ref.path.def {\n-                    Def::Trait(trait_did) => {\n-                        if tcx.try_add_builtin_trait(trait_did,\n-                                                     &mut builtin_bounds) {\n-                            let segments = &b.trait_ref.path.segments;\n-                            let parameters = &segments[segments.len() - 1].parameters;\n-                            if !parameters.types().is_empty() {\n-                                check_type_argument_count(tcx, b.trait_ref.path.span,\n-                                                          parameters.types().len(), &[]);\n-                            }\n-                            if !parameters.lifetimes().is_empty() {\n-                                report_lifetime_number_error(tcx, b.trait_ref.path.span,\n-                                                             parameters.lifetimes().len(), 0);\n-                            }\n-                            continue; // success\n-                        }\n-                    }\n-                    _ => {\n-                        // Not a trait? that's an error, but it'll get\n-                        // reported later.\n-                    }\n-                }\n                 trait_bounds.push(b);\n             }\n             hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n@@ -2030,7 +2049,6 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n \n     PartitionedBounds {\n-        builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n     }\n@@ -2105,7 +2123,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n     pub region_bounds: Vec<&'tcx ty::Region>,\n-    pub builtin_bounds: ty::BuiltinBounds,\n+    pub implicitly_sized: bool,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n }\n@@ -2116,10 +2134,14 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     {\n         let mut vec = Vec::new();\n \n-        for builtin_bound in &self.builtin_bounds {\n-            match tcx.trait_ref_for_builtin_bound(builtin_bound, param_ty) {\n-                Ok(trait_ref) => { vec.push(trait_ref.to_predicate()); }\n-                Err(ErrorReported) => { }\n+        // If it could be sized, and is, add the sized predicate\n+        if self.implicitly_sized {\n+            if let Some(sized) = tcx.lang_items.sized_trait() {\n+                let trait_ref = ty::TraitRef {\n+                    def_id: sized,\n+                    substs: tcx.mk_substs_trait(param_ty, &[])\n+                };\n+                vec.push(trait_ref.to_predicate());\n             }\n         }\n "}, {"sha": "6e2b42881a709622c876a403d315d7dca3d1df4b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n-                if let ty::TyTrait(..) = mt.ty.sty {\n+                if let ty::TyDynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);"}, {"sha": "f2c8ef46a7e252db6a090ee80222797cec8d5fe1", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -46,6 +46,7 @@ use rustc::hir;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n+use rustc::middle::lang_items;\n use syntax::ast;\n use syntax_pos::Span;\n use util::common::ErrorReported;\n@@ -64,7 +65,7 @@ pub struct CastCheck<'tcx> {\n /// fat pointers if their unsize-infos have the same kind.\n #[derive(Copy, Clone, PartialEq, Eq)]\n enum UnsizeKind<'tcx> {\n-    Vtable(DefId),\n+    Vtable(Option<DefId>),\n     Length,\n     /// The unsize info of this projection\n     OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n@@ -78,7 +79,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n         match t.sty {\n             ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n-            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal.def_id())),\n+            ty::TyDynamic(ref tty, ..) =>\n+                Some(UnsizeKind::Vtable(tty.principal().map(|p| p.def_id()))),\n             ty::TyAdt(def, substs) if def.is_struct() => {\n                 // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {\n@@ -129,7 +131,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n         match cast_ty.sty {\n-            ty::TyTrait(..) | ty::TySlice(..) => {\n+            ty::TyDynamic(..) | ty::TySlice(..) => {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n             }\n@@ -543,6 +545,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_is_known_to_be_sized(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundSized, span)\n+        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+        traits::type_known_to_meet_bound(self, ty, lang_item, span)\n     }\n }"}, {"sha": "486f8fc25bb32d7b8419cd5ae4a478ac4bf0eb5e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -112,15 +112,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected_ty);\n \n         match expected_ty.sty {\n-            ty::TyTrait(ref object_type) => {\n-                let sig = object_type.projection_bounds\n-                    .iter()\n+            ty::TyDynamic(ref object_type, ..) => {\n+                let sig = object_type.projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n                         self.deduce_sig_from_projection(&pb)\n                     })\n                     .next();\n-                let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal.def_id());\n+                let kind = object_type.principal()\n+                    .and_then(|p| self.tcx.lang_items.fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),"}, {"sha": "a5446b0fbaa89edc025b8c1c279b3dd3cada64ea", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -515,7 +515,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n         }\n \n         // these are always dtorck\n-        ty::TyTrait(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n+        ty::TyDynamic(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n     }\n }\n \n@@ -564,7 +564,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n             return DropckKind::RevisedSelf(revised_ty);\n         }\n-        ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n             return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n         },"}, {"sha": "ff9eaa012ba41e3c37f1ed4652134de01c00becb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .autoderef(self.span, self_ty)\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n-                    ty::TyTrait(ref data) => Some(closure(self, ty, data.principal)),\n+                    ty::TyDynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n                     _ => None,\n                 }\n             })"}, {"sha": "b0787d75c9cb4f903fa58a2794eddee5c6cb0db4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -295,9 +295,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n \n         match self_ty.sty {\n-            ty::TyTrait(box ref data) => {\n-                self.assemble_inherent_candidates_from_object(self_ty, data.principal);\n-                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n+            ty::TyDynamic(ref data, ..) => {\n+                if let Some(p) = data.principal() {\n+                    self.assemble_inherent_candidates_from_object(self_ty, p);\n+                    self.assemble_inherent_impl_candidates_for_type(p.def_id());\n+                }\n             }\n             ty::TyAdt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);"}, {"sha": "9443e0a3586b016abf563a0161ae11437dd8264e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -379,7 +379,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyAdt(def, _) => def.did.is_local(),\n \n-                ty::TyTrait(ref tr) => tr.principal.def_id().is_local(),\n+                ty::TyDynamic(ref tr, ..) => tr.principal()\n+                    .map_or(false, |p| p.def_id().is_local()),\n \n                 ty::TyParam(_) => true,\n "}, {"sha": "4dbb76e03d11af81f84fe2e57241b411f4f1886e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -123,6 +123,7 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n+use rustc::middle::lang_items;\n use rustc_back::slice;\n use rustc_const_eval::eval_length;\n \n@@ -268,7 +269,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match fcx.tcx.struct_tail(ty).sty {\n-            ty::TySlice(_) | ty::TyStr | ty::TyTrait(..) => {\n+            ty::TySlice(_) | ty::TyStr | ty::TyDynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n             _ => ExpectHasType(ty)\n@@ -1815,11 +1816,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               ty: Ty<'tcx>,\n                               span: Span,\n                               code: traits::ObligationCauseCode<'tcx>,\n-                              bound: ty::BuiltinBound)\n+                              def_id: DefId)\n     {\n-        self.register_builtin_bound(\n+        self.register_bound(\n             ty,\n-            bound,\n+            def_id,\n             traits::ObligationCause::new(span, self.body_id, code));\n     }\n \n@@ -1828,16 +1829,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  span: Span,\n                                  code: traits::ObligationCauseCode<'tcx>)\n     {\n-        self.require_type_meets(ty, span, code, ty::BoundSized);\n+        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+        self.require_type_meets(ty, span, code, lang_item);\n     }\n \n-    pub fn register_builtin_bound(&self,\n+    pub fn register_bound(&self,\n                                   ty: Ty<'tcx>,\n-                                  builtin_bound: ty::BuiltinBound,\n+                                  def_id: DefId,\n                                   cause: traits::ObligationCause<'tcx>)\n     {\n         self.fulfillment_cx.borrow_mut()\n-            .register_builtin_bound(self, ty, builtin_bound, cause);\n+            .register_bound(self, ty, def_id, cause);\n     }\n \n     pub fn register_predicate(&self,\n@@ -3909,7 +3911,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if count > 1 {\n                 // For [foo, ..n] where n > 1, `foo` must have\n                 // Copy type:\n-                self.require_type_meets(t, expr.span, traits::RepeatVec, ty::BoundCopy);\n+                let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n             }\n \n             if element_ty.references_error() {"}, {"sha": "c0bf5773ed56ab3de33d500caada73b8f34e7a70", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -812,11 +812,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::TyTrait(ref obj)) => {\n+            /*To:  */  &ty::TyDynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n-                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span),\n-                                       from_ty, obj.region_bound);\n+                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n             /*From:*/ (&ty::TyBox(from_referent_ty),"}, {"sha": "0727b1c8804cacd8af23b012fac258472cc32429", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -18,6 +18,7 @@ use middle::region::{CodeExtent};\n use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::middle::lang_items;\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -117,14 +118,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n                 let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(item.id)).unwrap();\n-                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n-                match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n-                    Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n-                    Some(_) | None => {\n-                        if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                            error_192(ccx, item.span);\n-                        }\n-                    }\n+                if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n+                    error_192(ccx, item.span);\n                 }\n             }\n             hir::ItemFn(.., body_id) => {\n@@ -241,9 +236,9 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 // For DST, all intermediate types must be sized.\n                 let unsized_len = if all_sized || variant.fields.is_empty() { 0 } else { 1 };\n                 for field in &variant.fields[..variant.fields.len() - unsized_len] {\n-                    fcx.register_builtin_bound(\n+                    fcx.register_bound(\n                         field.ty,\n-                        ty::BoundSized,\n+                        fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n                         traits::ObligationCause::new(field.span,\n                                                      fcx.body_id,\n                                                      traits::FieldSized));"}, {"sha": "30472f85db1207a9db955aecc7289cb3f4974420", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -23,7 +23,7 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n+use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n@@ -68,7 +68,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         match ty.sty {\n             TyAdt(def, _) => Some(def.did),\n \n-            TyTrait(ref t) => Some(t.principal.def_id()),\n+            TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n \n             TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n "}, {"sha": "2e8206ec959678297bd00f183307b3b857f65ac4", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -86,8 +86,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     ty::TyAdt(def, _) => {\n                         self.check_def_id(item, def.did);\n                     }\n-                    ty::TyTrait(ref data) => {\n-                        self.check_def_id(item, data.principal.def_id());\n+                    ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n+                        self.check_def_id(item, data.principal().unwrap().def_id());\n                     }\n                     ty::TyBox(..) => {\n                         match self.tcx.lang_items.require_owned_box() {"}, {"sha": "815811675a54bff05321ee3fef482003bb8bf6c7", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -178,18 +178,17 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 }\n \n                 // check for overlap with the automatic `impl Trait for Trait`\n-                if let ty::TyTrait(ref data) = trait_ref.self_ty().sty {\n+                if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n                     // This is something like impl Trait1 for Trait2. Illegal\n                     // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                    if !self.tcx.is_object_safe(data.principal.def_id()) {\n-                        // This is an error, but it will be\n-                        // reported by wfcheck.  Ignore it\n-                        // here. This is tested by\n-                        // `coherence-impl-trait-for-trait-object-safe.rs`.\n+                    if data.principal().map_or(true, |p| !self.tcx.is_object_safe(p.def_id())) {\n+                        // This is an error, but it will be reported by wfcheck.  Ignore it here.\n+                        // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n                     } else {\n                         let mut supertrait_def_ids =\n-                            traits::supertrait_def_ids(self.tcx, data.principal.def_id());\n+                            traits::supertrait_def_ids(self.tcx,\n+                                                       data.principal().unwrap().def_id());\n                         if supertrait_def_ids.any(|d| d == trait_def_id) {\n                             span_err!(self.tcx.sess,\n                                       item.span,"}, {"sha": "cbe0a1c4bf3ac26e7ec559bad655de8540f185ed", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -1639,11 +1639,10 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     assert!(prev_predicates.is_none());\n }\n \n-// Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                       bounds: &mut ty::BuiltinBounds,\n-                                       ast_bounds: &[hir::TyParamBound],\n-                                       span: Span)\n+// Is it marked with ?Sized\n+fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                ast_bounds: &[hir::TyParamBound],\n+                                span: Span) -> bool\n {\n     let tcx = astconv.tcx();\n \n@@ -1672,16 +1671,17 @@ fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\\n                                        a default. Only `?Sized` is supported\");\n-                    tcx.try_add_builtin_trait(kind_id, bounds);\n                 }\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            tcx.try_add_builtin_trait(kind_id.unwrap(), bounds);\n+            return false;\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n     }\n+\n+    true\n }\n \n /// Returns the early-bound lifetimes declared in this generics\n@@ -1963,14 +1963,9 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n {\n     let tcx = astconv.tcx();\n     let PartitionedBounds {\n-        mut builtin_bounds,\n         trait_bounds,\n         region_bounds\n-    } = partition_bounds(tcx, span, &ast_bounds);\n-\n-    if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(astconv, &mut builtin_bounds, ast_bounds, span);\n-    }\n+    } = partition_bounds(&ast_bounds);\n \n     let mut projection_bounds = vec![];\n \n@@ -1988,9 +1983,15 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n \n     trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n+    let implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n+        !is_unsized(astconv, ast_bounds, span)\n+    } else {\n+        false\n+    };\n+\n     Bounds {\n         region_bounds: region_bounds,\n-        builtin_bounds: builtin_bounds,\n+        implicitly_sized: implicitly_sized,\n         trait_bounds: trait_bounds,\n         projection_bounds: projection_bounds,\n     }"}, {"sha": "01e99a296e886bb49fb99e6cfe8f02527c768c55", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -2778,8 +2778,8 @@ fn main() {\n }\n ```\n \n-Builtin traits are an exception to this rule: it's possible to have bounds of\n-one non-builtin type, plus any number of builtin types. For example, the\n+Send and Sync are an exception to this rule: it's possible to have bounds of\n+one non-builtin trait, plus either or both of Send and Sync. For example, the\n following compiles correctly:\n \n ```"}, {"sha": "f34753c227d71c34d1625cceadcf31687e59d9f5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -371,15 +371,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                                  variance);\n             }\n \n-            ty::TyTrait(ref data) => {\n+            ty::TyDynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, data.region_bound, contra);\n+                self.add_constraints_from_region(generics, r, contra);\n \n-                let poly_trait_ref = data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n-                self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                if let Some(p) = data.principal() {\n+                    let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n+                    self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                }\n \n-                for projection in &data.projection_bounds {\n+                for projection in data.projection_bounds() {\n                     self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n                 }\n             }"}, {"sha": "8d65a5dbc6fcb0a588779a792548b27f64e57cd1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -30,6 +30,7 @@ use syntax_pos::{self, DUMMY_SP, Pos};\n use rustc_trans::back::link;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n+use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::print as pprust;\n@@ -593,12 +594,20 @@ pub enum TyParamBound {\n \n impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n-        use rustc::hir::TraitBoundModifier as TBM;\n-        let mut sized_bound = ty::BoundSized.clean(cx);\n-        if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n-            *tbm = TBM::Maybe\n-        };\n-        sized_bound\n+        let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+        let empty = cx.tcx.intern_substs(&[]);\n+        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+            Some(did), false, vec![], empty);\n+        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+        TraitBound(PolyTrait {\n+            trait_: ResolvedPath {\n+                path: path,\n+                typarams: None,\n+                did: did,\n+                is_generic: false,\n+            },\n+            lifetimes: vec![]\n+        }, hir::TraitBoundModifier::Maybe)\n     }\n \n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n@@ -675,37 +684,6 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n     }\n }\n \n-impl Clean<TyParamBound> for ty::BuiltinBound {\n-    fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        let tcx = cx.tcx;\n-        let empty = tcx.intern_substs(&[]);\n-        let (did, path) = match *self {\n-            ty::BoundSend =>\n-                (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(cx, \"Send\", None, false, vec![], empty)),\n-            ty::BoundSized =>\n-                (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(cx, \"Sized\", None, false, vec![], empty)),\n-            ty::BoundCopy =>\n-                (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(cx, \"Copy\", None, false, vec![], empty)),\n-            ty::BoundSync =>\n-                (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(cx, \"Sync\", None, false, vec![], empty)),\n-        };\n-        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-        TraitBound(PolyTrait {\n-            trait_: ResolvedPath {\n-                path: path,\n-                typarams: None,\n-                did: did,\n-                is_generic: false,\n-            },\n-            lifetimes: vec![]\n-        }, hir::TraitBoundModifier::None)\n-    }\n-}\n-\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         inline::record_extern_fqn(cx, self.def_id, TypeKind::Trait);\n@@ -1876,31 +1854,48 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::TyTrait(ref obj) => {\n-                let did = obj.principal.def_id();\n-                inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-\n-                let mut typarams = vec![];\n-                obj.region_bound.clean(cx).map(|b| typarams.push(RegionBound(b)));\n-                for bb in &obj.builtin_bounds {\n-                    typarams.push(bb.clean(cx));\n-                }\n+            ty::TyDynamic(ref obj, ref reg) => {\n+                if let Some(principal) = obj.principal() {\n+                    let did = principal.def_id();\n+                    inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+\n+                    let mut typarams = vec![];\n+                    reg.clean(cx).map(|b| typarams.push(RegionBound(b)));\n+                    for did in obj.auto_traits() {\n+                        let empty = cx.tcx.intern_substs(&[]);\n+                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                            Some(did), false, vec![], empty);\n+                        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+                        let bound = TraitBound(PolyTrait {\n+                            trait_: ResolvedPath {\n+                                path: path,\n+                                typarams: None,\n+                                did: did,\n+                                is_generic: false,\n+                            },\n+                            lifetimes: vec![]\n+                        }, hir::TraitBoundModifier::None);\n+                        typarams.push(bound);\n+                    }\n \n-                let mut bindings = vec![];\n-                for &ty::Binder(ref pb) in &obj.projection_bounds {\n-                    bindings.push(TypeBinding {\n-                        name: pb.item_name.clean(cx),\n-                        ty: pb.ty.clean(cx)\n-                    });\n-                }\n+                    let mut bindings = vec![];\n+                    for ty::Binder(ref pb) in obj.projection_bounds() {\n+                        bindings.push(TypeBinding {\n+                            name: pb.item_name.clean(cx),\n+                            ty: pb.ty.clean(cx)\n+                        });\n+                    }\n \n-                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n-                                         Some(did), false, bindings, obj.principal.0.substs);\n-                ResolvedPath {\n-                    path: path,\n-                    typarams: Some(typarams),\n-                    did: did,\n-                    is_generic: false,\n+                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n+                        false, bindings, principal.0.substs);\n+                    ResolvedPath {\n+                        path: path,\n+                        typarams: Some(typarams),\n+                        did: did,\n+                        is_generic: false,\n+                    }\n+                } else {\n+                    Never\n                 }\n             }\n             ty::TyTuple(ref t) => Tuple(t.clean(cx)),"}, {"sha": "8c79c15e3de5bf8c053da24e8c126aa88c38c281", "filename": "src/test/compile-fail/E0225.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2FE0225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2FE0225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0225.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     let _: Box<std::io::Read + std::io::Write>;\n-    //~^ ERROR only the builtin traits can be used as closure or object bounds [E0225]\n-    //~| NOTE non-builtin trait used as bounds\n+    //~^ ERROR only Send/Sync traits can be used as additional traits in a trait object [E0225]\n+    //~| NOTE non-Send/Sync additional trait\n }"}, {"sha": "a2e2e5caafe6d0c408cd5a13d2ed7de8c43cb06d", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -12,8 +12,7 @@ trait Trait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n-    //~^ ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n-    //~| ERROR the trait `std::marker::Sized` cannot be made into an object\n-    //~| ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n-    //~| ERROR the trait `std::marker::Sized` cannot be made into an object\n+    //~^ ERROR only Send/Sync traits can be used as additional traits in a trait object\n+    //~| ERROR the trait bound `Trait: std::marker::Sized` is not satisfied\n+    //~| ERROR the trait bound `Trait: std::marker::Sized` is not satisfied\n }"}, {"sha": "23cff4ac6ad6c219b55eae24f8c8d515c4d30523", "filename": "src/test/compile-fail/const-unsized.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -11,8 +11,8 @@\n use std::fmt::Debug;\n \n const CONST_0: Debug+Sync = *(&0 as &(Debug+Sync));\n-//~^ ERROR `std::fmt::Debug + Sync + 'static: std::marker::Sized` is not satisfied\n-//~| NOTE the trait `std::marker::Sized` is not implemented for `std::fmt::Debug + Sync + 'static`\n+//~^ ERROR `std::fmt::Debug + std::marker::Sync + 'static: std::marker::Sized` is not satisfied\n+//~| NOTE the trait `std::marker::Sized` is not implemented for `std::fmt::Debug + std::marker::Syn\n //~| NOTE does not have a constant size known at compile-time\n //~| NOTE constant expressions must have a statically known size\n \n@@ -23,8 +23,8 @@ const CONST_FOO: str = *\"foo\";\n //~| NOTE constant expressions must have a statically known size\n \n static STATIC_1: Debug+Sync = *(&1 as &(Debug+Sync));\n-//~^ ERROR `std::fmt::Debug + Sync + 'static: std::marker::Sized` is not satisfied\n-//~| NOTE the trait `std::marker::Sized` is not implemented for `std::fmt::Debug + Sync + 'static`\n+//~^ ERROR `std::fmt::Debug + std::marker::Sync + 'static: std::marker::Sized` is not satisfied\n+//~| NOTE the trait `std::marker::Sized` is not implemented for `std::fmt::Debug + std::marker::Syn\n //~| NOTE does not have a constant size known at compile-time\n //~| NOTE constant expressions must have a statically known size\n "}, {"sha": "508442fcb9453e4a0327aeb9c540f5cff5e3e736", "filename": "src/test/compile-fail/issue-16966.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fissue-16966.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fissue-16966.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16966.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:type annotations required\n+// error-pattern:type annotations or generic parameter binding required\n fn main() {\n     panic!(\n         std::default::Default::default()"}, {"sha": "2ad804fc8ced7e3c92964c1825f0553697c9521f", "filename": "src/test/compile-fail/issue-22560.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -20,6 +20,6 @@ type Test = Add +\n             //~| NOTE missing associated type `Output` value\n             Sub;\n             //~^ ERROR E0225\n-            //~| NOTE non-builtin trait used as bounds\n+            //~| NOTE non-Send/Sync additional trait\n \n fn main() { }"}, {"sha": "f146cfbe68b9631f50540cd022caa2c588095100", "filename": "src/test/compile-fail/issue-32963.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -16,6 +16,6 @@ fn size_of_copy<T: Copy+?Sized>() -> usize { mem::size_of::<T>() }\n \n fn main() {\n     size_of_copy::<Misc+Copy>();\n-    //~^ ERROR `Misc + Copy: std::marker::Copy` is not satisfied\n-    //~| ERROR the trait `std::marker::Copy` cannot be made into an object\n+    //~^ ERROR only Send/Sync traits can be used as additional traits in a trait object\n+    //~| ERROR the trait bound `Misc: std::marker::Copy` is not satisfied\n }"}, {"sha": "9f832c7b6e500f52e87a900e82b0c47cebb5c6f3", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -21,10 +21,10 @@ fn c(x: Box<Foo+Sync+Send>) {\n }\n \n fn d(x: Box<Foo>) {\n-    a(x); //~  ERROR mismatched types\n-          //~| expected type `Box<Foo + Send + 'static>`\n-          //~| found type `Box<Foo + 'static>`\n-          //~| expected bounds `Send`, found no bounds\n+    a(x); //~ ERROR mismatched types [E0308]\n+          //~| NOTE expected type `Box<Foo + std::marker::Send + 'static>`\n+          //~| NOTE found type `Box<Foo + 'static>`\n+          //~| NOTE expected trait `Foo + std::marker::Send`, found trait `Foo`\n }\n \n fn main() { }"}, {"sha": "983c66ec1c40fba449e4ba1490512cd00521d9b3", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -15,7 +15,7 @@ trait Foo {\n // This should emit the less confusing error, not the more confusing one.\n \n fn foo(_x: Foo + Send) {\n-    //~^ ERROR `Foo + Send + 'static: std::marker::Sized` is not satisfied\n+    //~^ ERROR the trait bound `Foo + std::marker::Send + 'static: std::marker::Sized` is not\n }\n \n fn main() { }"}, {"sha": "ba50aed42c36f64f1f21fe4709517dc5f45759a7", "filename": "src/test/run-pass/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e373b47872872a2ce61c5b02f4dd96d90d046ee/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs?ref=8e373b47872872a2ce61c5b02f4dd96d90d046ee", "patch": "@@ -70,7 +70,7 @@ pub mod testtypes {\n     // Tests TyFnPtr\n     pub type FooFnPtr = fn(u8) -> bool;\n \n-    // Tests TyTrait\n+    // Tests TyDynamic\n     pub trait FooTrait {\n         fn foo_method(&self) -> usize;\n     }"}]}