{"sha": "9146a919b616e39e528e4d7100d16eef52f1f852", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNDZhOTE5YjYxNmUzOWU1MjhlNGQ3MTAwZDE2ZWVmNTJmMWY4NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T18:57:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T18:57:15Z"}, "message": "auto merge of #19391 : nick29581/rust/assoc-eq, r=nikomatsakis\n\nr? @nikomatsakis \r\n\r\ncc @aturon (I think you were interested in this for some library stuff)\r\n\r\ncloses #18432", "tree": {"sha": "d6c397956a7905c50e86e85777b417a1f2c5bdfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c397956a7905c50e86e85777b417a1f2c5bdfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9146a919b616e39e528e4d7100d16eef52f1f852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9146a919b616e39e528e4d7100d16eef52f1f852", "html_url": "https://github.com/rust-lang/rust/commit/9146a919b616e39e528e4d7100d16eef52f1f852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9146a919b616e39e528e4d7100d16eef52f1f852/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5921241a3146cccaffc336a0d1ade1a90e3517f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5921241a3146cccaffc336a0d1ade1a90e3517f", "html_url": "https://github.com/rust-lang/rust/commit/a5921241a3146cccaffc336a0d1ade1a90e3517f"}, {"sha": "ce4318ad86f2ccd0710247020269ba0ba22c6d59", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4318ad86f2ccd0710247020269ba0ba22c6d59", "html_url": "https://github.com/rust-lang/rust/commit/ce4318ad86f2ccd0710247020269ba0ba22c6d59"}], "stats": {"total": 1130, "additions": 868, "deletions": 262}, "files": [{"sha": "0cdf6a68e44be343a2943c99c7496add4127ef54", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -148,5 +148,9 @@ register_diagnostics!(\n     E0169,\n     E0170,\n     E0171,\n-    E0172\n+    E0172,\n+    E0173,\n+    E0174,\n+    E0177,\n+    E0178\n )"}, {"sha": "23bd37486bc0a77f40ae9ceaff8847a2638180a9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -435,7 +435,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n }\n \n // Something that a name can resolve to.\n-#[deriving(Clone)]\n+#[deriving(Clone,Show)]\n pub enum DefLike {\n     DlDef(def::Def),\n     DlImpl(ast::DefId),"}, {"sha": "d24eddf9ab05b2fa109226a816a833a7b5e52648", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -1405,10 +1405,22 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 let new_types = data.types.map(|t| {\n                     self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n                 });\n+                let new_bindings = data.bindings.map(|b| {\n+                    P(ast::TypeBinding {\n+                        id: b.id,\n+                        ident: b.ident,\n+                        ty: self.rebuild_arg_ty_or_output(&*b.ty,\n+                                                          lifetime,\n+                                                          anon_nums,\n+                                                          region_names),\n+                        span: b.span\n+                    })\n+                });\n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: new_lts,\n-                    types: new_types\n-                })\n+                    types: new_types,\n+                    bindings: new_bindings,\n+               })\n             }\n         };\n         let new_seg = ast::PathSegment {"}, {"sha": "79bb19a1e535f245dc47527d47769979ff7a4967", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -1453,8 +1453,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             }\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            for bound in predicate.bounds.iter() {\n-                self.check_ty_param_bound(predicate.span, bound)\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                    for bound in bound_pred.bounds.iter() {\n+                        self.check_ty_param_bound(bound_pred.span, bound)\n+                    }\n+                }\n+                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n+                    self.visit_ty(&*eq_pred.ty);\n+                }\n             }\n         }\n     }"}, {"sha": "2899f60f736af299579a2ba24b7efaaed1c88535", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 80, "deletions": 56, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -108,7 +108,7 @@ pub type ExportMap2 = NodeMap<Vec<Export2>>;\n \n pub struct Export2 {\n     pub name: String,        // The name of the target.\n-    pub def_id: DefId,     // The definition of the target.\n+    pub def_id: DefId,       // The definition of the target.\n }\n \n // This set contains all exported definitions from external crates. The set does\n@@ -314,7 +314,7 @@ impl<'a> Copy for TypeParameters<'a> {}\n \n // The rib kind controls the translation of local\n // definitions (`DefLocal`) to upvars (`DefUpvar`).\n-\n+#[deriving(Show)]\n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n@@ -340,6 +340,7 @@ enum RibKind {\n impl Copy for RibKind {}\n \n // Methods can be required or provided. RequiredMethod methods only occur in traits.\n+#[deriving(Show)]\n enum MethodSort {\n     RequiredMethod,\n     ProvidedMethod(NodeId)\n@@ -414,6 +415,7 @@ enum DuplicateCheckingMode {\n impl Copy for DuplicateCheckingMode {}\n \n /// One local scope.\n+#[deriving(Show)]\n struct Rib {\n     bindings: HashMap<Name, DefLike>,\n     kind: RibKind,\n@@ -728,8 +730,11 @@ impl NameBindings {\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n-                let module = Module::new(parent_link, def_id, kind,\n-                                         external, is_public);\n+                let module = Module::new(parent_link,\n+                                         def_id,\n+                                         kind,\n+                                         external,\n+                                         is_public);\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     modifiers: modifiers,\n                     module_def: Some(Rc::new(module)),\n@@ -774,9 +779,9 @@ impl NameBindings {\n             }\n             Some(type_def) => {\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n+                    module_def: type_def.module_def,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n-                    module_def: type_def.module_def,\n                     modifiers: modifiers,\n                 });\n             }\n@@ -1286,7 +1291,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Name)\n-                           -> ParentLink {\n+                       -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_.downgrade(), name);\n@@ -1578,14 +1583,14 @@ impl<'a> Resolver<'a> {\n \n             ItemImpl(_, Some(_), _, _) => parent,\n \n-            ItemTrait(_, _, _, ref methods) => {\n+            ItemTrait(_, _, _, ref items) => {\n                 let name_bindings =\n                     self.add_child(name,\n                                    parent.clone(),\n                                    ForbidDuplicateTypesAndModules,\n                                    sp);\n \n-                // Add all the methods within to a new module.\n+                // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent.clone(), name);\n                 name_bindings.define_module(parent_link,\n                                             Some(local_def(item.id)),\n@@ -1598,13 +1603,12 @@ impl<'a> Resolver<'a> {\n \n                 let def_id = local_def(item.id);\n \n-                // Add the names of all the methods to the trait info.\n-                for method in methods.iter() {\n-                    let (name, kind) = match *method {\n+                // Add the names of all the items to the trait info.\n+                for trait_item in items.iter() {\n+                    let (name, kind) = match *trait_item {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n-                            let ty_m =\n-                                ast_util::trait_item_to_ty_method(method);\n+                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n \n                             let name = ty_m.ident.name;\n \n@@ -3353,7 +3357,7 @@ impl<'a> Resolver<'a> {\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span,\n                            name_search_type: NameSearchType)\n-                               -> ResolveResult<(Rc<Module>, LastPrivate)> {\n+                           -> ResolveResult<(Rc<Module>, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -3382,7 +3386,9 @@ impl<'a> Resolver<'a> {\n                                             mpath.slice_to(idx - 1));\n                         return Failed(Some((span, msg)));\n                     },\n-                    None => return Failed(None),\n+                    None => {\n+                        return Failed(None)\n+                    }\n                 }\n             }\n             Failed(err) => return Failed(err),\n@@ -3407,9 +3413,8 @@ impl<'a> Resolver<'a> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_module_in_lexical_scope(\n-                                                            module_,\n-                                                            module_path[0]) {\n+                        match self.resolve_module_in_lexical_scope(module_,\n+                                                                   module_path[0]) {\n                             Failed(err) => return Failed(err),\n                             Indeterminate => {\n                                 debug!(\"(resolving module path for import) \\\n@@ -3576,8 +3581,7 @@ impl<'a> Resolver<'a> {\n                                 -> ResolveResult<Rc<Module>> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n-        let resolve_result = self.resolve_item_in_lexical_scope(\n-            module_, name, TypeNS);\n+        let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS);\n         match resolve_result {\n             Success((target, _)) => {\n                 let bindings = &*target.bindings;\n@@ -4590,25 +4594,42 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_where_clause(&mut self, where_clause: &ast::WhereClause) {\n         for predicate in where_clause.predicates.iter() {\n-            match self.resolve_identifier(predicate.ident,\n-                                          TypeNS,\n-                                          true,\n-                                          predicate.span) {\n-                Some((def @ DefTyParam(_, _, _), last_private)) => {\n-                    self.record_def(predicate.id, (def, last_private));\n-                }\n-                _ => {\n-                    self.resolve_error(\n-                        predicate.span,\n-                        format!(\"undeclared type parameter `{}`\",\n-                                token::get_ident(\n-                                    predicate.ident)).as_slice());\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                    match self.resolve_identifier(bound_pred.ident,\n+                                                  TypeNS,\n+                                                  true,\n+                                                  bound_pred.span) {\n+                        Some((def @ DefTyParam(..), last_private)) => {\n+                            self.record_def(bound_pred.id, (def, last_private));\n+                        }\n+                        _ => {\n+                            self.resolve_error(\n+                                bound_pred.span,\n+                                format!(\"undeclared type parameter `{}`\",\n+                                        token::get_ident(\n+                                            bound_pred.ident)).as_slice());\n+                        }\n+                    }\n+\n+                    for bound in bound_pred.bounds.iter() {\n+                        self.resolve_type_parameter_bound(bound_pred.id, bound,\n+                                                          TraitBoundingTypeParameter);\n+                    }\n                 }\n-            }\n+                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n+                    match self.resolve_path(eq_pred.id, &eq_pred.path, TypeNS, true) {\n+                        Some((def @ DefTyParam(..), last_private)) => {\n+                            self.record_def(eq_pred.id, (def, last_private));\n+                        }\n+                        _ => {\n+                            self.resolve_error(eq_pred.path.span,\n+                                               \"undeclared associated type\");\n+                        }\n+                    }\n \n-            for bound in predicate.bounds.iter() {\n-                self.resolve_type_parameter_bound(predicate.id, bound,\n-                                                  TraitBoundingTypeParameter);\n+                    self.resolve_type(&*eq_pred.ty);\n+                }\n             }\n         }\n     }\n@@ -5269,15 +5290,19 @@ impl<'a> Resolver<'a> {\n                     path: &Path,\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n-        // First, resolve the types.\n+        // First, resolve the types and associated type bindings.\n         for ty in path.segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n             self.resolve_type(&**ty);\n         }\n+        for binding in path.segments.iter().flat_map(|s| s.parameters.bindings().into_iter()) {\n+            self.resolve_type(&*binding.ty);\n+        }\n \n         if path.global {\n             return self.resolve_crate_relative_path(path, namespace);\n         }\n \n+        // Try to find a path to an item in a module.\n         let unqualified_def =\n                 self.resolve_identifier(path.segments\n                                             .last().unwrap()\n@@ -5307,15 +5332,15 @@ impl<'a> Resolver<'a> {\n \n     // resolve a single identifier (used as a varref)\n     fn resolve_identifier(&mut self,\n-                              identifier: Ident,\n-                              namespace: Namespace,\n-                              check_ribs: bool,\n-                              span: Span)\n-                              -> Option<(Def, LastPrivate)> {\n+                          identifier: Ident,\n+                          namespace: Namespace,\n+                          check_ribs: bool,\n+                          span: Span)\n+                          -> Option<(Def, LastPrivate)> {\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n-                                                      namespace,\n-                                                      span) {\n+                                                        namespace,\n+                                                        span) {\n                 Some(def) => {\n                     return Some((def, LastMod(AllPublic)));\n                 }\n@@ -5333,7 +5358,7 @@ impl<'a> Resolver<'a> {\n                                             containing_module: Rc<Module>,\n                                             name: Name,\n                                             namespace: Namespace)\n-                                                -> NameDefinition {\n+                                            -> NameDefinition {\n         // First, search children.\n         self.populate_module_if_necessary(&containing_module);\n \n@@ -5403,9 +5428,9 @@ impl<'a> Resolver<'a> {\n \n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n-                                        path: &Path,\n-                                        namespace: Namespace)\n-                                        -> Option<(Def, LastPrivate)> {\n+                                    path: &Path,\n+                                    namespace: Namespace)\n+                                    -> Option<(Def, LastPrivate)> {\n         let module_path = path.segments.init().iter()\n                                               .map(|ps| ps.identifier.name)\n                                               .collect::<Vec<_>>();\n@@ -5422,9 +5447,8 @@ impl<'a> Resolver<'a> {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n-                        let msg = format!(\"Use of undeclared module `{}`\",\n-                                          self.names_to_string(\n-                                               module_path.as_slice()));\n+                        let msg = format!(\"Use of undeclared type or module `{}`\",\n+                                          self.names_to_string(module_path.as_slice()));\n                         (path.span, msg)\n                     }\n                 };\n@@ -5518,10 +5542,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n-                                            ident: Ident,\n-                                            namespace: Namespace,\n-                                            span: Span)\n-                                            -> Option<Def> {\n+                                        ident: Ident,\n+                                        namespace: Namespace,\n+                                        span: Span)\n+                                        -> Option<Def> {\n         // Check the local set of ribs.\n         let search_result = match namespace {\n             ValueNS => {"}, {"sha": "3ab94d3ca66197952ca35b0129761e9fb7bfcc70", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -210,8 +210,22 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             }\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            self.visit_ident(predicate.span, predicate.ident);\n-            visit::walk_ty_param_bounds_helper(self, &predicate.bounds);\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ident,\n+                                                                               ref bounds,\n+                                                                               span,\n+                                                                               .. }) => {\n+                    self.visit_ident(span, ident);\n+                    visit::walk_ty_param_bounds_helper(self, bounds);\n+                }\n+                &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ id,\n+                                                                         ref path,\n+                                                                         ref ty,\n+                                                                         .. }) => {\n+                    self.visit_path(path, id);\n+                    self.visit_ty(&**ty);\n+                }\n+            }\n         }\n     }\n \n@@ -486,7 +500,12 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n             visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            visit::walk_ty_param_bounds_helper(&mut collector, &predicate.bounds);\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounds, ..}) => {\n+                    visit::walk_ty_param_bounds_helper(&mut collector, bounds);\n+                }\n+                &ast::WherePredicate::EqPredicate(_) => unimplemented!()\n+            }\n         }\n     }\n "}, {"sha": "d3b1c2d2afc4d0174f7c6336bf53ffb1b8972413", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> Substs<'tcx> {\n         }\n     }\n \n-pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().map(|&t| t)\n     }\n \n@@ -123,6 +123,13 @@ pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         s\n     }\n \n+    pub fn with_assoc_tys(&self, assoc_tys: Vec<Ty<'tcx>>) -> Substs<'tcx> {\n+        assert!(self.types.is_empty_in(AssocSpace));\n+        let mut s = (*self).clone();\n+        s.types.replace(AssocSpace, assoc_tys);\n+        s\n+    }\n+\n     pub fn erase_regions(self) -> Substs<'tcx> {\n         let Substs { types, regions: _ } = self;\n         Substs { types: types, regions: ErasedRegions }"}, {"sha": "159b6961782c04a55c4015aeedd8c024ef35de49", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -10,7 +10,7 @@\n // except according to those terms.\n \n use middle::subst;\n-use middle::subst::{ParamSpace, Substs, VecPerParamSpace};\n+use middle::subst::{ParamSpace, Substs, VecPerParamSpace, Subst};\n use middle::infer::InferCtxt;\n use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n@@ -139,7 +139,7 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n }\n \n // determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n+// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -149,7 +149,18 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-    infcx.fresh_substs_for_generics(span, &impl_generics)\n+    let input_substs = infcx.fresh_substs_for_generics(span, &impl_generics);\n+\n+    // Add substs for the associated types bound in the impl.\n+    let ref items = tcx.impl_items.borrow()[impl_def_id];\n+    let mut assoc_tys = Vec::new();\n+    for item in items.iter() {\n+        if let &ty::ImplOrTraitItemId::TypeTraitItemId(id) = item {\n+            assoc_tys.push(tcx.tcache.borrow()[id].ty.subst(tcx, &input_substs));\n+        }\n+    }\n+\n+    input_substs.with_assoc_tys(assoc_tys)\n }\n \n impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {"}, {"sha": "3f555ec5c4cbe1b6e6598699f09ec74ce953afbc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -1613,7 +1613,7 @@ pub struct RegionParameterDef {\n     pub bounds: Vec<ty::Region>,\n }\n \n-/// Information about the type/lifetime parameters associated with an\n+/// Information about the formal type/lifetime parameters associated with an\n /// item or method. Analogous to ast::Generics.\n #[deriving(Clone, Show)]\n pub struct Generics<'tcx> {"}, {"sha": "e4edfadb3aaa7813ac621a5a90f5af83776f7390", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 105, "deletions": 45, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -84,13 +84,18 @@ pub trait AstConv<'tcx> {\n                                            trait_id: ast::DefId)\n                                            -> bool;\n \n-    /// Returns the binding of the given associated type for some type.\n+    /// Returns the concrete type bound to the given associated type (indicated\n+    /// by associated_type_id) in the current context. For example,\n+    /// in `trait Foo { type A; }` looking up `A` will give a type variable;\n+    /// in `impl Foo for ... { type A = int; ... }` looking up `A` will give `int`.\n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n+                               // DefId for the declaration of the trait\n+                               // in which the associated type is declared.\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx>;\n+                               -> Option<Ty<'tcx>>;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -208,7 +213,6 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     rscope: &RS,\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n-    self_ty: Option<Ty<'tcx>>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -226,19 +230,26 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n-    let (regions, types) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, path.span, E0169,\n                       \"parenthesized parameters may only be used with a trait\");\n-            (Vec::new(), convert_parenthesized_parameters(this, data))\n+            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n     };\n \n-    create_substs_for_ast_path(this, rscope, path.span, decl_def_id,\n-                               decl_generics, self_ty, types, regions)\n+    create_substs_for_ast_path(this,\n+                               rscope,\n+                               path.span,\n+                               decl_def_id,\n+                               decl_generics,\n+                               None,\n+                               types,\n+                               regions,\n+                               assoc_bindings)\n }\n \n fn create_substs_for_ast_path<'tcx,AC,RS>(\n@@ -249,7 +260,8 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>)\n+    regions: Vec<ty::Region>,\n+    assoc_bindings: Vec<(ast::Ident, Ty<'tcx>)>)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -356,13 +368,41 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n         }\n     }\n \n-    for param in decl_generics.types.get_slice(AssocSpace).iter() {\n-        substs.types.push(\n-            AssocSpace,\n-            this.associated_type_binding(span,\n-                                         self_ty,\n-                                         decl_def_id,\n-                                         param.def_id));\n+    for formal_assoc in decl_generics.types.get_slice(AssocSpace).iter() {\n+        let mut found = false;\n+        for &(ident, ty) in assoc_bindings.iter() {\n+            if formal_assoc.name.ident() == ident {\n+                substs.types.push(AssocSpace, ty);\n+                found = true;\n+                break;\n+            }\n+        }\n+        if !found {\n+            match this.associated_type_binding(span,\n+                                               self_ty,\n+                                               decl_def_id,\n+                                               formal_assoc.def_id) {\n+                Some(ty) => {\n+                    substs.types.push(AssocSpace, ty);\n+                }\n+                None => {\n+                    substs.types.push(AssocSpace, ty::mk_err());\n+                    span_err!(this.tcx().sess, span, E0171,\n+                              \"missing type for associated type `{}`\",\n+                              token::get_ident(formal_assoc.name.ident()));\n+                }\n+            }\n+        }\n+    }\n+\n+    for &(ident, _) in assoc_bindings.iter() {\n+        let mut formal_idents = decl_generics.types.get_slice(AssocSpace)\n+                                .iter().map(|t| t.name.ident());\n+        if !formal_idents.any(|i| i == ident) {\n+            span_err!(this.tcx().sess, span, E0177,\n+                      \"associated type `{}` does not exist\",\n+                      token::get_ident(ident));\n+        }\n     }\n \n     return substs;\n@@ -371,7 +411,9 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>, Vec<Ty<'tcx>>)\n+                                                    -> (Vec<ty::Region>,\n+                                                        Vec<Ty<'tcx>>,\n+                                                        Vec<(ast::Ident, Ty<'tcx>)>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -384,7 +426,12 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n         .map(|t| ast_ty_to_ty(this, rscope, &**t))\n         .collect();\n \n-    (regions, types)\n+    let assoc_bindings: Vec<_> =\n+        data.bindings.iter()\n+        .map(|b| (b.ident, ast_ty_to_ty(this, rscope, &*b.ty)))\n+        .collect();\n+\n+    (regions, types, assoc_bindings)\n }\n \n /// Returns the appropriate lifetime to use for any output lifetimes\n@@ -468,24 +515,15 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n-pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n-    ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<Ty<'tcx>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n-{\n-    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty)\n-}\n \n /// Instantiates the path for the given trait reference, assuming that it's bound to a valid trait\n /// type. Returns the def_id for the defining trait. Fails if the type is a type other than a trait\n /// type.\n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty<'tcx>>)\n+                                         self_ty: Option<Ty<'tcx>>,\n+                                         allow_eq: AllowEqConstraints)\n                                          -> Rc<ty::TraitRef<'tcx>>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n@@ -494,8 +532,12 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                            ast_trait_ref.path.span,\n                            ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n-            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id,\n-                                                          self_ty, &ast_trait_ref.path));\n+            let trait_ref = Rc::new(ast_path_to_trait_ref(this,\n+                                                          rscope,\n+                                                          trait_def_id,\n+                                                          self_ty,\n+                                                          &ast_trait_ref.path,\n+                                                          allow_eq));\n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n             trait_ref\n@@ -508,15 +550,23 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n+#[deriving(PartialEq,Show)]\n+pub enum AllowEqConstraints {\n+    Allow,\n+    DontAllow\n+}\n+\n fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n-    path: &ast::Path)\n+    path: &ast::Path,\n+    allow_eq: AllowEqConstraints)\n     -> ty::TraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n+    debug!(\"ast_path_to_trait_ref {}\", path);\n     let trait_def = this.get_trait_def(trait_def_id);\n \n     // the trait reference introduces a binding level here, so\n@@ -526,23 +576,29 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     // lifetimes. Oh well, not there yet.\n     let shifted_rscope = ShiftedRscope::new(rscope);\n \n-    let (regions, types) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             convert_angle_bracketed_parameters(this, &shifted_rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            (Vec::new(), convert_parenthesized_parameters(this, data))\n+            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n     };\n \n+    if allow_eq == AllowEqConstraints::DontAllow && assoc_bindings.len() > 0 {\n+        span_err!(this.tcx().sess, path.span, E0173,\n+                  \"equality constraints are not allowed in this position\");\n+    }\n+\n     let substs = create_substs_for_ast_path(this,\n                                             &shifted_rscope,\n                                             path.span,\n                                             trait_def_id,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n-                                            regions);\n+                                            regions,\n+                                            assoc_bindings);\n \n     ty::TraitRef::new(trait_def_id, substs)\n }\n@@ -564,7 +620,6 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                         rscope,\n                                         did,\n                                         &generics,\n-                                        None,\n                                         path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n@@ -605,7 +660,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs_for_ty(this, rscope, did, &generics, None, path)\n+        ast_path_substs_for_ty(this, rscope, did, &generics, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -694,7 +749,8 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                                     rscope,\n                                                     trait_def_id,\n                                                     None,\n-                                                    path));\n+                                                    path,\n+                                                    AllowEqConstraints::Allow));\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -703,7 +759,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n             }\n         }\n         _ => {\n-            span_err!(this.tcx().sess, ty.span, E0171,\n+            span_err!(this.tcx().sess, ty.span, E0178,\n                       \"expected a path on the left-hand side of `+`, not `{}`\",\n                       pprust::ty_to_string(ty));\n             match ty.node {\n@@ -714,8 +770,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                pprust::ty_to_string(&*mut_ty.ty),\n                                pprust::bounds_to_string(bounds));\n                 }\n-\n-                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n+               ast::TyRptr(Some(ref lt), ref mut_ty) => {\n                     span_note!(this.tcx().sess, ty.span,\n                                \"perhaps you meant `&{} {}({} +{})`? (per RFC 248)\",\n                                pprust::lifetime_to_string(lt),\n@@ -732,7 +787,6 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n             Err(ErrorReported)\n         }\n     }\n-\n }\n \n fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n@@ -773,7 +827,8 @@ fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n     let trait_ref = instantiate_trait_ref(this,\n                                           rscope,\n                                           &*qpath.trait_ref,\n-                                          Some(self_type));\n+                                          Some(self_type),\n+                                          AllowEqConstraints::DontAllow);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n \n@@ -917,7 +972,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            rscope,\n                                                            trait_def_id,\n                                                            None,\n-                                                           path);\n+                                                           path,\n+                                                           AllowEqConstraints::Allow);\n                         trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1341,7 +1397,11 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None))\n+            Some(instantiate_trait_ref(this,\n+                                       rscope,\n+                                       &trait_bound.trait_ref,\n+                                       None,\n+                                       AllowEqConstraints::Allow))\n         }\n         None => {\n             this.tcx().sess.span_err("}, {"sha": "4d23161f6dee475d5e22d5602546e029c884731a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -310,7 +310,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             substs: rcvr_substs.clone()\n         });\n \n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n                 get_method_index(tcx, &*new_trait_ref,\n                                  trait_ref.clone(), method_num);\n@@ -357,7 +357,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let bounds =\n             self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n             .as_slice();\n-        self.elaborate_bounds(bounds, |this, trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds, true, |this, trait_ref, m, method_num| {\n             let xform_self_ty =\n                 this.xform_self_ty(&m, &trait_ref.substs);\n \n@@ -394,6 +394,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn elaborate_bounds(\n         &mut self,\n         bounds: &[Rc<ty::TraitRef<'tcx>>],\n+        num_includes_types: bool,\n         mk_cand: for<'a> |this: &mut ProbeContext<'a, 'tcx>,\n                           tr: Rc<ty::TraitRef<'tcx>>,\n                           m: Rc<ty::Method<'tcx>>,\n@@ -407,7 +408,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 continue;\n             }\n \n-            let (pos, method) = match trait_method(tcx, bound_trait_ref.def_id, self.method_name) {\n+            let (pos, method) = match trait_method(tcx,\n+                                                   bound_trait_ref.def_id,\n+                                                   self.method_name,\n+                                                   num_includes_types) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -1003,12 +1007,18 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// index (or `None`, if no such method).\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n+                      method_name: ast::Name,\n+                      num_includes_types: bool)\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     trait_items\n         .iter()\n+        .filter(|item|\n+            num_includes_types || match *item {\n+                &ty::MethodTraitItem(_) => true,\n+                &ty::TypeTraitItem(_) => false\n+            })\n         .enumerate()\n         .find(|&(_, ref item)| item.name() == method_name)\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n@@ -1025,7 +1035,7 @@ fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // iterating down the supertraits of the object's trait until\n     // we find the trait the method came from, counting up the\n     // methods from them.\n-    let mut method_count = 0;\n+    let mut method_count = n_method;\n     ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n         if bound_ref.def_id == trait_ref.def_id {\n             false\n@@ -1040,7 +1050,7 @@ fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n             true\n         }\n     });\n-    method_count + n_method\n+    method_count\n }\n \n impl<'tcx> Candidate<'tcx> {"}, {"sha": "7e29e7078d4889fb1aed849c2cd8e0145c4cb0e3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -112,7 +112,7 @@ use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::{mod, abi, attr};\n-use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem};\n+use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{mod, local_def, PostExpansionMethod};\n use syntax::codemap::{mod, Span};\n use syntax::owned_slice::OwnedSlice;\n@@ -1585,9 +1585,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n                                _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n-        ty::mk_err()\n+        Some(ty::mk_err())\n     }\n }\n \n@@ -5281,10 +5281,18 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          found {} parameter(s)\",\n                          type_count, data.types.len());\n                     substs.types.truncate(space, 0);\n+                    break;\n                 }\n             }\n         }\n \n+        if data.bindings.len() > 0 {\n+            span_err!(fcx.tcx().sess, data.bindings[0].span, E0182,\n+                      \"unexpected binding of associated item in expression path \\\n+                       (only allowed in type paths)\");\n+            substs.types.truncate(subst::ParamSpace::AssocSpace, 0);\n+        }\n+\n         {\n             let region_count = region_defs.len(space);\n             assert_eq!(substs.regions().len(space), 0);\n@@ -5299,6 +5307,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         region_count,\n                         data.lifetimes.len());\n                     substs.mut_regions().truncate(space, 0);\n+                    break;\n                 }\n             }\n         }"}, {"sha": "defad95f749bd01761ff07687b491fe6d68123f3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -562,7 +562,7 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n     } else {\n         return // everything OK\n     };\n-    span_err!(tcx.sess, sp, E0173, \"manual implementations of `{}` are experimental\", trait_name);\n+    span_err!(tcx.sess, sp, E0183, \"manual implementations of `{}` are experimental\", trait_name);\n     span_help!(tcx.sess, sp,\n                \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n }"}, {"sha": "6b7f08e810451fe43ecae510ddcfb0a78080a452", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 79, "deletions": 62, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -32,7 +32,7 @@ as `ty_param()` instances.\n use self::ConvertMethodContext::*;\n use self::CreateTypeParametersForAssociatedTypesFlag::*;\n \n-use astconv::{AstConv, ty_of_arg};\n+use astconv::{AstConv, ty_of_arg, AllowEqConstraints};\n use astconv::{ast_ty_to_ty, ast_region_to_region};\n use astconv;\n use metadata::csearch;\n@@ -197,10 +197,10 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n                                _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         self.tcx().sess.span_err(span, \"associated types may not be \\\n                                         referenced here\");\n-        ty::mk_err()\n+        Some(ty::mk_err())\n     }\n }\n \n@@ -663,48 +663,43 @@ fn is_associated_type_valid_for_param(ty: Ty,\n \n fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                           span: Span,\n-                                          ty: Option<Ty<'tcx>>,\n+                                          self_ty: Option<Ty<'tcx>>,\n                                           associated_type_id: ast::DefId,\n                                           generics: &ty::Generics<'tcx>)\n-                                          -> Ty<'tcx>\n+                                          -> Option<Ty<'tcx>>\n {\n     debug!(\"find_associated_type_in_generics(ty={}, associated_type_id={}, generics={}\",\n-           ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n+           self_ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n \n-    let ty = match ty {\n+    let self_ty = match self_ty {\n         None => {\n-            tcx.sess.span_bug(span,\n-                              \"find_associated_type_in_generics(): no self \\\n-                               type\")\n+            return None;\n         }\n         Some(ty) => ty,\n     };\n \n-    match ty.sty {\n+    match self_ty.sty {\n         ty::ty_param(ref param_ty) => {\n-            /*let type_parameter = generics.types.get(param_ty.space,\n-                                                    param_ty.idx);\n-            let param_id = type_parameter.def_id;*/\n             let param_id = param_ty.def_id;\n             for type_parameter in generics.types.iter() {\n                 if type_parameter.def_id == associated_type_id\n                     && type_parameter.associated_with == Some(param_id) {\n-                    return ty::mk_param_from_def(tcx, type_parameter);\n+                    return Some(ty::mk_param_from_def(tcx, type_parameter));\n                 }\n             }\n \n             tcx.sess.span_err(\n                 span,\n                 format!(\"no suitable bound on `{}`\",\n-                        ty.user_string(tcx))[]);\n-            ty::mk_err()\n+                        self_ty.user_string(tcx))[]);\n+            Some(ty::mk_err())\n         }\n         _ => {\n             tcx.sess.span_err(\n                 span,\n                 \"it is currently unsupported to access associated types except \\\n                  through a type parameter; this restriction will be lifted in time\");\n-            ty::mk_err()\n+            Some(ty::mk_err())\n         }\n     }\n }\n@@ -762,16 +757,16 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx>\n+                               -> Option<Ty<'tcx>>\n     {\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n+            // It's an associated type on the trait that we're\n+            // implementing.\n             Some(trait_ref_id) if trait_ref_id == trait_id => {\n-                // It's an associated type on the trait that we're\n-                // implementing.\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n                 assert!(trait_def.generics.types\n                         .get_slice(subst::AssocSpace)\n                         .iter()\n@@ -782,7 +777,7 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n                         ast::MethodImplItem(_) => {}\n                         ast::TypeImplItem(ref typedef) => {\n                             if associated_type.name() == typedef.ident.name {\n-                                return self.ccx.to_ty(&ExplicitRscope, &*typedef.typ)\n+                                return Some(self.ccx.to_ty(&ExplicitRscope, &*typedef.typ))\n                             }\n                         }\n                     }\n@@ -801,7 +796,7 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.impl_generics)\n     }\n@@ -840,17 +835,17 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::FnCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.generics)\n     }\n@@ -887,17 +882,17 @@ impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.method_generics)\n     }\n@@ -943,10 +938,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n \n         // If this is one of our own associated types, return it.\n@@ -957,10 +952,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n                     ast::TypeTraitItem(ref item) => {\n                         if local_def(item.ty_param.id) == associated_type_id {\n-                            return ty::mk_param(self.tcx(),\n-                                                subst::AssocSpace,\n-                                                index,\n-                                                associated_type_id)\n+                            return Some(ty::mk_param(self.tcx(),\n+                                                     subst::AssocSpace,\n+                                                     index,\n+                                                     associated_type_id))\n                         }\n                         index += 1;\n                     }\n@@ -979,7 +974,7 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.method_generics)\n     }\n@@ -1020,17 +1015,17 @@ impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n         // our bounds.\n         find_associated_type_in_generics(self.chain.tcx(),\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.associated_types_generics)\n     }\n@@ -1142,8 +1137,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                astconv::instantiate_trait_ref(&icx, &ExplicitRscope, trait_ref,\n-                                               Some(selfty));\n+                astconv::instantiate_trait_ref(&icx,\n+                                               &ExplicitRscope,\n+                                               trait_ref,\n+                                               Some(selfty),\n+                                               AllowEqConstraints::DontAllow);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1361,8 +1359,12 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let self_param_ty = ty::ParamTy::for_self(def_id);\n \n-    let bounds = compute_bounds(ccx, token::SELF_KEYWORD_NAME, self_param_ty,\n-                                bounds.as_slice(), unbound, it.span,\n+    let bounds = compute_bounds(ccx,\n+                                token::SELF_KEYWORD_NAME,\n+                                self_param_ty,\n+                                bounds.as_slice(),\n+                                unbound,\n+                                it.span,\n                                 &generics.where_clause);\n \n     let substs = mk_item_substs(ccx, &ty_generics);\n@@ -1806,7 +1808,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     return result;\n \n-    fn create_type_parameters_for_associated_types<'tcx,AC>(\n+    fn create_type_parameters_for_associated_types<'tcx, AC>(\n         this: &AC,\n         space: subst::ParamSpace,\n         types: &[ast::TyParam],\n@@ -1856,8 +1858,17 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                 let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n                 let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n \n+                // Find any associated type bindings in the bound.\n+                let ref segments = ast_trait_ref.trait_ref.path.segments;\n+                let bindings = segments[segments.len() -1].parameters.bindings();\n+\n                 // Iterate over each associated type `Elem`\n                 for associated_type_def in associated_type_defs.iter() {\n+                    if bindings.iter().any(|b| associated_type_def.name.ident() == b.ident) {\n+                        // Don't add a variable for a bound associated type.\n+                        continue;\n+                    }\n+\n                     // Create the fresh type parameter `A`\n                     let def = ty::TypeParameterDef {\n                         name: associated_type_def.name,\n@@ -2016,10 +2027,11 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_poly_trait_ref(this,\n-                                                &ExplicitRscope,\n-                                                bound,\n-                                                Some(param_ty.to_ty(this.tcx())))\n+            astconv::instantiate_trait_ref(this,\n+                                           &ExplicitRscope,\n+                                           &bound.trait_ref,\n+                                           Some(param_ty.to_ty(this.tcx())),\n+                                           AllowEqConstraints::Allow)\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n@@ -2047,18 +2059,23 @@ fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n     }\n \n     for predicate in where_clause.predicates.iter() {\n-        let predicate_param_id =\n-            tcx.def_map\n-               .borrow()\n-               .get(&predicate.id)\n-               .expect(\"compute_bounds(): resolve didn't resolve the type \\\n-                        parameter identifier in a `where` clause\")\n-               .def_id();\n-        if param_ty.def_id != predicate_param_id {\n-            continue\n-        }\n-        for bound in predicate.bounds.iter() {\n-            result.push(bound);\n+        match predicate {\n+            &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                let predicate_param_id =\n+                    tcx.def_map\n+                       .borrow()\n+                       .get(&bound_pred.id)\n+                       .expect(\"merge_param_bounds(): resolve didn't resolve the \\\n+                                type parameter identifier in a `where` clause\")\n+                       .def_id();\n+                if param_ty.def_id != predicate_param_id {\n+                    continue\n+                }\n+                for bound in bound_pred.bounds.iter() {\n+                    result.push(bound);\n+                }\n+            }\n+            &ast::WherePredicate::EqPredicate(_) => panic!(\"not implemented\")\n         }\n     }\n "}, {"sha": "ecd3cafd91f1617b24fa1b8d962ac1e9ac85b562", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -149,5 +149,11 @@ register_diagnostics!(\n     E0171,\n     E0172,\n     E0173, // manual implementations of unboxed closure traits are experimental\n-    E0174 // explicit use of unboxed closure methods are experimental\n+    E0174, // explicit use of unboxed closure methods are experimental\n+    E0177,\n+    E0178,\n+    E0180,\n+    E0181,\n+    E0182,\n+    E0183\n )"}, {"sha": "630d41fa7e209b7a31ec39288f94091526bfc6b1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -693,9 +693,16 @@ pub struct WherePredicate {\n \n impl Clean<WherePredicate> for ast::WherePredicate {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n-        WherePredicate {\n-            name: self.ident.clean(cx),\n-            bounds: self.bounds.clean(cx)\n+        match *self {\n+            ast::WherePredicate::BoundPredicate(ref wbp) => {\n+                WherePredicate {\n+                    name: wbp.ident.clean(cx),\n+                    bounds: wbp.bounds.clean(cx)\n+                }\n+            }\n+            ast::WherePredicate::EqPredicate(_) => {\n+                unimplemented!();\n+            }\n         }\n     }\n }"}, {"sha": "ea8de458ce2255dd059906af3fe442fb1ec6a539", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -255,6 +255,7 @@ impl PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: Vec::new(),\n             types: OwnedSlice::empty(),\n+            bindings: OwnedSlice::empty(),\n         })\n     }\n \n@@ -307,6 +308,17 @@ impl PathParameters {\n             }\n         }\n     }\n+\n+    pub fn bindings(&self) -> Vec<&P<TypeBinding>> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.bindings.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n }\n \n /// A path like `Foo<'a, T>`\n@@ -316,11 +328,14 @@ pub struct AngleBracketedParameterData {\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: OwnedSlice<P<Ty>>,\n+    /// Bindings (equality constraints) on associated types, if present.\n+    /// E.g., `Foo<A=Bar>`.\n+    pub bindings: OwnedSlice<P<TypeBinding>>,\n }\n \n impl AngleBracketedParameterData {\n     fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty()\n+        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n     }\n }\n \n@@ -406,13 +421,27 @@ pub struct WhereClause {\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct WherePredicate {\n+pub enum WherePredicate {\n+    BoundPredicate(WhereBoundPredicate),\n+    EqPredicate(WhereEqPredicate)\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WhereBoundPredicate {\n     pub id: NodeId,\n     pub span: Span,\n     pub ident: Ident,\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WhereEqPredicate {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub path: Path,\n+    pub ty: P<Ty>,\n+}\n+\n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n pub type CrateConfig = Vec<P<MetaItem>> ;\n@@ -1118,6 +1147,16 @@ impl FloatTy {\n     }\n }\n \n+// Bind a type to an associated type: `A=Foo`.\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct TypeBinding {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub ty: P<Ty>,\n+    pub span: Span,\n+}\n+\n+\n // NB PartialEq method appears below.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Ty {"}, {"sha": "eec3f69ee64de2d073c835529fe40e2ac3e2bd43", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -174,12 +174,28 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n                 parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: Vec::new(),\n                     types: OwnedSlice::empty(),\n+                    bindings: OwnedSlice::empty(),\n                 })\n             }\n         ),\n     }\n }\n \n+// If path is a single segment ident path, return that ident. Otherwise, return\n+// None.\n+pub fn path_to_ident(path: &Path) -> Option<Ident> {\n+    if path.segments.len() != 1 {\n+        return None;\n+    }\n+\n+    let segment = &path.segments[0];\n+    if !segment.parameters.is_empty() {\n+        return None;\n+    }\n+\n+    Some(segment.identifier)\n+}\n+\n pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n     P(Pat {\n         id: id,"}, {"sha": "84040bcfa9f05b26203bbdd7005951db4474eebd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -37,7 +37,8 @@ pub trait AstBuilder {\n                 global: bool,\n                 idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>> )\n+                types: Vec<P<ast::Ty>>,\n+                bindings: Vec<P<ast::TypeBinding>> )\n         -> ast::Path;\n \n     // types\n@@ -293,20 +294,21 @@ pub trait AstBuilder {\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, false, strs, Vec::new(), Vec::new())\n+        self.path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec!(id))\n     }\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, true, strs, Vec::new(), Vec::new())\n+        self.path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>> )\n+                types: Vec<P<ast::Ty>>,\n+                bindings: Vec<P<ast::TypeBinding>> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n@@ -321,6 +323,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: OwnedSlice::from_vec(types),\n+                bindings: OwnedSlice::from_vec(bindings),\n             })\n         });\n         ast::Path {\n@@ -391,7 +394,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               self.ident_of(\"Option\")\n                           ),\n                           Vec::new(),\n-                          vec!( ty )))\n+                          vec!( ty ),\n+                          Vec::new()))\n     }\n \n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {"}, {"sha": "cf3b3ad9051aadabd6528d699b5ba7144b181afb", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -444,7 +444,7 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n-                        self_ty_params.into_vec()));\n+                        self_ty_params.into_vec(), Vec::new()));\n \n         let attr = cx.attribute(\n             self.span,"}, {"sha": "56d11c2377fa4f58050b1d162663aeccaf31bfbc", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -80,7 +80,7 @@ impl<'a> Path<'a> {\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys = self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n \n-        cx.path_all(span, self.global, idents, lt, tys)\n+        cx.path_all(span, self.global, idents, lt, tys, Vec::new())\n     }\n }\n \n@@ -177,7 +177,7 @@ impl<'a> Ty<'a> {\n                                                        .collect();\n \n                 cx.path_all(span, false, vec!(self_ty), lifetimes,\n-                            self_params.into_vec())\n+                            self_params.into_vec(), Vec::new())\n             }\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)"}, {"sha": "c4e64d58c293285cff8dba4786ca8ca12f21e320", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -88,6 +88,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                         true,\n                                         rand_ident.clone(),\n                                         Vec::new(),\n+                                        Vec::new(),\n                                         Vec::new());\n             let rand_name = cx.expr_path(rand_name);\n "}, {"sha": "8c17b31f458d0bf9534419b86826c9290ce50cd3", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -45,7 +45,8 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                                    Some(cx.lifetime(sp,\n                                                         cx.ident_of(\n                                                             \"'static\").name)),\n-                                                   ast::MutImmutable))))\n+                                                   ast::MutImmutable)),\n+                                   Vec::new()))\n       }\n       Some(s) => {\n           cx.expr_call_global(sp,"}, {"sha": "5d595474e9c70e33c25f0fde134030ace1e98d55", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -530,6 +530,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.fmtsp,\n                     true, Context::rtpath(self.ecx, \"Argument\"),\n                     vec![static_lifetime],\n+                    vec![],\n                     vec![]\n                 ));\n             lets.push(Context::item_static_array(self.ecx,"}, {"sha": "69e311c57f5ab6475439bab9dfc86228c6cf04ec", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -146,6 +146,10 @@ pub trait Folder {\n         noop_fold_qpath(t, self)\n     }\n \n+    fn fold_ty_binding(&mut self, t: P<TypeBinding>) -> P<TypeBinding> {\n+        noop_fold_ty_binding(t, self)\n+    }\n+\n     fn fold_mod(&mut self, m: Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n@@ -391,6 +395,15 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>\n     })\n }\n \n+pub fn noop_fold_ty_binding<T: Folder>(b: P<TypeBinding>, fld: &mut T) -> P<TypeBinding> {\n+    b.map(|TypeBinding { id, ident, ty, span }| TypeBinding {\n+        id: fld.new_id(id),\n+        ident: ident,\n+        ty: fld.fold_ty(ty),\n+        span: fld.new_span(span),\n+    })\n+}\n+\n pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n@@ -533,9 +546,10 @@ pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedP\n                                                            fld: &mut T)\n                                                            -> AngleBracketedParameterData\n {\n-    let AngleBracketedParameterData { lifetimes, types } = data;\n+    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n     AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n-                                  types: types.move_map(|ty| fld.fold_ty(ty)) }\n+                                  types: types.move_map(|ty| fld.fold_ty(ty)),\n+                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)) }\n }\n \n pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n@@ -807,14 +821,32 @@ pub fn noop_fold_where_clause<T: Folder>(\n }\n \n pub fn noop_fold_where_predicate<T: Folder>(\n-                                 WherePredicate {id, ident, bounds, span}: WherePredicate,\n+                                 pred: WherePredicate,\n                                  fld: &mut T)\n                                  -> WherePredicate {\n-    WherePredicate {\n-        id: fld.new_id(id),\n-        ident: fld.fold_ident(ident),\n-        bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-        span: fld.new_span(span)\n+    match pred {\n+        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{id,\n+                                                                     ident,\n+                                                                     bounds,\n+                                                                     span}) => {\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                id: fld.new_id(id),\n+                ident: fld.fold_ident(ident),\n+                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n+                span: fld.new_span(span)\n+            })\n+        }\n+        ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n+                                                               path,\n+                                                               ty,\n+                                                               span}) => {\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{\n+                id: fld.new_id(id),\n+                path: fld.fold_path(path),\n+                ty:fld.fold_ty(ty),\n+                span: fld.new_span(span)\n+            })\n+        }\n     }\n }\n "}, {"sha": "92c7380a61ded196fda7f37145ef83bb8810ce1f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 135, "deletions": 42, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -53,7 +53,7 @@ use ast::{StructVariantKind, BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n-use ast::{TupleVariantKind, Ty, Ty_};\n+use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n@@ -62,7 +62,7 @@ use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use ast::{Visibility, WhereClause, WherePredicate};\n+use ast::{Visibility, WhereClause};\n use ast;\n use ast_util::{mod, as_prec, ident_to_path, operator_prec};\n use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp};\n@@ -769,13 +769,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a sequence bracketed by '<' and '>', stopping\n-    /// before the '>'.\n-    pub fn parse_seq_to_before_gt<T>(\n-                                  &mut self,\n-                                  sep: Option<token::Token>,\n-                                  f: |&mut Parser| -> T)\n-                                  -> OwnedSlice<T> {\n+    pub fn parse_seq_to_before_gt_or_return<T>(&mut self,\n+                                               sep: Option<token::Token>,\n+                                               f: |&mut Parser| -> Option<T>)\n+                                               -> (OwnedSlice<T>, bool) {\n         let mut v = Vec::new();\n         // This loop works by alternating back and forth between parsing types\n         // and commas.  For example, given a string `A, B,>`, the parser would\n@@ -792,24 +789,48 @@ impl<'a> Parser<'a> {\n             }\n \n             if i % 2 == 0 {\n-                v.push(f(self));\n+                match f(self) {\n+                    Some(result) => v.push(result),\n+                    None => return (OwnedSlice::from_vec(v), true)\n+                }\n             } else {\n                 sep.as_ref().map(|t| self.expect(t));\n             }\n         }\n-        return OwnedSlice::from_vec(v);\n+        return (OwnedSlice::from_vec(v), false);\n+    }\n+\n+    /// Parse a sequence bracketed by '<' and '>', stopping\n+    /// before the '>'.\n+    pub fn parse_seq_to_before_gt<T>(&mut self,\n+                                     sep: Option<token::Token>,\n+                                     f: |&mut Parser| -> T)\n+                                     -> OwnedSlice<T> {\n+        let (result, returned) = self.parse_seq_to_before_gt_or_return(sep, |p| Some(f(p)));\n+        assert!(!returned);\n+        return result;\n     }\n \n-    pub fn parse_seq_to_gt<T>(\n-                           &mut self,\n-                           sep: Option<token::Token>,\n-                           f: |&mut Parser| -> T)\n-                           -> OwnedSlice<T> {\n+    pub fn parse_seq_to_gt<T>(&mut self,\n+                              sep: Option<token::Token>,\n+                              f: |&mut Parser| -> T)\n+                              -> OwnedSlice<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n     }\n \n+    pub fn parse_seq_to_gt_or_return<T>(&mut self,\n+                                        sep: Option<token::Token>,\n+                                        f: |&mut Parser| -> Option<T>)\n+                                        -> (OwnedSlice<T>, bool) {\n+        let (v, returned) = self.parse_seq_to_before_gt_or_return(sep, f);\n+        if !returned {\n+            self.expect_gt();\n+        }\n+        return (v, returned);\n+    }\n+\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -1842,11 +1863,12 @@ impl<'a> Parser<'a> {\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt(false) {\n-                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt();\n \n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: OwnedSlice::from_vec(types),\n+                    bindings: OwnedSlice::from_vec(bindings),\n                 })\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n                 let inputs = self.parse_seq_to_end(\n@@ -1894,6 +1916,7 @@ impl<'a> Parser<'a> {\n                     parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                         lifetimes: Vec::new(),\n                         types: OwnedSlice::empty(),\n+                        bindings: OwnedSlice::empty(),\n                     })\n                 });\n                 return segments;\n@@ -1902,12 +1925,13 @@ impl<'a> Parser<'a> {\n             // Check for a type segment.\n             if self.eat_lt(false) {\n                 // Consumed `a::b::<`, go look for types\n-                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt();\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n                         types: OwnedSlice::from_vec(types),\n+                        bindings: OwnedSlice::from_vec(bindings),\n                     }),\n                 });\n \n@@ -2435,13 +2459,18 @@ impl<'a> Parser<'a> {\n                     let dot = self.last_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n-                    let (_, tys) = if self.eat(&token::ModSep) {\n+                    let (_, tys, bindings) = if self.eat(&token::ModSep) {\n                         self.expect_lt();\n                         self.parse_generic_values_after_lt()\n                     } else {\n-                        (Vec::new(), Vec::new())\n+                        (Vec::new(), Vec::new(), Vec::new())\n                     };\n \n+                    if bindings.len() > 0 {\n+                        let last_span = self.last_span;\n+                        self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n+                    }\n+\n                     // expr.f() method call\n                     match self.token {\n                         token::OpenDelim(token::Paren) => {\n@@ -4041,16 +4070,51 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> (Vec<ast::Lifetime>, Vec<P<Ty>> ) {\n+    fn parse_generic_values_after_lt(&mut self)\n+                                     -> (Vec<ast::Lifetime>, Vec<P<Ty>>, Vec<P<TypeBinding>>) {\n         let lifetimes = self.parse_lifetimes(token::Comma);\n-        let result = self.parse_seq_to_gt(\n+\n+        // First parse types.\n+        let (types, returned) = self.parse_seq_to_gt_or_return(\n+            Some(token::Comma),\n+            |p| {\n+                p.forbid_lifetime();\n+                if p.look_ahead(1, |t| t == &token::Eq) {\n+                    None\n+                } else {\n+                    Some(p.parse_ty_sum())\n+                }\n+            }\n+        );\n+\n+        // If we found the `>`, don't continue.\n+        if !returned {\n+            return (lifetimes, types.into_vec(), Vec::new());\n+        }\n+\n+        // Then parse type bindings.\n+        let bindings = self.parse_seq_to_gt(\n             Some(token::Comma),\n             |p| {\n                 p.forbid_lifetime();\n-                p.parse_ty_sum()\n+                let lo = p.span.lo;\n+                let ident = p.parse_ident();\n+                let found_eq = p.eat(&token::Eq);\n+                if !found_eq {\n+                    let span = p.span;\n+                    p.span_warn(span, \"whoops, no =?\");\n+                }\n+                let ty = p.parse_ty();\n+                let hi = p.span.hi;\n+                let span = mk_sp(lo, hi);\n+                return P(TypeBinding{id: ast::DUMMY_NODE_ID,\n+                    ident: ident,\n+                    ty: ty,\n+                    span: span,\n+                });\n             }\n         );\n-        (lifetimes, result.into_vec())\n+        (lifetimes, types.into_vec(), bindings.into_vec())\n     }\n \n     fn forbid_lifetime(&mut self) {\n@@ -4070,29 +4134,58 @@ impl<'a> Parser<'a> {\n         let mut parsed_something = false;\n         loop {\n             let lo = self.span.lo;\n-            let ident = match self.token {\n-                token::Ident(..) => self.parse_ident(),\n+            let path = match self.token {\n+                token::Ident(..) => self.parse_path(NoTypesAllowed),\n                 _ => break,\n             };\n-            self.expect(&token::Colon);\n \n-            let bounds = self.parse_ty_param_bounds();\n-            let hi = self.span.hi;\n-            let span = mk_sp(lo, hi);\n+            if self.eat(&token::Colon) {\n+                let bounds = self.parse_ty_param_bounds();\n+                let hi = self.span.hi;\n+                let span = mk_sp(lo, hi);\n \n-            if bounds.len() == 0 {\n-                self.span_err(span,\n-                              \"each predicate in a `where` clause must have \\\n-                               at least one bound in it\");\n-            }\n+                if bounds.len() == 0 {\n+                    self.span_err(span,\n+                                  \"each predicate in a `where` clause must have \\\n+                                   at least one bound in it\");\n+                }\n \n-            generics.where_clause.predicates.push(ast::WherePredicate {\n-                id: ast::DUMMY_NODE_ID,\n-                span: span,\n-                ident: ident,\n-                bounds: bounds,\n-            });\n-            parsed_something = true;\n+                let ident = match ast_util::path_to_ident(&path) {\n+                    Some(ident) => ident,\n+                    None => {\n+                        self.span_err(path.span, \"expected a single identifier \\\n+                                                  in bound where clause\");\n+                        break;\n+                    }\n+                };\n+\n+                generics.where_clause.predicates.push(\n+                    ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: span,\n+                        ident: ident,\n+                        bounds: bounds,\n+                }));\n+                parsed_something = true;\n+            } else if self.eat(&token::Eq) {\n+                let ty = self.parse_ty();\n+                let hi = self.span.hi;\n+                let span = mk_sp(lo, hi);\n+                generics.where_clause.predicates.push(\n+                    ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: span,\n+                        path: path,\n+                        ty: ty,\n+                }));\n+                parsed_something = true;\n+                // FIXME(#18433)\n+                self.span_err(span, \"equality constraints are not yet supported in where clauses\");\n+            } else {\n+                let last_span = self.last_span;\n+                self.span_err(last_span,\n+                              \"unexpected token in `where` clause\");\n+            }\n \n             if !self.eat(&token::Comma) {\n                 break"}, {"sha": "26373d00aaf60d9c57c96b5a5899bb2fc44318f1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -1976,6 +1976,18 @@ impl<'a> State<'a> {\n                         Inconsistent,\n                         data.types.as_slice(),\n                         |s, ty| s.print_type(&**ty)));\n+                        comma = true;\n+                }\n+\n+                for binding in data.bindings.iter() {\n+                    if comma {\n+                        try!(self.word_space(\",\"))\n+                    }\n+                    try!(self.print_ident(binding.ident));\n+                    try!(space(&mut self.s));\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_type(&*binding.ty));\n+                    comma = true;\n                 }\n \n                 try!(word(&mut self.s, \">\"))\n@@ -2437,8 +2449,20 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\",\"));\n             }\n \n-            try!(self.print_ident(predicate.ident));\n-            try!(self.print_bounds(\":\", predicate.bounds.as_slice()));\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ident,\n+                                                                              ref bounds,\n+                                                                              ..}) => {\n+                    try!(self.print_ident(ident));\n+                    try!(self.print_bounds(\":\", bounds.as_slice()));\n+                }\n+                &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n+                    try!(self.print_path(path, false));\n+                    try!(space(&mut self.s));\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_type(&**ty));\n+                }\n+            }\n         }\n \n         Ok(())"}, {"sha": "a36f8b23ca3226d1bdb536a83b52980628a1896c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -573,8 +573,22 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in generics.where_clause.predicates.iter() {\n-        visitor.visit_ident(predicate.span, predicate.ident);\n-        walk_ty_param_bounds_helper(visitor, &predicate.bounds);\n+        match predicate {\n+            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{span,\n+                                                                          ident,\n+                                                                          ref bounds,\n+                                                                          ..}) => {\n+                visitor.visit_ident(span, ident);\n+                walk_ty_param_bounds_helper(visitor, bounds);\n+            }\n+            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n+                                                                    ref path,\n+                                                                    ref ty,\n+                                                                    ..}) => {\n+                visitor.visit_path(path, id);\n+                visitor.visit_ty(&**ty);\n+            }\n+        }\n     }\n }\n "}, {"sha": "00aeb1c1bae8f71a2163f888637fb1af7c44d8a8", "filename": "src/test/compile-fail-fulldeps/phase-syntax-doesnt-resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -19,6 +19,6 @@ extern crate macro_crate_test;\n \n fn main() {\n     macro_crate_test::foo();\n-    //~^ ERROR failed to resolve. Use of undeclared module `macro_crate_test`\n+    //~^ ERROR failed to resolve. Use of undeclared type or module `macro_crate_test`\n     //~^^ ERROR unresolved name `macro_crate_test::foo`\n }"}, {"sha": "4fd53150618749e5a5f0fd762cb1ee92e81a1c2b", "filename": "src/test/compile-fail/assoc-eq-1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-1.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types. Check that unsupported syntax\n+// does not ICE.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+fn foo2<I: Foo>(x: I) {\n+    let _: A = x.boo(); //~ERROR use of undeclared\n+    let _: I::A = x.boo(); //~ERROR failed to resolve\n+    //~^ERROR use of undeclared type name `I::A`\n+}\n+\n+pub fn main() {}"}, {"sha": "652bf4fb57753bf38a6ea1a626e450724539cdbe", "filename": "src/test/compile-fail/assoc-eq-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-2.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types. Check we get an error when an\n+// equality constraint is used in a qualified path.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint { 42 }\n+}\n+\n+fn baz<I: Foo>(x: &<I as Foo<A=Bar>>::A) {} //~ERROR equality constraints are not allowed in this\n+\n+pub fn main() {}"}, {"sha": "880b2e9cc4a77ebf7813e317bd2bc0f4582f27e2", "filename": "src/test/compile-fail/assoc-eq-3.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-3.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types. Check we get type errors\n+// where we should.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint {\n+        42\n+    }\n+}\n+\n+fn foo1<I: Foo<A=Bar>>(x: I) {\n+    let _: Bar = x.boo();\n+}\n+\n+fn foo2<I: Foo>(x: I) {\n+    let _: Bar = x.boo(); //~ERROR mismatched types\n+}\n+\n+\n+pub fn baz(x: &Foo<A=Bar>) {\n+    let _: Bar = x.boo();\n+}\n+\n+\n+pub fn main() {\n+    let a = 42i;\n+    foo1(a); //~ERROR the trait `Foo` is not implemented for the type `int`\n+    baz(&a); //~ERROR the trait `Foo` is not implemented for the type `int`\n+}"}, {"sha": "1a96b0ca6812e357b507e1daea4e8ffd69b5f8b8", "filename": "src/test/compile-fail/assoc-eq-expr-path.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fassoc-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-expr-path.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that an associated type cannot be bound in an expression path.\n+\n+#![feature(associated_types)]\n+\n+trait Foo {\n+    type A;\n+    fn bar() -> int;\n+}\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn bar() -> int { 42 }\n+}\n+\n+pub fn main() {\n+    let x: int = Foo::<A=uint>::bar();\n+    //~^ERROR unexpected binding of associated item in expression path\n+}"}, {"sha": "41a0be37add418a09afb8807c5bb6e9dc3c69c03", "filename": "src/test/compile-fail/hrtb-precedence-of-plus-error-message.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -18,17 +18,17 @@ trait Bar {\n \n struct Foo<'a> {\n     a: &'a Bar+'a,\n-        //~^ ERROR E0171\n+        //~^ ERROR E0178\n         //~^^ NOTE perhaps you meant `&'a (Bar + 'a)`?\n \n     b: &'a mut Bar+'a,\n-        //~^ ERROR E0171\n+        //~^ ERROR E0178\n         //~^^ NOTE perhaps you meant `&'a mut (Bar + 'a)`?\n \n     c: Box<Bar+'a>, // OK, no paren needed in this context\n \n     d: fn() -> Bar+'a,\n-        //~^ ERROR E0171\n+        //~^ ERROR E0178\n         //~^^ NOTE perhaps you forgot parentheses\n         //~^^^ WARN deprecated syntax\n }"}, {"sha": "e4f7521c33303cc340faabfacff70c593b767580", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -31,6 +31,6 @@ impl ToString_ for Point {\n fn main() {\n     let p = Point::new(0.0, 0.0);\n     //~^ ERROR unresolved name `Point::new`\n-    //~^^ ERROR failed to resolve. Use of undeclared module `Point`\n+    //~^^ ERROR failed to resolve. Use of undeclared type or module `Point`\n     println!(\"{}\", p.to_string());\n }"}, {"sha": "4c4fb5572d614a834392db98d33737b3806678f8", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -25,7 +25,7 @@ test!(b,\n #[qux]\n fn main() {\n     a::bar();\n-    //~^ ERROR failed to resolve. Use of undeclared module `a`\n+    //~^ ERROR failed to resolve. Use of undeclared type or module `a`\n     //~^^ ERROR unresolved name `a::bar`\n     b::bar();\n }"}, {"sha": "f1ba382b42dad35a52e62ce9b50499b851400382", "filename": "src/test/run-pass/assoc-eq.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Frun-pass%2Fassoc-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146a919b616e39e528e4d7100d16eef52f1f852/src%2Ftest%2Frun-pass%2Fassoc-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassoc-eq.rs?ref=9146a919b616e39e528e4d7100d16eef52f1f852", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint { 42 }\n+}\n+impl Foo for Bar {\n+    type A = int;\n+    fn boo(&self) -> int { 43 }\n+}\n+impl Foo for char {\n+    type A = Bar;\n+    fn boo(&self) -> Bar { Bar }\n+}\n+\n+fn foo1<I: Foo<A=Bar>>(x: I) -> Bar {\n+    x.boo()\n+}\n+fn foo2<I: Foo>(x: I) -> <I as Foo>::A {\n+    x.boo()\n+}\n+fn baz(x: &Foo<A=Bar>) -> Bar {\n+    x.boo()\n+}\n+\n+pub fn main() {\n+    let a = 42i;\n+    assert!(foo2(a) == 42u);\n+\n+    let a = Bar;\n+    assert!(foo2(a) == 43i);\n+\n+    let a = 'a';\n+    foo1(a);\n+    baz(&a);\n+}"}]}