{"sha": "e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "node_id": "C_kwDOAAsO6NoAKGUyMzAxMTU0ZTNjMzlmNGJmNjA2YjYxMzdkOWNmNWJmMjlhNWY1MmU", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-18T22:48:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-18T22:48:17Z"}, "message": "Rollup merge of #103456 - scottmcm:fix-unchecked-shifts, r=scottmcm\n\n`unchecked_{shl|shr}` should use `u32` as the RHS\n\nThe other shift methods, such as https://doc.rust-lang.org/nightly/std/primitive.u64.html#method.checked_shr and https://doc.rust-lang.org/nightly/std/primitive.i16.html#method.wrapping_shl, use `u32` for the shift amount.  That's consistent with other things, like `count_ones`, which also always use `u32` for a bit count, regardless of the size of the type.\n\nThis PR changes `unchecked_shl` and `unchecked_shr` to also use `u32` for the shift amount (rather than Self).\n\ncc #85122, the `unchecked_math` tracking issue", "tree": {"sha": "42ede50a548eb290598b8241a67a1cdc649ebcaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42ede50a548eb290598b8241a67a1cdc649ebcaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjeAuxCRBK7hj4Ov3rIwAAWXcIAHMd5RotM1MgV9ThYpxBAo18\nQP/aJtZoQg6CBfaT7nQ9SHPH4IS+uaGy9QqdnFiCrht2bHp+mYzPv/ij9bbtQHOo\n6t0jho3lR0fkzHIGi15SLWySfVURmHOSPBefCOmNpFrp1V1YFgnSLZMo0ePKBvDy\niS0G0pTzuWdryX+dCisWCikgtyYcuUa4Er8Cdmnqez5wHOaEllMkeKczoQCguLxN\nGjMJOvMn9r2Q+rUS70qjxwTHO/GUNwsZSZeRVFk9fjhbhyJusyTfOksI2006eVQ5\nc9kHovNNFowPY+8hJktEOz5BpGC3BZDCy8Cycw1LLRBc1kKHmxboQcfX2DZn7fg=\n=8MTW\n-----END PGP SIGNATURE-----\n", "payload": "tree 42ede50a548eb290598b8241a67a1cdc649ebcaa\nparent 6b09d60f82180a9138b0299df1dbc23d78b59920\nparent 9d4b1f98e6761e9a6c77a840fcaec1aea0741669\nauthor Manish Goregaokar <manishsmail@gmail.com> 1668811697 -0500\ncommitter GitHub <noreply@github.com> 1668811697 -0500\n\nRollup merge of #103456 - scottmcm:fix-unchecked-shifts, r=scottmcm\n\n`unchecked_{shl|shr}` should use `u32` as the RHS\n\nThe other shift methods, such as https://doc.rust-lang.org/nightly/std/primitive.u64.html#method.checked_shr and https://doc.rust-lang.org/nightly/std/primitive.i16.html#method.wrapping_shl, use `u32` for the shift amount.  That's consistent with other things, like `count_ones`, which also always use `u32` for a bit count, regardless of the size of the type.\n\nThis PR changes `unchecked_shl` and `unchecked_shr` to also use `u32` for the shift amount (rather than Self).\n\ncc #85122, the `unchecked_math` tracking issue\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "html_url": "https://github.com/rust-lang/rust/commit/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b09d60f82180a9138b0299df1dbc23d78b59920", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b09d60f82180a9138b0299df1dbc23d78b59920", "html_url": "https://github.com/rust-lang/rust/commit/6b09d60f82180a9138b0299df1dbc23d78b59920"}, {"sha": "9d4b1f98e6761e9a6c77a840fcaec1aea0741669", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d4b1f98e6761e9a6c77a840fcaec1aea0741669", "html_url": "https://github.com/rust-lang/rust/commit/9d4b1f98e6761e9a6c77a840fcaec1aea0741669"}], "stats": {"total": 100, "additions": 88, "deletions": 12}, "files": [{"sha": "f1e41b6c69ecd83b646841fa6fa49c687e9f2db5", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "patch": "@@ -131,6 +131,7 @@\n #![feature(const_pin)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_replace)]\n+#![feature(const_result_drop)]\n #![feature(const_ptr_as_ref)]\n #![feature(const_ptr_is_null)]\n #![feature(const_ptr_read)]"}, {"sha": "e1ab7ac5ff045e056a2ba2c26a295867e7137042", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "patch": "@@ -761,10 +761,11 @@ macro_rules! int_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n-            unsafe { intrinsics::unchecked_shl(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shl(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n@@ -808,10 +809,11 @@ macro_rules! int_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`.\n-            unsafe { intrinsics::unchecked_shr(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shr(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked absolute value. Computes `self.abs()`, returning `None` if\n@@ -1358,11 +1360,12 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shl(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shl(rhs & ($BITS - 1))\n             }\n         }\n \n@@ -1387,11 +1390,12 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shr(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shr(rhs & ($BITS - 1))\n             }\n         }\n "}, {"sha": "b2328b001de904368ad0adb8ef7ee8a98a080d67", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "patch": "@@ -3,6 +3,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::ascii;\n+use crate::convert::TryInto;\n use crate::error::Error;\n use crate::intrinsics;\n use crate::mem;"}, {"sha": "af74faa90b11031c954536972b8ab5e9170a0e25", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "patch": "@@ -908,10 +908,11 @@ macro_rules! uint_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n-            unsafe { intrinsics::unchecked_shl(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shl(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked shift right. Computes `self >> rhs`, returning `None`\n@@ -955,10 +956,11 @@ macro_rules! uint_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`.\n-            unsafe { intrinsics::unchecked_shr(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shr(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n@@ -1374,11 +1376,12 @@ macro_rules! uint_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shl(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shl(rhs & ($BITS - 1))\n             }\n         }\n \n@@ -1406,11 +1409,12 @@ macro_rules! uint_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shr(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shr(rhs & ($BITS - 1))\n             }\n         }\n "}, {"sha": "60d0cb09acaf94f85060896078c2a9f9cf796c7b", "filename": "src/test/codegen/unchecked_shifts.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/src%2Ftest%2Fcodegen%2Funchecked_shifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2301154e3c39f4bf606b6137d9cf5bf29a5f52e/src%2Ftest%2Fcodegen%2Funchecked_shifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked_shifts.rs?ref=e2301154e3c39f4bf606b6137d9cf5bf29a5f52e", "patch": "@@ -0,0 +1,66 @@\n+// compile-flags: -O\n+// min-llvm-version: 15.0 (LLVM 13 in CI does this differently from submodule LLVM)\n+// ignore-debug (because unchecked is checked in debug)\n+\n+#![crate_type = \"lib\"]\n+#![feature(unchecked_math)]\n+\n+// CHECK-LABEL: @unchecked_shl_unsigned_same\n+#[no_mangle]\n+pub unsafe fn unchecked_shl_unsigned_same(a: u32, b: u32) -> u32 {\n+    // CHECK-NOT: and i32\n+    // CHECK: shl i32 %a, %b\n+    // CHECK-NOT: and i32\n+    a.unchecked_shl(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shl_unsigned_smaller\n+#[no_mangle]\n+pub unsafe fn unchecked_shl_unsigned_smaller(a: u16, b: u32) -> u16 {\n+    // This uses -DAG to avoid failing on irrelevant reorderings,\n+    // like emitting the truncation earlier.\n+\n+    // CHECK-DAG: %[[INRANGE:.+]] = icmp ult i32 %b, 65536\n+    // CHECK-DAG: tail call void @llvm.assume(i1 %[[INRANGE]])\n+    // CHECK-DAG: %[[TRUNC:.+]] = trunc i32 %b to i16\n+    // CHECK-DAG: shl i16 %a, %[[TRUNC]]\n+    a.unchecked_shl(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shl_unsigned_bigger\n+#[no_mangle]\n+pub unsafe fn unchecked_shl_unsigned_bigger(a: u64, b: u32) -> u64 {\n+    // CHECK: %[[EXT:.+]] = zext i32 %b to i64\n+    // CHECK: shl i64 %a, %[[EXT]]\n+    a.unchecked_shl(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shr_signed_same\n+#[no_mangle]\n+pub unsafe fn unchecked_shr_signed_same(a: i32, b: u32) -> i32 {\n+    // CHECK-NOT: and i32\n+    // CHECK: ashr i32 %a, %b\n+    // CHECK-NOT: and i32\n+    a.unchecked_shr(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shr_signed_smaller\n+#[no_mangle]\n+pub unsafe fn unchecked_shr_signed_smaller(a: i16, b: u32) -> i16 {\n+    // This uses -DAG to avoid failing on irrelevant reorderings,\n+    // like emitting the truncation earlier.\n+\n+    // CHECK-DAG: %[[INRANGE:.+]] = icmp ult i32 %b, 32768\n+    // CHECK-DAG: tail call void @llvm.assume(i1 %[[INRANGE]])\n+    // CHECK-DAG: %[[TRUNC:.+]] = trunc i32 %b to i16\n+    // CHECK-DAG: ashr i16 %a, %[[TRUNC]]\n+    a.unchecked_shr(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shr_signed_bigger\n+#[no_mangle]\n+pub unsafe fn unchecked_shr_signed_bigger(a: i64, b: u32) -> i64 {\n+    // CHECK: %[[EXT:.+]] = zext i32 %b to i64\n+    // CHECK: ashr i64 %a, %[[EXT]]\n+    a.unchecked_shr(b)\n+}"}]}