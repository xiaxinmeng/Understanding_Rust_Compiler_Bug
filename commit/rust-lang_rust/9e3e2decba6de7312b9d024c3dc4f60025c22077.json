{"sha": "9e3e2decba6de7312b9d024c3dc4f60025c22077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllM2UyZGVjYmE2ZGU3MzEyYjlkMDI0YzNkYzRmNjAwMjVjMjIwNzc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-04T05:20:44Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-04T05:20:44Z"}, "message": "Add slides for final presentation.", "tree": {"sha": "c55a14753384548c15ff3041aa9584a8e1626834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c55a14753384548c15ff3041aa9584a8e1626834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e3e2decba6de7312b9d024c3dc4f60025c22077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3e2decba6de7312b9d024c3dc4f60025c22077", "html_url": "https://github.com/rust-lang/rust/commit/9e3e2decba6de7312b9d024c3dc4f60025c22077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e3e2decba6de7312b9d024c3dc4f60025c22077/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e72d8f8dc66cc0c20af129d4c99ca4e47fdc08ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72d8f8dc66cc0c20af129d4c99ca4e47fdc08ea", "html_url": "https://github.com/rust-lang/rust/commit/e72d8f8dc66cc0c20af129d4c99ca4e47fdc08ea"}], "stats": {"total": 458, "additions": 457, "deletions": 1}, "files": [{"sha": "bbd046fa2735f3551d435b02170fb395b1ce1793", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e3e2decba6de7312b9d024c3dc4f60025c22077/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/9e3e2decba6de7312b9d024c3dc4f60025c22077/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=9e3e2decba6de7312b9d024c3dc4f60025c22077", "patch": "@@ -1,5 +1,5 @@\n /target\n /doc\n+/final-presentation/out\n *.dot\n *.mir\n-*.png"}, {"sha": "23aa1a481b3ebc8eb1358f31a6e49f08090bc5d9", "filename": "final-presentation/latexmkrc", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3e2decba6de7312b9d024c3dc4f60025c22077/final-presentation%2Flatexmkrc", "raw_url": "https://github.com/rust-lang/rust/raw/9e3e2decba6de7312b9d024c3dc4f60025c22077/final-presentation%2Flatexmkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/final-presentation%2Flatexmkrc?ref=9e3e2decba6de7312b9d024c3dc4f60025c22077", "patch": "@@ -0,0 +1,12 @@\n+# vim: ft=perl\n+\n+$pdf_mode = 1;\n+$pdflatex = 'lualatex --shell-escape %O %S';\n+$out_dir = 'out';\n+\n+# This improves latexmk's detection of source files and generated files.\n+$recorder = 1;\n+\n+# Ignore always-regenerated *.pyg files from the minted package when considering\n+# whether to run pdflatex again.\n+$hash_calc_ignore_pattern{'pyg'} = '.*';"}, {"sha": "38484c670e01f3f355672d6c95f79f035a963a44", "filename": "final-presentation/rust-logo-512x512.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9e3e2decba6de7312b9d024c3dc4f60025c22077/final-presentation%2Frust-logo-512x512.png", "raw_url": "https://github.com/rust-lang/rust/raw/9e3e2decba6de7312b9d024c3dc4f60025c22077/final-presentation%2Frust-logo-512x512.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/final-presentation%2Frust-logo-512x512.png?ref=9e3e2decba6de7312b9d024c3dc4f60025c22077"}, {"sha": "892d31602c82421a2ad07943809a31797af628c5", "filename": "final-presentation/slides.tex", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/9e3e2decba6de7312b9d024c3dc4f60025c22077/final-presentation%2Fslides.tex", "raw_url": "https://github.com/rust-lang/rust/raw/9e3e2decba6de7312b9d024c3dc4f60025c22077/final-presentation%2Fslides.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/final-presentation%2Fslides.tex?ref=9e3e2decba6de7312b9d024c3dc4f60025c22077", "patch": "@@ -0,0 +1,444 @@\n+\\documentclass{beamer}\n+\\usecolortheme{beaver}\n+\\beamertemplatenavigationsymbolsempty\n+\n+% Fonts\n+\\usepackage{fontspec}\n+\\setmainfont{Source Serif Pro}[Ligatures=TeX]\n+\\setsansfont{Source Sans Pro}[Ligatures=TeX]\n+\\setmonofont{Source Code Pro}[\n+  BoldFont={* Medium},\n+  BoldItalicFont={* Medium Italic},\n+]\n+\n+\\usepackage[outputdir=out]{minted}\n+\\usepackage{tikz}\n+\\usetikzlibrary{positioning, fit}\n+\n+\\tikzset{\n+  invisible/.style={opacity=0,text opacity=0},\n+  highlight/.style={color=red},\n+  intro/.code args={<#1>}{%\n+    \\only<#1>{\\pgfkeysalso{highlight}}\n+    \\alt<#1->{}{\\pgfkeysalso{invisible}}\n+  },\n+}\n+\n+\\title{Miri}\n+\\subtitle{An interpreter for Rust's mid-level intermediate representation}\n+\\author{\n+  Scott Olson\n+  \\texorpdfstring{\\\\ \\scriptsize{Supervisor: Christopher Dutchyn}}{}\n+}\n+\\institute{\n+  CMPT 400 \\\\\n+  University of Saskatchewan\n+}\n+\\date{}\n+\\titlegraphic{\n+  \\includegraphics[width=64px,height=64px]{rust-logo-512x512.png} \\\\\n+  \\scriptsize{\\url{https://www.rust-lang.org}}\n+}\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+% Intro slides\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\begin{document}\n+\n+\\maketitle\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{What is Rust? \\small{[review]}}\n+\n+  According to the website\\dots\n+\n+  \\begin{quote}\n+    \\textbf{Rust} is a systems programming language that runs blazingly fast,\n+    prevents nearly all segfaults, and guarantees thread safety.\n+  \\end{quote}\n+\n+  It's a new programming language from Mozilla, and it looks like this:\n+\n+  \\begin{minted}[\n+    autogobble,\n+    fontsize=\\footnotesize,\n+    mathescape,\n+    xleftmargin=.3in,\n+  ]{rust}\n+    fn factorial(n: u64) -> u64 {\n+        (1..n).fold(1, |a, b| a * b)\n+    }\n+\n+    fn main() {\n+        for x in 1..6 {\n+            println!(\"{}\", factorial(x));\n+        }\n+        // $\\Rightarrow$ 1\n+        // $\\Rightarrow$ 1\n+        // $\\Rightarrow$ 2\n+        // $\\Rightarrow$ 6\n+        // $\\Rightarrow$ 24\n+    }\n+  \\end{minted}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\frametitle{How does Rust compile code? \\onslide<-6>{\\small{[review]}}}\n+\n+  \\begin{center}\n+    \\begin{tikzpicture}[x=4cm, y=3.5cm, auto, rounded corners]\n+      \\tikzstyle{basic-stage}=[rectangle, draw, thick, align=center]\n+      \\tikzstyle{stage}=[basic-stage, font=\\tiny]\n+      \\tikzstyle{pass}=[thick, -stealth]\n+      \\tikzstyle{pass-label}=[font=\\footnotesize]\n+\n+      \\node[basic-stage] (src) at (0,0) {Source\\\\Code};\n+      \\node[basic-stage] (mach) at (2,-1) {Machine\\\\Code};\n+\n+      \\draw<1>[pass, out=0, in=180]\n+        (src.east) to node[font=\\Huge] {?} (mach.west);\n+\n+      \\node[stage, intro=<2>] (ast) at (1,0)\n+        {\\normalsize{AST} \\\\ Abstract Syntax Tree};\n+      \\draw[pass, intro=<2>]\n+        (src) -- node[pass-label] {Parse} (ast);\n+\n+      \\node[stage, intro=<3>] (hir) at (2,0)\n+        {\\normalsize{HIR} \\\\ High-level Intermediate\\\\Representation};\n+      \\draw[pass, intro=<3>]\n+        (ast) -- node[pass-label] {Simplify} (hir);\n+\n+      \\node[stage, intro=<4>] (mir) at (0,-1)\n+        {\\normalsize{MIR} \\\\ Mid-level Intermediate\\\\Representation};\n+      \\path (hir.south) -- coordinate (middle) (mir.north);\n+      \\draw[pass, intro=<4>]\n+        (hir.south) |- (middle) -| (mir.north);\n+      \\node[pass-label, above, intro=<4>] at (middle) {Lower};\n+\n+      \\node[stage, intro=<5>] (llvm) at (1,-1)\n+        {\\normalsize{LLVM IR} \\\\ Low-level Intermediate\\\\Representation};\n+      \\draw[pass, intro=<5>]\n+        (mir) -- node[pass-label] {Translate} (llvm);\n+\n+      \\draw<6->[pass, intro=<6>]\n+        (llvm) -- node[pass-label] {Magic} (mach);\n+\n+      \\node[stage, intro=<7>] (exec) at (1,-1.75)\n+        {\\normalsize{Execution}};\n+      \\draw[pass, intro=<7>]\n+        (mach) -- node[pass-label] {CPU} (exec);\n+\n+      \\draw[pass, intro=<8>]\n+        (mir) -- node[pass-label] {Miri} (exec);\n+    \\end{tikzpicture}\n+  \\end{center}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\frametitle{Why build Miri?}\n+  \\begin{itemize}\n+    \\item For fun and learning.\n+\n+    \\item I originally planned to use it for testing the compiler and execution\n+      of unsafe code, but shifted my goals along the way. \\pause\n+\n+    \\item Now it serves as an experimental implementation of the upcoming\n+      compile-time function evaluation feature in Rust. \\pause\n+\n+      \\begin{itemize}\n+        \\item Similar to C++14's \\mintinline{cpp}{constexpr} feature.\n+\n+        \\item You can do complicated calculations at compile time and compile\n+          their \\emph{results} into the executable. \\pause\n+\n+        \\item For example, you can compute a ``perfect hash function'' for a\n+          statically-known map at compile-time and have guaranteed no-collision\n+          lookup at runtime. \\pause\n+\n+        \\item Miri actually supports far more of Rust than C++14's\n+          \\mintinline{cpp}{constexpr} does of C++ --- even heap allocation and\n+          unsafe code.\n+      \\end{itemize}\n+  \\end{itemize}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\frametitle{How was it built?}\n+\n+  At first I wrote a naive version with a number of downsides:\n+\n+  \\begin{itemize}\n+    \\item represented values in a traditional dynamic language format, where\n+      every value was the same size.\n+\n+    \\item didn't work well for aggregates (structs, enums, arrays, etc.).\n+\n+    \\item made unsafe programming tricks that make assumptions about low-level\n+      value layout essentially impossible.\n+  \\end{itemize}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\frametitle{How was it built?}\n+  \\begin{itemize}\n+    \\item Later, a Rust compiler team member proposed a ``Rust abstract\n+      machine`` with specialized value layout which solved my previous problems.\n+      \\pause\n+\n+    \\item His proposal was intended for a compile-time function evaluator in the\n+      Rust compiler, so I effectively implemented an experimental version of\n+      that. \\pause\n+\n+    \\item After this point, making Miri work well was primarily a software\n+      engineering problem.\n+  \\end{itemize}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\frametitle{Data layout}\n+  \\begin{itemize}\n+    \\item Memory in Miri is literally a HashMap from ``allocation IDs'' to\n+      ``abstract allocations''.\n+\n+    \\item Allocations are represented by: \\pause\n+      \\begin{enumerate}\n+        \\item An array of \\textbf{raw bytes} with a size based on the type of\n+          the value \\pause\n+        \\item A set of \\textbf{relocations} --- pointers into other abstract\n+          allocations \\pause\n+        \\item A mask determining which bytes are \\textbf{undefined}\n+      \\end{enumerate}\n+  \\end{itemize}\n+\\end{frame}\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+% Miri example slides\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{\\texttt{square} example}\n+  \\begin{center}\n+    \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n+      // Rust\n+      fn square(n: u64) -> u64 {\n+          n * n\n+      }\n+\n+      // Generated MIR\n+      fn square(arg0: u64) -> u64 {\n+          let var0: u64; // n           // On function entry, Miri creates\n+                                        // virtual allocations for all the\n+                                        // arguments, variables, and\n+                                        // temporaries.\n+\n+          bb0: {\n+              var0 = arg0;              // Copy the argument into `n`.\n+              return = Mul(var0, var0); // Multiply `n` with itself.\n+              goto -> bb1;              // Jump to basic block `bb1`.\n+          }\n+\n+          bb1: {\n+              return;                   // Return from the current fn.\n+          }\n+      }\n+    \\end{minted}\n+  \\end{center}\n+\\end{frame}\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{\\texttt{sum} example}\n+  \\begin{center}\n+    \\begin{minted}[autogobble,fontsize=\\tiny]{rust}\n+      // Rust\n+      fn sum() -> u64 {\n+          let mut sum = 0; let mut i = 0;\n+          while i < 10 { sum += i; i += 1; }\n+          sum\n+      }\n+\n+      // Generated MIR\n+      fn sum() -> u64 {\n+          let mut var0: u64; // sum\n+          let mut var1: u64; // i\n+          let mut tmp0: bool;\n+\n+          bb0: {\n+              // sum = 0; i = 0;\n+              var0 = const 0u64; var1 = const 0u64; goto -> bb1;\n+          }\n+          bb1: {\n+              // if i < 10 { goto bb2; } else { goto bb3; }\n+              tmp0 = Lt(var1, const 10u64);\n+              if(tmp0) -> [true: bb2, false: bb3];\n+          }\n+          bb2: {\n+              var0 = Add(var0, var1);       // sum = sum + i;\n+              var1 = Add(var1, const 1u64); // i = i + 1;\n+              goto -> bb1;\n+          }\n+          bb3: {\n+              return = var0; goto -> bb4;\n+          }\n+          bb4: { return; }\n+      }\n+    \\end{minted}\n+  \\end{center}\n+\\end{frame}\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{Heap allocations!}\n+  \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n+    fn make_vec() -> Vec<u8> {\n+        // Empty array with space for 4 bytes - allocated on the heap!\n+        let mut vec = Vec::with_capacity(4);\n+        // Initialize the first two slots.\n+        vec.push(1);\n+        vec.push(2);\n+        vec\n+    }\n+\n+    // For reference:\n+    //   struct Vec<T> { capacity: usize, data: *mut T, length: usize }\n+\n+    // Resulting allocations (on 32-bit little-endian architectures):\n+    //   Region A:\n+    //     04 00 00 00  00 00 00 00  02 00 00 00\n+    //                  \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n+    //\n+    //   Region B:\n+    //     01 02 __ __ (underscores denote undefined bytes)\n+  \\end{minted}\n+\n+  \\footnotesize{Evaluating the above involves a number of compiler built-ins,\n+  ``unsafe'' code blocks, and more inside the standard library,\n+  but Miri handles it all.}\n+\\end{frame}\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{Unsafe code!}\n+  \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n+    fn out_of_bounds() -> u8 {\n+        let mut vec = vec![1, 2]\n+        unsafe { *vec.get_unchecked(5) }\n+    }\n+\n+    // test.rs:3: error: pointer offset outside bounds of allocation\n+    // test.rs:3:     unsafe { *vec.get_unchecked(5) }\n+    //                         ^~~~~~~~~~~~~~~~~~~~~\n+\n+    fn undefined_bytes() -> u8 {\n+        let mut vec = Vec::with_capacity(10);\n+        unsafe { *vec.get_unchecked(5) }\n+    }\n+\n+    // test.rs:3: error: attempted to read undefined bytes\n+    // test.rs:3:     unsafe { *vec.get_unchecked(5) }\n+    //                         ^~~~~~~~~~~~~~~~~~~~~\n+  \\end{minted}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\frametitle{What can't Miri do?}\n+  \\begin{itemize}\n+    \\item Miri can't do all the stuff I didn't implement yet. :)\n+      \\begin{itemize}\n+        \\item non-trivial casts\n+        \\item function pointers\n+        \\item calling destructors and freeing memory\n+        \\item handling all constants properly (but, well, Miri might be\n+          replacing the old constants system)\n+      \\end{itemize}\n+\n+    \\item Miri can't do foreign function calls (e.g. calling functions defined\n+      in C or C++), but there is a reasonable way it could be done with libffi.\n+      \\begin{itemize}\n+        \\item On the other hand, for constant evaluation in the compiler, you\n+          want the evaluator to be deterministic and safe, so FFI calls might be\n+          banned anyway.\n+      \\end{itemize}\n+\n+    \\item Without quite some effort, Miri will probably never handle inline\n+      assembly...\n+  \\end{itemize}\n+\\end{frame}\n+\n+\\begin{frame}\n+  \\begin{center}\n+    \\LARGE{Questions?}\n+  \\end{center}\n+\\end{frame}\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+% Extra slides\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{\\texttt{varN} vs. \\texttt{argN}}\n+  \\begin{center}\n+    \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n+      // Rust\n+      type Pair = (u64, u64);\n+      fn swap((a, b): Pair) -> Pair {\n+          (b, a)\n+      }\n+\n+      // Generated MIR\n+      fn swap(arg0: (u64, u64)) -> (u64, u64) {\n+          let var0: u64; // a\n+          let var1: u64; // b\n+\n+          bb0: {\n+              var0 = arg0.0;         // get the 1st part of the pair\n+              var1 = arg0.1;         // get the 2nd part of the pair\n+              return = (var0, var1); // build a new pair in the result\n+              goto -> bb1;\n+          }\n+\n+          bb1: {\n+              return;\n+          }\n+      }\n+    \\end{minted}\n+  \\end{center}\n+\\end{frame}\n+\n+\\begin{frame}[fragile]\n+  \\frametitle{\\texttt{factorial} example}\n+  \\begin{center}\n+    \\begin{minted}[autogobble,fontsize=\\tiny]{rust}\n+      // Rust\n+      fn factorial(n: u64) -> u64 {\n+          (1..n).fold(1, |a, b| a * b)\n+      }\n+\n+      // Generated MIR\n+      fn factorial(arg0: u64) -> u64 {\n+          let var0: u64; // n\n+          let mut tmp0: Range<u64>; // Miri calculates sizes for generics like Range<u64>.\n+          let mut tmp1: [closure];\n+\n+          bb0: {\n+              var0 = arg0;\n+\n+              // tmp0 = 1..n\n+              tmp0 = Range<u64> { start: const 1u64, end: var0 };\n+\n+              // tmp1 = |a, b| a * b\n+              tmp1 = [closure];\n+\n+              // This loads the MIR for the `fold` fn from the standard library.\n+              // In general, MIR for any function from any library can be loaded.\n+              // return tmp0.fold(1, tmp1)\n+              return = Range<u64>::fold(tmp0, const 1u64, tmp1) -> bb1;\n+          }\n+\n+          bb1: {\n+              return;\n+          }\n+      }\n+    \\end{minted}\n+  \\end{center}\n+\\end{frame}\n+\n+\\end{document}"}]}