{"sha": "63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNTE5ZDkwMDZhOTFlOGQ3N2ExYjc4YmM0NmY0ODRiN2M2Y2ViM2I=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T10:06:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T10:06:51Z"}, "message": "Rename restrict to binding in alias.rs\n\nIts role gradually changed to the point where the old name doesn't\nreally make sense anymore.", "tree": {"sha": "b8c879f2683b420aa5b940700d23490a0cc72002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8c879f2683b420aa5b940700d23490a0cc72002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "html_url": "https://github.com/rust-lang/rust/commit/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44df04179902d248bfe1cff2fa346c02b40d3338", "url": "https://api.github.com/repos/rust-lang/rust/commits/44df04179902d248bfe1cff2fa346c02b40d3338", "html_url": "https://github.com/rust-lang/rust/commit/44df04179902d248bfe1cff2fa346c02b40d3338"}], "stats": {"total": 141, "additions": 66, "deletions": 75}, "files": [{"sha": "1a255ca9d476145acb00775f9c098bcc0818f101", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 66, "deletions": 75, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63519d9006a91e8d77a1b78bc46f484b7c6ceb3b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=63519d9006a91e8d77a1b78bc46f484b7c6ceb3b", "patch": "@@ -15,25 +15,30 @@ import std::option::{some, none, is_none};\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n tag copied { not_allowed; copied; not_copied; }\n \n-type restrict = @{node_id: node_id,\n-                  span: span,\n-                  local_id: uint,\n-                  root_var: option::t<node_id>,\n-                  unsafe_tys: [ty::t],\n-                  mutable ok: valid,\n-                  mutable copied: copied};\n-\n-type scope = [restrict];\n+type binding = @{node_id: node_id,\n+                 span: span,\n+                 local_id: uint,\n+                 root_var: option::t<node_id>,\n+                 unsafe_tys: [ty::t],\n+                 mutable ok: valid,\n+                 mutable copied: copied};\n+type scope = [binding]; // {bs: [binding], ret_style: ast::ret_style}\n+\n+fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n+              unsafe: [ty::t]) -> binding {\n+    ret @{node_id: id, span: span, local_id: cx.next_local,\n+          root_var: root_var, unsafe_tys: unsafe,\n+          mutable ok: valid, mutable copied: not_copied};\n+}\n \n tag local_info { local(uint); }\n \n type copy_map = std::map::hashmap<node_id, ()>;\n \n-type ctx =\n-    {tcx: ty::ctxt,\n-     local_map: std::map::hashmap<node_id, local_info>,\n-     mutable next_local: uint,\n-     copy_map: copy_map};\n+type ctx = {tcx: ty::ctxt,\n+            local_map: std::map::hashmap<node_id, local_info>,\n+            mutable next_local: uint,\n+            copy_map: copy_map};\n \n fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> copy_map {\n     // Stores information about object fields and function\n@@ -105,6 +110,10 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n       ast::expr_assign(dest, src) | ast::expr_assign_op(_, dest, src) {\n         check_assign(cx, dest, src, sc, v);\n       }\n+      ast::expr_ret(oexpr) {\n+        \n+        handled = false;\n+      }\n       _ { handled = false; }\n     }\n     if !handled { visit::visit_expr(ex, sc, v); }\n@@ -137,30 +146,30 @@ fn visit_decl(cx: @ctx, d: @ast::decl, sc: scope, v: vt<scope>) {\n     }\n }\n \n-fn cant_copy(cx: ctx, r: restrict) -> bool {\n-    alt r.copied {\n+fn cant_copy(cx: ctx, b: binding) -> bool {\n+    alt b.copied {\n       not_allowed. { ret true; }\n       copied. { ret false; }\n       not_copied. {}\n     }\n-    let ty = ty::node_id_to_type(cx.tcx, r.node_id);\n+    let ty = ty::node_id_to_type(cx.tcx, b.node_id);\n     if ty::type_allows_implicit_copy(cx.tcx, ty) {\n-        r.copied = copied;\n-        cx.copy_map.insert(r.node_id, ());\n+        b.copied = copied;\n+        cx.copy_map.insert(b.node_id, ());\n         if copy_is_expensive(cx.tcx, ty) {\n-            cx.tcx.sess.span_warn(r.span,\n+            cx.tcx.sess.span_warn(b.span,\n                                   \"inserting an implicit copy for type \" +\n                                   util::ppaux::ty_to_str(cx.tcx, ty));\n         }\n         ret false;\n     } else { ret true; }\n }\n \n-fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [restrict] {\n+fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n     let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n-    let restricts = [];\n+    let bindings = [];\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         let arg = args[i];\n@@ -175,17 +184,14 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [restrict] {\n             }\n         }\n         let root_var = path_def_id(cx, root.ex);\n-        restricts += [@{node_id: arg.id,\n-                        span: arg.span,\n-                        local_id: cx.next_local,\n-                        root_var: root_var,\n-                        unsafe_tys: inner_mut(root.ds),\n-                        mutable ok: valid,\n-                        mutable copied: alt arg_t.mode {\n-                          ast::by_move. { copied }\n-                          ast::by_ref. { not_copied }\n-                          ast::by_mut_ref. { not_allowed }\n-                        }}];\n+        let new_bnd = mk_binding(cx, arg.id, arg.span, root_var,\n+                                 inner_mut(root.ds));\n+        new_bnd.copied = alt arg_t.mode {\n+          ast::by_move. { copied }\n+          ast::by_ref. { not_copied }\n+          ast::by_mut_ref. { not_allowed }\n+        };\n+        bindings += [new_bnd];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -195,8 +201,8 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [restrict] {\n         };\n     if f_may_close {\n         let i = 0u;\n-        for r in restricts {\n-            if vec::len(r.unsafe_tys) > 0u && cant_copy(cx, r) {\n+        for b in bindings {\n+            if vec::len(b.unsafe_tys) > 0u && cant_copy(cx, b) {\n                 cx.tcx.sess.span_err(f.span,\n                                      #fmt[\"function may alias with argument \\\n                                            %u, which is not immutably rooted\",\n@@ -206,14 +212,14 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [restrict] {\n         }\n     }\n     let j = 0u;\n-    for r in restricts {\n-        for ty in r.unsafe_tys {\n+    for b in bindings {\n+        for ty in b.unsafe_tys {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias = arg_t.mode == ast::by_mut_ref;\n                 if i != j &&\n                        ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n-                       cant_copy(cx, r) {\n+                       cant_copy(cx, b) {\n                     cx.tcx.sess.span_err\n                         (args[i].span,\n                          #fmt[\"argument %u may alias with argument %u, \\\n@@ -229,11 +235,11 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [restrict] {\n \n     for {node: node, arg: arg} in mut_roots {\n         let i = 0u;\n-        for r in restricts {\n+        for b in bindings {\n             if i != arg {\n-                alt r.root_var {\n+                alt b.root_var {\n                   some(root) {\n-                    if node == root && cant_copy(cx, r) {\n+                    if node == root && cant_copy(cx, b) {\n                         cx.tcx.sess.span_err\n                             (args[arg].span,\n                              \"passing a mutable reference to a \\\n@@ -247,7 +253,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [restrict] {\n             i += 1u;\n         }\n     }\n-    ret restricts;\n+    ret bindings;\n }\n \n fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n@@ -277,13 +283,8 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n             }\n         }\n         for info in binding_info {\n-            new_sc += [@{node_id: info.id,\n-                         span: info.span,\n-                         local_id: cx.next_local,\n-                         root_var: root_var,\n-                         unsafe_tys: info.unsafe,\n-                         mutable ok: valid,\n-                         mutable copied: not_copied}];\n+            new_sc += [mk_binding(cx, info.id, info.span, root_var,\n+                                  info.unsafe)];\n         }\n         register_locals(cx, a.pats[0]);\n         visit::visit_arm(a, new_sc, v);\n@@ -297,13 +298,8 @@ fn check_for_each(cx: ctx, local: @ast::local, call: @ast::expr,\n       ast::expr_call(f, args) {\n         let new_sc = sc + check_call(cx, f, args);\n         for proot in *pattern_roots(cx.tcx, [], local.node.pat) {\n-            new_sc += [@{node_id: proot.id,\n-                         span: proot.span,\n-                         local_id: cx.next_local,\n-                         root_var: none::<node_id>,\n-                         unsafe_tys: inner_mut(proot.ds),\n-                         mutable ok: valid,\n-                         mutable copied: not_copied}];\n+            new_sc += [mk_binding(cx, proot.id, proot.span, none,\n+                                  inner_mut(proot.ds))];\n         }\n         register_locals(cx, local.node.pat);\n         visit::visit_block(blk, new_sc, v);\n@@ -330,13 +326,8 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n     let root_var = path_def_id(cx, root.ex);\n     let new_sc = sc;\n     for proot in *pattern_roots(cx.tcx, ext_ds, local.node.pat) {\n-        new_sc += [@{node_id: proot.id,\n-                     span: proot.span,\n-                     local_id: cx.next_local,\n-                     root_var: root_var,\n-                     unsafe_tys: inner_mut(proot.ds),\n-                     mutable ok: valid,\n-                     mutable copied: not_copied}];\n+        new_sc += [mk_binding(cx, proot.id, proot.span, root_var,\n+                              inner_mut(proot.ds))];\n     }\n     register_locals(cx, local.node.pat);\n     visit::visit_block(blk, new_sc, v);\n@@ -350,16 +341,16 @@ fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n     let my_local_id =\n         alt cx.local_map.find(my_defnum) { some(local(id)) { id } _ { 0u } };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n-    for r: restrict in sc {\n+    for b in sc {\n         // excludes variables introduced since the alias was made\n-        if my_local_id < r.local_id {\n-            for ty in r.unsafe_tys {\n+        if my_local_id < b.local_id {\n+            for ty in b.unsafe_tys {\n                 if ty_can_unsafely_include(cx, ty, var_t, assign) {\n-                    r.ok = val_taken(ex.span, p);\n+                    b.ok = val_taken(ex.span, p);\n                 }\n             }\n-        } else if r.node_id == my_defnum {\n-            test_scope(cx, sc, r, p);\n+        } else if b.node_id == my_defnum {\n+            test_scope(cx, sc, b, p);\n         }\n     }\n }\n@@ -369,8 +360,8 @@ fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n       ast::expr_path(p) {\n         let def = cx.tcx.def_map.get(dest.id);\n         let dnum = ast_util::def_id_of_def(def).node;\n-        for r: restrict in sc {\n-            if r.root_var == some(dnum) { r.ok = overwritten(dest.span, p); }\n+        for b in sc {\n+            if b.root_var == some(dnum) { b.ok = overwritten(dest.span, p); }\n         }\n       }\n       _ { visit_expr(cx, dest, sc, v); }\n@@ -383,9 +374,9 @@ fn check_assign(cx: @ctx, dest: @ast::expr, src: @ast::expr, sc: scope,\n     check_lval(cx, dest, sc, v);\n }\n \n-fn test_scope(cx: ctx, sc: scope, r: restrict, p: ast::path) {\n-    let prob = r.ok;\n-    alt r.root_var {\n+fn test_scope(cx: ctx, sc: scope, b: binding, p: ast::path) {\n+    let prob = b.ok;\n+    alt b.root_var {\n       some(dn) {\n         for other in sc {\n             if other.node_id == dn {\n@@ -396,7 +387,7 @@ fn test_scope(cx: ctx, sc: scope, r: restrict, p: ast::path) {\n       }\n       _ {}\n     }\n-    if prob != valid && cant_copy(cx, r) {\n+    if prob != valid && cant_copy(cx, b) {\n         let msg = alt prob {\n           overwritten(sp, wpt) {\n             {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}"}]}