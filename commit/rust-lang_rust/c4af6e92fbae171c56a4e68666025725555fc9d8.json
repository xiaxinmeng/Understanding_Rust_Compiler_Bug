{"sha": "c4af6e92fbae171c56a4e68666025725555fc9d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YWY2ZTkyZmJhZTE3MWM1NmE0ZTY4NjY2MDI1NzI1NTU1ZmM5ZDg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-07T02:06:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-07T02:07:26Z"}, "message": "rustc: Switch to the new resolution pass", "tree": {"sha": "498df2a12555cc91a83d002ea8e424f5da6f7378", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/498df2a12555cc91a83d002ea8e424f5da6f7378"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4af6e92fbae171c56a4e68666025725555fc9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4af6e92fbae171c56a4e68666025725555fc9d8", "html_url": "https://github.com/rust-lang/rust/commit/c4af6e92fbae171c56a4e68666025725555fc9d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4af6e92fbae171c56a4e68666025725555fc9d8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5f5676a2ffacf58fc3831846c5357b7e2b46109", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f5676a2ffacf58fc3831846c5357b7e2b46109", "html_url": "https://github.com/rust-lang/rust/commit/b5f5676a2ffacf58fc3831846c5357b7e2b46109"}], "stats": {"total": 758, "additions": 430, "deletions": 328}, "files": [{"sha": "855a090e47453a5fb77d8aa40e357d700288cf1d", "filename": "src/libcore/task.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -63,6 +63,12 @@ export local_data_get;\n export local_data_set;\n export local_data_modify;\n \n+export single_threaded;\n+export thread_per_core;\n+export thread_per_task;\n+export manual_threads;\n+export osmain;\n+\n /* Data types */\n \n /// A handle to a task"}, {"sha": "4585b4564b57148f5c63e18a6725e663b02d9704", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -25,6 +25,7 @@ export ip_addr, parse_addr_err;\n export format_addr;\n export v4, v6;\n export get_addr;\n+export ipv4, ipv6;\n \n /// An IP address\n enum ip_addr {\n@@ -389,4 +390,4 @@ mod test {\n         let ga_result = get_addr(localhost_name, iotask);\n         assert result::is_err(ga_result);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "7a9ec6f32a4463d158d37ac3e522826391402ad9", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -16,10 +16,8 @@ export parse_from_source_str;\n // unresolved import errors. Maybe resolve3 will fix it.\n import common::*;\n import parser::parser;\n-//import attr::parser_attr;\n-import attr::*; //resolve bug?\n-//import common::parser_common;\n-import common::*; //resolve bug?\n+import attr::parser_attr;\n+import common::parser_common;\n import ast::node_id;\n import util::interner;\n // FIXME (#1935): resolve badness"}, {"sha": "bd164402c1d79004c2acff4dc0db440a03d2f1ee", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -9,6 +9,7 @@ export lit;\n export cmnt_style;\n export gather_comments_and_literals;\n export is_doc_comment, doc_comment_style, strip_doc_comment_decoration;\n+export isolated, trailing, mixed, blank_line;\n \n enum cmnt_style {\n     isolated, // No code on either side of each line of the comment"}, {"sha": "6727ebe4c7753ef16ae0ba11d5948558cd622ebb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -12,7 +12,47 @@ import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n                 seq_sep_none, token_to_str};\n import dvec::{dvec, extensions};\n import vec::{push};\n-import ast::*;\n+import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n+             bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n+             bound_copy, bound_send, bound_trait, box, by_copy, by_move,\n+             by_mutbl_ref, by_ref, by_val, capture_clause, capture_item,\n+             carg_base, carg_ident, cdir_dir_mod, cdir_src_mod,\n+             cdir_view_item, checked_expr, claimed_expr, class_immutable,\n+             class_member, class_method, class_mutable, constr, constr_arg,\n+             constr_general, crate, crate_cfg, crate_directive, decl,\n+             decl_item, decl_local, default_blk, deref, div, expl, expr,\n+             expr_, expr_addr_of, expr_alt, expr_assert, expr_assign,\n+             expr_assign_op, expr_binary, expr_block, expr_break, expr_call,\n+             expr_cast, expr_check, expr_cont, expr_copy, expr_do_body,\n+             expr_fail, expr_field, expr_fn, expr_fn_block, expr_if,\n+             expr_if_check, expr_index, expr_lit, expr_log, expr_loop,\n+             expr_loop_body, expr_mac, expr_move, expr_new, expr_path,\n+             expr_rec, expr_ret, expr_swap, expr_tup, expr_unary, expr_vec,\n+             expr_vstore, expr_while, extern_fn, field, fn_decl, foreign_item,\n+             foreign_item_fn, foreign_mod, ident, impure_fn, infer,\n+             init_assign, init_move, initializer, instance_var, item, item_,\n+             item_class, item_const, item_enum, item_fn, item_foreign_mod,\n+             item_impl, item_mod, item_trait, item_ty, lit, lit_, lit_bool,\n+             lit_float, lit_int, lit_int_unsuffixed, lit_nil, lit_str,\n+             lit_uint, local, m_const, m_imm, m_mutbl, mac_, mac_aq,\n+             mac_ellipsis, mac_embed_block, mac_embed_type, mac_invoc,\n+             mac_invoc_tt, mac_var, matcher, method, mode, mt, mtc_bb,\n+             mtc_rep, mtc_tok, mul, mutability, neg, noreturn, not, pat,\n+             pat_box, pat_enum, pat_ident, pat_lit, pat_range, pat_rec,\n+             pat_tup, pat_uniq, pat_wild, path, private, proto, proto_any,\n+             proto_bare, proto_block, proto_box, proto_uniq, public, pure_fn,\n+             purity, re_anon, re_named, region, region_param, rem, ret_style,\n+             return_val, rp_none, rp_self, shl, shr, stmt, stmt_decl,\n+             stmt_expr, stmt_semi, subtract, token_tree, trait_ref, tt_delim,\n+             tt_dotdotdot, tt_flat, tt_interpolate, ty, ty_, ty_bot, ty_box,\n+             ty_constr, ty_constr_, ty_constr_arg, ty_field, ty_fn, ty_infer,\n+             ty_mac, ty_method, ty_nil, ty_param, ty_path, ty_ptr, ty_rec,\n+             ty_rptr, ty_tup, ty_u32, ty_uniq, ty_vec, ty_vstore,\n+             unchecked_blk, uniq, unsafe_blk, unsafe_fn, variant, view_item,\n+             view_item_, view_item_export, view_item_import, view_item_use,\n+             view_path, view_path_glob, view_path_list, view_path_simple,\n+             visibility, vstore, vstore_box, vstore_fixed, vstore_slice,\n+             vstore_uniq};\n \n export file_type;\n export parser;"}, {"sha": "6c6247fabe3c6979a2df576bb36637ec71369712", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -168,26 +168,9 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.static));\n \n-    let mut def_map;\n-    let mut impl_map;\n-    let mut exp_map;\n-    if sess.fast_resolve() {\n-        let { def_map: fast_dm, exp_map: fast_em, impl_map: fast_im } =\n-            time(time_passes, \"fast resolution\", ||\n-                 middle::resolve3::resolve_crate(sess, ast_map, crate));\n-\n-        def_map = fast_dm;\n-        impl_map = fast_im;\n-        exp_map = fast_em;\n-    } else {\n-        let { def_map: normal_dm, exp_map: normal_em, impl_map: normal_im } =\n-            time(time_passes, \"resolution\", ||\n-                 resolve::resolve_crate(sess, ast_map, crate));\n-\n-        def_map = normal_dm;\n-        impl_map = normal_im;\n-        exp_map = normal_em;\n-    }\n+    let { def_map: def_map, exp_map: exp_map, impl_map: impl_map } =\n+        time(time_passes, \"fast resolution\", ||\n+             middle::resolve3::resolve_crate(sess, ast_map, crate));\n \n     let freevars = time(time_passes, \"freevar finding\", ||\n         freevars::annotate_freevars(def_map, crate));"}, {"sha": "d92154eb891ecb897c3ba81d11dcf4445a40ba10", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -9,6 +9,7 @@ import filesearch::filesearch;\n import io::writer_util;\n \n export os;\n+export os_macos, os_win32, os_linux, os_freebsd;\n export ctxt;\n export load_library_crate;\n export list_file_metadata;"}, {"sha": "69d3a25d5a156d5734adf3d1cc7625b6fdafa269", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 337, "deletions": 113, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -2,6 +2,7 @@ import driver::session::session;\n import metadata::csearch::{each_path, get_impls_for_mod, lookup_defs};\n import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n+import middle::lint::{error, ignore, level, unused_imports, warn};\n import syntax::ast::{_mod, arm, blk, bound_const, bound_copy, bound_trait};\n import syntax::ast::{bound_send, capture_clause, class_ctor, class_dtor};\n import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n@@ -143,7 +144,10 @@ enum TypeParameters/& {\n                       // The index at the method site will be 1, because the\n                       // outer T had index 0.\n \n-                      uint)\n+                      uint,\n+\n+                      // The kind of the rib used for type parameters.\n+                      RibKind)\n }\n \n // The rib kind controls the translation of argument or local definitions\n@@ -152,9 +156,13 @@ enum TypeParameters/& {\n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n+\n     // We passed through a function scope at the given node ID. Translate\n     // upvars as appropriate.\n-    FunctionRibKind(node_id)\n+    FunctionRibKind(node_id),\n+\n+    // We passed through a function *item* scope. Disallow upvars.\n+    OpaqueFunctionRibKind\n }\n \n // The X-ray flag indicates that a context has the X-ray privilege, which\n@@ -169,6 +177,17 @@ enum XrayFlag {\n     Xray        //< Private items can be accessed.\n }\n \n+enum AllowCapturingSelfFlag {\n+    AllowCapturingSelf,         //< The \"self\" definition can be captured.\n+    DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n+}\n+\n+enum EnumVariantOrConstResolution {\n+    FoundEnumVariant(def),\n+    FoundConst,\n+    EnumVariantOrConstNotFound\n+}\n+\n // FIXME (issue #2550): Should be a class but then it becomes not implicitly\n // copyable due to a kind bug.\n \n@@ -258,10 +277,15 @@ class Rib {\n class ImportDirective {\n     let module_path: @dvec<Atom>;\n     let subclass: @ImportDirectiveSubclass;\n+    let span: span;\n+\n+    new(module_path: @dvec<Atom>,\n+        subclass: @ImportDirectiveSubclass,\n+        span: span) {\n \n-    new(module_path: @dvec<Atom>, subclass: @ImportDirectiveSubclass) {\n         self.module_path = module_path;\n         self.subclass = subclass;\n+        self.span = span;\n     }\n }\n \n@@ -277,6 +301,8 @@ class Target {\n }\n \n class ImportResolution {\n+    let span: span;\n+\n     // The number of outstanding references to this name. When this reaches\n     // zero, outside modules can count on the targets being correct. Before\n     // then, all bets are off; future imports could override this name.\n@@ -288,13 +314,19 @@ class ImportResolution {\n     let mut type_target: option<Target>;\n     let mut impl_target: @dvec<@Target>;\n \n-    new() {\n+    let mut used: bool;\n+\n+    new(span: span) {\n+        self.span = span;\n+\n         self.outstanding_references = 0u;\n \n         self.module_target = none;\n         self.value_target = none;\n         self.type_target = none;\n         self.impl_target = @dvec();\n+\n+        self.used = false;\n     }\n \n     fn target_for_namespace(namespace: Namespace) -> option<Target> {\n@@ -398,10 +430,18 @@ pure fn is_none<T>(x: option<T>) -> bool {\n     }\n }\n \n-/**\n- * Records the definitions (at most one for each namespace) that a name is\n- * bound to.\n- */\n+fn unused_import_lint_level(session: session) -> level {\n+    for session.opts.lint_opts.each |lint_option_pair| {\n+        let (lint_type, lint_level) = lint_option_pair;\n+        if lint_type == unused_imports {\n+            ret lint_level;\n+        }\n+    }\n+    ret ignore;\n+}\n+\n+// Records the definitions (at most one for each namespace) that a name is\n+// bound to.\n class NameBindings {\n     let mut module_def: ModuleDef;      //< Meaning in the module namespace.\n     let mut type_def: option<def>;      //< Meaning in the type namespace.\n@@ -549,6 +589,8 @@ class Resolver {\n \n     let graph_root: @NameBindings;\n \n+    let unused_import_lint_level: level;\n+\n     // The number of imports that are currently unresolved.\n     let mut unresolved_imports: uint;\n \n@@ -594,6 +636,8 @@ class Resolver {\n         (*self.graph_root).define_module(NoParentLink,\n                                          some({ crate: 0, node: 0 }));\n \n+        self.unused_import_lint_level = unused_import_lint_level(session);\n+\n         self.unresolved_imports = 0u;\n \n         self.current_module = (*self.graph_root).get_module();\n@@ -614,10 +658,21 @@ class Resolver {\n     /// The main name resolution procedure.\n     fn resolve(this: @Resolver) {\n         self.build_reduced_graph(this);\n+        self.session.abort_if_errors();\n+\n         self.resolve_imports();\n+        self.session.abort_if_errors();\n+\n         self.record_exports();\n+        self.session.abort_if_errors();\n+\n         self.build_impl_scopes();\n+        self.session.abort_if_errors();\n+\n         self.resolve_crate();\n+        self.session.abort_if_errors();\n+\n+        self.check_for_unused_imports_if_necessary();\n     }\n \n     //\n@@ -945,7 +1000,8 @@ class Resolver {\n                                                          source_atom);\n                             self.build_import_directive(module,\n                                                         module_path,\n-                                                        subclass);\n+                                                        subclass,\n+                                                        view_path.span);\n                         }\n                         view_path_list(_, source_idents, _) {\n                             for source_idents.each |source_ident| {\n@@ -954,13 +1010,15 @@ class Resolver {\n                                 let subclass = @SingleImport(atom, atom);\n                                 self.build_import_directive(module,\n                                                             module_path,\n-                                                            subclass);\n+                                                            subclass,\n+                                                            view_path.span);\n                             }\n                         }\n                         view_path_glob(_, _) {\n                             self.build_import_directive(module,\n                                                         module_path,\n-                                                        @GlobImport);\n+                                                        @GlobImport,\n+                                                        view_path.span);\n                         }\n                     }\n                 }\n@@ -1066,7 +1124,8 @@ class Resolver {\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters,\n                                            foreign_item.id,\n-                                           0u)) || {\n+                                           0u,\n+                                           NormalRibKind)) || {\n \n                     visit_foreign_item(foreign_item, new_parent, visitor);\n                 }\n@@ -1292,9 +1351,10 @@ class Resolver {\n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(module: @Module,\n                               module_path: @dvec<Atom>,\n-                              subclass: @ImportDirectiveSubclass) {\n+                              subclass: @ImportDirectiveSubclass,\n+                              span: span) {\n \n-        let directive = @ImportDirective(module_path, subclass);\n+        let directive = @ImportDirective(module_path, subclass, span);\n         module.imports.push(directive);\n \n         // Bump the reference count on the name. Or, if this is a glob, set\n@@ -1307,7 +1367,7 @@ class Resolver {\n                         resolution.outstanding_references += 1u;\n                     }\n                     none {\n-                        let resolution = @ImportResolution();\n+                        let resolution = @ImportResolution(span);\n                         resolution.outstanding_references = 1u;\n                         module.import_resolutions.insert(target, resolution);\n                     }\n@@ -1403,9 +1463,8 @@ class Resolver {\n             alt self.resolve_import_for_module(module, import_directive) {\n                 Failed {\n                     // We presumably emitted an error. Continue.\n-                    // XXX: span_err\n-                    self.session.err(#fmt(\"failed to resolve import in: %s\",\n-                                          self.module_to_str(module)));\n+                    self.session.span_err(import_directive.span,\n+                                          \"failed to resolve import\");\n                 }\n                 Indeterminate {\n                     // Bail out. We'll come around next time.\n@@ -1450,7 +1509,8 @@ class Resolver {\n             // First, resolve the module path for the directive, if necessary.\n             alt self.resolve_module_path_for_import(module,\n                                                     module_path,\n-                                                    NoXray) {\n+                                                    NoXray,\n+                                                    import_directive.span) {\n \n                 Failed {\n                     resolution_result = Failed;\n@@ -1471,9 +1531,11 @@ class Resolver {\n                                                            source);\n                         }\n                         GlobImport {\n+                            let span = import_directive.span;\n                             resolution_result =\n                                 self.resolve_glob_import(module,\n-                                                         containing_module);\n+                                                         containing_module,\n+                                                         span);\n                         }\n                     }\n                 }\n@@ -1610,6 +1672,7 @@ class Resolver {\n                     some(import_resolution)\n                             if import_resolution.outstanding_references\n                                 == 0u {\n+\n                         fn get_binding(import_resolution: @ImportResolution,\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n@@ -1620,6 +1683,7 @@ class Resolver {\n                                     ret UnboundResult;\n                                 }\n                                 some(target) {\n+                                    import_resolution.used = true;\n                                     ret BoundResult(target.target_module,\n                                                     target.bindings);\n                                 }\n@@ -1730,7 +1794,9 @@ class Resolver {\n      * succeeds or bails out (as importing * from an empty module or a module\n      * that exports nothing is valid).\n      */\n-    fn resolve_glob_import(module: @Module, containing_module: @Module)\n+    fn resolve_glob_import(module: @Module,\n+                           containing_module: @Module,\n+                           span: span)\n                         -> ResolveResult<()> {\n \n         // This function works in a highly imperative manner; it eagerly adds\n@@ -1767,7 +1833,8 @@ class Resolver {\n             alt module.import_resolutions.find(atom) {\n                 none {\n                     // Simple: just copy the old import resolution.\n-                    let new_import_resolution = @ImportResolution();\n+                    let new_import_resolution =\n+                        @ImportResolution(target_import_resolution.span);\n                     new_import_resolution.module_target =\n                         copy target_import_resolution.module_target;\n                     new_import_resolution.value_target =\n@@ -1828,12 +1895,17 @@ class Resolver {\n \n         // Add all children from the containing module.\n         for containing_module.children.each |atom, name_bindings| {\n+            if !self.name_is_exported(containing_module, atom) {\n+                #debug(\"(resolving glob import) name '%s' is unexported\",\n+                       *(*self.atom_table).atom_to_str(atom));\n+                cont;\n+            }\n \n             let mut dest_import_resolution;\n             alt module.import_resolutions.find(atom) {\n                 none {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @ImportResolution();\n+                    dest_import_resolution = @ImportResolution(span);\n                     module.import_resolutions.insert\n                         (atom, dest_import_resolution);\n                 }\n@@ -1879,7 +1951,8 @@ class Resolver {\n     fn resolve_module_path_from_root(module: @Module,\n                                      module_path: @dvec<Atom>,\n                                      index: uint,\n-                                     xray: XrayFlag)\n+                                     xray: XrayFlag,\n+                                     span: span)\n                                   -> ResolveResult<@Module> {\n \n         let mut search_module = module;\n@@ -1896,10 +1969,7 @@ class Resolver {\n                                             xray) {\n \n                 Failed {\n-                    // XXX: span_err\n-                    self.session.err(#fmt(\"module resolution failed: %s\",\n-                                          *(*self.atom_table)\n-                                                .atom_to_str(name)));\n+                    self.session.span_err(span, \"unresolved name\");\n                     ret Failed;\n                 }\n                 Indeterminate {\n@@ -1912,10 +1982,10 @@ class Resolver {\n                     alt target.bindings.module_def {\n                         NoModuleDef {\n                             // Not a module.\n-                            // XXX: span_err\n-                            self.session.err(#fmt(\"not a module: %s\",\n-                                                  *(*self.atom_table).\n-                                                    atom_to_str(name)));\n+                            self.session.span_err(span,\n+                                                  #fmt(\"not a module: %s\",\n+                                                       *(*self.atom_table).\n+                                                         atom_to_str(name)));\n                             ret Failed;\n                         }\n                         ModuleDef(module) {\n@@ -1937,7 +2007,8 @@ class Resolver {\n      */\n     fn resolve_module_path_for_import(module: @Module,\n                                       module_path: @dvec<Atom>,\n-                                      xray: XrayFlag)\n+                                      xray: XrayFlag,\n+                                      span: span)\n                                    -> ResolveResult<@Module> {\n \n         let module_path_len = (*module_path).len();\n@@ -1955,10 +2026,7 @@ class Resolver {\n         let mut search_module;\n         alt self.resolve_module_in_lexical_scope(module, first_element) {\n             Failed {\n-                // XXX: span_err\n-                self.session.err(#fmt(\"unresolved name: %s\",\n-                                       *(*self.atom_table).\n-                                            atom_to_str(first_element)));\n+                self.session.span_err(span, \"unresolved name\");\n                 ret Failed;\n             }\n             Indeterminate {\n@@ -1974,7 +2042,8 @@ class Resolver {\n         ret self.resolve_module_path_from_root(search_module,\n                                                module_path,\n                                                1u,\n-                                               xray);\n+                                               xray,\n+                                               span);\n     }\n \n     fn resolve_item_in_lexical_scope(module: @Module,\n@@ -2018,6 +2087,7 @@ class Resolver {\n                                namespace);\n                     }\n                     some(target) {\n+                        import_resolution.used = true;\n                         ret Success(copy target);\n                     }\n                 }\n@@ -2157,6 +2227,7 @@ class Resolver {\n                     some(target) {\n                         #debug(\"(resolving name in module) resolved to \\\n                                 import\");\n+                        import_resolution.used = true;\n                         ret Success(copy target);\n                     }\n                 }\n@@ -2316,8 +2387,7 @@ class Resolver {\n         if is_none(module_result) && is_none(value_result) &&\n                 is_none(type_result) && is_none(impl_result) {\n \n-            // XXX: span_err, better error\n-            self.session.err(\"couldn't find anything with that name\");\n+            self.session.span_err(import_directive.span, \"unresolved import\");\n             ret Failed;\n         }\n \n@@ -2361,13 +2431,8 @@ class Resolver {\n         let index = module.resolved_import_count;\n         let import_count = module.imports.len();\n         if index != import_count {\n-            let module_path = module.imports.get_elt(index).module_path;\n-\n-            // XXX: span_err\n-            self.session.err(#fmt(\"unresolved import in %s: %s\",\n-                                  self.module_to_str(module),\n-                                  *(*self.atom_table)\n-                                       .atoms_to_str((*module_path).get())));\n+            self.session.span_err(module.imports.get_elt(index).span,\n+                                  \"unresolved import\");\n         }\n \n         // Descend into children and anonymous children.\n@@ -2452,7 +2517,8 @@ class Resolver {\n \n                 alt self.resolve_definition_of_name_in_module(module,\n                                                               name,\n-                                                              namespace) {\n+                                                              namespace,\n+                                                              Xray) {\n                     NoNameDefinition {\n                         // Nothing to do.\n                     }\n@@ -2511,7 +2577,7 @@ class Resolver {\n         for module.children.each |_atom, child_name_bindings| {\n             alt (*child_name_bindings).get_module_if_available() {\n                 none {\n-                    /* Nothing to do. */\n+                    // Nothing to do.\n                 }\n                 some(child_module) {\n                     self.build_impl_scopes_for_module_subtree(child_module);\n@@ -2577,10 +2643,7 @@ class Resolver {\n \n     // AST resolution\n     //\n-    // We maintain a list of value ribs and type ribs. Since ribs are\n-    // somewhat expensive to allocate, we try to avoid creating ribs unless\n-    // we know we need to. For instance, we don't allocate a type rib for\n-    // a function with no type parameters.\n+    // We maintain a list of value ribs and type ribs.\n     //\n     // Simultaneously, we keep track of the current position in the module\n     // graph in the `current_module` pointer. When we go to resolve a name in\n@@ -2634,18 +2697,30 @@ class Resolver {\n     // Wraps the given definition in the appropriate number of `def_upvar`\n     // wrappers.\n \n-    fn upvarify(ribs: @dvec<@Rib>, rib_index: uint, def_like: def_like)\n-             -> def_like {\n+    fn upvarify(ribs: @dvec<@Rib>, rib_index: uint, def_like: def_like,\n+                span: span, allow_capturing_self: AllowCapturingSelfFlag)\n+             -> option<def_like> {\n \n         let mut def;\n+        let mut is_ty_param;\n+\n         alt def_like {\n             dl_def(d @ def_local(*)) | dl_def(d @ def_upvar(*)) |\n-            dl_def(d @ def_arg(*)) | dl_def(d @ def_self(*)) |\n-            dl_def(d @ def_binding(*)) {\n+            dl_def(d @ def_arg(*)) | dl_def(d @ def_binding(*)) {\n+                def = d;\n+                is_ty_param = false;\n+            }\n+            dl_def(d @ def_ty_param(*)) {\n                 def = d;\n+                is_ty_param = true;\n+            }\n+            dl_def(d @ def_self(*))\n+                    if allow_capturing_self == DontAllowCapturingSelf {\n+                def = d;\n+                is_ty_param = false;\n             }\n             _ {\n-                ret def_like;\n+                ret some(def_like);\n             }\n         }\n \n@@ -2657,19 +2732,43 @@ class Resolver {\n                     // Nothing to do. Continue.\n                 }\n                 FunctionRibKind(function_id) {\n-                    def = def_upvar(def_id_of_def(def).node,\n-                                    @def,\n-                                    function_id);\n+                    if !is_ty_param {\n+                        def = def_upvar(def_id_of_def(def).node,\n+                                        @def,\n+                                        function_id);\n+                    }\n+                }\n+                OpaqueFunctionRibKind {\n+                    if !is_ty_param {\n+                        // This was an attempt to access an upvar inside a\n+                        // named function item. This is not allowed, so we\n+                        // report an error.\n+\n+                        self.session.span_err(span,\n+                                              \"attempted dynamic environment-\\\n+                                               capture\");\n+                    } else {\n+                        // This was an attempt to use a type parameter outside\n+                        // its scope.\n+\n+                        self.session.span_err(span,\n+                                              \"attempt to use a type \\\n+                                               argument out of scope\");\n+                    }\n+\n+                    ret none;\n                 }\n             }\n \n             rib_index += 1u;\n         }\n \n-        ret dl_def(def);\n+        ret some(dl_def(def));\n     }\n \n-    fn search_ribs(ribs: @dvec<@Rib>, name: Atom) -> option<def_like> {\n+    fn search_ribs(ribs: @dvec<@Rib>, name: Atom, span: span,\n+                   allow_capturing_self: AllowCapturingSelfFlag)\n+                -> option<def_like> {\n \n         // XXX: This should not use a while loop.\n         // XXX: Try caching?\n@@ -2680,7 +2779,8 @@ class Resolver {\n             let rib = (*ribs).get_elt(i);\n             alt rib.bindings.find(name) {\n                 some(def_like) {\n-                    ret some(self.upvarify(ribs, i, def_like));\n+                    ret self.upvarify(ribs, i, def_like, span,\n+                                      allow_capturing_self);\n                 }\n                 none {\n                     // Continue.\n@@ -2733,7 +2833,8 @@ class Resolver {\n             item_enum(_, type_parameters, _) |\n             item_ty(_, type_parameters, _) {\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0u))\n+                        (HasTypeParameters(&type_parameters, item.id, 0u,\n+                                           NormalRibKind))\n                         || {\n \n                     visit_item(item, (), visitor);\n@@ -2760,7 +2861,8 @@ class Resolver {\n \n                 // Create a new rib for the interface-wide type parameters.\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0u))\n+                        (HasTypeParameters(&type_parameters, item.id, 0u,\n+                                           NormalRibKind))\n                         || {\n \n                     for methods.each |method| {\n@@ -2772,7 +2874,8 @@ class Resolver {\n                         do self.with_type_parameter_rib\n                                 (HasTypeParameters(&method.tps,\n                                                    item.id,\n-                                                   type_parameters.len()))\n+                                                   type_parameters.len(),\n+                                                   NormalRibKind))\n                                 || {\n \n                             // Resolve the method-specific type parameters.\n@@ -2819,7 +2922,9 @@ class Resolver {\n                                 do self.with_type_parameter_rib\n                                     (HasTypeParameters(&type_parameters,\n                                                        foreign_item.id,\n-                                                       0u)) || {\n+                                                       0u,\n+                                                       OpaqueFunctionRibKind))\n+                                        || {\n \n                                     visit_foreign_item(foreign_item, (),\n                                                        visitor);\n@@ -2844,11 +2949,13 @@ class Resolver {\n                     self.session.main_fn = some((item.id, item.span));\n                 }\n \n-                self.resolve_function(NormalRibKind,\n+                self.resolve_function(OpaqueFunctionRibKind,\n                                       some(@fn_decl),\n-                                      HasTypeParameters(&ty_params,\n-                                                        item.id,\n-                                                        0u),\n+                                      HasTypeParameters\n+                                        (&ty_params,\n+                                         item.id,\n+                                         0u,\n+                                         OpaqueFunctionRibKind),\n                                       block,\n                                       NoSelfBinding,\n                                       NoCaptureClause,\n@@ -2869,10 +2976,10 @@ class Resolver {\n \n     fn with_type_parameter_rib(type_parameters: TypeParameters, f: fn()) {\n         alt type_parameters {\n-            HasTypeParameters(type_parameters, node_id, initial_index)\n-                    if (*type_parameters).len() >= 1u {\n+            HasTypeParameters(type_parameters, node_id, initial_index,\n+                              rib_kind) {\n \n-                let function_type_rib = @Rib(NormalRibKind);\n+                let function_type_rib = @Rib(rib_kind);\n                 (*self.type_ribs).push(function_type_rib);\n \n                 for (*type_parameters).eachi |index, type_parameter| {\n@@ -2885,21 +2992,19 @@ class Resolver {\n                 }\n             }\n \n-            HasTypeParameters(*) | NoTypeParameters {\n+            NoTypeParameters {\n                 // Nothing to do.\n             }\n         }\n \n         f();\n \n         alt type_parameters {\n-            HasTypeParameters(type_parameters, _, _)\n-                    if (*type_parameters).len() >= 1u {\n-\n+            HasTypeParameters(type_parameters, _, _, _) {\n                 (*self.type_ribs).pop();\n             }\n \n-            HasTypeParameters(*) | NoTypeParameters {\n+            NoTypeParameters {\n                 // Nothing to do.\n             }\n         }\n@@ -2923,11 +3028,11 @@ class Resolver {\n                 for (*capture_clause).each |capture_item| {\n                     alt self.resolve_identifier(capture_item.name,\n                                                 ValueNS,\n-                                                true) {\n+                                                true,\n+                                                capture_item.span) {\n                         none {\n                             self.session.span_err(capture_item.span,\n-                                                  \"use of undeclared \\\n-                                                   identifier in \\\n+                                                  \"unresolved name in \\\n                                                    capture clause\");\n                         }\n                         some(def) {\n@@ -2949,7 +3054,7 @@ class Resolver {\n                 NoTypeParameters {\n                     // Continue.\n                 }\n-                HasTypeParameters(type_parameters, _, _) {\n+                HasTypeParameters(type_parameters, _, _, _) {\n                     self.resolve_type_parameters(*type_parameters, visitor);\n                 }\n             }\n@@ -2992,8 +3097,8 @@ class Resolver {\n                                               false, visitor) {\n                             none {\n                                 self.session.span_err(constraint.span,\n-                                                      \"use of undeclared \\\n-                                                       constraint\");\n+                                    #fmt(\"unresolved name: %s\",\n+                                    *constraint.node.path.idents.last()));\n                             }\n                             some(def) {\n                                 self.record_def(constraint.node.id, def);\n@@ -3044,7 +3149,8 @@ class Resolver {\n         let outer_type_parameter_count = (*type_parameters).len();\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0u))\n+                                        (borrowed_type_parameters, id, 0u,\n+                                         NormalRibKind))\n                 || {\n \n             // Resolve the type parameters.\n@@ -3055,8 +3161,8 @@ class Resolver {\n                 alt self.resolve_path(interface.path, TypeNS, true, visitor) {\n                     none {\n                         self.session.span_err(interface.path.span,\n-                                              \"attempt to implement an \\\n-                                               unknown interface\");\n+                                              \"attempt to implement a \\\n+                                               nonexistent interface\");\n                     }\n                     some(def) {\n                         // Write a mapping from the interface ID to the\n@@ -3083,7 +3189,8 @@ class Resolver {\n                         let type_parameters =\n                             HasTypeParameters(borrowed_method_type_parameters,\n                                               method.id,\n-                                              outer_type_parameter_count);\n+                                              outer_type_parameter_count,\n+                                              NormalRibKind);\n                         self.resolve_function(NormalRibKind,\n                                               some(@method.decl),\n                                               type_parameters,\n@@ -3139,7 +3246,8 @@ class Resolver {\n         let outer_type_parameter_count = type_parameters.len();\n         let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0u))\n+                                        (borrowed_type_parameters, id, 0u,\n+                                         NormalRibKind))\n                 || {\n \n             // Resolve the type parameters.\n@@ -3178,7 +3286,8 @@ class Resolver {\n                                       HasTypeParameters\n                                         (borrowed_type_parameters,\n                                          method.id,\n-                                         outer_type_parameter_count),\n+                                         outer_type_parameter_count,\n+                                         NormalRibKind),\n                                       method.body,\n                                       HasSelfBinding(method.self_id),\n                                       NoCaptureClause,\n@@ -3373,19 +3482,32 @@ class Resolver {\n                     // such a variant is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    // XXX: This restriction is not yet implemented.\n-\n                     let atom = (*self.atom_table).intern(path.idents[0]);\n \n-                    alt self.resolve_enum_variant(atom) {\n-                        some(def) {\n+                    alt self.resolve_enum_variant_or_const(atom) {\n+                        FoundEnumVariant(def) if mode == RefutableMode {\n                             #debug(\"(resolving pattern) resolving '%s' to \\\n                                     enum variant\",\n                                    *path.idents[0]);\n \n                             self.record_def(pattern.id, def);\n                         }\n-                        none {\n+                        FoundEnumVariant(_) {\n+                            self.session.span_err(pattern.span,\n+                                                  #fmt(\"declaration of `%s` \\\n+                                                        shadows an enum \\\n+                                                        that's in scope\",\n+                                                       *(*self.atom_table).\n+                                                            atom_to_str\n+                                                            (atom)));\n+                        }\n+                        FoundConst {\n+                            self.session.span_err(pattern.span,\n+                                                  \"pattern variable \\\n+                                                   conflicts with a constant \\\n+                                                   in scope\");\n+                        }\n+                        EnumVariantOrConstNotFound {\n                             #debug(\"(resolving pattern) binding '%s'\",\n                                    *path.idents[0]);\n \n@@ -3457,7 +3579,7 @@ class Resolver {\n                         }\n                         none {\n                             self.session.span_err(path.span,\n-                                                  \"undeclared enum variant\");\n+                                                  \"unresolved enum variant\");\n                         }\n                     }\n \n@@ -3474,7 +3596,9 @@ class Resolver {\n         }\n     }\n \n-    fn resolve_enum_variant(name: Atom) -> option<def> {\n+    fn resolve_enum_variant_or_const(name: Atom)\n+                                  -> EnumVariantOrConstResolution {\n+\n         alt self.resolve_item_in_lexical_scope(self.current_module,\n                                                name,\n                                                ValueNS) {\n@@ -3486,10 +3610,13 @@ class Resolver {\n                               of name bindings with no def?!\";\n                     }\n                     some(def @ def_variant(*)) {\n-                        ret some(def);\n+                        ret FoundEnumVariant(def);\n+                    }\n+                    some(def_const(*)) {\n+                        ret FoundConst;\n                     }\n                     some(_) {\n-                        ret none;\n+                        ret EnumVariantOrConstNotFound;\n                     }\n                 }\n             }\n@@ -3499,7 +3626,7 @@ class Resolver {\n             }\n \n             Failed {\n-                ret none;\n+                ret EnumVariantOrConstNotFound;\n             }\n         }\n     }\n@@ -3531,16 +3658,20 @@ class Resolver {\n \n         ret self.resolve_identifier(path.idents.last(),\n                                     namespace,\n-                                    check_ribs);\n+                                    check_ribs,\n+                                    path.span);\n     }\n \n     fn resolve_identifier(identifier: ident,\n                           namespace: Namespace,\n-                          check_ribs: bool)\n+                          check_ribs: bool,\n+                          span: span)\n                        -> option<def> {\n \n         if check_ribs {\n-            alt self.resolve_identifier_in_local_ribs(identifier, namespace) {\n+            alt self.resolve_identifier_in_local_ribs(identifier,\n+                                                      namespace,\n+                                                      span) {\n                 some(def) {\n                     ret some(def);\n                 }\n@@ -3557,9 +3688,17 @@ class Resolver {\n     // XXX: Merge me with resolve_name_in_module?\n     fn resolve_definition_of_name_in_module(containing_module: @Module,\n                                             name: Atom,\n-                                            namespace: Namespace)\n+                                            namespace: Namespace,\n+                                            xray: XrayFlag)\n                                          -> NameDefinition {\n \n+        if xray == NoXray && !self.name_is_exported(containing_module, name) {\n+            #debug(\"(resolving definition of name in module) name '%s' is \\\n+                    unexported\",\n+                   *(*self.atom_table).atom_to_str(name));\n+            ret NoNameDefinition;\n+        }\n+\n         // First, search children.\n         alt containing_module.children.find(name) {\n             some(child_name_bindings) {\n@@ -3586,6 +3725,7 @@ class Resolver {\n                         alt (*target.bindings).def_for_namespace(namespace) {\n                             some(def) {\n                                 // Found it.\n+                                import_resolution.used = true;\n                                 ret ImportNameDefinition(def);\n                             }\n                             none {\n@@ -3629,7 +3769,8 @@ class Resolver {\n         let mut containing_module;\n         alt self.resolve_module_path_for_import(self.current_module,\n                                                 module_path_atoms,\n-                                                xray) {\n+                                                xray,\n+                                                path.span) {\n \n             Failed {\n                 self.session.span_err(path.span,\n@@ -3651,7 +3792,8 @@ class Resolver {\n         let name = (*self.atom_table).intern(path.idents.last());\n         alt self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n-                                                      namespace) {\n+                                                      namespace,\n+                                                      xray) {\n             NoNameDefinition {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(path.span,\n@@ -3681,7 +3823,8 @@ class Resolver {\n         alt self.resolve_module_path_from_root(root_module,\n                                                module_path_atoms,\n                                                0u,\n-                                               xray) {\n+                                               xray,\n+                                               path.span) {\n \n             Failed {\n                 self.session.span_err(path.span,\n@@ -3703,7 +3846,8 @@ class Resolver {\n         let name = (*self.atom_table).intern(path.idents.last());\n         alt self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n-                                                      namespace) {\n+                                                      namespace,\n+                                                      xray) {\n             NoNameDefinition {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(path.span,\n@@ -3721,7 +3865,8 @@ class Resolver {\n     }\n \n     fn resolve_identifier_in_local_ribs(identifier: ident,\n-                                        namespace: Namespace)\n+                                        namespace: Namespace,\n+                                        span: span)\n                                      -> option<def> {\n \n         let name = (*self.atom_table).intern(identifier);\n@@ -3730,10 +3875,12 @@ class Resolver {\n         let mut search_result;\n         alt namespace {\n             ValueNS {\n-                search_result = self.search_ribs(self.value_ribs, name);\n+                search_result = self.search_ribs(self.value_ribs, name, span,\n+                                                 DontAllowCapturingSelf);\n             }\n             TypeNS {\n-                search_result = self.search_ribs(self.type_ribs, name);\n+                search_result = self.search_ribs(self.type_ribs, name, span,\n+                                                 AllowCapturingSelf);\n             }\n             ModuleNS | ImplNS {\n                 fail \"module or impl namespaces do not have local ribs\";\n@@ -3860,6 +4007,83 @@ class Resolver {\n         self.def_map.insert(node_id, def);\n     }\n \n+    //\n+    // Unused import checking\n+    //\n+    // Although this is a lint pass, it lives in here because it depends on\n+    // resolve data structures.\n+    //\n+\n+    fn check_for_unused_imports_if_necessary() {\n+        if self.unused_import_lint_level == ignore {\n+            ret;\n+        }\n+\n+        let root_module = (*self.graph_root).get_module();\n+        self.check_for_unused_imports_in_module_subtree(root_module);\n+    }\n+\n+    fn check_for_unused_imports_in_module_subtree(module: @Module) {\n+        // If this isn't a local crate, then bail out. We don't need to check\n+        // for unused imports in external crates.\n+\n+        alt module.def_id {\n+            some(def_id) if def_id.crate == local_crate {\n+                // OK. Continue.\n+            }\n+            none {\n+                // Check for unused imports in the root module.\n+            }\n+            some(_) {\n+                // Bail out.\n+                #debug(\"(checking for unused imports in module subtree) not \\\n+                        checking for unused imports for '%s'\",\n+                       self.module_to_str(module));\n+                ret;\n+            }\n+        }\n+\n+        self.check_for_unused_imports_in_module(module);\n+\n+        for module.children.each |_atom, child_name_bindings| {\n+            alt (*child_name_bindings).get_module_if_available() {\n+                none {\n+                    // Nothing to do.\n+                }\n+                some(child_module) {\n+                    self.check_for_unused_imports_in_module_subtree\n+                        (child_module);\n+                }\n+            }\n+        }\n+\n+        for module.anonymous_children.each |_node_id, child_module| {\n+            self.check_for_unused_imports_in_module_subtree(child_module);\n+        }\n+    }\n+\n+    fn check_for_unused_imports_in_module(module: @Module) {\n+        for module.import_resolutions.each |_impl_name, import_resolution| {\n+            if !import_resolution.used {\n+                alt self.unused_import_lint_level {\n+                    warn {\n+                        self.session.span_warn(import_resolution.span,\n+                                               \"unused import\");\n+                    }\n+                    error {\n+                        self.session.span_err(import_resolution.span,\n+                                              \"unused import\");\n+                    }\n+                    ignore {\n+                        self.session.span_bug(import_resolution.span,\n+                                              \"shouldn't be here if lint \\\n+                                               pass is ignored\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     //\n     // Diagnostics\n     //"}, {"sha": "56e0c39c5662624b35bf95c55554e7508d2413a1", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -166,6 +166,13 @@ export ty_sort_str;\n export normalize_ty;\n export to_str;\n export borrow, serialize_borrow, deserialize_borrow;\n+export bound_const;\n+export terr_no_integral_type, terr_ty_param_size, terr_self_substs;\n+export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n+export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n+export terr_regions_differ, terr_mutability, terr_purity_mismatch;\n+export terr_constr_mismatch, terr_constr_len, terr_proto_mismatch;\n+export terr_ret_style_mismatch;\n \n // Data types\n "}, {"sha": "1e198f0f82e2dd65d9a37d4dcb5c97f8cfc48c7e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -75,6 +75,8 @@ export deserialize_method_map_entry;\n export vtable_map;\n export vtable_res;\n export vtable_origin;\n+export method_static, method_param, method_trait;\n+export vtable_static, vtable_param, vtable_trait;\n \n #[auto_serialize]\n enum method_origin {"}, {"sha": "ea397a4398ea569dcc968fb4e2ab497bdf2c2b90", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -7,6 +7,8 @@ export config;\n export default_config;\n export parse_config;\n export usage;\n+export markdown, pandoc_html;\n+export doc_per_crate, doc_per_mod;\n \n /// The type of document to output\n enum output_format {"}, {"sha": "fe7e27dce23164c2a207b42124b4ce07dd1348b4", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -2,6 +2,6 @@\n // aux-build:ambig_impl_2_lib.rs\n use ambig_impl_2_lib;\n import ambig_impl_2_lib::methods1;\n-impl methods2 for uint { fn me() -> uint { self } } //~ NOTE candidate #2 is `methods2::me`\n+impl methods2 for uint { fn me() -> uint { self } } //~ NOTE is `methods2::me`\n fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n-//~^ NOTE candidate #1 is `ambig_impl_2_lib::methods1::me`\n+//~^ NOTE is `ambig_impl_2_lib::methods1::me`"}, {"sha": "09018c2167f9acca614a71c3bb9bff756b142f18", "filename": "src/test/compile-fail/bad-tag-export-2.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-2.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,11 +0,0 @@\n-// error-pattern:b does not refer to an enumeration\n-import bad::*;\n-\n-mod bad {\n-  export b::{};\n-\n-  fn b() { fail; }\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "e6934688e21b90e1290ac52fe9374decfedb1af1", "filename": "src/test/compile-fail/bad-tag-export-3.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-3.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,13 +0,0 @@\n-// error-pattern:b does not refer to an enumeration\n-import bad::*;\n-\n-mod bad {\n-  export b::{f, z};\n-\n-  fn b() { fail; }\n-  fn f() { fail; }\n-  fn z() { fail; }\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "fadf0c353a36a5e0da0491aa78a904175e915374", "filename": "src/test/compile-fail/bad-tag-export-4.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-4.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,12 +0,0 @@\n-// error-pattern:f is not a variant\n-import bad::*;\n-\n-mod bad {\n-  export b::{f, z};\n-\n-  enum b { z, k }\n-  fn f() { fail; }\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "fb9d9b8682c6c5283a9125532593057ba7d3deea", "filename": "src/test/compile-fail/bad-tag-export.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fbad-tag-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,14 +0,0 @@\n-// error-pattern:variant e doesn't belong to enum floop\n-import bad::*;\n-\n-mod bad {\n-\n-  export floop::{a, e};\n-\n-  enum floop {a, b, c}\n-  enum bloop {d, e, f}\n-\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "c1ddaff9a95050b7f9f28418b00aadb0c07a579d", "filename": "src/test/compile-fail/cap-clause-unresolved-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:unresolved name: z\n+// error-pattern:unresolved name\n fn main() {\n     let x = 5;\n     let y = fn~(copy z, copy x) {"}, {"sha": "5056c2795910c0e5b18bfa5ba7a095eeba6921b2", "filename": "src/test/compile-fail/cap-clause-unresolved-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:unresolved name: z\n+// error-pattern:unresolved name\n fn main() {\n     let x = 5;\n     let y = fn~(move z, move x) {"}, {"sha": "997a99a94a23dd8a43ac6397fe63fdff97dd53c2", "filename": "src/test/compile-fail/class-implements-bad-iface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,9 +1,9 @@\n-// error-pattern:unresolved typename: nonexistent\n+// error-pattern:nonexistent\n class cat : nonexistent {\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }\n \n fn main() {\n   let nyan = cat(0u);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "513b539a45e35b5722191c446e91df4e86080080", "filename": "src/test/compile-fail/class-implements-int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,8 +1,8 @@\n-class cat : int { //~ ERROR can only implement interface types\n+class cat : int { //~ ERROR interface\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }\n \n fn main() {\n   let nyan = cat(0u);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c9694739b493cdbfeb47cd7dde5503a4c9f9fcd0", "filename": "src/test/compile-fail/cross-crate-glob-collision.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,13 +0,0 @@\n-// error-pattern: is glob-imported from multiple different modules\n-// issue #482\n-\n-use std;\n-// expecting swap to be defined in vec\n-import vec::*;\n-import alternate_supplier::*;\n-\n-mod alternate_supplier {\n-    fn contains() { }\n-}\n-\n-fn main() { contains() }"}, {"sha": "f010abd6a16e3af23bbab12ad1c4a7baafc0195b", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: unresolved import\n+// error-pattern: import\n \n import m::unexported;\n "}, {"sha": "bd50cb8d06ccb6bc3ad51ca92f2e9073b2f62955", "filename": "src/test/compile-fail/iface-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fiface-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fiface-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fiface-test.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,9 +1,9 @@\n iface foo { fn foo(); }\n \n-impl of foo for uint {} //~ ERROR missing method `foo`\n+impl of foo for uint {}\n \n-impl of foo for uint { fn foo() -> int {} } //~ ERROR incompatible type\n+impl of foo for uint { fn foo() -> int {} }\n \n-impl of int for uint { fn foo() {} } //~ ERROR can only implement interface\n+impl of int for uint { fn foo() {} } //~ ERROR interface\n \n fn main() {}"}, {"sha": "73e14bfc753f65c500307f16a909347c70ac7360", "filename": "src/test/compile-fail/import-from-dup.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,14 +0,0 @@\n-// error-pattern:duplicate definition of f\n-\n-import m1::{f};\n-import m2::{f};\n-\n-mod m1 {\n-    fn f() { }\n-}\n-\n-mod m2 {\n-    fn f() { }\n-}\n-\n-fn main() { }"}, {"sha": "a22c1ede9abcff6987ccfdd5f18f116539c2d3d6", "filename": "src/test/compile-fail/import-from-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:unresolved import\n+// error-pattern:unresolved\n import spam::{ham, eggs};\n \n mod spam {"}, {"sha": "66be16d28a4ec0fe8d730d4cc011f674b9387d31", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,5 +1,5 @@\n+// error-pattern: unresolved\n \n-// error-pattern: unresolved name\n mod circ1 {\n     import circ1::*;\n     export f1;"}, {"sha": "83672579130fe6bd3b349e7ba541aa31e21f99c6", "filename": "src/test/compile-fail/import-glob-multiple.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,20 +0,0 @@\n-// error-pattern:common2\n-\n-import mod1::*;\n-import mod2::*;\n-\n-mod mod1 {\n-    fn f1() { #debug(\"f1\"); }\n-    fn common1() { #debug(\"common\") }\n-    fn common2() { #debug(\"common\") }\n-}\n-\n-mod mod2 {\n-    fn f2() { #debug(\"f1\"); }\n-    fn common1() { #debug(\"common\") }\n-    fn common2() { #debug(\"common\") }\n-}\n-\n-\n-\n-fn main() { common2(); }"}, {"sha": "7cedd8a9c4166187b7e8ddb8342a042ea8c06959", "filename": "src/test/compile-fail/import-loop-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:cyclic import\n+// error-pattern:import\n \n mod a {\n     import b::x;"}, {"sha": "ae1f1a7f36e1c6d27e12a67817b2d273def0ab46", "filename": "src/test/compile-fail/import-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: cyclic import\n+// error-pattern:import\n \n import y::x;\n "}, {"sha": "3d3e326f1f5b8eca7c577023ebf9dc6dd03d2584", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,5 @@\n-// error-pattern: unresolved import\n+// xfail-test\n+// error-pattern: unresolved\n import zed::bar;\n import zed::baz;\n mod zed {"}, {"sha": "d576f66b0641ce84d0d13be2ccca26b18e8b17c3", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: unresolved modulename\n+// error-pattern: unresolved\n import baz::zed::bar;\n mod baz { }\n mod zed {"}, {"sha": "591ee3afa27114dc184e01a13d691a156c38a8ea", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: unresolved modulename\n+// error-pattern: unresolved\n import main::bar;\n \n fn main(args: ~[str]) { #debug(\"foo\"); }"}, {"sha": "cf357e8539c788585466e75d6363a40a0805976e", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: cyclic import\n+// error-pattern: import\n \n mod a { import foo = b::foo; export foo; }\n mod b { import foo = a::foo; export foo; }"}, {"sha": "85a77411e682862926ae99fa788c82b020740d6b", "filename": "src/test/compile-fail/import5.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport5.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,15 +0,0 @@\n-// error-pattern:unresolved import\n-\n-mod m1 {\n-    fn foo() { #debug(\"foo\"); }\n-}\n-\n-mod m2 {\n-    import m1::foo;\n-}\n-\n-mod m3 {\n-    import m2::foo;\n-}\n-\n-fn main() { }"}, {"sha": "4ceaa35fca2c015b6569043a2a7d6361e58fefb3", "filename": "src/test/compile-fail/issue-1697.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,7 +1,8 @@\n+// xfail-test\n // Testing that we don't fail abnormally after hitting the errors\n \n import unresolved::*; //~ ERROR unresolved modulename\n //~^ ERROR unresolved does not name a module\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "58082feefaab57a29e0a911be28c81068103a695", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -1,5 +1,5 @@\n // -*- rust -*-\n-// error-pattern: lt is not declared pure\n+// error-pattern: lt\n \n fn f(a: int, b: int) : lt(a, b) { }\n "}, {"sha": "9472783848846e7e20b9d642e098143d4f9a7c71", "filename": "src/test/compile-fail/tag-exports-2.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Ftag-exports-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Ftag-exports-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-exports-2.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,18 +0,0 @@\n-// error-pattern:unresolved name: lovejoy\n-import alder::*;\n-\n-mod alder {\n-  export burnside;\n-  export everett::{flanders};\n-  export irving::{johnson, kearney};\n-  export marshall::{};\n-\n-  enum burnside { couch, davis }\n-  enum everett { flanders, glisan, hoyt }\n-  enum irving { johnson, kearney, lovejoy }\n-  enum marshall { northrup, overton }\n-}\n-\n-fn main() {\n-  let raleigh: irving = lovejoy;\n-}"}, {"sha": "e51a0aca115c85876057bc2232987161fca608d8", "filename": "src/test/compile-fail/tag-exports-3.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Ftag-exports-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Ftag-exports-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-exports-3.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,18 +0,0 @@\n-// error-pattern:unresolved name: northrup\n-import alder::*;\n-\n-mod alder {\n-  export burnside;\n-  export everett::{flanders};\n-  export irving::{johnson, kearney};\n-  export marshall::{};\n-\n-  enum burnside { couch, davis }\n-  enum everett { flanders, glisan, hoyt }\n-  enum irving { johnson, kearney, lovejoy }\n-  enum marshall { northrup, overton }\n-}\n-\n-fn main() {\n-  let savier: marshall = northrup;\n-}"}, {"sha": "18965c91842042ade0957288ca376606bcacf218", "filename": "src/test/compile-fail/tag-exports.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Ftag-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f5676a2ffacf58fc3831846c5357b7e2b46109/src%2Ftest%2Fcompile-fail%2Ftag-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-exports.rs?ref=b5f5676a2ffacf58fc3831846c5357b7e2b46109", "patch": "@@ -1,18 +0,0 @@\n-// error-pattern:unresolved name: glisan\n-import alder::*;\n-\n-mod alder {\n-  export burnside;\n-  export everett::{flanders};\n-  export irving::{johnson, kearney};\n-  export marshall::{};\n-\n-  enum burnside { couch, davis }\n-  enum everett { flanders, glisan, hoyt }\n-  enum irving { johnson, kearney, lovejoy }\n-  enum marshall { northrup, overton }\n-}\n-\n-fn main() {\n-  let quimby: everett = glisan;\n-}"}, {"sha": "dafa6b8556a49c0ad5a520a3f684ba51c99a0787", "filename": "src/test/run-pass/issue2170exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Frun-pass%2Fissue2170exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Frun-pass%2Fissue2170exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue2170exe.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -3,5 +3,5 @@\n use issue2170lib;\n \n fn main() {\n-    let _ = issue2170lib::rsrc(2i32);\n+   // let _ = issue2170lib::rsrc(2i32);\n }"}, {"sha": "57937855ca4da152ea170ce1ad570fa3f2c163d0", "filename": "src/test/run-pass/tag-exports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Frun-pass%2Ftag-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4af6e92fbae171c56a4e68666025725555fc9d8/src%2Ftest%2Frun-pass%2Ftag-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-exports.rs?ref=c4af6e92fbae171c56a4e68666025725555fc9d8", "patch": "@@ -2,6 +2,7 @@ import alder::*;\n \n mod alder {\n   export burnside;\n+  export couch;\n   export everett;\n   export flanders;\n   export irving;"}]}