{"sha": "214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "node_id": "C_kwDOAAsO6NoAKDIxNGU2NWMyZWI3ODhiNTBkODI3ZDY0ZTdiZWU0YzkxNWNlNGRkZDI", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-13T17:31:58Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-03-03T17:47:48Z"}, "message": "Add unuseless `#[allow(unused_allocation)]`", "tree": {"sha": "49075653a1856650fe75167a97aa137f9b11486c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49075653a1856650fe75167a97aa137f9b11486c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "html_url": "https://github.com/rust-lang/rust/commit/214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f3c25a6310bf9a7d13cec0beb11ad155f55407e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3c25a6310bf9a7d13cec0beb11ad155f55407e", "html_url": "https://github.com/rust-lang/rust/commit/6f3c25a6310bf9a7d13cec0beb11ad155f55407e"}], "stats": {"total": 37, "additions": 17, "deletions": 20}, "files": [{"sha": "5b91aaf9ea5541db509a26ff361c5880038275c6", "filename": "tests/ui/iterators/into-iter-on-arrays-lint.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed?ref=214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "patch": "@@ -2,7 +2,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n-#[allow(unused_must_use)]\n+#[allow(unused_must_use, unused_allocation)]\n fn main() {\n     let small = [1, 2];\n     let big = [0u8; 33];"}, {"sha": "25b0cef73d77784ee20342fa2fd1d71cddb5ee1f", "filename": "tests/ui/iterators/into-iter-on-arrays-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs?ref=214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "patch": "@@ -2,7 +2,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n-#[allow(unused_must_use)]\n+#[allow(unused_must_use, unused_allocation)]\n fn main() {\n     let small = [1, 2];\n     let big = [0u8; 33];"}, {"sha": "b8b6f0846bb44e693408e9f94f83bc03fdd2bf52", "filename": "tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs?ref=214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "patch": "@@ -4,7 +4,7 @@\n // run-pass\n // needs-unwind Asserting on contents of error message\n \n-#![allow(path_statements)]\n+#![allow(path_statements, unused_allocation)]\n #![feature(box_syntax, core_intrinsics, generic_assert, generic_assert_internals)]\n \n macro_rules! test {"}, {"sha": "c4651ec717787edd9faf1e4e4282554e9682de0c", "filename": "tests/ui/self/arbitrary_self_types_trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs?ref=214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_allocation)]\n \n use std::rc::Rc;\n \n@@ -13,7 +14,7 @@ impl Trait for Vec<i32> {\n }\n \n fn main() {\n-    let v = vec![1,2,3];\n+    let v = vec![1, 2, 3];\n \n-    assert_eq!(&[1,2,3], Box::new(Rc::new(v)).trait_method());\n+    assert_eq!(&[1, 2, 3], Box::new(Rc::new(v)).trait_method());\n }"}, {"sha": "54092542f98fae143ce38e0124524c0755ef5ec5", "filename": "tests/ui/structs-enums/align-struct.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fstructs-enums%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214e65c2eb788b50d827d64e7bee4c915ce4ddd2/tests%2Fui%2Fstructs-enums%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Falign-struct.rs?ref=214e65c2eb788b50d827d64e7bee4c915ce4ddd2", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(dead_code)]\n+#![allow(dead_code, unused_allocation)]\n \n use std::mem;\n \n@@ -20,7 +20,6 @@ struct AlignMany(i32);\n \n // Raising alignment may not alter size.\n #[repr(align(8))]\n-#[allow(dead_code)]\n struct Align8Many {\n     a: i32,\n     b: i32,\n@@ -29,9 +28,8 @@ struct Align8Many {\n }\n \n enum Enum {\n-    #[allow(dead_code)]\n     A(i32),\n-    B(Align16)\n+    B(Align16),\n }\n \n // Nested alignment - use `#[repr(C)]` to suppress field reordering for sizeof test\n@@ -73,7 +71,7 @@ struct AlignLarge {\n \n union UnionContainsAlign {\n     a: Align16,\n-    b: f32\n+    b: f32,\n }\n \n impl Align16 {\n@@ -158,7 +156,7 @@ pub fn main() {\n     // Note that the size of Nested may change if struct field re-ordering is enabled\n     assert_eq!(mem::align_of::<Nested>(), 16);\n     assert_eq!(mem::size_of::<Nested>(), 48);\n-    let a = Nested{ a: 1, b: 2, c: Align16(3), d: 4};\n+    let a = Nested { a: 1, b: 2, c: Align16(3), d: 4 };\n     assert_eq!(mem::align_of_val(&a), 16);\n     assert_eq!(mem::align_of_val(&a.b), 4);\n     assert_eq!(mem::align_of_val(&a.c), 16);\n@@ -179,8 +177,8 @@ pub fn main() {\n             assert_eq!(a.0, 15);\n             assert_eq!(mem::align_of_val(a), 16);\n             assert_eq!(mem::size_of_val(a), 16);\n-        },\n-        _ => ()\n+        }\n+        _ => (),\n     }\n     assert!(is_aligned_to(&e, 16));\n \n@@ -197,8 +195,8 @@ pub fn main() {\n     }\n \n     // arrays of aligned elements should also be aligned\n-    assert_eq!(mem::align_of::<[Align16;2]>(), 16);\n-    assert_eq!(mem::size_of::<[Align16;2]>(), 32);\n+    assert_eq!(mem::align_of::<[Align16; 2]>(), 16);\n+    assert_eq!(mem::size_of::<[Align16; 2]>(), 32);\n \n     let a = [Align16(0), Align16(1)];\n     assert_eq!(mem::align_of_val(&a[0]), 16);\n@@ -209,7 +207,7 @@ pub fn main() {\n     assert_eq!(mem::align_of_val(Box::new(Align16(0)).as_ref()), 16);\n \n     // check heap array is aligned\n-    let a = vec!(Align16(0), Align16(1));\n+    let a = vec![Align16(0), Align16(1)];\n     assert_eq!(mem::align_of_val(&a[0]), 16);\n     assert_eq!(mem::align_of_val(&a[1]), 16);\n \n@@ -224,16 +222,14 @@ pub fn main() {\n \n     assert_eq!(mem::align_of::<AlignContainsPacked4C>(), 16);\n     assert_eq!(mem::size_of::<AlignContainsPacked4C>(), 32);\n-    let a = AlignContainsPacked4C { a: Packed4C{ a: 1, b: 2 }, b: 3 };\n+    let a = AlignContainsPacked4C { a: Packed4C { a: 1, b: 2 }, b: 3 };\n     assert_eq!(mem::align_of_val(&a), 16);\n     assert_eq!(mem::align_of_val(&a.a), 4);\n     assert_eq!(mem::align_of_val(&a.b), mem::align_of::<u64>());\n     assert_eq!(mem::size_of_val(&a), 32);\n     assert!(is_aligned_to(&a, 16));\n \n-    let mut large = Box::new(AlignLarge {\n-        stuff: [0; 0x10000],\n-    });\n+    let mut large = Box::new(AlignLarge { stuff: [0; 0x10000] });\n     large.stuff[0] = 132;\n     *large.stuff.last_mut().unwrap() = 102;\n     assert_eq!(large.stuff[0], 132);"}]}