{"sha": "6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYjFhMGVhN2MxNTBjMGQzYWMzNjE5OTZhOTkzY2Q5NTQ4ZjZkYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-19T17:40:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-19T17:40:56Z"}, "message": "Auto merge of #28497 - apasel422:issue-28493, r=Gankro\n\nWhen both the key and value types were zero-sized, `BTreeMap` previously\r\ncalled `heap::allocate` with `size == 0` for leaf nodes, which is\r\nundefined behavior, and jemalloc would attempt to read invalid memory,\r\ncrashing the process.\r\n\r\nThis avoids undefined behavior by allocating enough space to store one\r\nedge in leaf nodes that would otherwise have `size == 0`. Although this\r\nuses extra memory, maps with zero-sized key types that have sensible\r\nimplementations of the ordering traits can only contain a single\r\nkey-value pair (and therefore only a single leaf node), and maps with\r\nkey and value types that are both zero-sized have few uses, if any.\r\n\r\nFurthermore, this is a temporary fix that will likely be unnecessary\r\nonce the `BTreeMap` implementation is rewritten to use parent pointers.\r\n\r\nCloses #28493.", "tree": {"sha": "a53708e1068cc9dea59639448a08d169cba345bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a53708e1068cc9dea59639448a08d169cba345bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "html_url": "https://github.com/rust-lang/rust/commit/6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6db1a0ea7c150c0d3ac361996a993cd9548f6daa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5b029da1eb37b0478ce45587db7dc8f66b39b7", "html_url": "https://github.com/rust-lang/rust/commit/0b5b029da1eb37b0478ce45587db7dc8f66b39b7"}, {"sha": "9526813f5bc088261201934d7d6e574231eb252e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9526813f5bc088261201934d7d6e574231eb252e", "html_url": "https://github.com/rust-lang/rust/commit/9526813f5bc088261201934d7d6e574231eb252e"}], "stats": {"total": 60, "additions": 59, "deletions": 1}, "files": [{"sha": "f5088bf4646a5ecbdfd750ed0ddf6b7780257c4f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6db1a0ea7c150c0d3ac361996a993cd9548f6daa/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1a0ea7c150c0d3ac361996a993cd9548f6daa/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "patch": "@@ -164,7 +164,12 @@ fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize,\n     let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::align_of::<K>());\n     let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::align_of::<V>());\n     let (edges_size, edges_align) = if is_leaf {\n-        (0, 1)\n+        // allocate one edge to ensure that we don't pass size 0 to `heap::allocate`\n+        if mem::size_of::<K>() == 0 && mem::size_of::<V>() == 0 {\n+            (1, mem::align_of::<Node<K, V>>())\n+        } else {\n+            (0, 1)\n+        }\n     } else {\n         ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::align_of::<Node<K, V>>())\n     };"}, {"sha": "846353cc4e7c29abe36aad462e14b1d5bc8095c3", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6db1a0ea7c150c0d3ac361996a993cd9548f6daa/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1a0ea7c150c0d3ac361996a993cd9548f6daa/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "patch": "@@ -294,6 +294,59 @@ fn test_extend_ref() {\n     assert_eq!(a[&3], \"three\");\n }\n \n+#[test]\n+fn test_zst() {\n+    let mut m = BTreeMap::new();\n+    assert_eq!(m.len(), 0);\n+\n+    assert_eq!(m.insert((), ()), None);\n+    assert_eq!(m.len(), 1);\n+\n+    assert_eq!(m.insert((), ()), Some(()));\n+    assert_eq!(m.len(), 1);\n+    assert_eq!(m.iter().count(), 1);\n+\n+    m.clear();\n+    assert_eq!(m.len(), 0);\n+\n+    for _ in 0..100 {\n+        m.insert((), ());\n+    }\n+\n+    assert_eq!(m.len(), 1);\n+    assert_eq!(m.iter().count(), 1);\n+}\n+\n+// This test's only purpose is to ensure that zero-sized keys with nonsensical orderings\n+// do not cause segfaults when used with zero-sized values. All other map behavior is\n+// undefined.\n+#[test]\n+fn test_bad_zst() {\n+    use std::cmp::Ordering;\n+\n+    struct Bad;\n+\n+    impl PartialEq for Bad {\n+        fn eq(&self, _: &Self) -> bool { false }\n+    }\n+\n+    impl Eq for Bad {}\n+\n+    impl PartialOrd for Bad {\n+        fn partial_cmp(&self, _: &Self) -> Option<Ordering> { Some(Ordering::Less) }\n+    }\n+\n+    impl Ord for Bad {\n+        fn cmp(&self, _: &Self) -> Ordering { Ordering::Less }\n+    }\n+\n+    let mut m = BTreeMap::new();\n+\n+    for _ in 0..100 {\n+        m.insert(Bad, Bad);\n+    }\n+}\n+\n mod bench {\n     use std::collections::BTreeMap;\n     use std::__rand::{Rng, thread_rng};"}]}