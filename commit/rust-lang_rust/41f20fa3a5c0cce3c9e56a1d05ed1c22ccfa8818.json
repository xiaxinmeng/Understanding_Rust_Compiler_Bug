{"sha": "41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "node_id": "C_kwDOAAsO6NoAKDQxZjIwZmEzYTVjMGNjZTNjOWU1NmExZDA1ZWQxYzIyY2NmYTg4MTg", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-01-31T02:45:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-31T02:45:14Z"}, "message": "Support 128-bit integers on platforms without native support (#103)\n\n* Use sized integer types\r\n\r\n* Add support for integer types not supported on some platforms\r\n\r\n* Add feature to test non-native integers in CI", "tree": {"sha": "fa85b85bac74fafa64ea759c0affb6bfc25e97bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa85b85bac74fafa64ea759c0affb6bfc25e97bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh9006CRBK7hj4Ov3rIwAAcIwIAHTRNDEf2b2gls3P/gDBlCOF\n69Heg2es0knFEhQv+Bj12YA/ioIVmKqDvN1vrQ8j/HDKD0dF9HsAnHHJQIzeQTy+\n4kDDhaWj7ct/Un1SUVD+oEasWWx6p/bNUhNpRA3ovGKTEkPZZOHxklhiTkenV8KZ\nPOTmecfp179Dd0O3P3Bxku+3quieGL3vrwZsNlZuhhvnA/5vnr26qX7wezkJJMVJ\nl3oZXiizXHQvuNNZu9JsKVqIBz0Dj3ZdyospXOBHjgETb4yPHWrx4oRf25ZgSO16\nw2yIveZ2wHLMrEoDD9Oxfny0YwJ7spxcYp2aK5ux1Mm5tXSvJWEplTIh5AdZ6PM=\n=jcvh\n-----END PGP SIGNATURE-----\n", "payload": "tree fa85b85bac74fafa64ea759c0affb6bfc25e97bd\nparent b7bfb21242bec640826f33a73e0ad4365ab9a841\nauthor antoyo <antoyo@users.noreply.github.com> 1643597114 -0500\ncommitter GitHub <noreply@github.com> 1643597114 -0500\n\nSupport 128-bit integers on platforms without native support (#103)\n\n* Use sized integer types\r\n\r\n* Add support for integer types not supported on some platforms\r\n\r\n* Add feature to test non-native integers in CI"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "html_url": "https://github.com/rust-lang/rust/commit/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7bfb21242bec640826f33a73e0ad4365ab9a841", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7bfb21242bec640826f33a73e0ad4365ab9a841", "html_url": "https://github.com/rust-lang/rust/commit/b7bfb21242bec640826f33a73e0ad4365ab9a841"}], "stats": {"total": 1565, "additions": 1215, "deletions": 350}, "files": [{"sha": "337837c40bfb86eb03fcb00a01b576af1156116d", "filename": ".github/workflows/ci.yml", "status": "renamed", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -10,30 +10,43 @@ jobs:\n \n     strategy:\n       fail-fast: false\n+      matrix:\n+        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\"]\n \n     steps:\n     - uses: actions/checkout@v2\n \n+    - uses: actions/checkout@v2\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n     - name: Install packages\n       run: sudo apt-get install ninja-build ripgrep\n \n     - name: Download artifact\n       uses: dawidd6/action-download-artifact@v2\n       with:\n           workflow: main.yml\n-          name: libgccjit.so\n+          name: ${{ matrix.libgccjit_version }}\n           path: gcc-build\n           repo: antoyo/gcc\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n \n     - name: Setup path to libgccjit\n       run: |\n           echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n           ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n \n-    - name: Set LIBRARY_PATH\n+    - name: Set env\n       run: |\n         echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n         echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n \n     # https://github.com/actions/cache/issues/133\n     - name: Fixup owner of ~/.cargo/", "previous_filename": ".github/workflows/main.yml"}, {"sha": "efda74b2633aedb0f50449b1500e9cd0f46ed0f9", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -18,3 +18,4 @@ gimple*\n res\n test-backend\n gcc_path\n+benchmarks"}, {"sha": "d4c407b0974fda9196a181cbeb602a2f26821510", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#e68fce53af18dce4d40e6b7090f881ff86a2e892\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#cbb07c6601ba4246fc2967c4d770403c57192ca2\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#e68fce53af18dce4d40e6b7090f881ff86a2e892\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#cbb07c6601ba4246fc2967c4d770403c57192ca2\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "6e333f1b641aeb46dafad0e73bc212356c9827e5", "filename": "Readme.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -109,6 +109,13 @@ Or add a breakpoint to `add_error` in gdb and print the line number using:\n \n ```\n p loc->m_line\n+p loc->m_filename->m_buffer\n+```\n+\n+To print a debug representation of a tree:\n+\n+```c\n+debug_tree(expr);\n ```\n \n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n@@ -134,4 +141,5 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Set `linker='-Clinker=m68k-linux-gcc'`.\n  * Set the path to the cross-compiling libgccjit in `gcc_path`.\n  * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n+ * Comment the line: `context.add_command_line_option(\"-masm=intel\");` in src/base.rs.\n  * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "8a621e12b04e4c274f8eb05dd6b57bc770a6d802", "filename": "build.sh", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -3,7 +3,7 @@\n #set -x\n set -e\n \n-if [ -f ./gcc_path ]; then \n+if [ -f ./gcc_path ]; then\n     export GCC_PATH=$(cat gcc_path)\n else\n     echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n@@ -13,13 +13,21 @@ fi\n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n \n+features=\n+\n+if [[ \"$1\" == \"--features\" ]]; then\n+    shift\n+    features=\"--features $1\"\n+    shift\n+fi\n+\n if [[ \"$1\" == \"--release\" ]]; then\n     export CHANNEL='release'\n-    CARGO_INCREMENTAL=1 cargo rustc --release\n+    CARGO_INCREMENTAL=1 cargo rustc --release $features\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n-    cargo rustc\n+    cargo rustc $features\n fi\n \n source config.sh"}, {"sha": "a965ca971a07d362635049c8a40a138800d20a60", "filename": "build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/build_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/build_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fbuild_sysroot.sh?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -22,7 +22,7 @@ if [[ \"$1\" == \"--release\" ]]; then\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release\n else\n     sysroot_channel='debug'\n-    cargo build --target $TARGET_TRIPLE\n+    cargo build --target $TARGET_TRIPLE --features compiler_builtins/c\n fi\n \n # Copy files to sysroot"}, {"sha": "b503bd020f6bb87a24267ca96edeb177fc06df43", "filename": "src/back/write.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fback%2Fwrite.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -45,7 +45,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 if env::var(\"CG_GCCJIT_DUMP_MODULE_NAMES\").as_deref() == Ok(\"1\") {\n                     println!(\"Module {}\", module.name);\n                 }\n-                if env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n+                if env::var(\"CG_GCCJIT_DUMP_ALL_MODULES\").as_deref() == Ok(\"1\") || env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n                     println!(\"Dumping reproducer {}\", module.name);\n                     let _ = fs::create_dir(\"/tmp/reproducers\");\n                     // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n@@ -54,6 +54,11 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                     context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n                     println!(\"Dumped reproducer {}\", module.name);\n                 }\n+                if env::var(\"CG_GCCJIT_DUMP_TO_FILE\").as_deref() == Ok(\"1\") {\n+                    let _ = fs::create_dir(\"/tmp/gccjit_dumps\");\n+                    let path = &format!(\"/tmp/gccjit_dumps/{}.c\", module.name);\n+                    context.dump_to_file(path, true);\n+                }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));\n             }\n "}, {"sha": "6808993182a03780204702340110bc083066f3c5", "filename": "src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -52,15 +52,15 @@ pub fn linkage_to_gcc(linkage: Linkage) -> FunctionType {\n     }\n }\n \n-pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<GccContext>, u64) {\n+pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_128bit_integers: bool) -> (ModuleCodegen<GccContext>, u64) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n     let (module, _) = tcx.dep_graph.with_task(\n         dep_node,\n         tcx,\n-        cgu_name,\n+        (cgu_name, supports_128bit_integers),\n         module_codegen,\n         Some(dep_graph::hash_result),\n     );\n@@ -71,7 +71,7 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n     // the time we needed for codegenning it.\n     let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n \n-    fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<GccContext> {\n+    fn module_codegen(tcx: TyCtxt<'_>, (cgu_name, supports_128bit_integers): (Symbol, bool)) -> ModuleCodegen<GccContext> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n@@ -106,7 +106,7 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n         }\n \n         {\n-            let cx = CodegenCx::new(&context, cgu, tcx);\n+            let cx = CodegenCx::new(&context, cgu, tcx, supports_128bit_integers);\n \n             let mono_items = cgu.items_in_deterministic_order(tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {"}, {"sha": "2969eda2d532c5b400216f8ad96c59368333878e", "filename": "src/builder.rs", "status": "modified", "additions": 41, "deletions": 187, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn atomic_extremum(&mut self, operation: ExtremumOperation, dst: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering) -> RValue<'gcc> {\n-        let size = self.cx.int_width(src.get_type()) / 8;\n+        let size = src.get_type().get_size();\n \n         let func = self.current_func();\n \n@@ -141,8 +141,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn compare_exchange(&self, dst: RValue<'gcc>, cmp: LValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n-        let size = self.cx.int_width(src.get_type());\n-        let compare_exchange = self.context.get_builtin_function(&format!(\"__atomic_compare_exchange_{}\", size / 8));\n+        let size = src.get_type().get_size();\n+        let compare_exchange = self.context.get_builtin_function(&format!(\"__atomic_compare_exchange_{}\", size));\n         let order = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n         let failure_order = self.context.new_rvalue_from_int(self.i32_type, failure_order.to_gcc());\n         let weak = self.context.new_rvalue_from_int(self.bool_type, weak as i32);\n@@ -290,7 +290,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n             current_block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n@@ -309,15 +309,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         }\n     }\n \n-    pub fn overflow_call(&mut self, func: Function<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    pub fn overflow_call(&self, func: Function<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local.\n         let return_type = self.context.new_type::<bool>();\n         let current_block = self.current_block.borrow().expect(\"block\");\n         let current_func = current_block.get_function();\n         // TODO(antoyo): return the new_call() directly? Since the overflow function has no side-effects.\n         unsafe { RETURN_VALUE_COUNT += 1 };\n-        let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+        let result = current_func.new_local(None, return_type, &format!(\"overflowReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n         current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n         result.to_rvalue()\n     }\n@@ -468,40 +468,32 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n     }\n \n-    fn add(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): this should not be required.\n-        if format!(\"{:?}\", a.get_type()) != format!(\"{:?}\", b.get_type()) {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a + b\n+    fn add(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_add(a, b)\n     }\n \n     fn fadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a + b\n     }\n \n-    fn sub(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() != b.get_type() {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a - b\n+    fn sub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_sub(a, b)\n     }\n \n     fn fsub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a - b\n     }\n \n     fn mul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a * b\n+        self.gcc_mul(a, b)\n     }\n \n     fn fmul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a * b\n     }\n \n     fn udiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): convert the arguments to unsigned?\n-        a / b\n+        self.gcc_udiv(a, b)\n     }\n \n     fn exactudiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -511,8 +503,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn sdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): convert the arguments to signed?\n-        a / b\n+        self.gcc_sdiv(a, b)\n     }\n \n     fn exactsdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -529,11 +520,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn urem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a % b\n+        self.gcc_urem(a, b)\n     }\n \n     fn srem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a % b\n+        self.gcc_srem(a, b)\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -549,104 +540,49 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn shl(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n-        let a_type = a.get_type();\n-        let b_type = b.get_type();\n-        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n-            let a = self.context.new_cast(None, a, b_type);\n-            let result = a << b;\n-            self.context.new_cast(None, result, a_type)\n-        }\n-        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n-            let b = self.context.new_cast(None, b, a_type);\n-            a << b\n-        }\n-        else {\n-            a << b\n-        }\n+        self.gcc_shl(a, b)\n     }\n \n     fn lshr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n-        // TODO(antoyo): cast to unsigned to do a logical shift if that does not work.\n-        let a_type = a.get_type();\n-        let b_type = b.get_type();\n-        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n-            let a = self.context.new_cast(None, a, b_type);\n-            let result = a >> b;\n-            self.context.new_cast(None, result, a_type)\n-        }\n-        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n-            let b = self.context.new_cast(None, b, a_type);\n-            a >> b\n-        }\n-        else {\n-            a >> b\n-        }\n+        self.gcc_lshr(a, b)\n     }\n \n     fn ashr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check whether behavior is an arithmetic shift for >> .\n-        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n-        let a_type = a.get_type();\n-        let b_type = b.get_type();\n-        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n-            let a = self.context.new_cast(None, a, b_type);\n-            let result = a >> b;\n-            self.context.new_cast(None, result, a_type)\n-        }\n-        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n-            let b = self.context.new_cast(None, b, a_type);\n-            a >> b\n-        }\n-        else {\n-            a >> b\n-        }\n+        // It seems to be if the value is signed.\n+        self.gcc_lshr(a, b)\n     }\n \n-    fn and(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() != b.get_type() {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a & b\n+    fn and(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_and(a, b)\n     }\n \n-    fn or(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() != b.get_type() {\n-            b = self.context.new_cast(None, b, a.get_type());\n-        }\n-        a | b\n+    fn or(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.cx.gcc_or(a, b)\n     }\n \n     fn xor(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a ^ b\n+        self.gcc_xor(a, b)\n     }\n \n     fn neg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n-        self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n+        self.gcc_neg(a)\n     }\n \n     fn fneg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n         self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n     }\n \n     fn not(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n-        let operation =\n-            if a.get_type().is_bool() {\n-                UnaryOp::LogicalNegate\n-            }\n-            else {\n-                UnaryOp::BitwiseNegate\n-            };\n-        self.cx.context.new_unary_op(None, operation, a.get_type(), a)\n+        self.gcc_not(a)\n     }\n \n     fn unchecked_sadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a + b\n     }\n \n     fn unchecked_uadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        a + b\n+        self.gcc_add(a, b)\n     }\n \n     fn unchecked_ssub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -655,7 +591,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn unchecked_usub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): should generate poison value?\n-        a - b\n+        self.gcc_sub(a, b)\n     }\n \n     fn unchecked_smul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n@@ -687,76 +623,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n-        use rustc_middle::ty::{Int, IntTy::*, Uint, UintTy::*};\n-\n-        let new_kind =\n-            match typ.kind() {\n-                Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n-                Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n-                t @ (Uint(_) | Int(_)) => t.clone(),\n-                _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n-            };\n-\n-        // TODO(antoyo): remove duplication with intrinsic?\n-        let name =\n-            match oop {\n-                OverflowOp::Add =>\n-                    match new_kind {\n-                        Int(I8) => \"__builtin_add_overflow\",\n-                        Int(I16) => \"__builtin_add_overflow\",\n-                        Int(I32) => \"__builtin_sadd_overflow\",\n-                        Int(I64) => \"__builtin_saddll_overflow\",\n-                        Int(I128) => \"__builtin_add_overflow\",\n-\n-                        Uint(U8) => \"__builtin_add_overflow\",\n-                        Uint(U16) => \"__builtin_add_overflow\",\n-                        Uint(U32) => \"__builtin_uadd_overflow\",\n-                        Uint(U64) => \"__builtin_uaddll_overflow\",\n-                        Uint(U128) => \"__builtin_add_overflow\",\n-\n-                        _ => unreachable!(),\n-                    },\n-                OverflowOp::Sub =>\n-                    match new_kind {\n-                        Int(I8) => \"__builtin_sub_overflow\",\n-                        Int(I16) => \"__builtin_sub_overflow\",\n-                        Int(I32) => \"__builtin_ssub_overflow\",\n-                        Int(I64) => \"__builtin_ssubll_overflow\",\n-                        Int(I128) => \"__builtin_sub_overflow\",\n-\n-                        Uint(U8) => \"__builtin_sub_overflow\",\n-                        Uint(U16) => \"__builtin_sub_overflow\",\n-                        Uint(U32) => \"__builtin_usub_overflow\",\n-                        Uint(U64) => \"__builtin_usubll_overflow\",\n-                        Uint(U128) => \"__builtin_sub_overflow\",\n-\n-                        _ => unreachable!(),\n-                    },\n-                OverflowOp::Mul =>\n-                    match new_kind {\n-                        Int(I8) => \"__builtin_mul_overflow\",\n-                        Int(I16) => \"__builtin_mul_overflow\",\n-                        Int(I32) => \"__builtin_smul_overflow\",\n-                        Int(I64) => \"__builtin_smulll_overflow\",\n-                        Int(I128) => \"__builtin_mul_overflow\",\n-\n-                        Uint(U8) => \"__builtin_mul_overflow\",\n-                        Uint(U16) => \"__builtin_mul_overflow\",\n-                        Uint(U32) => \"__builtin_umul_overflow\",\n-                        Uint(U64) => \"__builtin_umulll_overflow\",\n-                        Uint(U128) => \"__builtin_mul_overflow\",\n-\n-                        _ => unreachable!(),\n-                    },\n-            };\n-\n-        let intrinsic = self.context.get_builtin_function(&name);\n-        let res = self.current_func()\n-            // TODO(antoyo): is it correct to use rhs type instead of the parameter typ?\n-            .new_local(None, rhs.get_type(), \"binopResult\")\n-            .get_address(None);\n-        let overflow = self.overflow_call(intrinsic, &[lhs, rhs, res], None);\n-        (res.dereference(None).to_rvalue(), overflow)\n+        self.gcc_checked_binop(oop, typ, lhs, rhs)\n     }\n \n     fn alloca(&mut self, ty: Type<'gcc>, align: Align) -> RValue<'gcc> {\n@@ -1003,7 +870,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     /* Casts */\n     fn trunc(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check that it indeed truncate the value.\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_int_cast(value, dest_ty)\n     }\n \n     fn sext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1016,19 +883,19 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn fptoui(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_float_to_uint_cast(value, dest_ty)\n     }\n \n     fn fptosi(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_float_to_int_cast(value, dest_ty)\n     }\n \n     fn uitofp(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_uint_to_float_cast(value, dest_ty)\n     }\n \n     fn sitofp(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.context.new_cast(None, value, dest_ty)\n+        self.gcc_int_to_float_cast(value, dest_ty)\n     }\n \n     fn fptrunc(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1054,7 +921,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn intcast(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>, _is_signed: bool) -> RValue<'gcc> {\n         // NOTE: is_signed is for value, not dest_typ.\n-        self.cx.context.new_cast(None, value, dest_typ)\n+        self.gcc_int_cast(value, dest_typ)\n     }\n \n     fn pointercast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -1075,21 +942,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     /* Comparisons */\n-    fn icmp(&mut self, op: IntPredicate, mut lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        let left_type = lhs.get_type();\n-        let right_type = rhs.get_type();\n-        if left_type != right_type {\n-            // NOTE: because libgccjit cannot compare function pointers.\n-            if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n-                lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n-                rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n-            }\n-            // NOTE: hack because we try to cast a vector type to the same vector type.\n-            else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n-                rhs = self.context.new_cast(None, rhs, left_type);\n-            }\n-        }\n-        self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+    fn icmp(&mut self, op: IntPredicate, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        self.gcc_icmp(op, lhs, rhs)\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n@@ -1156,7 +1010,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         then_block.add_assignment(None, variable, then_val);\n         then_block.end_with_jump(None, after_block);\n \n-        if then_val.get_type() != else_val.get_type() {\n+        if !then_val.get_type().is_compatible_with(else_val.get_type()) {\n             else_val = self.context.new_cast(None, else_val, then_val.get_type());\n         }\n         else_block.add_assignment(None, variable, else_val);\n@@ -1322,7 +1176,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn atomic_rmw(&mut self, op: AtomicRmwBinOp, dst: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering) -> RValue<'gcc> {\n-        let size = self.cx.int_width(src.get_type()) / 8;\n+        let size = src.get_type().get_size();\n         let name =\n             match op {\n                 AtomicRmwBinOp::AtomicXchg => format!(\"__atomic_exchange_{}\", size),\n@@ -1396,7 +1250,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             // Fix the code in codegen_ssa::base::from_immediate.\n             return value;\n         }\n-        self.context.new_cast(None, value, dest_typ)\n+        self.gcc_int_cast(value, dest_typ)\n     }\n \n     fn cx(&self) -> &CodegenCx<'gcc, 'tcx> {\n@@ -1470,7 +1324,7 @@ impl<'tcx> HasTargetSpec for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-trait ToGccComp {\n+pub trait ToGccComp {\n     fn to_gcc_comparison(&self) -> ComparisonOp;\n }\n "}, {"sha": "89a3dc052d838bca388739865f3e30bae01e5525", "filename": "src/common.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -1,7 +1,5 @@\n-use std::convert::TryFrom;\n-\n use gccjit::LValue;\n-use gccjit::{Block, CType, RValue, Type, ToRValue};\n+use gccjit::{Block, RValue, Type, ToRValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods,\n@@ -111,29 +109,15 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn const_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n-        self.context.new_rvalue_from_long(typ, i64::try_from(int).expect(\"i64::try_from\"))\n+        self.gcc_int(typ, int)\n     }\n \n     fn const_uint(&self, typ: Type<'gcc>, int: u64) -> RValue<'gcc> {\n-        self.context.new_rvalue_from_long(typ, u64::try_from(int).expect(\"u64::try_from\") as i64)\n+        self.gcc_uint(typ, int)\n     }\n \n     fn const_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n-        if num >> 64 != 0 {\n-            // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n-            let low = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n-            let high = self.context.new_rvalue_from_long(typ, (num >> 64) as u64 as i64);\n-\n-            let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n-            (high << sixty_four) | self.context.new_cast(None, low, typ)\n-        }\n-        else if typ.is_i128(self) {\n-            let num = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n-            self.context.new_cast(None, num, typ)\n-        }\n-        else {\n-            self.context.new_rvalue_from_long(typ, num as u64 as i64)\n-        }\n+        self.gcc_uint_big(typ, num)\n     }\n \n     fn const_bool(&self, val: bool) -> RValue<'gcc> {\n@@ -425,11 +409,11 @@ impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n     }\n \n     fn is_i128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.context.new_c_type(CType::Int128t)\n+        self.unqualified() == cx.i128_type.unqualified()\n     }\n \n     fn is_u128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.context.new_c_type(CType::UInt128t)\n+        self.unqualified() == cx.u128_type.unqualified()\n     }\n \n     fn is_f32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {"}, {"sha": "795966d8183054d400221b7ccc1421c586d69fa2", "filename": "src/context.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -62,6 +62,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub ulonglong_type: Type<'gcc>,\n     pub sizet_type: Type<'gcc>,\n \n+    pub supports_128bit_integers: bool,\n+\n     pub float_type: Type<'gcc>,\n     pub double_type: Type<'gcc>,\n \n@@ -110,22 +112,29 @@ pub struct CodegenCx<'gcc, 'tcx> {\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n-    pub fn new(context: &'gcc Context<'gcc>, codegen_unit: &'tcx CodegenUnit<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+    pub fn new(context: &'gcc Context<'gcc>, codegen_unit: &'tcx CodegenUnit<'tcx>, tcx: TyCtxt<'tcx>, supports_128bit_integers: bool) -> Self {\n         let check_overflow = tcx.sess.overflow_checks();\n-        // TODO(antoyo): fix this mess. libgccjit seems to return random type when using new_int_type().\n-        let isize_type = context.new_c_type(CType::LongLong);\n-        let usize_type = context.new_c_type(CType::ULongLong);\n-        let bool_type = context.new_type::<bool>();\n-        let i8_type = context.new_type::<i8>();\n-        let i16_type = context.new_type::<i16>();\n-        let i32_type = context.new_type::<i32>();\n-        let i64_type = context.new_c_type(CType::LongLong);\n-        let i128_type = context.new_c_type(CType::Int128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?\n-        let u8_type = context.new_type::<u8>();\n-        let u16_type = context.new_type::<u16>();\n-        let u32_type = context.new_type::<u32>();\n-        let u64_type = context.new_c_type(CType::ULongLong);\n-        let u128_type = context.new_c_type(CType::UInt128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?\n+\n+        let i8_type = context.new_c_type(CType::Int8t);\n+        let i16_type = context.new_c_type(CType::Int16t);\n+        let i32_type = context.new_c_type(CType::Int32t);\n+        let i64_type = context.new_c_type(CType::Int64t);\n+        let u8_type = context.new_c_type(CType::UInt8t);\n+        let u16_type = context.new_c_type(CType::UInt16t);\n+        let u32_type = context.new_c_type(CType::UInt32t);\n+        let u64_type = context.new_c_type(CType::UInt64t);\n+\n+        let (i128_type, u128_type) =\n+            if supports_128bit_integers {\n+                let i128_type = context.new_c_type(CType::Int128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?;\n+                let u128_type = context.new_c_type(CType::UInt128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?;\n+                (i128_type, u128_type)\n+            }\n+            else {\n+                let i128_type = context.new_array_type(None, i64_type, 2);\n+                let u128_type = context.new_array_type(None, u64_type, 2);\n+                (i128_type, u128_type)\n+            };\n \n         let tls_model = to_gcc_tls_mode(tcx.sess.tls_model());\n \n@@ -139,8 +148,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ulonglong_type = context.new_c_type(CType::ULongLong);\n         let sizet_type = context.new_c_type(CType::SizeT);\n \n-        assert_eq!(isize_type, i64_type);\n-        assert_eq!(usize_type, u64_type);\n+        let isize_type = context.new_c_type(CType::LongLong);\n+        let usize_type = context.new_c_type(CType::ULongLong);\n+        let bool_type = context.new_type::<bool>();\n+\n+        // TODO(antoyo): only have those assertions on x86_64.\n+        assert_eq!(isize_type.get_size(), i64_type.get_size());\n+        assert_eq!(usize_type.get_size(), u64_type.get_size());\n \n         let mut functions = FxHashMap::default();\n         let builtins = [\n@@ -190,6 +204,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             ulonglong_type,\n             sizet_type,\n \n+            supports_128bit_integers,\n+\n             float_type,\n             double_type,\n \n@@ -221,6 +237,41 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         function\n     }\n \n+    pub fn is_native_int_type(&self, typ: Type<'gcc>) -> bool {\n+        let types = [\n+            self.u8_type,\n+            self.u16_type,\n+            self.u32_type,\n+            self.u64_type,\n+            self.i8_type,\n+            self.i16_type,\n+            self.i32_type,\n+            self.i64_type,\n+        ];\n+\n+        for native_type in types {\n+            if native_type.is_compatible_with(typ) {\n+                return true;\n+            }\n+        }\n+\n+        self.supports_128bit_integers &&\n+            (self.u128_type.is_compatible_with(typ) || self.i128_type.is_compatible_with(typ))\n+    }\n+\n+    pub fn is_non_native_int_type(&self, typ: Type<'gcc>) -> bool {\n+        !self.supports_128bit_integers &&\n+            (self.u128_type.is_compatible_with(typ) || self.i128_type.is_compatible_with(typ))\n+    }\n+\n+    pub fn is_native_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n+        self.is_native_int_type(typ) || typ == self.bool_type\n+    }\n+\n+    pub fn is_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n+        self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ == self.bool_type\n+    }\n+\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }"}, {"sha": "a1f28f3f8812ac6b0b0ec26cf48b6c5d5c0feac6", "filename": "src/int.rs", "status": "added", "additions": 737, "deletions": 0, "changes": 737, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fint.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -0,0 +1,737 @@\n+//! Module to handle integer operations.\n+//! This module exists because some integer types are not supported on some gcc platforms, e.g.\n+//! 128-bit integers on 32-bit platforms and thus require to be handled manually.\n+\n+use std::convert::TryFrom;\n+\n+use gccjit::{ComparisonOp, FunctionType, RValue, ToRValue, Type, UnaryOp, BinaryOp};\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::traits::{BackendTypes, BaseTypeMethods, BuilderMethods, OverflowOp};\n+use rustc_middle::ty::Ty;\n+\n+use crate::builder::ToGccComp;\n+use crate::{builder::Builder, common::{SignType, TypeReflection}, context::CodegenCx};\n+\n+impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    pub fn gcc_urem(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // 128-bit unsigned %: __umodti3\n+        self.multiplicative_operation(BinaryOp::Modulo, \"mod\", false, a, b)\n+    }\n+\n+    pub fn gcc_srem(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // 128-bit signed %:   __modti3\n+        self.multiplicative_operation(BinaryOp::Modulo, \"mod\", true, a, b)\n+    }\n+\n+    pub fn gcc_not(&self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        let typ = a.get_type();\n+        if self.is_native_int_type_or_bool(typ) {\n+            let operation =\n+                if typ.is_bool() {\n+                    UnaryOp::LogicalNegate\n+                }\n+                else {\n+                    UnaryOp::BitwiseNegate\n+                };\n+            self.cx.context.new_unary_op(None, operation, typ, a)\n+        }\n+        else {\n+            // TODO(antoyo): use __negdi2 and __negti2 instead?\n+            let element_type = typ.dyncast_array().expect(\"element type\");\n+            let values = [\n+                self.cx.context.new_unary_op(None, UnaryOp::BitwiseNegate, element_type, self.low(a)),\n+                self.cx.context.new_unary_op(None, UnaryOp::BitwiseNegate, element_type, self.high(a)),\n+            ];\n+            self.cx.context.new_array_constructor(None, typ, &values)\n+        }\n+    }\n+\n+    pub fn gcc_neg(&self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        if self.is_native_int_type(a_type) {\n+            self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n+        }\n+        else {\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let func = self.context.new_function(None, FunctionType::Extern, a_type, &[param_a], \"__negti2\", false);\n+            self.context.new_call(None, func, &[a])\n+        }\n+    }\n+\n+    pub fn gcc_and(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.cx.bitwise_operation(BinaryOp::BitwiseAnd, a, b)\n+    }\n+\n+    pub fn gcc_lshr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        let a_native = self.is_native_int_type(a_type);\n+        let b_native = self.is_native_int_type(b_type);\n+        if a_native && b_native {\n+            // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n+            // TODO(antoyo): cast to unsigned to do a logical shift if that does not work.\n+            if a_type.is_unsigned(self) && b_type.is_signed(self) {\n+                let a = self.context.new_cast(None, a, b_type);\n+                let result = a >> b;\n+                self.context.new_cast(None, result, a_type)\n+            }\n+            else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n+                let b = self.context.new_cast(None, b, a_type);\n+                a >> b\n+            }\n+            else {\n+                a >> b\n+            }\n+        }\n+        else if a_native && !b_native {\n+            self.gcc_lshr(a, self.gcc_int_cast(b, a_type))\n+        }\n+        else {\n+            // NOTE: we cannot use the lshr builtin because it's calling hi() (to get the most\n+            // significant half of the number) which uses lshr.\n+\n+            let native_int_type = a_type.dyncast_array().expect(\"get element type\");\n+\n+            let func = self.current_func();\n+            let then_block = func.new_block(\"then\");\n+            let else_block = func.new_block(\"else\");\n+            let after_block = func.new_block(\"after\");\n+            let b0_block = func.new_block(\"b0\");\n+            let actual_else_block = func.new_block(\"actual_else\");\n+\n+            let result = func.new_local(None, a_type, \"shiftResult\");\n+\n+            let sixty_four = self.gcc_int(native_int_type, 64);\n+            let sixty_three = self.gcc_int(native_int_type, 63);\n+            let zero = self.gcc_zero(native_int_type);\n+            let b = self.gcc_int_cast(b, native_int_type);\n+            let condition = self.gcc_icmp(IntPredicate::IntNE, self.gcc_and(b, sixty_four), zero);\n+            self.llbb().end_with_conditional(None, condition, then_block, else_block);\n+\n+            // TODO(antoyo): take endianness into account.\n+            let shift_value = self.gcc_sub(b, sixty_four);\n+            let high = self.high(a);\n+            let sign =\n+                if a_type.is_signed(self) {\n+                    high >> sixty_three\n+                }\n+                else {\n+                    zero\n+                };\n+            let values = [\n+                high >> shift_value,\n+                sign,\n+            ];\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            then_block.add_assignment(None, result, array_value);\n+            then_block.end_with_jump(None, after_block);\n+\n+            let condition = self.gcc_icmp(IntPredicate::IntEQ, b, zero);\n+            else_block.end_with_conditional(None, condition, b0_block, actual_else_block);\n+\n+            b0_block.add_assignment(None, result, a);\n+            b0_block.end_with_jump(None, after_block);\n+\n+            let shift_value = self.gcc_sub(sixty_four, b);\n+            // NOTE: cast low to its unsigned type in order to perform a logical right shift.\n+            let unsigned_type = native_int_type.to_unsigned(&self.cx);\n+            let casted_low = self.context.new_cast(None, self.low(a), unsigned_type);\n+            let shifted_low = casted_low >> self.context.new_cast(None, b, unsigned_type);\n+            let shifted_low = self.context.new_cast(None, shifted_low, native_int_type);\n+            let values = [\n+                (high << shift_value) | shifted_low,\n+                high >> b,\n+            ];\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            actual_else_block.add_assignment(None, result, array_value);\n+            actual_else_block.end_with_jump(None, after_block);\n+\n+            // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n+            // state need to be updated.\n+            self.block = Some(after_block);\n+            *self.cx.current_block.borrow_mut() = Some(after_block);\n+\n+            result.to_rvalue()\n+        }\n+    }\n+\n+    fn additive_operation(&self, operation: BinaryOp, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n+            if a.get_type() != b.get_type() {\n+                b = self.context.new_cast(None, b, a.get_type());\n+            }\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else {\n+            let signed = a_type.is_compatible_with(self.i128_type);\n+            let func_name =\n+                match (operation, signed) {\n+                    (BinaryOp::Plus, true) => \"__rust_i128_add\",\n+                    (BinaryOp::Plus, false) => \"__rust_u128_add\",\n+                    (BinaryOp::Minus, true) => \"__rust_i128_sub\",\n+                    (BinaryOp::Minus, false) => \"__rust_u128_sub\",\n+                    _ => unreachable!(\"unexpected additive operation {:?}\", operation),\n+                };\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let param_b = self.context.new_parameter(None, b_type, \"b\");\n+            let func = self.context.new_function(None, FunctionType::Extern, a_type, &[param_a, param_b], func_name, false);\n+            self.context.new_call(None, func, &[a, b])\n+        }\n+    }\n+\n+    pub fn gcc_add(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.additive_operation(BinaryOp::Plus, a, b)\n+    }\n+\n+    pub fn gcc_mul(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.multiplicative_operation(BinaryOp::Mult, \"mul\", true, a, b)\n+    }\n+\n+    pub fn gcc_sub(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.additive_operation(BinaryOp::Minus, a, b)\n+    }\n+\n+    fn multiplicative_operation(&self, operation: BinaryOp, operation_name: &str, signed: bool, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else {\n+            let sign =\n+                if signed {\n+                    \"\"\n+                }\n+                else {\n+                    \"u\"\n+                };\n+            let func_name = format!(\"__{}{}ti3\", sign, operation_name);\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let param_b = self.context.new_parameter(None, b_type, \"b\");\n+            let func = self.context.new_function(None, FunctionType::Extern, a_type, &[param_a, param_b], func_name, false);\n+            self.context.new_call(None, func, &[a, b])\n+        }\n+    }\n+\n+    pub fn gcc_sdiv(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): check if the types are signed?\n+        // 128-bit, signed: __divti3\n+        // TODO(antoyo): convert the arguments to signed?\n+        self.multiplicative_operation(BinaryOp::Divide, \"div\", true, a, b)\n+    }\n+\n+    pub fn gcc_udiv(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // 128-bit, unsigned: __udivti3\n+        self.multiplicative_operation(BinaryOp::Divide, \"div\", false, a, b)\n+    }\n+\n+    pub fn gcc_checked_binop(&self, oop: OverflowOp, typ: Ty<'_>, lhs: <Self as BackendTypes>::Value, rhs: <Self as BackendTypes>::Value) -> (<Self as BackendTypes>::Value, <Self as BackendTypes>::Value) {\n+        use rustc_middle::ty::{Int, IntTy::*, Uint, UintTy::*};\n+\n+        let new_kind =\n+            match typ.kind() {\n+                Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n+                Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n+                t @ (Uint(_) | Int(_)) => t.clone(),\n+                _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n+            };\n+\n+        // TODO(antoyo): remove duplication with intrinsic?\n+        let name =\n+            if self.is_native_int_type(lhs.get_type()) {\n+                match oop {\n+                    OverflowOp::Add =>\n+                        match new_kind {\n+                            Int(I8) => \"__builtin_add_overflow\",\n+                            Int(I16) => \"__builtin_add_overflow\",\n+                            Int(I32) => \"__builtin_sadd_overflow\",\n+                            Int(I64) => \"__builtin_saddll_overflow\",\n+                            Int(I128) => \"__builtin_add_overflow\",\n+\n+                            Uint(U8) => \"__builtin_add_overflow\",\n+                            Uint(U16) => \"__builtin_add_overflow\",\n+                            Uint(U32) => \"__builtin_uadd_overflow\",\n+                            Uint(U64) => \"__builtin_uaddll_overflow\",\n+                            Uint(U128) => \"__builtin_add_overflow\",\n+\n+                            _ => unreachable!(),\n+                        },\n+                    OverflowOp::Sub =>\n+                        match new_kind {\n+                            Int(I8) => \"__builtin_sub_overflow\",\n+                            Int(I16) => \"__builtin_sub_overflow\",\n+                            Int(I32) => \"__builtin_ssub_overflow\",\n+                            Int(I64) => \"__builtin_ssubll_overflow\",\n+                            Int(I128) => \"__builtin_sub_overflow\",\n+\n+                            Uint(U8) => \"__builtin_sub_overflow\",\n+                            Uint(U16) => \"__builtin_sub_overflow\",\n+                            Uint(U32) => \"__builtin_usub_overflow\",\n+                            Uint(U64) => \"__builtin_usubll_overflow\",\n+                            Uint(U128) => \"__builtin_sub_overflow\",\n+\n+                            _ => unreachable!(),\n+                        },\n+                    OverflowOp::Mul =>\n+                        match new_kind {\n+                            Int(I8) => \"__builtin_mul_overflow\",\n+                            Int(I16) => \"__builtin_mul_overflow\",\n+                            Int(I32) => \"__builtin_smul_overflow\",\n+                            Int(I64) => \"__builtin_smulll_overflow\",\n+                            Int(I128) => \"__builtin_mul_overflow\",\n+\n+                            Uint(U8) => \"__builtin_mul_overflow\",\n+                            Uint(U16) => \"__builtin_mul_overflow\",\n+                            Uint(U32) => \"__builtin_umul_overflow\",\n+                            Uint(U64) => \"__builtin_umulll_overflow\",\n+                            Uint(U128) => \"__builtin_mul_overflow\",\n+\n+                            _ => unreachable!(),\n+                        },\n+                }\n+            }\n+            else {\n+                match new_kind {\n+                    Int(I128) | Uint(U128) => {\n+                        let func_name =\n+                            match oop {\n+                                OverflowOp::Add =>\n+                                    match new_kind {\n+                                        Int(I128) => \"__rust_i128_addo\",\n+                                        Uint(U128) => \"__rust_u128_addo\",\n+                                        _ => unreachable!(),\n+                                    },\n+                                OverflowOp::Sub =>\n+                                    match new_kind {\n+                                        Int(I128) => \"__rust_i128_subo\",\n+                                        Uint(U128) => \"__rust_u128_subo\",\n+                                        _ => unreachable!(),\n+                                    },\n+                                OverflowOp::Mul =>\n+                                    match new_kind {\n+                                        Int(I128) => \"__rust_i128_mulo\", // TODO(antoyo): use __muloti4d instead?\n+                                        Uint(U128) => \"__rust_u128_mulo\",\n+                                        _ => unreachable!(),\n+                                    },\n+                            };\n+                        let a_type = lhs.get_type();\n+                        let b_type = rhs.get_type();\n+                        let param_a = self.context.new_parameter(None, a_type, \"a\");\n+                        let param_b = self.context.new_parameter(None, b_type, \"b\");\n+                        let result_field = self.context.new_field(None, a_type, \"result\");\n+                        let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                        let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                        let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                        let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                        let overflow = result.access_field(None, overflow_field);\n+                        let int_result = result.access_field(None, result_field);\n+                        return (int_result, overflow);\n+                    },\n+                    _ => {\n+                        match oop {\n+                            OverflowOp::Mul =>\n+                                match new_kind {\n+                                    Int(I32) => \"__mulosi4\",\n+                                    Int(I64) => \"__mulodi4\",\n+                                    _ => unreachable!(),\n+                                },\n+                            _ => unimplemented!(\"overflow operation for {:?}\", new_kind),\n+                        }\n+                    }\n+                }\n+            };\n+\n+        let intrinsic = self.context.get_builtin_function(&name);\n+        let res = self.current_func()\n+            // TODO(antoyo): is it correct to use rhs type instead of the parameter typ?\n+            .new_local(None, rhs.get_type(), \"binopResult\")\n+            .get_address(None);\n+        let overflow = self.overflow_call(intrinsic, &[lhs, rhs, res], None);\n+        (res.dereference(None).to_rvalue(), overflow)\n+    }\n+\n+    pub fn gcc_icmp(&self, op: IntPredicate, mut lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = lhs.get_type();\n+        let b_type = rhs.get_type();\n+        if self.is_non_native_int_type(a_type) || self.is_non_native_int_type(b_type) {\n+            let signed = a_type.is_compatible_with(self.i128_type);\n+            let sign =\n+                if signed {\n+                    \"\"\n+                }\n+                else {\n+                    \"u\"\n+                };\n+            let func_name = format!(\"__{}cmpti2\", sign);\n+            let param_a = self.context.new_parameter(None, a_type, \"a\");\n+            let param_b = self.context.new_parameter(None, b_type, \"b\");\n+            let func = self.context.new_function(None, FunctionType::Extern, self.int_type, &[param_a, param_b], func_name, false);\n+            let cmp = self.context.new_call(None, func, &[lhs, rhs]);\n+            let (op, limit) =\n+                match op {\n+                    IntPredicate::IntEQ => {\n+                        return self.context.new_comparison(None, ComparisonOp::Equals, cmp, self.context.new_rvalue_one(self.int_type));\n+                    },\n+                    IntPredicate::IntNE => {\n+                        return self.context.new_comparison(None, ComparisonOp::NotEquals, cmp, self.context.new_rvalue_one(self.int_type));\n+                    },\n+                    IntPredicate::IntUGT => (ComparisonOp::Equals, 2),\n+                    IntPredicate::IntUGE => (ComparisonOp::GreaterThanEquals, 1),\n+                    IntPredicate::IntULT => (ComparisonOp::Equals, 0),\n+                    IntPredicate::IntULE => (ComparisonOp::LessThanEquals, 1),\n+                    IntPredicate::IntSGT => (ComparisonOp::Equals, 2),\n+                    IntPredicate::IntSGE => (ComparisonOp::GreaterThanEquals, 1),\n+                    IntPredicate::IntSLT => (ComparisonOp::Equals, 0),\n+                    IntPredicate::IntSLE => (ComparisonOp::LessThanEquals, 1),\n+                };\n+            self.context.new_comparison(None, op, cmp, self.context.new_rvalue_from_int(self.int_type, limit))\n+        }\n+        else {\n+            let left_type = lhs.get_type();\n+            let right_type = rhs.get_type();\n+            if left_type != right_type {\n+                // NOTE: because libgccjit cannot compare function pointers.\n+                if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n+                    lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n+                    rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n+                }\n+                // NOTE: hack because we try to cast a vector type to the same vector type.\n+                else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n+                    rhs = self.context.new_cast(None, rhs, left_type);\n+                }\n+            }\n+            self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+        }\n+    }\n+\n+    pub fn gcc_xor(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n+            a ^ b\n+        }\n+        else {\n+            let values = [\n+                self.low(a) ^ self.low(b),\n+                self.high(a) ^ self.high(b),\n+            ];\n+            self.context.new_array_constructor(None, a_type, &values)\n+        }\n+    }\n+\n+    pub fn gcc_shl(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        let a_native = self.is_native_int_type(a_type);\n+        let b_native = self.is_native_int_type(b_type);\n+        if a_native && b_native {\n+            // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n+            if a_type.is_unsigned(self) && b_type.is_signed(self) {\n+                let a = self.context.new_cast(None, a, b_type);\n+                let result = a << b;\n+                self.context.new_cast(None, result, a_type)\n+            }\n+            else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n+                let b = self.context.new_cast(None, b, a_type);\n+                a << b\n+            }\n+            else {\n+                a << b\n+            }\n+        }\n+        else if a_native && !b_native {\n+            self.gcc_shl(a, self.gcc_int_cast(b, a_type))\n+        }\n+        else {\n+            // NOTE: we cannot use the ashl builtin because it's calling widen_hi() which uses ashl.\n+            let native_int_type = a_type.dyncast_array().expect(\"get element type\");\n+\n+            let func = self.current_func();\n+            let then_block = func.new_block(\"then\");\n+            let else_block = func.new_block(\"else\");\n+            let after_block = func.new_block(\"after\");\n+            let b0_block = func.new_block(\"b0\");\n+            let actual_else_block = func.new_block(\"actual_else\");\n+\n+            let result = func.new_local(None, a_type, \"shiftResult\");\n+\n+            let b = self.gcc_int_cast(b, native_int_type);\n+            let sixty_four = self.gcc_int(native_int_type, 64);\n+            let zero = self.gcc_zero(native_int_type);\n+            let condition = self.gcc_icmp(IntPredicate::IntNE, self.gcc_and(b, sixty_four), zero);\n+            self.llbb().end_with_conditional(None, condition, then_block, else_block);\n+\n+            // TODO(antoyo): take endianness into account.\n+            let values = [\n+                zero,\n+                self.low(a) << (b - sixty_four),\n+            ];\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            then_block.add_assignment(None, result, array_value);\n+            then_block.end_with_jump(None, after_block);\n+\n+            let condition = self.gcc_icmp(IntPredicate::IntEQ, b, zero);\n+            else_block.end_with_conditional(None, condition, b0_block, actual_else_block);\n+\n+            b0_block.add_assignment(None, result, a);\n+            b0_block.end_with_jump(None, after_block);\n+\n+            // NOTE: cast low to its unsigned type in order to perform a logical right shift.\n+            let unsigned_type = native_int_type.to_unsigned(&self.cx);\n+            let casted_low = self.context.new_cast(None, self.low(a), unsigned_type);\n+            let shift_value = self.context.new_cast(None, sixty_four - b, unsigned_type);\n+            let high_low = self.context.new_cast(None, casted_low >> shift_value, native_int_type);\n+            let values = [\n+                self.low(a) << b,\n+                (self.high(a) << b) | high_low,\n+            ];\n+\n+            let array_value = self.context.new_array_constructor(None, a_type, &values);\n+            actual_else_block.add_assignment(None, result, array_value);\n+            actual_else_block.end_with_jump(None, after_block);\n+\n+            // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n+            // state need to be updated.\n+            self.block = Some(after_block);\n+            *self.cx.current_block.borrow_mut() = Some(after_block);\n+\n+            result.to_rvalue()\n+        }\n+    }\n+\n+    pub fn gcc_bswap(&mut self, mut arg: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n+        let arg_type = arg.get_type();\n+        if !self.is_native_int_type(arg_type) {\n+            let native_int_type = arg_type.dyncast_array().expect(\"get element type\");\n+            let lsb = self.context.new_array_access(None, arg, self.context.new_rvalue_from_int(self.int_type, 0)).to_rvalue();\n+            let swapped_lsb = self.gcc_bswap(lsb, width / 2);\n+            let swapped_lsb = self.context.new_cast(None, swapped_lsb, native_int_type);\n+            let msb = self.context.new_array_access(None, arg, self.context.new_rvalue_from_int(self.int_type, 1)).to_rvalue();\n+            let swapped_msb = self.gcc_bswap(msb, width / 2);\n+            let swapped_msb = self.context.new_cast(None, swapped_msb, native_int_type);\n+\n+            // NOTE: we also need to swap the two elements here, in addition to swapping inside\n+            // the elements themselves like done above.\n+            return self.context.new_array_constructor(None, arg_type, &[swapped_msb, swapped_lsb]);\n+        }\n+\n+        // TODO(antoyo): check if it's faster to use string literals and a\n+        // match instead of format!.\n+        let bswap = self.cx.context.get_builtin_function(&format!(\"__builtin_bswap{}\", width));\n+        // FIXME(antoyo): this cast should not be necessary. Remove\n+        // when having proper sized integer types.\n+        let param_type = bswap.get_param(0).to_rvalue().get_type();\n+        if param_type != arg_type {\n+            arg = self.bitcast(arg, param_type);\n+        }\n+        self.cx.context.new_call(None, bswap, &[arg])\n+    }\n+}\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn gcc_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n+        if self.is_native_int_type_or_bool(typ) {\n+            self.context.new_rvalue_from_long(typ, i64::try_from(int).expect(\"i64::try_from\"))\n+        }\n+        else {\n+            // NOTE: set the sign in high.\n+            self.from_low_high(typ, int, -(int.is_negative() as i64))\n+        }\n+    }\n+\n+    pub fn gcc_uint(&self, typ: Type<'gcc>, int: u64) -> RValue<'gcc> {\n+        if self.is_native_int_type_or_bool(typ) {\n+            self.context.new_rvalue_from_long(typ, u64::try_from(int).expect(\"u64::try_from\") as i64)\n+        }\n+        else {\n+            self.from_low_high(typ, int as i64, 0)\n+        }\n+    }\n+\n+    pub fn gcc_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n+        let low = num as u64;\n+        let high = (num >> 64) as u64;\n+        if num >> 64 != 0 {\n+            // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n+            if self.is_native_int_type(typ) {\n+                let low = self.context.new_rvalue_from_long(self.u64_type, low as i64);\n+                let high = self.context.new_rvalue_from_long(typ, high as i64);\n+\n+                let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n+                let shift = high << sixty_four;\n+                shift | self.context.new_cast(None, low, typ)\n+            }\n+            else {\n+                self.from_low_high(typ, low as i64, high as i64)\n+            }\n+        }\n+        else if typ.is_i128(self) {\n+            let num = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n+            self.gcc_int_cast(num, typ)\n+        }\n+        else {\n+            self.gcc_uint(typ, num as u64)\n+        }\n+    }\n+\n+    pub fn gcc_zero(&self, typ: Type<'gcc>) -> RValue<'gcc> {\n+        if self.is_native_int_type_or_bool(typ) {\n+            self.context.new_rvalue_zero(typ)\n+        }\n+        else {\n+            self.from_low_high(typ, 0, 0)\n+        }\n+    }\n+\n+    pub fn gcc_int_width(&self, typ: Type<'gcc>) -> u64 {\n+        if self.is_native_int_type_or_bool(typ) {\n+            typ.get_size() as u64 * 8\n+        }\n+        else {\n+            // NOTE: the only unsupported types are u128 and i128.\n+            128\n+        }\n+    }\n+\n+    fn bitwise_operation(&self, operation: BinaryOp, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        let a_native = self.is_native_int_type_or_bool(a_type);\n+        let b_native = self.is_native_int_type_or_bool(b_type);\n+        if a_native && b_native {\n+            if a_type != b_type {\n+                b = self.context.new_cast(None, b, a_type);\n+            }\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else {\n+            assert!(!a_native && !b_native, \"both types should either be native or non-native for or operation\");\n+            let native_int_type = a_type.dyncast_array().expect(\"get element type\");\n+            let values = [\n+                self.context.new_binary_op(None, operation, native_int_type, self.low(a), self.low(b)),\n+                self.context.new_binary_op(None, operation, native_int_type, self.high(a), self.high(b)),\n+            ];\n+            self.context.new_array_constructor(None, a_type, &values)\n+        }\n+    }\n+\n+    pub fn gcc_or(&self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.bitwise_operation(BinaryOp::BitwiseOr, a, b)\n+    }\n+\n+    // TODO(antoyo): can we use https://github.com/rust-lang/compiler-builtins/blob/master/src/int/mod.rs#L379 instead?\n+    pub fn gcc_int_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        let value_type = value.get_type();\n+        if self.is_native_int_type_or_bool(dest_typ) && self.is_native_int_type_or_bool(value_type) {\n+            self.context.new_cast(None, value, dest_typ)\n+        }\n+        else if self.is_native_int_type_or_bool(dest_typ) {\n+            self.context.new_cast(None, self.low(value), dest_typ)\n+        }\n+        else if self.is_native_int_type_or_bool(value_type) {\n+            let dest_element_type = dest_typ.dyncast_array().expect(\"get element type\");\n+\n+            // NOTE: set the sign of the value.\n+            let zero = self.context.new_rvalue_zero(value_type);\n+            let is_negative = self.context.new_comparison(None, ComparisonOp::LessThan, value, zero);\n+            let is_negative = self.gcc_int_cast(is_negative, dest_element_type);\n+            let values = [\n+                self.context.new_cast(None, value, dest_element_type),\n+                self.context.new_unary_op(None, UnaryOp::Minus, dest_element_type, is_negative),\n+            ];\n+            self.context.new_array_constructor(None, dest_typ, &values)\n+        }\n+        else {\n+            // Since u128 and i128 are the only types that can be unsupported, we know the type of\n+            // value and the destination type have the same size, so a bitcast is fine.\n+            self.context.new_bitcast(None, value, dest_typ)\n+        }\n+    }\n+\n+    fn int_to_float_cast(&self, signed: bool, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        let value_type = value.get_type();\n+        if self.is_native_int_type_or_bool(value_type) {\n+            return self.context.new_cast(None, value, dest_typ);\n+        }\n+\n+        let name_suffix =\n+            match self.type_kind(dest_typ) {\n+                TypeKind::Float => \"tisf\",\n+                TypeKind::Double => \"tidf\",\n+                kind => panic!(\"cannot cast a non-native integer to type {:?}\", kind),\n+            };\n+        let sign =\n+            if signed {\n+                \"\"\n+            }\n+            else {\n+                \"un\"\n+            };\n+        let func_name = format!(\"__float{}{}\", sign, name_suffix);\n+        let param = self.context.new_parameter(None, value_type, \"n\");\n+        let func = self.context.new_function(None, FunctionType::Extern, dest_typ, &[param], func_name, false);\n+        self.context.new_call(None, func, &[value])\n+    }\n+\n+    pub fn gcc_int_to_float_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.int_to_float_cast(true, value, dest_typ)\n+    }\n+\n+    pub fn gcc_uint_to_float_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.int_to_float_cast(false, value, dest_typ)\n+    }\n+\n+    fn float_to_int_cast(&self, signed: bool, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        let value_type = value.get_type();\n+        if self.is_native_int_type_or_bool(dest_typ) {\n+            return self.context.new_cast(None, value, dest_typ);\n+        }\n+\n+        let name_suffix =\n+            match self.type_kind(value_type) {\n+                TypeKind::Float => \"sfti\",\n+                TypeKind::Double => \"dfti\",\n+                kind => panic!(\"cannot cast a {:?} to non-native integer\", kind),\n+            };\n+        let sign =\n+            if signed {\n+                \"\"\n+            }\n+            else {\n+                \"uns\"\n+            };\n+        let func_name = format!(\"__fix{}{}\", sign, name_suffix);\n+        let param = self.context.new_parameter(None, value_type, \"n\");\n+        let func = self.context.new_function(None, FunctionType::Extern, dest_typ, &[param], func_name, false);\n+        self.context.new_call(None, func, &[value])\n+    }\n+\n+    pub fn gcc_float_to_int_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.float_to_int_cast(true, value, dest_typ)\n+    }\n+\n+    pub fn gcc_float_to_uint_cast(&self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        self.float_to_int_cast(false, value, dest_typ)\n+    }\n+\n+    fn high(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_array_access(None, value, self.context.new_rvalue_from_int(self.int_type, 1))\n+            .to_rvalue()\n+    }\n+\n+    fn low(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_array_access(None, value, self.context.new_rvalue_from_int(self.int_type, 0))\n+            .to_rvalue()\n+    }\n+\n+    fn from_low_high(&self, typ: Type<'gcc>, low: i64, high: i64) -> RValue<'gcc> {\n+        let native_int_type = typ.dyncast_array().expect(\"get element type\");\n+        let values = [\n+            self.context.new_rvalue_from_long(native_int_type, low),\n+            self.context.new_rvalue_from_long(native_int_type, high),\n+        ];\n+        self.context.new_array_constructor(None, typ, &values)\n+    }\n+}"}, {"sha": "7cd0f944f2f975c502bbd171a5b6706a5cab7af8", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 111, "deletions": 83, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -1,7 +1,7 @@\n pub mod llvm;\n mod simd;\n \n-use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp};\n+use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n@@ -175,11 +175,11 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                                     let arg = args[0].immediate();\n                                     let result = func.new_local(None, arg.get_type(), \"zeros\");\n-                                    let zero = self.cx.context.new_rvalue_zero(arg.get_type());\n-                                    let cond = self.cx.context.new_comparison(None, ComparisonOp::Equals, arg, zero);\n+                                    let zero = self.cx.gcc_zero(arg.get_type());\n+                                    let cond = self.gcc_icmp(IntPredicate::IntEQ, arg, zero);\n                                     self.llbb().end_with_conditional(None, cond, then_block, else_block);\n \n-                                    let zero_result = self.cx.context.new_rvalue_from_long(arg.get_type(), width as i64);\n+                                    let zero_result = self.cx.gcc_uint(arg.get_type(), width);\n                                     then_block.add_assignment(None, result, zero_result);\n                                     then_block.end_with_jump(None, after_block);\n \n@@ -195,8 +195,8 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                             sym::cttz => self.count_trailing_zeroes(width, arg),\n                                             _ => unreachable!(),\n                                         };\n-                                    else_block.add_assignment(None, result, zeros);\n-                                    else_block.end_with_jump(None, after_block);\n+                                    self.llbb().add_assignment(None, result, zeros);\n+                                    self.llbb().end_with_jump(None, after_block);\n \n                                     // NOTE: since jumps were added in a place rustc does not\n                                     // expect, the current blocks in the state need to be updated.\n@@ -217,17 +217,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                         args[0].immediate() // byte swap a u8/i8 is just a no-op\n                                     }\n                                     else {\n-                                        // TODO(antoyo): check if it's faster to use string literals and a\n-                                        // match instead of format!.\n-                                        let bswap = self.cx.context.get_builtin_function(&format!(\"__builtin_bswap{}\", width));\n-                                        let mut arg = args[0].immediate();\n-                                        // FIXME(antoyo): this cast should not be necessary. Remove\n-                                        // when having proper sized integer types.\n-                                        let param_type = bswap.get_param(0).to_rvalue().get_type();\n-                                        if param_type != arg.get_type() {\n-                                            arg = self.bitcast(arg, param_type);\n-                                        }\n-                                        self.cx.context.new_call(None, bswap, &[arg])\n+                                        self.gcc_bswap(args[0].immediate(), width)\n                                     }\n                                 },\n                                 sym::bitreverse => self.bit_reverse(width, args[0].immediate()),\n@@ -526,7 +516,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_cast(None, value, typ)\n+                self.gcc_int_cast(value, typ)\n             }\n             else {\n                 value\n@@ -673,30 +663,33 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 },\n                 128 => {\n                     // TODO(antoyo): find a more efficient implementation?\n-                    let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n-                    let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n-                    let low = self.context.new_cast(None, value, self.u64_type);\n+                    let sixty_four = self.gcc_int(typ, 64);\n+                    let right_shift = self.gcc_lshr(value, sixty_four);\n+                    let high = self.gcc_int_cast(right_shift, self.u64_type);\n+                    let low = self.gcc_int_cast(value, self.u64_type);\n \n                     let reversed_high = self.bit_reverse(64, high);\n                     let reversed_low = self.bit_reverse(64, low);\n \n-                    let new_low = self.context.new_cast(None, reversed_high, typ);\n-                    let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n+                    let new_low = self.gcc_int_cast(reversed_high, typ);\n+                    let new_high = self.shl(self.gcc_int_cast(reversed_low, typ), sixty_four);\n \n-                    new_low | new_high\n+                    self.gcc_or(new_low, new_high)\n                 },\n                 _ => {\n                     panic!(\"cannot bit reverse with width = {}\", width);\n                 },\n             };\n \n-        self.context.new_cast(None, result, result_type)\n+        self.gcc_int_cast(result, result_type)\n     }\n \n-    fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+    fn count_leading_zeroes(&mut self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): use width?\n         let arg_type = arg.get_type();\n         let count_leading_zeroes =\n+            // TODO(antoyo): write a new function Type::is_compatible_with(&Type) and use it here\n+            // instead of using is_uint().\n             if arg_type.is_uint(&self.cx) {\n                 \"__builtin_clz\"\n             }\n@@ -712,9 +705,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let result = self.current_func()\n                     .new_local(None, array_type, \"count_loading_zeroes_results\");\n \n-                let sixty_four = self.context.new_rvalue_from_long(arg_type, 64);\n-                let high = self.context.new_cast(None, arg >> sixty_four, self.u64_type);\n-                let low = self.context.new_cast(None, arg, self.u64_type);\n+                let sixty_four = self.const_uint(arg_type, 64);\n+                let shift = self.lshr(arg, sixty_four);\n+                let high = self.gcc_int_cast(shift, self.u64_type);\n+                let low = self.gcc_int_cast(arg, self.u64_type);\n \n                 let zero = self.context.new_rvalue_zero(self.usize_type);\n                 let one = self.context.new_rvalue_one(self.usize_type);\n@@ -723,17 +717,18 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let clzll = self.context.get_builtin_function(\"__builtin_clzll\");\n \n                 let first_elem = self.context.new_array_access(None, result, zero);\n-                let first_value = self.context.new_cast(None, self.context.new_call(None, clzll, &[high]), arg_type);\n+                let first_value = self.gcc_int_cast(self.context.new_call(None, clzll, &[high]), arg_type);\n                 self.llbb()\n                     .add_assignment(None, first_elem, first_value);\n \n                 let second_elem = self.context.new_array_access(None, result, one);\n-                let second_value = self.context.new_cast(None, self.context.new_call(None, clzll, &[low]), arg_type) + sixty_four;\n+                let cast = self.gcc_int_cast(self.context.new_call(None, clzll, &[low]), arg_type);\n+                let second_value = self.add(cast, sixty_four);\n                 self.llbb()\n                     .add_assignment(None, second_elem, second_value);\n \n                 let third_elem = self.context.new_array_access(None, result, two);\n-                let third_value = self.context.new_rvalue_from_long(arg_type, 128);\n+                let third_value = self.const_uint(arg_type, 128);\n                 self.llbb()\n                     .add_assignment(None, third_elem, third_value);\n \n@@ -749,13 +744,13 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_cast(None, res, arg_type);\n+                return self.gcc_int_cast(res.to_rvalue(), arg_type);\n             }\n             else {\n-                let count_leading_zeroes = self.context.get_builtin_function(\"__builtin_clz\");\n-                let arg = self.context.new_cast(None, arg, self.uint_type);\n-                let diff = self.int_width(self.uint_type) - self.int_width(arg_type);\n-                let diff = self.context.new_rvalue_from_long(self.int_type, diff);\n+                let count_leading_zeroes = self.context.get_builtin_function(\"__builtin_clzll\");\n+                let arg = self.context.new_cast(None, arg, self.ulonglong_type);\n+                let diff = self.ulonglong_type.get_size() as i64 - arg_type.get_size() as i64;\n+                let diff = self.context.new_rvalue_from_long(self.int_type, diff * 8);\n                 let res = self.context.new_call(None, count_leading_zeroes, &[arg]) - diff;\n                 return self.context.new_cast(None, res, arg_type);\n             };\n@@ -764,18 +759,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         self.context.new_cast(None, res, arg_type)\n     }\n \n-    fn count_trailing_zeroes(&self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+    fn count_trailing_zeroes(&mut self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n         let result_type = arg.get_type();\n         let arg =\n             if result_type.is_signed(self.cx) {\n                 let new_type = result_type.to_unsigned(self.cx);\n-                self.context.new_cast(None, arg, new_type)\n+                self.gcc_int_cast(arg, new_type)\n             }\n             else {\n                 arg\n             };\n         let arg_type = arg.get_type();\n         let (count_trailing_zeroes, expected_type) =\n+            // TODO(antoyo): write a new function Type::is_compatible_with(&Type) and use it here\n+            // instead of using is_uint().\n             if arg_type.is_uchar(&self.cx) || arg_type.is_ushort(&self.cx) || arg_type.is_uint(&self.cx) {\n                 // NOTE: we don't need to & 0xFF for uchar because the result is undefined on zero.\n                 (\"__builtin_ctz\", self.cx.uint_type)\n@@ -792,9 +789,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let result = self.current_func()\n                     .new_local(None, array_type, \"count_loading_zeroes_results\");\n \n-                let sixty_four = self.context.new_rvalue_from_long(arg_type, 64);\n-                let high = self.context.new_cast(None, arg >> sixty_four, self.u64_type);\n-                let low = self.context.new_cast(None, arg, self.u64_type);\n+                let sixty_four = self.gcc_int(arg_type, 64);\n+                let shift = self.gcc_lshr(arg, sixty_four);\n+                let high = self.gcc_int_cast(shift, self.u64_type);\n+                let low = self.gcc_int_cast(arg, self.u64_type);\n \n                 let zero = self.context.new_rvalue_zero(self.usize_type);\n                 let one = self.context.new_rvalue_one(self.usize_type);\n@@ -803,17 +801,17 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let ctzll = self.context.get_builtin_function(\"__builtin_ctzll\");\n \n                 let first_elem = self.context.new_array_access(None, result, zero);\n-                let first_value = self.context.new_cast(None, self.context.new_call(None, ctzll, &[low]), arg_type);\n+                let first_value = self.gcc_int_cast(self.context.new_call(None, ctzll, &[low]), arg_type);\n                 self.llbb()\n                     .add_assignment(None, first_elem, first_value);\n \n                 let second_elem = self.context.new_array_access(None, result, one);\n-                let second_value = self.context.new_cast(None, self.context.new_call(None, ctzll, &[high]), arg_type) + sixty_four;\n+                let second_value = self.gcc_add(self.gcc_int_cast(self.context.new_call(None, ctzll, &[high]), arg_type), sixty_four);\n                 self.llbb()\n                     .add_assignment(None, second_elem, second_value);\n \n                 let third_elem = self.context.new_array_access(None, result, two);\n-                let third_value = self.context.new_rvalue_from_long(arg_type, 128);\n+                let third_value = self.gcc_int(arg_type, 128);\n                 self.llbb()\n                     .add_assignment(None, third_elem, third_value);\n \n@@ -829,10 +827,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_cast(None, res, result_type);\n+                return self.gcc_int_cast(res.to_rvalue(), result_type);\n             }\n             else {\n-                unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n+                let count_trailing_zeroes = self.context.get_builtin_function(\"__builtin_ctzll\");\n+                let arg_size = arg_type.get_size();\n+                let casted_arg = self.context.new_cast(None, arg, self.ulonglong_type);\n+                let byte_diff = self.ulonglong_type.get_size() as i64 - arg_size as i64;\n+                let diff = self.context.new_rvalue_from_long(self.int_type, byte_diff * 8);\n+                let mask = self.context.new_rvalue_from_long(arg_type, -1); // To get the value with all bits set.\n+                let masked = mask & self.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, arg);\n+                let cond = self.context.new_comparison(None, ComparisonOp::Equals, masked, mask);\n+                let diff = diff * self.context.new_cast(None, cond, self.int_type);\n+                let res = self.context.new_call(None, count_trailing_zeroes, &[casted_arg]) - diff;\n+                return self.context.new_cast(None, res, result_type);\n             };\n         let count_trailing_zeroes = self.context.get_builtin_function(count_trailing_zeroes);\n         let arg =\n@@ -846,18 +854,14 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         self.context.new_cast(None, res, result_type)\n     }\n \n-    fn int_width(&self, typ: Type<'gcc>) -> i64 {\n-        self.cx.int_width(typ) as i64\n-    }\n-\n-    fn pop_count(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+    fn pop_count(&mut self, value: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): use the optimized version with fewer operations.\n         let result_type = value.get_type();\n         let value_type = result_type.to_unsigned(self.cx);\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_cast(None, value, value_type)\n+                self.gcc_int_cast(value, value_type)\n             }\n             else {\n                 value\n@@ -867,13 +871,14 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             // TODO(antoyo): implement in the normal algorithm below to have a more efficient\n             // implementation (that does not require a call to __popcountdi2).\n             let popcount = self.context.get_builtin_function(\"__builtin_popcountll\");\n-            let sixty_four = self.context.new_rvalue_from_long(value_type, 64);\n-            let high = self.context.new_cast(None, value >> sixty_four, self.cx.ulonglong_type);\n+            let sixty_four = self.gcc_int(value_type, 64);\n+            let right_shift = self.gcc_lshr(value, sixty_four);\n+            let high = self.gcc_int_cast(right_shift, self.cx.ulonglong_type);\n             let high = self.context.new_call(None, popcount, &[high]);\n-            let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n+            let low = self.gcc_int_cast(value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n             let res = high + low;\n-            return self.context.new_cast(None, res, result_type);\n+            return self.gcc_int_cast(res, result_type);\n         }\n \n         // First step.\n@@ -935,27 +940,29 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     // Algorithm from: https://blog.regehr.org/archives/1063\n     fn rotate_left(&mut self, value: RValue<'gcc>, shift: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n-        let max = self.context.new_rvalue_from_long(shift.get_type(), width as i64);\n-        let shift = shift % max;\n+        let max = self.const_uint(shift.get_type(), width);\n+        let shift = self.urem(shift, max);\n         let lhs = self.shl(value, shift);\n+        let result_neg = self.neg(shift);\n         let result_and =\n             self.and(\n-                self.context.new_unary_op(None, UnaryOp::Minus, shift.get_type(), shift),\n-                self.context.new_rvalue_from_long(shift.get_type(), width as i64 - 1),\n+                result_neg,\n+                self.const_uint(shift.get_type(), width - 1),\n             );\n         let rhs = self.lshr(value, result_and);\n         self.or(lhs, rhs)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063\n     fn rotate_right(&mut self, value: RValue<'gcc>, shift: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n-        let max = self.context.new_rvalue_from_long(shift.get_type(), width as i64);\n-        let shift = shift % max;\n+        let max = self.const_uint(shift.get_type(), width);\n+        let shift = self.urem(shift, max);\n         let lhs = self.lshr(value, shift);\n+        let result_neg = self.neg(shift);\n         let result_and =\n             self.and(\n-                self.context.new_unary_op(None, UnaryOp::Minus, shift.get_type(), shift),\n-                self.context.new_rvalue_from_long(shift.get_type(), width as i64 - 1),\n+                result_neg,\n+                self.const_uint(shift.get_type(), width - 1),\n             );\n         let rhs = self.shl(value, result_and);\n         self.or(lhs, rhs)\n@@ -1015,31 +1022,52 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn saturating_sub(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n         if signed {\n             // Also based on algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let func_name =\n-                match width {\n-                    8 => \"__builtin_sub_overflow\",\n-                    16 => \"__builtin_sub_overflow\",\n-                    32 => \"__builtin_ssub_overflow\",\n-                    64 => \"__builtin_ssubll_overflow\",\n-                    128 => \"__builtin_sub_overflow\",\n-                    _ => unreachable!(),\n-                };\n-            let overflow_func = self.context.get_builtin_function(func_name);\n             let result_type = lhs.get_type();\n             let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_diff\");\n-            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+            let supports_native_type = self.is_native_int_type(result_type);\n+            let overflow =\n+                if supports_native_type {\n+                    let func_name =\n+                        match width {\n+                            8 => \"__builtin_sub_overflow\",\n+                            16 => \"__builtin_sub_overflow\",\n+                            32 => \"__builtin_ssub_overflow\",\n+                            64 => \"__builtin_ssubll_overflow\",\n+                            128 => \"__builtin_sub_overflow\",\n+                            _ => unreachable!(),\n+                        };\n+                    let overflow_func = self.context.get_builtin_function(func_name);\n+                    self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None)\n+                }\n+                else {\n+                    let func_name =\n+                        match width {\n+                            128 => \"__rust_i128_subo\",\n+                            _ => unreachable!(),\n+                        };\n+                    let param_a = self.context.new_parameter(None, result_type, \"a\");\n+                    let param_b = self.context.new_parameter(None, result_type, \"b\");\n+                    let result_field = self.context.new_field(None, result_type, \"result\");\n+                    let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                    let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                    let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                    let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                    let overflow = result.access_field(None, overflow_field);\n+                    let int_result = result.access_field(None, result_field);\n+                    self.llbb().add_assignment(None, res, int_result);\n+                    overflow\n+                };\n \n             let then_block = func.new_block(\"then\");\n             let after_block = func.new_block(\"after\");\n \n-            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n-            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n-            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n-                self.context.new_rvalue_from_int(unsigned_type, 0)\n-            );\n-            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n-            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            // NOTE: convert the type to unsigned to have an unsigned shift.\n+            let unsigned_type = result_type.to_unsigned(&self.cx);\n+            let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n+            let uint_max = self.gcc_not(self.gcc_int(unsigned_type, 0));\n+            let int_max = self.gcc_lshr(uint_max, self.gcc_int(unsigned_type, 1));\n+            then_block.add_assignment(None, res, self.gcc_int_cast(self.gcc_add(shifted, int_max), result_type));\n             then_block.end_with_jump(None, after_block);\n \n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);"}, {"sha": "ca283e1380c4bdd656ddb7ce87f29a8bf1546f50", "filename": "src/lib.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -1,4 +1,5 @@\n /*\n+ * TODO(antoyo): implement equality in libgccjit based on https://zpz.github.io/blog/overloading-equality-operator-in-cpp-class-hierarchy/ (for type equality?)\n  * TODO(antoyo): support #[inline] attributes.\n  * TODO(antoyo): support LTO (gcc's equivalent to Thin LTO is enabled by -fwhopr: https://stackoverflow.com/questions/64954525/does-gcc-have-thin-lto).\n  *\n@@ -21,6 +22,7 @@ extern crate rustc_middle;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n+extern crate tempfile;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n #[allow(unused_extern_crates)]\n@@ -40,15 +42,16 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod int;\n mod intrinsic;\n mod mono_item;\n mod type_;\n mod type_of;\n \n use std::any::Any;\n-use std::sync::Arc;\n+use std::sync::{Arc, Mutex};\n \n-use gccjit::{Context, OptimizationLevel};\n+use gccjit::{Context, OptimizationLevel, CType};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n use rustc_codegen_ssa::base::codegen_crate;\n@@ -65,6 +68,7 @@ use rustc_session::config::{Lto, OptLevel, OutputFilenames};\n use rustc_session::Session;\n use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n+use tempfile::TempDir;\n \n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n@@ -77,13 +81,24 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n }\n \n #[derive(Clone)]\n-pub struct GccCodegenBackend;\n+pub struct GccCodegenBackend {\n+    supports_128bit_integers: Arc<Mutex<bool>>,\n+}\n \n impl CodegenBackend for GccCodegenBackend {\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n             sess.warn(\"LTO is not supported. You may get a linker error.\");\n         }\n+\n+        let temp_dir = TempDir::new().expect(\"cannot create temporary directory\");\n+        let temp_file = temp_dir.into_path().join(\"result.asm\");\n+        let check_context = Context::default();\n+        check_context.set_print_errors_to_stderr(false);\n+        let _int128_ty = check_context.new_c_type(CType::UInt128t);\n+        // NOTE: we cannot just call compile() as this would require other files than libgccjit.so.\n+        check_context.compile_to_file(gccjit::OutputKind::Assembler, temp_file.to_str().expect(\"path to str\"));\n+        *self.supports_128bit_integers.lock().expect(\"lock\") = check_context.get_last_error() == Ok(None);\n     }\n \n     fn codegen_crate<'tcx>(&self, tcx: TyCtxt<'tcx>, metadata: EncodedMetadata, need_metadata_module: bool) -> Box<dyn Any> {\n@@ -129,7 +144,7 @@ impl ExtraBackendMethods for GccCodegenBackend {\n     }\n \n     fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n-        base::compile_codegen_unit(tcx, cgu_name)\n+        base::compile_codegen_unit(tcx, cgu_name, *self.supports_128bit_integers.lock().expect(\"lock\"))\n     }\n \n     fn target_machine_factory(&self, _sess: &Session, _opt_level: OptLevel) -> TargetMachineFactoryFn<Self> {\n@@ -237,7 +252,9 @@ impl WriteBackendMethods for GccCodegenBackend {\n /// This is the entrypoint for a hot plugged rustc_codegen_gccjit\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(GccCodegenBackend)\n+    Box::new(GccCodegenBackend {\n+        supports_128bit_integers: Arc::new(Mutex::new(false)),\n+    })\n }\n \n fn to_gcc_opt_level(optlevel: Option<OptLevel>) -> OptimizationLevel {"}, {"sha": "3c96cd6afc256c29e1ad3f7cd3c727227a143f0a", "filename": "src/type_.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n-use crate::common::TypeReflection;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n@@ -119,9 +118,15 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn type_kind(&self, typ: Type<'gcc>) -> TypeKind {\n-        if typ.is_integral() {\n+        if self.is_int_type_or_bool(typ) {\n             TypeKind::Integer\n         }\n+        else if typ == self.float_type {\n+            TypeKind::Float\n+        }\n+        else if typ == self.double_type {\n+            TypeKind::Double\n+        }\n         else if typ.dyncast_vector().is_some() {\n             TypeKind::Vector\n         }\n@@ -175,24 +180,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> u64 {\n-        if typ.is_i8(self) || typ.is_u8(self) {\n-            8\n-        }\n-        else if typ.is_i16(self) || typ.is_u16(self) {\n-            16\n-        }\n-        else if typ.is_i32(self) || typ.is_u32(self) {\n-            32\n-        }\n-        else if typ.is_i64(self) || typ.is_u64(self) {\n-            64\n-        }\n-        else if typ.is_i128(self) || typ.is_u128(self) {\n-            128\n-        }\n-        else {\n-            panic!(\"Cannot get width of int type {:?}\", typ);\n-        }\n+        self.gcc_int_width(typ)\n     }\n \n     fn val_ty(&self, value: RValue<'gcc>) -> Type<'gcc> {"}, {"sha": "4f05013440b437564ed1e83845f0ee97a310bedc", "filename": "test.sh", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -4,7 +4,7 @@\n \n set -e\n \n-if [ -f ./gcc_path ]; then \n+if [ -f ./gcc_path ]; then\n     export GCC_PATH=$(cat gcc_path)\n else\n     echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n@@ -14,14 +14,26 @@ fi\n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n \n+features=\n+\n+if [[ \"$1\" == \"--features\" ]]; then\n+    shift\n+    features=\"--features $1\"\n+    shift\n+fi\n+\n if [[ \"$1\" == \"--release\" ]]; then\n     export CHANNEL='release'\n-    CARGO_INCREMENTAL=1 cargo rustc --release\n+    CARGO_INCREMENTAL=1 cargo rustc --release $features\n     shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n-    cargo rustc\n+    cargo rustc $features\n+fi\n+\n+if [[ \"$1\" == \"--build\" ]]; then\n+    exit\n fi\n \n source config.sh\n@@ -206,6 +218,14 @@ case $1 in\n         clean_ui_tests\n         ;;\n \n+    \"--std-tests\")\n+        std_tests\n+        ;;\n+\n+    \"--build-sysroot\")\n+        build_sysroot\n+        ;;\n+\n     *)\n         clean\n         mini_tests"}, {"sha": "7a62fc7d1f7811f94167479f419ced926192b55f", "filename": "tests/run/int.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/tests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818/tests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fint.rs?ref=41f20fa3a5c0cce3c9e56a1d05ed1c22ccfa8818", "patch": "@@ -0,0 +1,151 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+\n+#![feature(arbitrary_self_types, auto_traits, core_intrinsics, lang_items, start, intrinsics)]\n+\n+#![no_std]\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+/*\n+ * Core\n+ */\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+    }\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    unsafe {\n+        core::intrinsics::abort();\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    let var = 134217856_u128;\n+    let var2 = 10475372733397991552_u128;\n+    let var3 = 193236519889708027473620326106273939584_u128;\n+    let var4 = 123236519889708027473620326106273939584_u128;\n+    let var5 = 153236519889708027473620326106273939584_u128;\n+    let var6 = 18446744073709551616_i128;\n+    let var7 = 170141183460469231731687303715884105728_u128;\n+\n+    // Shifts.\n+    assert_eq!(var << (argc as u128 - 1), var);\n+    assert_eq!(var << argc as u128, 268435712);\n+    assert_eq!(var << (argc + 32) as u128, 1152922604118474752);\n+    assert_eq!(var << (argc + 48) as u128, 75557935783508361347072);\n+    assert_eq!(var << (argc + 60) as u128, 309485304969250248077606912);\n+    assert_eq!(var << (argc + 62) as u128, 1237941219877000992310427648);\n+    assert_eq!(var << (argc + 63) as u128, 2475882439754001984620855296);\n+    assert_eq!(var << (argc + 80) as u128, 324518863143436548128224745357312);\n+\n+    assert_eq!(var2 << argc as u128, 20950745466795983104);\n+    assert_eq!(var2 << (argc as u128 - 1), var2);\n+    assert_eq!(var2 << (argc + 32) as u128, 89982766606709001335848566784);\n+    assert_eq!(var2 << (argc + 48) as u128, 5897110592337281111546171672756224);\n+    assert_eq!(var2 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n+    assert_eq!(var2 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n+    assert_eq!(var2 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n+\n+    assert_eq!(var3 << argc as u128, 46190672858477591483866044780779667712);\n+    assert_eq!(var3 << (argc as u128 - 1), var3);\n+    assert_eq!(var3 << (argc + 32) as u128, 21267668304951024224840338247585366016);\n+    assert_eq!(var3 << (argc + 48) as u128, 1335125106377253154015353231953100800);\n+    assert_eq!(var3 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n+    assert_eq!(var3 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n+    assert_eq!(var3 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n+\n+    assert_eq!(var >> (argc as u128 - 1), var);\n+    assert_eq!(var >> argc as u128, 67108928);\n+    assert_eq!(var >> (argc + 32) as u128, 0);\n+    assert_eq!(var >> (argc + 48) as u128, 0);\n+    assert_eq!(var >> (argc + 60) as u128, 0);\n+    assert_eq!(var >> (argc + 62) as u128, 0);\n+    assert_eq!(var >> (argc + 63) as u128, 0);\n+\n+    assert_eq!(var2 >> argc as u128, 5237686366698995776);\n+    assert_eq!(var2 >> (argc as u128 - 1), var2);\n+    assert_eq!(var2 >> (argc + 32) as u128, 1219493888);\n+    assert_eq!(var2 >> (argc + 48) as u128, 18608);\n+    assert_eq!(var2 >> (argc + 60) as u128, 4);\n+    assert_eq!(var2 >> (argc + 62) as u128, 1);\n+    assert_eq!(var2 >> (argc + 63) as u128, 0);\n+\n+    assert_eq!(var3 >> (argc as u128 - 1), var3);\n+    assert_eq!(var3 >> argc as u128, 96618259944854013736810163053136969792);\n+    assert_eq!(var3 >> (argc + 32) as u128, 22495691651677250335181635584);\n+    assert_eq!(var3 >> (argc + 48) as u128, 343257013727985387194544);\n+    assert_eq!(var3 >> (argc + 60) as u128, 83802981867183932420);\n+    assert_eq!(var3 >> (argc + 62) as u128, 20950745466795983105);\n+    assert_eq!(var3 >> (argc + 63) as u128, 10475372733397991552);\n+    assert_eq!(var3 >> (argc + 80) as u128, 79920751444992);\n+\n+    assert_eq!(var6 >> argc as u128, 9223372036854775808);\n+    assert_eq!((var6 - 1) >> argc as u128, 9223372036854775807);\n+    assert_eq!(var7 >> argc as u128, 85070591730234615865843651857942052864);\n+\n+    // Casts\n+    assert_eq!((var >> (argc + 32) as u128) as u64, 0);\n+    assert_eq!((var >> argc as u128) as u64, 67108928);\n+\n+    // Addition.\n+    assert_eq!(var + argc as u128, 134217857);\n+\n+    assert_eq!(var2 + argc as u128, 10475372733397991553);\n+    assert_eq!(var2 + (var2 + argc as u128) as u128, 20950745466795983105);\n+\n+    assert_eq!(var3 + argc as u128, 193236519889708027473620326106273939585);\n+\n+    // Subtraction\n+    assert_eq!(var - argc as u128, 134217855);\n+\n+    assert_eq!(var2 - argc as u128, 10475372733397991551);\n+\n+    assert_eq!(var3 - argc as u128, 193236519889708027473620326106273939583);\n+\n+    // Multiplication\n+    assert_eq!(var * (argc + 1) as u128, 268435712);\n+    assert_eq!(var * (argc as u128 + var2), 1405982069077538020949770368);\n+\n+    assert_eq!(var2 * (argc + 1) as u128, 20950745466795983104);\n+    assert_eq!(var2 * (argc as u128 + var2), 109733433903618109003204073240861360256);\n+\n+    assert_eq!(var3 * argc as u128, 193236519889708027473620326106273939584);\n+\n+    assert_eq!(var4 * (argc + 1) as u128, 246473039779416054947240652212547879168);\n+\n+    assert_eq!(var5 * (argc + 1) as u128, 306473039779416054947240652212547879168);\n+\n+    // Division.\n+    assert_eq!(var / (argc + 1) as u128, 67108928);\n+    assert_eq!(var / (argc + 2) as u128, 44739285);\n+\n+    assert_eq!(var2 / (argc + 1) as u128, 5237686366698995776);\n+    assert_eq!(var2 / (argc + 2) as u128, 3491790911132663850);\n+\n+    assert_eq!(var3 / (argc + 1) as u128, 96618259944854013736810163053136969792);\n+    assert_eq!(var3 / (argc + 2) as u128, 64412173296569342491206775368757979861);\n+    assert_eq!(var3 / (argc as u128 + var4), 1);\n+    assert_eq!(var3 / (argc as u128 + var2), 18446744073709551615);\n+\n+    assert_eq!(var4 / (argc + 1) as u128, 61618259944854013736810163053136969792);\n+    assert_eq!(var4 / (argc + 2) as u128, 41078839963236009157873442035424646528);\n+\n+    0\n+}"}]}