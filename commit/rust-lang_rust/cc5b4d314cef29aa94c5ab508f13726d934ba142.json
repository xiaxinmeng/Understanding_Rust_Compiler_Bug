{"sha": "cc5b4d314cef29aa94c5ab508f13726d934ba142", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNWI0ZDMxNGNlZjI5YWE5NGM1YWI1MDhmMTM3MjZkOTM0YmExNDI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-08T16:41:58Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-08T16:41:58Z"}, "message": "add md files", "tree": {"sha": "601fa88ac503368ae84a01bc30c5d027123aa25c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/601fa88ac503368ae84a01bc30c5d027123aa25c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc5b4d314cef29aa94c5ab508f13726d934ba142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc5b4d314cef29aa94c5ab508f13726d934ba142", "html_url": "https://github.com/rust-lang/rust/commit/cc5b4d314cef29aa94c5ab508f13726d934ba142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc5b4d314cef29aa94c5ab508f13726d934ba142/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89df25f400844092e2f667f954e84f839e3731bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/89df25f400844092e2f667f954e84f839e3731bc", "html_url": "https://github.com/rust-lang/rust/commit/89df25f400844092e2f667f954e84f839e3731bc"}], "stats": {"total": 371, "additions": 371, "deletions": 0}, "files": [{"sha": "5730192b6a3fbf4725d53214ba4d4b12f1ca806b", "filename": "lifetimes.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc5b4d314cef29aa94c5ab508f13726d934ba142/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc5b4d314cef29aa94c5ab508f13726d934ba142/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=cc5b4d314cef29aa94c5ab508f13726d934ba142", "patch": "@@ -0,0 +1,13 @@\n+% Advanced Lifetimes\n+\n+Lifetimes are the breakout feature of Rust.\n+\n+# Safe Rust\n+\n+* no aliasing of &mut\n+\n+# Unsafe Rust\n+\n+* Splitting lifetimes into disjoint regions\n+* Creating lifetimes from raw pointers\n+*\n\\ No newline at end of file"}, {"sha": "13a2bdf8fff7cd76aa8707e23bf07e4ea22e82dd", "filename": "raii.md", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/cc5b4d314cef29aa94c5ab508f13726d934ba142/raii.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc5b4d314cef29aa94c5ab508f13726d934ba142/raii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/raii.md?ref=cc5b4d314cef29aa94c5ab508f13726d934ba142", "patch": "@@ -0,0 +1,179 @@\n+% The Perils Of RAII\n+\n+Ownership Based Resource Management (AKA RAII: Resource Acquisition is Initialization) is\n+something you'll interact with a lot in Rust. Especially if you use the standard library.\n+\n+Roughly speaking the pattern is as follows: to acquire a resource, you create an object that\n+manages it. To release the resource, you simply destroy the object, and it cleans up the\n+resource for you. The most common \"resource\"\n+this pattern manages is simply *memory*. `Box`, `Rc`, and basically everything in\n+`std::collections` is a convenience to enable correctly managing memory. This is particularly\n+important in Rust because we have no pervasive GC to rely on for memory management. Which is the\n+point, really: Rust is about control. However we are not limited to just memory.\n+Pretty much every other system resource like a thread, file, or socket is exposed through\n+this kind of API.\n+\n+So, how does RAII work in Rust? Unlike C++, Rust does not come with a slew on builtin\n+kinds of constructor. There are no Copy, Default, Assignment, Move, or whatever constructors.\n+This largely has to do with Rust's philosophy of being explicit.\n+\n+Move constructors are meaningless in Rust because we don't enable types to \"care\" about their\n+location in memory. Every type must be ready for it to be blindly memcopied to somewhere else\n+in memory. This means pure on-the-stack-but-still-movable intrusive linked lists are simply\n+not happening in Rust (safely).\n+\n+Assignment and copy constructors similarly don't exist because move semantics are the *default*\n+in rust. At most `x = y` just moves the bits of y into the x variable. Rust does provide two\n+facilities for going back to C++'s copy-oriented semantics: `Copy` and `Clone`. Clone is our\n+moral equivalent of copy constructor, but it's never implicitly invoked. You have to explicitly\n+call `clone` on an element you want to be cloned. Copy is a special case of Clone where the\n+implementation is just \"duplicate the bitwise representation\". Copy types *are* implicitely\n+cloned whenever they're moved, but because of the definition of Copy this just means *not*\n+treating the old copy as uninitialized; a no-op.\n+\n+While Rust provides a `Default` trait for specifying the moral equivalent of a default\n+constructor, it's incredibly rare for this trait to be used. This is because variables\n+aren't implicitely initialized (see [working with uninitialized memory][uninit] for details).\n+Default is basically only useful for generic programming.\n+\n+More often than not, in a concrete case a type will provide a static `new` method for any\n+kind of \"default\" constructor. This has no relation to `new` in other languages and has no\n+special meaning. It's just a naming convention.\n+\n+What the language *does* provide is full-blown automatic destructors through the `Drop` trait,\n+which provides the following method:\n+\n+```rust\n+fn drop(&mut self);\n+```\n+\n+This method gives the type time to somehow finish what it was doing. **After `drop` is run,\n+Rust will recursively try to drop all of the fields of the `self` struct**. This is a\n+convenience feature so that you don't have to write \"destructor boilerplate\" dropping\n+children. **There is no way to prevent this in Rust 1.0**.  Also note that `&mut self` means\n+that even if you *could* supress recursive Drop, Rust will prevent you from e.g. moving fields\n+out of self. For most types, this is totally fine: they own all their data, there's no\n+additional state passed into drop to try to send it to, and `self` is about to be marked as\n+uninitialized (and therefore inaccessible).\n+\n+For instance, a custom implementation of `Box` might write `Drop` like this:\n+\n+```rust\n+struct Box<T>{ ptr: *mut T }\n+\n+impl<T> Drop for Box<T> {\n+\tfn drop(&mut self) {\n+\t\tunsafe {\n+\t\t\t(*self.ptr).drop();\n+\t\t\theap::deallocate(self.ptr);\n+\t\t}\n+\t}\n+}\n+```\n+\n+and this works fine because when Rust goes to drop the `ptr` field it just sees a *mut that\n+has no actual `Drop` implementation. Similarly nothing can use-after-free the `ptr` because\n+the Box is completely gone.\n+\n+However this wouldn't work:\n+\n+```rust\n+struct Box<T>{ ptr: *mut T }\n+\n+impl<T> Drop for Box<T> {\n+\tfn drop(&mut self) {\n+\t\tunsafe {\n+\t\t\t(*self.ptr).drop();\n+\t\t\theap::deallocate(self.ptr);\n+\t\t}\n+\t}\n+}\n+\n+struct SuperBox<T> { box: Box<T> }\n+\n+impl<T> Drop for SuperBox<T> {\n+\tfn drop(&mut self) {\n+\t\tunsafe {\n+\t\t\t// Hyper-optimized: deallocate the box's contents for it\n+\t\t\t// without `drop`ing the contents\n+\t\t\theap::deallocate(self.box.ptr);\n+\t\t}\n+\t}\n+}\n+```\n+\n+because after we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n+happily proceed to tell the box to Drop itself and everything will blow up with\n+use-after-frees and double-frees.\n+\n+Note that the recursive drop behaviour applies to *all* structs and enums\n+regardless of whether they implement Drop. Therefore something like\n+\n+```rust\n+struct Boxy<T> {\n+\tdata1: Box<T>,\n+\tdata2: Box<T>,\n+\tinfo: u32,\n+}\n+```\n+\n+will have its data1 and data2's fields destructors whenever it \"would\" be\n+dropped, even though it itself doesn't implement Drop. We say that such a type\n+*needs Drop*, even though it is not itself Drop.\n+\n+Similarly,\n+\n+```rust\n+enum Link {\n+\tNext(Box<Link>),\n+\tNone,\n+}\n+```\n+\n+will have its inner Box field dropped *if and only if* a value stores the Next variant.\n+\n+In general this works really nice because you don't need to worry about adding/removing\n+dtors when you refactor your data layout. Still there's certainly many valid usecases for\n+needing to do trickier things with destructors.\n+\n+The classic safe solution to blocking recursive drop semantics and allowing moving out\n+of Self is to use an Option:\n+\n+```rust\n+struct Box<T>{ ptr: *mut T }\n+\n+impl<T> Drop for Box<T> {\n+\tfn drop(&mut self) {\n+\t\tunsafe {\n+\t\t\t(*self.ptr).drop();\n+\t\t\theap::deallocate(self.ptr);\n+\t\t}\n+\t}\n+}\n+\n+struct SuperBox<T> { box: Option<Box<T>> }\n+\n+impl<T> Drop for SuperBox<T> {\n+\tfn drop(&mut self) {\n+\t\tunsafe {\n+\t\t\t// Hyper-optimized: deallocate the box's contents for it\n+\t\t\t// without `drop`ing the contents. Need to set the `box`\n+\t\t\t// fields as `None` to prevent Rust from trying to Drop it.\n+\t\t\theap::deallocate(self.box.take().unwrap().ptr);\n+\t\t}\n+\t}\n+}\n+```\n+\n+However this has fairly odd semantics: you're saying that a field that *should* always be Some\n+may be None, just because that happens in the dtor. Of course this conversely makes a lot of sense:\n+you can call arbitrary methods on self during the destructor, and this should prevent you from\n+ever doing so after deinitializing the field. Not that it will prevent you from producing any other\n+arbitrarily invalid state in there.\n+\n+On balance this is an ok choice. Certainly if you're just getting started.\n+\n+In the future, we expect there to be a first-class way to announce that a field\n+should be automatically dropped.\n+\n+[uninit]:\n\\ No newline at end of file"}, {"sha": "89d0a93f6385a53186f16d559833420234ebcbb7", "filename": "uninitialized.md", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/cc5b4d314cef29aa94c5ab508f13726d934ba142/uninitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc5b4d314cef29aa94c5ab508f13726d934ba142/uninitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/uninitialized.md?ref=cc5b4d314cef29aa94c5ab508f13726d934ba142", "patch": "@@ -0,0 +1,179 @@\n+% Working With Uninitialized Memory\n+\n+All runtime-allocated memory in a Rust program begins its life as *uninitialized*. In this state the value of the memory is an indeterminate pile of bits that may or may not even reflect a valid state for the type that is supposed to inhabit that location of memory. Attempting to interpret this memory as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n+\n+Like C, all stack variables in Rust begin their life as uninitialized until a value is explicitly assigned to them. Unlike C, Rust statically prevents you from ever reading them until you do:\n+\n+```rust\n+fn main() {\n+\tlet x: i32;\n+\tprintln!(\"{}\", x);\n+}\n+```\n+\n+```text\n+src/main.rs:3:20: 3:21 error: use of possibly uninitialized variable: `x`\n+src/main.rs:3     println!(\"{}\", x);\n+                                 ^\n+```\n+\n+This is based off of a basic branch analysis: every branch must assign a value to `x` before it\n+is first used. Interestingly, Rust doesn't require the variable to be mutable to perform a delayed initialization if every branch assigns exactly once. However the analysis does not take advantage of constant analysis or anything like that. So this compiles:\n+\n+```rust\n+fn main() {\n+\tlet x: i32;\n+\tlet y: i32;\n+\n+\ty = 1;\n+\n+\tif true {\n+\t\tx = 1;\n+\t} else {\n+\t\tx = 2;\n+\t}\n+\n+    println!(\"{} {}\", x, y);\n+}\n+```\n+\n+but this doesn't:\n+\n+```rust\n+fn main() {\n+\tlet x: i32;\n+\tif true {\n+\t\tx = 1;\n+\t}\n+\tprintln!(\"{}\", x);\n+}\n+```\n+\n+```text\n+src/main.rs:6:17: 6:18 error: use of possibly uninitialized variable: `x`\n+src/main.rs:6 \tprintln!(\"{}\", x);\n+```\n+\n+while this does:\n+\n+```rust\n+fn main() {\n+\tlet x: i32;\n+\tif true {\n+\t\tx = 1;\n+\t\tprintln!(\"{}\", x);\n+\t}\n+\t// Don't care that there are branches where it's not initialized\n+\t// since we don't use the value in those branches\n+}\n+```\n+\n+If a value is moved out of a variable, that variable becomes logically uninitialized if the type\n+of the value isn't Copy. That is:\n+\n+```rust\n+fn main() {\n+\tlet x = 0;\n+\tlet y = Box::new(0);\n+\tlet z1 = x; // x is still valid because i32 is Copy\n+\tlet z2 = y; // y has once more become logically uninitialized, since Box is not Copy\n+}\n+```\n+\n+However reassigning `y` in this example *would* require `y` to be marked as mutable, as a\n+Safe Rust program could observe that the value of `y` changed. Otherwise the variable is\n+exactly like new.\n+\n+This raises an interesting question with respect to `Drop`: where does Rust\n+try to call the destructor of a variable that is conditionally initialized?\n+It turns out that Rust actually tracks whether a type should be dropped or not *at runtime*. As a\n+variable becomes initialized and uninitialized, a *drop flag* for that variable is set and unset.\n+When a variable goes out of scope or is assigned it evaluates whether the current value of the\n+variable should be dropped. Of course, static analysis can remove these checks. If the compiler\n+can prove that a value is guaranteed to be either initialized or not, then it can theoretically\n+generate more efficient code! As such it may be desirable to structure code to have *static drop\n+semantics* when possible.\n+\n+As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a secret field of any type\n+that implements Drop. The language sets the drop flag by overwriting the entire struct with a\n+particular value. This is pretty obviously Not The Fastest and causes a bunch of trouble with\n+optimizing code. As such work is currently under way to move the flags out onto the stack frame\n+where they more reasonably belong. Unfortunately this work will take some time as it requires\n+fairly substantial changes to the compiler.\n+\n+So in general, Rust programs don't need to worry about uninitialized values on the stack for\n+correctness. Although they might care for performance. Thankfully, Rust makes it easy to take\n+control here! Uninitialized values are there, and Safe Rust lets you work with them, but you're\n+never in trouble.\n+\n+One interesting exception to this rule is working with arrays. Safe Rust doesn't permit you to\n+partially initialize an array. When you initialize an array, you can either set every value to the\n+same thing with `let x = [val; N]`, or you can specify each member individually with\n+`let x = [val1, val2, val3]`. Unfortunately this is pretty rigid, especially if you need\n+to initialize your array in a more incremental or dynamic way.\n+\n+Unsafe Rust gives us a powerful tool to handle this problem: `std::mem::uninitialized`.\n+This function pretends to return a value when really it does nothing at all. Using it, we can\n+convince Rust that we have initialized a variable, allowing us to do trickier things with\n+conditional and incremental initialization.\n+\n+Unfortunately, this raises a tricky problem. Assignment has a different meaning to Rust based on\n+whether it believes that a variable is initialized or not. If it's uninitialized, then Rust will\n+semantically just memcopy the bits over the uninit ones, and do nothing else. However if Rust\n+believes a value to be initialized, it will try to `Drop` the old value! Since we've tricked Rust\n+into believing that the value is initialized, we can no longer safely use normal assignment.\n+\n+This is also a problem if you're working with a raw system allocator, which of course returns a\n+pointer to uninitialized memory.\n+\n+To handle this, we must use the `std::ptr` module. In particular, it provides three functions that\n+allow us to assign bytes to a location in memory without evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n+\n+* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed to by `ptr`.\n+* `ptr::copy(src, dest, count)` copies the bits that `count` T's would occupy from src to dest. (this is equivalent to memmove -- note that the argument order is reversed!)\n+* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a little faster on the\n+assumption that the two ranges of memory don't overlap. (this is equivalent to memcopy -- note that the argument order is reversed!)\n+\n+It should go without saying that these functions, if misused, will cause serious havoc or just\n+straight up Undefined Behaviour. The only things that these functions *themselves* require is that\n+the locations you want to read and write are allocated. However the ways writing arbitrary bit\n+patterns to arbitrary locations of memory can break things are basically uncountable!\n+\n+Putting this all together, we get the following:\n+\n+```rust\n+fn main() {\n+\tuse std::mem;\n+\n+\t// size of the array is hard-coded but easy to change. This means we can't\n+\t// use [a, b, c] syntax to initialize the array, though!\n+\tconst SIZE = 10;\n+\n+\tlet x: [Box<u32>; SIZE];\n+\n+\tunsafe {\n+\t\t// convince Rust that x is Totally Initialized\n+\t\tx = mem::uninitialized();\n+\t\tfor i in 0..SIZE {\n+\t\t\t// very carefully overwrite each index without reading it\n+\t\t\tptr::write(&mut x[i], Box::new(i));\n+\t\t}\n+\t}\n+\n+\tprintln!(\"{}\", x);\n+}\n+```\n+\n+It's worth noting that you don't need to worry about ptr::write-style shenanigans with\n+Plain Old Data (POD; types which don't implement Drop, nor contain Drop types),\n+because Rust knows not to try to Drop them. Similarly you should be able to assign the POD\n+fields of partially initialized structs directly.\n+\n+However when working with uninitialized memory you need to be ever vigilant for Rust trying to\n+Drop values you make like this before they're fully initialized. So every control path through\n+that variable's scope must initialize the value before it ends. *This includes code panicking*.\n+Again, POD types need not worry.\n+\n+And that's about it for working with uninitialized memory! Basically nothing anywhere expects\n+to be handed uninitialized memory, so if you're going to pass it around at all, be sure to be\n+*really* careful."}]}