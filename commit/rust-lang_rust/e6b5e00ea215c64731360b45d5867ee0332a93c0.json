{"sha": "e6b5e00ea215c64731360b45d5867ee0332a93c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YjVlMDBlYTIxNWM2NDczMTM2MGI0NWQ1ODY3ZWUwMzMyYTkzYzA=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-11T05:58:44Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-11T06:57:38Z"}, "message": "Simplify struct representation.\n\nOut goes the extra layer of struct wrapping; the destructedness flag is\nadded to the end of the struct.  This means that, if the struct\npreviously had alignment padding at the end, the flag will live there\ninstead of increasing the struct size.", "tree": {"sha": "33e4edd8973f27815835b1b178660eeb03143d7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33e4edd8973f27815835b1b178660eeb03143d7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6b5e00ea215c64731360b45d5867ee0332a93c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b5e00ea215c64731360b45d5867ee0332a93c0", "html_url": "https://github.com/rust-lang/rust/commit/e6b5e00ea215c64731360b45d5867ee0332a93c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6b5e00ea215c64731360b45d5867ee0332a93c0/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d8596d400b245143df4a421654d7a94a8b4c1e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d8596d400b245143df4a421654d7a94a8b4c1e1", "html_url": "https://github.com/rust-lang/rust/commit/1d8596d400b245143df4a421654d7a94a8b4c1e1"}], "stats": {"total": 79, "additions": 31, "deletions": 48}, "files": [{"sha": "d816aefeb2fd849fec2ecb1ab6b6714f34eba361", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 31, "deletions": 48, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e6b5e00ea215c64731360b45d5867ee0332a93c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b5e00ea215c64731360b45d5867ee0332a93c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e6b5e00ea215c64731360b45d5867ee0332a93c0", "patch": "@@ -81,8 +81,14 @@ pub enum Repr {\n     Unit(int),\n     /// C-like enums; basically an int.\n     CEnum(int, int), // discriminant range\n-    /// Single-case variants, and structs/tuples/records.\n-    Univariant(Struct, Destructor),\n+    /**\n+     * Single-case variants, and structs/tuples/records.\n+     *\n+     * Structs with destructors need a dynamic destroyedness flag to\n+     * avoid running the destructor too many times; this is included\n+     * in the `Struct` if present.\n+     */\n+    Univariant(Struct, bool),\n     /**\n      * General-case enums: discriminant as int, followed by fields.\n      * The fields start immediately after the discriminant, meaning\n@@ -92,18 +98,6 @@ pub enum Repr {\n     General(~[Struct])\n }\n \n-/**\n- * Structs without destructors have historically had an extra layer of\n- * LLVM-struct to make accessing them work the same as structs with\n- * destructors.  This could probably be flattened to a boolean now\n- * that this module exists.\n- */\n-enum Destructor {\n-    StructWithDtor,\n-    StructWithoutDtor,\n-    NonStruct\n-}\n-\n /// For structs, and struct-like parts of anything fancier.\n struct Struct {\n     size: u64,\n@@ -129,14 +123,17 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     }\n     let repr = @match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, *elems), NonStruct)\n+            Univariant(mk_struct(cx, *elems), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let dt = ty::ty_dtor(cx.tcx, def_id).is_present();\n-            Univariant(mk_struct(cx, fields.map(|field| {\n+            let ftys = do fields.map |field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n-            })), if dt { StructWithDtor } else { StructWithoutDtor })\n+            };\n+            let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n+            let ftys =\n+                if dtor { ftys + [ty::mk_bool(cx.tcx)] } else { ftys };\n+            Univariant(mk_struct(cx, ftys), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n@@ -156,7 +153,7 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n             } else if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n                 fail_unless!(cases[0].discr == 0);\n-                Univariant(mk_struct(cx, cases[0].tys), NonStruct)\n+                Univariant(mk_struct(cx, cases[0].tys), false)\n             } else if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n@@ -206,16 +203,11 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     match *r {\n         Unit(*) => ~[],\n         CEnum(*) => ~[T_enum_discrim(cx)],\n-        Univariant(ref st, dt) => {\n-            let f = if sizing {\n+        Univariant(ref st, _dtor) => {\n+            if sizing {\n                 st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n             } else {\n                 st.fields.map(|&ty| type_of::type_of(cx, ty))\n-            };\n-            match dt {\n-                NonStruct => f,\n-                StructWithoutDtor => ~[T_struct(f)],\n-                StructWithDtor => ~[T_struct(f), T_i8()]\n             }\n         }\n         General(ref sts) => {\n@@ -308,9 +300,10 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n             fail_unless!(min <= discr && discr <= max);\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n-        Univariant(_, StructWithDtor) => {\n+        Univariant(ref st, true) => {\n             fail_unless!(discr == 0);\n-            Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n+            Store(bcx, C_bool(true),\n+                  GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(*) => {\n             fail_unless!(discr == 0);\n@@ -328,7 +321,10 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n         Unit(*) | CEnum(*) => 0,\n-        Univariant(ref st, _) => { fail_unless!(discr == 0); st.fields.len() }\n+        Univariant(ref st, dtor) => {\n+            fail_unless!(discr == 0);\n+            st.fields.len() - (if dtor { 1 } else { 0 })\n+        }\n         General(ref cases) => cases[discr as uint].fields.len()\n     }\n }\n@@ -343,12 +339,8 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n         Unit(*) | CEnum(*) => {\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n-        Univariant(ref st, dt) => {\n+        Univariant(ref st, _dtor) => {\n             fail_unless!(discr == 0);\n-            let val = match dt {\n-                NonStruct => val,\n-                StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n-            };\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n@@ -376,7 +368,7 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n /// Access the struct drop flag, if present.\n pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n-        Univariant(_, StructWithDtor) => GEPi(bcx, val, [0, 1]),\n+        Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n         _ => bcx.ccx().sess.bug(~\"tried to get drop flag of non-droppable \\\n                                   type\")\n     }\n@@ -415,15 +407,9 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n             fail_unless!(min <= discr && discr <= max);\n             C_int(ccx, discr)\n         }\n-        Univariant(ref st, dt) => {\n+        Univariant(ref st, _dro) => {\n             fail_unless!(discr == 0);\n-            let s = C_struct(build_const_struct(ccx, st, vals));\n-            match dt {\n-                NonStruct => s,\n-                // The actual destructor flag doesn't need to be present.\n-                // But add an extra struct layer for compatibility.\n-                StructWithDtor | StructWithoutDtor => C_struct(~[s])\n-            }\n+            C_struct(build_const_struct(ccx, st, vals))\n         }\n         General(ref cases) => {\n             let case = &cases[discr as uint];\n@@ -508,9 +494,7 @@ pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n     match *r {\n         Unit(*) | CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n                                              const\"),\n-        Univariant(_, NonStruct) => const_struct_field(ccx, val, ix),\n-        Univariant(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n-                                                               [0]), ix),\n+        Univariant(*) => const_struct_field(ccx, val, ix),\n         General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n                                                             [1, 0]), ix)\n     }\n@@ -542,8 +526,7 @@ fn const_struct_field(ccx: @CrateContext, val: ValueRef, ix: uint)\n /// Is it safe to bitcast a value to the one field of its one variant?\n pub fn is_newtypeish(r: &Repr) -> bool {\n     match *r {\n-        Univariant(ref st, StructWithoutDtor)\n-        | Univariant(ref st, NonStruct) => st.fields.len() == 1,\n+        Univariant(ref st, false) => st.fields.len() == 1,\n         _ => false\n     }\n }"}]}