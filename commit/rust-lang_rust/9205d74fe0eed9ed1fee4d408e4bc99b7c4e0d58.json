{"sha": "9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMDVkNzRmZTBlZWQ5ZWQxZmVlNGQ0MDhlNGJjOTliN2M0ZTBkNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-10T03:45:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-10T03:45:11Z"}, "message": "auto merge of #20782 : iKevinY/rust/trpl-formatting, r=steveklabnik\n\nHere's my PR for the changes discussed in #19823. I decided to leave `_these_` types of italics the way there were because it differentiates the use of italics for emphasis from `*key term*` italics. Otherwise, bolded terms have been changed to italics, and single and double quotes have been changed appropriately, depending on their context (my judgement may not be the best, though).\r\n\r\nr? @steveklabnik (congratulations on #19897 being finalized and merged, by the way!)", "tree": {"sha": "31c27cd0ed2c3a4a2ffa55e9e9a524225e065dc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31c27cd0ed2c3a4a2ffa55e9e9a524225e065dc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "html_url": "https://github.com/rust-lang/rust/commit/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14f9d1f256e643e65f42737c7d3174bcc7a75abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/14f9d1f256e643e65f42737c7d3174bcc7a75abb", "html_url": "https://github.com/rust-lang/rust/commit/14f9d1f256e643e65f42737c7d3174bcc7a75abb"}, {"sha": "8f61814641c0fbbb929c8a04658d4ea819b4db51", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f61814641c0fbbb929c8a04658d4ea819b4db51", "html_url": "https://github.com/rust-lang/rust/commit/8f61814641c0fbbb929c8a04658d4ea819b4db51"}], "stats": {"total": 278, "additions": 139, "deletions": 139}, "files": [{"sha": "11ced4b9f3c1d130a81180a8902fadb1495cd7cc", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -1,7 +1,7 @@\n % Arrays, Vectors, and Slices\n \n Like many programming languages, Rust has list types to represent a sequence of\n-things. The most basic is the **array**, a fixed-size list of elements of the\n+things. The most basic is the *array*, a fixed-size list of elements of the\n same type. By default, arrays are immutable.\n \n ```{rust}\n@@ -32,7 +32,7 @@ for e in a.iter() {\n }\n ```\n \n-You can access a particular element of an array with **subscript notation**:\n+You can access a particular element of an array with *subscript notation*:\n \n ```{rust}\n let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n@@ -47,7 +47,7 @@ array, you will get an error: array access is bounds-checked at run-time. Such\n errant access is the source of many bugs in other systems programming\n languages.\n \n-A **vector** is a dynamic or \"growable\" array, implemented as the standard\n+A *vector* is a dynamic or \"growable\" array, implemented as the standard\n library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n later). Vectors are to arrays what `String` is to `&str`. You can create them\n with the `vec!` macro:\n@@ -73,7 +73,7 @@ println!(\"The length of nums is now {}\", nums.len());   // Prints 4\n \n Vectors have many more useful methods.\n \n-A **slice** is a reference to (or \"view\" into) an array. They are useful for\n+A *slice* is a reference to (or \"view\" into) an array. They are useful for\n allowing safe, efficient access to a portion of an array without copying. For\n example, you might want to reference just one line of a file read into memory.\n By nature, a slice is not created directly, but from an existing variable."}, {"sha": "cec9c1e7cf7dde178417ae75bfea51885f7f2e2c", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -2,7 +2,7 @@\n \n So far, we've made lots of functions in Rust, but we've given them all names.\n Rust also allows us to create anonymous functions. Rust's anonymous\n-functions are called **closure**s. By themselves, closures aren't all that\n+functions are called *closures*. By themselves, closures aren't all that\n interesting, but when you combine them with functions that take closures as\n arguments, really powerful things are possible.\n \n@@ -61,7 +61,7 @@ fn main() {\n \n ## Moving closures\n \n-Rust has a second type of closure, called a **moving closure**. Moving\n+Rust has a second type of closure, called a *moving closure*. Moving\n closures are indicated using the `move` keyword (e.g., `move || x *\n x`). The difference between a moving closure and an ordinary closure\n is that a moving closure always takes ownership of all variables that"}, {"sha": "fe7acaab5fc70ad56b86fa30cf4169d1dfb7ca2c", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -4,8 +4,8 @@ Now that we have some functions, it's a good idea to learn about comments.\n Comments are notes that you leave to other programmers to help explain things\n about your code. The compiler mostly ignores them.\n \n-Rust has two kinds of comments that you should care about: **line comment**s\n-and **doc comment**s.\n+Rust has two kinds of comments that you should care about: *line comments*\n+and *doc comments*.\n \n ```{rust}\n // Line comments are anything after '//' and extend to the end of the line."}, {"sha": "31d330b40222f212ee8bafaccb4354dff78b046a", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -6,7 +6,7 @@ strings, but next, let's talk about some more complicated ways of storing data.\n \n ## Tuples\n \n-The first compound data type we're going to talk about are called **tuple**s.\n+The first compound data type we're going to talk about are called *tuples*.\n Tuples are an ordered list of a fixed size. Like this:\n \n ```rust\n@@ -25,10 +25,10 @@ position having a type name rather than the value. Careful readers will also\n note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n You haven't seen `&str` as a type before, and we'll discuss the details of\n strings later. In systems programming languages, strings are a bit more complex\n-than in other languages. For now, just read `&str` as \"a string slice,\" and\n+than in other languages. For now, just read `&str` as a *string slice*, and\n we'll learn more soon.\n \n-You can access the fields in a tuple through a **destructuring let**. Here's\n+You can access the fields in a tuple through a *destructuring let*. Here's\n an example:\n \n ```rust\n@@ -40,8 +40,8 @@ println!(\"x is {}\", x);\n Remember before when I said the left-hand side of a `let` statement was more\n powerful than just assigning a binding? Here we are. We can put a pattern on\n the left-hand side of the `let`, and if it matches up to the right-hand side,\n-we can assign multiple bindings at once. In this case, `let` 'destructures,'\n-or 'breaks up,' the tuple, and assigns the bits to three bindings.\n+we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n+or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n \n This pattern is very powerful, and we'll see it repeated more later.\n \n@@ -83,18 +83,18 @@ fn main() {\n }\n ```\n \n-Even though Rust functions can only return one value, a tuple _is_ one value,\n-that happens to be made up of more than one value. You can also see in this example how you\n-can destructure a pattern returned by a function, as well.\n+Even though Rust functions can only return one value, a tuple *is* one value,\n+that happens to be made up of more than one value. You can also see in this\n+example how you can destructure a pattern returned by a function, as well.\n \n Tuples are a very simple data structure, and so are not often what you want.\n Let's move on to their bigger sibling, structs.\n \n ## Structs\n \n-A struct is another form of a 'record type,' just like a tuple. There's a\n+A struct is another form of a *record type*, just like a tuple. There's a\n difference: structs give each element that they contain a name, called a\n-'field' or a 'member.' Check it out:\n+*field* or a *member*. Check it out:\n \n ```rust\n struct Point {\n@@ -143,8 +143,7 @@ This will print `The point is at (5, 0)`.\n ## Tuple Structs and Newtypes\n \n Rust has another data type that's like a hybrid between a tuple and a struct,\n-called a **tuple struct**. Tuple structs do have a name, but their fields\n-don't:\n+called a *tuple struct*. Tuple structs do have a name, but their fields don't:\n \n \n ```{rust}\n@@ -182,7 +181,7 @@ Now, we have actual names, rather than positions. Good names are important,\n and with a struct, we have actual names.\n \n There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this a 'newtype,' because it lets\n+tuple struct with only one element. We call this a *newtype*, because it lets\n you create a new type that's a synonym for another one:\n \n ```{rust}\n@@ -199,7 +198,7 @@ destructuring `let`.\n \n ## Enums\n \n-Finally, Rust has a \"sum type\", an **enum**. Enums are an incredibly useful\n+Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n feature of Rust, and are used throughout the standard library. This is an enum\n that is provided by the Rust standard library:\n "}, {"sha": "c179a263b35ed446031b477d2701c8e421d2b04c", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -8,17 +8,17 @@ these kinds of things, Rust has a module system.\n \n # Basic terminology: Crates and Modules\n \n-Rust has two distinct terms that relate to the module system: \"crate\" and\n-\"module.\" A crate is synonymous with a 'library' or 'package' in other\n+Rust has two distinct terms that relate to the module system: *crate* and\n+*module*. A crate is synonymous with a *library* or *package* in other\n languages. Hence \"Cargo\" as the name of Rust's package management tool: you\n ship your crates to others with Cargo. Crates can produce an executable or a\n shared library, depending on the project.\n \n-Each crate has an implicit \"root module\" that contains the code for that crate.\n+Each crate has an implicit *root module* that contains the code for that crate.\n You can then define a tree of sub-modules under that root module. Modules allow\n you to partition your code within the crate itself.\n \n-As an example, let's make a \"phrases\" crate, which will give us various phrases\n+As an example, let's make a *phrases* crate, which will give us various phrases\n in different languages. To keep things simple, we'll stick to \"greetings\" and\n \"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e\uff09 as\n two languages for those phrases to be in. We'll use this module layout:\n@@ -45,7 +45,7 @@ two languages for those phrases to be in. We'll use this module layout:\n \n In this example, `phrases` is the name of our crate. All of the rest are\n modules.  You can see that they form a tree, branching out from the crate\n-\"root\", which is the root of the tree: `phrases` itself.\n+*root*, which is the root of the tree: `phrases` itself.\n \n Now that we have a plan, let's define these modules in code. To start,\n generate a new crate with Cargo:"}, {"sha": "6c444b741c5de36346af356eab69010b869db233", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -16,10 +16,10 @@ how to handle each. Then, we'll discuss upgrading failures to panics.\n # Failure vs. Panic\n \n Rust uses two terms to differentiate between two forms of error: failure, and\n-panic. A **failure** is an error that can be recovered from in some way. A\n-**panic** is an error that cannot be recovered from.\n+panic. A *failure* is an error that can be recovered from in some way. A\n+*panic* is an error that cannot be recovered from.\n \n-What do we mean by 'recover'? Well, in most cases, the possibility of an error\n+What do we mean by \"recover\"? Well, in most cases, the possibility of an error\n is expected. For example, consider the `from_str` function:\n \n ```{rust,ignore}\n@@ -35,7 +35,7 @@ from_str(\"hello5world\");\n ```\n \n This won't work. So we know that this function will only work properly for some\n-inputs. It's expected behavior. We call this kind of error 'failure.'\n+inputs. It's expected behavior. We call this kind of error a *failure*.\n \n On the other hand, sometimes, there are errors that are unexpected, or which\n we cannot recover from. A classic example is an `assert!`:\n@@ -46,7 +46,7 @@ assert!(x == 5);\n \n We use `assert!` to declare that something is true. If it's not true, something\n is very wrong. Wrong enough that we can't continue with things in the current\n-state. Another example is using the `unreachable!()` macro\n+state. Another example is using the `unreachable!()` macro:\n \n ```{rust,ignore}\n enum Event {\n@@ -114,7 +114,7 @@ fn main() {\n \n We shouldn't ever hit the `_` case, so we use the `unreachable!()` macro to\n indicate this. `unreachable!()` gives a different kind of error than `Result`.\n-Rust calls these sorts of errors 'panics.'\n+Rust calls these sorts of errors *panics*.\n \n # Handling errors with `Option` and `Result`\n "}, {"sha": "a65325af7be3db9532474e8a52ada8efed1975b0", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -166,7 +166,7 @@ GitHub](https://github.com/thestinger/rust-snappy).\n \n # Stack management\n \n-Rust tasks by default run on a \"large stack\". This is actually implemented as a\n+Rust tasks by default run on a *large stack*. This is actually implemented as a\n reserving a large segment of the address space and then lazily mapping in pages\n as they are needed. When calling an external C function, the code is invoked on\n the same stack as the rust stack. This means that there is no extra"}, {"sha": "2e32fdfa7947f0b976401e9c5a7e1225a36ead99", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -8,7 +8,7 @@ fn main() {\n ```\n \n This is the simplest possible function declaration. As we mentioned before,\n-`fn` says 'this is a function,' followed by the name, some parentheses because\n+`fn` says \"this is a function,\" followed by the name, some parentheses because\n this function takes no arguments, and then some curly braces to indicate the\n body. Here's a function named `foo`:\n \n@@ -86,7 +86,7 @@ fn add_one(x: i32) -> i32 {\n ```\n \n Rust functions return exactly one value, and you declare the type after an\n-'arrow', which is a dash (`-`) followed by a greater-than sign (`>`).\n+\"arrow,\" which is a dash (`-`) followed by a greater-than sign (`>`).\n \n You'll note the lack of a semicolon here. If we added it in:\n "}, {"sha": "402f36cd74bd9239f3b15f86e17ec859cd446907", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -20,9 +20,9 @@ enum OptionalFloat64 {\n ```\n \n This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called **parametric polymorphism** in type theory,\n-which means that they are types or functions that have multiple forms (\"poly\"\n-is multiple, \"morph\" is form) over a given parameter (\"parametric\").\n+way: generics. Generics are called *parametric polymorphism* in type theory,\n+which means that they are types or functions that have multiple forms (*poly*\n+is multiple, *morph* is form) over a given parameter (*parametric*).\n \n Anyway, enough with type theory declarations, let's check out the generic form\n of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n@@ -150,7 +150,7 @@ fn inverse32(x: f32) -> Result<f32, String> {\n }\n ```\n \n-Bummer. What we need is a **generic function**. Luckily, we can write one!\n+Bummer. What we need is a *generic function*. Luckily, we can write one!\n However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n A generic version of `inverse` would look something like this:\n "}, {"sha": "16bd1e347b7c85c839848a130fa9016e197e11d5", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -111,7 +111,7 @@ Enter the docs. Rust has a page specifically to document the standard library.\n You can find that page [here](../std/index.html). There's a lot of information on\n that page, but the best part is the search bar. Right up at the top, there's\n a box that you can enter in a search term. The search is pretty primitive\n-right now, but is getting better all the time. If you type 'random' in that\n+right now, but is getting better all the time. If you type \"random\" in that\n box, the page will update to [this one](../std/index.html?search=random). The very\n first result is a link to [`std::rand::random`](../std/rand/fn.random.html). If we\n click on that result, we'll be taken to its documentation page.\n@@ -147,7 +147,7 @@ explained.  We then added in a `let` expression to create a variable binding\n named `secret_number`, and we printed out its result.\n \n Also, you may wonder why we are using `%` on the result of `rand::random()`.\n-This operator is called 'modulo', and it returns the remainder of a division.\n+This operator is called *modulo*, and it returns the remainder of a division.\n By taking the modulo of the result of `rand::random()`, we're limiting the\n values to be between 0 and 99. Then, we add one to the result, making it from 1\n to 100. Using modulo can give you a very, very small bias in the result, but\n@@ -608,8 +608,8 @@ out that I guessed 76. Run the program a few times, and verify that guessing\n the number works, as well as guessing a number too small.\n \n The Rust compiler helped us out quite a bit there! This technique is called\n-\"lean on the compiler\", and it's often useful when working on some code. Let\n-the error messages help guide you towards the correct types.\n+\"leaning on the compiler\", and it's often useful when working on some code.\n+Let the error messages help guide you towards the correct types.\n \n Now we've got most of the game working, but we can only make one guess. Let's\n change that by adding loops!"}, {"sha": "eced72465ecbb49032ec455a45fc5f5411e0be6c", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -66,7 +66,7 @@ it explain itself to you:\n \n TOML is very similar to INI, but with some extra goodies.\n \n-Anyway, there are two **table**s in this file: `package` and `bin`. The first\n+Anyway, there are two *tables* in this file: `package` and `bin`. The first\n tells Cargo metadata about your package. The second tells Cargo that we're\n interested in building a binary, not a library (though we could do both!), as\n well as what it is named."}, {"sha": "3cb14df1210a9af07524bdbb1921441a5c055326", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -67,7 +67,7 @@ fn main() {\n }\n ```\n \n-These lines define a **function** in Rust. The `main` function is special:\n+These lines define a *function* in Rust. The `main` function is special:\n it's the beginning of every Rust program. The first line says \"I'm declaring a\n function named `main`, which takes no arguments and returns nothing.\" If there\n were arguments, they would go inside the parentheses (`(` and `)`), and because\n@@ -91,7 +91,7 @@ spaces, not tabs. Please configure your editor of choice to insert four spaces\n with the tab key. We provide some [sample configurations for various\n editors](https://github.com/rust-lang/rust/tree/master/src/etc).\n \n-The second point is the `println!()` part. This is calling a Rust **macro**,\n+The second point is the `println!()` part. This is calling a Rust *macro*,\n which is how metaprogramming is done in Rust. If it were a function instead, it\n would look like this: `println()`. For our purposes, we don't need to worry\n about this difference. Just know that sometimes, you'll see a `!`, and that\n@@ -102,19 +102,19 @@ last thing to mention: Rust's macros are significantly different from C macros,\n if you've used those. Don't be scared of using macros. We'll get to the details\n eventually, you'll just have to trust us for now.\n \n-Next, `\"Hello, world!\"` is a **string**. Strings are a surprisingly complicated\n-topic in a systems programming language, and this is a **statically allocated**\n+Next, `\"Hello, world!\"` is a *string*. Strings are a surprisingly complicated\n+topic in a systems programming language, and this is a *statically allocated*\n string. We will talk more about different kinds of allocation later. We pass\n this string as an argument to `println!`, which prints the string to the\n screen. Easy enough!\n \n-Finally, the line ends with a semicolon (`;`). Rust is an **expression\n-oriented** language, which means that most things are expressions. The `;` is\n+Finally, the line ends with a semicolon (`;`). Rust is an *expression\n+oriented* language, which means that most things are expressions. The `;` is\n used to indicate that this expression is over, and the next one is ready to\n begin. Most lines of Rust code end with a `;`. We will cover this in-depth\n later in the guide.\n \n-Finally, actually **compiling** and **running** our program. We can compile\n+Finally, actually *compiling* and *running* our program. We can compile\n with our compiler, `rustc`, by passing it the name of our source file:\n \n ```{bash}\n@@ -147,7 +147,7 @@ This prints out our `Hello, world!` text to our terminal.\n \n If you come from a dynamically typed language like Ruby, Python, or JavaScript,\n you may not be used to these two steps being separate. Rust is an\n-**ahead-of-time compiled language**, which means that you can compile a\n+*ahead-of-time compiled language*, which means that you can compile a\n program, give it to someone else, and they don't need to have Rust installed.\n If you give someone a `.rb` or `.py` or `.js` file, they need to have\n Ruby/Python/JavaScript installed, but you just need one command to both compile"}, {"sha": "8c9d89652b6676986eef2b0a4ac2bc008af486fb", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -4,7 +4,7 @@ Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional\n systems language. So let's talk about it, to make sure you grasp the nuances.\n \n-`if` is a specific form of a more general concept, the 'branch.' The name comes\n+`if` is a specific form of a more general concept, the *branch*. The name comes\n from a branch in a tree: a decision point, where depending on a choice,\n multiple paths can be taken.\n \n@@ -70,7 +70,7 @@ make no sense. But in Rust, `if` is an expression, which means that it returns\n a value. We can then use this value to initialize the binding.\n \n Speaking of which, bindings are a kind of the first of Rust's two statements.\n-The proper name is a **declaration statement**. So far, `let` is the only kind\n+The proper name is a *declaration statement*. So far, `let` is the only kind\n of declaration statement we've seen. Let's talk about that some more.\n \n In some languages, variable bindings can be written as expressions, not just\n@@ -95,15 +95,15 @@ expression, although its value is not particularly useful. Unlike C, where an\n assignment evaluates to the assigned value (e.g. `5` in the previous example),\n in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n \n-The second kind of statement in Rust is the **expression statement**. Its\n+The second kind of statement in Rust is the *expression statement*. Its\n purpose is to turn any expression into a statement. In practical terms, Rust's\n grammar expects statements to follow other statements. This means that you use\n semicolons to separate expressions from each other. This means that Rust\n looks a lot like most other languages that require you to use semicolons\n at the end of every line, and you will see semicolons at the end of almost\n every line of Rust code you see.\n \n-What is this exception that makes us say 'almost?' You saw it already, in this\n+What is this exception that makes us say \"almost\"? You saw it already, in this\n code:\n \n ```{rust}\n@@ -129,7 +129,7 @@ Note the semicolons after the 10 and 15. Rust will give us the following error:\n error: mismatched types: expected `i32` but found `()` (expected i32 but found ())\n ```\n \n-We expected an integer, but we got `()`. `()` is pronounced 'unit', and is a\n+We expected an integer, but we got `()`. `()` is pronounced *unit*, and is a\n special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n variable of type `i32`. It's only a valid value for variables of the type `()`,\n which aren't very useful. Remember how we said statements don't return a value?"}, {"sha": "8312f762c113a0552589c0c894eeb972099b3486", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -11,7 +11,7 @@ for x in range(0i, 10i) {\n ```\n \n Now that you know more Rust, we can talk in detail about how this works. The\n-`range` function returns an **iterator**. An iterator is something that we can\n+`range` function returns an *iterator*. An iterator is something that we can\n call the `.next()` method on repeatedly, and it gives us a sequence of things.\n \n Like this:\n@@ -101,19 +101,19 @@ So, now that we've established that `range` is often not what you want, let's\n talk about what you do want instead.\n \n There are three broad classes of things that are relevant here: iterators,\n-**iterator adapters**, and **consumers**. Here's some definitions:\n+*iterator adapters*, and *consumers*. Here's some definitions:\n \n-* 'iterators' give you a sequence of values.\n-* 'iterator adapters' operate on an iterator, producing a new iterator with a\n+* *iterators* give you a sequence of values.\n+* *iterator adapters* operate on an iterator, producing a new iterator with a\n   different output sequence.\n-* 'consumers' operate on an iterator, producing some final set of values.\n+* *consumers* operate on an iterator, producing some final set of values.\n \n Let's talk about consumers first, since you've already seen an iterator,\n `range`.\n \n ## Consumers\n \n-A 'consumer' operates on an iterator, returning some kind of value or values.\n+A *consumer* operates on an iterator, returning some kind of value or values.\n The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n@@ -161,9 +161,9 @@ let sum = range(1i, 4i)\n \n `fold()` is a consumer that looks like this:\n `fold(base, |accumulator, element| ...)`. It takes two arguments: the first\n-is an element called the \"base\". The second is a closure that itself takes two\n-arguments: the first is called the \"accumulator,\" and the second is an\n-\"element.\" Upon each iteration, the closure is called, and the result is the\n+is an element called the *base*. The second is a closure that itself takes two\n+arguments: the first is called the *accumulator*, and the second is an\n+*element*. Upon each iteration, the closure is called, and the result is the\n value of the accumulator on the next iteration. On the first iteration, the\n base is the value of the accumulator.\n \n@@ -205,7 +205,7 @@ see why consumers matter.\n As we've said before, an iterator is something that we can call the\n `.next()` method on repeatedly, and it gives us a sequence of things.\n Because you need to call the method, this means that iterators\n-are **lazy** and don't need to generate all of the values upfront.\n+are *lazy* and don't need to generate all of the values upfront.\n This code, for example, does not actually generate the numbers\n `1-100`, and just creates a value that represents the sequence:\n \n@@ -252,7 +252,7 @@ we need to talk about with regards to iterators. Let's get to it!\n \n ## Iterator adapters\n \n-\"Iterator adapters\" take an iterator and modify it somehow, producing\n+*Iterator adapters* take an iterator and modify it somehow, producing\n a new iterator. The simplest one is called `map`:\n \n ```{rust,ignore}"}, {"sha": "f54084a7fb9d3a679615100987c4e899ffaa1acb", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -46,7 +46,7 @@ Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n developers.\n \n-We'll talk more about `for` when we cover **iterator**s, later in the Guide.\n+We'll talk more about `for` when we cover *iterators*, later in the Guide.\n \n ## `while`\n "}, {"sha": "c73fbefb2a4019352bfb7104ecfcc11c38049a92", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -575,4 +575,4 @@ If Rust's macro system can't do what you need, you may want to write a\n macros, this is significantly more work, the interfaces are much less stable,\n and the warnings about debugging apply ten-fold. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called \"procedural macros\" for this reason.\n+extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "1833b05591be99f671d3900d06f373c4a217ffd4", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -20,13 +20,13 @@ match x {\n }\n ```\n \n-`match` takes an expression and then branches based on its value. Each 'arm' of\n+`match` takes an expression and then branches based on its value. Each *arm* of\n the branch is of the form `val => expression`. When the value matches, that arm's\n expression will be evaluated. It's called `match` because of the term 'pattern\n matching', which `match` is an implementation of.\n \n So what's the big advantage here? Well, there are a few. First of all, `match`\n-enforces 'exhaustiveness checking'. Do you see that last arm, the one with the\n+enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n ```text\n@@ -36,7 +36,7 @@ error: non-exhaustive patterns: `_` not covered\n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n integer, Rust knows that it can have a number of different values \u2013 for example,\n `6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a 'catch-all arm'. If none of the other arms match,\n+to compile. `_` acts like a *catch-all arm*. If none of the other arms match,\n the arm with `_` will, and since we have this catch-all arm, we now have an arm\n for every possible value of `x`, and so our program will compile successfully.\n "}, {"sha": "3d8de00991c95af9cc3a9940b347b98cf599a2cb", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -7,16 +7,16 @@ can be awkward. Consider this code:\n baz(bar(foo(x)));\n ```\n \n-We would read this left-to right, and so we see 'baz bar foo.' But this isn't the\n-order that the functions would get called in, that's inside-out: 'foo bar baz.'\n+We would read this left-to right, and so we see \"baz bar foo.\" But this isn't the\n+order that the functions would get called in, that's inside-out: \"foo bar baz.\"\n Wouldn't it be nice if we could do this instead?\n \n ```{rust,ignore}\n x.foo().bar().baz();\n ```\n \n Luckily, as you may have guessed with the leading question, you can! Rust provides\n-the ability to use this **method call syntax** via the `impl` keyword.\n+the ability to use this *method call syntax* via the `impl` keyword.\n \n Here's how it works:\n \n@@ -82,7 +82,7 @@ fn main() {\n }\n ```\n \n-This **static method** builds a new `Circle` for us. Note that static methods\n+This *static method* builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n "}, {"sha": "4febec941350b7c7f2a1de7a6aaa4540be3f9031", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -3,15 +3,15 @@\n This guide presents Rust's ownership system. This is one of Rust's most unique\n and compelling features, with which Rust developers should become quite\n acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n-The ownership system has a few distinct concepts: **ownership**, **borrowing**,\n-and **lifetimes**. We'll talk about each one in turn.\n+The ownership system has a few distinct concepts: *ownership*, *borrowing*,\n+and *lifetimes*. We'll talk about each one in turn.\n \n # Meta\n \n Before we get to the details, two important notes about the ownership system.\n \n Rust has a focus on safety and speed. It accomplishes these goals through many\n-\"zero cost abstractions,\" which means that in Rust, abstractions cost as little\n+*zero-cost abstractions*, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n of a zero cost abstraction. All of the analysis we'll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n@@ -31,14 +31,14 @@ With that in mind, let's learn about ownership.\n \n # Ownership\n \n-At its core, ownership is about 'resources.' For the purposes of the vast\n+At its core, ownership is about *resources*. For the purposes of the vast\n majority of this guide, we will talk about a specific resource: memory. The\n concept generalizes to any kind of resource, like a file handle, but to make it\n more concrete, we'll focus on memory.\n \n When your program allocates some memory, it needs some way to deallocate that\n memory. Imagine a function `foo` that allocates four bytes of memory, and then\n-never deallocates that memory. We call this problem 'leaking' memory, because\n+never deallocates that memory. We call this problem *leaking* memory, because\n each time we call `foo`, we're allocating another four bytes. Eventually, with\n enough calls to `foo`, we will run our system out of memory. That's no good. So\n we need some way for `foo` to deallocate those four bytes. It's also important\n@@ -50,7 +50,7 @@ times is bad. The counts must match.\n \n There's one other important detail with regards to allocating memory. Whenever\n we request some amount of memory, what we are given is a handle to that memory.\n-This handle (often called a 'pointer', when we're referring to memory) is how\n+This handle (often called a *pointer*, when we're referring to memory) is how\n we interact with the allocated memory. As long as we have that handle, we can\n do something with the memory. Once we're done with the handle, we're also done\n with the memory, as we can't do anything useful without a handle to it.\n@@ -74,8 +74,8 @@ The call to `malloc` allocates some memory. The call to `free` deallocates the\n memory. There's also bookkeeping about allocating the correct amount of memory.\n \n Rust combines these two aspects of allocating memory (and other resources) into\n-a concept called 'ownership.' Whenever we request some memory, that handle we\n-receive is called the 'owning handle.' Whenever that handle goes out of scope,\n+a concept called *ownership*. Whenever we request some memory, that handle we\n+receive is called the *owning handle*. Whenever that handle goes out of scope,\n Rust knows that you cannot do anything with the memory anymore, and so\n therefore deallocates the memory for you. Here's the equivalent example in\n Rust:\n@@ -171,8 +171,8 @@ This code will compile and run just fine. Now, we return a `box`, and so the\n ownership is transferred back to `y` in `main`. We only have ownership for the\n duration of our function before giving it back. This pattern is very common,\n and so Rust introduces a concept to describe a handle which temporarily refers\n-to something another handle owns. It's called \"borrowing,\" and it's done with\n-\"references\", designated by the `&` symbol.\n+to something another handle owns. It's called *borrowing*, and it's done with\n+*references*, designated by the `&` symbol.\n \n # Borrowing\n \n@@ -191,11 +191,11 @@ contents. But then we give ownership right back.\n \n In the physical world, you can give one of your possessions to someone for a\n short period of time. You still own your possession, you're just letting someone\n-else use it for a while. We call that 'lending' something to someone, and that\n-person is said to be 'borrowing' that something from you.\n+else use it for a while. We call that *lending* something to someone, and that\n+person is said to be *borrowing* that something from you.\n \n Rust's ownership system also allows an owner to lend out a handle for a limited\n-period. This is also called 'borrowing.' Here's a version of `add_one` which\n+period. This is also called *borrowing*. Here's a version of `add_one` which\n borrows its argument rather than taking ownership:\n \n ```rust\n@@ -219,11 +219,11 @@ complicated, however. For example, imagine this set of operations:\n 4. You decide to use the resource.\n \n Uh oh! Your reference is pointing to an invalid resource. This is called a\n-\"dangling pointer\" or \"use after free,\" when the resource is memory.\n+*dangling pointer* or \"use after free,\" when the resource is memory.\n \n To fix this, we have to make sure that step four never happens after step\n three. The ownership system in Rust does this through a concept called\n-\"lifetimes,\" which describe the scope that a reference is valid for.\n+*lifetimes*, which describe the scope that a reference is valid for.\n \n Let's look at that function which borrows an `int` again:\n \n@@ -233,7 +233,7 @@ fn add_one(num: &int) -> int {\n }\n ```\n \n-Rust has a feature called 'lifetime elision,' which allows you to not write\n+Rust has a feature called *lifetime elision*, which allows you to not write\n lifetime annotations in certain circumstances. This is one of them. We will\n cover the others later. Without eliding the lifetimes, `add_one` looks like\n this:\n@@ -244,7 +244,7 @@ fn add_one<'a>(num: &'a int) -> int {\n }\n ```\n \n-The `'a` is called a **lifetime**. Most lifetimes are used in places where\n+The `'a` is called a *lifetime*. Most lifetimes are used in places where\n short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n have more descriptive names. Let's dig into the syntax in a bit more detail:\n \n@@ -362,7 +362,7 @@ name is the first step towards being able to talk about it.\n \n ## 'static\n \n-The lifetime named 'static' is a special lifetime. It signals that something\n+The lifetime named *static* is a special lifetime. It signals that something\n has the lifetime of the entire program. Most Rust programmers first come across\n `'static` when dealing with strings:\n \n@@ -456,14 +456,14 @@ thread-safe counterpart of `Rc<T>`.\n \n ## Lifetime Elision\n \n-Earlier, we mentioned 'lifetime elision,' a feature of Rust which allows you to\n+Earlier, we mentioned *lifetime elision*, a feature of Rust which allows you to\n not write lifetime annotations in certain circumstances. All references have a\n lifetime, and so if you elide a lifetime (like `&T` instead of `&'a T`), Rust\n will do three things to determine what those lifetimes should be.\n \n-When talking about lifetime elision, we use the term 'input lifetime' and\n-'output lifetime'. An 'input lifetime' is a lifetime associated with a parameter\n-of a function, and an 'output lifetime' is a lifetime associated with the return\n+When talking about lifetime elision, we use the term *input lifetime* and\n+*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n+of a function, and an *output lifetime* is a lifetime associated with the return\n value of a function. For example, this function has an input lifetime:\n \n ```{rust,ignore}"}, {"sha": "c54d502b4edde4401383823910f71a129e688afa", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -5,7 +5,7 @@ then with `match` statements. Let's go on a whirlwind tour of all of the things\n patterns can do!\n \n A quick refresher: you can match against literals directly, and `_` acts as an\n-'any' case:\n+*any* case:\n \n ```{rust}\n let x = 1i;\n@@ -72,7 +72,7 @@ match x {\n }\n ```\n \n-You can introduce **match guards** with `if`:\n+You can introduce *match guards* with `if`:\n \n ```{rust}\n enum OptionalInt {"}, {"sha": "2fc361ca1b2841eaae1809c65d7aec3392ba9e49", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -29,7 +29,7 @@ information.\n `rustc` can load compiler plugins, which are user-provided libraries that\n extend the compiler's behavior with new syntax extensions, lint checks, etc.\n \n-A plugin is a dynamic library crate with a designated \"registrar\" function that\n+A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can use these extensions by\n loading the plugin crate with `#[plugin] extern crate`. See the\n [`rustc::plugin`](../rustc/plugin/index.html) documentation for more about the"}, {"sha": "63c16ef191e06787cda71640225ed97c20bc4336", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -23,7 +23,7 @@ languages, so it's important to understand them.\n \n When you create a new variable binding, you're giving a name to a value that's\n stored at a particular location on the stack. (If you're not familiar with the\n-\"heap\" vs. \"stack\", please check out [this Stack Overflow\n+*heap* vs. *stack*, please check out [this Stack Overflow\n question](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap),\n as the rest of this guide assumes you know the difference.) Like this:\n \n@@ -43,7 +43,7 @@ refer to `x`, we get the corresponding value. Hence, `x` is `5`.\n \n Let's introduce a pointer. In some languages, there is just one type of\n 'pointer,' but in Rust, we have many types. In this case, we'll use a Rust\n-**reference**, which is the simplest kind of pointer.\n+*reference*, which is the simplest kind of pointer.\n \n ```{rust}\n let x = 5i;\n@@ -90,7 +90,7 @@ hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n ```\n \n-We can **dereference** the pointer by using the `*` operator. Dereferencing a\n+We can *dereference* the pointer by using the `*` operator. Dereferencing a\n pointer means accessing the value at the location stored in the pointer. This\n will work:\n \n@@ -105,8 +105,8 @@ println!(\"{}\", x + *z);\n It prints `13`.\n \n That's it! That's all pointers are: they point to some memory location. Not\n-much else to them. Now that we've discussed the 'what' of pointers, let's\n-talk about the 'why.'\n+much else to them. Now that we've discussed the *what* of pointers, let's\n+talk about the *why*.\n \n ## Pointer uses\n \n@@ -168,7 +168,7 @@ Even in a language which is pass by value, `i` will be `5` at the comment. You\n see, because the argument `x` is a pointer, we do send a copy over to `foo`,\n but because it points at a memory location, which we then assign to, the\n original value is still changed. This pattern is called\n-'pass-reference-by-value.' Tricky!\n+*pass-reference-by-value*. Tricky!\n \n ## Common pointer problems\n \n@@ -209,7 +209,7 @@ as `make_pointer` returns. But we return a pointer to its memory location, and\n so back in `main`, we try to use that pointer, and it's a very similar\n situation to our first one. Setting invalid memory locations is bad.\n \n-As one last example of a big problem with pointers, **aliasing** can be an\n+As one last example of a big problem with pointers, *aliasing* can be an\n issue. Two pointers are said to alias when they point at the same location\n in memory. Like this:\n \n@@ -248,7 +248,7 @@ it's worth it to not have the problems that simple pointers have.\n \n # References\n \n-The most basic type of pointer that Rust has is called a 'reference.' Rust\n+The most basic type of pointer that Rust has is called a *reference*. Rust\n references look like this:\n \n ```{rust}\n@@ -340,8 +340,8 @@ let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time\n Despite their complete safety, a reference's representation at runtime is the\n same as that of an ordinary pointer in a C program. They introduce zero\n overhead. The compiler does all safety checks at compile time. The theory that\n-allows for this was originally called **region pointers**. Region pointers\n-evolved into what we know today as **lifetimes**.\n+allows for this was originally called *region pointers*. Region pointers\n+evolved into what we know today as *lifetimes*.\n \n Here's the simple explanation: would you expect this code to compile?\n \n@@ -355,7 +355,7 @@ fn main() {\n Probably not. That's because you know that the name `x` is valid from where\n it's declared to when it goes out of scope. In this case, that's the end of\n the `main` function. So you know this code will cause an error. We call this\n-duration a 'lifetime'. Let's try a more complex example:\n+duration a *lifetime*. Let's try a more complex example:\n \n ```{rust}\n fn main() {\n@@ -474,7 +474,7 @@ those contents.\n \n # Boxes\n \n-`Box<T>` is Rust's 'boxed pointer' type. Boxes provide the simplest form of\n+`Box<T>` is Rust's *boxed pointer* type. Boxes provide the simplest form of\n heap allocation in Rust. Creating a box looks like this:\n \n ```{rust}\n@@ -496,10 +496,10 @@ they go out of scope:\n ```\n \n However, boxes do _not_ use reference counting or garbage collection. Boxes are\n-what's called an **affine type**. This means that the Rust compiler, at compile\n+what's called an *affine type*. This means that the Rust compiler, at compile\n time, determines when the box comes into and goes out of scope, and inserts the\n appropriate calls there. Furthermore, boxes are a specific kind of affine type,\n-known as a **region**. You can read more about regions [in this paper on the\n+known as a *region*. You can read more about regions [in this paper on the\n Cyclone programming\n language](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf).\n \n@@ -560,7 +560,7 @@ fn main() {\n }\n ```\n \n-In this case, Rust knows that `x` is being 'borrowed' by the `add_one()`\n+In this case, Rust knows that `x` is being *borrowed* by the `add_one()`\n function, and since it's only reading the value, allows it.\n \n We can borrow `x` multiple times, as long as it's not simultaneous:\n@@ -606,7 +606,7 @@ and occasionally, when returning data.\n ### Recursive data structures\n \n Sometimes, you need a recursive data structure. The simplest is known as a\n-'cons list':\n+*cons list*:\n \n \n ```{rust}"}, {"sha": "c4d171bb3a9007e82919abec03c44e4da4b9c4ac", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -103,7 +103,7 @@ line of input, though it might also fail to do so. This could happen if our prog\n isn't running in a terminal, but as part of a cron job, or some other context\n where there's no standard input. Because of this, `read_line` returns a type\n very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n-`IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n+`IoResult<T>` yet because it is the *generic* form of our `OptionalInt`.\n Until then, you can think of it as being the same thing, just for any type \u2013\n not just `i32`s.\n "}, {"sha": "51f9356bd2f9e44edb0183fa48701b4d21a15181", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -6,14 +6,14 @@ focus. Any time you have a data structure of variable size, things can get\n tricky, and strings are a re-sizable data structure. That being said, Rust's\n strings also work differently than in some other systems languages, such as C.\n \n-Let's dig into the details. A **string** is a sequence of Unicode scalar values\n+Let's dig into the details. A *string* is a sequence of Unicode scalar values\n encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n validly encoded UTF-8 sequences. Additionally, strings are not null-terminated\n and can contain null bytes.\n \n Rust has two main types of strings: `&str` and `String`.\n \n-The first kind is a `&str`. This is pronounced a 'string slice.' String literals\n+The first kind is a `&str`. These are called *string slices*. String literals\n are of the type `&str`:\n \n ```{rust}"}, {"sha": "4c6a7f1323fb1c492873404fbfca66675b57f117", "filename": "src/doc/trpl/tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ftasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ftasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftasks.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -73,8 +73,8 @@ with it. For this, we use *channels*. A channel is simply a pair of endpoints:\n one for sending messages and another for receiving messages.\n \n The simplest way to create a channel is to use the `channel` function to create a\n-`(Sender, Receiver)` pair. In Rust parlance, a **sender** is a sending endpoint\n-of a channel, and a **receiver** is the receiving endpoint. Consider the following\n+`(Sender, Receiver)` pair. In Rust parlance, a *sender* is a sending endpoint\n+of a channel, and a *receiver* is the receiving endpoint. Consider the following\n example of calculating two results concurrently:\n \n ```{rust,ignore}"}, {"sha": "791a90bdf9b8207c438e426f3783ae21e5390ab4", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -294,9 +294,9 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n \n It works!\n \n-The current convention is to use the `test` module to hold your \"unit\"-style\n+The current convention is to use the `test` module to hold your \"unit-style\"\n tests. Anything that just tests one small bit of functionality makes sense to\n-go here. But what about \"integration\"-style tests instead? For that, we have\n+go here. But what about \"integration-style\" tests instead? For that, we have\n the `tests` directory\n \n # The `tests` directory"}, {"sha": "acbcb0b5dd9752bf9197ec386aa1ea846457df01", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -65,7 +65,7 @@ error: type `T` does not implement any method in scope named `area`\n ```\n \n Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a **trait constraint** to our generic `T`, ensuring\n+method. But we can add a *trait constraint* to our generic `T`, ensuring\n that it does:\n \n ```{rust}\n@@ -269,7 +269,7 @@ if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n not, because both the trait and the type aren't in our crate.\n \n One last thing about traits: generic functions with a trait bound use\n-**monomorphization** (\"mono\": one, \"morph\": form), so they are statically\n+*monomorphization* (*mono*: one, *morph*: form), so they are statically\n dispatched. What's that mean? Well, let's take a look at `print_area` again:\n \n ```{rust,ignore}\n@@ -313,5 +313,5 @@ fn main() {\n \n The names don't actually change to this, it's just for illustration. But\n as you can see, there's no overhead of deciding which version to call here,\n-hence 'statically dispatched.' The downside is that we have two copies of\n+hence *statically dispatched*. The downside is that we have two copies of\n the same function, so our binary is a little bit larger."}, {"sha": "38427875a6230562663777cfcd690b6a481f6e0a", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -78,7 +78,7 @@ let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n \n ## Raw pointers\n \n-Rust offers two additional pointer types \"raw pointers\", written as\n+Rust offers two additional pointer types (*raw pointers*), written as\n `*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n respectively; indeed, one of their most common uses is for FFI,\n interfacing with external C libraries.\n@@ -418,11 +418,12 @@ specify some extra info about the inline assembly:\n \n Current valid options are:\n \n-1. **volatile** - specifying this is analogous to `__asm__ __volatile__ (...)` in gcc/clang.\n-2. **alignstack** - certain instructions expect the stack to be\n+1. *volatile* - specifying this is analogous to\n+   `__asm__ __volatile__ (...)` in gcc/clang.\n+2. *alignstack* - certain instructions expect the stack to be\n    aligned a certain way (i.e SSE) and specifying this indicates to\n    the compiler to insert its usual stack alignment code\n-3. **intel** - use intel syntax instead of the default AT&T.\n+3. *intel* - use intel syntax instead of the default AT&T.\n \n # Avoiding the standard library\n "}, {"sha": "aa99caa731fe3a755bd75b4c84f2c64cef0c79df", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=9205d74fe0eed9ed1fee4d408e4bc99b7c4e0d58", "patch": "@@ -1,6 +1,6 @@\n % Variable bindings\n \n-The first thing we'll learn about are 'variable bindings.' They look like this:\n+The first thing we'll learn about are *variable bindings*. They look like this:\n \n ```{rust}\n fn main() {\n@@ -12,9 +12,9 @@ Putting `fn main() {` in each example is a bit tedious, so we'll leave that out\n in the future. If you're following along, make sure to edit your `main()`\n function, rather than leaving it off. Otherwise, you'll get an error.\n \n-In many languages, this is called a 'variable.' But Rust's variable bindings\n+In many languages, this is called a *variable*. But Rust's variable bindings\n have a few tricks up their sleeves. Rust has a very powerful feature called\n-'pattern matching' that we'll get into detail with later, but the left\n+*pattern matching* that we'll get into detail with later, but the left\n hand side of a `let` expression is a full pattern, not just a variable name.\n This means we can do things like:\n \n@@ -28,7 +28,7 @@ So let's just keep this in the back of our minds as we go forward.\n \n Rust is a statically typed language, which means that we specify our types up\n front. So why does our first example compile? Well, Rust has this thing called\n-\"type inference.\" If it can figure out what the type of something is, Rust\n+*type inference*. If it can figure out what the type of something is, Rust\n doesn't require you to actually type it out.\n \n We can add the type if we want to, though. Types come after a colon (`:`):\n@@ -53,7 +53,7 @@ Note the similarities between this annotation and the syntax you use with `let`.\n Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n include them to help you understand what the types that Rust infers are.\n \n-By default, bindings are **immutable**. This code will not compile:\n+By default, bindings are *immutable*. This code will not compile:\n \n ```{ignore}\n let x = 5;\n@@ -162,7 +162,7 @@ talk about this stuff we've added to `println!`.\n \n If you include two curly braces (`{}`, some call them moustaches...) in your\n string to print, Rust will interpret this as a request to interpolate some sort\n-of value. **String interpolation** is a computer science term that means \"stick\n+of value. *String interpolation* is a computer science term that means \"stick\n in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n want `x` to be the value we're interpolating. The comma is used to separate\n arguments we pass to functions and macros, if you're passing more than one."}]}