{"sha": "18f75a9197a5b535f9804901bfefbaffe373d689", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Zjc1YTkxOTdhNWI1MzVmOTgwNDkwMWJmZWZiYWZmZTM3M2Q2ODk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-24T01:13:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:47Z"}, "message": "std: Add comments to the time module", "tree": {"sha": "e7a5381e89e606deac905a974c1335ac6e8ac730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7a5381e89e606deac905a974c1335ac6e8ac730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f75a9197a5b535f9804901bfefbaffe373d689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f75a9197a5b535f9804901bfefbaffe373d689", "html_url": "https://github.com/rust-lang/rust/commit/18f75a9197a5b535f9804901bfefbaffe373d689", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f75a9197a5b535f9804901bfefbaffe373d689/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "html_url": "https://github.com/rust-lang/rust/commit/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac"}], "stats": {"total": 17, "additions": 16, "deletions": 1}, "files": [{"sha": "6e347711c1c07dc3e066ae4714c6f9a8c968ef1e", "filename": "src/libstd/time.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18f75a9197a5b535f9804901bfefbaffe373d689/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f75a9197a5b535f9804901bfefbaffe373d689/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=18f75a9197a5b535f9804901bfefbaffe373d689", "patch": "@@ -29,7 +29,10 @@ macro_rules! earlyexit(\n     ($e:expr) => (match $e { Some(v) => v, None => return None })\n )\n \n-/// ISO 8601 duration\n+/// The representation of a span of time.\n+///\n+/// This type has nanosecond precision, and conforms to the ISO 8601\n+/// standard for Date interchange.\n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n pub struct Duration {\n     days: i32,\n@@ -38,6 +41,7 @@ pub struct Duration {\n }\n \n impl Duration {\n+    /// Create a new `Duration`.\n     pub fn new(days: i32, secs: i32, nanos: i32) -> Option<Duration> {\n         let (secs_, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n         let secs = earlyexit!(secs.checked_add(&secs_));\n@@ -46,67 +50,78 @@ impl Duration {\n         Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n     }\n \n+    /// Create a new `Duration` from an integer number of weeks.\n     #[inline]\n     pub fn weeks(weeks: i32) -> Duration {\n         Duration::days(weeks * 7)\n     }\n \n+    /// Create a new `Duration` from an integer number of days.\n     #[inline]\n     pub fn days(days: i32) -> Duration {\n         let days = days.to_i32().expect(\"Duration::days out of bounds\");\n         Duration { days: days, secs: 0, nanos: 0 }\n     }\n \n+    /// Create a new `Duration` from an integer number of hours.\n     #[inline]\n     pub fn hours(hours: i32) -> Duration {\n         let (days, hours) = div_mod_floor(hours, (SECS_PER_DAY / 3600));\n         let secs = hours * 3600;\n         Duration { secs: secs as u32, ..Duration::days(days) }\n     }\n \n+    /// Create a new `Duration` from an integer number of minutes.\n     #[inline]\n     pub fn minutes(mins: i32) -> Duration {\n         let (days, mins) = div_mod_floor(mins, (SECS_PER_DAY / 60));\n         let secs = mins * 60;\n         Duration { secs: secs as u32, ..Duration::days(days) }\n     }\n \n+    /// Create a new `Duration` from an integer number of seconds.\n     #[inline]\n     pub fn seconds(secs: i32) -> Duration {\n         let (days, secs) = div_mod_floor(secs, SECS_PER_DAY);\n         Duration { secs: secs as u32, ..Duration::days(days) }\n     }\n \n+    /// Create a new `Duration` from an integer number of milliseconds.\n     #[inline]\n     pub fn milliseconds(millis: i32) -> Duration {\n         let (secs, millis) = div_mod_floor(millis, (NANOS_PER_SEC / 1_000_000));\n         let nanos = millis * 1_000_000;\n         Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n     }\n \n+    /// Create a new `Duration` from an integer number of microseconds.\n     #[inline]\n     pub fn microseconds(micros: i32) -> Duration {\n         let (secs, micros) = div_mod_floor(micros, (NANOS_PER_SEC / 1_000));\n         let nanos = micros * 1_000;\n         Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n     }\n \n+    /// Create a new `Duration` from an integer number of nanoseconds.\n     #[inline]\n     pub fn nanoseconds(nanos: i32) -> Duration {\n         let (secs, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n         Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n     }\n \n+    /// Return the number of whole days in the `Duration`.\n     #[inline]\n     pub fn ndays(&self) -> i32 {\n         self.days as i32\n     }\n \n+    /// Return the fractional number of days in the `Duration` as seconds.\n     #[inline]\n     pub fn nseconds(&self) -> u32 {\n         self.secs as u32\n     }\n \n+    /// Return the fractional number of seconds in the `Duration` as nanoseconds.\n     #[inline]\n     pub fn nnanoseconds(&self) -> u32 {\n         self.nanos as u32"}]}