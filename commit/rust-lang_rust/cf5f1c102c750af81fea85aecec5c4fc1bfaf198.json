{"sha": "cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNWYxYzEwMmM3NTBhZjgxZmVhODVhZWNlYzVjNGZjMWJmYWYxOTg=", "commit": {"author": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-23T07:30:10Z"}, "committer": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-23T07:44:23Z"}, "message": "add static method generation assist", "tree": {"sha": "c9c59272d702d15deb3086157b65a86707c35847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9c59272d702d15deb3086157b65a86707c35847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "html_url": "https://github.com/rust-lang/rust/commit/cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf5f1c102c750af81fea85aecec5c4fc1bfaf198/comments", "author": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "996300f4a061e895a339a909fddce94f68ce7d19", "url": "https://api.github.com/repos/rust-lang/rust/commits/996300f4a061e895a339a909fddce94f68ce7d19", "html_url": "https://github.com/rust-lang/rust/commit/996300f4a061e895a339a909fddce94f68ce7d19"}], "stats": {"total": 163, "additions": 146, "deletions": 17}, "files": [{"sha": "ad98aa16d85e19b93f2ab035510af7105f48d834", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 146, "deletions": 17, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/cf5f1c102c750af81fea85aecec5c4fc1bfaf198/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5f1c102c750af81fea85aecec5c4fc1bfaf198/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "patch": "@@ -70,26 +70,56 @@ impl FuncExpr {\n fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n-\n     let path = path_expr.path()?;\n+    let fn_name = fn_name(&path)?;\n     if ctx.sema.resolve_path(&path).is_some() {\n         // The function call already resolves, no need to add a function\n         return None;\n     }\n \n-    let target_module = match path.qualifier() {\n+    let target_module;\n+    let mut adt_name = None;\n+\n+    let (target, file, insert_offset) = match path.qualifier() {\n         Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n-            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => Some(module),\n-            _ => return None,\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => {\n+                target_module = Some(module);\n+                get_fn_target(ctx, &target_module, call.clone())?\n+            }\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n+                let current_module = current_module(call.syntax(), ctx)?;\n+                let module = adt.module(ctx.sema.db);\n+                target_module = if current_module == module { None } else { Some(module) };\n+                if current_module.krate() != module.krate() {\n+                    return None;\n+                }\n+                let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n+                let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n+                adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n+                (target, file, insert_offset)\n+            }\n+            _ => {\n+                return None;\n+            }\n         },\n-        None => None,\n+        _ => {\n+            target_module = None;\n+            get_fn_target(ctx, &target_module, call.clone())?\n+        }\n     };\n-\n-    let (target, file, insert_offset) = get_fn_target(ctx, &target_module, call.clone())?;\n     let function_builder = FunctionBuilder::from_call(ctx, &call, &path, target_module, target)?;\n-    let target = call.syntax().text_range();\n+    let text_range = call.syntax().text_range();\n     let label = format!(\"Generate {} function\", function_builder.fn_name.clone());\n-    add_func_to_accumulator(acc, ctx, target, function_builder, insert_offset, file, None, label)\n+    add_func_to_accumulator(\n+        acc,\n+        ctx,\n+        text_range,\n+        function_builder,\n+        insert_offset,\n+        file,\n+        adt_name,\n+        label,\n+    )\n }\n \n fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -103,13 +133,7 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if current_module.krate() != target_module.krate() {\n         return None;\n     }\n-\n-    let range = adt.source(ctx.sema.db)?.syntax().original_file_range(ctx.sema.db);\n-    let file = ctx.sema.parse(range.file_id);\n-    let adt_source =\n-        ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n-    let impl_ = find_struct_impl(ctx, &adt_source, fn_name.text().as_str())?;\n-\n+    let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n     let (target, insert_offset) = get_method_target(ctx, &target_module, &impl_)?;\n     let function_builder =\n         FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n@@ -122,7 +146,7 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         text_range,\n         function_builder,\n         insert_offset,\n-        range.file_id,\n+        file,\n         adt_name,\n         label,\n     )\n@@ -156,6 +180,18 @@ fn current_module(current_node: &SyntaxNode, ctx: &AssistContext) -> Option<Modu\n     ctx.sema.scope(current_node).module()\n }\n \n+fn get_adt_source(\n+    ctx: &AssistContext,\n+    adt: &hir::Adt,\n+    fn_name: &str,\n+) -> Option<(Option<ast::Impl>, FileId)> {\n+    let range = adt.source(ctx.sema.db)?.syntax().original_file_range(ctx.sema.db);\n+    let file = ctx.sema.parse(range.file_id);\n+    let adt_source =\n+        ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n+    find_struct_impl(ctx, &adt_source, fn_name).map(|impl_| (impl_, range.file_id))\n+}\n+\n struct FunctionTemplate {\n     leading_ws: String,\n     fn_def: ast::Fn,\n@@ -1514,6 +1550,99 @@ fn bar(&self) ${0:-> ()} {\n     todo!()\n }\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {S::bar$0();}\n+\",\n+            r\"\n+struct S;\n+fn foo() {S::bar();}\n+impl S {\n+\n+\n+fn bar() ${0:-> ()} {\n+    todo!()\n+}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method_within_an_impl() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {S::bar$0();}\n+impl S {}\n+\n+\",\n+            r\"\n+struct S;\n+fn foo() {S::bar();}\n+impl S {\n+    fn bar() ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method_from_different_module() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+mod s {\n+    pub struct S;\n+}\n+fn foo() {s::S::bar$0();}\n+\",\n+            r\"\n+mod s {\n+    pub struct S;\n+impl S {\n+\n+\n+    pub(crate) fn bar() ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+}\n+fn foo() {s::S::bar();}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method_with_cursor_anywhere_on_call_expresion() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {$0S::bar();}\n+\",\n+            r\"\n+struct S;\n+fn foo() {S::bar();}\n+impl S {\n+\n+\n+fn bar() ${0:-> ()} {\n+    todo!()\n+}\n+}\n \",\n         )\n     }"}]}