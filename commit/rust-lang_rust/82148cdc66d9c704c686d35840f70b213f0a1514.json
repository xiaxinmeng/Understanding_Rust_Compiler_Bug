{"sha": "82148cdc66d9c704c686d35840f70b213f0a1514", "node_id": "C_kwDOAAsO6NoAKDgyMTQ4Y2RjNjZkOWM3MDRjNjg2ZDM1ODQwZjcwYjIxM2YwYTE1MTQ", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-10-16T06:29:59Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-10-16T23:04:39Z"}, "message": "Change outlives clause checking algorithm", "tree": {"sha": "c7512e4689b26d4706aa6acac97916ecf281c4d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7512e4689b26d4706aa6acac97916ecf281c4d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82148cdc66d9c704c686d35840f70b213f0a1514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82148cdc66d9c704c686d35840f70b213f0a1514", "html_url": "https://github.com/rust-lang/rust/commit/82148cdc66d9c704c686d35840f70b213f0a1514", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82148cdc66d9c704c686d35840f70b213f0a1514/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "html_url": "https://github.com/rust-lang/rust/commit/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1"}], "stats": {"total": 243, "additions": 137, "deletions": 106}, "files": [{"sha": "ad716c76c80aa3ef21f87b0ec5300b0cca3fb491", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82148cdc66d9c704c686d35840f70b213f0a1514/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82148cdc66d9c704c686d35840f70b213f0a1514/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=82148cdc66d9c704c686d35840f70b213f0a1514", "patch": "@@ -1255,16 +1255,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tainted_by_errors_flag.set(true)\n     }\n \n-    /// Process the region constraints and report any errors that\n+    /// Process the region constraints and return any any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(\n+    pub fn resolve_regions(\n         &self,\n         region_context: DefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n-    ) {\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n         let (var_infos, data) = {\n             let mut inner = self.inner.borrow_mut();\n             let inner = &mut *inner;\n@@ -1290,6 +1290,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n \n+        errors\n+    }\n+\n+    /// Process the region constraints and report any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        region_context: DefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+        mode: RegionckMode,\n+    ) {\n+        let errors = self.resolve_regions(region_context, outlives_env, mode);\n+\n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while"}, {"sha": "4ed149e1fe792782f8e2bc23b589dc08dcfcdcdb", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82148cdc66d9c704c686d35840f70b213f0a1514/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82148cdc66d9c704c686d35840f70b213f0a1514/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=82148cdc66d9c704c686d35840f70b213f0a1514", "patch": "@@ -104,7 +104,7 @@ macro_rules! ignore_err {\n     };\n }\n \n-trait OutlivesEnvironmentExt<'tcx> {\n+pub(crate) trait OutlivesEnvironmentExt<'tcx> {\n     fn add_implied_bounds(\n         &mut self,\n         infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "dc9784594c21ba7544ba3538fb93028cfa96a0ce", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 110, "deletions": 80, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/82148cdc66d9c704c686d35840f70b213f0a1514/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82148cdc66d9c704c686d35840f70b213f0a1514/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=82148cdc66d9c704c686d35840f70b213f0a1514", "patch": "@@ -1,7 +1,7 @@\n+use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n-use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -12,7 +12,10 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -22,7 +25,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n@@ -279,84 +282,104 @@ fn check_gat_where_clauses(\n         return;\n     }\n     let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n+    let mut clauses = FxHashSet::default();\n     // For every function in this trait...\n     for item in\n         associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n     {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let sig: ty::Binder<'_, ty::FnSig<'_>> = tcx.fn_sig(item.def_id);\n-            let sig = infcx.replace_bound_vars_with_placeholders(sig);\n-            // Find out what regions are passed as GAT substs\n-            let mut visitor = GATSubstCollector {\n-                tcx,\n-                gat: trait_item.def_id.to_def_id(),\n-                regions: FxHashSet::default(),\n-                _types: FxHashSet::default(),\n-            };\n-            sig.output().visit_with(&mut visitor);\n-            // If there are none, then it nothing to do\n-            if visitor.regions.is_empty() {\n-                return;\n-            }\n-            let mut clauses = FxHashSet::default();\n-            // Otherwise, find the clauses required from implied bounds\n-            for input in sig.inputs() {\n-                // For a given input type, find the implied bounds\n-                let TypeOpOutput { output: bounds, .. } = match ty::ParamEnv::empty()\n-                    .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty: input })\n-                    .fully_perform(&infcx)\n-                {\n-                    Ok(o) => o,\n-                    Err(_) => continue,\n-                };\n-                debug!(?bounds);\n-                for bound in bounds {\n-                    match bound {\n-                        traits::query::OutlivesBound::RegionSubParam(r, p) => {\n-                            // If the implied bound is a `RegionSubParam` and\n-                            // the region is used a GAT subst...\n-                            for idx in visitor\n-                                .regions\n-                                .iter()\n-                                .filter(|(proj_r, _)| proj_r == &r)\n-                                .map(|r| r.1)\n-                            {\n-                                // Then create a clause that is required on the GAT\n-                                let param_r = tcx.mk_region(ty::RegionKind::ReEarlyBound(\n-                                    ty::EarlyBoundRegion {\n-                                        def_id: generics.params[idx].def_id,\n-                                        index: idx as u32,\n-                                        name: generics.params[idx].name,\n-                                    },\n-                                ));\n-                                let clause = ty::PredicateKind::TypeOutlives(\n-                                    ty::OutlivesPredicate(tcx.mk_ty(ty::Param(p)), param_r),\n-                                );\n-                                let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                                clauses.insert(clause);\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            // If there are any missing clauses, emit an error\n-            debug!(?clauses);\n-            if !clauses.is_empty() {\n-                let written_predicates: ty::GenericPredicates<'_> =\n-                    tcx.predicates_of(trait_item.def_id);\n-                for clause in clauses {\n-                    let found =\n-                        written_predicates.predicates.iter().find(|p| p.0 == clause).is_some();\n-                    debug!(?clause, ?found);\n-                    let mut error = tcx.sess.struct_span_err(\n-                        trait_item.generics.span,\n-                        &format!(\"Missing bound: {}\", clause),\n+        let id = hir::HirId::make_owner(item.def_id.expect_local());\n+        let span = DUMMY_SP;\n+        let param_env = tcx.param_env(item.def_id.expect_local());\n+\n+        let sig = tcx.fn_sig(item.def_id);\n+        let sig = tcx.liberate_late_bound_regions(item.def_id, sig);\n+        let mut visitor = GATSubstCollector {\n+            tcx,\n+            gat: trait_item.def_id.to_def_id(),\n+            regions: FxHashSet::default(),\n+            types: FxHashSet::default(),\n+        };\n+        sig.output().visit_with(&mut visitor);\n+        let mut wf_tys = FxHashSet::default();\n+        wf_tys.extend(sig.inputs());\n+        // FIXME: normalize and add normalized inputs?\n+\n+        for (region, region_idx) in &visitor.regions {\n+            for (ty, ty_idx) in &visitor.types {\n+                tcx.infer_ctxt().enter(|infcx| {\n+                    let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+                    outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, span);\n+                    outlives_environment.save_implied_bounds(id);\n+                    let region_bound_pairs =\n+                        outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n+\n+                    let cause =\n+                        ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n+\n+                    let sup_type = *ty;\n+                    let sub_region = region;\n+\n+                    let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n+                        infer::RelateParamBound(cause.span, sup_type, None)\n+                    });\n+\n+                    let outlives = &mut TypeOutlives::new(\n+                        &infcx,\n+                        tcx,\n+                        &region_bound_pairs,\n+                        Some(tcx.lifetimes.re_root_empty),\n+                        param_env,\n                     );\n-                    error.emit();\n-                }\n+                    outlives.type_must_outlive(origin, sup_type, sub_region);\n+\n+                    let errors = infcx.resolve_regions(\n+                        trait_item.def_id.to_def_id(),\n+                        &outlives_environment,\n+                        RegionckMode::default(),\n+                    );\n+\n+                    debug!(?errors, \"errors\");\n+\n+                    if errors.is_empty() {\n+                        debug!(?ty_idx, ?region_idx);\n+                        debug!(\"required clause: {} must outlive {}\", ty, region);\n+                        let ty_param = generics.param_at(*ty_idx, tcx);\n+                        let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n+                            index: ty_param.index,\n+                            name: ty_param.name,\n+                        }));\n+                        let region_param = generics.param_at(*region_idx, tcx);\n+                        // Then create a clause that is required on the GAT\n+                        let region_param =\n+                            tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                                def_id: region_param.def_id,\n+                                index: region_param.index,\n+                                name: region_param.name,\n+                            }));\n+                        let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                            ty_param,\n+                            region_param,\n+                        ));\n+                        let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                        clauses.insert(clause);\n+                    }\n+                });\n             }\n-        })\n+        }\n+    }\n+\n+    // If there are any missing clauses, emit an error\n+    debug!(?clauses);\n+    if !clauses.is_empty() {\n+        let written_predicates: ty::GenericPredicates<'_> = tcx.predicates_of(trait_item.def_id);\n+        for clause in clauses {\n+            let found = written_predicates.predicates.iter().find(|p| p.0 == clause).is_some();\n+            debug!(?clause, ?found);\n+            let mut error = tcx\n+                .sess\n+                .struct_span_err(trait_item.generics.span, &format!(\"Missing bound: {}\", clause));\n+            error.emit();\n+        }\n     }\n }\n \n@@ -366,7 +389,7 @@ struct GATSubstCollector<'tcx> {\n     // Which region appears and which parameter index its subsituted for\n     regions: FxHashSet<(ty::Region<'tcx>, usize)>,\n     // Which params appears and which parameter index its subsituted for\n-    _types: FxHashSet<(Ty<'tcx>, usize)>,\n+    types: FxHashSet<(Ty<'tcx>, usize)>,\n }\n \n impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n@@ -375,13 +398,20 @@ impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Projection(p) if p.item_def_id == self.gat => {\n-                let (_, substs) = p.trait_ref_and_own_substs(self.tcx);\n-                self.regions.extend(substs.iter().enumerate().filter_map(|(idx, subst)| {\n+                for (idx, subst) in p.substs.iter().enumerate() {\n                     match subst.unpack() {\n-                        GenericArgKind::Lifetime(lt) => Some((lt, idx)),\n-                        _ => None,\n+                        GenericArgKind::Lifetime(lt) => {\n+                            self.regions.insert((lt, idx));\n+                        }\n+                        GenericArgKind::Type(t) => match t.kind() {\n+                            ty::Param(_) => {\n+                                self.types.insert((t, idx));\n+                            }\n+                            _ => {}\n+                        },\n+                        _ => {}\n                     }\n-                }));\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "7a1fb51eafa0a3bfbc079d7e343d8ce055a75aba", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82148cdc66d9c704c686d35840f70b213f0a1514/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82148cdc66d9c704c686d35840f70b213f0a1514/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=82148cdc66d9c704c686d35840f70b213f0a1514", "patch": "@@ -45,15 +45,13 @@ trait Deserializer3<T, U> {\n \n trait Deserializer4 {\n     type Out<'x>;\n-    //~^ Missing bound\n     fn deserialize<'a, T>(&self, input: &'a T) -> Self::Out<'a>;\n }\n \n struct Wrap<T>(T);\n \n trait Des {\n     type Out<'x, D>;\n-    //~^ Missing bound\n     fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, Wrap<T>>;\n }\n /*\n@@ -92,5 +90,5 @@ impl Des3 for () {\n     }\n }\n */\n-  \n+\n fn main() {}"}, {"sha": "42af6d25a2380787b0e12245943c03cca9526bf7", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82148cdc66d9c704c686d35840f70b213f0a1514/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82148cdc66d9c704c686d35840f70b213f0a1514/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=82148cdc66d9c704c686d35840f70b213f0a1514", "patch": "@@ -16,41 +16,29 @@ error: Missing bound: T: 'x\n LL |     type Out<'x>;\n    |             ^^^^\n \n-error: Missing bound: T: 'x\n+error: Missing bound: U: 'y\n   --> $DIR/self-outlives-lint.rs:40:13\n    |\n LL |     type Out<'x, 'y>;\n    |             ^^^^^^^^\n \n-error: Missing bound: U: 'y\n+error: Missing bound: T: 'x\n   --> $DIR/self-outlives-lint.rs:40:13\n    |\n LL |     type Out<'x, 'y>;\n    |             ^^^^^^^^\n \n-error: Missing bound: T: 'x\n-  --> $DIR/self-outlives-lint.rs:47:13\n-   |\n-LL |     type Out<'x>;\n-   |             ^^^^\n-\n-error: Missing bound: T: 'x\n-  --> $DIR/self-outlives-lint.rs:55:13\n-   |\n-LL |     type Out<'x, D>;\n-   |             ^^^^^^^\n-\n-error: Missing bound: T: 'x\n-  --> $DIR/self-outlives-lint.rs:69:13\n+error: Missing bound: D: 'x\n+  --> $DIR/self-outlives-lint.rs:67:13\n    |\n LL |     type Out<'x, D>;\n    |             ^^^^^^^\n \n-error: Missing bound: T: 'x\n-  --> $DIR/self-outlives-lint.rs:83:13\n+error: Missing bound: D: 'x\n+  --> $DIR/self-outlives-lint.rs:81:13\n    |\n LL |     type Out<'x, D>;\n    |             ^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 7 previous errors\n "}]}