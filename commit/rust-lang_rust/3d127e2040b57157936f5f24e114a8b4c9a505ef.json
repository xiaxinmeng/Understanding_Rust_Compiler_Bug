{"sha": "3d127e2040b57157936f5f24e114a8b4c9a505ef", "node_id": "C_kwDOAAsO6NoAKDNkMTI3ZTIwNDBiNTcxNTc5MzZmNWYyNGUxMTRhOGI0YzlhNTA1ZWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T12:28:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T12:28:19Z"}, "message": "Auto merge of #94123 - bjorn3:cg_ssa_singleton_builder, r=tmiasko\n\nPartially move cg_ssa towards using a single builder\n\nNot all codegen backends can handle hopping between blocks well. For example Cranelift requires blocks to be terminated before switching to building a new block. Rust-gpu requires a `RefCell` to allow hopping between blocks and cg_gcc currently has a buggy implementation of hopping between blocks. This PR reduces the amount of cases where cg_ssa switches between blocks before they are finished and mostly fixes the block hopping in cg_gcc. (~~only `scalar_to_backend` doesn't handle it correctly yet in cg_gcc~~ fixed that one.)\n\n`@antoyo` please review the cg_gcc changes.", "tree": {"sha": "eda8d0fab2d62b7abbf0fde7d455c9d2bd979093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda8d0fab2d62b7abbf0fde7d455c9d2bd979093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d127e2040b57157936f5f24e114a8b4c9a505ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d127e2040b57157936f5f24e114a8b4c9a505ef", "html_url": "https://github.com/rust-lang/rust/commit/3d127e2040b57157936f5f24e114a8b4c9a505ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d127e2040b57157936f5f24e114a8b4c9a505ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ccfe2ff1d59666dc0188dfd5847304fec257565", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ccfe2ff1d59666dc0188dfd5847304fec257565", "html_url": "https://github.com/rust-lang/rust/commit/7ccfe2ff1d59666dc0188dfd5847304fec257565"}, {"sha": "96cf7999ab64ead0c06384da51eb8586ffebfc1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/96cf7999ab64ead0c06384da51eb8586ffebfc1e", "html_url": "https://github.com/rust-lang/rust/commit/96cf7999ab64ead0c06384da51eb8586ffebfc1e"}], "stats": {"total": 308, "additions": 158, "deletions": 150}, "files": [{"sha": "b430dc329cb9aacc7f79bd1a4a9f4bca4259b1eb", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=3d127e2040b57157936f5f24e114a8b4c9a505ef", "patch": "@@ -390,11 +390,6 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         bx\n     }\n \n-    fn build_sibling_block(&mut self, name: &str) -> Self {\n-        let block = self.append_sibling_block(name);\n-        Self::build(self.cx, block)\n-    }\n-\n     fn llbb(&self) -> Block<'gcc> {\n         self.block.expect(\"block\")\n     }\n@@ -409,6 +404,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         func.new_block(name)\n     }\n \n+    fn switch_to_block(&mut self, block: Self::BasicBlock) {\n+        *self.cx.current_block.borrow_mut() = Some(block);\n+        self.block = Some(block);\n+    }\n+\n     fn ret_void(&mut self) {\n         self.llbb().end_with_void_return(None)\n     }\n@@ -880,28 +880,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let start = dest.project_index(&mut self, zero).llval;\n         let end = dest.project_index(&mut self, count).llval;\n \n-        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n-        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n-        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+        let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n+        let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n+        let next_bb = self.append_sibling_block(\"repeat_loop_next\");\n \n         let ptr_type = start.get_type();\n         let current = self.llbb().get_function().new_local(None, ptr_type, \"loop_var\");\n         let current_val = current.to_rvalue();\n         self.assign(current, start);\n \n-        self.br(header_bx.llbb());\n+        self.br(header_bb);\n \n-        let keep_going = header_bx.icmp(IntPredicate::IntNE, current_val, end);\n-        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+        self.switch_to_block(header_bb);\n+        let keep_going = self.icmp(IntPredicate::IntNE, current_val, end);\n+        self.cond_br(keep_going, body_bb, next_bb);\n \n+        self.switch_to_block(body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n-        cg_elem.val.store(&mut body_bx, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n+        cg_elem.val.store(&mut self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n-        let next = body_bx.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n-        body_bx.llbb().add_assignment(None, current, next);\n-        body_bx.br(header_bx.llbb());\n+        let next = self.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n+        self.llbb().add_assignment(None, current, next);\n+        self.br(header_bb);\n \n-        next_bx\n+        self.switch_to_block(next_bb);\n+        self\n     }\n \n     fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {"}, {"sha": "780af5bc2af8b444f9004dacfa0faedfe393de91", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=3d127e2040b57157936f5f24e114a8b4c9a505ef", "patch": "@@ -166,9 +166,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Self::append_block(self.cx, self.llfn(), name)\n     }\n \n-    fn build_sibling_block(&mut self, name: &str) -> Self {\n-        let llbb = self.append_sibling_block(name);\n-        Self::build(self.cx, llbb)\n+    fn switch_to_block(&mut self, llbb: Self::BasicBlock) {\n+        *self = Self::build(self.cx, llbb)\n     }\n \n     fn ret_void(&mut self) {\n@@ -544,16 +543,19 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let start = dest.project_index(&mut self, zero).llval;\n         let end = dest.project_index(&mut self, count).llval;\n \n-        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n-        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n-        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+        let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n+        let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n+        let next_bb = self.append_sibling_block(\"repeat_loop_next\");\n \n-        self.br(header_bx.llbb());\n+        self.br(header_bb);\n+\n+        let mut header_bx = Self::build(self.cx, header_bb);\n         let current = header_bx.phi(self.val_ty(start), &[start], &[self.llbb()]);\n \n         let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n-        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+        header_bx.cond_br(keep_going, body_bb, next_bb);\n \n+        let mut body_bx = Self::build(self.cx, body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n         cg_elem\n             .val\n@@ -564,10 +566,10 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             current,\n             &[self.const_usize(1)],\n         );\n-        body_bx.br(header_bx.llbb());\n-        header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n+        body_bx.br(header_bb);\n+        header_bx.add_incoming_to_phi(current, next, body_bb);\n \n-        next_bx\n+        Self::build(self.cx, next_bb)\n     }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: WrappingRange) {"}, {"sha": "e7c13e793d92e3150cca00f3d9b8f33243d73989", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=3d127e2040b57157936f5f24e114a8b4c9a505ef", "patch": "@@ -452,11 +452,11 @@ fn codegen_msvc_try<'ll>(\n     let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n \n-        let mut normal = bx.build_sibling_block(\"normal\");\n-        let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n-        let mut catchpad_rust = bx.build_sibling_block(\"catchpad_rust\");\n-        let mut catchpad_foreign = bx.build_sibling_block(\"catchpad_foreign\");\n-        let mut caught = bx.build_sibling_block(\"caught\");\n+        let normal = bx.append_sibling_block(\"normal\");\n+        let catchswitch = bx.append_sibling_block(\"catchswitch\");\n+        let catchpad_rust = bx.append_sibling_block(\"catchpad_rust\");\n+        let catchpad_foreign = bx.append_sibling_block(\"catchpad_foreign\");\n+        let caught = bx.append_sibling_block(\"caught\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n@@ -520,12 +520,13 @@ fn codegen_msvc_try<'ll>(\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n+        bx.invoke(try_func_ty, try_func, &[data], normal, catchswitch, None);\n \n-        normal.ret(bx.const_i32(0));\n+        bx.switch_to_block(normal);\n+        bx.ret(bx.const_i32(0));\n \n-        let cs =\n-            catchswitch.catch_switch(None, None, &[catchpad_rust.llbb(), catchpad_foreign.llbb()]);\n+        bx.switch_to_block(catchswitch);\n+        let cs = bx.catch_switch(None, None, &[catchpad_rust, catchpad_foreign]);\n \n         // We can't use the TypeDescriptor defined in libpanic_unwind because it\n         // might be in another DLL and the SEH encoding only supports specifying\n@@ -558,21 +559,24 @@ fn codegen_msvc_try<'ll>(\n         // since our exception object effectively contains a Box.\n         //\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n+        bx.switch_to_block(catchpad_rust);\n         let flags = bx.const_i32(8);\n-        let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n-        let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n+        let funclet = bx.catch_pad(cs, &[tydesc, flags, slot]);\n+        let ptr = bx.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        catchpad_rust.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n-        catchpad_rust.catch_ret(&funclet, caught.llbb());\n+        bx.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n+        bx.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n+        bx.switch_to_block(catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n-        let funclet = catchpad_foreign.catch_pad(cs, &[null, flags, null]);\n-        catchpad_foreign.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n-        catchpad_foreign.catch_ret(&funclet, caught.llbb());\n+        let funclet = bx.catch_pad(cs, &[null, flags, null]);\n+        bx.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n+        bx.catch_ret(&funclet, caught);\n \n-        caught.ret(bx.const_i32(1));\n+        bx.switch_to_block(caught);\n+        bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -613,30 +617,33 @@ fn codegen_gnu_try<'ll>(\n         //      (%ptr, _) = landingpad\n         //      call %catch_func(%data, %ptr)\n         //      ret 1\n-        let mut then = bx.build_sibling_block(\"then\");\n-        let mut catch = bx.build_sibling_block(\"catch\");\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(bx.const_i32(0));\n+        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n+        bx.switch_to_block(catch);\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n-        let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 1);\n+        let vals = bx.landing_pad(lpad_ty, bx.eh_personality(), 1);\n         let tydesc = bx.const_null(bx.type_i8p());\n-        catch.add_clause(vals, tydesc);\n-        let ptr = catch.extract_value(vals, 0);\n+        bx.add_clause(vals, tydesc);\n+        let ptr = bx.extract_value(vals, 0);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        catch.call(catch_ty, catch_func, &[data, ptr], None);\n-        catch.ret(bx.const_i32(1));\n+        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -674,57 +681,54 @@ fn codegen_emcc_try<'ll>(\n         //      %catch_data[1] = %is_rust_panic\n         //      call %catch_func(%data, %catch_data)\n         //      ret 1\n-        let mut then = bx.build_sibling_block(\"then\");\n-        let mut catch = bx.build_sibling_block(\"catch\");\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(bx.const_i32(0));\n+        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n+        bx.switch_to_block(catch);\n         let tydesc = bx.eh_catch_typeinfo();\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n-        let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 2);\n-        catch.add_clause(vals, tydesc);\n-        catch.add_clause(vals, bx.const_null(bx.type_i8p()));\n-        let ptr = catch.extract_value(vals, 0);\n-        let selector = catch.extract_value(vals, 1);\n+        let vals = bx.landing_pad(lpad_ty, bx.eh_personality(), 2);\n+        bx.add_clause(vals, tydesc);\n+        bx.add_clause(vals, bx.const_null(bx.type_i8p()));\n+        let ptr = bx.extract_value(vals, 0);\n+        let selector = bx.extract_value(vals, 1);\n \n         // Check if the typeid we got is the one for a Rust panic.\n-        let rust_typeid = catch.call_intrinsic(\"llvm.eh.typeid.for\", &[tydesc]);\n-        let is_rust_panic = catch.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n-        let is_rust_panic = catch.zext(is_rust_panic, bx.type_bool());\n+        let rust_typeid = bx.call_intrinsic(\"llvm.eh.typeid.for\", &[tydesc]);\n+        let is_rust_panic = bx.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n+        let is_rust_panic = bx.zext(is_rust_panic, bx.type_bool());\n \n         // We need to pass two values to catch_func (ptr and is_rust_panic), so\n         // create an alloca and pass a pointer to that.\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let i8_align = bx.tcx().data_layout.i8_align.abi;\n         let catch_data_type = bx.type_struct(&[bx.type_i8p(), bx.type_bool()], false);\n-        let catch_data = catch.alloca(catch_data_type, ptr_align);\n-        let catch_data_0 = catch.inbounds_gep(\n-            catch_data_type,\n-            catch_data,\n-            &[bx.const_usize(0), bx.const_usize(0)],\n-        );\n-        catch.store(ptr, catch_data_0, ptr_align);\n-        let catch_data_1 = catch.inbounds_gep(\n-            catch_data_type,\n-            catch_data,\n-            &[bx.const_usize(0), bx.const_usize(1)],\n-        );\n-        catch.store(is_rust_panic, catch_data_1, i8_align);\n-        let catch_data = catch.bitcast(catch_data, bx.type_i8p());\n+        let catch_data = bx.alloca(catch_data_type, ptr_align);\n+        let catch_data_0 =\n+            bx.inbounds_gep(catch_data_type, catch_data, &[bx.const_usize(0), bx.const_usize(0)]);\n+        bx.store(ptr, catch_data_0, ptr_align);\n+        let catch_data_1 =\n+            bx.inbounds_gep(catch_data_type, catch_data, &[bx.const_usize(0), bx.const_usize(1)]);\n+        bx.store(is_rust_panic, catch_data_1, i8_align);\n+        let catch_data = bx.bitcast(catch_data, bx.type_i8p());\n \n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        catch.call(catch_ty, catch_func, &[data, catch_data], None);\n-        catch.ret(bx.const_i32(1));\n+        bx.call(catch_ty, catch_func, &[data, catch_data], None);\n+        bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function"}, {"sha": "ceb3d5a84abf3ecf795eae8b82cacddb8014e6ef", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=3d127e2040b57157936f5f24e114a8b4c9a505ef", "patch": "@@ -102,10 +102,10 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     let va_list_ty = va_list_layout.llvm_type(bx);\n     let layout = bx.cx.layout_of(target_ty);\n \n-    let mut maybe_reg = bx.build_sibling_block(\"va_arg.maybe_reg\");\n-    let mut in_reg = bx.build_sibling_block(\"va_arg.in_reg\");\n-    let mut on_stack = bx.build_sibling_block(\"va_arg.on_stack\");\n-    let mut end = bx.build_sibling_block(\"va_arg.end\");\n+    let maybe_reg = bx.append_sibling_block(\"va_arg.maybe_reg\");\n+    let in_reg = bx.append_sibling_block(\"va_arg.in_reg\");\n+    let on_stack = bx.append_sibling_block(\"va_arg.on_stack\");\n+    let end = bx.append_sibling_block(\"va_arg.end\");\n     let zero = bx.const_i32(0);\n     let offset_align = Align::from_bytes(4).unwrap();\n \n@@ -125,53 +125,53 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     // if the offset >= 0 then the value will be on the stack\n     let mut reg_off_v = bx.load(bx.type_i32(), reg_off, offset_align);\n     let use_stack = bx.icmp(IntPredicate::IntSGE, reg_off_v, zero);\n-    bx.cond_br(use_stack, on_stack.llbb(), maybe_reg.llbb());\n+    bx.cond_br(use_stack, on_stack, maybe_reg);\n \n     // The value at this point might be in a register, but there is a chance that\n     // it could be on the stack so we have to update the offset and then check\n     // the offset again.\n \n+    bx.switch_to_block(maybe_reg);\n     if gr_type && layout.align.abi.bytes() > 8 {\n-        reg_off_v = maybe_reg.add(reg_off_v, bx.const_i32(15));\n-        reg_off_v = maybe_reg.and(reg_off_v, bx.const_i32(-16));\n+        reg_off_v = bx.add(reg_off_v, bx.const_i32(15));\n+        reg_off_v = bx.and(reg_off_v, bx.const_i32(-16));\n     }\n-    let new_reg_off_v = maybe_reg.add(reg_off_v, bx.const_i32(slot_size as i32));\n+    let new_reg_off_v = bx.add(reg_off_v, bx.const_i32(slot_size as i32));\n \n-    maybe_reg.store(new_reg_off_v, reg_off, offset_align);\n+    bx.store(new_reg_off_v, reg_off, offset_align);\n \n     // Check to see if we have overflowed the registers as a result of this.\n     // If we have then we need to use the stack for this value\n-    let use_stack = maybe_reg.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n-    maybe_reg.cond_br(use_stack, on_stack.llbb(), in_reg.llbb());\n+    let use_stack = bx.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n+    bx.cond_br(use_stack, on_stack, in_reg);\n \n+    bx.switch_to_block(in_reg);\n     let top_type = bx.type_i8p();\n-    let top = in_reg.struct_gep(va_list_ty, va_list_addr, reg_top_index);\n-    let top = in_reg.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n+    let top = bx.struct_gep(va_list_ty, va_list_addr, reg_top_index);\n+    let top = bx.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n \n     // reg_value = *(@top + reg_off_v);\n-    let mut reg_addr = in_reg.gep(bx.type_i8(), top, &[reg_off_v]);\n+    let mut reg_addr = bx.gep(bx.type_i8(), top, &[reg_off_v]);\n     if bx.tcx().sess.target.endian == Endian::Big && layout.size.bytes() != slot_size {\n         // On big-endian systems the value is right-aligned in its slot.\n         let offset = bx.const_i32((slot_size - layout.size.bytes()) as i32);\n-        reg_addr = in_reg.gep(bx.type_i8(), reg_addr, &[offset]);\n+        reg_addr = bx.gep(bx.type_i8(), reg_addr, &[offset]);\n     }\n     let reg_type = layout.llvm_type(bx);\n-    let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n-    let reg_value = in_reg.load(reg_type, reg_addr, layout.align.abi);\n-    in_reg.br(end.llbb());\n+    let reg_addr = bx.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n+    let reg_value = bx.load(reg_type, reg_addr, layout.align.abi);\n+    bx.br(end);\n \n     // On Stack block\n+    bx.switch_to_block(on_stack);\n     let stack_value =\n-        emit_ptr_va_arg(&mut on_stack, list, target_ty, false, Align::from_bytes(8).unwrap(), true);\n-    on_stack.br(end.llbb());\n+        emit_ptr_va_arg(bx, list, target_ty, false, Align::from_bytes(8).unwrap(), true);\n+    bx.br(end);\n \n-    let val = end.phi(\n-        layout.immediate_llvm_type(bx),\n-        &[reg_value, stack_value],\n-        &[in_reg.llbb(), on_stack.llbb()],\n-    );\n+    bx.switch_to_block(end);\n+    let val =\n+        bx.phi(layout.immediate_llvm_type(bx), &[reg_value, stack_value], &[in_reg, on_stack]);\n \n-    *bx = end;\n     val\n }\n "}, {"sha": "f6c41af41b4d3293dd0d242b3d77cd3403eea00f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=3d127e2040b57157936f5f24e114a8b4c9a505ef", "patch": "@@ -96,9 +96,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n \n             debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let mut trampoline = fx.new_block(name);\n-            trampoline.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline.llbb()\n+            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+            trampoline\n         } else {\n             lltarget\n         }\n@@ -169,9 +170,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n \n             if let Some((ret_dest, target)) = destination {\n-                let mut ret_bx = fx.build_block(target);\n-                fx.set_debug_loc(&mut ret_bx, self.terminator.source_info);\n-                fx.store_return(&mut ret_bx, ret_dest, &fn_abi.ret, invokeret);\n+                bx.switch_to_block(fx.llbb(target));\n+                fx.set_debug_loc(bx, self.terminator.source_info);\n+                fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n             let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n@@ -452,15 +453,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n-        let panic_block = bx.build_sibling_block(\"panic\");\n+        let panic_block = bx.append_sibling_block(\"panic\");\n         if expected {\n-            bx.cond_br(cond, lltarget, panic_block.llbb());\n+            bx.cond_br(cond, lltarget, panic_block);\n         } else {\n-            bx.cond_br(cond, panic_block.llbb(), lltarget);\n+            bx.cond_br(cond, panic_block, lltarget);\n         }\n \n         // After this point, bx is the block for the call to panic.\n-        bx = panic_block;\n+        bx.switch_to_block(panic_block);\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n@@ -908,22 +909,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             // Test whether the function pointer is associated with the type identifier.\n             let cond = bx.type_test(fn_ptr, typeid_metadata);\n-            let mut bx_pass = bx.build_sibling_block(\"type_test.pass\");\n-            let mut bx_fail = bx.build_sibling_block(\"type_test.fail\");\n-            bx.cond_br(cond, bx_pass.llbb(), bx_fail.llbb());\n+            let bb_pass = bx.append_sibling_block(\"type_test.pass\");\n+            let bb_fail = bx.append_sibling_block(\"type_test.fail\");\n+            bx.cond_br(cond, bb_pass, bb_fail);\n \n+            bx.switch_to_block(bb_pass);\n             helper.do_call(\n                 self,\n-                &mut bx_pass,\n+                &mut bx,\n                 fn_abi,\n                 fn_ptr,\n                 &llargs,\n                 destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                 cleanup,\n             );\n \n-            bx_fail.abort();\n-            bx_fail.unreachable();\n+            bx.switch_to_block(bb_fail);\n+            bx.abort();\n+            bx.unreachable();\n \n             return;\n         }\n@@ -1020,7 +1023,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n-        let mut bx = self.build_block(bb);\n+        let llbb = self.llbb(bb);\n+        let mut bx = Bx::build(self.cx, llbb);\n         let mir = self.mir;\n         let data = &mir[bb];\n \n@@ -1356,16 +1360,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let mut cs_bx = self.new_block(&format!(\"cs_funclet{:?}\", bb));\n-                    let mut cp_bx = self.new_block(&format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bx.llbb();\n+                    let cs_bb =\n+                        Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n+                    let cp_bb =\n+                        Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n+                    ret_llbb = cs_bb;\n \n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bx.llbb()]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n+                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1374,16 +1382,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let mut cleanup_bx = self.new_block(&format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bx.llbb();\n+                    let cleanup_bb =\n+                        Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n+                    ret_llbb = cleanup_bb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let mut bx = self.new_block(\"cleanup\");\n+            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut bx = Bx::build(self.cx, bb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n@@ -1405,18 +1416,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     fn unreachable_block(&mut self) -> Bx::BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let mut bx = self.new_block(\"unreachable\");\n+            let llbb = Bx::append_block(self.cx, self.llfn, \"unreachable\");\n+            let mut bx = Bx::build(self.cx, llbb);\n             bx.unreachable();\n-            self.unreachable_block = Some(bx.llbb());\n-            bx.llbb()\n+            self.unreachable_block = Some(llbb);\n+            llbb\n         })\n     }\n \n     fn double_unwind_guard(&mut self) -> Bx::BasicBlock {\n         self.double_unwind_guard.unwrap_or_else(|| {\n             assert!(!base::wants_msvc_seh(self.cx.sess()));\n \n-            let mut bx = self.new_block(\"abort\");\n+            let llbb = Bx::append_block(self.cx, self.llfn, \"abort\");\n+            let mut bx = Bx::build(self.cx, llbb);\n             self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n \n             let llpersonality = self.cx.eh_personality();\n@@ -1434,20 +1447,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.apply_attrs_to_cleanup_callsite(llret);\n \n             bx.unreachable();\n-            let llbb = bx.llbb();\n \n             self.double_unwind_guard = Some(llbb);\n             llbb\n         })\n     }\n \n-    // FIXME(eddyb) replace with `build_sibling_block`/`append_sibling_block`\n-    // (which requires having a `Bx` already, and not all callers do).\n-    fn new_block(&self, name: &str) -> Bx {\n-        let llbb = Bx::append_block(self.cx, self.llfn, name);\n-        Bx::build(self.cx, llbb)\n-    }\n-\n     /// Get the backend `BasicBlock` for a MIR `BasicBlock`, either already\n     /// cached in `self.cached_llbbs`, or created on demand (and cached).\n     // FIXME(eddyb) rename `llbb` and other `ll`-prefixed things to use a\n@@ -1461,11 +1466,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n-    pub fn build_block(&mut self, bb: mir::BasicBlock) -> Bx {\n-        let llbb = self.llbb(bb);\n-        Bx::build(self.cx, llbb)\n-    }\n-\n     fn make_return_dest(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "1c7fe060ea4fb1300b35e15e68a5ed0d32c25e4e", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d127e2040b57157936f5f24e114a8b4c9a505ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=3d127e2040b57157936f5f24e114a8b4c9a505ef", "patch": "@@ -53,8 +53,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn append_sibling_block(&mut self, name: &str) -> Self::BasicBlock;\n \n-    // FIXME(eddyb) replace with callers using `append_sibling_block`.\n-    fn build_sibling_block(&mut self, name: &str) -> Self;\n+    fn switch_to_block(&mut self, llbb: Self::BasicBlock);\n \n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);"}]}