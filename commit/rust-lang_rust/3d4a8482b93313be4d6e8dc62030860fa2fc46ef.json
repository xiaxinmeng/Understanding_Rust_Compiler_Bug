{"sha": "3d4a8482b93313be4d6e8dc62030860fa2fc46ef", "node_id": "C_kwDOAAsO6NoAKDNkNGE4NDgyYjkzMzEzYmU0ZDZlOGRjNjIwMzA4NjBmYTJmYzQ2ZWY", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-10-30T20:47:04Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-11-14T22:03:16Z"}, "message": "x86_64 SSE2 fast-path for str.contains(&str) and short needles\n\nBased on Wojciech Mu\u0142a's \"SIMD-friendly algorithms for substring searching\"[0]\n\nThe two-way algorithm is Big-O efficient but it needs to preprocess the needle\nto find a \"criticla factorization\" of it. This additional work is significant\nfor short needles. Additionally it mostly advances needle.len() bytes at a time.\n\nThe SIMD-based approach used here on the other hand can advance based on its\nvector width, which can exceed the needle length. Except for pathological cases,\nbut due to being limited to small needles the worst case blowup is also small.\n\nbenchmarks taken on a Zen2:\n\n```\n16CGU, OLD:\ntest str::bench_contains_short_short                     ... bench:          27 ns/iter (+/- 1)\ntest str::bench_contains_short_long                      ... bench:         667 ns/iter (+/- 29)\ntest str::bench_contains_bad_naive                       ... bench:         131 ns/iter (+/- 2)\ntest str::bench_contains_bad_simd                        ... bench:         130 ns/iter (+/- 2)\ntest str::bench_contains_equal                           ... bench:         148 ns/iter (+/- 4)\n\n\n16CGU, NEW:\ntest str::bench_contains_short_short                     ... bench:           8 ns/iter (+/- 0)\ntest str::bench_contains_short_long                      ... bench:         135 ns/iter (+/- 4)\ntest str::bench_contains_bad_naive                       ... bench:         130 ns/iter (+/- 2)\ntest str::bench_contains_bad_simd                        ... bench:         292 ns/iter (+/- 1)\ntest str::bench_contains_equal                           ... bench:           3 ns/iter (+/- 0)\n\n\n1CGU, OLD:\ntest str::bench_contains_short_short                     ... bench:          30 ns/iter (+/- 0)\ntest str::bench_contains_short_long                      ... bench:         713 ns/iter (+/- 17)\ntest str::bench_contains_bad_naive                       ... bench:         131 ns/iter (+/- 3)\ntest str::bench_contains_bad_simd                        ... bench:         130 ns/iter (+/- 3)\ntest str::bench_contains_equal                           ... bench:         148 ns/iter (+/- 6)\n\n1CGU, NEW:\ntest str::bench_contains_short_short                     ... bench:          10 ns/iter (+/- 0)\ntest str::bench_contains_short_long                      ... bench:         111 ns/iter (+/- 0)\ntest str::bench_contains_bad_naive                       ... bench:         135 ns/iter (+/- 3)\ntest str::bench_contains_bad_simd                        ... bench:         274 ns/iter (+/- 2)\ntest str::bench_contains_equal                           ... bench:           4 ns/iter (+/- 0)\n```\n\n\n[0] http://0x80.pl/articles/simd-strfind.html#sse-avx2", "tree": {"sha": "d938d383d22b7bbae59bf113aaf7692ed69c883c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d938d383d22b7bbae59bf113aaf7692ed69c883c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d4a8482b93313be4d6e8dc62030860fa2fc46ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4a8482b93313be4d6e8dc62030860fa2fc46ef", "html_url": "https://github.com/rust-lang/rust/commit/3d4a8482b93313be4d6e8dc62030860fa2fc46ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d4a8482b93313be4d6e8dc62030860fa2fc46ef/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467b299e537cc94e29c1db252557cb7365924d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/467b299e537cc94e29c1db252557cb7365924d9a", "html_url": "https://github.com/rust-lang/rust/commit/467b299e537cc94e29c1db252557cb7365924d9a"}], "stats": {"total": 102, "additions": 102, "deletions": 0}, "files": [{"sha": "def11ca45c05e0eb85fa8d74cb25fb3c27a6db9d", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3d4a8482b93313be4d6e8dc62030860fa2fc46ef/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4a8482b93313be4d6e8dc62030860fa2fc46ef/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=3d4a8482b93313be4d6e8dc62030860fa2fc46ef", "patch": "@@ -39,6 +39,7 @@\n )]\n \n use crate::cmp;\n+use crate::cmp::Ordering;\n use crate::fmt;\n use crate::slice::memchr;\n \n@@ -946,6 +947,27 @@ impl<'a, 'b> Pattern<'a> for &'b str {\n         haystack.as_bytes().starts_with(self.as_bytes())\n     }\n \n+    /// Checks whether the pattern matches anywhere in the haystack\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        if self.len() == 0 {\n+            return true;\n+        }\n+\n+        match self.len().cmp(&haystack.len()) {\n+            Ordering::Less => {\n+                #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse2\"))]\n+                if self.as_bytes().len() <= 8 {\n+                    return simd_contains(self, haystack);\n+                }\n+\n+                self.into_searcher(haystack).next_match().is_some()\n+            }\n+            Ordering::Equal => self == haystack,\n+            Ordering::Greater => false,\n+        }\n+    }\n+\n     /// Removes the pattern from the front of haystack, if it matches.\n     #[inline]\n     fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n@@ -1684,3 +1706,83 @@ impl TwoWayStrategy for RejectAndMatch {\n         SearchStep::Match(a, b)\n     }\n }\n+\n+#[cfg(all(target_arch = \"x86_64\", target_feature = \"sse2\"))]\n+#[inline]\n+fn simd_contains(needle: &str, haystack: &str) -> bool {\n+    let needle = needle.as_bytes();\n+    let haystack = haystack.as_bytes();\n+\n+    if needle.len() == 1 {\n+        return haystack.contains(&needle[0]);\n+    }\n+\n+    const CHUNK: usize = 16;\n+\n+    // do a naive search if if the haystack is too small to fit\n+    if haystack.len() < CHUNK + needle.len() - 1 {\n+        return haystack.windows(needle.len()).any(|c| c == needle);\n+    }\n+\n+    use crate::arch::x86_64::{\n+        __m128i, _mm_and_si128, _mm_cmpeq_epi8, _mm_loadu_si128, _mm_movemask_epi8, _mm_set1_epi8,\n+    };\n+\n+    // SAFETY: no preconditions other than sse2 being available\n+    let first: __m128i = unsafe { _mm_set1_epi8(needle[0] as i8) };\n+    // SAFETY: no preconditions other than sse2 being available\n+    let last: __m128i = unsafe { _mm_set1_epi8(*needle.last().unwrap() as i8) };\n+\n+    let check_mask = #[cold]\n+    |idx, mut mask: u32| -> bool {\n+        while mask != 0 {\n+            let trailing = mask.trailing_zeros();\n+            let offset = idx + trailing as usize + 1;\n+            let sub = &haystack[offset..][..needle.len() - 2];\n+            let trimmed_needle = &needle[1..needle.len() - 1];\n+\n+            if sub == trimmed_needle {\n+                return true;\n+            }\n+            mask &= !(1 << trailing);\n+        }\n+        return false;\n+    };\n+\n+    let test_chunk = |i| -> bool {\n+        // SAFETY: this requires at least CHUNK bytes being readable at offset i\n+        // that is ensured by the loop ranges (see comments below)\n+        let a: __m128i = unsafe { _mm_loadu_si128(haystack.as_ptr().add(i) as *const _) };\n+        let b: __m128i =\n+            // SAFETY: this requires CHUNK + needle.len() - 1 bytes being readable at offset i\n+            unsafe { _mm_loadu_si128(haystack.as_ptr().add(i + needle.len() - 1) as *const _) };\n+\n+        // SAFETY: no preconditions other than sse2 being available\n+        let eq_first: __m128i = unsafe { _mm_cmpeq_epi8(first, a) };\n+        // SAFETY: no preconditions other than sse2 being available\n+        let eq_last: __m128i = unsafe { _mm_cmpeq_epi8(last, b) };\n+\n+        // SAFETY: no preconditions other than sse2 being available\n+        let mask: u32 = unsafe { _mm_movemask_epi8(_mm_and_si128(eq_first, eq_last)) } as u32;\n+\n+        if mask != 0 {\n+            return check_mask(i, mask);\n+        }\n+        return false;\n+    };\n+\n+    let mut i = 0;\n+    let mut result = false;\n+    while !result && i + CHUNK + needle.len() <= haystack.len() {\n+        result |= test_chunk(i);\n+        i += CHUNK;\n+    }\n+\n+    // process the tail that didn't fit into CHUNK-sized steps\n+    // this simply repeats the same procedure but as right-aligned chunk instead\n+    // of a left-aligned one. The last byte must be exactly flush with the string end so\n+    // we don't miss a single byte or read out of bounds.\n+    result |= test_chunk(haystack.len() + 1 - needle.len() - CHUNK);\n+\n+    return result;\n+}"}]}