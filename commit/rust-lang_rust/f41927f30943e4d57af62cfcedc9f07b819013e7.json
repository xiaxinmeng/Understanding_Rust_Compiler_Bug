{"sha": "f41927f30943e4d57af62cfcedc9f07b819013e7", "node_id": "C_kwDOAAsO6NoAKGY0MTkyN2YzMDk0M2U0ZDU3YWY2MmNmY2VkYzlmMDdiODE5MDEzZTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T14:00:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T14:00:28Z"}, "message": "Auto merge of #108820 - cjgillot:ensure-on-disk, r=oli-obk\n\nEnsure value is on the on-disk cache before returning from `ensure()`.\n\nThe current logic for `ensure()` a query just checks that the node is green in the dependency graph.\nHowever, a lot of places use `ensure()` to prevent the query from being called later. This is the case before stealing a query result.\n\nIf the query is actually green but the value is not available in the on-disk cache, `ensure` would return, but a subsequent call to the full query would run the code, and attempt to read from a stolen value.\n\nThis PR conforms the query system to the usage by checking whether the queried value is loadable from disk before returning.\n\nSadly, I can't manage to craft a proper test...\n\nShould fix all instances of \"attempted to read from stolen value\".", "tree": {"sha": "ac1896f170229aa3f52c6a8e402d890208071e51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac1896f170229aa3f52c6a8e402d890208071e51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f41927f30943e4d57af62cfcedc9f07b819013e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f41927f30943e4d57af62cfcedc9f07b819013e7", "html_url": "https://github.com/rust-lang/rust/commit/f41927f30943e4d57af62cfcedc9f07b819013e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f41927f30943e4d57af62cfcedc9f07b819013e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24c0b81c1fd5de8e00276524896d3352ed91a8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/24c0b81c1fd5de8e00276524896d3352ed91a8cb", "html_url": "https://github.com/rust-lang/rust/commit/24c0b81c1fd5de8e00276524896d3352ed91a8cb"}, {"sha": "e955ec0908c54b33ab08d4b768c9f8aa8071c643", "url": "https://api.github.com/repos/rust-lang/rust/commits/e955ec0908c54b33ab08d4b768c9f8aa8071c643", "html_url": "https://github.com/rust-lang/rust/commit/e955ec0908c54b33ab08d4b768c9f8aa8071c643"}], "stats": {"total": 146, "additions": 116, "deletions": 30}, "files": [{"sha": "ea7fa02521e44f6ed251b9fe812f20641c495ec3", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -435,8 +435,9 @@ fn compute_hir_hash(\n \n pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n-    tcx.ensure().output_filenames(());\n-    let _ = tcx.early_lint_checks(()); // Borrows `resolver_for_lowering`.\n+    // Queries that borrow `resolver_for_lowering`.\n+    tcx.ensure_with_value().output_filenames(());\n+    tcx.ensure_with_value().early_lint_checks(());\n     let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);"}, {"sha": "16306bef42ea48274e9398db4758bca53f668d04", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -2050,13 +2050,13 @@ fn prefetch_mir(tcx: TyCtxt<'_>) {\n         let (encode_const, encode_opt) = should_encode_mir(tcx, def_id);\n \n         if encode_const {\n-            tcx.ensure().mir_for_ctfe(def_id);\n+            tcx.ensure_with_value().mir_for_ctfe(def_id);\n         }\n         if encode_opt {\n-            tcx.ensure().optimized_mir(def_id);\n+            tcx.ensure_with_value().optimized_mir(def_id);\n         }\n         if encode_opt || encode_const {\n-            tcx.ensure().promoted_mir(def_id);\n+            tcx.ensure_with_value().promoted_mir(def_id);\n         }\n     })\n }"}, {"sha": "05219efe5f54d06c1e4be37dd90794c9c5d143e4", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -99,6 +99,11 @@ pub struct TyCtxtEnsure<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n }\n \n+#[derive(Copy, Clone)]\n+pub struct TyCtxtEnsureWithValue<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n     /// are executed instead of just returning their results.\n@@ -107,6 +112,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         TyCtxtEnsure { tcx: self }\n     }\n \n+    /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+    /// are executed instead of just returning their results.\n+    ///\n+    /// This version verifies that the computed result exists in the cache before returning.\n+    #[inline(always)]\n+    pub fn ensure_with_value(self) -> TyCtxtEnsureWithValue<'tcx> {\n+        TyCtxtEnsureWithValue { tcx: self }\n+    }\n+\n     /// Returns a transparent wrapper for `TyCtxt` which uses\n     /// `span` as the location of queries performed through it.\n     #[inline(always)]\n@@ -314,7 +328,31 @@ macro_rules! define_callbacks {\n \n                 match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n-                    None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n+                    None => self.tcx.queries.$name(\n+                        self.tcx,\n+                        DUMMY_SP,\n+                        key,\n+                        QueryMode::Ensure { check_cache: false },\n+                    ),\n+                };\n+            })*\n+        }\n+\n+        impl<'tcx> TyCtxtEnsureWithValue<'tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n+                let key = key.into_query_param();\n+                opt_remap_env_constness!([$($modifiers)*][key]);\n+\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n+                    Some(_) => return,\n+                    None => self.tcx.queries.$name(\n+                        self.tcx,\n+                        DUMMY_SP,\n+                        key,\n+                        QueryMode::Ensure { check_cache: true },\n+                    ),\n                 };\n             })*\n         }"}, {"sha": "70d5fc2d9588ae530a91b814e87545d55b061e67", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -48,17 +48,14 @@ pub(crate) fn mir_built(\n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n-    // We can't use `ensure()` for `thir_abstract_const` as it doesn't compute the query\n-    // if inputs are green. This can cause ICEs when calling `thir_abstract_const` after\n-    // THIR has been stolen if we haven't computed this query yet.\n     match def {\n         ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n-            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did));\n-            drop(tcx.thir_abstract_const_of_const_arg((did, const_param_did)));\n+            tcx.ensure_with_value().thir_check_unsafety_for_const_arg((did, const_param_did));\n+            tcx.ensure_with_value().thir_abstract_const_of_const_arg((did, const_param_did));\n         }\n         ty::WithOptConstParam { did, const_param_did: None } => {\n-            tcx.ensure().thir_check_unsafety(did);\n-            drop(tcx.thir_abstract_const(did));\n+            tcx.ensure_with_value().thir_check_unsafety(did);\n+            tcx.ensure_with_value().thir_abstract_const(did);\n         }\n     }\n "}, {"sha": "4917b045d4c03ddbee2eb6383214c815660dd3a5", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -278,14 +278,14 @@ fn mir_const(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Steal<\n     // Unsafety check uses the raw mir, so make sure it is run.\n     if !tcx.sess.opts.unstable_opts.thir_unsafeck {\n         if let Some(param_did) = def.const_param_did {\n-            tcx.ensure().unsafety_check_result_for_const_arg((def.did, param_did));\n+            tcx.ensure_with_value().unsafety_check_result_for_const_arg((def.did, param_did));\n         } else {\n-            tcx.ensure().unsafety_check_result(def.did);\n+            tcx.ensure_with_value().unsafety_check_result(def.did);\n         }\n     }\n \n     // has_ffi_unwind_calls query uses the raw mir, so make sure it is run.\n-    tcx.ensure().has_ffi_unwind_calls(def.did);\n+    tcx.ensure_with_value().has_ffi_unwind_calls(def.did);\n \n     let mut body = tcx.mir_built(def).steal();\n \n@@ -433,7 +433,7 @@ fn mir_drops_elaborated_and_const_checked(\n     if tcx.sess.opts.unstable_opts.drop_tracking_mir\n         && let DefKind::Generator = tcx.def_kind(def.did)\n     {\n-        tcx.ensure().mir_generator_witnesses(def.did);\n+        tcx.ensure_with_value().mir_generator_witnesses(def.did);\n     }\n     let mir_borrowck = tcx.mir_borrowck_opt_const_arg(def);\n \n@@ -444,7 +444,7 @@ fn mir_drops_elaborated_and_const_checked(\n \n         // Do not compute the mir call graph without said call graph actually being used.\n         if inline::Inline.is_enabled(&tcx.sess) {\n-            let _ = tcx.mir_inliner_callees(ty::InstanceDef::Item(def));\n+            tcx.ensure_with_value().mir_inliner_callees(ty::InstanceDef::Item(def));\n         }\n     }\n \n@@ -613,7 +613,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         // Run the `mir_for_ctfe` query, which depends on `mir_drops_elaborated_and_const_checked`\n         // which we are going to steal below. Thus we need to run `mir_for_ctfe` first, so it\n         // computes and caches its result.\n-        Some(hir::ConstContext::ConstFn) => tcx.ensure().mir_for_ctfe(did),\n+        Some(hir::ConstContext::ConstFn) => tcx.ensure_with_value().mir_for_ctfe(did),\n         None => {}\n         Some(other) => panic!(\"do not use `optimized_mir` for constants: {:?}\", other),\n     }"}, {"sha": "035bfe978f20831702974893202fff28305b1053", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -31,6 +31,7 @@ use rustc_span::Span;\n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n+use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::query::*;\n #[cfg(parallel_compiler)]\n pub use rustc_query_system::query::{deadlock, QueryContext};"}, {"sha": "35b7e5919e42ac99b15ed723c2f98177760995a9", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -388,6 +388,12 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n+    /// Return whether the cached query result can be decoded.\n+    pub fn loadable_from_disk(&self, dep_node_index: SerializedDepNodeIndex) -> bool {\n+        self.query_result_index.contains_key(&dep_node_index)\n+        // with_decoder is infallible, so we can stop here\n+    }\n+\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(\n@@ -398,7 +404,9 @@ impl<'sess> OnDiskCache<'sess> {\n     where\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n-        self.load_indexed(tcx, dep_node_index, &self.query_result_index)\n+        let opt_value = self.load_indexed(tcx, dep_node_index, &self.query_result_index);\n+        debug_assert_eq!(opt_value.is_some(), self.loadable_from_disk(dep_node_index));\n+        opt_value\n     }\n \n     /// Stores side effect emitted during computation of an anonymous query.\n@@ -428,8 +436,8 @@ impl<'sess> OnDiskCache<'sess> {\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n-\n-        self.with_decoder(tcx, pos, |decoder| Some(decode_tagged(decoder, dep_node_index)))\n+        let value = self.with_decoder(tcx, pos, |decoder| decode_tagged(decoder, dep_node_index));\n+        Some(value)\n     }\n \n     fn with_decoder<'a, 'tcx, T, F: for<'s> FnOnce(&mut CacheDecoder<'s, 'tcx>) -> T>("}, {"sha": "ca3c3997df003d43d55277cbc3b227578396cf21", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -364,6 +364,14 @@ where\n     }\n }\n \n+pub(crate) fn loadable_from_disk<'tcx>(tcx: QueryCtxt<'tcx>, id: SerializedDepNodeIndex) -> bool {\n+    if let Some(cache) = tcx.on_disk_cache().as_ref() {\n+        cache.loadable_from_disk(id)\n+    } else {\n+        false\n+    }\n+}\n+\n pub(crate) fn try_load_from_disk<'tcx, V>(\n     tcx: QueryCtxt<'tcx>,\n     id: SerializedDepNodeIndex,\n@@ -535,6 +543,21 @@ macro_rules! define_queries {\n                 })\n             }\n \n+            #[inline]\n+            fn loadable_from_disk(\n+                self,\n+                _qcx: QueryCtxt<'tcx>,\n+                _key: &Self::Key,\n+                _index: SerializedDepNodeIndex,\n+            ) -> bool {\n+                should_ever_cache_on_disk!([$($modifiers)*] {\n+                    self.cache_on_disk(_qcx.tcx, _key) &&\n+                        $crate::plumbing::loadable_from_disk(_qcx, _index)\n+                } {\n+                    false\n+                })\n+            }\n+\n             #[inline(always)]\n             fn anon(self) -> bool {\n                 is_anon!([$($modifiers)*])"}, {"sha": "a0aeb812af968124f211fa6202335da3c32ed499", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -43,6 +43,8 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n \n     fn try_load_from_disk(self, qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self::Value>;\n \n+    fn loadable_from_disk(self, qcx: Qcx, key: &Self::Key, idx: SerializedDepNodeIndex) -> bool;\n+\n     fn anon(self) -> bool;\n     fn eval_always(self) -> bool;\n     fn depth_limit(self) -> bool;"}, {"sha": "a3656f4ebe6e7519faa6b80cb7d64ef98baf09d5", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41927f30943e4d57af62cfcedc9f07b819013e7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=f41927f30943e4d57af62cfcedc9f07b819013e7", "patch": "@@ -564,10 +564,17 @@ where\n         // can be forced from `DepNode`.\n         debug_assert!(\n             !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n-            \"missing on-disk cache entry for {dep_node:?}\"\n+            \"missing on-disk cache entry for reconstructible {dep_node:?}\"\n         );\n     }\n \n+    // Sanity check for the logic in `ensure`: if the node is green and the result loadable,\n+    // we should actually be able to load it.\n+    debug_assert!(\n+        !query.loadable_from_disk(qcx, &key, prev_dep_node_index),\n+        \"missing on-disk cache entry for loadable {dep_node:?}\"\n+    );\n+\n     // We could not load a result from the on-disk cache, so\n     // recompute.\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n@@ -718,6 +725,7 @@ fn ensure_must_run<Q, Qcx>(\n     query: Q,\n     qcx: Qcx,\n     key: &Q::Key,\n+    check_cache: bool,\n ) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n     Q: QueryConfig<Qcx>,\n@@ -733,28 +741,36 @@ where\n     let dep_node = query.construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n-    match dep_graph.try_mark_green(qcx, &dep_node) {\n+    let serialized_dep_node_index = match dep_graph.try_mark_green(qcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n             // Either way, we can't call `dep_graph.read()` as we don't have the\n             // DepNodeIndex. We must invoke the query itself. The performance cost\n             // this introduces should be negligible as we'll immediately hit the\n             // in-memory cache, or another query down the line will.\n-            (true, Some(dep_node))\n+            return (true, Some(dep_node));\n         }\n-        Some((_, dep_node_index)) => {\n+        Some((serialized_dep_node_index, dep_node_index)) => {\n             dep_graph.read_index(dep_node_index);\n             qcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n-            (false, None)\n+            serialized_dep_node_index\n         }\n+    };\n+\n+    // We do not need the value at all, so do not check the cache.\n+    if !check_cache {\n+        return (false, None);\n     }\n+\n+    let loadable = query.loadable_from_disk(qcx, key, serialized_dep_node_index);\n+    (!loadable, Some(dep_node))\n }\n \n #[derive(Debug)]\n pub enum QueryMode {\n     Get,\n-    Ensure,\n+    Ensure { check_cache: bool },\n }\n \n #[inline(always)]\n@@ -769,8 +785,8 @@ where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(query, qcx, &key);\n+    let dep_node = if let QueryMode::Ensure { check_cache } = mode {\n+        let (must_run, dep_node) = ensure_must_run(query, qcx, &key, check_cache);\n         if !must_run {\n             return None;\n         }"}]}