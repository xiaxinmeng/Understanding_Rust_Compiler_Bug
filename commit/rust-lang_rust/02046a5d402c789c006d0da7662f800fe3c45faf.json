{"sha": "02046a5d402c789c006d0da7662f800fe3c45faf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMDQ2YTVkNDAyYzc4OWMwMDZkMGRhNzY2MmY4MDBmZTNjNDVmYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T20:33:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T20:33:53Z"}, "message": "Auto merge of #70371 - Centril:rollup-ywi1vo3, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #70023 (clean up E0436 explanation)\n - #70234 (#[track_caller] on core::ops::{Index, IndexMut}.)\n - #70241 (Miri: move ModifiedStatic to ConstEval errors)\n - #70342 (IoSlice/IoSliceMut should be Send and Sync)\n - #70350 (Request \"-Z unstable-options\" for unstable options)\n - #70355 (Clean up E0454)\n - #70359 (must_use on split_off)\n - #70368 (Mark hotplug_codegen_backend as ignore-stage1)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "298c6737ad0555e0d2ebdfffcb91c18f5fa77dfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/298c6737ad0555e0d2ebdfffcb91c18f5fa77dfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02046a5d402c789c006d0da7662f800fe3c45faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02046a5d402c789c006d0da7662f800fe3c45faf", "html_url": "https://github.com/rust-lang/rust/commit/02046a5d402c789c006d0da7662f800fe3c45faf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02046a5d402c789c006d0da7662f800fe3c45faf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dcf54f564c6d8bbf48960fb9aaec88a0e2e062a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dcf54f564c6d8bbf48960fb9aaec88a0e2e062a", "html_url": "https://github.com/rust-lang/rust/commit/2dcf54f564c6d8bbf48960fb9aaec88a0e2e062a"}, {"sha": "bf1ad2229fc635434c3f5d61db8feb1e7e33f861", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1ad2229fc635434c3f5d61db8feb1e7e33f861", "html_url": "https://github.com/rust-lang/rust/commit/bf1ad2229fc635434c3f5d61db8feb1e7e33f861"}], "stats": {"total": 355, "additions": 237, "deletions": 118}, "files": [{"sha": "69284fbf1b37db7b89b26052d667007e252281d9", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -1876,6 +1876,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2, [2, 3]);\n     /// ```\n     #[inline]\n+    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let len = self.len();"}, {"sha": "7c89d38caa4e64dbd3ad7a0f1d445fff50870bc4", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -1461,6 +1461,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n+    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     pub fn split_off(&mut self, at: usize) -> String {\n         assert!(self.is_char_boundary(at));\n         let other = self.vec.split_off(at);"}, {"sha": "d2f09eb4a75688fe1119cb4a3aab288999bd93c4", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -266,14 +266,14 @@ fn test_split_off_empty() {\n fn test_split_off_past_end() {\n     let orig = \"Hello, world!\";\n     let mut split = String::from(orig);\n-    split.split_off(orig.len() + 1);\n+    let _ = split.split_off(orig.len() + 1);\n }\n \n #[test]\n #[should_panic]\n fn test_split_off_mid_char() {\n     let mut orig = String::from(\"\u5c71\");\n-    orig.split_off(1);\n+    let _ = orig.split_off(1);\n }\n \n #[test]"}, {"sha": "64dd633f75d2b4b2badcaaf4c7c9df4839b5a0f6", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -65,6 +65,7 @@ pub trait Index<Idx: ?Sized> {\n \n     /// Performs the indexing (`container[index]`) operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(not(bootstrap), track_caller)]\n     fn index(&self, index: Idx) -> &Self::Output;\n }\n \n@@ -166,5 +167,6 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// Performs the mutable indexing (`container[index]`) operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(not(bootstrap), track_caller)]\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }"}, {"sha": "2140a7be9efe8c05b2b1bb2b2ff63924e3962ae8", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -2306,6 +2306,7 @@ impl<T> [T] {\n     /// assert_eq!(&bytes, b\"Hello, Wello!\");\n     /// ```\n     #[stable(feature = \"copy_within\", since = \"1.37.0\")]\n+    #[track_caller]\n     pub fn copy_within<R: ops::RangeBounds<usize>>(&mut self, src: R, dest: usize)\n     where\n         T: Copy,\n@@ -2721,18 +2722,21 @@ where\n \n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn slice_index_len_fail(index: usize, len: usize) -> ! {\n     panic!(\"index {} out of range for slice of length {}\", index, len);\n }\n \n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn slice_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n@@ -2804,11 +2808,13 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// Returns a shared reference to the output at this location, panicking\n     /// if out of bounds.\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    #[cfg_attr(not(bootstrap), track_caller)]\n     fn index(self, slice: &T) -> &Self::Output;\n \n     /// Returns a mutable reference to the output at this location, panicking\n     /// if out of bounds.\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    #[cfg_attr(not(bootstrap), track_caller)]\n     fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n }\n "}, {"sha": "013ca182c13cd867210f9ab65061cb5eee734b2b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -1794,6 +1794,7 @@ mod traits {\n \n     #[inline(never)]\n     #[cold]\n+    #[track_caller]\n     fn str_index_overflow_fail() -> ! {\n         panic!(\"attempted to index str up to maximum usize\");\n     }\n@@ -2185,6 +2186,7 @@ fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n \n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     const MAX_DISPLAY_LENGTH: usize = 256;\n     let (truncated, s_trunc) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);"}, {"sha": "f7871952452128b4dc78b173bf1fad043893a7dd", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -453,9 +453,6 @@ pub enum UnsupportedOpInfo {\n     ReadForeignStatic(DefId),\n     /// Could not find MIR for a function.\n     NoMirFor(DefId),\n-    /// Modified a static during const-eval.\n-    /// FIXME: move this to `ConstEvalErrKind` through a machine hook.\n-    ModifiedStatic,\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n     /// Encountered raw bytes where we needed a pointer.\n@@ -471,12 +468,6 @@ impl fmt::Debug for UnsupportedOpInfo {\n                 write!(f, \"tried to read from foreign (extern) static {:?}\", did)\n             }\n             NoMirFor(did) => write!(f, \"could not load MIR for {:?}\", did),\n-            ModifiedStatic => write!(\n-                f,\n-                \"tried to modify a static's initial value from another static's \\\n-                    initializer\"\n-            ),\n-\n             ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n             ReadBytesAsPointer => write!(f, \"unable to turn bytes into a pointer\"),\n         }"}, {"sha": "1dc2f2a6f248b00ade6dd45ff2d9e49a66da59e1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -984,6 +984,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n \n+    /// Stores memory for globals (statics/consts).\n     pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: ShardedHashMap<&'tcx LayoutDetails, ()>,"}, {"sha": "48ecc49e92f547ff1a5794525c4fbd4e78f17e34", "filename": "src/librustc_error_codes/error_codes/E0436.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -1,5 +1,4 @@\n-The functional record update syntax is only allowed for structs. (Struct-like\n-enum variants don't qualify, for example.)\n+The functional record update syntax was used on something other than a struct.\n \n Erroneous code example:\n \n@@ -24,7 +23,9 @@ fn one_up_competitor(competitor_frequency: PublicationFrequency)\n }\n ```\n \n-Rewrite the expression without functional record update syntax:\n+The functional record update syntax is only allowed for structs (struct-like\n+enum variants don't qualify, for example). To fix the previous code, rewrite the\n+expression without functional record update syntax:\n \n ```\n enum PublicationFrequency {"}, {"sha": "23ca6c7824df1e1129d41304d98635fee4a16986", "filename": "src/librustc_error_codes/error_codes/E0454.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -1,4 +1,6 @@\n-A link name was given with an empty name. Erroneous code example:\n+A link name was given with an empty name.\n+\n+Erroneous code example:\n \n ```compile_fail,E0454\n #[link(name = \"\")] extern {}"}, {"sha": "aa30f43df93500018eebc19b9fb7abb95303dc7d", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -12,6 +12,7 @@ use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n pub enum ConstEvalErrKind {\n     NeedsRfc(String),\n     ConstAccessesStatic,\n+    ModifiedGlobal,\n     AssertFailure(AssertKind<u64>),\n     Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n }\n@@ -33,6 +34,9 @@ impl fmt::Display for ConstEvalErrKind {\n                 write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n             }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n+            ModifiedGlobal => {\n+                write!(f, \"modifying a static's initial value from another static's initializer\")\n+            }\n             AssertFailure(ref msg) => write!(f, \"{:?}\", msg),\n             Panic { msg, line, col, file } => {\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)"}, {"sha": "8f4501cc3fb69ace1fd213244a418c1bab5d4275", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -8,8 +8,9 @@ use std::hash::Hash;\n use rustc_data_structures::fx::FxHashMap;\n \n use rustc::mir::AssertMessage;\n-use rustc_span::source_map::Span;\n+use rustc_ast::ast::Mutability;\n use rustc_span::symbol::Symbol;\n+use rustc_span::{def_id::DefId, Span};\n \n use crate::interpret::{\n     self, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind, OpTy,\n@@ -167,7 +168,7 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n-    type MemoryKinds = !;\n+    type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n \n@@ -177,7 +178,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n \n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n-    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n+    const GLOBAL_KIND: Option<!> = None; // no copying of globals allowed\n \n     // We do not check for alignment to avoid having to carry an `Align`\n     // in `ConstValue::ByRef`.\n@@ -317,7 +318,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n+    fn tag_global_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -345,11 +346,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n         Ok(())\n     }\n \n-    fn before_access_static(\n+    fn before_access_global(\n         memory_extra: &MemoryExtra,\n-        _allocation: &Allocation,\n+        alloc_id: AllocId,\n+        allocation: &Allocation,\n+        def_id: Option<DefId>,\n+        is_write: bool,\n     ) -> InterpResult<'tcx> {\n-        if memory_extra.can_access_statics {\n+        if is_write && allocation.mutability == Mutability::Not {\n+            Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n+        } else if is_write {\n+            Err(ConstEvalErrKind::ModifiedGlobal.into())\n+        } else if memory_extra.can_access_statics || def_id.is_none() {\n+            // `def_id.is_none()` indicates this is not a static, but a const or so.\n             Ok(())\n         } else {\n             Err(ConstEvalErrKind::ConstAccessesStatic.into())"}, {"sha": "c50146f295adb67e8517934a7408f619f2732e08", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -253,8 +253,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This represents a *direct* access to that memory, as opposed to access\n     /// through a pointer that was created by the program.\n     #[inline(always)]\n-    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        self.memory.tag_static_base_pointer(ptr)\n+    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+        self.memory.tag_global_base_pointer(ptr)\n     }\n \n     #[inline(always)]"}, {"sha": "b9ed69842f1a9b28beaffdedf30170b241f6b149", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -16,7 +16,7 @@ use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, Scalar\n pub trait CompileTimeMachine<'mir, 'tcx> = Machine<\n     'mir,\n     'tcx,\n-    MemoryKinds = !,\n+    MemoryKind = !,\n     PointerTag = (),\n     ExtraFnVal = !,\n     FrameExtra = (),\n@@ -104,7 +104,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         MemoryKind::Stack | MemoryKind::Vtable | MemoryKind::CallerLocation => {}\n     }\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into\n-    // read-only memory, and also by Miri when evluating other constants/statics that\n+    // read-only memory, and also by Miri when evaluating other globals that\n     // access this one.\n     if mode == InternMode::Static {\n         // When `ty` is `None`, we assume no interior mutability."}, {"sha": "cc87c2916862be2e88b414ae56b07a530f4c2482", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -7,7 +7,7 @@ use std::hash::Hash;\n \n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc_span::Span;\n+use rustc_span::{def_id::DefId, Span};\n \n use super::{\n     AllocId, Allocation, AllocationExtra, Frame, ImmTy, InterpCx, InterpResult, Memory, MemoryKind,\n@@ -79,7 +79,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n /// and some use case dependent behaviour can instead be applied.\n pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + MayLeak + Eq + 'static;\n+    type MemoryKind: ::std::fmt::Debug + MayLeak + Eq + 'static;\n \n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n@@ -105,16 +105,17 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKinds>, Allocation<Self::PointerTag, Self::AllocExtra>),\n+            (MemoryKind<Self::MemoryKind>, Allocation<Self::PointerTag, Self::AllocExtra>),\n         > + Default\n         + Clone;\n \n-    /// The memory kind to use for copied statics -- or None if statics should not be mutated\n-    /// and thus any such attempt will cause a `ModifiedStatic` error to be raised.\n+    /// The memory kind to use for copied global memory (held in `tcx`) --\n+    /// or None if such memory should not be mutated and thus any such attempt will cause\n+    /// a `ModifiedStatic` error to be raised.\n     /// Statics are copied under two circumstances: When they are mutated, and when\n-    /// `tag_allocation` or `find_foreign_static` (see below) returns an owned allocation\n+    /// `tag_allocation` (see below) returns an owned allocation\n     /// that is added to the memory so that the work is not done twice.\n-    const STATIC_KIND: Option<Self::MemoryKinds>;\n+    const GLOBAL_KIND: Option<Self::MemoryKind>;\n \n     /// Whether memory accesses should be alignment-checked.\n     const CHECK_ALIGN: bool;\n@@ -207,11 +208,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called before a `Static` value is accessed.\n+    /// Called before a global allocation is accessed.\n+    /// `def_id` is `Some` if this is the \"lazy\" allocation of a static.\n     #[inline]\n-    fn before_access_static(\n+    fn before_access_global(\n         _memory_extra: &Self::MemoryExtra,\n+        _alloc_id: AllocId,\n         _allocation: &Allocation,\n+        _def_id: Option<DefId>,\n+        _is_write: bool,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -231,10 +236,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n     /// This keeps uniform code paths for handling both allocations created by CTFE\n-    /// for statics, and allocations created by Miri during evaluation.\n+    /// for globals, and allocations created by Miri during evaluation.\n     ///\n     /// `kind` is the kind of the allocation being tagged; it can be `None` when\n-    /// it's a static and `STATIC_KIND` is `None`.\n+    /// it's a global and `GLOBAL_KIND` is `None`.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n@@ -243,20 +248,20 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// Also return the \"base\" tag to use for this allocation: the one that is used for direct\n     /// accesses to this allocation. If `kind == STATIC_KIND`, this tag must be consistent\n-    /// with `tag_static_base_pointer`.\n+    /// with `tag_global_base_pointer`.\n     fn init_allocation_extra<'b>(\n         memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n-        kind: Option<MemoryKind<Self::MemoryKinds>>,\n+        kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n \n-    /// Return the \"base\" tag for the given *static* allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation. If `id` is not a static allocation,\n+    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n     /// this will return an unusable tag (i.e., accesses will be UB)!\n     ///\n     /// Expects `id` to be already canonical, if needed.\n-    fn tag_static_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n+    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n     #[inline]"}, {"sha": "110f2ffd9d78c8045affa8d9e6545e415d1785c3", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -80,12 +80,12 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Allocations local to this instance of the miri engine. The kind\n     /// helps ensure that the same mechanism is used for allocation and\n     /// deallocation. When an allocation is not found here, it is a\n-    /// static and looked up in the `tcx` for read access. Some machines may\n-    /// have to mutate this map even on a read-only access to a static (because\n+    /// global and looked up in the `tcx` for read access. Some machines may\n+    /// have to mutate this map even on a read-only access to a global (because\n     /// they do pointer provenance tracking and the allocations in `tcx` have\n     /// the wrong type), so we let the machine override this type.\n-    /// Either way, if the machine allows writing to a static, doing so will\n-    /// create a copy of the static allocation here.\n+    /// Either way, if the machine allows writing to a global, doing so will\n+    /// create a copy of the global allocation here.\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) alloc_map: M::MemoryMap,\n \n@@ -130,9 +130,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// This represents a *direct* access to that memory, as opposed to access\n     /// through a pointer that was created by the program.\n     #[inline]\n-    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n         let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        ptr.with_tag(M::tag_static_base_pointer(&self.extra, id))\n+        ptr.with_tag(M::tag_global_base_pointer(&self.extra, id))\n     }\n \n     pub fn create_fn_alloc(\n@@ -149,23 +149,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 id\n             }\n         };\n-        self.tag_static_base_pointer(Pointer::from(id))\n+        self.tag_global_base_pointer(Pointer::from(id))\n     }\n \n     pub fn allocate(\n         &mut self,\n         size: Size,\n         align: Align,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::undef(size, align);\n         self.allocate_with(alloc, kind)\n     }\n \n-    pub fn allocate_static_bytes(\n+    pub fn allocate_bytes(\n         &mut self,\n         bytes: &[u8],\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::from_byte_aligned_bytes(bytes);\n         self.allocate_with(alloc, kind)\n@@ -174,13 +174,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn allocate_with(\n         &mut self,\n         alloc: Allocation,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n         let id = self.tcx.alloc_map.lock().reserve();\n         debug_assert_ne!(\n             Some(kind),\n-            M::STATIC_KIND.map(MemoryKind::Machine),\n-            \"dynamically allocating static memory\"\n+            M::GLOBAL_KIND.map(MemoryKind::Machine),\n+            \"dynamically allocating global memory\"\n         );\n         let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n@@ -193,7 +193,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n             throw_ub_format!(\n@@ -215,9 +215,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    /// Deallocate a local, or do nothing if that local has been made into a static\n+    /// Deallocate a local, or do nothing if that local has been made into a global.\n     pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx> {\n-        // The allocation might be already removed by static interning.\n+        // The allocation might be already removed by global interning.\n         // This can only really happen in the CTFE instance, not in miri.\n         if self.alloc_map.contains_key(&ptr.alloc_id) {\n             self.deallocate(ptr, None, MemoryKind::Stack)\n@@ -230,7 +230,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n         old_size_and_align: Option<(Size, Align)>,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n@@ -244,7 +244,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n-                // Deallocating static memory -- always an error\n+                // Deallocating global memory -- always an error\n                 return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n                     Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n                     Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => {\n@@ -403,43 +403,45 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    /// Helper function to obtain the global (tcx) allocation for a static.\n+    /// Helper function to obtain a global (tcx) allocation.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n     /// this machine use the same pointer tag, so it is indirected through\n     /// `M::tag_allocation`.\n-    ///\n-    /// Notice that every static has two `AllocId` that will resolve to the same\n-    /// thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n-    /// and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n-    /// `const_eval_raw` and it is the \"resolved\" ID.\n-    /// The resolved ID is never used by the interpreted progrma, it is hidden.\n-    /// The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n-    /// contains a reference to memory that was created during its evaluation (i.e., not to\n-    /// another static), those inner references only exist in \"resolved\" form.\n-    ///\n-    /// Assumes `id` is already canonical.\n-    fn get_static_alloc(\n+    fn get_global_alloc(\n         memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n         id: AllocId,\n+        is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n-        let alloc = match alloc {\n-            Some(GlobalAlloc::Memory(mem)) => Cow::Borrowed(mem),\n+        let (alloc, def_id) = match alloc {\n+            Some(GlobalAlloc::Memory(mem)) => {\n+                // Memory of a constant or promoted or anonymous memory referenced by a static.\n+                (mem, None)\n+            }\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n-                // We got a \"lazy\" static that has not been computed yet.\n+                // Notice that every static has two `AllocId` that will resolve to the same\n+                // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n+                // and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n+                // `const_eval_raw` and it is the \"resolved\" ID.\n+                // The resolved ID is never used by the interpreted progrma, it is hidden.\n+                // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n+                // contains a reference to memory that was created during its evaluation (i.e., not\n+                // to another static), those inner references only exist in \"resolved\" form.\n+                //\n+                // Assumes `id` is already canonical.\n                 if tcx.is_foreign_item(def_id) {\n-                    trace!(\"get_static_alloc: foreign item {:?}\", def_id);\n+                    trace!(\"get_global_alloc: foreign item {:?}\", def_id);\n                     throw_unsup!(ReadForeignStatic(def_id))\n                 }\n-                trace!(\"get_static_alloc: Need to compute {:?}\", def_id);\n+                trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n                 let instance = Instance::mono(tcx.tcx, def_id);\n                 let gid = GlobalId { instance, promoted: None };\n-                // use the raw query here to break validation cycles. Later uses of the static\n-                // will call the full query anyway\n+                // Use the raw query here to break validation cycles. Later uses of the static\n+                // will call the full query anyway.\n                 let raw_const =\n                     tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n                         // no need to report anything, the const_eval call takes care of that\n@@ -454,18 +456,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let id = raw_const.alloc_id;\n                 let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n \n-                M::before_access_static(memory_extra, allocation)?;\n-                Cow::Borrowed(allocation)\n+                (allocation, Some(def_id))\n             }\n         };\n+        M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n+        let alloc = Cow::Borrowed(alloc);\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n         let (alloc, tag) = M::init_allocation_extra(\n             memory_extra,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n-            M::STATIC_KIND.map(MemoryKind::Machine),\n+            M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n-        debug_assert_eq!(tag, M::tag_static_base_pointer(memory_extra, id));\n+        debug_assert_eq!(tag, M::tag_global_base_pointer(memory_extra, id));\n         Ok(alloc)\n     }\n \n@@ -478,10 +481,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let id = M::canonical_alloc_id(self, id);\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n-        // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n+        // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_static_alloc(&self.extra, self.tcx, id).map_err(Err)?;\n+            let alloc = Self::get_global_alloc(&self.extra, self.tcx, id, /*is_write*/ false)\n+                .map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -490,8 +494,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n                 Cow::Owned(alloc) => {\n                     // Need to put it into the map and return a ref to that\n-                    let kind = M::STATIC_KIND.expect(\n-                        \"I got an owned allocation that I have to copy but the machine does \\\n+                    let kind = M::GLOBAL_KIND.expect(\n+                        \"I got a global allocation that I have to copy but the machine does \\\n                             not expect that to happen\",\n                     );\n                     Ok((MemoryKind::Machine(kind), alloc))\n@@ -515,16 +519,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n-            // Need to make a copy, even if `get_static_alloc` is able\n+            // Need to make a copy, even if `get_global_alloc` is able\n             // to give us a cheap reference.\n-            let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n+            let alloc = Self::get_global_alloc(memory_extra, tcx, id, /*is_write*/ true)?;\n             if alloc.mutability == Mutability::Not {\n                 throw_ub!(WriteToReadOnly(id))\n             }\n-            match M::STATIC_KIND {\n-                Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => throw_unsup!(ModifiedStatic),\n-            }\n+            let kind = M::GLOBAL_KIND.expect(\n+                \"I got a global allocation that I have to copy but the machine does \\\n+                    not expect that to happen\",\n+            );\n+            Ok((MemoryKind::Machine(kind), alloc.into_owned()))\n         });\n         // Unpack the error type manually because type inference doesn't\n         // work otherwise (and we cannot help it because `impl Trait`)\n@@ -553,7 +558,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n-        // b) duplicate a static's allocation in miri\n+        // b) duplicate a global's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n             return Ok((alloc.size, alloc.align));\n         }\n@@ -728,7 +733,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     );\n                 }\n                 Err(()) => {\n-                    // static alloc?\n+                    // global alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             self.dump_alloc_helper("}, {"sha": "90fb7eb2bb3ac0cdf60f0c35b4a41c8d620dd5e9", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -517,7 +517,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let tag_scalar = |scalar| match scalar {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_static_base_pointer(ptr)),\n+            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_global_base_pointer(ptr)),\n             Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         };\n         // Early-return cases.\n@@ -547,7 +547,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n-                let ptr = self.tag_static_base_pointer(Pointer::new(id, offset));\n+                let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n                 Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             }\n             ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x).into()),\n@@ -559,7 +559,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Size::from_bytes(start as u64), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n-                    self.tag_static_base_pointer(ptr).into(),\n+                    self.tag_global_base_pointer(ptr).into(),\n                     (end - start) as u64, // len: `end - start`\n                     self,\n                 ))"}, {"sha": "6cf11c071e4f7edc767faaedd9bf0a13677a71b9", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -290,7 +290,7 @@ where\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n     M: Machine<'mir, 'tcx, PointerTag = Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKind>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n@@ -1015,7 +1015,7 @@ where\n     pub fn allocate(\n         &mut self,\n         layout: TyLayout<'tcx>,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n         MPlaceTy::from_aligned_ptr(ptr, layout)\n@@ -1025,9 +1025,9 @@ where\n     pub fn allocate_str(\n         &mut self,\n         str: &str,\n-        kind: MemoryKind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n-        let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n+        let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n         let mplace = MemPlace {\n             ptr: ptr.into(),\n@@ -1118,7 +1118,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n-        let ptr = self.tag_static_base_pointer(Pointer::from(raw.alloc_id));\n+        let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }"}, {"sha": "cbb79637076bc3b31bcfcf3f4daef64a2eb86fc3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_session::lint;\n-use rustc_span::Span;\n+use rustc_span::{def_id::DefId, Span};\n use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n@@ -162,7 +162,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n struct ConstPropMachine;\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n-    type MemoryKinds = !;\n+    type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n \n@@ -172,7 +172,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n-    const STATIC_KIND: Option<!> = None;\n+    const GLOBAL_KIND: Option<!> = None;\n \n     const CHECK_ALIGN: bool = false;\n \n@@ -247,7 +247,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n+    fn tag_global_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -270,14 +270,23 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         l.access()\n     }\n \n-    fn before_access_static(\n+    fn before_access_global(\n         _memory_extra: &(),\n+        _alloc_id: AllocId,\n         allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        def_id: Option<DefId>,\n+        is_write: bool,\n     ) -> InterpResult<'tcx> {\n-        // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n-        // the memory behind that in the future), then we can't const prop it\n-        if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n-            throw_machine_stop_str!(\"can't eval mutable statics in ConstProp\")\n+        if is_write {\n+            throw_machine_stop_str!(\"can't write to global\");\n+        }\n+        // If the static allocation is mutable or if it has relocations (it may be legal to mutate\n+        // the memory behind that in the future), then we can't const prop it.\n+        if allocation.mutability == Mutability::Mut {\n+            throw_machine_stop_str!(\"can't eval mutable globals in ConstProp\");\n+        }\n+        if def_id.is_some() && allocation.relocations().len() > 0 {\n+            throw_machine_stop_str!(\"can't eval statics with pointers in ConstProp\");\n         }\n \n         Ok(())"}, {"sha": "88d556229e4cb98ca2a1763199800dd21440b6e2", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -951,6 +951,12 @@ pub trait Read {\n #[repr(transparent)]\n pub struct IoSliceMut<'a>(sys::io::IoSliceMut<'a>);\n \n+#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\n+unsafe impl<'a> Send for IoSliceMut<'a> {}\n+\n+#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\n+unsafe impl<'a> Sync for IoSliceMut<'a> {}\n+\n #[stable(feature = \"iovec\", since = \"1.36.0\")]\n impl<'a> fmt::Debug for IoSliceMut<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1054,6 +1060,12 @@ impl<'a> DerefMut for IoSliceMut<'a> {\n #[repr(transparent)]\n pub struct IoSlice<'a>(sys::io::IoSlice<'a>);\n \n+#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\n+unsafe impl<'a> Send for IoSlice<'a> {}\n+\n+#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\n+unsafe impl<'a> Sync for IoSlice<'a> {}\n+\n #[stable(feature = \"iovec\", since = \"1.36.0\")]\n impl<'a> fmt::Debug for IoSlice<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "aac454c023c8073dc5651cd952c281a1e8ae9192", "filename": "src/libtest/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibtest%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Flibtest%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fcli.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -213,7 +213,7 @@ macro_rules! unstable_optflag {\n         let opt = $matches.opt_present($option_name);\n         if !$allow_unstable && opt {\n             return Err(format!(\n-                \"The \\\"{}\\\" flag is only accepted on the nightly compiler\",\n+                \"The \\\"{}\\\" flag is only accepted on the nightly compiler with -Z unstable-options\",\n                 $option_name\n             ));\n         }"}, {"sha": "d8ceace7fff250e1dbfcb638303c21a8adb61a87", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2FMakefile?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -1,5 +1,7 @@\n include ../tools.mk\n \n+# ignore-stage1\n+\n all:\n \t/bin/echo || exit 0 # This test requires /bin/echo to exist\n \t$(RUSTC) the_backend.rs --crate-name the_backend --crate-type dylib \\"}, {"sha": "bf5e476d80045711821a4f014efab4ed776bb231", "filename": "src/test/ui/consts/const-eval/assign-to-static-within-other-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static.stderr?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/assign-to-static-within-other-static.rs:10:5\n    |\n LL |     FOO = 5;\n-   |     ^^^^^^^ tried to modify a static's initial value from another static's initializer\n+   |     ^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n "}, {"sha": "acc6fb026cd696352e91f36eea106f3612343070", "filename": "src/test/ui/consts/miri_unleashed/mutating_global.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+// Make sure we cannot mutate globals.\n+\n+static mut GLOBAL: i32 = 0;\n+\n+const MUTATING_GLOBAL: () = {\n+    unsafe {\n+        GLOBAL = 99 //~ ERROR any use of this value will cause an error\n+        //~^ WARN skipping const checks\n+        //~| WARN skipping const checks\n+    }\n+};\n+\n+fn main() {}"}, {"sha": "4e67d2c0fb85e88721f290c0c482c20b39004f0c", "filename": "src/test/ui/consts/miri_unleashed/mutating_global.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutating_global.stderr?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -0,0 +1,29 @@\n+warning: skipping const checks\n+  --> $DIR/mutating_global.rs:9:9\n+   |\n+LL |         GLOBAL = 99\n+   |         ^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutating_global.rs:9:9\n+   |\n+LL |         GLOBAL = 99\n+   |         ^^^^^^\n+\n+error: any use of this value will cause an error\n+  --> $DIR/mutating_global.rs:9:9\n+   |\n+LL | / const MUTATING_GLOBAL: () = {\n+LL | |     unsafe {\n+LL | |         GLOBAL = 99\n+   | |         ^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n+LL | |\n+LL | |\n+LL | |     }\n+LL | | };\n+   | |__-\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "8db75dd63cf2a0e5357f7e65bf3ee69bd4d52a98", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.mut_refs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/static_mut_containing_mut_ref2.rs:7:45\n    |\n LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n-   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n "}, {"sha": "91f9dbd8d0b9efc8b1e385eebc9b604455af2daf", "filename": "src/test/ui/consts/static_mut_containing_mut_ref3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/static_mut_containing_mut_ref3.rs:3:31\n    |\n LL | static mut BAR: () = unsafe { FOO.0 = 99; };\n-   |                               ^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+   |                               ^^^^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n "}, {"sha": "35a2956ee26b8715b7bedd632a27f5c86dc5ab91", "filename": "src/test/ui/rfc-2091-track-caller/std-panic-locations.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -2,10 +2,14 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![feature(option_expect_none, option_unwrap_none)]\n+#![allow(unconditional_panic)]\n \n //! Test that panic locations for `#[track_caller]` functions in std have the correct\n //! location reported.\n \n+use std::collections::{BTreeMap, HashMap, VecDeque};\n+use std::ops::{Index, IndexMut};\n+\n fn main() {\n     // inspect the `PanicInfo` we receive to ensure the right file is the source\n     std::panic::set_hook(Box::new(|info| {\n@@ -35,4 +39,22 @@ fn main() {\n     let fine: Result<(), ()> = Ok(());\n     assert_panicked(|| fine.unwrap_err());\n     assert_panicked(|| fine.expect_err(\"\"));\n+\n+    let mut small = [0]; // the implementation backing str, vec, etc\n+    assert_panicked(move || { small.index(1); });\n+    assert_panicked(move || { small[1]; });\n+    assert_panicked(move || { small.index_mut(1); });\n+    assert_panicked(move || { small[1] += 1; });\n+\n+    let sorted: BTreeMap<bool, bool> = Default::default();\n+    assert_panicked(|| { sorted.index(&false); });\n+    assert_panicked(|| { sorted[&false]; });\n+\n+    let unsorted: HashMap<bool, bool> = Default::default();\n+    assert_panicked(|| { unsorted.index(&false); });\n+    assert_panicked(|| { unsorted[&false]; });\n+\n+    let weirdo: VecDeque<()> = Default::default();\n+    assert_panicked(|| { weirdo.index(1); });\n+    assert_panicked(|| { weirdo[1]; });\n }"}, {"sha": "6c2bd13d433ad7f99ad93a8f72ca141130d79037", "filename": "src/test/ui/write-to-static-mut-in-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02046a5d402c789c006d0da7662f800fe3c45faf/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr?ref=02046a5d402c789c006d0da7662f800fe3c45faf", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/write-to-static-mut-in-static.rs:2:33\n    |\n LL | pub static mut B: () = unsafe { A = 1; };\n-   |                                 ^^^^^ tried to modify a static's initial value from another static's initializer\n+   |                                 ^^^^^ modifying a static's initial value from another static's initializer\n \n error[E0391]: cycle detected when const-evaluating `C`\n   --> $DIR/write-to-static-mut-in-static.rs:5:34"}]}