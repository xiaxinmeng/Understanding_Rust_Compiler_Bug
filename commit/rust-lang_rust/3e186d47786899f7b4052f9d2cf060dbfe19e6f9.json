{"sha": "3e186d47786899f7b4052f9d2cf060dbfe19e6f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMTg2ZDQ3Nzg2ODk5ZjdiNDA1MmY5ZDJjZjA2MGRiZmUxOWU2Zjk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-19T13:17:57Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-19T13:17:57Z"}, "message": "internal: resolve attributes in name resolution", "tree": {"sha": "695bb45a2202570fa1b20448a84b8b92139c2473", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/695bb45a2202570fa1b20448a84b8b92139c2473"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e186d47786899f7b4052f9d2cf060dbfe19e6f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e186d47786899f7b4052f9d2cf060dbfe19e6f9", "html_url": "https://github.com/rust-lang/rust/commit/3e186d47786899f7b4052f9d2cf060dbfe19e6f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e186d47786899f7b4052f9d2cf060dbfe19e6f9/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "312f1fe20a6a0a8e69834c66f51b9abc9db5e0ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/312f1fe20a6a0a8e69834c66f51b9abc9db5e0ce", "html_url": "https://github.com/rust-lang/rust/commit/312f1fe20a6a0a8e69834c66f51b9abc9db5e0ce"}], "stats": {"total": 131, "additions": 128, "deletions": 3}, "files": [{"sha": "5cc7f2df659393381ef99c5c192d387fe4a57287", "filename": "crates/hir_def/src/intern.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e186d47786899f7b4052f9d2cf060dbfe19e6f9/crates%2Fhir_def%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e186d47786899f7b4052f9d2cf060dbfe19e6f9/crates%2Fhir_def%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fintern.rs?ref=3e186d47786899f7b4052f9d2cf060dbfe19e6f9", "patch": "@@ -4,7 +4,7 @@\n \n use std::{\n     collections::HashMap,\n-    fmt::{self, Debug},\n+    fmt::{self, Debug, Display},\n     hash::{BuildHasherDefault, Hash, Hasher},\n     ops::Deref,\n     sync::Arc,\n@@ -171,6 +171,12 @@ impl<T: Debug + Internable + ?Sized> Debug for Interned<T> {\n     }\n }\n \n+impl<T: Display + Internable + ?Sized> Display for Interned<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self.arc).fmt(f)\n+    }\n+}\n+\n pub struct InternStorage<T: ?Sized> {\n     map: OnceCell<InternMap<T>>,\n }"}, {"sha": "c314b5309fd64c297055020c13a9d7df5d369342", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 121, "deletions": 2, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3e186d47786899f7b4052f9d2cf060dbfe19e6f9/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e186d47786899f7b4052f9d2cf060dbfe19e6f9/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3e186d47786899f7b4052f9d2cf060dbfe19e6f9", "patch": "@@ -21,6 +21,7 @@ use syntax::ast;\n \n use crate::{\n     attr::{AttrId, Attrs},\n+    builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n     intern::Interned,\n@@ -99,6 +100,7 @@ pub(super) fn collect_defs(\n         proc_macros,\n         exports_proc_macros: false,\n         from_glob_import: Default::default(),\n+        ignore_attrs_on: FxHashSet::default(),\n     };\n     match block {\n         Some(block) => {\n@@ -217,6 +219,7 @@ struct MacroDirective {\n enum MacroDirectiveKind {\n     FnLike { ast_id: AstIdWithPath<ast::MacroCall>, fragment: FragmentKind },\n     Derive { ast_id: AstIdWithPath<ast::Item>, derive_attr: AttrId },\n+    Attr { ast_id: AstIdWithPath<ast::Item>, attr: AttrId, mod_item: ModItem },\n }\n \n struct DefData<'a> {\n@@ -243,6 +246,7 @@ struct DefCollector<'a> {\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n     exports_proc_macros: bool,\n     from_glob_import: PerNsGlobImports,\n+    ignore_attrs_on: FxHashSet<ModItem>,\n }\n \n impl DefCollector<'_> {\n@@ -297,7 +301,10 @@ impl DefCollector<'_> {\n             self.resolve_imports();\n \n             match self.resolve_macros() {\n-                ReachedFixedPoint::Yes => break,\n+                ReachedFixedPoint::Yes => match self.reseed_with_unresolved_attributes() {\n+                    ReachedFixedPoint::Yes => break,\n+                    ReachedFixedPoint::No => i += 1,\n+                },\n                 ReachedFixedPoint::No => i += 1,\n             }\n             if i == FIXED_POINT_LIMIT {\n@@ -343,6 +350,50 @@ impl DefCollector<'_> {\n         }\n     }\n \n+    /// When the fixed-point loop reaches a stable state, we might still have some unresolved\n+    /// attributes (or unexpanded attribute proc macros) left over. This takes them, and feeds the\n+    /// item they're applied to back into name resolution.\n+    ///\n+    /// This effectively ignores the fact that the macro is there and just treats the items as\n+    /// normal code.\n+    ///\n+    /// This improves UX when proc macros are turned off or don't work, and replicates the behavior\n+    /// before we supported proc. attribute macros.\n+    fn reseed_with_unresolved_attributes(&mut self) -> ReachedFixedPoint {\n+        let mut added_items = false;\n+        let unexpanded_macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        for directive in &unexpanded_macros {\n+            if let MacroDirectiveKind::Attr { mod_item, .. } = &directive.kind {\n+                // Make sure to only add such items once.\n+                if !self.ignore_attrs_on.insert(*mod_item) {\n+                    continue;\n+                }\n+\n+                let file_id = self.def_map[directive.module_id].definition_source(self.db).file_id;\n+                let item_tree = self.db.file_item_tree(file_id);\n+                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                ModCollector {\n+                    def_collector: &mut *self,\n+                    macro_depth: directive.depth,\n+                    module_id: directive.module_id,\n+                    file_id,\n+                    item_tree: &item_tree,\n+                    mod_dir,\n+                }\n+                .collect(&[*mod_item]);\n+                added_items = true;\n+            }\n+        }\n+        self.unexpanded_macros = unexpanded_macros;\n+\n+        if added_items {\n+            // Continue name resolution with the new data.\n+            ReachedFixedPoint::No\n+        } else {\n+            ReachedFixedPoint::Yes\n+        }\n+    }\n+\n     /// Adds a definition of procedural macro `name` to the root module.\n     ///\n     /// # Notes on procedural macro resolution\n@@ -849,6 +900,9 @@ impl DefCollector<'_> {\n                         Err(UnresolvedMacro { .. }) => (),\n                     }\n                 }\n+                MacroDirectiveKind::Attr { .. } => {\n+                    // not yet :)\n+                }\n             }\n \n             true\n@@ -953,7 +1007,7 @@ impl DefCollector<'_> {\n                         ));\n                     }\n                 },\n-                MacroDirectiveKind::Derive { .. } => {\n+                MacroDirectiveKind::Derive { .. } | MacroDirectiveKind::Attr { .. } => {\n                     // FIXME: we might want to diagnose this too\n                 }\n             }\n@@ -1061,6 +1115,14 @@ impl ModCollector<'_, '_> {\n                     continue;\n                 }\n             }\n+\n+            if let Err(()) = self.resolve_attributes(&attrs, item) {\n+                // Do not process the item. It has at least one non-builtin attribute, which *must*\n+                // resolve to a proc macro (or fail to resolve), so we'll never see this item during\n+                // normal name resolution.\n+                continue;\n+            }\n+\n             let module = self.def_collector.def_map.module_id(self.module_id);\n \n             let mut def = None;\n@@ -1367,6 +1429,62 @@ impl ModCollector<'_, '_> {\n         res\n     }\n \n+    /// Resolves attributes on an item.\n+    ///\n+    /// Returns `Err` when some attributes could not be resolved to builtins and have been\n+    /// registered as unresolved.\n+    fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n+        fn is_builtin_attr(path: &ModPath) -> bool {\n+            if path.kind == PathKind::Plain {\n+                if let Some(tool_module) = path.segments().first() {\n+                    let tool_module = tool_module.to_string();\n+                    if builtin_attr::TOOL_MODULES.iter().any(|m| tool_module == *m) {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some(name) = path.as_ident() {\n+                    let name = name.to_string();\n+                    if builtin_attr::INERT_ATTRIBUTES\n+                        .iter()\n+                        .chain(builtin_attr::EXTRA_ATTRIBUTES)\n+                        .any(|attr| name == *attr)\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            false\n+        }\n+\n+        // We failed to resolve an attribute on this item earlier, and are falling back to treating\n+        // the item as-is.\n+        if self.def_collector.ignore_attrs_on.contains(&mod_item) {\n+            return Ok(());\n+        }\n+\n+        match attrs.iter().find(|attr| !is_builtin_attr(&attr.path)) {\n+            Some(non_builtin_attr) => {\n+                log::debug!(\"non-builtin attribute {}\", non_builtin_attr.path);\n+\n+                let ast_id = AstIdWithPath::new(\n+                    self.file_id,\n+                    mod_item.ast_id(self.item_tree),\n+                    non_builtin_attr.path.as_ref().clone(),\n+                );\n+                self.def_collector.unexpanded_macros.push(MacroDirective {\n+                    module_id: self.module_id,\n+                    depth: self.macro_depth + 1,\n+                    kind: MacroDirectiveKind::Attr { ast_id, attr: non_builtin_attr.id, mod_item },\n+                });\n+\n+                Err(())\n+            }\n+            None => Ok(()),\n+        }\n+    }\n+\n     fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::Item>) {\n         for derive in attrs.by_key(\"derive\").attrs() {\n             match derive.parse_derive() {\n@@ -1599,6 +1717,7 @@ mod tests {\n             proc_macros: Default::default(),\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n+            ignore_attrs_on: FxHashSet::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}]}