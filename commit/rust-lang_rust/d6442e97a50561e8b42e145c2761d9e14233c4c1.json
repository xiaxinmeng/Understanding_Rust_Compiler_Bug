{"sha": "d6442e97a50561e8b42e145c2761d9e14233c4c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NDQyZTk3YTUwNTYxZThiNDJlMTQ1YzI3NjFkOWUxNDIzM2M0YzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-09T23:02:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-09T23:02:51Z"}, "message": "auto merge of #4854 : thestinger/rust/oldmap, r=catamorphism", "tree": {"sha": "187ce1b6632bec9577819378aecaed51b178d3b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/187ce1b6632bec9577819378aecaed51b178d3b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6442e97a50561e8b42e145c2761d9e14233c4c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6442e97a50561e8b42e145c2761d9e14233c4c1", "html_url": "https://github.com/rust-lang/rust/commit/d6442e97a50561e8b42e145c2761d9e14233c4c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6442e97a50561e8b42e145c2761d9e14233c4c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fe6b1b6cfcdf52fd99f02b1d999c480e134e30f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe6b1b6cfcdf52fd99f02b1d999c480e134e30f", "html_url": "https://github.com/rust-lang/rust/commit/7fe6b1b6cfcdf52fd99f02b1d999c480e134e30f"}, {"sha": "4e6994dbfa3c32ef6a560c9ab2d940a5b032eef4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6994dbfa3c32ef6a560c9ab2d940a5b032eef4", "html_url": "https://github.com/rust-lang/rust/commit/4e6994dbfa3c32ef6a560c9ab2d940a5b032eef4"}], "stats": {"total": 389, "additions": 188, "deletions": 201}, "files": [{"sha": "db976b580c7f14f67c2890bf887ab5689495d78e", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -730,7 +730,7 @@ pub fn configure(opts: Options) -> Cargo {\n     need_dir(&c.libdir);\n     need_dir(&c.bindir);\n \n-    for sources.each_key_ref |&k| {\n+    for sources.each_key |&k| {\n         let mut s = sources.get(&k);\n         load_source_packages(&c, s);\n         sources.insert(k, s);\n@@ -748,7 +748,7 @@ pub fn configure(opts: Options) -> Cargo {\n }\n \n pub fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n-    for c.sources.each_value_ref |&v| {\n+    for c.sources.each_value |&v| {\n         for v.packages.each |p| {\n             b(v, p);\n         }\n@@ -1155,7 +1155,7 @@ pub fn cmd_install(c: &mut Cargo) {\n }\n \n pub fn sync(c: &Cargo) {\n-    for c.sources.each_key_ref |&k| {\n+    for c.sources.each_key |&k| {\n         let mut s = c.sources.get(&k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n@@ -1569,7 +1569,7 @@ pub fn cmd_list(c: &Cargo) {\n             }\n         }\n     } else {\n-        for c.sources.each_value_ref |&v| {\n+        for c.sources.each_value |&v| {\n             print_source(v);\n         }\n     }\n@@ -1636,7 +1636,7 @@ pub fn dump_sources(c: &Cargo) {\n         result::Ok(writer) => {\n             let mut hash = ~LinearMap::new();\n \n-            for c.sources.each_ref |&k, &v| {\n+            for c.sources.each |&k, &v| {\n                 let mut chash = ~LinearMap::new();\n \n                 chash.insert(~\"url\", json::String(v.url));\n@@ -1675,7 +1675,7 @@ pub fn copy_warn(srcfile: &Path, destfile: &Path) {\n \n pub fn cmd_sources(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n-        for c.sources.each_value_ref |&v| {\n+        for c.sources.each_value |&v| {\n             info(fmt!(\"%s (%s) via %s\",\n                       v.name, v.url, v.method));\n         }\n@@ -1686,7 +1686,7 @@ pub fn cmd_sources(c: &Cargo) {\n \n     match action {\n         ~\"clear\" => {\n-          for c.sources.each_key_ref |&k| {\n+          for c.sources.each_key |&k| {\n                 c.sources.remove(&k);\n             }\n \n@@ -1706,7 +1706,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            if c.sources.contains_key_ref(&name) {\n+            if c.sources.contains_key(&name) {\n                 error(fmt!(\"source already exists: %s\", name));\n             } else {\n                 c.sources.insert(name, @Source {\n@@ -1733,7 +1733,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            if c.sources.contains_key_ref(&name) {\n+            if c.sources.contains_key(&name) {\n                 c.sources.remove(&name);\n                 info(fmt!(\"removed source: %s\", name));\n             } else {"}, {"sha": "4cca6757cc39407691230ee261383225c2d77bd1", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -18,8 +18,7 @@ use core::os;\n use core::uint;\n use core::util;\n use core::vec;\n-use std::oldmap::HashMap;\n-use std::oldmap;\n+use core::hashmap::linear::LinearSet;\n \n pure fn not_win32(os: session::os) -> bool {\n   match os {\n@@ -187,16 +186,14 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n }\n \n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n-    let set = oldmap::HashMap();\n+    let mut set = LinearSet::new();\n     let mut minimized = ~[];\n     for rpaths.each |rpath| {\n-        let s = rpath.to_str();\n-        if !set.contains_key_ref(&s) {\n-            minimized.push(/*bad*/copy *rpath);\n-            set.insert(s, ());\n+        if set.insert(rpath.to_str()) {\n+            minimized.push(copy *rpath);\n         }\n     }\n-    return minimized;\n+    minimized\n }\n \n #[cfg(unix)]"}, {"sha": "73ec872b6a6ecfe9cc15c6f7e0c26f115d7eb9ec", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -86,13 +86,13 @@ pub fn set_crate_data(cstore: @mut CStore,\n }\n \n pub fn have_crate_data(cstore: @mut CStore, cnum: ast::crate_num) -> bool {\n-    return cstore.metas.contains_key_ref(&cnum);\n+    cstore.metas.contains_key(&cnum)\n }\n \n pub fn iter_crate_data(cstore: @mut CStore,\n                        i: fn(ast::crate_num, crate_metadata)) {\n     let metas = cstore.metas;\n-    for metas.each_ref |&k, &v| {\n+    for metas.each |&k, &v| {\n         i(k, v);\n     }\n }\n@@ -148,7 +148,7 @@ pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n     let mut result = ~[];\n \n     let use_crate_map = cstore.use_crate_map;\n-    for use_crate_map.each_value_ref |&cnum| {\n+    for use_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         debug!(\"Add hash[%s]: %s\", cdata.name, hash);"}, {"sha": "fcc1a4e806dffeefcc309557eba8f0a23b692a90", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -99,7 +99,7 @@ pub enum encode_ctxt = {\n };\n \n pub fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n-    ecx.reachable.contains_key_ref(&id)\n+    ecx.reachable.contains_key(&id)\n }\n \n fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Encoder, name: ident) {"}, {"sha": "251fec684865c73628afc8a492b10126d63cfa3c", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -689,7 +689,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n \n     self.check_for_conflicting_loans(expr.id);\n \n-    if self.bccx.moves_map.contains_key_ref(&expr.id) {\n+    if self.bccx.moves_map.contains_key(&expr.id) {\n         self.check_move_out_from_expr(expr);\n     }\n \n@@ -710,15 +710,15 @@ fn check_loans_in_expr(expr: @ast::expr,\n       }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n-      if self.bccx.method_map.contains_key_ref(&expr.id) => {\n+      if self.bccx.method_map.contains_key(&expr.id) => {\n         self.check_call(expr,\n                         None,\n                         expr.callee_id,\n                         expr.span,\n                         ~[rval]);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n-      if self.bccx.method_map.contains_key_ref(&expr.id) => {\n+      if self.bccx.method_map.contains_key(&expr.id) => {\n         self.check_call(expr,\n                         None,\n                         expr.callee_id,"}, {"sha": "d4c45828858be7fbdfb74f755c18358b3cac7339", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -207,7 +207,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       ast::expr_binary(_, rcvr, _) |\n       ast::expr_unary(_, rcvr) |\n       ast::expr_assign_op(_, rcvr, _)\n-      if self.bccx.method_map.contains_key_ref(&ex.id) => {\n+      if self.bccx.method_map.contains_key(&ex.id) => {\n         // Receivers in method calls are always passed by ref.\n         //\n         // Here, in an overloaded operator, the call is this expression,\n@@ -244,7 +244,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       // }\n \n       ast::expr_field(rcvr, _, _)\n-      if self.bccx.method_map.contains_key_ref(&ex.id) => {\n+      if self.bccx.method_map.contains_key(&ex.id) => {\n         // Receivers in method calls are always passed by ref.\n         //\n         // Here, the field a.b is in fact a closure.  Eventually, this"}, {"sha": "097f0579362a90167e73ec8fa9915615cd63b101", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -375,7 +375,7 @@ impl PreserveCtxt {\n                 // scope_id;`. Though that would potentially re-introduce\n                 // the ICE. See #3511 for more details.\n                 let scope_to_use = if\n-                    self.bccx.stmt_map.contains_key_ref(&scope_id) {\n+                    self.bccx.stmt_map.contains_key(&scope_id) {\n                     // Root it in its parent scope, b/c\n                     // trans won't introduce a new scope for the\n                     // stmt"}, {"sha": "6cca576fa130ba1437a6141adce68c1acb9cf664", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -102,7 +102,7 @@ pub fn check_expr(sess: Session,\n           }\n           expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n           expr_binary(_, _, _) | expr_unary(_, _) => {\n-            if method_map.contains_key_ref(&e.id) {\n+            if method_map.contains_key(&e.id) {\n                 sess.span_err(e.span, ~\"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }"}, {"sha": "1a3e42511295e1ebc46d4d86d178bd58fa0d1618", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -59,7 +59,7 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n         return false;\n     }\n \n-    !cx.moves_map.contains_key_ref(&expr.id)\n+    !cx.moves_map.contains_key(&expr.id)\n }\n \n pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n@@ -734,7 +734,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                     by_ref_span = Some(span);\n                 }\n                 bind_infer => {\n-                    if cx.moves_map.contains_key_ref(&id) {\n+                    if cx.moves_map.contains_key(&id) {\n                         any_by_move = true;\n                     }\n                 }\n@@ -774,7 +774,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     pat_ident(_, _, sub) => {\n-                        if cx.moves_map.contains_key_ref(&p.id) {\n+                        if cx.moves_map.contains_key(&p.id) {\n                             check_move(p, sub);\n                         }\n                     }\n@@ -800,7 +800,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                                 behind_bad_pointer);\n \n                         if behind_bad_pointer &&\n-                            cx.moves_map.contains_key_ref(&pat.id)\n+                            cx.moves_map.contains_key(&pat.id)\n                         {\n                             cx.tcx.sess.span_err(\n                                 pat.span,"}, {"sha": "0d3b7c36f6d921f8ba6229b5de78f9c265c1d6ee", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -69,7 +69,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n                       }\n                       if i == depth { // Made it to end of loop\n                         let dnum = ast_util::def_id_of_def(def).node;\n-                        if !seen.contains_key_ref(&dnum) {\n+                        if !seen.contains_key(&dnum) {\n                             refs.push(@freevar_entry {\n                                 def: def,\n                                 span: expr.span,"}, {"sha": "6bcc71514d4a343e59aa636d2318544a7e8c8b4b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -391,7 +391,7 @@ impl LanguageItemCollector {\n     }\n \n     fn check_completeness() {\n-        for self.item_refs.each_ref |&key, &item_ref| {\n+        for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", key));"}, {"sha": "487148ddd97d7cabdec0f1c808eff98a2aa788c4", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -400,7 +400,7 @@ pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n                     sess: sess});\n \n     // Install defaults.\n-    for cx.dict.each_value_ref |&spec| {\n+    for cx.dict.each_value |&spec| {\n         cx.set_level(spec.lint, spec.default);\n     }\n "}, {"sha": "fd9271af6c6d8f7b93b1ea227b3e8899e42035d2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -340,7 +340,7 @@ pub impl &mem_categorization_ctxt {\n         let expr_ty = tcx.ty(expr);\n         match expr.node {\n           ast::expr_unary(ast::deref, e_base) => {\n-            if self.method_map.contains_key_ref(&expr.id) {\n+            if self.method_map.contains_key(&expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n@@ -349,7 +349,7 @@ pub impl &mem_categorization_ctxt {\n           }\n \n           ast::expr_field(base, f_name, _) => {\n-            if self.method_map.contains_key_ref(&expr.id) {\n+            if self.method_map.contains_key(&expr.id) {\n                 return self.cat_method_ref(expr, expr_ty);\n             }\n \n@@ -358,7 +358,7 @@ pub impl &mem_categorization_ctxt {\n           }\n \n           ast::expr_index(base, _) => {\n-            if self.method_map.contains_key_ref(&expr.id) {\n+            if self.method_map.contains_key(&expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n "}, {"sha": "b23066c1d96921504dcec9d4ad12cc6572864fc5", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -668,7 +668,7 @@ impl VisitContext {\n                                arg_exprs: &[@expr],\n                                visitor: vt<VisitContext>) -> bool\n     {\n-        if !self.method_map.contains_key_ref(&expr.id) {\n+        if !self.method_map.contains_key(&expr.id) {\n             return false;\n         }\n \n@@ -799,7 +799,7 @@ impl VisitContext {\n             for arm.pats.each |pat| {\n                 let mut found = false;\n                 do pat_bindings(self.tcx.def_map, *pat) |_, node_id, _, _| {\n-                    if moves_map.contains_key_ref(&node_id) {\n+                    if moves_map.contains_key(&node_id) {\n                         found = true;\n                     }\n                 }"}, {"sha": "5b2d3c9bb96cd579b7a7ab1e63afbac972fc8a86", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -296,7 +296,7 @@ pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n       _ => {}\n     };\n \n-    if new_cx.root_exprs.contains_key_ref(&expr.id) {\n+    if new_cx.root_exprs.contains_key(&expr.id) {\n         new_cx.parent = Some(expr.id);\n     }\n \n@@ -840,7 +840,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        for region_paramd_items.each_ref |&key, &value| {\n+        for region_paramd_items.each |&key, &value| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "ba550dbbde8ed62b266fb685d3ae743e6acd52f1", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -1942,7 +1942,7 @@ pub impl Resolver {\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n-        for module_.children.each_value_ref |&child_node| {\n+        for module_.children.each_value |&child_node| {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -1953,7 +1953,7 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value_ref |&child_module| {\n+        for module_.anonymous_children.each_value |&child_module| {\n             self.resolve_imports_for_module_subtree(child_module);\n         }\n     }\n@@ -2241,7 +2241,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key_ref(&target);\n+        assert module_.import_resolutions.contains_key(&target);\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match value_result {\n@@ -2400,7 +2400,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key_ref(&target);\n+        assert module_.import_resolutions.contains_key(&target);\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match module_result {\n@@ -2461,7 +2461,7 @@ pub impl Resolver {\n         assert containing_module.glob_count == 0;\n \n         // Add all resolved imports from the containing module.\n-        for containing_module.import_resolutions.each_ref\n+        for containing_module.import_resolutions.each\n                 |&ident, &target_import_resolution| {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n@@ -2512,7 +2512,7 @@ pub impl Resolver {\n         }\n \n         // Add all children from the containing module.\n-        for containing_module.children.each_ref |&ident, &name_bindings| {\n+        for containing_module.children.each |&ident, &name_bindings| {\n             let mut dest_import_resolution;\n             match module_.import_resolutions.find(&ident) {\n                 None => {\n@@ -3182,7 +3182,7 @@ pub impl Resolver {\n         }\n \n         // Descend into children and anonymous children.\n-        for module_.children.each_value_ref |&child_node| {\n+        for module_.children.each_value |&child_node| {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n@@ -3193,7 +3193,7 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value_ref |&module_| {\n+        for module_.anonymous_children.each_value |&module_| {\n             self.report_unresolved_imports(module_);\n         }\n     }\n@@ -3238,7 +3238,7 @@ pub impl Resolver {\n \n         self.record_exports_for_module(module_);\n \n-        for module_.children.each_value_ref |&child_name_bindings| {\n+        for module_.children.each_value |&child_name_bindings| {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -3249,7 +3249,7 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value_ref |&child_module| {\n+        for module_.anonymous_children.each_value |&child_module| {\n             self.record_exports_for_module_subtree(child_module);\n         }\n     }\n@@ -3297,7 +3297,7 @@ pub impl Resolver {\n     }\n \n     fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n-        for module_.children.each_ref |ident, namebindings| {\n+        for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n@@ -3312,7 +3312,7 @@ pub impl Resolver {\n                                              false);\n         }\n \n-        for module_.import_resolutions.each_ref |ident, importresolution| {\n+        for module_.import_resolutions.each |ident, importresolution| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        self.session.str_of(*ident));\n@@ -4102,7 +4102,7 @@ pub impl Resolver {\n         for arm.pats.eachi() |i, p| {\n             let map_i = self.binding_mode_map(*p);\n \n-            for map_0.each_ref |&key, &binding_0| {\n+            for map_0.each |&key, &binding_0| {\n                 match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n@@ -4123,8 +4123,8 @@ pub impl Resolver {\n                 }\n             }\n \n-            for map_i.each_ref |&key, &binding| {\n-                if !map_0.contains_key_ref(&key) {\n+            for map_i.each |&key, &binding| {\n+                if !map_0.contains_key(&key) {\n                     self.session.span_err(\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n@@ -4353,7 +4353,7 @@ pub impl Resolver {\n \n                             match bindings_list {\n                                 Some(bindings_list)\n-                                if !bindings_list.contains_key_ref(&ident)\n+                                if !bindings_list.contains_key(&ident)\n                                     => {\n                                     let last_rib = (*self.value_ribs).last();\n                                     last_rib.bindings.insert(ident,\n@@ -4426,18 +4426,18 @@ pub impl Resolver {\n                 pat_struct(path, _, _) => {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n-                                if self.structs.contains_key_ref(&class_id)\n+                                if self.structs.contains_key(&class_id)\n                                      => {\n                             let class_def = def_struct(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n                         Some(definition @ def_struct(class_id))\n-                                if self.structs.contains_key_ref(&class_id)\n+                                if self.structs.contains_key(&class_id)\n                                      => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         Some(definition @ def_variant(_, variant_id))\n-                                if self.structs.contains_key_ref(&variant_id)\n+                                if self.structs.contains_key(&variant_id)\n                                      => {\n                             self.record_def(pattern.id, definition);\n                         }\n@@ -4886,12 +4886,12 @@ pub impl Resolver {\n \n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n-                            if self.structs.contains_key_ref(&class_id) => {\n+                            if self.structs.contains_key(&class_id) => {\n                         let class_def = def_struct(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))\n-                            if self.structs.contains_key_ref(&class_id) => {\n+                            if self.structs.contains_key(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n                     _ => {\n@@ -5035,7 +5035,7 @@ pub impl Resolver {\n             }\n \n             // Look for trait children.\n-            for search_module.children.each_value_ref |&child_name_bindings| {\n+            for search_module.children.each_value |&child_name_bindings| {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n                     Some(def) => {\n                         match def {\n@@ -5055,7 +5055,7 @@ pub impl Resolver {\n             }\n \n             // Look for imports.\n-            for search_module.import_resolutions.each_value_ref\n+            for search_module.import_resolutions.each_value\n                     |&import_resolution| {\n \n                 match import_resolution.target_for_namespace(TypeNS) {\n@@ -5115,7 +5115,7 @@ pub impl Resolver {\n                self.session.str_of(name));\n \n         match self.trait_info.find(&trait_def_id) {\n-            Some(trait_info) if trait_info.contains_key_ref(&name) => {\n+            Some(trait_info) if trait_info.contains_key(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n@@ -5223,7 +5223,7 @@ pub impl Resolver {\n \n         self.check_for_unused_imports_in_module(module_);\n \n-        for module_.children.each_value_ref |&child_name_bindings| {\n+        for module_.children.each_value |&child_name_bindings| {\n             match (*child_name_bindings).get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -5235,13 +5235,13 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each_value_ref |&child_module| {\n+        for module_.anonymous_children.each_value |&child_module| {\n             self.check_for_unused_imports_in_module_subtree(child_module);\n         }\n     }\n \n     fn check_for_unused_imports_in_module(module_: @Module) {\n-        for module_.import_resolutions.each_value_ref |&import_resolution| {\n+        for module_.import_resolutions.each_value |&import_resolution| {\n             // Ignore dummy spans for things like automatically injected\n             // imports for the prelude, and also don't warn about the same\n             // import statement being unused more than once.\n@@ -5306,12 +5306,12 @@ pub impl Resolver {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n-        for module_.children.each_key_ref |&name| {\n+        for module_.children.each_key |&name| {\n             debug!(\"* %s\", self.session.str_of(name));\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.each_ref |&name, &import_resolution| {\n+        for module_.import_resolutions.each |&name, &import_resolution| {\n             let mut value_repr;\n             match (*import_resolution).target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "2369a63e544899a99dd54e3f17c91106af128074", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -1096,7 +1096,7 @@ pub fn store_non_ref_bindings(bcx: block,\n      */\n \n     let mut bcx = bcx;\n-    for data.bindings_map.each_value_ref |&binding_info| {\n+    for data.bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n             TrByValue(is_move, lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n@@ -1130,7 +1130,7 @@ pub fn insert_lllocals(bcx: block,\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n      * the bindings. */\n \n-    for data.bindings_map.each_value_ref |&binding_info| {\n+    for data.bindings_map.each_value |&binding_info| {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1203,7 +1203,7 @@ pub fn compile_guard(bcx: block,\n \n     fn drop_bindings(bcx: block, data: &ArmData) -> block {\n         let mut bcx = bcx;\n-        for data.bindings_map.each_value_ref |&binding_info| {\n+        for data.bindings_map.each_value |&binding_info| {\n             match binding_info.trmode {\n                 TrByValue(_, llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n@@ -1598,7 +1598,7 @@ pub fn trans_match_inner(scope_cx: block,\n                     // but during matching we need to store a *T as explained\n                     // above\n                     let is_move =\n-                        scope_cx.ccx().maps.moves_map.contains_key_ref(&p_id);\n+                        scope_cx.ccx().maps.moves_map.contains_key(&p_id);\n                     llmatch = alloca(bcx, T_ptr(llvariable_ty));\n                     trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n                 }"}, {"sha": "ced47bb5681b16fb366008be3e770e891515562e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -169,7 +169,7 @@ pub fn get_extern_fn(externs: ExternMap,\n                      name: @str,\n                      cc: lib::llvm::CallConv,\n                      ty: TypeRef) -> ValueRef {\n-    if externs.contains_key_ref(&name) { return externs.get(&name); }\n+    if externs.contains_key(&name) { return externs.get(&name); }\n     let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name, f);\n     return f;\n@@ -178,7 +178,7 @@ pub fn get_extern_fn(externs: ExternMap,\n pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n                         name: @str, ty: TypeRef) -> ValueRef {\n     unsafe {\n-        if externs.contains_key_ref(&name) { return externs.get(&name); }\n+        if externs.contains_key(&name) { return externs.get(&name); }\n         let c = str::as_c_str(name, |buf| {\n             llvm::LLVMAddGlobal(llmod, ty, buf)\n         });\n@@ -448,7 +448,7 @@ pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n     // XXX: Bad copy.\n-    if ccx.all_llvm_symbols.contains_key_ref(&sym) {\n+    if ccx.all_llvm_symbols.contains_key(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     ccx.all_llvm_symbols.insert(sym, ());\n@@ -2477,7 +2477,7 @@ pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             ccx.sess.bug(~\"get_item_val(): unexpected variant\")\n           }\n         };\n-        if !(exprt || ccx.reachable.contains_key_ref(&id)) {\n+        if !(exprt || ccx.reachable.contains_key(&id)) {\n             lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n         }\n         ccx.item_vals.insert(id, val);\n@@ -2800,7 +2800,7 @@ pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n         lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     }\n     let mut elts: ~[ValueRef] = ~[];\n-    for ccx.module_data.each_ref |&key, &val| {\n+    for ccx.module_data.each |&key, &val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n@@ -3084,7 +3084,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n \n         if ccx.sess.count_llvm_insns() {\n-            for ccx.stats.llvm_insns.each_ref |&k, &v| {\n+            for ccx.stats.llvm_insns.each |&k, &v| {\n                 io::println(fmt!(\"%-7u %s\", v, k));\n             }\n         }"}, {"sha": "81fa221aac4de6cfde8705e85906d4db60245f17", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -674,8 +674,7 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                assert !bcx.ccx().maps.moves_map.contains_key_ref(\n-                    &arg_expr.id);\n+                assert !bcx.ccx().maps.moves_map.contains_key(&arg_expr.id);\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n@@ -685,15 +684,15 @@ pub fn trans_arg_expr(bcx: block,\n                         // the explicit self code currently passes by-ref, it\n                         // does not hold.\n                         //\n-                        //assert !bcx.ccx().maps.moves_map.contains_key_ref(\n+                        //assert !bcx.ccx().maps.moves_map.contains_key(\n                         //    &arg_expr.id);\n                         val = arg_datum.to_ref_llval(bcx);\n                     }\n \n                     ast::by_val => {\n                         // NB: avoid running the take glue.\n \n-                        assert !bcx.ccx().maps.moves_map.contains_key_ref(\n+                        assert !bcx.ccx().maps.moves_map.contains_key(\n                             &arg_expr.id);\n                         val = arg_datum.to_value_llval(bcx);\n                     }"}, {"sha": "bcf796caa7a4adfedc4a310ad44ccbd9e381c829", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -132,7 +132,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n     if !ast_util::is_local(def_id) {\n         cx.tcx.sess.bug(~\"cross-crate constants\");\n     }\n-    if !cx.const_values.contains_key_ref(&def_id.node) {\n+    if !cx.const_values.contains_key(&def_id.node) {\n         match cx.tcx.items.get(&def_id.node) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_const(_, subexpr), _"}, {"sha": "792c5958822e036c9e764f9056636c476805a80f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -186,7 +186,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     // XXX: Bad copy.\n     let modname = path_str(ccx.sess, copy modpath);\n \n-    let global = if ccx.module_data.contains_key_ref(&modname) {\n+    let global = if ccx.module_data.contains_key(&modname) {\n         ccx.module_data.get(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq("}, {"sha": "d301a31357be3b1836e46fc627ddf8f903736db4", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -223,7 +223,7 @@ pub impl Datum {\n          * `id` is located in the move table, but copies otherwise.\n          */\n \n-        if bcx.ccx().maps.moves_map.contains_key_ref(&id) {\n+        if bcx.ccx().maps.moves_map.contains_key(&id) {\n             self.move_to(bcx, action, dst)\n         } else {\n             self.copy_to(bcx, action, dst)"}, {"sha": "f50cadc96712416dc108c271e04c31999e938923", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -117,7 +117,7 @@ pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n }\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let existing = if cache.contains_key_ref(&mdtag) {\n+    let existing = if cache.contains_key(&mdtag) {\n         cache.get(&mdtag)\n     } else {\n         ~[]\n@@ -176,7 +176,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache,\n                             eq_fn: fn(md: T) -> bool)\n                          -> Option<T> {\n     unsafe {\n-        if cache.contains_key_ref(&mdtag) {\n+        if cache.contains_key(&mdtag) {\n             let items = cache.get(&mdtag);\n             for items.each |item| {\n                 let md: T = md_from_metadata::<T>(*item);"}, {"sha": "cab2adc43faa6d16d9684bf8a21f7a21287a618d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -265,7 +265,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n-    if bcx.tcx().adjustments.contains_key_ref(&expr.id) {\n+    if bcx.tcx().adjustments.contains_key(&expr.id) {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n         let datumblock = trans_to_datum(bcx, expr);\n@@ -426,7 +426,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         ast::expr_binary(op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            assert !bcx.ccx().maps.method_map.contains_key_ref(&expr.id);\n+            assert !bcx.ccx().maps.method_map.contains_key(&expr.id);\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n@@ -1215,7 +1215,7 @@ fn trans_unary_datum(bcx: block,\n     assert op != ast::deref;\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert !bcx.ccx().maps.method_map.contains_key_ref(&un_expr.id);\n+    assert !bcx.ccx().maps.method_map.contains_key(&un_expr.id);\n \n     let un_ty = expr_ty(bcx, un_expr);\n     let sub_ty = expr_ty(bcx, sub_expr);"}, {"sha": "08d22a4fbf0e2eedf6bc1debb769384118b2093e", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -384,7 +384,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name);\n     let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n@@ -762,7 +762,7 @@ pub fn emit_tydescs(ccx: @crate_ctxt) {\n     let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n-    for ccx.tydescs.each_value_ref |&val| {\n+    for ccx.tydescs.each_value |&val| {\n         let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n         let ti = val;\n "}, {"sha": "75e494f7bfcd977c9fb5bfdadc113f3c4fb4ae27", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -180,7 +180,7 @@ pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n \n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key_ref(&t) { return cx.enum_sizes.get(&t); }\n+    if cx.enum_sizes.contains_key(&t) { return cx.enum_sizes.get(&t); }\n     match ty::get(t).sty {\n       ty::ty_enum(tid, ref substs) => {\n         // Compute max(variant sizes)."}, {"sha": "fb487b98e152f28f202ea9d8ff790b9031e161b1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -871,7 +871,7 @@ pub fn trans_trait_cast(bcx: block,\n     match vstore {\n         ty::vstore_slice(*) | ty::vstore_box => {\n             let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n-            if bcx.tcx().legacy_boxed_traits.contains_key_ref(&id) {\n+            if bcx.tcx().legacy_boxed_traits.contains_key(&id) {\n                 // Allocate an @ box and store the value into it\n                 let {bcx: new_bcx, box: llbox, body: body} =\n                     malloc_boxed(bcx, v_ty);"}, {"sha": "f77aa33407d105d6a475bb49c4e2aa9f0f620927", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -95,7 +95,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n }\n \n fn traverse_public_item(cx: ctx, item: @item) {\n-    if cx.rmap.contains_key_ref(&item.id) { return; }\n+    if cx.rmap.contains_key(&item.id) { return; }\n     cx.rmap.insert(item.id, ());\n     match /*bad*/copy item.node {\n       item_mod(m) => traverse_public_mod(cx, item.id, m),\n@@ -145,7 +145,7 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n }\n \n fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n-    if cx.rmap.contains_key_ref(&ty.id) { return; }\n+    if cx.rmap.contains_key(&ty.id) { return; }\n     cx.rmap.insert(ty.id, ());\n \n     match ty.node {"}, {"sha": "16677530ecd1582ccf1388ffc6a00c0c0a20c401", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -331,7 +331,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                  -> block {\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&tydesc);\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc);\n     let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n     let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {"}, {"sha": "84a19cd4c04773770c9ac0f4105d96c05b61667c", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -93,7 +93,7 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n-    if cx.lltypes.contains_key_ref(&t) { return cx.lltypes.get(&t); }\n+    if cx.lltypes.contains_key(&t) { return cx.lltypes.get(&t); }\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain"}, {"sha": "4350c62af6fc3155e1ca92a4cb2ab64723b718c4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -2778,7 +2778,7 @@ pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n }\n \n fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n-    return cx.node_type_substs.contains_key_ref(&id);\n+    cx.node_type_substs.contains_key(&id)\n }\n \n // Type accessors for substructures of types\n@@ -3082,7 +3082,7 @@ pub enum ExprKind {\n pub fn expr_kind(tcx: ctxt,\n                  method_map: typeck::method_map,\n                  expr: @ast::expr) -> ExprKind {\n-    if method_map.contains_key_ref(&expr.id) {\n+    if method_map.contains_key(&expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n         // exception, as its result is always unit.\n@@ -4338,7 +4338,7 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n                     let super_t = supertrait.tpt.ty;\n                     let d_id = ty_to_def_id(super_t).expect(\"supertrait \\\n                         should be a trait ty\");\n-                    if !supertrait_map.contains_key_ref(&d_id) {\n+                    if !supertrait_map.contains_key(&d_id) {\n                         supertrait_map.insert(d_id, super_t);\n                         trait_ty = super_t;\n                         seen_def_ids.push(d_id);"}, {"sha": "95bed1140500d48ffe8bd3fe573bf407f19f9a8b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -239,7 +239,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     // Report an error if not all the fields were specified.\n     if !etc {\n         for class_fields.eachi |i, field| {\n-            if found_fields.contains_key_ref(&i) {\n+            if found_fields.contains_key(&i) {\n                 loop;\n             }\n             tcx.sess.span_err(span,"}, {"sha": "463ae3201a4475c39043265d4f144e93874c43f9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -1172,12 +1172,11 @@ pub impl LookupContext {\n         match candidate.origin {\n             method_static(method_id) | method_self(method_id, _)\n                 | method_super(method_id, _) => {\n-                bad = self.tcx().destructors.contains_key_ref(&method_id);\n+                bad = self.tcx().destructors.contains_key(&method_id);\n             }\n             method_param(method_param { trait_id: trait_id, _ }) |\n             method_trait(trait_id, _, _) => {\n-                bad = self.tcx().destructor_for_type.contains_key_ref(\n-                    &trait_id);\n+                bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n             }\n         }\n "}, {"sha": "fda9702d58284d996b70d91641bbc5852c01a774", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -3208,8 +3208,8 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n-          assert tcx.intrinsic_defs.contains_key_ref(&tydesc_name);\n-          assert ccx.tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n+          assert tcx.intrinsic_defs.contains_key(&tydesc_name);\n+          assert ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name);\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(&tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(&ty_visitor_name);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,"}, {"sha": "c91607489ecece3a163193ae8d63a9ded5ff74c4", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -213,7 +213,7 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n             // `constrain_auto_ref()` on all exprs.  But that causes a\n             // lot of spurious errors because of how the region\n             // hierarchy is setup.\n-            if rcx.fcx.ccx.method_map.contains_key_ref(&callee.id) {\n+            if rcx.fcx.ccx.method_map.contains_key(&callee.id) {\n                 match callee.node {\n                     ast::expr_field(base, _, _) => {\n                         constrain_auto_ref(rcx, base);\n@@ -749,7 +749,7 @@ pub mod guarantor {\n         let _i = ::util::common::indenter();\n \n         let guarantor = {\n-            if rcx.fcx.ccx.method_map.contains_key_ref(&expr.id) {\n+            if rcx.fcx.ccx.method_map.contains_key(&expr.id) {\n                 None\n             } else {\n                 guarantor(rcx, expr)"}, {"sha": "410b4a3e33d6e6553e74898e4fae56013522f68d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -268,7 +268,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                         // im is one specific impl of trait_ty.\n \n                         // First, ensure we haven't processed this impl yet.\n-                        if impls_seen.contains_key_ref(&im.did) {\n+                        if impls_seen.contains_key(&im.did) {\n                             loop;\n                         }\n                         impls_seen.insert(im.did, ());"}, {"sha": "1b27619938146294afdea6cc60c5d09949911c83", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -141,7 +141,7 @@ fn maybe_resolve_type_vars_for_node(wbcx: @mut WbCtxt,\n                                     sp: span,\n                                     id: ast::node_id)\n                                  -> Option<ty::t> {\n-    if wbcx.fcx.inh.node_types.contains_key_ref(&id) {\n+    if wbcx.fcx.inh.node_types.contains_key(&id) {\n         resolve_type_vars_for_node(wbcx, sp, id)\n     } else {\n         None"}, {"sha": "5e51c216093009e943e42110f8c32e807c599b2e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -418,7 +418,7 @@ pub impl CoherenceChecker {\n         let coherence_info = &mut self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n-        for extension_methods.each_key_ref |&trait_id| {\n+        for extension_methods.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n@@ -503,7 +503,7 @@ pub impl CoherenceChecker {\n         }\n \n         for ty::trait_methods(tcx, trait_did).each |method| {\n-            if provided_method_idents.contains_key_ref(&method.ident) {\n+            if provided_method_idents.contains_key(&method.ident) {\n                 if !f(method) {\n                     break;\n                 }\n@@ -911,7 +911,7 @@ pub impl CoherenceChecker {\n         let tcx = self.crate_context.tcx;\n         let pmm = tcx.provided_methods;\n \n-        if pmm.contains_key_ref(&trait_def_id) { return; }\n+        if pmm.contains_key(&trait_def_id) { return; }\n \n         debug!(\"(adding default methods for trait) processing trait\");\n "}, {"sha": "982a8d7d9574f679a90ce4ed092fb02e2d3361b3", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -304,7 +304,7 @@ pub fn ensure_supertraits(ccx: @mut CrateCtxt,\n                           rp: Option<ty::region_variance>,\n                           trait_refs: &[@ast::trait_ref]) {\n     let tcx = ccx.tcx;\n-    if tcx.supertraits.contains_key_ref(&local_def(id)) { return; }\n+    if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n     let instantiated = dvec::DVec();\n     for trait_refs.each |trait_ref| {"}, {"sha": "027b99cc42192f393abaaa61e566cce4b5f1a79f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -1242,7 +1242,7 @@ impl RegionVarBindings {\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.each_ref |constraint, span| {\n+        for self.constraints.each |constraint, span| {\n             edges.push(GraphEdge {\n                 next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,"}, {"sha": "5273dbd30492f51cf5ba0c8a39d781c2281104ee", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -177,7 +177,7 @@ Available lint options:\n \n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0;\n-    for lint_dict.each_key_ref |&k| { max_key = uint::max(k.len(), max_key); }\n+    for lint_dict.each_key |&k| { max_key = uint::max(k.len(), max_key); }\n     fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n@@ -186,7 +186,7 @@ Available lint options:\n                      padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each_ref |&k, &v| {\n+    for lint_dict.each |&k, &v| {\n         let k = str::replace(k, ~\"_\", ~\"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),"}, {"sha": "cea6d17e35d7794ea8133c7aa5141089650ac3e0", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 58, "deletions": 64, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -76,7 +76,7 @@ pub mod chained {\n         FoundAfter(@Entry<K,V>, @Entry<K,V>)\n     }\n \n-    priv impl<K:Eq IterBytes Hash, V: Copy> T<K, V> {\n+    priv impl<K:Eq IterBytes Hash, V> T<K, V> {\n         pure fn search_rem(k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n@@ -90,15 +90,13 @@ pub mod chained {\n                   }\n                   Some(e1) => {\n                     comp += 1u;\n-                    unsafe {\n-                        if e1.hash == h && e1.key == *k {\n-                            debug!(\"search_tbl: present, comp %u, \\\n-                                    hash %u, idx %u\",\n-                                   comp, h, idx);\n-                            return FoundAfter(e0, e1);\n-                        } else {\n-                            e0 = e1;\n-                        }\n+                    if e1.hash == h && e1.key == *k {\n+                        debug!(\n+                            \"search_tbl: present, comp %u, hash %u, idx %u\",\n+                            comp, h, idx);\n+                        return FoundAfter(e0, e1);\n+                    } else {\n+                        e0 = e1;\n                     }\n                   }\n                 }\n@@ -114,14 +112,12 @@ pub mod chained {\n                 return NotFound;\n               }\n               Some(e) => {\n-                unsafe {\n-                    if e.hash == h && e.key == *k {\n-                        debug!(\"search_tbl: present, comp %u, hash %u, \\\n-                                idx %u\", 1u, h, idx);\n-                        return FoundFirst(idx, e);\n-                    } else {\n-                        return self.search_rem(k, h, idx, e);\n-                    }\n+                if e.hash == h && e.key == *k {\n+                    debug!(\"search_tbl: present, comp %u, hash %u, \\\n+                           idx %u\", 1u, h, idx);\n+                    return FoundFirst(idx, e);\n+                } else {\n+                    return self.search_rem(k, h, idx, e);\n                 }\n               }\n             }\n@@ -172,8 +168,8 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V> {\n-        pure fn contains_key_ref(&self, k: &K) -> bool {\n+    impl<K: Eq IterBytes Hash, V> T<K, V> {\n+        pure fn contains_key(&self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n               NotFound => false,\n@@ -225,13 +221,43 @@ pub mod chained {\n             }\n         }\n \n+        fn remove(k: &K) -> bool {\n+            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n+              NotFound => false,\n+              FoundFirst(idx, entry) => {\n+                self.count -= 1u;\n+                self.chains[idx] = entry.next;\n+                true\n+              }\n+              FoundAfter(eprev, entry) => {\n+                self.count -= 1u;\n+                eprev.next = entry.next;\n+                true\n+              }\n+            }\n+        }\n+\n+        pure fn each(&self, blk: fn(key: &K, value: &V) -> bool) {\n+            for self.each_entry |entry| {\n+                if !blk(&entry.key, &entry.value) { break; }\n+            }\n+        }\n+\n+        pure fn each_key(&self, blk: fn(key: &K) -> bool) {\n+            self.each(|k, _v| blk(k))\n+        }\n+\n+        pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+            self.each(|_k, v| blk(v))\n+        }\n+    }\n+\n+    impl<K: Eq IterBytes Hash Copy, V: Copy> T<K, V> {\n         pure fn find(&self, k: &K) -> Option<V> {\n-            unsafe {\n-                match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n-                  NotFound => None,\n-                  FoundFirst(_, entry) => Some(entry.value),\n-                  FoundAfter(_, entry) => Some(entry.value)\n-                }\n+            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n+              NotFound => None,\n+              FoundFirst(_, entry) => Some(entry.value),\n+              FoundAfter(_, entry) => Some(entry.value)\n             }\n         }\n \n@@ -297,36 +323,6 @@ pub mod chained {\n             }\n             option::unwrap(move opt_v)\n         }\n-\n-        fn remove(k: &K) -> bool {\n-            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n-              NotFound => false,\n-              FoundFirst(idx, entry) => {\n-                self.count -= 1u;\n-                self.chains[idx] = entry.next;\n-                true\n-              }\n-              FoundAfter(eprev, entry) => {\n-                self.count -= 1u;\n-                eprev.next = entry.next;\n-                true\n-              }\n-            }\n-        }\n-\n-        pure fn each_ref(&self, blk: fn(key: &K, value: &V) -> bool) {\n-            for self.each_entry |entry| {\n-                if !blk(&entry.key, &entry.value) { break; }\n-            }\n-        }\n-\n-        pure fn each_key_ref(&self, blk: fn(key: &K) -> bool) {\n-            self.each_ref(|k, _v| blk(k))\n-        }\n-\n-        pure fn each_value_ref(&self, blk: fn(value: &V) -> bool) {\n-            self.each_ref(|_k, v| blk(v))\n-        }\n     }\n \n     impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> T<K, V> {\n@@ -362,9 +358,7 @@ pub mod chained {\n \n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: ops::Index<K, V> {\n         pure fn index(&self, k: K) -> V {\n-            unsafe {\n-                self.get(&k)\n-            }\n+            self.get(&k)\n         }\n     }\n \n@@ -397,7 +391,7 @@ pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, key: K) -> bool {\n /// Convert a set into a vector.\n pub pure fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n     do vec::build_sized(s.len()) |push| {\n-        for s.each_key_ref() |&k| {\n+        for s.each_key() |&k| {\n             push(k);\n         }\n     }\n@@ -628,9 +622,9 @@ mod tests {\n     fn test_contains_key() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert (!map.contains_key_ref(&key));\n+        assert (!map.contains_key(&key));\n         map.insert(key, ~\"val\");\n-        assert (map.contains_key_ref(&key));\n+        assert (map.contains_key(&key));\n     }\n \n     #[test]\n@@ -648,10 +642,10 @@ mod tests {\n         let mut map = HashMap::<~str, ~str>();\n         map.insert(key, ~\"val\");\n         assert (map.len() == 1);\n-        assert (map.contains_key_ref(&key));\n+        assert (map.contains_key(&key));\n         map.clear();\n         assert (map.len() == 0);\n-        assert (!map.contains_key_ref(&key));\n+        assert (!map.contains_key(&key));\n     }\n \n     #[test]"}, {"sha": "d258393e3b954dfc11d5c6109d1ef5047eb05e95", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -24,8 +24,7 @@ use core::either::Either;\n use core::either;\n use core::option;\n use core::vec;\n-use std::oldmap::HashMap;\n-use std::oldmap;\n+use core::hashmap::linear::LinearSet;\n use std;\n \n /* Constructors */\n@@ -358,16 +357,15 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n \n pub fn require_unique_names(diagnostic: span_handler,\n                             metas: &[@ast::meta_item]) {\n-    let map = oldmap::HashMap();\n+    let mut set = LinearSet::new();\n     for metas.each |meta| {\n         let name = get_meta_item_name(*meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n-        if map.contains_key_ref(&name) {\n+        if !set.insert(name) {\n             diagnostic.span_fatal(meta.span,\n                                   fmt!(\"duplicate meta item `%s`\", name));\n         }\n-        map.insert(name, ());\n     }\n }\n "}, {"sha": "4b1194bb5f174851c83170075ee320bf9756fa8b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -197,7 +197,7 @@ pub fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n           codemap::spanned {\n                 node: match_nonterminal(bind_name, _, idx), span: sp\n           } => {\n-            if ret_val.contains_key_ref(&bind_name) {\n+            if ret_val.contains_key(&bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n                                                *p_s.interner.get(bind_name))\n             }"}, {"sha": "e0d53fadfa0b8b0e83898dba3f46fdb0cd58499c", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -96,7 +96,7 @@ pub impl Parser {\n \n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(word: ~str) {\n-        if !self.keywords.contains_key_ref(&word) {\n+        if !self.keywords.contains_key(&word) {\n             self.bug(fmt!(\"unknown keyword: %s\", word));\n         }\n     }\n@@ -120,7 +120,7 @@ pub impl Parser {\n     fn is_any_keyword(tok: token::Token) -> bool {\n         match tok {\n           token::IDENT(sid, false) => {\n-            self.keywords.contains_key_ref(self.id_to_str(sid))\n+            self.keywords.contains_key(self.id_to_str(sid))\n           }\n           _ => false\n         }\n@@ -146,7 +146,7 @@ pub impl Parser {\n     }\n \n     fn is_strict_keyword(word: ~str) -> bool {\n-        self.strict_keywords.contains_key_ref(&word)\n+        self.strict_keywords.contains_key(&word)\n     }\n \n     fn check_strict_keywords() {\n@@ -166,7 +166,7 @@ pub impl Parser {\n     }\n \n     fn is_reserved_keyword(word: ~str) -> bool {\n-        self.reserved_keywords.contains_key_ref(&word)\n+        self.reserved_keywords.contains_key(&word)\n     }\n \n     fn check_reserved_keywords() {"}, {"sha": "9b2040fed1a1f4a3b599b171f3cdb0f569521278", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -137,7 +137,7 @@ pub impl Parser {\n                    desc: &str) {\n         self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n \n-        if !self.obsolete_set.contains_key_ref(&kind) {\n+        if !self.obsolete_set.contains_key(&kind) {\n             self.sess.span_diagnostic.handler().note(fmt!(\"%s\", desc));\n             self.obsolete_set.insert(kind, ());\n         }"}, {"sha": "b8d756d893adfc821ac4a39483830a340d545a24", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -455,13 +455,13 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n  */\n pub fn keyword_table() -> HashMap<~str, ()> {\n     let keywords = HashMap();\n-    for temporary_keyword_table().each_key_ref |&word| {\n+    for temporary_keyword_table().each_key |&word| {\n         keywords.insert(word, ());\n     }\n-    for strict_keyword_table().each_key_ref |&word| {\n+    for strict_keyword_table().each_key |&word| {\n         keywords.insert(word, ());\n     }\n-    for reserved_keyword_table().each_key_ref |&word| {\n+    for reserved_keyword_table().each_key |&word| {\n         keywords.insert(word, ());\n     }\n     keywords"}, {"sha": "62341f08ce3be349544f4b5cf93e270d49b87568", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -49,7 +49,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   for mm.each_ref |&key, &val| {\n+   for mm.each |&key, &val| {\n       pairs.push((key, pct(val, total)));\n    }\n "}, {"sha": "b19454ec230c207d27994710a625d018765cb6b0", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6442e97a50561e8b42e145c2761d9e14233c4c1/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=d6442e97a50561e8b42e145c2761d9e14233c4c1", "patch": "@@ -134,7 +134,7 @@ fn writer(path: ~str, pport: pipes::Port<Line>, size: uint)\n             done += 1_u;\n             let mut prev = done;\n             while prev <= i {\n-                if lines.contains_key_ref(&prev) {\n+                if lines.contains_key(&prev) {\n                     debug!(\"WS %u\", prev);\n                     cout.write(lines.get(&prev));\n                     done += 1_u;"}]}