{"sha": "973fa8e30eb2f699db4337624e193d0994666c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3M2ZhOGUzMGViMmY2OTlkYjQzMzc2MjRlMTkzZDA5OTQ2NjZjN2M=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-12-31T08:14:16Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-12-31T08:15:38Z"}, "message": "Add fallible Rc APIs (`Rc::try_new_*`)", "tree": {"sha": "5e2776027852b35d9f805a1a385ff5f022e354b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e2776027852b35d9f805a1a385ff5f022e354b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/973fa8e30eb2f699db4337624e193d0994666c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/973fa8e30eb2f699db4337624e193d0994666c7c", "html_url": "https://github.com/rust-lang/rust/commit/973fa8e30eb2f699db4337624e193d0994666c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/973fa8e30eb2f699db4337624e193d0994666c7c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd2c6c318bfe3191e936f4500d60b5089db1ef60", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2c6c318bfe3191e936f4500d60b5089db1ef60", "html_url": "https://github.com/rust-lang/rust/commit/dd2c6c318bfe3191e936f4500d60b5089db1ef60"}], "stats": {"total": 143, "additions": 121, "deletions": 22}, "files": [{"sha": "afaefaa2565e8fff7d9ca0a195e2a195ec3a3506", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 121, "deletions": 22, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/973fa8e30eb2f699db4337624e193d0994666c7c/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973fa8e30eb2f699db4337624e193d0994666c7c/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=973fa8e30eb2f699db4337624e193d0994666c7c", "patch": "@@ -346,28 +346,6 @@ impl<T> Rc<T> {\n         )\n     }\n \n-    /// Constructs a new `Rc<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(allocator_api, new_uninit)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn try_new(value: T) -> Result<Rc<T>, AllocError> {\n-        // There is an implicit weak pointer owned by all the strong\n-        // pointers, which ensures that the weak destructor never frees\n-        // the allocation while the strong destructor is running, even\n-        // if the weak pointer is stored inside the strong one.\n-        Ok(Self::from_inner(\n-            Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n-                .into(),\n-        ))\n-    }\n-\n     /// Constructs a new `Rc<T>` using a weak reference to itself. Attempting\n     /// to upgrade the weak reference before this function returns will result\n     /// in a `None` value. However, the weak reference may be cloned freely and\n@@ -475,6 +453,95 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    /// Constructs a new `Rc<T>`, returning an error if the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::try_new(5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn try_new(value: T) -> Result<Rc<T>, AllocError> {\n+        // There is an implicit weak pointer owned by all the strong\n+        // pointers, which ensures that the weak destructor never frees\n+        // the allocation while the strong destructor is running, even\n+        // if the weak pointer is stored inside the strong one.\n+        Ok(Self::from_inner(\n+            Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n+                .into(),\n+        ))\n+    }\n+\n+    /// Constructs a new `Rc` with uninitialized contents, returning an error if the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::try_new_uninit()?;\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_uninit() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Rc::from_ptr(Rc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n+\n+    /// Constructs a new `Rc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes, returning an error if the allocation fails\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let zero = Rc::<u32>::try_new_zeroed()?;\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    //#[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_zeroed() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Rc::from_ptr(Rc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate_zeroed(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -1056,6 +1123,38 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n+    /// Allocates an `RcBox<T>` with sufficient space for\n+    /// a possibly-unsized inner value where the value has the layout provided,\n+    /// returning an error if allocation fails.\n+    ///\n+    /// The function `mem_to_rcbox` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n+    unsafe fn try_allocate_for_layout(\n+        value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n+        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n+    ) -> Result<*mut RcBox<T>, AllocError> {\n+        // Calculate layout using the given value layout.\n+        // Previously, layout was calculated on the expression\n+        // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n+        // reference (see #54908).\n+        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+\n+        // Allocate for the layout.\n+        let ptr = allocate(layout)?;\n+\n+        // Initialize the RcBox\n+        let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());\n+        unsafe {\n+            debug_assert_eq!(Layout::for_value(&*inner), layout);\n+\n+            ptr::write(&mut (*inner).strong, Cell::new(1));\n+            ptr::write(&mut (*inner).weak, Cell::new(1));\n+        }\n+\n+        Ok(inner)\n+    }\n+\n     /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value."}]}