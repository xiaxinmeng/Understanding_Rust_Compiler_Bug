{"sha": "f712df8c5dfa14a01525dc28f38d731eedcc7263", "node_id": "C_kwDOAAsO6NoAKGY3MTJkZjhjNWRmYTE0YTAxNTI1ZGMyOGYzOGQ3MzFlZWRjYzcyNjM", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-10-20T23:42:53Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:23Z"}, "message": "Track drop points in generator_interior\n\nThis change adds the basic infrastructure for tracking drop ranges in\ngenerator interior analysis, which allows us to exclude dropped types\nfrom the generator type.\n\nNot yet complete, but many of the async/await and generator tests pass.\nThe main missing piece is tracking branching control flow (e.g. around\nan `if` expression). The patch does include support, however, for\nmultiple yields in th e same block.\n\nIssue #57478", "tree": {"sha": "f61e38b6a137644418ebdeec644567e7f5398e24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f61e38b6a137644418ebdeec644567e7f5398e24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f712df8c5dfa14a01525dc28f38d731eedcc7263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f712df8c5dfa14a01525dc28f38d731eedcc7263", "html_url": "https://github.com/rust-lang/rust/commit/f712df8c5dfa14a01525dc28f38d731eedcc7263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f712df8c5dfa14a01525dc28f38d731eedcc7263/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be32f896a7fc7e9db8b92132b147870bd57bc9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be32f896a7fc7e9db8b92132b147870bd57bc9b", "html_url": "https://github.com/rust-lang/rust/commit/4be32f896a7fc7e9db8b92132b147870bd57bc9b"}], "stats": {"total": 267, "additions": 168, "deletions": 99}, "files": [{"sha": "f8989200d7e088d9e3d21c07acb5de55e6436bc0", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f712df8c5dfa14a01525dc28f38d731eedcc7263/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f712df8c5dfa14a01525dc28f38d731eedcc7263/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=f712df8c5dfa14a01525dc28f38d731eedcc7263", "patch": "@@ -255,7 +255,6 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             hir::ExprKind::AssignOp(..)\n             | hir::ExprKind::Index(..)\n             | hir::ExprKind::Unary(..)\n-            | hir::ExprKind::Call(..)\n             | hir::ExprKind::MethodCall(..) => {\n                 // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n                 //"}, {"sha": "a406a1a8ecd9943cec6559484a3ee759f1b73c93", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 161, "deletions": 29, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f712df8c5dfa14a01525dc28f38d731eedcc7263/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f712df8c5dfa14a01525dc28f38d731eedcc7263/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=f712df8c5dfa14a01525dc28f38d731eedcc7263", "patch": "@@ -3,7 +3,10 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n+use crate::expr_use_visitor::{self, ExprUseVisitor};\n+\n use super::FnCtxt;\n+use hir::HirIdMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n use rustc_hir as hir;\n@@ -34,6 +37,7 @@ struct InteriorVisitor<'a, 'tcx> {\n     guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n     guard_bindings_set: HirIdSet,\n     linted_values: HirIdSet,\n+    drop_ranges: HirIdMap<DropRange>,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -48,9 +52,11 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n     ) {\n         use rustc_span::DUMMY_SP;\n \n+        let ty = self.fcx.resolve_vars_if_possible(ty);\n+\n         debug!(\n-            \"generator_interior: attempting to record type {:?} {:?} {:?} {:?}\",\n-            ty, scope, expr, source_span\n+            \"attempting to record type ty={:?}; hir_id={:?}; scope={:?}; expr={:?}; source_span={:?}; expr_count={:?}\",\n+            ty, hir_id, scope, expr, source_span, self.expr_count,\n         );\n \n         let live_across_yield = scope\n@@ -68,6 +74,14 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                         yield_data.expr_and_pat_count, self.expr_count, source_span\n                     );\n \n+                    match self.drop_ranges.get(&hir_id) {\n+                        Some(range) if range.contains(yield_data.expr_and_pat_count) => {\n+                            debug!(\"value is dropped at yield point; not recording\");\n+                            return None\n+                        }\n+                        _ => (),\n+                    }\n+\n                     // If it is a borrowing happening in the guard,\n                     // it needs to be recorded regardless because they\n                     // do live across this yield point.\n@@ -85,7 +99,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             });\n \n         if let Some(yield_data) = live_across_yield {\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n             debug!(\n                 \"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                 expr, scope, ty, self.expr_count, yield_data.span\n@@ -154,7 +167,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 self.expr_count,\n                 expr.map(|e| e.span)\n             );\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n@@ -166,6 +178,39 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_call(\n+        &mut self,\n+        call_expr: &'tcx Expr<'tcx>,\n+        callee: &'tcx Expr<'tcx>,\n+        args: &'tcx [Expr<'tcx>],\n+    ) {\n+        match &callee.kind {\n+            ExprKind::Path(qpath) => {\n+                let res = self.fcx.typeck_results.borrow().qpath_res(qpath, callee.hir_id);\n+                match res {\n+                    // Direct calls never need to keep the callee `ty::FnDef`\n+                    // ZST in a temporary, so skip its type, just in case it\n+                    // can significantly complicate the generator type.\n+                    Res::Def(\n+                        DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn),\n+                        _,\n+                    ) => {\n+                        // NOTE(eddyb) this assumes a path expression has\n+                        // no nested expressions to keep track of.\n+                        self.expr_count += 1;\n+\n+                        // Record the rest of the call expression normally.\n+                        for arg in args {\n+                            self.visit_expr(arg);\n+                        }\n+                    }\n+                    _ => intravisit::walk_expr(self, call_expr),\n+                }\n+            }\n+            _ => intravisit::walk_expr(self, call_expr),\n+        }\n+    }\n }\n \n pub fn resolve_interior<'a, 'tcx>(\n@@ -176,6 +221,20 @@ pub fn resolve_interior<'a, 'tcx>(\n     kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n+\n+    let mut drop_range_visitor = DropRangeVisitor::default();\n+\n+    // Run ExprUseVisitor to find where values are consumed.\n+    ExprUseVisitor::new(\n+        &mut drop_range_visitor,\n+        &fcx.infcx,\n+        def_id.expect_local(),\n+        fcx.param_env,\n+        &fcx.typeck_results.borrow(),\n+    )\n+    .consume_body(body);\n+    intravisit::walk_body(&mut drop_range_visitor, body);\n+\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxIndexSet::default(),\n@@ -186,6 +245,7 @@ pub fn resolve_interior<'a, 'tcx>(\n         guard_bindings: <_>::default(),\n         guard_bindings_set: <_>::default(),\n         linted_values: <_>::default(),\n+        drop_ranges: drop_range_visitor.drop_ranges,\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -313,32 +373,9 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let mut guard_borrowing_from_pattern = false;\n+\n         match &expr.kind {\n-            ExprKind::Call(callee, args) => match &callee.kind {\n-                ExprKind::Path(qpath) => {\n-                    let res = self.fcx.typeck_results.borrow().qpath_res(qpath, callee.hir_id);\n-                    match res {\n-                        // Direct calls never need to keep the callee `ty::FnDef`\n-                        // ZST in a temporary, so skip its type, just in case it\n-                        // can significantly complicate the generator type.\n-                        Res::Def(\n-                            DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn),\n-                            _,\n-                        ) => {\n-                            // NOTE(eddyb) this assumes a path expression has\n-                            // no nested expressions to keep track of.\n-                            self.expr_count += 1;\n-\n-                            // Record the rest of the call expression normally.\n-                            for arg in *args {\n-                                self.visit_expr(arg);\n-                            }\n-                        }\n-                        _ => intravisit::walk_expr(self, expr),\n-                    }\n-                }\n-                _ => intravisit::walk_expr(self, expr),\n-            },\n+            ExprKind::Call(callee, args) => self.visit_call(expr, callee, args),\n             ExprKind::Path(qpath) => {\n                 intravisit::walk_expr(self, expr);\n                 let res = self.fcx.typeck_results.borrow().qpath_res(qpath, expr.hir_id);\n@@ -617,3 +654,98 @@ fn check_must_not_suspend_def(\n     }\n     false\n }\n+\n+/// This struct facilitates computing the ranges for which a place is uninitialized.\n+#[derive(Default)]\n+struct DropRangeVisitor {\n+    consumed_places: HirIdSet,\n+    drop_ranges: HirIdMap<DropRange>,\n+    expr_count: usize,\n+}\n+\n+impl DropRangeVisitor {\n+    fn record_drop(&mut self, hir_id: HirId) {\n+        debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n+        self.drop_ranges.insert(hir_id, DropRange { dropped_at: self.expr_count });\n+    }\n+\n+    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n+    /// expressions. This method consumes a little deeper into the expression when needed.\n+    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n+        self.record_drop(expr.hir_id);\n+        match expr.kind {\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                self.record_drop(*hir_id);\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor {\n+    fn consume(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+    ) {\n+        debug!(\"consume {:?}; diag_expr_id={:?}\", place_with_id, diag_expr_id);\n+        self.consumed_places.insert(place_with_id.hir_id);\n+    }\n+\n+    fn borrow(\n+        &mut self,\n+        _place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: hir::HirId,\n+        _bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+    }\n+\n+    fn mutate(\n+        &mut self,\n+        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: hir::HirId,\n+    ) {\n+    }\n+\n+    fn fake_read(\n+        &mut self,\n+        _place: expr_use_visitor::Place<'tcx>,\n+        _cause: rustc_middle::mir::FakeReadCause,\n+        _diag_expr_id: hir::HirId,\n+    ) {\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DropRangeVisitor {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, expr: &Expr<'_>) {\n+        intravisit::walk_expr(self, expr);\n+\n+        self.expr_count += 1;\n+\n+        if self.consumed_places.contains(&expr.hir_id) {\n+            self.consume_expr(expr);\n+        }\n+    }\n+}\n+\n+struct DropRange {\n+    /// The post-order id of the point where this expression is dropped.\n+    ///\n+    /// We can consider the value dropped at any post-order id greater than dropped_at.\n+    dropped_at: usize,\n+}\n+\n+impl DropRange {\n+    fn contains(&self, id: usize) -> bool {\n+        id >= self.dropped_at\n+    }\n+}"}, {"sha": "4dd36e7f0f062b7184ba054573ce0e28b580ff4e", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=f712df8c5dfa14a01525dc28f38d731eedcc7263", "patch": "@@ -18,7 +18,7 @@ async fn fut() {}\n async fn fut_arg<T>(_: T) {}\n \n async fn local_dropped_before_await() {\n-    // FIXME: it'd be nice for this to be allowed in a `Send` `async fn`\n+    // this is okay now because of the drop\n     let x = non_send();\n     drop(x);\n     fut().await;\n@@ -36,7 +36,7 @@ async fn non_send_temporary_in_match() {\n }\n \n async fn non_sync_with_method_call() {\n-    // FIXME: it'd be nice for this to work.\n+\n     let f: &mut std::fmt::Formatter = panic!();\n     if non_sync().fmt(f).unwrap() == () {\n         fut().await;\n@@ -47,9 +47,9 @@ fn assert_send(_: impl Send) {}\n \n pub fn pass_assert() {\n     assert_send(local_dropped_before_await());\n-    //~^ ERROR future cannot be sent between threads safely\n+\n     assert_send(non_send_temporary_in_match());\n     //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_sync_with_method_call());\n-    //~^ ERROR future cannot be sent between threads safely\n+\n }"}, {"sha": "79c043b701ddb249c69a3bea60a09c1a2eca3527", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=f712df8c5dfa14a01525dc28f38d731eedcc7263", "patch": "@@ -8,24 +8,8 @@ async fn bar<T>() -> () {}\n async fn foo() {\n     bar().await;\n     //~^ ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n     //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`\n }\n fn main() {}"}, {"sha": "853e53ed69df237303e61ae5fee2c6ee90b0445d", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=f712df8c5dfa14a01525dc28f38d731eedcc7263", "patch": "@@ -10,54 +10,6 @@ note: the type is part of the `async fn` body because of this `await`\n LL |     bar().await;\n    |          ^^^^^^\n \n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0698`."}, {"sha": "39710febdb95cf892ea4bdbdbbfa8dd086fc8b06", "filename": "src/test/ui/generator/issue-57478.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f712df8c5dfa14a01525dc28f38d731eedcc7263/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs?ref=f712df8c5dfa14a01525dc28f38d731eedcc7263", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![feature(negative_impls, generators)]\n \n struct Foo;"}]}