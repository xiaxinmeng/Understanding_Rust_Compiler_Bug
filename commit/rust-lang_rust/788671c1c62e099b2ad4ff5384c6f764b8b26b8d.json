{"sha": "788671c1c62e099b2ad4ff5384c6f764b8b26b8d", "node_id": "C_kwDOAAsO6NoAKDc4ODY3MWMxYzYyZTA5OWIyYWQ0ZmY1Mzg0YzZmNzY0YjhiMjZiOGQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-18T05:59:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-18T05:59:22Z"}, "message": "Rollup merge of #106997 - Sp00ph:introselect, r=scottmcm\n\nAdd heapsort fallback in `select_nth_unstable`\n\nAddresses #102451 and #106933.\n\n`slice::select_nth_unstable` uses a quick select implementation based on the same pattern defeating quicksort algorithm that `slice::sort_unstable` uses. `slice::sort_unstable` uses a recursion limit and falls back to heapsort if there were too many bad pivot choices, to ensure O(n log n) worst case running time (known as introsort). However, `slice::select_nth_unstable` does not have such a fallback strategy, which leads to it having a worst case running time of O(n\u00b2) instead. #102451 links to a playground which generates pathological inputs that show this quadratic behavior. On my machine, a randomly generated slice of length `1 << 19` takes ~200\u00b5s to calculate its median, whereas a pathological input of the same length takes over 2.5s. This PR adds an iteration limit to `select_nth_unstable`, falling back to heapsort, which ensures an O(n log n) worst case running time (introselect). With this change, there was no noticable slowdown for the random input, but the same pathological input now takes only ~1.2ms. In the future it might be worth implementing something like Median of Medians or Fast Deterministic Selection instead, which guarantee O(n) running time for all possible inputs. I've left this as a `FIXME` for now and only implemented the heapsort fallback to minimize the needed code changes.\n\nI still think we should clarify in the `select_nth_unstable` docs that the worst case running time isn't currently O(n) (the original reason that #102451 was opened), but I think it's a lot better to be able to guarantee O(n log n) instead of O(n\u00b2) for the worst case.", "tree": {"sha": "7693b9d1990c1a9bf003a05bec813d96bd5de4a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7693b9d1990c1a9bf003a05bec813d96bd5de4a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/788671c1c62e099b2ad4ff5384c6f764b8b26b8d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjx4q6CRBK7hj4Ov3rIwAAuhsIAF0XGxydmjqZ5IVMoQs/R957\nPvxc74tG0tybSFWjaD9rMZKhXSXc7KZjorSpP+wZ3mZ8H3v8tQxB1uy42iUXKJB/\nkJ71X6M0FPLdpUbc8b43tFJOR43MB9/uRfhZ9lsWNJekoRyhUQNr7hXVFZQroXFp\nWyWGF8llU+gAhn92rsK4O69H2MYRHwjFM5o2QQKcECA7RJd0Ip/e6bl1eDjVmEFz\nJ8/lxie2w5jeo8eVwE0MVxOoXPBm/86Rz/FKXExy8Kx5muCLDRQWaUnNJZkjxW9f\ns909mr/UfckM8XnZzxNn9GOaKftPk7IxGEX5KjKEgtlOEVCc7m4MgYPylEPx2Tc=\n=3hpV\n-----END PGP SIGNATURE-----\n", "payload": "tree 7693b9d1990c1a9bf003a05bec813d96bd5de4a8\nparent f547bb57155470ce57fec9a7b7aec6927468c4bb\nparent 273c6c3913e4d32c3321a3c92fb2ce32c1db9cb8\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674021562 +0100\ncommitter GitHub <noreply@github.com> 1674021562 +0100\n\nRollup merge of #106997 - Sp00ph:introselect, r=scottmcm\n\nAdd heapsort fallback in `select_nth_unstable`\n\nAddresses #102451 and #106933.\n\n`slice::select_nth_unstable` uses a quick select implementation based on the same pattern defeating quicksort algorithm that `slice::sort_unstable` uses. `slice::sort_unstable` uses a recursion limit and falls back to heapsort if there were too many bad pivot choices, to ensure O(n log n) worst case running time (known as introsort). However, `slice::select_nth_unstable` does not have such a fallback strategy, which leads to it having a worst case running time of O(n\u00b2) instead. #102451 links to a playground which generates pathological inputs that show this quadratic behavior. On my machine, a randomly generated slice of length `1 << 19` takes ~200\u00b5s to calculate its median, whereas a pathological input of the same length takes over 2.5s. This PR adds an iteration limit to `select_nth_unstable`, falling back to heapsort, which ensures an O(n log n) worst case running time (introselect). With this change, there was no noticable slowdown for the random input, but the same pathological input now takes only ~1.2ms. In the future it might be worth implementing something like Median of Medians or Fast Deterministic Selection instead, which guarantee O(n) running time for all possible inputs. I've left this as a `FIXME` for now and only implemented the heapsort fallback to minimize the needed code changes.\n\nI still think we should clarify in the `select_nth_unstable` docs that the worst case running time isn't currently O(n) (the original reason that #102451 was opened), but I think it's a lot better to be able to guarantee O(n log n) instead of O(n\u00b2) for the worst case.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/788671c1c62e099b2ad4ff5384c6f764b8b26b8d", "html_url": "https://github.com/rust-lang/rust/commit/788671c1c62e099b2ad4ff5384c6f764b8b26b8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/788671c1c62e099b2ad4ff5384c6f764b8b26b8d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f547bb57155470ce57fec9a7b7aec6927468c4bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f547bb57155470ce57fec9a7b7aec6927468c4bb", "html_url": "https://github.com/rust-lang/rust/commit/f547bb57155470ce57fec9a7b7aec6927468c4bb"}, {"sha": "273c6c3913e4d32c3321a3c92fb2ce32c1db9cb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/273c6c3913e4d32c3321a3c92fb2ce32c1db9cb8", "html_url": "https://github.com/rust-lang/rust/commit/273c6c3913e4d32c3321a3c92fb2ce32c1db9cb8"}], "stats": {"total": 22, "additions": 22, "deletions": 0}, "files": [{"sha": "3ac01d1727513ec99ae350740263314bd0442dd9", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/788671c1c62e099b2ad4ff5384c6f764b8b26b8d/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788671c1c62e099b2ad4ff5384c6f764b8b26b8d/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=788671c1c62e099b2ad4ff5384c6f764b8b26b8d", "patch": "@@ -831,6 +831,15 @@ fn partition_at_index_loop<'a, T, F>(\n ) where\n     F: FnMut(&T, &T) -> bool,\n {\n+    // Limit the amount of iterations and fall back to heapsort, similarly to `slice::sort_unstable`.\n+    // This lowers the worst case running time from O(n^2) to O(n log n).\n+    // FIXME: Investigate whether it would be better to use something like Median of Medians\n+    // or Fast Deterministic Selection to guarantee O(n) worst case.\n+    let mut limit = usize::BITS - v.len().leading_zeros();\n+\n+    // True if the last partitioning was reasonably balanced.\n+    let mut was_balanced = true;\n+\n     loop {\n         // For slices of up to this length it's probably faster to simply sort them.\n         const MAX_INSERTION: usize = 10;\n@@ -839,6 +848,18 @@ fn partition_at_index_loop<'a, T, F>(\n             return;\n         }\n \n+        if limit == 0 {\n+            heapsort(v, is_less);\n+            return;\n+        }\n+\n+        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n+        // some elements around. Hopefully we'll choose a better pivot this time.\n+        if !was_balanced {\n+            break_patterns(v);\n+            limit -= 1;\n+        }\n+\n         // Choose a pivot\n         let (pivot, _) = choose_pivot(v, is_less);\n \n@@ -863,6 +884,7 @@ fn partition_at_index_loop<'a, T, F>(\n         }\n \n         let (mid, _) = partition(v, pivot, is_less);\n+        was_balanced = cmp::min(mid, v.len() - mid) >= v.len() / 8;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n         let (left, right) = v.split_at_mut(mid);"}]}