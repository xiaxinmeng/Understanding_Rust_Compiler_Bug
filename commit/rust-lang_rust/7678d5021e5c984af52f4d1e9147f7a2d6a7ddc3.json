{"sha": "7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NzhkNTAyMWU1Yzk4NGFmNTJmNGQxZTkxNDdmN2EyZDZhN2RkYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-06T15:01:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-06T15:01:27Z"}, "message": "Auto merge of #48779 - michaelwoerister:share-generics4, r=alexcrichton\n\nAllow for re-using monomorphizations in upstream crates.\n\nFollowup to #48611. This implementation is pretty much finished modulo failing tests if there are any. Not quite ready for review yet though.\n\n### DESCRIPTION\n\nThis PR introduces a `share-generics` mode for RLIBs and Rust dylibs. When a crate is compiled in this mode, two things will happen:\n- before instantiating a monomorphization in the current crate, the compiler will look for that monomorphization in all upstream crates and link to it, if possible.\n- monomorphizations are not internalized during partitioning. Instead they are added to the list of symbols exported from the crate.\n\nThis results in less code being translated and LLVMed. However, there are also downsides:\n- it will impede optimization somewhat, since fewer functions can be internalized, and\n- Rust dylibs will have bigger symbol tables since they'll also export monomorphizations.\n\nConsequently, this PR only enables the `shared-generics` mode for opt-levels `No`, `Less`, `Size`, and `MinSize`, and for when incremental compilation is activated. `-O2` and `-O3` will still generate generic functions per-crate.\n\nAnother thing to note is that this has a somewhat similar effect as MIR-only RLIBs, in that monomorphizations are shared, but it is less effective because it cannot share monomorphizations between sibling crates:\n\n```\n         A        <--- defines `fn foo<T>() { .. }`\n       /   \\\n      /     \\\n     B       C    <--- both call `foo<u32>()`\n      \\     /\n       \\   /\n         D        <--- calls `foo<u32>()` too\n```\n\nWith `share-generics`, both `B` and `C` have to instantiate `foo<u32>` and only `D` can re-use it (from either `B` or `C`). With MIR-only RLIBs, `B` and `C` would not instantiate anything, and in `D` we would then only instantiate `foo<u32>` once.\nOn the other hand, when there are many leaf crates in the graph (e.g. when compiling many individual test binaries) then the `share-generics` approach will often be more effective.\n\n### TODO\n - [x] Add codegen test that makes sure monomorphizations can be internalized in non-Rust binaries.\n - [x] Add codegen-units test that makes sure we share generics.\n - [x] Add run-make test that makes sure we don't export any monomorphizations from non-Rust binaries.\n - [x] Review for reproducible-builds implications.", "tree": {"sha": "5ff794b1cdb273c298ae4124b3c088bbbfe5e0be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ff794b1cdb273c298ae4124b3c088bbbfe5e0be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "html_url": "https://github.com/rust-lang/rust/commit/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2253216ec500601f9c2998196cb1b0a1ed0ae576", "url": "https://api.github.com/repos/rust-lang/rust/commits/2253216ec500601f9c2998196cb1b0a1ed0ae576", "html_url": "https://github.com/rust-lang/rust/commit/2253216ec500601f9c2998196cb1b0a1ed0ae576"}, {"sha": "61991a544f2e673e626e5db7639585fe8aa048b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/61991a544f2e673e626e5db7639585fe8aa048b7", "html_url": "https://github.com/rust-lang/rust/commit/61991a544f2e673e626e5db7639585fe8aa048b7"}], "stats": {"total": 856, "additions": 675, "deletions": 181}, "files": [{"sha": "7c5318a96f5ac5773422972984e7afd37179579b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -561,6 +561,7 @@ define_dep_nodes!( <'tcx>\n     [] ImplParent(DefId),\n     [] TraitOfItem(DefId),\n     [] IsReachableNonGeneric(DefId),\n+    [] IsUnreachableLocalDefinition(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n     [] TransFnAttrs(DefId),\n@@ -648,15 +649,16 @@ define_dep_nodes!( <'tcx>\n \n     [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n \n-    [] GetSymbolExportLevel(DefId),\n-\n     [] WasmCustomSections(CrateNum),\n \n     [input] Features,\n \n     [] ProgramClausesFor(DefId),\n     [] WasmImportModuleMap(CrateNum),\n     [] ForeignModules(CrateNum),\n+\n+    [] UpstreamMonomorphizations(CrateNum),\n+    [] UpstreamMonomorphizationsFor(DefId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "f86913490258e51c11d72f1fba3fe1b08836fd68", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -53,8 +53,21 @@ for &'gcx ty::Slice<T>\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::subst::Kind<'gcx> {\n+impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a>>\n+{\n+    type KeyType = Fingerprint;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> Fingerprint {\n+        let mut hasher = StableHasher::new();\n+        let mut hcx: StableHashingContext<'a> = hcx.clone();\n+        self.hash_stable(&mut hcx, &mut hasher);\n+        hasher.finish()\n+    }\n+}\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -67,6 +80,7 @@ for ty::subst::UnpackedKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n             ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n             ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),"}, {"sha": "01783eb0ff65f8b90cf561c59d790c5994822d64", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -9,8 +9,13 @@\n // except according to those terms.\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n+                                           StableHasherResult};\n use std::cmp;\n+use std::mem;\n use ty;\n+use ty::subst::Substs;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n@@ -40,56 +45,89 @@ impl SymbolExportLevel {\n }\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum ExportedSymbol {\n+pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n+    Generic(DefId, &'tcx Substs<'tcx>),\n     NoDefId(ty::SymbolName),\n }\n \n-impl ExportedSymbol {\n-    pub fn symbol_name(&self, tcx: ty::TyCtxt) -> ty::SymbolName {\n+impl<'tcx> ExportedSymbol<'tcx> {\n+    pub fn symbol_name(&self,\n+                       tcx: ty::TyCtxt<'_, 'tcx, '_>)\n+                       -> ty::SymbolName {\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => {\n                 tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n             }\n+            ExportedSymbol::Generic(def_id, substs) => {\n+                tcx.symbol_name(ty::Instance::new(def_id, substs))\n+            }\n             ExportedSymbol::NoDefId(symbol_name) => {\n                 symbol_name\n             }\n         }\n     }\n \n-    pub fn compare_stable(&self, tcx: ty::TyCtxt, other: &ExportedSymbol) -> cmp::Ordering {\n+    pub fn compare_stable(&self,\n+                          tcx: ty::TyCtxt<'_, 'tcx, '_>,\n+                          other: &ExportedSymbol<'tcx>)\n+                          -> cmp::Ordering {\n         match *self {\n-            ExportedSymbol::NonGeneric(self_def_id) => {\n-                match *other {\n-                    ExportedSymbol::NonGeneric(other_def_id) => {\n-                        tcx.def_path_hash(self_def_id).cmp(&tcx.def_path_hash(other_def_id))\n-                    }\n-                    ExportedSymbol::NoDefId(_) => {\n-                        cmp::Ordering::Less\n-                    }\n+            ExportedSymbol::NonGeneric(self_def_id) => match *other {\n+                ExportedSymbol::NonGeneric(other_def_id) => {\n+                    tcx.def_path_hash(self_def_id).cmp(&tcx.def_path_hash(other_def_id))\n+                }\n+                ExportedSymbol::Generic(..) |\n+                ExportedSymbol::NoDefId(_) => {\n+                    cmp::Ordering::Less\n+                }\n+            }\n+            ExportedSymbol::Generic(..) => match *other {\n+                ExportedSymbol::NonGeneric(_) => {\n+                    cmp::Ordering::Greater\n+                }\n+                ExportedSymbol::Generic(..) => {\n+                    self.symbol_name(tcx).cmp(&other.symbol_name(tcx))\n+                }\n+                ExportedSymbol::NoDefId(_) => {\n+                    cmp::Ordering::Less\n                 }\n             }\n-            ExportedSymbol::NoDefId(self_symbol_name) => {\n-                match *other {\n-                    ExportedSymbol::NonGeneric(_) => {\n-                        cmp::Ordering::Greater\n-                    }\n-                    ExportedSymbol::NoDefId(ref other_symbol_name) => {\n-                        self_symbol_name.cmp(other_symbol_name)\n-                    }\n+            ExportedSymbol::NoDefId(self_symbol_name) => match *other {\n+                ExportedSymbol::NonGeneric(_) |\n+                ExportedSymbol::Generic(..) => {\n+                    cmp::Ordering::Greater\n+                }\n+                ExportedSymbol::NoDefId(ref other_symbol_name) => {\n+                    self_symbol_name.cmp(other_symbol_name)\n                 }\n             }\n         }\n     }\n }\n \n-impl_stable_hash_for!(enum self::ExportedSymbol {\n-    NonGeneric(def_id),\n-    NoDefId(symbol_name)\n-});\n-\n pub fn metadata_symbol_name(tcx: ty::TyCtxt) -> String {\n     format!(\"rust_metadata_{}_{}\",\n             tcx.original_crate_name(LOCAL_CRATE),\n             tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())\n }\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ExportedSymbol::NonGeneric(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+            ExportedSymbol::Generic(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            ExportedSymbol::NoDefId(symbol_name) => {\n+                symbol_name.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "a07370e1e42a7649f53787ab85c38bc2844cfb0c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -1304,6 +1304,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"embed LLVM bitcode in object files\"),\n     strip_debuginfo_if_disabled: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n+    share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+          \"make the current crate share its generic instantiations\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "69b33efdb3542c02bace3f32fb00ac3560ef3498", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -14,7 +14,8 @@ use dep_graph::DepGraph;\n use dep_graph::{DepNode, DepConstructor};\n use errors::DiagnosticBuilder;\n use session::Session;\n-use session::config::{BorrowckMode, OutputFilenames};\n+use session::config::{BorrowckMode, OutputFilenames, OptLevel};\n+use session::config::CrateType::*;\n use middle;\n use hir::{TraitCandidate, HirId, ItemLocalId};\n use hir::def::{Def, Export};\n@@ -1499,6 +1500,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.sess.opts.debugging_opts.mir_emit_validate > 0 ||\n             self.use_mir()\n     }\n+\n+    #[inline]\n+    pub fn share_generics(self) -> bool {\n+        match self.sess.opts.debugging_opts.share_generics {\n+            Some(setting) => setting,\n+            None => {\n+                self.sess.opts.incremental.is_some() ||\n+                match self.sess.opts.optimize {\n+                    OptLevel::No   |\n+                    OptLevel::Less |\n+                    OptLevel::Size |\n+                    OptLevel::SizeMin => true,\n+                    OptLevel::Default    |\n+                    OptLevel::Aggressive => false,\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn local_crate_exports_generics(self) -> bool {\n+        debug_assert!(self.share_generics());\n+\n+        self.sess.crate_types.borrow().iter().any(|crate_type| {\n+            match crate_type {\n+                CrateTypeExecutable |\n+                CrateTypeStaticlib  |\n+                CrateTypeProcMacro  |\n+                CrateTypeCdylib     => false,\n+                CrateTypeRlib       |\n+                CrateTypeDylib      => true,\n+            }\n+        })\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "16866636cd90aacae94f00970462b272dabc0409", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -131,6 +131,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::upstream_monomorphizations<'tcx> {\n+    fn describe(_: TyCtxt, k: CrateNum) -> String {\n+        format!(\"collecting available upstream monomorphizations `{:?}`\", k)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls<'tcx> {\n     fn describe(_: TyCtxt, k: CrateNum) -> String {\n         format!(\"all inherent impls defined in crate `{:?}`\", k)"}, {"sha": "5a23a3b952a423c392f4aa8ce274d965b966285a", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -319,9 +319,15 @@ define_maps! { <'tcx>\n     //\n     // Does not include external symbols that don't have a corresponding DefId,\n     // like the compiler-generated `main` function and so on.\n-    [] fn reachable_non_generics: ReachableNonGenerics(CrateNum) -> Lrc<DefIdSet>,\n+    [] fn reachable_non_generics: ReachableNonGenerics(CrateNum)\n+        -> Lrc<DefIdMap<SymbolExportLevel>>,\n     [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n+    [] fn is_unreachable_local_definition: IsUnreachableLocalDefinition(DefId) -> bool,\n \n+    [] fn upstream_monomorphizations: UpstreamMonomorphizations(CrateNum)\n+        -> Lrc<DefIdMap<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>>,\n+    [] fn upstream_monomorphizations_for: UpstreamMonomorphizationsFor(DefId)\n+        -> Option<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>,\n \n     [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n \n@@ -381,11 +387,10 @@ define_maps! { <'tcx>\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(ExportedSymbol, SymbolExportLevel)>>,\n+        -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-    [] fn symbol_export_level: GetSymbolExportLevel(DefId) -> SymbolExportLevel,\n     [] fn is_translated_item: IsTranslatedItem(DefId) -> bool,\n     [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n     [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,"}, {"sha": "65571aa6a692db4d10a0b8f63102a62f2ae20b62", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -1003,6 +1003,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n         DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n         DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n+        DepKind::IsUnreachableLocalDefinition => {\n+            force!(is_unreachable_local_definition, def_id!());\n+        }\n         DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n         DepKind::TransFnAttrs => { force!(trans_fn_attrs, def_id!()); }\n@@ -1087,13 +1090,19 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n \n-        DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n \n         DepKind::ProgramClausesFor => { force!(program_clauses_for, def_id!()); }\n         DepKind::WasmCustomSections => { force!(wasm_custom_sections, krate!()); }\n         DepKind::WasmImportModuleMap => { force!(wasm_import_module_map, krate!()); }\n         DepKind::ForeignModules => { force!(foreign_modules, krate!()); }\n+\n+        DepKind::UpstreamMonomorphizations => {\n+            force!(upstream_monomorphizations, krate!());\n+        }\n+        DepKind::UpstreamMonomorphizationsFor => {\n+            force!(upstream_monomorphizations_for, def_id!());\n+        }\n     }\n \n     true"}, {"sha": "51088563c7b9c0d0951ef8260577f0ece00a84c9", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -186,9 +186,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let reachable_non_generics = tcx\n             .exported_symbols(cdata.cnum)\n             .iter()\n-            .filter_map(|&(exported_symbol, _)| {\n+            .filter_map(|&(exported_symbol, export_level)| {\n                 if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n-                    return Some(def_id)\n+                    return Some((def_id, export_level))\n                 } else {\n                     None\n                 }\n@@ -268,7 +268,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             return Arc::new(Vec::new())\n         }\n \n-        Arc::new(cdata.exported_symbols())\n+        Arc::new(cdata.exported_symbols(tcx))\n     }\n \n     wasm_custom_sections => { Lrc::new(cdata.wasm_custom_sections()) }"}, {"sha": "42e208ded49fd0f1f0782836dc3d219a8e5d700c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -1065,11 +1065,13 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn exported_symbols(&self) -> Vec<(ExportedSymbol, SymbolExportLevel)> {\n-        self.root\n-            .exported_symbols\n-            .decode(self)\n-            .collect()\n+    pub fn exported_symbols(&self,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                            -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n+        let lazy_seq: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> =\n+            LazySeq::with_position_and_length(self.root.exported_symbols.position,\n+                                              self.root.exported_symbols.len);\n+        lazy_seq.decode((self, tcx)).collect()\n     }\n \n     pub fn wasm_custom_sections(&self) -> Vec<DefId> {"}, {"sha": "1b208a512e2a46c6a977b5c272aef67f8a7e95a7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -1444,13 +1444,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     // definition (as that's not defined in this crate).\n     fn encode_exported_symbols(&mut self,\n                                exported_symbols: &[(ExportedSymbol, SymbolExportLevel)])\n-                               -> LazySeq<(ExportedSymbol, SymbolExportLevel)> {\n-\n+                               -> EncodedExportedSymbols {\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n \n-        self.lazy_seq(exported_symbols\n+        let lazy_seq = self.lazy_seq(exported_symbols\n             .iter()\n             .filter(|&&(ref exported_symbol, _)| {\n                 match *exported_symbol {\n@@ -1460,7 +1459,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     _ => true,\n                 }\n             })\n-            .cloned())\n+            .cloned());\n+\n+        EncodedExportedSymbols {\n+            len: lazy_seq.len,\n+            position: lazy_seq.position,\n+        }\n     }\n \n     fn encode_wasm_custom_sections(&mut self, statics: &[DefId]) -> LazySeq<DefIndex> {"}, {"sha": "e3986bb7d91f94c5bdbde85cef7b828b75cf6d58", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -15,7 +15,6 @@ use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n use rustc::ich::StableHashingContext;\n-use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -206,7 +205,7 @@ pub struct CrateRoot {\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<(ExportedSymbol, SymbolExportLevel)>,\n+    pub exported_symbols: EncodedExportedSymbols,\n     pub wasm_custom_sections: LazySeq<DefIndex>,\n \n     pub index: LazySeq<index::Index>,\n@@ -531,3 +530,9 @@ impl_stable_hash_for!(struct GeneratorData<'tcx> { layout });\n // Tags used for encoding Spans:\n pub const TAG_VALID_SPAN: u8 = 0;\n pub const TAG_INVALID_SPAN: u8 = 1;\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct EncodedExportedSymbols {\n+    pub position: usize,\n+    pub len: usize,\n+}"}, {"sha": "ef018237dbad9c21fe26c4a89dcc260dd015ee36", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -569,7 +569,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     ty::TyClosure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n                             self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n-                        self.output.push(create_fn_mono_item(instance));\n+                        if should_monomorphize_locally(self.tcx, &instance) {\n+                            self.output.push(create_fn_mono_item(instance));\n+                        }\n                     }\n                     _ => bug!(),\n                 }\n@@ -731,14 +733,16 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n         ty::InstanceDef::Intrinsic(_) |\n         ty::InstanceDef::CloneShim(..) => return true\n     };\n-    match tcx.hir.get_if_local(def_id) {\n+\n+    return match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => {\n             false // foreign items are linked against, not translated.\n         }\n         Some(_) => true,\n         None => {\n             if tcx.is_reachable_non_generic(def_id) ||\n-                tcx.is_foreign_item(def_id)\n+                tcx.is_foreign_item(def_id) ||\n+                is_available_upstream_generic(tcx, def_id, instance.substs)\n             {\n                 // We can link to the item in question, no instance needed\n                 // in this crate\n@@ -750,6 +754,33 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n                 true\n             }\n         }\n+    };\n+\n+    fn is_available_upstream_generic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               def_id: DefId,\n+                                               substs: &'tcx Substs<'tcx>)\n+                                               -> bool {\n+        debug_assert!(!def_id.is_local());\n+\n+        // If we are not in share generics mode, we don't link to upstream\n+        // monomorphizations but always instantiate our own internal versions\n+        // instead.\n+        if !tcx.share_generics() {\n+            return false\n+        }\n+\n+        // If this instance has no type parameters, it cannot be a shared\n+        // monomorphization. Non-generic instances are already handled above\n+        // by `is_reachable_non_generic()`\n+        if substs.types().next().is_none() {\n+            return false\n+        }\n+\n+        // Take a look at the available monomorphizations listed in the metadata\n+        // of upstream crates.\n+        tcx.upstream_monomorphizations_for(def_id)\n+           .map(|set| set.contains_key(substs))\n+           .unwrap_or(false)\n     }\n }\n "}, {"sha": "da4cb4ec789041d219ce33d3c0084cba30b0a5b0", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 70, "deletions": 12, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -302,6 +302,13 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n     let mut internalization_candidates = FxHashSet();\n \n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics = tcx.share_generics() &&\n+                          tcx.local_crate_exports_generics();\n+\n     for trans_item in trans_items {\n         match trans_item.instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n@@ -325,13 +332,27 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             .or_insert_with(make_codegen_unit);\n \n         let mut can_be_internalized = true;\n-        let default_visibility = |id: DefId| {\n-            if tcx.sess.target.target.options.default_hidden_visibility &&\n-                tcx.symbol_export_level(id) != SymbolExportLevel::C\n-            {\n-                Visibility::Hidden\n-            } else {\n+        let default_visibility = |id: DefId, is_generic: bool| {\n+            if !tcx.sess.target.target.options.default_hidden_visibility {\n+                return Visibility::Default\n+            }\n+\n+            // Generic functions never have export level C\n+            if is_generic {\n+                return Visibility::Hidden\n+            }\n+\n+            // Things with export level C don't get instantiated in downstream\n+            // crates\n+            if !id.is_local() {\n+                return Visibility::Hidden\n+            }\n+\n+            if let Some(&SymbolExportLevel::C) = tcx.reachable_non_generics(id.krate)\n+                                                    .get(&id) {\n                 Visibility::Default\n+            } else {\n+                Visibility::Hidden\n             }\n         };\n         let (linkage, mut visibility) = match trans_item.explicit_linkage(tcx) {\n@@ -341,6 +362,11 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     MonoItem::Fn(ref instance) => {\n                         let visibility = match instance.def {\n                             InstanceDef::Item(def_id) => {\n+                                let is_generic = instance.substs\n+                                                         .types()\n+                                                         .next()\n+                                                         .is_some();\n+\n                                 // The `start_fn` lang item is actually a\n                                 // monomorphized instance of a function in the\n                                 // standard library, used for the `main`\n@@ -363,14 +389,46 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     can_be_internalized = false;\n                                     Visibility::Hidden\n                                 } else if def_id.is_local() {\n-                                    if tcx.is_reachable_non_generic(def_id) {\n+                                    if is_generic {\n+                                        if export_generics {\n+                                            if tcx.is_unreachable_local_definition(def_id) {\n+                                                // This instance cannot be used\n+                                                // from another crate.\n+                                                Visibility::Hidden\n+                                            } else {\n+                                                // This instance might be useful in\n+                                                // a downstream crate.\n+                                                can_be_internalized = false;\n+                                                default_visibility(def_id, true)\n+                                            }\n+                                        } else {\n+                                            // We are not exporting generics or\n+                                            // the definition is not reachable\n+                                            // for downstream crates, we can\n+                                            // internalize its instantiations.\n+                                            Visibility::Hidden\n+                                        }\n+                                    } else {\n+                                        // This isn't a generic function.\n+                                        if tcx.is_reachable_non_generic(def_id) {\n+                                            can_be_internalized = false;\n+                                            debug_assert!(!is_generic);\n+                                            default_visibility(def_id, false)\n+                                        } else {\n+                                            Visibility::Hidden\n+                                        }\n+                                    }\n+                                } else {\n+                                    // This is an upstream DefId.\n+                                    if export_generics && is_generic {\n+                                        // If it is a upstream monomorphization\n+                                        // and we export generics, we must make\n+                                        // it available to downstream crates.\n                                         can_be_internalized = false;\n-                                        default_visibility(def_id)\n+                                        default_visibility(def_id, true)\n                                     } else {\n                                         Visibility::Hidden\n                                     }\n-                                } else {\n-                                    Visibility::Hidden\n                                 }\n                             }\n                             InstanceDef::FnPtrShim(..) |\n@@ -387,7 +445,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     MonoItem::Static(def_id) => {\n                         let visibility = if tcx.is_reachable_non_generic(def_id) {\n                             can_be_internalized = false;\n-                            default_visibility(def_id)\n+                            default_visibility(def_id, false)\n                         } else {\n                             Visibility::Hidden\n                         };\n@@ -397,7 +455,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let def_id = tcx.hir.local_def_id(node_id);\n                         let visibility = if tcx.is_reachable_non_generic(def_id) {\n                             can_be_internalized = false;\n-                            default_visibility(def_id)\n+                            default_visibility(def_id, false)\n                         } else {\n                             Visibility::Hidden\n                         };"}, {"sha": "acd2a7657307c4db2d1a6d2d69c1a53336bcb06c", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 172, "deletions": 59, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -14,14 +14,17 @@ use std::sync::Arc;\n use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::TransFnAttrFlags;\n-use rustc::hir::def_id::CrateNum;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n+use rustc::ich::Fingerprint;\n use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol, metadata_symbol_name};\n use rustc::session::config;\n use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::{FxHashMap, DefIdSet};\n+use rustc::ty::subst::Substs;\n+use rustc::util::nodemap::{FxHashMap, DefIdMap};\n use rustc_allocator::ALLOCATOR_METHODS;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use std::collections::hash_map::Entry::*;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n@@ -56,51 +59,12 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType])\n \n fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              cnum: CrateNum)\n-                                             -> Lrc<DefIdSet>\n+                                             -> Lrc<DefIdMap<SymbolExportLevel>>\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_trans() {\n-        return Lrc::new(DefIdSet())\n-    }\n-\n-    let export_threshold = threshold(tcx);\n-\n-    // We already collect all potentially reachable non-generic items for\n-    // `exported_symbols`. Now we just filter them down to what is actually\n-    // exported for the given crate we are compiling.\n-    let reachable_non_generics = tcx\n-        .exported_symbols(LOCAL_CRATE)\n-        .iter()\n-        .filter_map(|&(exported_symbol, level)| {\n-            if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n-                if level.is_below_threshold(export_threshold) {\n-                    return Some(def_id)\n-                }\n-            }\n-\n-            None\n-        })\n-        .collect();\n-\n-    Lrc::new(reachable_non_generics)\n-}\n-\n-fn is_reachable_non_generic_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               def_id: DefId)\n-                                               -> bool {\n-    tcx.reachable_non_generics(def_id.krate).contains(&def_id)\n-}\n-\n-fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             cnum: CrateNum)\n-                                             -> Arc<Vec<(ExportedSymbol,\n-                                                         SymbolExportLevel)>>\n-{\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n-    if !tcx.sess.opts.output_types.should_trans() {\n-        return Arc::new(vec![])\n+        return Lrc::new(DefIdMap())\n     }\n \n     // Check to see if this crate is a \"special runtime crate\". These\n@@ -113,7 +77,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let special_runtime_crate = tcx.is_panic_runtime(LOCAL_CRATE) ||\n         tcx.is_compiler_builtins(LOCAL_CRATE);\n \n-    let reachable_non_generics: DefIdSet = tcx.reachable_set(LOCAL_CRATE).0\n+    let mut reachable_non_generics: DefIdMap<_> = tcx.reachable_set(LOCAL_CRATE).0\n         .iter()\n         .filter_map(|&node_id| {\n             // We want to ignore some FFI functions that are not exposed from\n@@ -166,11 +130,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => None\n             }\n         })\n-        .collect();\n-\n-    let mut symbols: Vec<_> = reachable_non_generics\n-        .iter()\n-        .map(|&def_id| {\n+        .map(|def_id| {\n             let export_level = if special_runtime_crate {\n                 let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n                 // We can probably do better here by just ensuring that\n@@ -188,24 +148,63 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     SymbolExportLevel::Rust\n                 }\n             } else {\n-                tcx.symbol_export_level(def_id)\n+                symbol_export_level(tcx, def_id)\n             };\n             debug!(\"EXPORTED SYMBOL (local): {} ({:?})\",\n                    tcx.symbol_name(Instance::mono(tcx, def_id)),\n                    export_level);\n-            (ExportedSymbol::NonGeneric(def_id), export_level)\n+            (def_id, export_level)\n         })\n         .collect();\n \n     if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n         let def_id = tcx.hir.local_def_id(id);\n-        symbols.push((ExportedSymbol::NonGeneric(def_id), SymbolExportLevel::C));\n+        reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }\n \n     if let Some(id) = tcx.sess.plugin_registrar_fn.get() {\n         let def_id = tcx.hir.local_def_id(id);\n-        symbols.push((ExportedSymbol::NonGeneric(def_id), SymbolExportLevel::C));\n+        reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n+    }\n+\n+    Lrc::new(reachable_non_generics)\n+}\n+\n+fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                     def_id: DefId)\n+                                                     -> bool {\n+    let export_threshold = threshold(tcx);\n+\n+    if let Some(&level) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n+        level.is_below_threshold(export_threshold)\n+    } else {\n+        false\n     }\n+}\n+\n+fn is_reachable_non_generic_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                      def_id: DefId)\n+                                                      -> bool {\n+    tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n+}\n+\n+fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Arc<Vec<(ExportedSymbol<'tcx>,\n+                                                         SymbolExportLevel)>>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Arc::new(vec![])\n+    }\n+\n+    let mut symbols: Vec<_> = tcx.reachable_non_generics(LOCAL_CRATE)\n+                                 .iter()\n+                                 .map(|(&def_id, &level)| {\n+                                    (ExportedSymbol::NonGeneric(def_id), level)\n+                                 })\n+                                 .collect();\n \n     if let Some(_) = *tcx.sess.entry_fn.borrow() {\n         let symbol_name = \"main\".to_string();\n@@ -244,6 +243,46 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         symbols.push((exported_symbol, SymbolExportLevel::Rust));\n     }\n \n+    if tcx.share_generics() && tcx.local_crate_exports_generics() {\n+        use rustc::mir::mono::{Linkage, Visibility, MonoItem};\n+        use rustc::ty::InstanceDef;\n+\n+        // Normally, we require that shared monomorphizations are not hidden,\n+        // because if we want to re-use a monomorphization from a Rust dylib, it\n+        // needs to be exported.\n+        // However, on platforms that don't allow for Rust dylibs, having\n+        // external linkage is enough for monomorphization to be linked to.\n+        let need_visibility = tcx.sess.target.target.options.dynamic_linking &&\n+                              !tcx.sess.target.target.options.only_cdylib;\n+\n+        let (_, cgus) = tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n+\n+        for (mono_item, &(linkage, visibility)) in cgus.iter()\n+                                                       .flat_map(|cgu| cgu.items().iter()) {\n+            if linkage != Linkage::External {\n+                // We can only re-use things with external linkage, otherwise\n+                // we'll get a linker error\n+                continue\n+            }\n+\n+            if need_visibility && visibility == Visibility::Hidden {\n+                // If we potentially share things from Rust dylibs, they must\n+                // not be hidden\n+                continue\n+            }\n+\n+            if let &MonoItem::Fn(Instance {\n+                def: InstanceDef::Item(def_id),\n+                substs,\n+            }) = mono_item {\n+                if substs.types().next().is_some() {\n+                    symbols.push((ExportedSymbol::Generic(def_id, substs),\n+                                  SymbolExportLevel::Rust));\n+                }\n+            }\n+        }\n+    }\n+\n     // Sort so we get a stable incr. comp. hash.\n     symbols.sort_unstable_by(|&(ref symbol1, ..), &(ref symbol2, ..)| {\n         symbol1.compare_stable(tcx, symbol2)\n@@ -252,19 +291,93 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Arc::new(symbols)\n }\n \n+fn upstream_monomorphizations_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    cnum: CrateNum)\n+    -> Lrc<DefIdMap<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>>\n+{\n+    debug_assert!(cnum == LOCAL_CRATE);\n+\n+    let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n+\n+    let mut instances = DefIdMap();\n+\n+    let cnum_stable_ids: IndexVec<CrateNum, Fingerprint> = {\n+        let mut cnum_stable_ids = IndexVec::from_elem_n(Fingerprint::ZERO,\n+                                                        cnums.len() + 1);\n+\n+        for &cnum in cnums.iter() {\n+            cnum_stable_ids[cnum] = tcx.def_path_hash(DefId {\n+                krate: cnum,\n+                index: CRATE_DEF_INDEX,\n+            }).0;\n+        }\n+\n+        cnum_stable_ids\n+    };\n+\n+    for &cnum in cnums.iter() {\n+        for &(ref exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n+            if let &ExportedSymbol::Generic(def_id, substs) = exported_symbol {\n+                let substs_map = instances.entry(def_id)\n+                                          .or_insert_with(|| FxHashMap());\n+\n+                match substs_map.entry(substs) {\n+                    Occupied(mut e) => {\n+                        // If there are multiple monomorphizations available,\n+                        // we select one deterministically.\n+                        let other_cnum = *e.get();\n+                        if cnum_stable_ids[other_cnum] > cnum_stable_ids[cnum] {\n+                            e.insert(cnum);\n+                        }\n+                    }\n+                    Vacant(e) => {\n+                        e.insert(cnum);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    Lrc::new(instances.into_iter()\n+                      .map(|(key, value)| (key, Lrc::new(value)))\n+                      .collect())\n+}\n+\n+fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId)\n+    -> Option<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>\n+{\n+    debug_assert!(!def_id.is_local());\n+    tcx.upstream_monomorphizations(LOCAL_CRATE)\n+       .get(&def_id)\n+       .cloned()\n+}\n+\n+fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n+    } else {\n+        bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n+              def_id)\n+    }\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     providers.reachable_non_generics = reachable_non_generics_provider;\n-    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider_local;\n     providers.exported_symbols = exported_symbols_provider_local;\n-    providers.symbol_export_level = symbol_export_level_provider;\n+    providers.upstream_monomorphizations = upstream_monomorphizations_provider;\n+    providers.is_unreachable_local_definition = is_unreachable_local_definition_provider;\n }\n \n pub fn provide_extern(providers: &mut Providers) {\n-    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n-    providers.symbol_export_level = symbol_export_level_provider;\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider_extern;\n+    providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n }\n \n-fn symbol_export_level_provider(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "2c503bdab30a9b68745c2641635c3be58bfa2f4a", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -118,44 +118,84 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         // This is sort of subtle. Inside our codegen unit we started off\n         // compilation by predefining all our own `TransItem` instances. That\n         // is, everything we're translating ourselves is already defined. That\n-        // means that anything we're actually translating ourselves will have\n-        // hit the above branch in `get_declared_value`. As a result, we're\n-        // guaranteed here that we're declaring a symbol that won't get defined,\n-        // or in other words we're referencing a foreign value.\n+        // means that anything we're actually translating in this codegen unit\n+        // will have hit the above branch in `get_declared_value`. As a result,\n+        // we're guaranteed here that we're declaring a symbol that won't get\n+        // defined, or in other words we're referencing a value from another\n+        // codegen unit or even another crate.\n         //\n         // So because this is a foreign value we blanket apply an external\n         // linkage directive because it's coming from a different object file.\n         // The visibility here is where it gets tricky. This symbol could be\n         // referencing some foreign crate or foreign library (an `extern`\n         // block) in which case we want to leave the default visibility. We may\n-        // also, though, have multiple codegen units.\n-        //\n-        // In the situation of multiple codegen units this function may be\n-        // referencing a function from another codegen unit. If we're\n-        // indeed referencing a symbol in another codegen unit then we're in one\n-        // of two cases:\n-        //\n-        //  * This is a symbol defined in a foreign crate and we're just\n-        //    monomorphizing in another codegen unit. In this case this symbols\n-        //    is for sure not exported, so both codegen units will be using\n-        //    hidden visibility. Hence, we apply a hidden visibility here.\n-        //\n-        //  * This is a symbol defined in our local crate. If the symbol in the\n-        //    other codegen unit is also not exported then like with the foreign\n-        //    case we apply a hidden visibility. If the symbol is exported from\n-        //    the foreign object file, however, then we leave this at the\n-        //    default visibility as we'll just import it naturally.\n+        // also, though, have multiple codegen units. It could be a\n+        // monomorphization, in which case its expected visibility depends on\n+        // whether we are sharing generics or not. The important thing here is\n+        // that the visibility we apply to the declaration is the same one that\n+        // has been applied to the definition (wherever that definition may be).\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if cx.tcx.is_translated_item(instance_def_id) {\n-                if instance_def_id.is_local() {\n-                    if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n-                        llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+            let is_generic = instance.substs.types().next().is_some();\n+\n+            if is_generic {\n+                // This is a monomorphization. Its expected visibility depends\n+                // on whether we are in share-generics mode.\n+\n+                if cx.tcx.share_generics() {\n+                    // We are in share_generics mode.\n+\n+                    if instance_def_id.is_local() {\n+                        // This is a definition from the current crate. If the\n+                        // definition is unreachable for downstream crates or\n+                        // the current crate does not re-export generics, the\n+                        // definition of the instance will have been declared\n+                        // as `hidden`.\n+                        if cx.tcx.is_unreachable_local_definition(instance_def_id) ||\n+                           !cx.tcx.local_crate_exports_generics() {\n+                            llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                        }\n+                    } else {\n+                        // This is a monomorphization of a generic function\n+                        // defined in an upstream crate.\n+                        if cx.tcx.upstream_monomorphizations_for(instance_def_id)\n+                                 .map(|set| set.contains_key(instance.substs))\n+                                 .unwrap_or(false) {\n+                            // This is instantiated in another crate. It cannot\n+                            // be `hidden`.\n+                        } else {\n+                            // This is a local instantiation of an upstream definition.\n+                            // If the current crate does not re-export it\n+                            // (because it is a C library or an executable), it\n+                            // will have been declared `hidden`.\n+                            if !cx.tcx.local_crate_exports_generics() {\n+                                llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                            }\n+                        }\n                     }\n                 } else {\n+                    // When not sharing generics, all instances are in the same\n+                    // crate and have hidden visibility\n                     llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                 }\n+            } else {\n+                // This is a non-generic function\n+                if cx.tcx.is_translated_item(instance_def_id) {\n+                    // This is a function that is instantiated in the local crate\n+\n+                    if instance_def_id.is_local() {\n+                        // This is function that is defined in the local crate.\n+                        // If it is not reachable, it is hidden.\n+                        if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n+                            llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                        }\n+                    } else {\n+                        // This is a function from an upstream crate that has\n+                        // been instantiated here. These are always hidden.\n+                        llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                    }\n+                }\n             }\n         }\n "}, {"sha": "f8f2fdd9320d2a5fd061a7137664f1b9200eb465", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -33,6 +33,7 @@\n #![cfg_attr(stage0, feature(conservative_impl_trait))]\n #![feature(optin_builtin_traits)]\n #![feature(inclusive_range_fields)]\n+#![feature(underscore_lifetimes)]\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;"}, {"sha": "af174f7ce8516f2eef0b536ce3313951a73ee4f4", "filename": "src/librustc_trans_utils/symbol_names.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -100,7 +100,7 @@\n use rustc::middle::weak_lang_items;\n use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::item::{MonoItem, MonoItemExt, InstantiationMode};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n@@ -170,32 +170,45 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         assert!(!substs.needs_subst());\n         substs.visit_with(&mut hasher);\n \n-        let mut avoid_cross_crate_conflicts = false;\n-\n-        // If this is an instance of a generic function, we also hash in\n-        // the ID of the instantiating crate. This avoids symbol conflicts\n-        // in case the same instances is emitted in two crates of the same\n-        // project.\n-        if substs.types().next().is_some() {\n-            avoid_cross_crate_conflicts = true;\n-        }\n-\n-        // If we're dealing with an instance of a function that's inlined from\n-        // another crate but we're marking it as globally shared to our\n-        // compliation (aka we're not making an internal copy in each of our\n-        // codegen units) then this symbol may become an exported (but hidden\n-        // visibility) symbol. This means that multiple crates may do the same\n-        // and we want to be sure to avoid any symbol conflicts here.\n-        match MonoItem::Fn(instance).instantiation_mode(tcx) {\n-            InstantiationMode::GloballyShared { may_conflict: true } => {\n-                avoid_cross_crate_conflicts = true;\n-            }\n-            _ => {}\n-        }\n+        let is_generic = substs.types().next().is_some();\n+        let avoid_cross_crate_conflicts =\n+            // If this is an instance of a generic function, we also hash in\n+            // the ID of the instantiating crate. This avoids symbol conflicts\n+            // in case the same instances is emitted in two crates of the same\n+            // project.\n+            is_generic ||\n+\n+            // If we're dealing with an instance of a function that's inlined from\n+            // another crate but we're marking it as globally shared to our\n+            // compliation (aka we're not making an internal copy in each of our\n+            // codegen units) then this symbol may become an exported (but hidden\n+            // visibility) symbol. This means that multiple crates may do the same\n+            // and we want to be sure to avoid any symbol conflicts here.\n+            match MonoItem::Fn(instance).instantiation_mode(tcx) {\n+                InstantiationMode::GloballyShared { may_conflict: true } => true,\n+                _ => false,\n+            };\n \n         if avoid_cross_crate_conflicts {\n-            hasher.hash(tcx.crate_name.as_str());\n-            hasher.hash(tcx.sess.local_crate_disambiguator());\n+            let instantiating_crate = if is_generic {\n+                if !def_id.is_local() && tcx.share_generics() {\n+                    // If we are re-using a monomorphization from another crate,\n+                    // we have to compute the symbol hash accordingly.\n+                    let upstream_monomorphizations =\n+                        tcx.upstream_monomorphizations_for(def_id);\n+\n+                    upstream_monomorphizations.and_then(|monos| monos.get(&substs)\n+                                                                     .cloned())\n+                                              .unwrap_or(LOCAL_CRATE)\n+                } else {\n+                    LOCAL_CRATE\n+                }\n+            } else {\n+                LOCAL_CRATE\n+            };\n+\n+            hasher.hash(&tcx.original_crate_name(instantiating_crate).as_str()[..]);\n+            hasher.hash(&tcx.crate_disambiguator(instantiating_crate));\n         }\n     });\n "}, {"sha": "b742da8a9001f6304dd061a6d96ac67464374fd8", "filename": "src/test/codegen-units/partitioning/auxiliary/shared_generics_aux.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Zshare-generics=yes\n+\n+#![crate_type=\"rlib\"]\n+\n+pub fn generic_fn<T>(x: T, y: T) -> (T, T) {\n+    (x, y)\n+}\n+\n+pub fn use_generic_fn_f32() -> (f32, f32) {\n+    generic_fn(0.0f32, 1.0f32)\n+}"}, {"sha": "140b43c85d548d93d61cbedfb7b8e156cbd5c0f3", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n-// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp/partitioning-tests/extern-generic\n+// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp/partitioning-tests/extern-generic -Zshare-generics=y\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n@@ -59,4 +59,4 @@ mod mod3 {\n // Make sure the two generic functions from the extern crate get instantiated\n // once for the current crate\n //~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n-//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[Internal]\n+//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]"}, {"sha": "d352609bfcbe4f1f8009a9e76be70648098f70fc", "filename": "src/test/codegen-units/partitioning/shared-generics.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe\n+\n+#![crate_type=\"rlib\"]\n+\n+// aux-build:shared_generics_aux.rs\n+extern crate shared_generics_aux;\n+\n+//~ TRANS_ITEM fn shared_generics::foo[0]\n+pub fn foo() {\n+\n+    //~ TRANS_ITEM fn shared_generics_aux::generic_fn[0]<u16> @@ shared_generics_aux.volatile[External]\n+    let _ = shared_generics_aux::generic_fn(0u16, 1u16);\n+\n+    // This should not generate a monomorphization because it's already\n+    // available in `shared_generics_aux`.\n+    let _ = shared_generics_aux::generic_fn(0.0f32, 3.0f32);\n+}\n+\n+// TRANS_ITEM drop-glue i8"}, {"sha": "162a025c30217c45a5aab8cb4dcc2096f0db2700", "filename": "src/test/codegen/local-generics-in-exe-internalized.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen%2Flocal-generics-in-exe-internalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Fcodegen%2Flocal-generics-in-exe-internalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flocal-generics-in-exe-internalized.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes -Zshare-generics=yes\n+\n+// Check that local generics are internalized if they are in the same CGU\n+\n+// CHECK: define internal {{.*}} @_ZN34local_generics_in_exe_internalized3foo{{.*}}\n+pub fn foo<T>(x: T, y: T) -> (T, T) {\n+    (x, y)\n+}\n+\n+fn main() {\n+    let _ = foo(0u8, 1u8);\n+}"}, {"sha": "17d470063fc934f6ce8fb418f00adf9863e4f1e5", "filename": "src/test/run-make-fulldeps/symbol-visibility/Makefile", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -23,11 +23,11 @@ COMBINED_CDYLIB_NAME=libcombined_rlib_dylib.dylib\n endif\n \n all:\n-\t$(RUSTC) an_rlib.rs\n-\t$(RUSTC) a_cdylib.rs\n-\t$(RUSTC) a_rust_dylib.rs\n-\t$(RUSTC) an_executable.rs\n-\t$(RUSTC) a_cdylib.rs --crate-name combined_rlib_dylib --crate-type=rlib,cdylib\n+\t$(RUSTC) -Zshare-generics=no an_rlib.rs\n+\t$(RUSTC) -Zshare-generics=no a_cdylib.rs\n+\t$(RUSTC) -Zshare-generics=no a_rust_dylib.rs\n+\t$(RUSTC) -Zshare-generics=no an_executable.rs\n+\t$(RUSTC) -Zshare-generics=no a_cdylib.rs --crate-name combined_rlib_dylib --crate-type=rlib,cdylib\n \n \t# Check that a cdylib exports its public #[no_mangle] functions\n \t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n@@ -39,10 +39,15 @@ all:\n \t# Check that a Rust dylib exports its monomorphic functions\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_rust_function_from_rust_dylib.*E)\" -eq \"1\" ]\n+\t# Check that a Rust dylib does not export generics if -Zshare-generics=no\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rust_dylib.*E)\" -eq \"0\" ]\n+\n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n+\t# Check that a Rust dylib does not export generics if -Zshare-generics=no\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rlib.*E)\" -eq \"0\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n \t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n@@ -57,4 +62,31 @@ all:\n \t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n \t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c _ZN.*h.*E)\" -eq \"0\" ]\n+\n+\n+\t$(RUSTC) -Zshare-generics=yes an_rlib.rs\n+\t$(RUSTC) -Zshare-generics=yes a_cdylib.rs\n+\t$(RUSTC) -Zshare-generics=yes a_rust_dylib.rs\n+\t$(RUSTC) -Zshare-generics=yes an_executable.rs\n+\n+\t# Check that a cdylib exports its public #[no_mangle] functions\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n+\t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t# Check that a cdylib DOES NOT export any public Rust functions\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c _ZN.*h.*E)\" -eq \"0\" ]\n+\n+\t# Check that a Rust dylib exports its monomorphic functions, including generics this time\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_rust_function_from_rust_dylib.*E)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rust_dylib.*E)\" -eq \"1\" ]\n+\n+\t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rlib.*E)\" -eq \"1\" ]\n+\n+\t# Check that an executable does not export any dynamic symbols\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_rust_function_from_exe)\" -eq \"0\" ]\n endif"}, {"sha": "99e748ec2efc88e8659f64ed2eb97ef08c52efe1", "filename": "src/test/run-make-fulldeps/symbol-visibility/a_rust_dylib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2Fa_rust_dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2Fa_rust_dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2Fa_rust_dylib.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -17,4 +17,9 @@ pub fn public_rust_function_from_rust_dylib() {}\n \n // This should be exported\n #[no_mangle]\n-pub extern \"C\" fn public_c_function_from_rust_dylib() {}\n+pub extern \"C\" fn public_c_function_from_rust_dylib() {\n+    let _ = public_generic_function_from_rust_dylib(1u16);\n+}\n+\n+// This should be exported if -Zshare-generics=yes\n+pub fn public_generic_function_from_rust_dylib<T>(x: T) -> T { x }"}, {"sha": "a1d73afd30b110684d51086d761cfa619e6d9665", "filename": "src/test/run-make-fulldeps/symbol-visibility/an_rlib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2Fan_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2Fan_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2Fan_rlib.rs?ref=7678d5021e5c984af52f4d1e9147f7a2d6a7ddc3", "patch": "@@ -13,4 +13,10 @@\n pub fn public_rust_function_from_rlib() {}\n \n #[no_mangle]\n-pub extern \"C\" fn public_c_function_from_rlib() {}\n+pub extern \"C\" fn public_c_function_from_rlib() {\n+    let _ = public_generic_function_from_rlib(0u64);\n+}\n+\n+pub fn public_generic_function_from_rlib<T>(x: T) -> T {\n+    x\n+}"}]}