{"sha": "87c2907bca4fbb4fabb909c6da5988a97866938d", "node_id": "C_kwDOAAsO6NoAKDg3YzI5MDdiY2E0ZmJiNGZhYmI5MDljNmRhNTk4OGE5Nzg2NjkzOGQ", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-15T10:35:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-15T15:47:04Z"}, "message": "remove compare-fn and use erased-ty", "tree": {"sha": "59981c3a25f7e1ebb689901a34bc5a221816ab74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59981c3a25f7e1ebb689901a34bc5a221816ab74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c2907bca4fbb4fabb909c6da5988a97866938d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c2907bca4fbb4fabb909c6da5988a97866938d", "html_url": "https://github.com/rust-lang/rust/commit/87c2907bca4fbb4fabb909c6da5988a97866938d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c2907bca4fbb4fabb909c6da5988a97866938d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e260afc3ba1eeeb3bd006fb72474365698b88c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/e260afc3ba1eeeb3bd006fb72474365698b88c47", "html_url": "https://github.com/rust-lang/rust/commit/e260afc3ba1eeeb3bd006fb72474365698b88c47"}], "stats": {"total": 40, "additions": 23, "deletions": 17}, "files": [{"sha": "e17ec3034a5613c389d9068e342f66a486711c28", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/87c2907bca4fbb4fabb909c6da5988a97866938d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c2907bca4fbb4fabb909c6da5988a97866938d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=87c2907bca4fbb4fabb909c6da5988a97866938d", "patch": "@@ -123,14 +123,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n-        self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n-            if let ty::Projection(..) = ty.kind() {\n-                let erased_ty = self.tcx.erase_regions(ty);\n-                erased_ty == erased_projection_ty\n-            } else {\n-                false\n-            }\n-        })\n+        self.declared_generic_bounds_from_env_for_erased_ty(erased_projection_ty)\n     }\n \n     /// Searches the where-clauses in scope for regions that\n@@ -219,12 +212,23 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         param_ty: ty::ParamTy,\n     ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let generic_ty = param_ty.to_ty(self.tcx);\n-        self.declared_generic_bounds_from_env_with_compare_fn(|ty| ty == generic_ty)\n+        self.declared_generic_bounds_from_env_for_erased_ty(generic_ty)\n     }\n \n-    fn declared_generic_bounds_from_env_with_compare_fn(\n+    /// Searches the environment to find all bounds that apply to `erased_ty`.\n+    /// Obviously these must be approximate -- they are in fact both *over* and\n+    /// and *under* approximated:\n+    ///\n+    /// * Over-approximated because we erase regions, so\n+    /// * Under-approximated because we look for syntactic equality and so for complex types\n+    ///   like `<T as Foo<fn(&u32, &u32)>>::Item` or whatever we may fail to figure out\n+    ///   all the subtleties.\n+    ///\n+    /// In some cases, such as when `erased_ty` represents a `ty::Param`, however,\n+    /// the result is precise.\n+    fn declared_generic_bounds_from_env_for_erased_ty(\n         &self,\n-        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+        erased_ty: Ty<'tcx>,\n     ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let tcx = self.tcx;\n \n@@ -235,7 +239,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // like `T` and `T::Item`. It may not work as well for things\n         // like `<T as Foo<'a>>::Item`.\n         let c_b = self.param_env.caller_bounds();\n-        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b.into_iter());\n+        let param_bounds = self.collect_outlives_from_predicate_list(erased_ty, c_b.into_iter());\n \n         // Next, collect regions we scraped from the well-formedness\n         // constraints in the fn signature. To do that, we walk the list\n@@ -250,18 +254,19 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // don't know that this holds from first principles.\n         let from_region_bound_pairs = self.region_bound_pairs.iter().filter_map(|&(r, p)| {\n             debug!(\n-                \"declared_generic_bounds_from_env_with_compare_fn: region_bound_pair = {:?}\",\n+                \"declared_generic_bounds_from_env_for_erased_ty: region_bound_pair = {:?}\",\n                 (r, p)\n             );\n             let p_ty = p.to_ty(tcx);\n-            compare_ty(p_ty).then_some(ty::OutlivesPredicate(p_ty, r))\n+            let erased_p_ty = self.tcx.erase_regions(p_ty);\n+            (erased_p_ty == erased_ty).then_some(ty::OutlivesPredicate(p.to_ty(tcx), r))\n         });\n \n         param_bounds\n             .chain(from_region_bound_pairs)\n             .inspect(|bound| {\n                 debug!(\n-                    \"declared_generic_bounds_from_env_with_compare_fn: result predicate = {:?}\",\n+                    \"declared_generic_bounds_from_env_for_erased_ty: result predicate = {:?}\",\n                     bound\n                 )\n             })\n@@ -341,12 +346,13 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// otherwise want a precise match.\n     fn collect_outlives_from_predicate_list(\n         &self,\n-        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+        erased_ty: Ty<'tcx>,\n         predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let tcx = self.tcx;\n         predicates\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n-            .filter(move |p| compare_ty(p.0))\n+            .filter(move |p| tcx.erase_regions(p.0) == erased_ty)\n     }\n }"}]}