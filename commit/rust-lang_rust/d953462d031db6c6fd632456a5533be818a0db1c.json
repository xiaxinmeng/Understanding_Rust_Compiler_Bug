{"sha": "d953462d031db6c6fd632456a5533be818a0db1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NTM0NjJkMDMxZGI2YzZmZDYzMjQ1NmE1NTMzYmU4MThhMGRiMWM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-15T02:53:56Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-15T02:58:34Z"}, "message": "Complete a data visitor type that does proper pointer-walking.", "tree": {"sha": "2fd5a72019f94ae4e94a7aa872fefb5bbe1da77a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fd5a72019f94ae4e94a7aa872fefb5bbe1da77a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d953462d031db6c6fd632456a5533be818a0db1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d953462d031db6c6fd632456a5533be818a0db1c", "html_url": "https://github.com/rust-lang/rust/commit/d953462d031db6c6fd632456a5533be818a0db1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d953462d031db6c6fd632456a5533be818a0db1c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a214e3abd23fa68e358ff4647aab6c34f91f3d9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a214e3abd23fa68e358ff4647aab6c34f91f3d9b", "html_url": "https://github.com/rust-lang/rust/commit/a214e3abd23fa68e358ff4647aab6c34f91f3d9b"}], "stats": {"total": 778, "additions": 606, "deletions": 172}, "files": [{"sha": "6496d8052d408988c8ffe5f9e867b471cc8fdbfa", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d953462d031db6c6fd632456a5533be818a0db1c/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d953462d031db6c6fd632456a5533be818a0db1c/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=d953462d031db6c6fd632456a5533be818a0db1c", "patch": "@@ -52,29 +52,38 @@ mod intrinsic {\n         fn visit_leave_evec_uniq(mtbl: uint) -> bool;\n         fn visit_enter_evec_slice(mtbl: uint) -> bool;\n         fn visit_leave_evec_slice(mtbl: uint) -> bool;\n-        fn visit_enter_evec_fixed(mtbl: uint, sz: uint) -> bool;\n-        fn visit_leave_evec_fixed(mtbl: uint, sz: uint) -> bool;\n+        fn visit_enter_evec_fixed(mtbl: uint, n: uint,\n+                                  sz: uint, align: uint) -> bool;\n+        fn visit_leave_evec_fixed(mtbl: uint, n: uint,\n+                                  sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_rec(n_fields: uint) -> bool;\n+        fn visit_enter_rec(n_fields: uint,\n+                           sz: uint, align: uint) -> bool;\n         fn visit_enter_rec_field(mtbl: uint, i: uint,\n                                  name: str/&) -> bool;\n         fn visit_leave_rec_field(mtbl: uint, i: uint,\n                                  name: str/&) -> bool;\n-        fn visit_leave_rec(n_fields: uint) -> bool;\n+        fn visit_leave_rec(n_fields: uint,\n+                           sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_class(n_fields: uint) -> bool;\n+        fn visit_enter_class(n_fields: uint,\n+                             sz: uint, align: uint) -> bool;\n         fn visit_enter_class_field(mtbl: uint, i: uint,\n                                    name: str/&) -> bool;\n         fn visit_leave_class_field(mtbl: uint, i: uint,\n                                    name: str/&) -> bool;\n-        fn visit_leave_class(n_fields: uint) -> bool;\n+        fn visit_leave_class(n_fields: uint,\n+                             sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_tup(n_fields: uint) -> bool;\n+        fn visit_enter_tup(n_fields: uint,\n+                           sz: uint, align: uint) -> bool;\n         fn visit_enter_tup_field(i: uint) -> bool;\n         fn visit_leave_tup_field(i: uint) -> bool;\n-        fn visit_leave_tup(n_fields: uint) -> bool;\n+        fn visit_leave_tup(n_fields: uint,\n+                           sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_enum(n_variants: uint) -> bool;\n+        fn visit_enter_enum(n_variants: uint,\n+                            sz: uint, align: uint) -> bool;\n         fn visit_enter_enum_variant(variant: uint,\n                                     disr_val: int,\n                                     n_fields: uint,\n@@ -85,7 +94,8 @@ mod intrinsic {\n                                     disr_val: int,\n                                     n_fields: uint,\n                                     name: str/&) -> bool;\n-        fn visit_leave_enum(n_variants: uint) -> bool;\n+        fn visit_leave_enum(n_variants: uint,\n+                            sz: uint, align: uint) -> bool;\n \n         fn visit_enter_fn(purity: uint, proto: uint,\n                           n_inputs: uint, retstyle: uint) -> bool;"}, {"sha": "9731c34fa8238cf525785b3310633ad301be4b24", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d953462d031db6c6fd632456a5533be818a0db1c/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d953462d031db6c6fd632456a5533be818a0db1c/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=d953462d031db6c6fd632456a5533be818a0db1c", "patch": "@@ -80,10 +80,14 @@ impl methods for reflector {\n                          [self.c_uint(mt.mutbl as uint)] + extra);\n     }\n \n-    fn vstore_name_and_extra(vstore: ty::vstore,\n+    fn vstore_name_and_extra(t: ty::t,\n+                             vstore: ty::vstore,\n                              f: fn(str,[ValueRef])) {\n         alt vstore {\n-          ty::vstore_fixed(n) { f(\"fixed\", [self.c_uint(n)]) }\n+          ty::vstore_fixed(n) {\n+            let extra = [self.c_uint(n)] + self.c_size_and_align(t);\n+            f(\"fixed\", extra)\n+          }\n           ty::vstore_slice(_) { f(\"slice\", []) }\n           ty::vstore_uniq { f(\"uniq\", []);}\n           ty::vstore_box { f(\"box\", []); }\n@@ -123,12 +127,12 @@ impl methods for reflector {\n \n           ty::ty_vec(mt) { self.bracketed_mt(\"vec\", mt, []) }\n           ty::ty_estr(vst) {\n-            self.vstore_name_and_extra(vst) {|name, extra|\n+            self.vstore_name_and_extra(t, vst) {|name, extra|\n                 self.visit(\"estr_\" + name, extra)\n             }\n           }\n           ty::ty_evec(mt, vst) {\n-            self.vstore_name_and_extra(vst) {|name, extra|\n+            self.vstore_name_and_extra(t, vst) {|name, extra|\n                 self.bracketed_mt(\"evec_\" + name, mt, extra)\n             }\n           }\n@@ -138,21 +142,25 @@ impl methods for reflector {\n           ty::ty_rptr(_, mt) { self.bracketed_mt(\"rptr\", mt, []) }\n \n           ty::ty_rec(fields) {\n-            self.visit(\"enter_rec\", [self.c_uint(vec::len(fields))]);\n+            let extra = ([self.c_uint(vec::len(fields))]\n+                         + self.c_size_and_align(t));\n+            self.visit(\"enter_rec\", extra);\n             for fields.eachi {|i, field|\n                 self.bracketed_mt(\"rec_field\", field.mt,\n                                   [self.c_uint(i),\n                                    self.c_slice(*field.ident)]);\n             }\n-            self.visit(\"leave_rec\", [self.c_uint(vec::len(fields))]);\n+            self.visit(\"leave_rec\", extra);\n           }\n \n           ty::ty_tup(tys) {\n-            self.visit(\"enter_tup\", [self.c_uint(vec::len(tys))]);\n+            let extra = ([self.c_uint(vec::len(tys))]\n+                         + self.c_size_and_align(t));\n+            self.visit(\"enter_tup\", extra);\n             for tys.eachi {|i, t|\n                 self.bracketed_t(\"tup_field\", t, [self.c_uint(i)]);\n             }\n-            self.visit(\"leave_tup\", [self.c_uint(vec::len(tys))]);\n+            self.visit(\"leave_tup\", extra);\n           }\n \n           // FIXME: fetch constants out of intrinsic:: for the numbers.\n@@ -206,13 +214,16 @@ impl methods for reflector {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let fields = ty::class_items_as_fields(tcx, did, substs);\n-            self.visit(\"enter_class\", [self.c_uint(vec::len(fields))]);\n+            let extra = ([self.c_uint(vec::len(fields))]\n+                         + self.c_size_and_align(t));\n+\n+            self.visit(\"enter_class\", extra);\n             for fields.eachi {|i, field|\n                 self.bracketed_mt(\"class_field\", field.mt,\n                                   [self.c_uint(i),\n                                    self.c_slice(*field.ident)]);\n             }\n-            self.visit(\"leave_class\", [self.c_uint(vec::len(fields))]);\n+            self.visit(\"leave_class\", extra);\n           }\n \n           // FIXME: visiting all the variants in turn is probably\n@@ -223,8 +234,10 @@ impl methods for reflector {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let variants = ty::substd_enum_variants(tcx, did, substs);\n+            let extra = ([self.c_uint(vec::len(variants))]\n+                         + self.c_size_and_align(t));\n \n-            self.visit(\"enter_enum\", [self.c_uint(vec::len(variants))]);\n+            self.visit(\"enter_enum\", extra);\n             for variants.eachi {|i, v|\n                 let extra = [self.c_uint(i),\n                              self.c_int(v.disr_val),\n@@ -237,7 +250,7 @@ impl methods for reflector {\n                 }\n                 self.visit(\"leave_enum_variant\", extra);\n             }\n-            self.visit(\"leave_enum\", [self.c_uint(vec::len(variants))]);\n+            self.visit(\"leave_enum\", extra);\n           }\n \n           // Miscallaneous extra types"}, {"sha": "391acdaa9a2c952f4d0768a36ab1fb55503ea33c", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 558, "deletions": 150, "changes": 708, "blob_url": "https://github.com/rust-lang/rust/blob/d953462d031db6c6fd632456a5533be818a0db1c/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d953462d031db6c6fd632456a5533be818a0db1c/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d953462d031db6c6fd632456a5533be818a0db1c", "patch": "@@ -1,191 +1,588 @@\n+// FIXME: un-xfail after snapshot\n+// xfail-test\n+\n+import intrinsic::ty_visitor;\n import libc::c_void;\n \n-iface data_cursor {\n-    fn set_ptr(p: *c_void);\n-    fn get_ptr() -> *c_void;\n+#[doc = \"High-level interfaces to `intrinsic::visit_ty` reflection system.\"]\n+\n+#[doc = \"Iface for visitor that wishes to reflect on data.\"]\n+iface movable_ptr {\n+    fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n }\n \n-enum my_visitor = @{\n-    mut ptr: *c_void,\n-    mut vals: [str]\n+#[doc = \"Helper function for alignment calculation.\"]\n+#[inline(always)]\n+fn align(size: uint, align: uint) -> uint {\n+    ((size + align) - 1u) & !(align - 1u)\n+}\n+\n+enum ptr_visit_adaptor<V: ty_visitor movable_ptr> = {\n+    inner: V\n };\n+impl ptr_visitor<V: ty_visitor movable_ptr>\n+    of ty_visitor for ptr_visit_adaptor<V> {\n \n-impl methods for my_visitor {\n-    fn get<T>(f: fn(T)) {\n-        unsafe {\n-            f(*(self.ptr as *T));\n+    #[inline(always)]\n+    fn bump(sz: uint) {\n+        self.inner.move_ptr() {|p|\n+            ((p as uint) + sz) as *c_void\n         }\n     }\n-}\n \n-impl of data_cursor for my_visitor {\n-    fn set_ptr(p: *c_void) { self.ptr = p; }\n-    fn get_ptr() -> *c_void { self.ptr }\n-}\n+    #[inline(always)]\n+    fn align(a: uint) {\n+        self.inner.move_ptr() {|p|\n+            align(p as uint, a) as *c_void\n+        }\n+    }\n \n-impl of intrinsic::ty_visitor for my_visitor {\n+    #[inline(always)]\n+    fn align_to<T>() {\n+        self.align(sys::min_align_of::<T>());\n+    }\n+\n+    #[inline(always)]\n+    fn bump_past<T>() {\n+        self.bump(sys::size_of::<T>());\n+    }\n+\n+    fn visit_bot() -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_bot() { ret false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_nil() -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_nil() { ret false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n \n-    fn visit_bot() -> bool { true }\n-    fn visit_nil() -> bool { true }\n     fn visit_bool() -> bool {\n-        self.get::<bool>() {|b|\n-            self.vals += [bool::to_str(b)];\n-        }\n+        self.align_to::<bool>();\n+        if ! self.inner.visit_bool() { ret false; }\n+        self.bump_past::<bool>();\n         true\n     }\n+\n     fn visit_int() -> bool {\n-        self.get::<int>() {|i|\n-            self.vals += [int::to_str(i, 10u)];\n+        self.align_to::<int>();\n+        if ! self.inner.visit_int() { ret false; }\n+        self.bump_past::<int>();\n+        true\n+    }\n+\n+    fn visit_i8() -> bool {\n+        self.align_to::<i8>();\n+        if ! self.inner.visit_i8() { ret false; }\n+        self.bump_past::<i8>();\n+        true\n+    }\n+\n+    fn visit_i16() -> bool {\n+        self.align_to::<i16>();\n+        if ! self.inner.visit_i16() { ret false; }\n+        self.bump_past::<i16>();\n+        true\n+    }\n+\n+    fn visit_i32() -> bool {\n+        self.align_to::<i32>();\n+        if ! self.inner.visit_i32() { ret false; }\n+        self.bump_past::<i32>();\n+        true\n+    }\n+\n+    fn visit_i64() -> bool {\n+        self.align_to::<i64>();\n+        if ! self.inner.visit_i64() { ret false; }\n+        self.bump_past::<i64>();\n+        true\n+    }\n+\n+    fn visit_uint() -> bool {\n+        self.align_to::<uint>();\n+        if ! self.inner.visit_uint() { ret false; }\n+        self.bump_past::<uint>();\n+        true\n+    }\n+\n+    fn visit_u8() -> bool {\n+        self.align_to::<u8>();\n+        if ! self.inner.visit_u8() { ret false; }\n+        self.bump_past::<u8>();\n+        true\n+    }\n+\n+    fn visit_u16() -> bool {\n+        self.align_to::<u16>();\n+        if ! self.inner.visit_u16() { ret false; }\n+        self.bump_past::<u16>();\n+        true\n+    }\n+\n+    fn visit_u32() -> bool {\n+        self.align_to::<u32>();\n+        if ! self.inner.visit_u32() { ret false; }\n+        self.bump_past::<u32>();\n+        true\n+    }\n+\n+    fn visit_u64() -> bool {\n+        self.align_to::<u64>();\n+        if ! self.inner.visit_u64() { ret false; }\n+        self.bump_past::<u64>();\n+        true\n+    }\n+\n+    fn visit_float() -> bool {\n+        self.align_to::<float>();\n+        if ! self.inner.visit_float() { ret false; }\n+        self.bump_past::<float>();\n+        true\n+    }\n+\n+    fn visit_f32() -> bool {\n+        self.align_to::<f32>();\n+        if ! self.inner.visit_f32() { ret false; }\n+        self.bump_past::<f32>();\n+        true\n+    }\n+\n+    fn visit_f64() -> bool {\n+        self.align_to::<f64>();\n+        if ! self.inner.visit_f64() { ret false; }\n+        self.bump_past::<f64>();\n+        true\n+    }\n+\n+    fn visit_char() -> bool {\n+        self.align_to::<char>();\n+        if ! self.inner.visit_char() { ret false; }\n+        self.bump_past::<char>();\n+        true\n+    }\n+\n+    fn visit_str() -> bool {\n+        self.align_to::<str>();\n+        if ! self.inner.visit_str() { ret false; }\n+        self.bump_past::<str>();\n+        true\n+    }\n+\n+    fn visit_estr_box() -> bool {\n+        self.align_to::<str/@>();\n+        if ! self.inner.visit_estr_box() { ret false; }\n+        self.bump_past::<str/@>();\n+        true\n+    }\n+\n+    fn visit_estr_uniq() -> bool {\n+        self.align_to::<str/~>();\n+        if ! self.inner.visit_estr_uniq() { ret false; }\n+        self.bump_past::<str/~>();\n+        true\n+    }\n+\n+    fn visit_estr_slice() -> bool {\n+        self.align_to::<str/&static>();\n+        if ! self.inner.visit_estr_slice() { ret false; }\n+        self.bump_past::<str/&static>();\n+        true\n+    }\n+\n+    fn visit_estr_fixed(sz: uint) -> bool {\n+        self.align_to::<u8>();\n+        if ! self.inner.visit_estr_fixed(sz) { ret false; }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_enter_box(mtbl: uint) -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_enter_box(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_box(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_box(mtbl) { ret false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_enter_uniq(mtbl: uint) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_enter_uniq(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_uniq(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_uniq(mtbl) { ret false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n+    fn visit_enter_ptr(mtbl: uint) -> bool {\n+        self.align_to::<*u8>();\n+        if ! self.inner.visit_enter_ptr(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_ptr(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_ptr(mtbl) { ret false; }\n+        self.bump_past::<*u8>();\n+        true\n+    }\n+\n+    fn visit_enter_rptr(mtbl: uint) -> bool {\n+        self.align_to::<&static.u8>();\n+        if ! self.inner.visit_enter_rptr(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_rptr(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_rptr(mtbl) { ret false; }\n+        self.bump_past::<&static.u8>();\n+        true\n+    }\n+\n+    fn visit_enter_vec(mtbl: uint) -> bool {\n+        self.align_to::<[u8]>();\n+        if ! self.inner.visit_enter_vec(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_vec(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_vec(mtbl) { ret false; }\n+        self.bump_past::<[u8]>();\n+        true\n+    }\n+\n+    fn visit_enter_evec_box(mtbl: uint) -> bool {\n+        self.align_to::<[u8]/@>();\n+        if ! self.inner.visit_enter_evec_box(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_evec_box(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_evec_box(mtbl) { ret false; }\n+        self.bump_past::<[u8]/@>();\n+        true\n+    }\n+\n+    fn visit_enter_evec_uniq(mtbl: uint) -> bool {\n+        self.align_to::<[u8]/~>();\n+        if ! self.inner.visit_enter_evec_uniq(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_evec_uniq(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_evec_uniq(mtbl) { ret false; }\n+        self.bump_past::<[u8]/~>();\n+        true\n+    }\n+\n+    fn visit_enter_evec_slice(mtbl: uint) -> bool {\n+        self.align_to::<[u8]/&static>();\n+        if ! self.inner.visit_enter_evec_slice(mtbl) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_evec_slice(mtbl: uint) -> bool {\n+        if ! self.inner.visit_leave_evec_slice(mtbl) { ret false; }\n+        self.bump_past::<[u8]/&static>();\n+        true\n+    }\n+\n+    fn visit_enter_evec_fixed(mtbl: uint, n: uint,\n+                              sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_evec_fixed(mtbl, n, sz, align) {\n+            ret false;\n         }\n         true\n     }\n-    fn visit_i8() -> bool { true }\n-    fn visit_i16() -> bool { true }\n-    fn visit_i32() -> bool { true }\n-    fn visit_i64() -> bool { true }\n \n-    fn visit_uint() -> bool { true }\n-    fn visit_u8() -> bool { true }\n-    fn visit_u16() -> bool { true }\n-    fn visit_u32() -> bool { true }\n-    fn visit_u64() -> bool { true }\n+    fn visit_leave_evec_fixed(mtbl: uint, n: uint,\n+                              sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_evec_fixed(mtbl, n, sz, align) {\n+            ret false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n \n-    fn visit_float() -> bool { true }\n-    fn visit_f32() -> bool { true }\n-    fn visit_f64() -> bool { true }\n+    fn visit_enter_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_rec(n_fields, sz, align) { ret false; }\n+        true\n+    }\n \n-    fn visit_char() -> bool { true }\n-    fn visit_str() -> bool { true }\n+    fn visit_enter_rec_field(mtbl: uint, i: uint,\n+                             name: str/&) -> bool {\n+        if ! self.inner.visit_enter_rec_field(mtbl, i, name) { ret false; }\n+        true\n+    }\n \n-    fn visit_estr_box() -> bool { true }\n-    fn visit_estr_uniq() -> bool { true }\n-    fn visit_estr_slice() -> bool { true }\n-    fn visit_estr_fixed(_sz: uint) -> bool { true }\n+    fn visit_leave_rec_field(mtbl: uint, i: uint,\n+                             name: str/&) -> bool {\n+        if ! self.inner.visit_leave_rec_field(mtbl, i, name) { ret false; }\n+        true\n+    }\n \n-    fn visit_enter_box(_mtbl: uint) -> bool { true }\n-    fn visit_leave_box(_mtbl: uint) -> bool { true }\n-    fn visit_enter_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_leave_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_enter_ptr(_mtbl: uint) -> bool { true }\n-    fn visit_leave_ptr(_mtbl: uint) -> bool { true }\n-    fn visit_enter_rptr(_mtbl: uint) -> bool { true }\n-    fn visit_leave_rptr(_mtbl: uint) -> bool { true }\n+    fn visit_leave_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_rec(n_fields, sz, align) { ret false; }\n+        self.bump(sz);\n+        true\n+    }\n \n-    fn visit_enter_vec(_mtbl: uint) -> bool { true }\n-    fn visit_leave_vec(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_box(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_box(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_fixed(_mtbl: uint, _sz: uint) -> bool { true }\n-    fn visit_leave_evec_fixed(_mtbl: uint, _sz: uint) -> bool { true }\n+    fn visit_enter_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n+            ret false;\n+        }\n+        true\n+    }\n \n-    fn visit_enter_rec(_n_fields: uint) -> bool { true }\n-    fn visit_enter_rec_field(_mtbl: uint, _i: uint,\n-                             _name: str/&) -> bool { true }\n-    fn visit_leave_rec_field(_mtbl: uint, _i: uint,\n-                             _name: str/&) -> bool { true }\n-    fn visit_leave_rec(_n_fields: uint) -> bool { true }\n+    fn visit_enter_class_field(mtbl: uint, i: uint,\n+                               name: str/&) -> bool {\n+        if ! self.inner.visit_enter_class_field(mtbl, i, name) {\n+            ret false;\n+        }\n+        true\n+    }\n \n-    fn visit_enter_class(_n_fields: uint) -> bool { true }\n-    fn visit_enter_class_field(_mtbl: uint, _i: uint,\n-                               _name: str/&) -> bool { true }\n-    fn visit_leave_class_field(_mtbl: uint, _i: uint,\n-                               _name: str/&) -> bool { true }\n-    fn visit_leave_class(_n_fields: uint) -> bool { true }\n+    fn visit_leave_class_field(mtbl: uint, i: uint,\n+                               name: str/&) -> bool {\n+        if ! self.inner.visit_leave_class_field(mtbl, i, name) {\n+            ret false;\n+        }\n+        true\n+    }\n \n-    fn visit_enter_tup(_n_fields: uint) -> bool { true }\n-    fn visit_enter_tup_field(_i: uint) -> bool { true }\n-    fn visit_leave_tup_field(_i: uint) -> bool { true }\n-    fn visit_leave_tup(_n_fields: uint) -> bool { true }\n+    fn visit_leave_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n+            ret false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n \n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_enter_fn_input(_i: uint, _mode: uint) -> bool { true }\n-    fn visit_leave_fn_input(_i: uint, _mode: uint) -> bool { true }\n-    fn visit_enter_fn_output(_retstyle: uint) -> bool { true }\n-    fn visit_leave_fn_output(_retstyle: uint) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+    fn visit_enter_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_tup(n_fields, sz, align) { ret false; }\n+        true\n+    }\n \n-    fn visit_enter_enum(_n_variants: uint) -> bool { true }\n-    fn visit_enter_enum_variant(_variant: uint,\n-                                _disr_val: int,\n-                                _n_fields: uint,\n-                                _name: str/&) -> bool { true }\n-    fn visit_enter_enum_variant_field(_i: uint) -> bool { true }\n-    fn visit_leave_enum_variant_field(_i: uint) -> bool { true }\n-    fn visit_leave_enum_variant(_variant: uint,\n-                                _disr_val: int,\n-                                _n_fields: uint,\n-                                _name: str/&) -> bool { true }\n-    fn visit_leave_enum(_n_variants: uint) -> bool { true }\n+    fn visit_enter_tup_field(i: uint) -> bool {\n+        if ! self.inner.visit_enter_tup_field(i) { ret false; }\n+        true\n+    }\n \n-    fn visit_iface() -> bool { true }\n-    fn visit_enter_res() -> bool { true }\n-    fn visit_leave_res() -> bool { true }\n-    fn visit_var() -> bool { true }\n-    fn visit_var_integral() -> bool { true }\n-    fn visit_param(_i: uint) -> bool { true }\n-    fn visit_self() -> bool { true }\n-    fn visit_type() -> bool { true }\n-    fn visit_opaque_box() -> bool { true }\n-    fn visit_enter_constr() -> bool { true }\n-    fn visit_leave_constr() -> bool { true }\n-    fn visit_closure_ptr(_ck: uint) -> bool { true }\n-}\n+    fn visit_leave_tup_field(i: uint) -> bool {\n+        if ! self.inner.visit_leave_tup_field(i) { ret false; }\n+        true\n+    }\n \n-enum data_visitor<V:intrinsic::ty_visitor data_cursor> = {\n-    inner: V\n-};\n+    fn visit_leave_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_tup(n_fields, sz, align) { ret false; }\n+        self.bump(sz);\n+        true\n+    }\n \n-fn align_to<T>(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n+    fn visit_enter_fn(purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n+            ret false;\n+        }\n+        true\n+    }\n \n-impl dv<V: intrinsic::ty_visitor data_cursor> of\n-    intrinsic::ty_visitor for data_visitor<V> {\n+    fn visit_enter_fn_input(i: uint, mode: uint) -> bool {\n+        if ! self.inner.visit_enter_fn_input(i, mode) { ret false; }\n+        true\n+    }\n \n-    fn move_ptr(f: fn(*c_void) -> *c_void) {\n-        self.inner.set_ptr(f(self.inner.get_ptr()));\n+    fn visit_leave_fn_input(i: uint, mode: uint) -> bool {\n+        if ! self.inner.visit_leave_fn_input(i, mode) { ret false; }\n+        true\n     }\n \n-    fn bump(sz: uint) {\n-        self.move_ptr() {|p|\n-            ((p as uint) + sz) as *c_void\n+    fn visit_enter_fn_output(retstyle: uint) -> bool {\n+        if ! self.inner.visit_enter_fn_output(retstyle) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_fn_output(retstyle: uint) -> bool {\n+        if ! self.inner.visit_leave_fn_output(retstyle) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_fn(purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n+            ret false;\n         }\n+        true\n     }\n \n-    fn align_to<T>() {\n-        self.move_ptr() {|p|\n-            align_to::<T>(p as uint,\n-                          sys::min_align_of::<T>()) as *c_void\n+    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_enum(n_variants, sz, align) { ret false; }\n+        true\n+    }\n+\n+    fn visit_enter_enum_variant(variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: str/&) -> bool {\n+        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            ret false;\n         }\n+        true\n     }\n \n-    fn bump_past<T>() {\n-        self.bump(sys::size_of::<T>());\n+    fn visit_enter_enum_variant_field(i: uint) -> bool {\n+        if ! self.inner.visit_enter_enum_variant_field(i) { ret false; }\n+        true\n     }\n \n-    fn visit_bot() -> bool {\n-        self.align_to::<bool>();\n-        self.inner.visit_bot();\n-        self.bump_past::<bool>();\n+    fn visit_leave_enum_variant_field(i: uint) -> bool {\n+        if ! self.inner.visit_leave_enum_variant_field(i) { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: str/&) -> bool {\n+        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            ret false;\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_enum(n_variants, sz, align) { ret false; }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_iface() -> bool {\n+        self.align_to::<ty_visitor>();\n+        if ! self.inner.visit_iface() { ret false; }\n+        self.bump_past::<ty_visitor>();\n+        true\n+    }\n+\n+    fn visit_enter_res() -> bool {\n+        // FIXME: I _think_ a resource takes no space,\n+        // but I might be wrong.\n+        if ! self.inner.visit_enter_res() { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_res() -> bool {\n+        if ! self.inner.visit_leave_res() { ret false; }\n+        true\n+    }\n+\n+    fn visit_var() -> bool {\n+        if ! self.inner.visit_var() { ret false; }\n+        true\n+    }\n+\n+    fn visit_var_integral() -> bool {\n+        if ! self.inner.visit_var_integral() { ret false; }\n+        true\n+    }\n+\n+    fn visit_param(i: uint) -> bool {\n+        if ! self.inner.visit_param(i) { ret false; }\n+        true\n+    }\n+\n+    fn visit_self() -> bool {\n+        self.align_to::<&static.u8>();\n+        if ! self.inner.visit_self() { ret false; }\n+        self.align_to::<&static.u8>();\n         true\n     }\n+\n+    fn visit_type() -> bool {\n+        if ! self.inner.visit_type() { ret false; }\n+        true\n+    }\n+\n+    fn visit_opaque_box() -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_opaque_box() { ret false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_enter_constr() -> bool {\n+        if ! self.inner.visit_enter_constr() { ret false; }\n+        true\n+    }\n+\n+    fn visit_leave_constr() -> bool {\n+        if ! self.inner.visit_leave_constr() { ret false; }\n+        true\n+    }\n+\n+    fn visit_closure_ptr(ck: uint) -> bool {\n+        self.align_to::<fn@()>();\n+        if ! self.inner.visit_closure_ptr(ck) { ret false; }\n+        self.bump_past::<fn@()>();\n+        true\n+    }\n+}\n+\n+enum my_visitor = @{\n+    mut ptr1: *c_void,\n+    mut ptr2: *c_void,\n+    mut vals: [str]\n+};\n+\n+impl extra_methods for my_visitor {\n+    fn get<T>(f: fn(T)) {\n+        unsafe {\n+            f(*(self.ptr1 as *T));\n+        }\n+    }\n+}\n+\n+impl of movable_ptr for my_visitor {\n+    fn move_ptr(adjustment: fn(*c_void) -> *c_void) {\n+        self.ptr1 = adjustment(self.ptr1);\n+        self.ptr2 = adjustment(self.ptr2);\n+    }\n+}\n+\n+impl of ty_visitor for my_visitor {\n+\n+    fn visit_bot() -> bool { true }\n     fn visit_nil() -> bool { true }\n     fn visit_bool() -> bool {\n-        self.align_to::<bool>();\n-        self.inner.visit_bool();\n-        self.bump_past::<bool>();\n+/*\n+        self.get::<bool>() {|b|\n+            self.vals += [bool::to_str(b)];\n+        }\n+*/\n         true\n     }\n     fn visit_int() -> bool {\n-        self.align_to::<int>();\n-        self.inner.visit_int();\n-        self.bump_past::<int>();\n+/*\n+        self.get::<int>() {|i|\n+            self.vals += [int::to_str(i, 10u)];\n+        }\n+*/\n         true\n     }\n     fn visit_i8() -> bool { true }\n@@ -228,27 +625,35 @@ impl dv<V: intrinsic::ty_visitor data_cursor> of\n     fn visit_leave_evec_uniq(_mtbl: uint) -> bool { true }\n     fn visit_enter_evec_slice(_mtbl: uint) -> bool { true }\n     fn visit_leave_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_fixed(_mtbl: uint, _sz: uint) -> bool { true }\n-    fn visit_leave_evec_fixed(_mtbl: uint, _sz: uint) -> bool { true }\n+    fn visit_enter_evec_fixed(_mtbl: uint, _n: uint,\n+                              _sz: uint, _align: uint) -> bool { true }\n+    fn visit_leave_evec_fixed(_mtbl: uint, _n: uint,\n+                              _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_rec(_n_fields: uint) -> bool { true }\n+    fn visit_enter_rec(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_rec_field(_mtbl: uint, _i: uint,\n                              _name: str/&) -> bool { true }\n     fn visit_leave_rec_field(_mtbl: uint, _i: uint,\n                              _name: str/&) -> bool { true }\n-    fn visit_leave_rec(_n_fields: uint) -> bool { true }\n+    fn visit_leave_rec(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_class(_n_fields: uint) -> bool { true }\n+    fn visit_enter_class(_n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_class_field(_mtbl: uint, _i: uint,\n                                _name: str/&) -> bool { true }\n     fn visit_leave_class_field(_mtbl: uint, _i: uint,\n                                _name: str/&) -> bool { true }\n-    fn visit_leave_class(_n_fields: uint) -> bool { true }\n+    fn visit_leave_class(_n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_tup(_n_fields: uint) -> bool { true }\n+    fn visit_enter_tup(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_tup_field(_i: uint) -> bool { true }\n     fn visit_leave_tup_field(_i: uint) -> bool { true }\n-    fn visit_leave_tup(_n_fields: uint) -> bool { true }\n+    fn visit_leave_tup(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_fn(_purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n@@ -259,7 +664,8 @@ impl dv<V: intrinsic::ty_visitor data_cursor> of\n     fn visit_leave_fn(_purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n \n-    fn visit_enter_enum(_n_variants: uint) -> bool { true }\n+    fn visit_enter_enum(_n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_enum_variant(_variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n@@ -270,7 +676,8 @@ impl dv<V: intrinsic::ty_visitor data_cursor> of\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: str/&) -> bool { true }\n-    fn visit_leave_enum(_n_variants: uint) -> bool { true }\n+    fn visit_leave_enum(_n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_iface() -> bool { true }\n     fn visit_enter_res() -> bool { true }\n@@ -286,18 +693,19 @@ impl dv<V: intrinsic::ty_visitor data_cursor> of\n     fn visit_closure_ptr(_ck: uint) -> bool { true }\n }\n \n+\n fn main() {\n     let r = (1,2,3,true,false);\n     let p = ptr::addr_of(r) as *c_void;\n-    let u = my_visitor(@{mut ptr: p,\n+    let u = my_visitor(@{mut ptr1: p,\n+                         mut ptr2: p,\n                          mut vals: []});\n-    let v = data_visitor({inner: u});\n+    let v = ptr_visit_adaptor({inner: u});\n     let vv = v as intrinsic::ty_visitor;\n     intrinsic::visit_ty::<(int,int,int,bool,bool)>(vv);\n \n     for (copy u.vals).each {|s|\n         io::println(#fmt(\"val: %s\", s));\n     }\n     assert u.vals == [\"1\", \"2\", \"3\", \"true\", \"false\"];\n-\n  }"}, {"sha": "8e90e4380684a5fc9dc78d749db1f91f5cf615d9", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d953462d031db6c6fd632456a5533be818a0db1c/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d953462d031db6c6fd632456a5533be818a0db1c/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=d953462d031db6c6fd632456a5533be818a0db1c", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: un-xfail after snapshot\n+// xfail-test\n+\n enum my_visitor = @{ mut types: [str] };\n \n impl of intrinsic::ty_visitor for my_visitor {"}]}