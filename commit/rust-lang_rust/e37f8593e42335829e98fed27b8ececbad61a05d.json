{"sha": "e37f8593e42335829e98fed27b8ececbad61a05d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzN2Y4NTkzZTQyMzM1ODI5ZTk4ZmVkMjdiOGVjZWNiYWQ2MWEwNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-11T14:03:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-11T14:03:12Z"}, "message": "Auto merge of #33556 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 9 pull requests\n\n- Successful merges: #33129, #33260, #33345, #33386, #33522, #33524, #33528, #33539, #33542\n- Failed merges: #33342, #33475, #33517", "tree": {"sha": "4c3ed31a0c4bda41b14975493fa1a80425a24b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c3ed31a0c4bda41b14975493fa1a80425a24b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e37f8593e42335829e98fed27b8ececbad61a05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e37f8593e42335829e98fed27b8ececbad61a05d", "html_url": "https://github.com/rust-lang/rust/commit/e37f8593e42335829e98fed27b8ececbad61a05d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e37f8593e42335829e98fed27b8ececbad61a05d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0495417416c8e0687bc6a997507c403627f6568", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0495417416c8e0687bc6a997507c403627f6568", "html_url": "https://github.com/rust-lang/rust/commit/c0495417416c8e0687bc6a997507c403627f6568"}, {"sha": "403970f96c002fd194eb6c23f927438bac39f725", "url": "https://api.github.com/repos/rust-lang/rust/commits/403970f96c002fd194eb6c23f927438bac39f725", "html_url": "https://github.com/rust-lang/rust/commit/403970f96c002fd194eb6c23f927438bac39f725"}], "stats": {"total": 282, "additions": 262, "deletions": 20}, "files": [{"sha": "bc60a577bd35cd79292b09b7dd54a9c348c33083", "filename": "src/doc/nomicon/vec-alloc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Fdoc%2Fnomicon%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Fdoc%2Fnomicon%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-alloc.md?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -150,7 +150,7 @@ LLVM needs to work with different languages' semantics and custom allocators,\n it can't really intimately understand allocation. Instead, the main idea behind\n allocation is \"doesn't overlap with other stuff\". That is, heap allocations,\n stack allocations, and globals don't randomly overlap. Yep, it's about alias\n-analysis. As such, Rust can technically play a bit fast an loose with the notion of\n+analysis. As such, Rust can technically play a bit fast and loose with the notion of\n an allocation as long as it's *consistent*.\n \n Getting back to the empty allocation case, there are a couple of places where"}, {"sha": "8b3168b29aa4f5dafa1b1923d6b6cc5a2b24cbb5", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -147,6 +147,7 @@ impl<T> RawVec<T> {\n     /// Gets the capacity of the allocation.\n     ///\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n+    #[inline(always)]\n     pub fn cap(&self) -> usize {\n         if mem::size_of::<T>() == 0 {\n             !0"}, {"sha": "ce1d6ec5a6478a688f462e55d5f4b95b7fff38cd", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -521,12 +521,24 @@ use string;\n ///\n /// # Examples\n ///\n+/// Basic usage:\n+///\n /// ```\n /// use std::fmt;\n ///\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n+///\n+/// Please note that using [`format!`][format!] might be preferrable.\n+/// Example:\n+///\n+/// ```\n+/// let s = format!(\"Hello, {}!\", \"world\");\n+/// assert_eq!(s, \"Hello, world!\".to_string());\n+/// ```\n+///\n+/// [format!]: ../macro.format!.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();"}, {"sha": "dde4d03dad8ac01bcfcd6e570c9ca19df2153c8b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -776,6 +776,32 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// let mut output = String::new();\n+/// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n+///     .expect(\"Error occurred while trying to write in String\");\n+/// assert_eq!(output, \"Hello world!\");\n+/// ```\n+///\n+/// Please note that using [`write!`][write_macro] might be preferrable. Example:\n+///\n+/// ```\n+/// use std::fmt::Write;\n+///\n+/// let mut output = String::new();\n+/// write!(&mut output, \"Hello {}!\", \"world\")\n+///     .expect(\"Error occurred while trying to write in String\");\n+/// assert_eq!(output, \"Hello world!\");\n+/// ```\n+///\n+/// [write_macro]: ../../std/macro.write!.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn write(output: &mut Write, args: Arguments) -> Result {\n     let mut formatter = Formatter {"}, {"sha": "9d2d52015e394256845364c5066c6a49e1a356be", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -1240,9 +1240,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                    orig_node_idx,\n                    node_idx);\n \n-            // figure out the direction from which this node takes its\n-            // values, and search for concrete regions etc in that direction\n-            let dir = graph::INCOMING;\n             process_edges(self, &mut state, graph, node_idx, dir);\n         }\n "}, {"sha": "5c062316310101a35478092e4d5d3418fd5a250d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -193,7 +193,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 })\n             }\n             FnKind::Closure(_) => {\n-                self.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n+                // Closures have their own set of labels, save labels just\n+                // like for foreign items above.\n+                let saved = replace(&mut self.labels_in_fn, vec![]);\n+                let result = self.add_scope_and_walk_fn(fk, fd, b, s, fn_id);\n+                replace(&mut self.labels_in_fn, saved);\n+                result\n             }\n         }\n     }"}, {"sha": "0687faa112f5e9efbaf28f46e1dffac2389dfe87", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -454,6 +454,110 @@ fn foo(a: &mut i32) {\n ```\n \"##,\n \n+E0504: r##\"\n+This error occurs when an attempt is made to move a borrowed variable into a\n+closure.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        println!(\"child function: {}\", fancy_num.num);\n+        // error: cannot move `fancy_num` into closure because it is borrowed\n+    };\n+\n+    x();\n+    println!(\"main function: {}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n+the closure `x`. There is no way to move a value into a closure while it is\n+borrowed, as that would invalidate the borrow.\n+\n+If the closure can't outlive the value being moved, try using a reference\n+rather than moving:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        // fancy_ref is usable here because it doesn't move `fancy_num`\n+        println!(\"child function: {}\", fancy_ref.num);\n+    };\n+\n+    x();\n+\n+    println!(\"main function: {}\", fancy_num.num);\n+}\n+```\n+\n+If the value has to be borrowed and then moved, try limiting the lifetime of\n+the borrow using a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"main function: {}\", fancy_ref.num);\n+        // `fancy_ref` goes out of scope here\n+    }\n+\n+    let x = move || {\n+        // `fancy_num` can be moved now (no more references exist)\n+        println!(\"child function: {}\", fancy_num.num);\n+    };\n+\n+    x();\n+}\n+```\n+\n+If the lifetime of a reference isn't enough, such as in the case of threading,\n+consider using an `Arc` to create a reference-counted value:\n+\n+```\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n+    let fancy_ref2 = fancy_ref1.clone();\n+\n+    let x = thread::spawn(move || {\n+        // `fancy_ref1` can be moved and has a `'static` lifetime\n+        println!(\"child thread: {}\", fancy_ref1.num);\n+    });\n+\n+    x.join().expect(\"child thread should finish\");\n+    println!(\"main thread: {}\", fancy_ref2.num);\n+}\n+```\n+\"##,\n+\n E0506: r##\"\n This error occurs when an attempt is made to assign to a borrowed value.\n \n@@ -756,7 +860,6 @@ register_diagnostics! {\n     E0500, // closure requires unique access to `..` but .. is already borrowed\n     E0502, // cannot borrow `..`.. as .. because .. is also borrowed as ...\n     E0503, // cannot use `..` because it was mutably borrowed\n-    E0504, // cannot move `..` into closure because it is borrowed\n     E0505, // cannot move out of `..` because it is borrowed\n     E0508, // cannot move out of type `..`, a non-copy fixed-size array\n     E0524, // two closures require unique access to `..` at the same time"}, {"sha": "c86c22b1e0f3b7f1b56070e2fce4d685554e92ac", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -215,22 +215,63 @@ match Some(\"hi\".to_string()) {\n The variable `s` has type `String`, and its use in the guard is as a variable of\n type `String`. The guard code effectively executes in a separate scope to the\n body of the arm, so the value would be moved into this anonymous scope and\n-therefore become unavailable in the body of the arm. Although this example seems\n-innocuous, the problem is most clear when considering functions that take their\n-argument by value.\n+therefore becomes unavailable in the body of the arm.\n \n-```compile_fail\n+The problem above can be solved by using the `ref` keyword.\n+\n+```\n match Some(\"hi\".to_string()) {\n-    Some(s) if { drop(s); false } => (),\n-    Some(s) => {}, // use s.\n+    Some(ref s) if s.len() == 0 => {},\n     _ => {},\n }\n ```\n \n-The value would be dropped in the guard then become unavailable not only in the\n-body of that arm but also in all subsequent arms! The solution is to bind by\n-reference when using guards or refactor the entire expression, perhaps by\n-putting the condition inside the body of the arm.\n+Though this example seems innocuous and easy to solve, the problem becomes clear\n+when it encounters functions which consume the value:\n+\n+```compile_fail\n+struct A{}\n+\n+impl A {\n+    fn consume(self) -> usize {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let a = Some(A{});\n+    match a {\n+        Some(y) if y.consume() > 0 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+In this situation, even the `ref` keyword cannot solve it, since borrowed\n+content cannot be moved. This problem cannot be solved generally. If the value\n+can be cloned, here is a not-so-specific solution:\n+\n+```\n+#[derive(Clone)]\n+struct A{}\n+\n+impl A {\n+    fn consume(self) -> usize {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let a = Some(A{});\n+    match a{\n+        Some(ref y) if y.clone().consume() > 0 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+If the value will be consumed in the pattern guard, using its clone will not\n+move its ownership, so the code works.\n \"##,\n \n E0009: r##\""}, {"sha": "05e4c79a7e8d5adafdd8a9eede74948987ecc60a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -742,7 +742,7 @@ fn f(a: u16, b: &str) {}\n \n Must always be called with exactly two arguments, e.g. `f(2, \"test\")`.\n \n-Note, that Rust does not have a notion of optional function arguments or\n+Note that Rust does not have a notion of optional function arguments or\n variadic functions (except for its C-FFI).\n \"##,\n "}, {"sha": "da0520ebcb84a9eb7b6da695c558f506eda919da", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -1537,7 +1537,6 @@ impl<'a> Item<'a> {\n     }\n }\n \n-\n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         debug_assert!(!self.item.is_stripped());\n@@ -1575,6 +1574,9 @@ impl<'a> fmt::Display for Item<'a> {\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n+        if let Some(version) = self.item.stable_since() {\n+            write!(fmt, \"<span class='since'>{}</span>\", version)?;\n+        }\n         write!(fmt,\n                r##\"<span id='render-detail'>\n                    <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\">\n@@ -1922,7 +1924,6 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n            decl = f.decl)?;\n-    render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }\n \n@@ -2236,7 +2237,6 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   \"\",\n                   true)?;\n     write!(w, \"</pre>\")?;\n-    render_stability_since_raw(w, it.stable_since(), None)?;\n \n     document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter(|f| {"}, {"sha": "d256e939afcfc788e1fe70768694a3ac94da2c1a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -634,6 +634,12 @@ a.test-arrow {\n     padding-left: 10px;\n }\n \n+span.since {\n+    position: initial;\n+    font-size: 20px;\n+    margin-right: 5px;\n+}\n+\n /* Media Queries */\n \n @media (max-width: 700px) {"}, {"sha": "ac0167e08bdd668ebb8b0e590da6a3d2503bcd71", "filename": "src/test/compile-fail/region-invariant-static-error-reporting.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test checks that the error messages you get for this example\n+// at least mention `'a` and `'static`. The precise messages can drift\n+// over time, but this test used to exhibit some pretty bogus messages\n+// that were not remotely helpful.\n+\n+// error-pattern:cannot infer\n+// error-pattern:cannot outlive the lifetime 'a\n+// error-pattern:must be valid for the static lifetime\n+// error-pattern:cannot infer\n+// error-pattern:cannot outlive the lifetime 'a\n+// error-pattern:must be valid for the static lifetime\n+\n+struct Invariant<'a>(Option<&'a mut &'a mut ()>);\n+\n+fn mk_static() -> Invariant<'static> { Invariant(None) }\n+\n+fn unify<'a>(x: Option<Invariant<'a>>, f: fn(Invariant<'a>)) {\n+    let bad = if x.is_some() {\n+        x.unwrap()\n+    } else {\n+        mk_static()\n+    };\n+    f(bad);\n+}\n+\n+fn main() {}"}, {"sha": "64e7350fb824471fc39a716efd39822b7c7a619f", "filename": "src/test/run-pass/issue-25343.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Ftest%2Frun-pass%2Fissue-25343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37f8593e42335829e98fed27b8ececbad61a05d/src%2Ftest%2Frun-pass%2Fissue-25343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25343.rs?ref=e37f8593e42335829e98fed27b8ececbad61a05d", "patch": "@@ -8,9 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(unused)]\n fn main() {\n     || {\n         'label: loop {\n         }\n     };\n+\n+    // More cases added from issue 31754\n+\n+    'label2: loop {\n+        break;\n+    }\n+\n+    let closure = || {\n+        'label2: loop {}\n+    };\n+\n+    fn inner_fn() {\n+        'label2: loop {}\n+    }\n }"}]}