{"sha": "0b58fdf9252ccd08bf610e13625f49380e769e06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNThmZGY5MjUyY2NkMDhiZjYxMGUxMzYyNWY0OTM4MGU3NjllMDY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T17:25:05Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:39:26Z"}, "message": "rustc: remove Repr and UserString.", "tree": {"sha": "6c06392933aabf16e5ac6858db78f63358f4d26d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c06392933aabf16e5ac6858db78f63358f4d26d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b58fdf9252ccd08bf610e13625f49380e769e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b58fdf9252ccd08bf610e13625f49380e769e06", "html_url": "https://github.com/rust-lang/rust/commit/0b58fdf9252ccd08bf610e13625f49380e769e06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b58fdf9252ccd08bf610e13625f49380e769e06/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "html_url": "https://github.com/rust-lang/rust/commit/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890"}], "stats": {"total": 3439, "additions": 1637, "deletions": 1802}, "files": [{"sha": "33d37b285890add380cb4af184013d386dba25db", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -17,7 +17,6 @@\n use middle::def;\n use middle::ty::{self, Ty};\n use syntax::ast;\n-use util::ppaux::Repr;\n \n pub const NO_REGIONS: usize = 1;\n pub const NO_TPS: usize = 2;\n@@ -63,7 +62,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n         let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n             None => {\n                 tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\", path.repr()))\n+                                  &format!(\"unbound path {:?}\", path))\n             }\n             Some(d) => d.full_def()\n         };"}, {"sha": "21e2ad198810efc4a62bfc0f76b538a52ec2a78b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -31,7 +31,6 @@ use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n-use util::ppaux::Repr;\n \n use syntax::{ast, ast_util, codemap, fold};\n use syntax::codemap::Span;\n@@ -1623,8 +1622,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);\n-                        debug!(\"inserting ty for node {}: {}\",\n-                               id,  ty.repr());\n+                        debug!(\"inserting ty for node {}: {:?}\",\n+                               id,  ty);\n                         dcx.tcx.node_type_insert(id, ty);\n                     }\n                     c::tag_table_item_subst => {"}, {"sha": "e1f8e24253b39689fb3130126f3f4fd68a00224e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -36,7 +36,6 @@ use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor, FnKind};\n-use util::ppaux::UserString;\n use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n@@ -210,7 +209,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n                               \"non-exhaustive patterns: type {} is non-empty\",\n-                              pat_ty.user_string());\n+                              pat_ty);\n                 }\n                 // If the type *is* empty, it's vacuously exhaustive\n                 return;\n@@ -243,11 +242,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                &token::get_ident(ident.node), pat_ty.user_string());\n+                                &token::get_ident(ident.node), pat_ty);\n                             fileline_help!(cx.tcx.sess, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                pat_ty.user_string(), &token::get_ident(ident.node));\n+                                pat_ty, &token::get_ident(ident.node));\n                         }\n                     }\n                 }"}, {"sha": "f5934751c58b282528c85fd6de0a76eb5aaeca3c", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -15,7 +15,6 @@ use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty::ParameterEnvironment;\n use middle::ty;\n-use util::ppaux::{Repr, UserString};\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -59,11 +58,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, cmt.ty.repr());\n+        debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n         if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                cmt.ty.user_string());\n+                cmt.ty);\n         }\n     }\n "}, {"sha": "23ad3f0d4b904357c32f8150cd3e54b27bf9eb8f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -23,7 +23,6 @@ use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n-use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n use syntax::ast_util;\n@@ -1030,8 +1029,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                            rcvr_self,\n                                                            Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"resolve_trait_associated_const: trait_substs={}\",\n-           trait_substs.repr());\n+    debug!(\"resolve_trait_associated_const: trait_substs={:?}\",\n+           trait_substs);\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n \n@@ -1052,10 +1051,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         }\n         Err(e) => {\n             tcx.sess.span_bug(ti.span,\n-                              &format!(\"Encountered error `{}` when trying \\\n+                              &format!(\"Encountered error `{:?}` when trying \\\n                                         to select an implementation for \\\n                                         constant trait item reference.\",\n-                                       e.repr()))\n+                                       e))\n         }\n     };\n "}, {"sha": "bb63ec42d8c0cb9c87473545e46ea77e8f5b6cdb", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -15,7 +15,6 @@ use self::UnsafeContext::*;\n use middle::def;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -66,8 +65,8 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n         };\n-        debug!(\"effect: checking index with base type {}\",\n-                 base_type.repr());\n+        debug!(\"effect: checking index with base type {:?}\",\n+                 base_type);\n         match base_type.sty {\n             ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => if ty::TyStr == ty.sty {\n                 span_err!(self.tcx.sess, e.span, E0134,\n@@ -142,25 +141,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n                 let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-                debug!(\"effect: method call case, base type is {}\",\n-                        base_type.repr());\n+                debug!(\"effect: method call case, base type is {:?}\",\n+                        base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }\n             }\n             ast::ExprCall(ref base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                debug!(\"effect: call case, base type is {}\",\n-                        base_type.repr());\n+                debug!(\"effect: call case, base type is {:?}\",\n+                        base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                debug!(\"effect: unary case, base type is {}\",\n-                        base_type.repr());\n+                debug!(\"effect: unary case, base type is {:?}\",\n+                        base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n                     self.require_unsafe(expr.span, \"dereference of raw pointer\")\n                 }"}, {"sha": "ab67c68be124bd0938f31f5f5e52776acc99b481", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -27,7 +27,6 @@ use middle::ty::{self};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticClosure};\n-use util::ppaux::Repr;\n \n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -362,8 +361,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n                         cmt: mc::cmt<'tcx>) {\n-        debug!(\"delegate_consume(consume_id={}, cmt={})\",\n-               consume_id, cmt.repr());\n+        debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n+               consume_id, cmt);\n \n         let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n@@ -376,7 +375,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n-        debug!(\"consume_expr(expr={})\", expr.repr());\n+        debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n@@ -397,8 +396,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    r: ty::Region,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n-        debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n-               expr.repr(), r.repr(), bk.repr());\n+        debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\",\n+               expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n@@ -414,7 +413,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     pub fn walk_expr(&mut self, expr: &ast::Expr) {\n-        debug!(\"walk_expr(expr={})\", expr.repr());\n+        debug!(\"walk_expr(expr={:?})\", expr);\n \n         self.walk_adjustment(expr);\n \n@@ -618,8 +617,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n         let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n-        debug!(\"walk_callee: callee={} callee_ty={}\",\n-               callee.repr(), callee_ty.repr());\n+        debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n+               callee, callee_ty);\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n         match callee_ty.sty {\n             ty::TyBareFn(..) => {\n@@ -637,7 +636,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         None => {\n                             self.tcx().sess.span_bug(\n                                 callee.span,\n-                                &format!(\"unexpected callee type {}\", callee_ty.repr()))\n+                                &format!(\"unexpected callee type {}\", callee_ty))\n                         }\n                     };\n                 match overloaded_call_type {\n@@ -811,7 +810,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoderefs(&mut self,\n                        expr: &ast::Expr,\n                        autoderefs: usize) {\n-        debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(), autoderefs);\n+        debug!(\"walk_autoderefs expr={:?} autoderefs={}\", expr, autoderefs);\n \n         for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n@@ -828,8 +827,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n-                                &format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr()))\n+                                &format!(\"bad overloaded deref type {:?}\",\n+                                    method_ty))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -842,9 +841,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoderefref(&mut self,\n                          expr: &ast::Expr,\n                          adj: &ty::AutoDerefRef<'tcx>) {\n-        debug!(\"walk_autoderefref expr={} adj={}\",\n-               expr.repr(),\n-               adj.repr());\n+        debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n+               expr,\n+               adj);\n \n         self.walk_autoderefs(expr, adj.autoderefs);\n \n@@ -875,9 +874,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     opt_autoref: Option<ty::AutoRef<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n-        debug!(\"walk_autoref(expr.id={} cmt_derefd={} opt_autoref={:?})\",\n+        debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n                expr.id,\n-               cmt_base.repr(),\n+               cmt_base,\n                opt_autoref);\n \n         let cmt_base_ty = cmt_base.ty;\n@@ -901,9 +900,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ty::AutoUnsafe(m) => {\n-                debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n+                debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n-                       cmt_base.repr());\n+                       cmt_base);\n \n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n@@ -1011,8 +1010,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                cmt_discr: mc::cmt<'tcx>,\n                                pat: &ast::Pat,\n                                mode: &mut TrackMatchMode) {\n-        debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(),\n-               pat.repr());\n+        debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n+               pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.tcx();\n             let def_map = &self.tcx().def_map;\n@@ -1043,8 +1042,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 cmt_discr: mc::cmt<'tcx>,\n                 pat: &ast::Pat,\n                 match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(),\n-               pat.repr());\n+        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n+               pat);\n \n         let mc = &self.mc;\n         let typer = self.typer;\n@@ -1054,9 +1053,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n-                debug!(\"binding cmt_pat={} pat={} match_mode={:?}\",\n-                       cmt_pat.repr(),\n-                       pat.repr(),\n+                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                       cmt_pat,\n+                       pat,\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n@@ -1160,9 +1159,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                     mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n                                 };\n \n-                            debug!(\"variant downcast_cmt={} pat={}\",\n-                                   downcast_cmt.repr(),\n-                                   pat.repr());\n+                            debug!(\"variant downcast_cmt={:?} pat={:?}\",\n+                                   downcast_cmt,\n+                                   pat);\n \n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n@@ -1172,9 +1171,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n \n-                            debug!(\"struct cmt_pat={} pat={}\",\n-                                   cmt_pat.repr(),\n-                                   pat.repr());\n+                            debug!(\"struct cmt_pat={:?} pat={:?}\",\n+                                   cmt_pat,\n+                                   pat);\n \n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n@@ -1192,9 +1191,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // pattern.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected type: {:?} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected type: {:?} and type {:?}\",\n                                                   def,\n-                                                  cmt_pat.ty.repr());\n+                                                  cmt_pat.ty);\n                                 tcx.sess.span_bug(pat.span, &msg)\n                             }\n                         }\n@@ -1209,9 +1208,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // reported.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected def: {:?} and type {:?}\",\n                                                   def,\n-                                                  cmt_pat.ty.repr());\n+                                                  cmt_pat.ty);\n                                 tcx.sess.span_bug(pat.span, &msg[..])\n                             }\n                         }\n@@ -1237,7 +1236,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n-        debug!(\"walk_captures({})\", closure_expr.repr());\n+        debug!(\"walk_captures({:?})\", closure_expr);\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n             for freevar in freevars {"}, {"sha": "e08da94c7314a0b5c364c9181a44f8ecfaef604c", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -14,7 +14,6 @@ use middle::implicator::Implication;\n use middle::ty::{self, FreeRegion};\n use util::common::can_reach;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n@@ -32,7 +31,7 @@ impl FreeRegionMap {\n                                                        implications: &[Implication<'tcx>])\n     {\n         for implication in implications {\n-            debug!(\"implication: {}\", implication.repr());\n+            debug!(\"implication: {:?}\", implication);\n             match *implication {\n                 Implication::RegionSubRegion(_, ty::ReFree(free_a), ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n@@ -49,7 +48,7 @@ impl FreeRegionMap {\n     pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n                                                      tcx: &ty::ctxt<'tcx>,\n                                                      predicates: &[ty::Predicate<'tcx>]) {\n-        debug!(\"relate_free_regions_from_predicates(predicates={})\", predicates.repr());\n+        debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n             match *predicate {\n                 ty::Predicate::Projection(..) |\n@@ -67,9 +66,9 @@ impl FreeRegionMap {\n                         _ => {\n                             // All named regions are instantiated with free regions.\n                             tcx.sess.bug(\n-                                &format!(\"record_region_bounds: non free region: {} / {}\",\n-                                         r_a.repr(),\n-                                         r_b.repr()));\n+                                &format!(\"record_region_bounds: non free region: {:?} / {:?}\",\n+                                         r_a,\n+                                         r_b));\n                         }\n                     }\n                 }"}, {"sha": "d26df43286d9c8db04bc43834ca7e86485d31c25", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -21,7 +21,6 @@ use syntax::codemap::Span;\n \n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n-use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n@@ -54,10 +53,10 @@ pub fn implications<'a,'tcx>(\n     span: Span)\n     -> Vec<Implication<'tcx>>\n {\n-    debug!(\"implications(body_id={}, ty={}, outer_region={})\",\n+    debug!(\"implications(body_id={}, ty={:?}, outer_region={:?})\",\n            body_id,\n-           ty.repr(),\n-           outer_region.repr());\n+           ty,\n+           outer_region);\n \n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n@@ -69,7 +68,7 @@ pub fn implications<'a,'tcx>(\n                               out: Vec::new(),\n                               visited: FnvHashSet() };\n     wf.accumulate_from_ty(ty);\n-    debug!(\"implications: out={}\", wf.out.repr());\n+    debug!(\"implications: out={:?}\", wf.out);\n     wf.out\n }\n \n@@ -79,8 +78,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n-        debug!(\"accumulate_from_ty(ty={})\",\n-               ty.repr());\n+        debug!(\"accumulate_from_ty(ty={:?})\",\n+               ty);\n \n         // When expanding out associated types, we can visit a cyclic\n         // set of types. Issue #23003.\n@@ -313,8 +312,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_assoc_types_transitive(&mut self,\n                                               data: &ty::PolyTraitPredicate<'tcx>)\n     {\n-        debug!(\"accumulate_from_assoc_types_transitive({})\",\n-               data.repr());\n+        debug!(\"accumulate_from_assoc_types_transitive({:?})\",\n+               data);\n \n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n             match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n@@ -327,8 +326,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_assoc_types(&mut self,\n                                    trait_ref: ty::TraitRef<'tcx>)\n     {\n-        debug!(\"accumulate_from_assoc_types({})\",\n-               trait_ref.repr());\n+        debug!(\"accumulate_from_assoc_types({:?})\",\n+               trait_ref);\n \n         let trait_def_id = trait_ref.def_id;\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n@@ -337,8 +336,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                      .iter()\n                      .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n                      .collect();\n-        debug!(\"accumulate_from_assoc_types: assoc_type_projections={}\",\n-               assoc_type_projections.repr());\n+        debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n+               assoc_type_projections);\n         let tys = match self.fully_normalize(&assoc_type_projections) {\n             Ok(tys) => { tys }\n             Err(ErrorReported) => { return; }"}, {"sha": "742ad3f29b7808aea72c87fba94d39eb94bdd7b3", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -31,7 +31,6 @@ use super::type_variable::{BiTo};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::{Repr};\n \n pub struct Bivariate<'a, 'tcx: 'a> {\n     fields: CombineFields<'a, 'tcx>\n@@ -73,8 +72,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(), b.repr());\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n+               a, b);\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;"}, {"sha": "17d545212c281184c43f37b5b43b6670ed4f0197", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -47,7 +47,6 @@ use middle::ty::{self, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -212,10 +211,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                 Some(e) => e,\n             };\n \n-            debug!(\"instantiate(a_ty={} dir={:?} b_vid={})\",\n-                   a_ty.repr(),\n+            debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\",\n+                   a_ty,\n                    dir,\n-                   b_vid.repr());\n+                   b_vid);\n \n             // Check whether `vid` has been instantiated yet.  If not,\n             // make a generalized form of `ty` and instantiate with\n@@ -229,10 +228,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                         EqTo => self.generalize(a_ty, b_vid, false),\n                         BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n                     });\n-                    debug!(\"instantiate(a_ty={}, dir={:?}, \\\n-                                        b_vid={}, generalized_ty={})\",\n-                           a_ty.repr(), dir, b_vid.repr(),\n-                           generalized_ty.repr());\n+                    debug!(\"instantiate(a_ty={:?}, dir={:?}, \\\n+                                        b_vid={:?}, generalized_ty={:?})\",\n+                           a_ty, dir, b_vid,\n+                           generalized_ty);\n                     self.infcx.type_variables\n                         .borrow_mut()\n                         .instantiate_and_push(\n@@ -334,8 +333,8 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             ty::ReEarlyBound(..) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    &format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr()));\n+                    &format!(\"Encountered early bound region when generalizing: {:?}\",\n+                            r));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "cbbf73d942073c2714bf30bcc84f169526a2f4ce", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use super::type_variable::{EqTo};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::{Repr};\n \n pub struct Equate<'a, 'tcx: 'a> {\n     fields: CombineFields<'a, 'tcx>\n@@ -45,8 +44,8 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(), b.repr());\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n+               a, b);\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -75,10 +74,10 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(),\n-               b.repr());\n+               a,\n+               b);\n         let origin = Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n         Ok(a)"}, {"sha": "4ae618d45b7280b644059a1f2d06ed7745dc6a33", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -79,9 +79,10 @@ use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty};\n use middle::ty::{Region, ReFree};\n+\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n-use std::string::String;\n+use std::fmt;\n use syntax::ast;\n use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n@@ -90,10 +91,6 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-// Note: only import UserString, not Repr, since user-facing error\n-// messages shouldn't include debug serializations.\n-use util::ppaux::UserString;\n-\n pub fn note_and_explain_region(tcx: &ty::ctxt,\n                                prefix: &str,\n                                region: ty::Region,\n@@ -170,7 +167,7 @@ pub fn note_and_explain_region(tcx: &ty::ctxt,\n                 ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n                 _ => {\n                     format!(\"the lifetime {} as defined on\",\n-                            fr.bound_region.user_string())\n+                            fr.bound_region)\n                 }\n             };\n \n@@ -229,7 +226,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: UserString + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -507,7 +504,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: UserString + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -523,8 +520,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         Some(format!(\"expected `{}`, found `{}`\",\n-                     expected.user_string(),\n-                     found.user_string()))\n+                     expected,\n+                     found))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -540,9 +537,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n-                format!(\"the parameter type `{}`\", p.user_string()),\n+                format!(\"the parameter type `{}`\", p),\n             GenericKind::Projection(ref p) =>\n-                format!(\"the associated type `{}`\", p.user_string()),\n+                format!(\"the associated type `{}`\", p),\n         };\n \n         match sub {\n@@ -554,8 +551,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                        bound_kind.user_string(),\n-                        sub.user_string()));\n+                        bound_kind,\n+                        sub));\n             }\n \n             ty::ReStatic => {\n@@ -566,7 +563,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string()));\n+                        bound_kind));\n             }\n \n             _ => {\n@@ -578,7 +575,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string()));\n+                        bound_kind));\n                 note_and_explain_region(\n                     self.tcx,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n@@ -1561,7 +1558,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let br_string = |br: ty::BoundRegion| {\n-            let mut s = br.user_string();\n+            let mut s = br.to_string();\n             if !s.is_empty() {\n                 s.push_str(\" \");\n             }"}, {"sha": "d6b03266b1fe74e32d4d58cc2d2f5ef0cb316bb3", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use super::Subtype;\n \n use middle::ty::{self, Ty};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'a, 'tcx: 'a> {\n@@ -55,10 +54,10 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(),\n-               b.repr());\n+               a,\n+               b);\n \n         let origin = Subtype(self.fields.trace.clone());\n         Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))"}, {"sha": "7b26f6b153733a7f13e8125ead80914a9a48c08c", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -20,7 +20,6 @@ use middle::ty_fold::{self, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n \n pub trait HigherRankedRelations<'a,'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n@@ -46,8 +45,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                             -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        debug!(\"higher_ranked_sub(a={}, b={})\",\n-               a.repr(), b.repr());\n+        debug!(\"higher_ranked_sub(a={:?}, b={:?})\",\n+               a, b);\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -73,8 +72,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             let (b_prime, skol_map) =\n                 self.infcx.skolemize_late_bound_regions(b, snapshot);\n \n-            debug!(\"a_prime={}\", a_prime.repr());\n-            debug!(\"b_prime={}\", b_prime.repr());\n+            debug!(\"a_prime={:?}\", a_prime);\n+            debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n             let result = try!(self.sub().relate(&a_prime, &b_prime));\n@@ -96,8 +95,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 }\n             }\n \n-            debug!(\"higher_ranked_sub: OK result={}\",\n-                   result.repr());\n+            debug!(\"higher_ranked_sub: OK result={:?}\",\n+                   result);\n \n             Ok(ty::Binder(result))\n         });\n@@ -123,7 +122,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"lub result0 = {}\", result0.repr());\n+            debug!(\"lub result0 = {:?}\", result0);\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n@@ -135,10 +134,10 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                     |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars, &a_map, r));\n \n-            debug!(\"lub({},{}) = {}\",\n-                   a.repr(),\n-                   b.repr(),\n-                   result1.repr());\n+            debug!(\"lub({:?},{:?}) = {:?}\",\n+                   a,\n+                   b,\n+                   result1);\n \n             Ok(ty::Binder(result1))\n         });\n@@ -196,8 +195,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        debug!(\"higher_ranked_glb({}, {})\",\n-               a.repr(), b.repr());\n+        debug!(\"higher_ranked_glb({:?}, {:?})\",\n+               a, b);\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -217,7 +216,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"glb result0 = {}\", result0.repr());\n+            debug!(\"glb result0 = {:?}\", result0);\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n@@ -231,10 +230,10 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                                                     &a_map, &a_vars, &b_vars,\n                                                     r));\n \n-            debug!(\"glb({},{}) = {}\",\n-                   a.repr(),\n-                   b.repr(),\n-                   result1.repr());\n+            debug!(\"glb({:?},{:?}) = {:?}\",\n+                   a,\n+                   b,\n+                   result1);\n \n             Ok(ty::Binder(result1))\n         });\n@@ -449,9 +448,9 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n             !escaping_region_vars.contains(&r)\n         });\n \n-        debug!(\"region_vars_confined_to_snapshot: region_vars={} escaping_types={}\",\n-               region_vars.repr(),\n-               escaping_types.repr());\n+        debug!(\"region_vars_confined_to_snapshot: region_vars={:?} escaping_types={:?}\",\n+               region_vars,\n+               escaping_types);\n \n         region_vars\n     }\n@@ -532,10 +531,10 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n \n-    debug!(\"skolemize_bound_regions(binder={}, result={}, map={})\",\n-           binder.repr(),\n-           result.repr(),\n-           map.repr());\n+    debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n+           binder,\n+           result,\n+           map);\n \n     (result, map)\n }\n@@ -553,8 +552,8 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n      * hold. See `README.md` for more details.\n      */\n \n-    debug!(\"leak_check: skol_map={}\",\n-           skol_map.repr());\n+    debug!(\"leak_check: skol_map={:?}\",\n+           skol_map);\n \n     let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n     for (&skol_br, &skol) in skol_map {\n@@ -571,10 +570,10 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                 }\n             };\n \n-            debug!(\"{} (which replaced {}) is tainted by {}\",\n-                   skol.repr(),\n-                   skol_br.repr(),\n-                   tainted_region.repr());\n+            debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n+                   skol,\n+                   skol_br,\n+                   tainted_region);\n \n             // A is not as polymorphic as B:\n             return Err((skol_br, tainted_region));\n@@ -620,9 +619,9 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n {\n     debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n \n-    debug!(\"plug_leaks(skol_map={}, value={})\",\n-           skol_map.repr(),\n-           value.repr());\n+    debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n+           skol_map,\n+           value);\n \n     // Compute a mapping from the \"taint set\" of each skolemized\n     // region back to the `ty::BoundRegion` that it originally\n@@ -638,8 +637,8 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         })\n         .collect();\n \n-    debug!(\"plug_leaks: inv_skol_map={}\",\n-           inv_skol_map.repr());\n+    debug!(\"plug_leaks: inv_skol_map={:?}\",\n+           inv_skol_map);\n \n     // Remove any instantiated type variables from `value`; those can hide\n     // references to regions from the `fold_regions` code below.\n@@ -667,8 +666,8 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         }\n     });\n \n-    debug!(\"plug_leaks: result={}\",\n-           result.repr());\n+    debug!(\"plug_leaks: result={:?}\",\n+           result);\n \n     result\n }"}, {"sha": "7b34fda24064ef7fff78846eae32b6dc220b7230", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -35,7 +35,6 @@ use super::InferCtxt;\n use middle::ty::TyVar;\n use middle::ty::{self, Ty};\n use middle::ty_relate::{RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n@@ -51,10 +50,10 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n                                                         -> RelateResult<'tcx, Ty<'tcx>>\n     where 'tcx: 'a\n {\n-    debug!(\"{}.lattice_tys({}, {})\",\n+    debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),\n-           a.repr(),\n-           b.repr());\n+           a,\n+           b);\n \n     if a == b {\n         return Ok(a);"}, {"sha": "9d993ead5ca20039e78c396c394866d7ec0fc416", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use super::Subtype;\n \n use middle::ty::{self, Ty};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'a, 'tcx: 'a> {\n@@ -55,10 +54,10 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(),\n-               b.repr());\n+               a,\n+               b);\n \n         let origin = Subtype(self.fields.trace.clone());\n         Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))"}, {"sha": "2df335b5c3c0a89dd1ab7df0ab9f2476fb00aac4", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -36,7 +36,6 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::{Repr, UserString};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -330,8 +329,8 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                   b: Ty<'tcx>)\n                                   -> Ty<'tcx>\n {\n-    debug!(\"common_supertype({}, {})\",\n-           a.repr(), b.repr());\n+    debug!(\"common_supertype({:?}, {:?})\",\n+           a, b);\n \n     let trace = TypeTrace {\n         origin: origin,\n@@ -355,15 +354,15 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           b: Ty<'tcx>)\n                           -> UnitResult<'tcx>\n {\n-    debug!(\"mk_subty({} <: {})\", a.repr(), b.repr());\n+    debug!(\"mk_subty({:?} <: {:?})\", a, b);\n     cx.sub_types(a_is_expected, origin, a, b)\n }\n \n pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               a: Ty<'tcx>,\n                               b: Ty<'tcx>)\n                               -> UnitResult<'tcx> {\n-    debug!(\"can_mk_subty({} <: {})\", a.repr(), b.repr());\n+    debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n     cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n@@ -383,7 +382,7 @@ pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: SubregionOrigin<'tcx>,\n                          a: ty::Region,\n                          b: ty::Region) {\n-    debug!(\"mk_subr({} <: {})\", a.repr(), b.repr());\n+    debug!(\"mk_subr({:?} <: {:?})\", a, b);\n     let snapshot = cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit(snapshot);\n@@ -396,7 +395,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          b: Ty<'tcx>)\n                          -> UnitResult<'tcx>\n {\n-    debug!(\"mk_eqty({} <: {})\", a.repr(), b.repr());\n+    debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n     cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n }\n \n@@ -407,8 +406,8 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    b: ty::PolyTraitRef<'tcx>)\n                                    -> UnitResult<'tcx>\n {\n-    debug!(\"mk_sub_trait_refs({} <: {})\",\n-           a.repr(), b.repr());\n+    debug!(\"mk_sub_trait_refs({:?} <: {:?})\",\n+           a, b);\n     cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n@@ -637,7 +636,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      b: Ty<'tcx>)\n                      -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_types({} <: {})\", a.repr(), b.repr());\n+        debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n@@ -664,9 +663,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           b: ty::TraitRef<'tcx>)\n                           -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_trait_refs({} <: {})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"sub_trait_refs({:?} <: {:?})\",\n+               a,\n+               b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n@@ -683,9 +682,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                b: ty::PolyTraitRef<'tcx>)\n                                -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_poly_trait_refs({} <: {})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n+               a,\n+               b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n@@ -861,7 +860,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(&t).user_string()\n+        self.resolve_type_vars_if_possible(&t).to_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -870,8 +869,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        let t = self.resolve_type_vars_if_possible(t);\n-        t.user_string()\n+        self.resolve_type_vars_if_possible(t).to_string()\n     }\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n@@ -1047,18 +1045,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 kind: GenericKind<'tcx>,\n                                 a: ty::Region,\n                                 bs: Vec<ty::Region>) {\n-        debug!(\"verify_generic_bound({}, {} <: {})\",\n-               kind.repr(),\n-               a.repr(),\n-               bs.repr());\n+        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n+               kind,\n+               a,\n+               bs);\n \n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n \n     pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'b,'tcx> + Repr\n+        where T: Relate<'b,'tcx> + fmt::Debug\n     {\n-        debug!(\"can_equate({}, {})\", a.repr(), b.repr());\n+        debug!(\"can_equate({:?}, {:?})\", a, b);\n         self.probe(|_| {\n             // Gin up a dummy trace, since this won't be committed\n             // anyhow. We should make this typetrace stuff more"}, {"sha": "869f4d011cefe18218eb3752c41f029e3cfdafc3", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -24,7 +24,6 @@ use super::Constraint;\n use middle::infer::SubregionOrigin;\n use middle::infer::region_inference::RegionVarBindings;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n@@ -191,13 +190,13 @@ impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n             Node::RegionVid(n_vid) =>\n                 dot::LabelText::label(format!(\"{:?}\", n_vid)),\n             Node::Region(n_rgn) =>\n-                dot::LabelText::label(format!(\"{}\", n_rgn.repr())),\n+                dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n         }\n     }\n     fn edge_label(&self, e: &Edge) -> dot::LabelText {\n         match *e {\n             Edge::Constraint(ref c) =>\n-                dot::LabelText::label(format!(\"{}\", self.map.get(c).unwrap().repr())),\n+                dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap())),\n             Edge::EnclScope(..) =>\n                 dot::LabelText::label(format!(\"(enclosed)\")),\n         }"}, {"sha": "ddd352fcb430aaefbb0098266e6eadf2665e2e1b", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 69, "deletions": 70, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -30,7 +30,6 @@ use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty_relate::RelateResult;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n@@ -324,8 +323,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n-        debug!(\"created new region variable {:?} with origin {}\",\n-               vid, origin.repr());\n+        debug!(\"created new region variable {:?} with origin {:?}\",\n+               vid, origin);\n         return vid;\n     }\n \n@@ -392,8 +391,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_constraint({})\",\n-               constraint.repr());\n+        debug!(\"RegionVarBindings: add_constraint({:?})\",\n+               constraint);\n \n         if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n             if self.in_snapshot() {\n@@ -407,8 +406,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add verifys once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_verify({})\",\n-               verify.repr());\n+        debug!(\"RegionVarBindings: add_verify({:?})\",\n+               verify);\n \n         let mut verifys = self.verifys.borrow_mut();\n         let index = verifys.len();\n@@ -426,8 +425,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n-            debug!(\"add_given({} <= {:?})\",\n-                   sub.repr(),\n+            debug!(\"add_given({:?} <= {:?})\",\n+                   sub,\n                    sup);\n \n             self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n@@ -453,10 +452,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: make_subregion({}, {}) due to {}\",\n-               sub.repr(),\n-               sup.repr(),\n-               origin.repr());\n+        debug!(\"RegionVarBindings: make_subregion({:?}, {:?}) due to {:?}\",\n+               sub,\n+               sup,\n+               origin);\n \n         match (sub, sup) {\n           (ReEarlyBound(..), ReEarlyBound(..)) => {\n@@ -472,9 +471,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (_, ReLateBound(..)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                &format!(\"cannot relate bound region: {} <= {}\",\n-                        sub.repr(),\n-                        sup.repr()));\n+                &format!(\"cannot relate bound region: {:?} <= {:?}\",\n+                        sub,\n+                        sup));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -511,9 +510,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: lub_regions({}, {})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\",\n+               a,\n+               b);\n         match (a, b) {\n             (ReStatic, _) | (_, ReStatic) => {\n                 ReStatic // nothing lives longer than static\n@@ -536,9 +535,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: glb_regions({}, {})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\",\n+               a,\n+               b);\n         match (a, b) {\n             (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n@@ -564,7 +563,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n-                debug!(\"resolve_var({:?}) = {}\", rid, r.repr());\n+                debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n                 r\n             }\n         }\n@@ -621,7 +620,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n     pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={:?}, r0={})\", mark, r0.repr());\n+        debug!(\"tainted(mark={:?}, r0={:?})\", mark, r0);\n         let _indenter = indenter();\n \n         // `result_set` acts as a worklist: we explore all outgoing\n@@ -732,9 +731,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (ReEarlyBound(..), _) |\n           (_, ReEarlyBound(..)) => {\n             self.tcx.sess.bug(\n-                &format!(\"cannot relate bound region: LUB({}, {})\",\n-                        a.repr(),\n-                        b.repr()));\n+                &format!(\"cannot relate bound region: LUB({:?}, {:?})\",\n+                        a,\n+                        b));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -837,9 +836,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReEarlyBound(..), _) |\n             (_, ReEarlyBound(..)) => {\n               self.tcx.sess.bug(\n-                  &format!(\"cannot relate bound region: GLB({}, {})\",\n-                          a.repr(),\n-                          b.repr()));\n+                  &format!(\"cannot relate bound region: GLB({:?}, {:?})\",\n+                          a,\n+                          b));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -1014,18 +1013,18 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn dump_constraints(&self) {\n         debug!(\"----() Start constraint listing ()----\");\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n-            debug!(\"Constraint {} => {}\", idx, constraint.repr());\n+            debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n     }\n \n     fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n-            debug!(\"expansion: constraint={} origin={}\",\n-                   constraint.repr(),\n+            debug!(\"expansion: constraint={:?} origin={:?}\",\n+                   constraint,\n                    self.constraints.borrow()\n                                    .get(constraint)\n                                    .unwrap()\n-                                   .repr());\n+                                   );\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.index as usize];\n@@ -1055,10 +1054,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    b_data: &mut VarData)\n                    -> bool\n     {\n-        debug!(\"expand_node({}, {:?} == {})\",\n-               a_region.repr(),\n+        debug!(\"expand_node({:?}, {:?} == {:?})\",\n+               a_region,\n                b_vid,\n-               b_data.value.repr());\n+               b_data.value);\n \n         // Check if this relationship is implied by a given.\n         match a_region {\n@@ -1074,8 +1073,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of {:?} to {}\",\n-                   b_vid, a_region.repr());\n+            debug!(\"Setting initial value of {:?} to {:?}\",\n+                   b_vid, a_region);\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -1087,10 +1086,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of {:?} from {} to {}\",\n+            debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n                    b_vid,\n-                   cur_region.repr(),\n-                   lub.repr());\n+                   cur_region,\n+                   lub);\n \n             b_data.value = Value(lub);\n             return true;\n@@ -1106,12 +1105,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    free_regions: &FreeRegionMap,\n                    var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n-            debug!(\"contraction: constraint={} origin={}\",\n-                   constraint.repr(),\n+            debug!(\"contraction: constraint={:?} origin={:?}\",\n+                   constraint,\n                    self.constraints.borrow()\n                                    .get(constraint)\n                                    .unwrap()\n-                                   .repr());\n+                                   );\n             match *constraint {\n               ConstrainRegSubVar(..) => {\n                 // This is an expansion constraint.  Ignore.\n@@ -1140,9 +1139,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node({:?} == {}/{:?}, {})\",\n-               a_vid, a_data.value.repr(),\n-               a_data.classification, b_region.repr());\n+        debug!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n+               a_vid, a_data.value,\n+               a_data.classification, b_region);\n \n         return match a_data.value {\n             NoValue => {\n@@ -1172,10 +1171,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                       -> bool\n         {\n             if !free_regions.is_subregion_of(this.tcx, a_region, b_region) {\n-                debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n+                debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n                        a_vid,\n-                       a_region.repr(),\n-                       b_region.repr());\n+                       a_region,\n+                       b_region);\n                 a_data.value = ErrorValue;\n             }\n             false\n@@ -1193,19 +1192,19 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of {:?} from {} to {}\",\n+                        debug!(\"Contracting value of {:?} from {:?} to {:?}\",\n                                a_vid,\n-                               a_region.repr(),\n-                               glb.repr());\n+                               a_region,\n+                               glb);\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting {:?} to ErrorValue: no glb of {}, {}\",\n+                    debug!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n                            a_vid,\n-                           a_region.repr(),\n-                           b_region.repr());\n+                           a_region,\n+                           b_region);\n                     a_data.value = ErrorValue;\n                     false\n                 }\n@@ -1230,9 +1229,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    debug!(\"ConcreteFailure: !(sub <= sup): sub={}, sup={}\",\n-                           sub.repr(),\n-                           sup.repr());\n+                    debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n+                           sub,\n+                           sup);\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n@@ -1432,10 +1431,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_expanding_node() could not find error \\\n-                    for var {:?}, lower_bounds={}, upper_bounds={}\",\n+                    for var {:?}, lower_bounds={:?}, upper_bounds={:?}\",\n                     node_idx,\n-                    lower_bounds.repr(),\n-                    upper_bounds.repr()));\n+                    lower_bounds,\n+                    upper_bounds));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1479,9 +1478,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n-                     for var {:?}, upper_bounds={}\",\n+                     for var {:?}, upper_bounds={:?}\",\n                     node_idx,\n-                    upper_bounds.repr()));\n+                    upper_bounds));\n     }\n \n     fn collect_concrete_regions(&self,\n@@ -1579,8 +1578,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             for (constraint, _) in self.constraints.borrow().iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n-                    debug!(\"Updated due to constraint {}\",\n-                           constraint.repr());\n+                    debug!(\"Updated due to constraint {:?}\",\n+                           constraint);\n                     changed = true;\n                 }\n             }\n@@ -1620,9 +1619,9 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n \n impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionAndOrigin({},{})\",\n-               self.region.repr(),\n-               self.origin.repr())\n+        write!(f, \"RegionAndOrigin({:?},{:?})\",\n+               self.region,\n+               self.origin)\n     }\n }\n "}, {"sha": "b67437fd12781d0c2e9791e01504e0eca95fa779", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -11,7 +11,6 @@\n use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n use middle::ty::{self, Ty};\n use middle::ty_fold::{self, TypeFoldable};\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -95,8 +94,8 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 }\n                 ty::TyInfer(_) => {\n                     self.infcx.tcx.sess.bug(\n-                        &format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr()));\n+                        &format!(\"Unexpected type in full type resolver: {:?}\",\n+                                t));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "2b7f9a74b8bd5af568beb401d22f9a0445a3f751", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::{Repr};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Sub<'a, 'tcx: 'a> {\n@@ -49,7 +48,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(), b.repr());\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n \n         if a == b { return Ok(a); }\n \n@@ -85,10 +84,10 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(),\n-               b.repr());\n+               a,\n+               b);\n         let origin = Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n         Ok(a)"}, {"sha": "c4d924d676c89ff93d8bd0999c546c9e46801a17", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -14,7 +14,6 @@ use middle::def::DefFn;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n use middle::ty::{self, Ty};\n-use util::ppaux::Repr;\n \n use std::fmt;\n \n@@ -204,15 +203,15 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         match types_in_scope.next() {\n             None => {\n-                debug!(\"with_each_combination(substs={})\",\n-                       substs.repr());\n+                debug!(\"with_each_combination(substs={:?})\",\n+                       substs);\n \n                 callback(substs);\n             }\n \n             Some((space, index, &param_ty)) => {\n-                debug!(\"with_each_combination: space={:?}, index={}, param_ty={}\",\n-                       space, index, param_ty.repr());\n+                debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n+                       space, index, param_ty);\n \n                 if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n@@ -230,7 +229,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n-        debug!(\"Pushing transmute restriction: {}\", restriction.repr());\n+        debug!(\"Pushing transmute restriction: {:?}\", restriction);\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n }"}, {"sha": "ca8de74b35bda68072c5cff84a29a139bd9f977a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -78,12 +78,10 @@ use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n-use util::ppaux::{Repr, UserString};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n \n use std::cell::RefCell;\n use std::fmt;\n@@ -435,8 +433,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n             _ => base_ty,\n         };\n-        debug!(\"pat_ty(pat={}) base_ty={} ret_ty={}\",\n-               pat.repr(), base_ty.repr(), ret_ty.repr());\n+        debug!(\"pat_ty(pat={:?}) base_ty={:?} ret_ty={:?}\",\n+               pat, base_ty, ret_ty);\n         Ok(ret_ty)\n     }\n \n@@ -459,9 +457,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     ty::AdjustReifyFnPointer |\n                     ty::AdjustUnsafeFnPointer |\n                     ty::AdjustDerefRef(_) => {\n-                        debug!(\"cat_expr({}): {}\",\n-                               adjustment.repr(),\n-                               expr.repr());\n+                        debug!(\"cat_expr({:?}): {:?}\",\n+                               adjustment,\n+                               expr);\n                         // Result is an rvalue.\n                         let expr_ty = try!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n@@ -476,17 +474,17 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                autoderefs: usize)\n                                -> McResult<cmt<'tcx>> {\n         let mut cmt = try!(self.cat_expr_unadjusted(expr));\n-        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n+        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={:?}\",\n                autoderefs,\n-               cmt.repr());\n+               cmt);\n         for deref in 1..autoderefs + 1 {\n             cmt = try!(self.cat_deref(expr, cmt, deref, None));\n         }\n         return Ok(cmt);\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr());\n+        debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n         let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n@@ -497,10 +495,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprField(ref base, f_name) => {\n             let base_cmt = try!(self.cat_expr(&**base));\n-            debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n+            debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n-                   expr.repr(),\n-                   base_cmt.repr());\n+                   expr,\n+                   base_cmt);\n             Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n@@ -523,8 +521,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     let elem_ty = match ret_ty.sty {\n                         ty::TyRef(_, mt) => mt.ty,\n                         _ => {\n-                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n-                                   ret_ty.repr());\n+                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {:?}?\",\n+                                   ret_ty);\n                             return Err(());\n                         }\n                     };\n@@ -582,8 +580,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n                    -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_def: id={} expr={} def={:?}\",\n-               id, expr_ty.repr(), def);\n+        debug!(\"cat_def: id={} expr={:?} def={:?}\",\n+               id, expr_ty, def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n@@ -634,9 +632,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   _ => {\n                       self.tcx().sess.span_bug(\n                           span,\n-                          &format!(\"Upvar of non-closure {} - {}\",\n+                          &format!(\"Upvar of non-closure {} - {:?}\",\n                                   fn_node_id,\n-                                  ty.repr()));\n+                                  ty));\n                   }\n               }\n           }\n@@ -745,7 +743,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let ret = Rc::new(cmt_result);\n-        debug!(\"cat_upvar ret={}\", ret.repr());\n+        debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n \n@@ -816,7 +814,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             note: NoteClosureEnv(upvar_id)\n         };\n \n-        debug!(\"env_deref ret {}\", ret.repr());\n+        debug!(\"env_deref ret {:?}\", ret);\n \n         ret\n     }\n@@ -854,7 +852,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty::ReStatic\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n-        debug!(\"cat_rvalue_node ret {}\", ret.repr());\n+        debug!(\"cat_rvalue_node ret {:?}\", ret);\n         ret\n     }\n \n@@ -871,7 +869,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty:expr_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_rvalue ret {}\", ret.repr());\n+        debug!(\"cat_rvalue ret {:?}\", ret);\n         ret\n     }\n \n@@ -889,7 +887,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: f_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_field ret {}\", ret.repr());\n+        debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n \n@@ -907,7 +905,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: f_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_tup_field ret {}\", ret.repr());\n+        debug!(\"cat_tup_field ret {:?}\", ret);\n         ret\n     }\n \n@@ -924,7 +922,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let method_ty = self.typer.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n-               method_call, method_ty.map(|ty| ty.repr()));\n+               method_call, method_ty.map(|ty| ty));\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n@@ -942,12 +940,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                               mt.ty,\n                                               deref_context,\n                                                 /* implicit: */ false);\n-                debug!(\"cat_deref ret {}\", ret.repr());\n+                debug!(\"cat_deref ret {:?}\", ret);\n                 ret\n             }\n             None => {\n-                debug!(\"Explicit deref of non-derefable type: {}\",\n-                       base_cmt_ty.repr());\n+                debug!(\"Explicit deref of non-derefable type: {:?}\",\n+                       base_cmt_ty);\n                 return Err(());\n             }\n         }\n@@ -990,7 +988,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: deref_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_deref_common ret {}\", ret.repr());\n+        debug!(\"cat_deref_common ret {:?}\", ret);\n         Ok(ret)\n     }\n \n@@ -1041,7 +1039,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let m = base_cmt.mutbl.inherit();\n         let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n                            m, context, element_ty);\n-        debug!(\"cat_index ret {}\", ret.repr());\n+        debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n@@ -1095,7 +1093,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 base_cmt\n             }\n         };\n-        debug!(\"deref_vec ret {}\", ret.repr());\n+        debug!(\"deref_vec ret {:?}\", ret);\n         Ok(ret)\n     }\n \n@@ -1154,7 +1152,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: interior_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_imm_interior ret={}\", ret.repr());\n+        debug!(\"cat_imm_interior ret={:?}\", ret);\n         ret\n     }\n \n@@ -1172,7 +1170,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: downcast_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_downcast ret={}\", ret.repr());\n+        debug!(\"cat_downcast ret={:?}\", ret);\n         ret\n     }\n \n@@ -1232,9 +1230,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        debug!(\"cat_pattern: id={} pat={} cmt={}\",\n-               pat.id, pprust::pat_to_string(pat),\n-               cmt.repr());\n+        debug!(\"cat_pattern: {:?} cmt={:?}\",\n+               pat,\n+               cmt);\n \n         (*op)(self, cmt.clone(), pat);\n \n@@ -1520,7 +1518,7 @@ impl<'tcx> cmt_<'tcx> {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&cat_upvar(ref var)) => {\n-                        var.user_string()\n+                        var.to_string()\n                     }\n                     Some(_) => unreachable!(),\n                     None => {\n@@ -1560,7 +1558,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"pattern-bound indexed content\".to_string()\n             }\n             cat_upvar(ref var) => {\n-                var.user_string()\n+                var.to_string()\n             }\n             cat_downcast(ref cmt, _) => {\n                 cmt.descriptive_string(tcx)"}, {"sha": "3f00d9ba5e98d149cd9c5d94b7bce402d533a76f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, Visitor};\n use syntax::feature_gate::emit_feature_err;\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n-use util::ppaux::Repr;\n \n use std::mem::replace;\n \n@@ -450,7 +449,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                     tcx.sess.span_bug(e.span,\n                                       &format!(\"stability::check_expr: struct construction \\\n                                                 of non-struct, type {:?}\",\n-                                               type_.repr()));\n+                                               type_));\n                 }\n             }\n         }\n@@ -551,7 +550,7 @@ pub fn lookup<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability>\n }\n \n fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    debug!(\"lookup(id={})\", id.repr());\n+    debug!(\"lookup(id={:?})\", id);\n \n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {"}, {"sha": "c3c29d0ade8dfb0e64b5403f1c902bb48111ec86", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -15,7 +15,6 @@ pub use self::RegionSubsts::*;\n \n use middle::ty::{self, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use util::ppaux::Repr;\n \n use std::fmt;\n use std::iter::IntoIterator;\n@@ -618,10 +617,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                 self.tcx().sess.span_bug(\n                                     span,\n                                     &format!(\"Type parameter out of range \\\n-                                              when substituting in region {} (root type={}) \\\n+                                              when substituting in region {} (root type={:?}) \\\n                                               (space={:?}, index={})\",\n-                                             data.name.as_str(),\n-                                             self.root_ty.repr(),\n+                                             data.name,\n+                                             self.root_ty,\n                                              data.space,\n                                              data.index));\n                             }\n@@ -673,14 +672,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 self.tcx().sess.span_bug(\n                     span,\n-                    &format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n-                                 when substituting (root type={}) substs={}\",\n-                            p.repr(),\n-                            source_ty.repr(),\n+                    &format!(\"Type parameter `{:?}` ({:?}/{:?}/{}) out of range \\\n+                                 when substituting (root type={:?}) substs={:?}\",\n+                            p,\n+                            source_ty,\n                             p.space,\n                             p.idx,\n-                            self.root_ty.repr(),\n-                            self.substs.repr()));\n+                            self.root_ty,\n+                            self.substs));\n             }\n         };\n \n@@ -731,14 +730,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n-               ty.repr(), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+               ty, self.region_binders_passed, ty::type_has_escaping_regions(ty));\n \n         if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n             return ty;\n         }\n \n         let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {:?}\", result.repr());\n+        debug!(\"shift_regions: shifted result = {:?}\", result);\n \n         result\n     }"}, {"sha": "a826836b10c62c181accd85e1c82eef74bc5b9a4", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -22,7 +22,6 @@ use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n-use util::ppaux::Repr;\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n@@ -34,10 +33,10 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n                          -> bool\n {\n     debug!(\"impl_can_satisfy(\\\n-           impl1_def_id={}, \\\n-           impl2_def_id={})\",\n-           impl1_def_id.repr(),\n-           impl2_def_id.repr());\n+           impl1_def_id={:?}, \\\n+           impl2_def_id={:?})\",\n+           impl1_def_id,\n+           impl2_def_id);\n \n     let param_env = &ty::empty_parameter_environment(infcx.tcx);\n     let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n@@ -53,9 +52,9 @@ fn overlap(selcx: &mut SelectionContext,\n            b_def_id: ast::DefId)\n            -> bool\n {\n-    debug!(\"overlap(a_def_id={}, b_def_id={})\",\n-           a_def_id.repr(),\n-           b_def_id.repr());\n+    debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n+           a_def_id,\n+           b_def_id);\n \n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 a_def_id,\n@@ -65,9 +64,9 @@ fn overlap(selcx: &mut SelectionContext,\n                                                                 b_def_id,\n                                                                 util::fresh_type_vars_for_impl);\n \n-    debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr());\n+    debug!(\"overlap: a_trait_ref={:?}\", a_trait_ref);\n \n-    debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr());\n+    debug!(\"overlap: b_trait_ref={:?}\", b_trait_ref);\n \n     // Does `a <: b` hold? If not, no overlap.\n     if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n@@ -89,7 +88,7 @@ fn overlap(selcx: &mut SelectionContext,\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr());\n+        debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n         return false\n     }\n \n@@ -98,7 +97,7 @@ fn overlap(selcx: &mut SelectionContext,\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n-    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr());\n+    debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n \n     // if the orphan rules pass, that means that no ancestor crate can\n     // impl this, so it's up to us.\n@@ -180,17 +179,17 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           impl_def_id: ast::DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check({})\", impl_def_id.repr());\n+    debug!(\"orphan_check({:?})\", impl_def_id);\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n-    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr());\n+    debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n-        debug!(\"trait {} is local to current crate\",\n-               trait_ref.def_id.repr());\n+        debug!(\"trait {:?} is local to current crate\",\n+               trait_ref.def_id);\n         return Ok(());\n     }\n \n@@ -202,8 +201,8 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 infer_is_local: InferIsLocal)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={}, infer_is_local={})\",\n-           trait_ref.repr(), infer_is_local.0);\n+    debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={})\",\n+           trait_ref, infer_is_local.0);\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n@@ -214,14 +213,14 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // some local type.\n     for input_ty in input_tys {\n         if ty_is_local(tcx, input_ty, infer_is_local) {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr());\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n             let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n             for uncovered_ty in uncovered_tys {\n                 if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n-                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr());\n+                    debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                     return Err(OrphanCheckErr::UncoveredTy(param));\n                 }\n             }\n@@ -234,7 +233,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // parameters reachable.\n         if !infer_is_local.0 {\n             if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n-                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr());\n+                debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                 return Err(OrphanCheckErr::UncoveredTy(param));\n             }\n         }\n@@ -294,7 +293,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  infer_is_local: InferIsLocal)\n                                  -> bool\n {\n-    debug!(\"ty_is_local_constructor({})\", ty.repr());\n+    debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n         ty::TyBool |\n@@ -335,8 +334,8 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::TyClosure(..) |\n         ty::TyError => {\n             tcx.sess.bug(\n-                &format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr()))\n+                &format!(\"ty_is_local invoked on unexpected type: {:?}\",\n+                        ty))\n         }\n     }\n }"}, {"sha": "8618f5215290769924d31ce6813b1b6171de2b40", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,9 +28,9 @@ use middle::infer::InferCtxt;\n use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n+use std::fmt;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n-use util::ppaux::{Repr, UserString};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n@@ -68,7 +68,7 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n         span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n-                predicate.user_string(),\n+                predicate,\n                 error.err);\n         note_obligation_cause(infcx, obligation);\n     }\n@@ -87,16 +87,16 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 item.meta().span\n             };\n             let def = ty::lookup_trait_def(infcx.tcx, def_id);\n-            let trait_str = def.trait_ref.user_string();\n+            let trait_str = def.trait_ref.to_string();\n             if let Some(ref istring) = item.value_str() {\n                 let mut generic_map = def.generics.types.iter_enumerated()\n                                          .map(|(param, i, gen)| {\n                                                (gen.name.as_str().to_string(),\n                                                 trait_ref.substs.types.get(param, i)\n-                                                         .user_string())\n+                                                         .to_string())\n                                               }).collect::<HashMap<String, String>>();\n                 generic_map.insert(\"Self\".to_string(),\n-                                   trait_ref.self_ty().user_string());\n+                                   trait_ref.self_ty().to_string());\n                 let parser = Parser::new(&istring);\n                 let mut errored = false;\n                 let err: String = parser.filter_map(|p| {\n@@ -157,13 +157,13 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                           obligation: &Obligation<'tcx, T>)\n                                           -> !\n-    where T: UserString + TypeFoldable<'tcx>\n+    where T: fmt::Display + TypeFoldable<'tcx>\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n               \"overflow evaluating the requirement `{}`\",\n-              predicate.user_string());\n+              predicate);\n \n     suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -184,7 +184,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string());;\n+                            obligation.predicate);;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -197,8 +197,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n-                                        trait_ref.user_string(),\n-                                        trait_ref.self_ty().user_string());\n+                                        trait_ref,\n+                                        trait_ref.self_ty());\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n@@ -216,7 +216,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                &predicate).err().unwrap();\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate.user_string(),\n+                                    predicate,\n                                     err);\n                         }\n \n@@ -226,7 +226,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                       &predicate).err().unwrap();\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate.user_string(),\n+                                    predicate,\n                                     err);\n                         }\n \n@@ -235,7 +235,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string());\n+                                        predicate);\n                         }\n                     }\n                 }\n@@ -249,9 +249,9 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty().user_string(),\n-                        expected_trait_ref.user_string(),\n-                        actual_trait_ref.user_string(),\n+                        expected_trait_ref.self_ty(),\n+                        expected_trait_ref,\n+                        actual_trait_ref,\n                         e);\n                     note_obligation_cause(infcx, obligation);\n             }\n@@ -282,7 +282,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.sess.span_note(\n                             obligation.cause.span,\n                             &format!(\"method `{}` has no receiver\",\n-                                    method.name.user_string()));\n+                                    method.name));\n                     }\n \n                     ObjectSafetyViolation::Method(method,\n@@ -291,15 +291,15 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             obligation.cause.span,\n                             &format!(\"method `{}` references the `Self` type \\\n                                     in its arguments or return type\",\n-                                    method.name.user_string()));\n+                                    method.name));\n                     }\n \n                     ObjectSafetyViolation::Method(method,\n                             MethodViolationCode::Generic) => {\n                         infcx.tcx.sess.span_note(\n                             obligation.cause.span,\n                             &format!(\"method `{}` has generic type parameters\",\n-                                    method.name.user_string()));\n+                                    method.name));\n                     }\n                 }\n             }\n@@ -316,9 +316,9 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n     let predicate = infcx.resolve_type_vars_if_possible(&obligation.predicate);\n \n-    debug!(\"maybe_report_ambiguity(predicate={}, obligation={})\",\n-           predicate.repr(),\n-           obligation.repr());\n+    debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n+           predicate,\n+           obligation);\n \n     match predicate {\n         ty::Predicate::Trait(ref data) => {\n@@ -349,11 +349,11 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations or generic parameter binding required\",\n-                                self_ty.user_string());\n+                                self_ty);\n                     } else {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string());;\n+                                predicate);;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -365,16 +365,16 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         \"coherence failed to report ambiguity: \\\n                          cannot locate the impl of the trait `{}` for \\\n                          the type `{}`\",\n-                        trait_ref.user_string(),\n-                        self_ty.user_string()));\n+                        trait_ref,\n+                        self_ty));\n             }\n         }\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string());;\n+                        predicate);;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -383,7 +383,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                       obligation: &Obligation<'tcx, T>)\n-    where T: UserString\n+    where T: fmt::Display\n {\n     note_obligation_cause_code(infcx,\n                                &obligation.predicate,\n@@ -395,7 +395,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                            predicate: &T,\n                                            cause_span: Span,\n                                            cause_code: &ObligationCauseCode<'tcx>)\n-    where T: UserString\n+    where T: fmt::Display\n {\n     let tcx = infcx.tcx;\n     match *cause_code {\n@@ -463,24 +463,24 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n                        \"required because it appears within the type `{}`\",\n-                       parent_trait_ref.0.self_ty().user_string());\n+                       parent_trait_ref.0.self_ty());\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n                        \"required because of the requirements on the impl of `{}` for `{}`\",\n-                       parent_trait_ref.user_string(),\n-                       parent_trait_ref.0.self_ty().user_string());\n+                       parent_trait_ref,\n+                       parent_trait_ref.0.self_ty());\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             span_note!(tcx.sess, cause_span,\n                       \"the requirement `{}` appears on the impl method \\\n                       but not on the corresponding trait method\",\n-                      predicate.user_string());\n+                      predicate);\n         }\n     }\n }"}, {"sha": "593a71a30fe2a11ae5dd86609b4df3e2b088d4d7", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -15,7 +15,6 @@ use std::collections::HashSet;\n use std::fmt;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n@@ -138,8 +137,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n     {\n-        debug!(\"normalize_associated_type(projection_ty={})\",\n-               projection_ty.repr());\n+        debug!(\"normalize_associated_type(projection_ty={:?})\",\n+               projection_ty);\n \n         assert!(!projection_ty.has_escaping_regions());\n \n@@ -152,7 +151,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n \n-        debug!(\"normalize_associated_type: result={}\", normalized.value.repr());\n+        debug!(\"normalize_associated_type: result={:?}\", normalized.value);\n \n         normalized.value\n     }\n@@ -190,11 +189,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         assert!(!obligation.has_escaping_regions());\n \n         if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n-            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr());\n+            debug!(\"register_predicate({:?}) -- already seen, skip\", obligation);\n             return;\n         }\n \n-        debug!(\"register_predicate({})\", obligation.repr());\n+        debug!(\"register_predicate({:?})\", obligation);\n         self.predicates.push(obligation);\n     }\n \n@@ -378,9 +377,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     true\n                 }\n                 Err(selection_err) => {\n-                    debug!(\"predicate: {} error: {}\",\n-                           obligation.repr(),\n-                           selection_err.repr());\n+                    debug!(\"predicate: {:?} error: {:?}\",\n+                           obligation,\n+                           selection_err);\n                     errors.push(\n                         FulfillmentError::new(\n                             obligation.clone(),\n@@ -439,9 +438,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n             let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n-            debug!(\"process_predicate: poly_project_and_unify_type({}) returned {}\",\n-                   project_obligation.repr(),\n-                   result.repr());\n+            debug!(\"process_predicate: poly_project_and_unify_type({:?}) returned {:?}\",\n+                   project_obligation,\n+                   result);\n             match result {\n                 Ok(Some(obligations)) => {\n                     new_obligations.extend(obligations);\n@@ -479,8 +478,8 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                                sub_region: r_b,\n                                                cause: cause };\n \n-    debug!(\"register_region_obligation({})\",\n-           region_obligation.repr());\n+    debug!(\"register_region_obligation({:?})\",\n+           region_obligation);\n \n     region_obligations.entry(region_obligation.cause.body_id).or_insert(vec![])\n         .push(region_obligation);"}, {"sha": "e3c122e2f1f59319f6dc3291c0510af5f8a50222", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -23,7 +23,6 @@ use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n@@ -319,8 +318,8 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                                  span: Span)\n                                                  -> bool\n {\n-    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={:?})\",\n-           ty.repr(),\n+    debug!(\"type_known_to_meet_builtin_bound(ty={:?}, bound={:?})\",\n+           ty,\n            bound);\n \n     let mut fulfill_cx = FulfillmentContext::new(false);\n@@ -337,16 +336,16 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     // assume it is move; linear is always ok.\n     match fulfill_cx.select_all_or_error(infcx, typer) {\n         Ok(()) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} success\",\n-                   ty.repr(),\n+            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n+                   ty,\n                    bound);\n             true\n         }\n         Err(e) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} errors={}\",\n-                   ty.repr(),\n+            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n+                   ty,\n                    bound,\n-                   e.repr());\n+                   e);\n             false\n         }\n     }\n@@ -376,8 +375,8 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     let span = cause.span;\n     let body_id = cause.body_id;\n \n-    debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n-           unnormalized_env.repr());\n+    debug!(\"normalize_param_env_or_error(unnormalized_env={:?})\",\n+           unnormalized_env);\n \n     let predicates: Vec<_> =\n         util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.clone())\n@@ -392,8 +391,8 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     // constructed, but I am not currently doing so out of laziness.\n     // -nmatsakis\n \n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={}\",\n-           predicates.repr());\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n+           predicates);\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n@@ -435,21 +434,21 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n-    debug!(\"normalize_param_env(value={})\", value.repr());\n+    debug!(\"normalize_param_env(value={:?})\", value);\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n     let mut fulfill_cx = FulfillmentContext::new(false);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n-    debug!(\"normalize_param_env: normalized_value={} obligations={}\",\n-           normalized_value.repr(),\n-           obligations.repr());\n+    debug!(\"normalize_param_env: normalized_value={:?} obligations={:?}\",\n+           normalized_value,\n+           obligations);\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n     try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={}\", resolved_value.repr());\n+    debug!(\"normalize_param_env: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }\n "}, {"sha": "afb30716c36697b50955d1f5fcb4ec0f4c0fa07c", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -25,7 +25,6 @@ use middle::traits;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::rc::Rc;\n use syntax::ast;\n-use util::ppaux::Repr;\n \n #[derive(Debug)]\n pub enum ObjectSafetyViolation<'tcx> {\n@@ -71,7 +70,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n         result\n     });\n \n-    debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(), result);\n+    debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n \n     result\n }\n@@ -112,9 +111,9 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n         violations.push(ObjectSafetyViolation::SupertraitSelf);\n     }\n \n-    debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n-           trait_def_id.repr(),\n-           violations.repr());\n+    debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+           trait_def_id,\n+           violations);\n \n     violations\n }"}, {"sha": "3ac58dafa4a7a25807825eb90ad3e5784cd772d5", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n-use util::ppaux::Repr;\n \n use std::fmt;\n \n@@ -79,8 +78,8 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"poly_project_and_unify_type(obligation={})\",\n-           obligation.repr());\n+    debug!(\"poly_project_and_unify_type(obligation={:?})\",\n+           obligation);\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n@@ -112,8 +111,8 @@ fn project_and_unify_type<'cx,'tcx>(\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"project_and_unify_type(obligation={})\",\n-           obligation.repr());\n+    debug!(\"project_and_unify_type(obligation={:?})\",\n+           obligation);\n \n     let Normalized { value: normalized_ty, obligations } =\n         match opt_normalize_projection_type(selcx,\n@@ -127,9 +126,9 @@ fn project_and_unify_type<'cx,'tcx>(\n             }\n         };\n \n-    debug!(\"project_and_unify_type: normalized_ty={} obligations={}\",\n-           normalized_ty.repr(),\n-           obligations.repr());\n+    debug!(\"project_and_unify_type: normalized_ty={:?} obligations={:?}\",\n+           normalized_ty,\n+           obligations);\n \n     let infcx = selcx.infcx();\n     let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n@@ -141,8 +140,8 @@ fn project_and_unify_type<'cx,'tcx>(\n \n fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n                                                     obligation: &ProjectionObligation<'tcx>) {\n-    debug!(\"consider_unification_despite_ambiguity(obligation={})\",\n-           obligation.repr());\n+    debug!(\"consider_unification_despite_ambiguity(obligation={:?})\",\n+           obligation);\n \n     let def_id = obligation.predicate.projection_ty.trait_ref.def_id;\n     match selcx.tcx().lang_items.fn_trait_kind(def_id) {\n@@ -176,7 +175,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n                     &ty::Binder(ret_type));\n \n             debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n-                   ret_type.repr());\n+                   ret_type);\n             let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n@@ -357,9 +356,9 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     -> Option<NormalizedTy<'tcx>>\n {\n     debug!(\"normalize_projection_type(\\\n-           projection_ty={}, \\\n+           projection_ty={:?}, \\\n            depth={})\",\n-           projection_ty.repr(),\n+           projection_ty,\n            depth);\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n@@ -370,17 +369,17 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            debug!(\"normalize_projection_type: projected_ty={} depth={} obligations={}\",\n-                   projected_ty.repr(),\n+            debug!(\"normalize_projection_type: projected_ty={:?} depth={} obligations={:?}\",\n+                   projected_ty,\n                    depth,\n-                   obligations.repr());\n+                   obligations);\n \n             if ty::type_has_projection(projected_ty) {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n-                debug!(\"normalize_projection_type: normalized_ty={} depth={}\",\n-                       normalized_ty.repr(),\n+                debug!(\"normalize_projection_type: normalized_ty={:?} depth={}\",\n+                       normalized_ty,\n                        depth);\n \n                 obligations.extend(normalizer.obligations);\n@@ -396,8 +395,8 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             }\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(\"normalize_projection_type: projected_ty={} no progress\",\n-                   projected_ty.repr());\n+            debug!(\"normalize_projection_type: projected_ty={:?} no progress\",\n+                   projected_ty);\n             Some(Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n@@ -451,8 +450,8 @@ fn project_type<'cx,'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>)\n     -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n-    debug!(\"project(obligation={})\",\n-           obligation.repr());\n+    debug!(\"project(obligation={:?})\",\n+           obligation);\n \n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n@@ -463,7 +462,7 @@ fn project_type<'cx,'tcx>(\n     let obligation_trait_ref =\n         selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n \n-    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr());\n+    debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n \n     if obligation_trait_ref.references_error() {\n         return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n@@ -591,12 +590,12 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     env_predicates: I)\n     where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n-    debug!(\"assemble_candidates_from_predicates(obligation={})\",\n-           obligation.repr());\n+    debug!(\"assemble_candidates_from_predicates(obligation={:?})\",\n+           obligation);\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n-        debug!(\"assemble_candidates_from_predicates: predicate={}\",\n-               predicate.repr());\n+        debug!(\"assemble_candidates_from_predicates: predicate={:?}\",\n+               predicate);\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n@@ -613,10 +612,9 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                                               obligation_poly_trait_ref).is_ok()\n                 });\n \n-                debug!(\"assemble_candidates_from_predicates: candidate {} is_match {} same_name {}\",\n-                       data.repr(),\n-                       is_match,\n-                       same_name);\n+                debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n+                                                             is_match={} same_name={}\",\n+                       data, is_match, same_name);\n \n                 if is_match {\n                     candidate_set.vec.push(\n@@ -635,15 +633,15 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     object_ty: Ty<'tcx>)\n {\n-    debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n-           object_ty.repr());\n+    debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n+           object_ty);\n     let data = match object_ty.sty {\n         ty::TyTrait(ref data) => data,\n         _ => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                &format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n-                         object_ty.repr()));\n+                &format!(\"assemble_candidates_from_object_type called with non-object: {:?}\",\n+                         object_ty));\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -673,16 +671,16 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             return Ok(());\n         }\n         Err(e) => {\n-            debug!(\"assemble_candidates_from_impls: selection error {}\",\n-                   e.repr());\n+            debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n+                   e);\n             return Err(e);\n         }\n     };\n \n     match vtable {\n         super::VtableImpl(data) => {\n-            debug!(\"assemble_candidates_from_impls: impl candidate {}\",\n-                   data.repr());\n+            debug!(\"assemble_candidates_from_impls: impl candidate {:?}\",\n+                   data);\n \n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n@@ -732,8 +730,8 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                &format!(\"Cannot project an associated type from `{}`\",\n-                         vtable.repr()));\n+                &format!(\"Cannot project an associated type from `{:?}`\",\n+                         vtable));\n         }\n     }\n \n@@ -746,9 +744,9 @@ fn confirm_candidate<'cx,'tcx>(\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    debug!(\"confirm_candidate(candidate={}, obligation={})\",\n-           candidate.repr(),\n-           obligation.repr());\n+    debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\",\n+           candidate,\n+           obligation);\n \n     match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n@@ -812,9 +810,9 @@ fn confirm_callable_candidate<'cx,'tcx>(\n {\n     let tcx = selcx.tcx();\n \n-    debug!(\"confirm_callable_candidate({},{})\",\n-           obligation.repr(),\n-           fn_sig.repr());\n+    debug!(\"confirm_callable_candidate({:?},{:?})\",\n+           obligation,\n+           fn_sig);\n \n     // the `Output` associated type is declared on `FnOnce`\n     let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n@@ -864,9 +862,9 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n         Err(e) => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                &format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                         obligation.repr(),\n-                         projection.repr(),\n+                &format!(\"Failed to unify `{:?}` and `{:?}` in projection: {}\",\n+                         obligation,\n+                         projection,\n                          e));\n         }\n     }\n@@ -914,8 +912,8 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     }\n \n     selcx.tcx().sess.span_bug(obligation.cause.span,\n-                              &format!(\"No associated type for {}\",\n-                                       trait_ref.repr()));\n+                              &format!(\"No associated type for {:?}\",\n+                                       trait_ref));\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {"}, {"sha": "1653cac68e6e05a435c0fb6bd93b7d6a1e1eddb3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 141, "deletions": 142, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -51,7 +51,6 @@ use std::rc::Rc;\n use syntax::{abi, ast};\n use util::common::ErrorReported;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n@@ -300,7 +299,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// type environment by performing unification.\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n-        debug!(\"select({})\", obligation.repr());\n+        debug!(\"select({:?})\", obligation);\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n@@ -389,8 +388,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                obligation: &PredicateObligation<'tcx>)\n                                -> bool\n     {\n-        debug!(\"evaluate_obligation({})\",\n-               obligation.repr());\n+        debug!(\"evaluate_obligation({:?})\",\n+               obligation);\n \n         self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n             .may_apply()\n@@ -442,8 +441,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &PredicateObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n-        debug!(\"evaluate_predicate_recursively({})\",\n-               obligation.repr());\n+        debug!(\"evaluate_predicate_recursively({:?})\",\n+               obligation);\n \n         // Check the cache from the tcx of predicates that we know\n         // have been proven elsewhere. This cache only contains\n@@ -501,8 +500,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            obligation: &TraitObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n-        debug!(\"evaluate_obligation_recursively({})\",\n-               obligation.repr());\n+        debug!(\"evaluate_obligation_recursively({:?})\",\n+               obligation);\n \n         let stack = self.push_stack(previous_stack, obligation);\n \n@@ -549,8 +548,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                   |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n                                                      &prev.fresh_trait_ref)))\n         {\n-            debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n-                   stack.fresh_trait_ref.repr());\n+            debug!(\"evaluate_stack({:?}) --> unbound argument, recursion -->  ambiguous\",\n+                   stack.fresh_trait_ref);\n             return EvaluatedToAmbig;\n         }\n \n@@ -578,8 +577,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // skip top-most frame\n             .any(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n-            debug!(\"evaluate_stack({}) --> recursive\",\n-                   stack.fresh_trait_ref.repr());\n+            debug!(\"evaluate_stack({:?}) --> recursive\",\n+                   stack.fresh_trait_ref);\n             return EvaluatedToOk;\n         }\n \n@@ -597,9 +596,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          obligation: &TraitObligation<'tcx>)\n                          -> bool\n     {\n-        debug!(\"evaluate_impl(impl_def_id={}, obligation={})\",\n-               impl_def_id.repr(),\n-               obligation.repr());\n+        debug!(\"evaluate_impl(impl_def_id={:?}, obligation={:?})\",\n+               impl_def_id,\n+               obligation);\n \n         self.infcx.probe(|snapshot| {\n             match self.match_impl(impl_def_id, obligation, snapshot) {\n@@ -645,16 +644,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // with fresh skolemized types starting from index 0.\n         let cache_fresh_trait_pred =\n             self.infcx.freshen(stack.obligation.predicate.clone());\n-        debug!(\"candidate_from_obligation(cache_fresh_trait_pred={}, obligation={})\",\n-               cache_fresh_trait_pred.repr(),\n-               stack.repr());\n+        debug!(\"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n+               cache_fresh_trait_pred,\n+               stack);\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n         match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_fresh_trait_pred={}, candidate={}\",\n-                       cache_fresh_trait_pred.repr(),\n-                       c.repr());\n+                debug!(\"CACHE HIT: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+                       cache_fresh_trait_pred,\n+                       c);\n                 return c;\n             }\n             None => { }\n@@ -664,8 +663,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n-            debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n-                   cache_fresh_trait_pred.repr(), candidate.repr());\n+            debug!(\"CACHE MISS: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+                   cache_fresh_trait_pred, candidate);\n             self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         }\n \n@@ -694,10 +693,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = candidate_set.vec;\n \n-        debug!(\"assembled {} candidates for {}: {}\",\n+        debug!(\"assembled {} candidates for {:?}: {:?}\",\n                candidates.len(),\n-               stack.repr(),\n-               candidates.repr());\n+               stack,\n+               candidates);\n \n         // At this point, we know that each of the entries in the\n         // candidate set is *individually* applicable. Now we have to\n@@ -737,12 +736,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .any(|j| self.candidate_should_be_dropped_in_favor_of(&candidates[i],\n                                                                           &candidates[j]));\n                 if is_dup {\n-                    debug!(\"Dropping candidate #{}/{}: {}\",\n-                           i, candidates.len(), candidates[i].repr());\n+                    debug!(\"Dropping candidate #{}/{}: {:?}\",\n+                           i, candidates.len(), candidates[i]);\n                     candidates.swap_remove(i);\n                 } else {\n-                    debug!(\"Retaining candidate #{}/{}: {}\",\n-                           i, candidates.len(), candidates[i].repr());\n+                    debug!(\"Retaining candidate #{}/{}: {:?}\",\n+                           i, candidates.len(), candidates[i]);\n                     i += 1;\n                 }\n             }\n@@ -908,8 +907,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n             Some(ty::BoundCopy) => {\n-                debug!(\"obligation self ty is {}\",\n-                       obligation.predicate.0.self_ty().repr());\n+                debug!(\"obligation self ty is {:?}\",\n+                       obligation.predicate.0.self_ty());\n \n                 // User-defined copy impls are permitted, but only for\n                 // structs and enums.\n@@ -959,9 +958,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let poly_trait_predicate =\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n \n-        debug!(\"assemble_candidates_for_projected_tys({},{})\",\n-               obligation.repr(),\n-               poly_trait_predicate.repr());\n+        debug!(\"assemble_candidates_for_projected_tys({:?},{:?})\",\n+               obligation,\n+               poly_trait_predicate);\n \n         // FIXME(#20297) -- just examining the self-type is very simplistic\n \n@@ -983,8 +982,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return; }\n         };\n \n-        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={}\",\n-               trait_def_id.repr());\n+        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n+               trait_def_id);\n \n         let result = self.infcx.probe(|snapshot| {\n             self.match_projection_obligation_against_bounds_from_trait(obligation,\n@@ -1007,29 +1006,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let (skol_trait_predicate, skol_map) =\n             self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                skol_trait_predicate={} skol_map={}\",\n-               skol_trait_predicate.repr(),\n-               skol_map.repr());\n+                skol_trait_predicate={:?} skol_map={:?}\",\n+               skol_trait_predicate,\n+               skol_map);\n \n         let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => &data.trait_ref,\n             _ => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     &format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n-                              but self-ty not a projection: {}\",\n-                             skol_trait_predicate.trait_ref.self_ty().repr()));\n+                              but self-ty not a projection: {:?}\",\n+                             skol_trait_predicate.trait_ref.self_ty()));\n             }\n         };\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                projection_trait_ref={}\",\n-               projection_trait_ref.repr());\n+                projection_trait_ref={:?}\",\n+               projection_trait_ref);\n \n         let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n         let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                bounds={}\",\n-               bounds.repr());\n+                bounds={:?}\",\n+               bounds);\n \n         let matching_bound =\n             util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n@@ -1043,8 +1042,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               snapshot)));\n \n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                matching_bound={}\",\n-               matching_bound.repr());\n+                matching_bound={:?}\",\n+               matching_bound);\n         match matching_bound {\n             None => false,\n             Some(bound) => {\n@@ -1090,8 +1089,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   candidates: &mut SelectionCandidateSet<'tcx>)\n                                                   -> Result<(),SelectionError<'tcx>>\n     {\n-        debug!(\"assemble_candidates_from_caller_bounds({})\",\n-               stack.obligation.repr());\n+        debug!(\"assemble_candidates_from_caller_bounds({:?})\",\n+               stack.obligation);\n \n         let all_bounds =\n             self.param_env().caller_bounds\n@@ -1157,10 +1156,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return Ok(()); }\n         };\n \n-        debug!(\"assemble_unboxed_candidates: self_ty={} kind={:?} obligation={}\",\n-               self_ty.repr(),\n+        debug!(\"assemble_unboxed_candidates: self_ty={:?} kind={:?} obligation={:?}\",\n+               self_ty,\n                kind,\n-               obligation.repr());\n+               obligation);\n \n         match self.closure_typer.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n@@ -1223,7 +1222,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr());\n+        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n         let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n \n@@ -1249,7 +1248,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr());\n+        debug!(\"assemble_candidates_from_default_impls(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();\n \n@@ -1318,8 +1317,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &TraitObligation<'tcx>,\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n-               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr());\n+        debug!(\"assemble_candidates_from_object_ty(self_ty={:?})\",\n+               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()));\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1364,8 +1363,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             };\n \n-            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n-                   poly_trait_ref.repr());\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\",\n+                   poly_trait_ref);\n \n             // see whether the object trait can be upcast to the trait we are looking for\n             let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n@@ -1408,8 +1407,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let source = self.infcx.shallow_resolve(self_ty);\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n-        debug!(\"assemble_candidates_for_unsizing(source={}, target={})\",\n-               source.repr(), target.repr());\n+        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n+               source, target);\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n@@ -1475,7 +1474,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             candidate: &SelectionCandidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        debug!(\"winnow_candidate: candidate={}\", candidate.repr());\n+        debug!(\"winnow_candidate: candidate={:?}\", candidate);\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n@@ -1567,8 +1566,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         match self.builtin_bound(bound, stack.obligation) {\n             Ok(If(..)) => {\n-                debug!(\"builtin_bound: bound={}\",\n-                       bound.repr());\n+                debug!(\"builtin_bound: bound={:?}\",\n+                       bound);\n                 candidates.vec.push(BuiltinCandidate(bound));\n                 Ok(())\n             }\n@@ -1776,8 +1775,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr()));\n+                        \"asked to assemble builtin bounds of unexpected type: {:?}\",\n+                        self_ty));\n             }\n         };\n \n@@ -1839,8 +1838,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to assemble constituent types of unexpected type: {}\",\n-                        t.repr()));\n+                        \"asked to assemble constituent types of unexpected type: {:?}\",\n+                        t));\n             }\n \n             ty::TyBox(referent_ty) => {  // Box<T>\n@@ -1974,9 +1973,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          candidate: SelectionCandidate<'tcx>)\n                          -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_candidate({}, {})\",\n-               obligation.repr(),\n-               candidate.repr());\n+        debug!(\"confirm_candidate({:?}, {:?})\",\n+               obligation,\n+               candidate);\n \n         match candidate {\n             BuiltinCandidate(builtin_bound) => {\n@@ -2066,9 +2065,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                param: ty::PolyTraitRef<'tcx>)\n                                -> Vec<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_param_candidate({},{})\",\n-               obligation.repr(),\n-               param.repr());\n+        debug!(\"confirm_param_candidate({:?},{:?})\",\n+               obligation,\n+               param);\n \n         // During evaluation, we already checked that this\n         // where-clause trait-ref could be unified with the obligation\n@@ -2078,9 +2077,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(obligations) => obligations,\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    &format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n-                             param.repr(),\n-                             obligation.repr()));\n+                    &format!(\"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n+                             param,\n+                             obligation));\n             }\n         }\n     }\n@@ -2091,16 +2090,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_builtin_candidate({})\",\n-               obligation.repr());\n+        debug!(\"confirm_builtin_candidate({:?})\",\n+               obligation);\n \n         match try!(self.builtin_bound(bound, obligation)) {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    &format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr()));\n+                    &format!(\"builtin bound for {:?} was ambig\",\n+                            obligation));\n             }\n         }\n     }\n@@ -2120,8 +2119,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let obligations = self.collect_predicates_for_types(obligation, trait_def, nested);\n \n-        debug!(\"vtable_builtin_data: obligations={}\",\n-               obligations.repr());\n+        debug!(\"vtable_builtin_data: obligations={:?}\",\n+               obligations);\n \n         VtableBuiltinData { nested: obligations }\n     }\n@@ -2136,9 +2135,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       trait_def_id: ast::DefId)\n                                       -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_default_impl_candidate({}, {})\",\n-               obligation.repr(),\n-               trait_def_id.repr());\n+        debug!(\"confirm_default_impl_candidate({:?}, {:?})\",\n+               obligation,\n+               trait_def_id);\n \n         // binder is moved below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n@@ -2147,8 +2146,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to confirm default implementation for ambiguous type: {}\",\n-                        self_ty.repr()));\n+                        \"asked to confirm default implementation for ambiguous type: {:?}\",\n+                        self_ty));\n             }\n         }\n     }\n@@ -2158,9 +2157,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              trait_def_id: ast::DefId)\n                                              -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_default_impl_object_candidate({}, {})\",\n-               obligation.repr(),\n-               trait_def_id.repr());\n+        debug!(\"confirm_default_impl_object_candidate({:?}, {:?})\",\n+               obligation,\n+               trait_def_id);\n \n         assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n \n@@ -2186,8 +2185,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to confirm default object implementation for non-object type: {}\",\n-                        self_ty.repr()));\n+                        \"asked to confirm default object implementation for non-object type: {:?}\",\n+                        self_ty));\n             }\n         }\n     }\n@@ -2199,7 +2198,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"vtable_default_impl_data: nested={}\", nested.repr());\n+        debug!(\"vtable_default_impl_data: nested={:?}\", nested);\n \n         let mut obligations = self.collect_predicates_for_types(obligation,\n                                                                 trait_def_id,\n@@ -2220,7 +2219,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // no Errors in that code above\n         obligations.append(&mut trait_obligations.unwrap());\n \n-        debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr());\n+        debug!(\"vtable_default_impl_data: obligations={:?}\", obligations);\n \n         VtableDefaultImplData {\n             trait_def_id: trait_def_id,\n@@ -2234,17 +2233,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                               -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n                                         SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_impl_candidate({},{})\",\n-               obligation.repr(),\n-               impl_def_id.repr());\n+        debug!(\"confirm_impl_candidate({:?},{:?})\",\n+               obligation,\n+               impl_def_id);\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         self.infcx.commit_if_ok(|snapshot| {\n             let (substs, skol_map) =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n-            debug!(\"confirm_impl_candidate substs={}\", substs.repr());\n+            debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n@@ -2259,11 +2258,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n-        debug!(\"vtable_impl(impl_def_id={}, substs={}, recursion_depth={}, skol_map={})\",\n-               impl_def_id.repr(),\n-               substs.repr(),\n+        debug!(\"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, skol_map={:?})\",\n+               impl_def_id,\n+               substs,\n                recursion_depth,\n-               skol_map.repr());\n+               skol_map);\n \n         let mut impl_obligations =\n             self.impl_or_trait_obligations(cause,\n@@ -2273,9 +2272,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            skol_map,\n                                            snapshot);\n \n-        debug!(\"vtable_impl: impl_def_id={} impl_obligations={}\",\n-               impl_def_id.repr(),\n-               impl_obligations.repr());\n+        debug!(\"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n+               impl_def_id,\n+               impl_obligations);\n \n         impl_obligations.append(&mut substs.obligations);\n \n@@ -2288,8 +2287,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 obligation: &TraitObligation<'tcx>)\n                                 -> VtableObjectData<'tcx>\n     {\n-        debug!(\"confirm_object_candidate({})\",\n-               obligation.repr());\n+        debug!(\"confirm_object_candidate({:?})\",\n+               obligation);\n \n         // FIXME skipping binder here seems wrong -- we should\n         // probably flatten the binder from the obligation and the\n@@ -2330,8 +2329,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     obligation: &TraitObligation<'tcx>)\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_fn_pointer_candidate({})\",\n-               obligation.repr());\n+        debug!(\"confirm_fn_pointer_candidate({:?})\",\n+               obligation);\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n@@ -2357,20 +2356,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_closure_candidate({},{},{})\",\n-               obligation.repr(),\n-               closure_def_id.repr(),\n-               substs.repr());\n+        debug!(\"confirm_closure_candidate({:?},{:?},{:?})\",\n+               obligation,\n+               closure_def_id,\n+               substs);\n \n         let Normalized {\n             value: trait_ref,\n             obligations\n         } = self.closure_trait_ref(obligation, closure_def_id, substs);\n \n-        debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={}, obligations={})\",\n-               closure_def_id.repr(),\n-               trait_ref.repr(),\n-               obligations.repr());\n+        debug!(\"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n+               closure_def_id,\n+               trait_ref,\n+               obligations);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -2438,8 +2437,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::no_late_bound_regions(tcx, &obligation.self_ty()).unwrap());\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n-        debug!(\"confirm_builtin_unsize_candidate(source={}, target={})\",\n-               source.repr(), target.repr());\n+        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n+               source, target);\n \n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n@@ -2615,9 +2614,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok((substs, skol_map)) => (substs, skol_map),\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    &format!(\"Impl {} was matchable against {} but now is not\",\n-                            impl_def_id.repr(),\n-                            obligation.repr()));\n+                    &format!(\"Impl {:?} was matchable against {:?} but now is not\",\n+                            impl_def_id,\n+                            obligation));\n             }\n         }\n     }\n@@ -2656,12 +2655,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation.recursion_depth + 1,\n                                           &impl_trait_ref);\n \n-        debug!(\"match_impl(impl_def_id={}, obligation={}, \\\n-               impl_trait_ref={}, skol_obligation_trait_ref={})\",\n-               impl_def_id.repr(),\n-               obligation.repr(),\n-               impl_trait_ref.repr(),\n-               skol_obligation_trait_ref.repr());\n+        debug!(\"match_impl(impl_def_id={:?}, obligation={:?}, \\\n+               impl_trait_ref={:?}, skol_obligation_trait_ref={:?})\",\n+               impl_def_id,\n+               obligation,\n+               impl_trait_ref,\n+               skol_obligation_trait_ref);\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         if let Err(e) = self.infcx.sub_trait_refs(false,\n@@ -2677,7 +2676,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        debug!(\"match_impl: success impl_substs={}\", impl_substs.repr());\n+        debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n         Ok((Normalized {\n             value: impl_substs,\n             obligations: impl_trait_ref.obligations\n@@ -2728,9 +2727,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n     {\n-        debug!(\"match_poly_trait_ref: obligation={} poly_trait_ref={}\",\n-               obligation.repr(),\n-               poly_trait_ref.repr());\n+        debug!(\"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n+               obligation,\n+               poly_trait_ref);\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n@@ -2769,15 +2768,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n         let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n \n-        debug!(\"match_impl_self_types(obligation_self_ty={}, impl_self_ty={})\",\n-               obligation_self_ty.repr(),\n-               impl_self_ty.repr());\n+        debug!(\"match_impl_self_types(obligation_self_ty={:?}, impl_self_ty={:?})\",\n+               obligation_self_ty,\n+               impl_self_ty);\n \n         match self.match_self_types(obligation_cause,\n                                     impl_self_ty,\n                                     obligation_self_ty) {\n             Ok(()) => {\n-                debug!(\"Matched impl_substs={}\", impl_substs.repr());\n+                debug!(\"Matched impl_substs={:?}\", impl_substs);\n                 Ok(impl_substs)\n             }\n             Err(()) => {\n@@ -2889,7 +2888,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n-        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr());\n+        debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n \n         let predicates = ty::lookup_predicates(self.tcx(), def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n@@ -2939,9 +2938,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn upcast(&mut self, obj_trait_ref: ty::PolyTraitRef<'tcx>, obligation: &TraitObligation<'tcx>)\n               -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n-        debug!(\"upcast(obj_trait_ref={}, obligation={})\",\n-               obj_trait_ref.repr(),\n-               obligation.repr());\n+        debug!(\"upcast(obj_trait_ref={:?}, obligation={:?})\",\n+               obj_trait_ref,\n+               obligation);\n \n         let obligation_def_id = obligation.predicate.def_id();\n         let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n@@ -2957,7 +2956,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n         });\n \n-        debug!(\"upcast: upcast_trait_refs={}\", upcast_trait_refs.repr());\n+        debug!(\"upcast: upcast_trait_refs={:?}\", upcast_trait_refs);\n         upcast_trait_refs\n     }\n }"}, {"sha": "6fb085c8838d7bba4dede0df9c96ef0dd86f4d90", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n-use util::ppaux::Repr;\n \n use super::{Obligation, ObligationCause, PredicateObligation,\n             VtableImpl, VtableParam, VtableImplData, VtableDefaultImplData};\n@@ -125,8 +124,8 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                               .map(|p| p.subst_supertrait(self.tcx, &data.to_poly_trait_ref()))\n                               .collect();\n \n-                debug!(\"super_predicates: data={} predicates={}\",\n-                       data.repr(), predicates.repr());\n+                debug!(\"super_predicates: data={:?} predicates={:?}\",\n+                       data, predicates);\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n@@ -314,8 +313,8 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> Vec<PredicateObligation<'tcx>>\n {\n-    debug!(\"predicates_for_generics(generic_bounds={})\",\n-           generic_bounds.repr());\n+    debug!(\"predicates_for_generics(generic_bounds={:?})\",\n+           generic_bounds);\n \n     generic_bounds.predicates.iter().map(|predicate| {\n         Obligation { cause: cause.clone(),"}, {"sha": "e82754680a5e967fc633a37ccdf29fe2217fbc16", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -66,7 +66,6 @@ use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::{self, TypeWalker};\n-use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n@@ -2848,8 +2847,8 @@ impl<'tcx> TraitDef<'tcx> {\n                        tcx: &ctxt<'tcx>,\n                        impl_def_id: DefId,\n                        impl_trait_ref: TraitRef<'tcx>) {\n-        debug!(\"TraitDef::record_impl for {}, from {}\",\n-               self.repr(), impl_trait_ref.repr());\n+        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n+               self, impl_trait_ref);\n \n         // We don't want to borrow_mut after we already populated all impls,\n         // so check if an impl is present with an immutable borrow first.\n@@ -3773,7 +3772,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         TyArray(ty, _) | TySlice(ty) => ty,\n         TyStr => mk_mach_uint(cx, ast::TyU8),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                  ty.user_string())),\n+                                  ty)),\n     }\n }\n \n@@ -4242,8 +4241,8 @@ fn type_impls_bound<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'tcx>>,\n \n     let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n-    debug!(\"type_impls_bound({}, {:?}) = {:?}\",\n-           ty.repr(),\n+    debug!(\"type_impls_bound({:?}, {:?}) = {:?}\",\n+           ty,\n            bound,\n            is_impld);\n \n@@ -4344,20 +4343,20 @@ pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n     fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                            r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-        debug!(\"type_requires({}, {})?\",\n-               r_ty.repr(), ty.repr());\n+        debug!(\"type_requires({:?}, {:?})?\",\n+               r_ty, ty);\n \n         let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n \n-        debug!(\"type_requires({}, {})? {:?}\",\n-               r_ty.repr(), ty.repr(), r);\n+        debug!(\"type_requires({:?}, {:?})? {:?}\",\n+               r_ty, ty, r);\n         return r;\n     }\n \n     fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                               r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-        debug!(\"subtypes_require({}, {})?\",\n-               r_ty.repr(), ty.repr());\n+        debug!(\"subtypes_require({:?}, {:?})?\",\n+               r_ty, ty);\n \n         let r = match ty.sty {\n             // fixed length vectors need special treatment compared to\n@@ -4435,8 +4434,8 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             }\n         };\n \n-        debug!(\"subtypes_require({}, {})? {:?}\",\n-               r_ty.repr(), ty.repr(), r);\n+        debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n+               r_ty, ty, r);\n \n         return r;\n     }\n@@ -4542,7 +4541,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n                                             seen: &mut Vec<Ty<'tcx>>,\n                                             ty: Ty<'tcx>) -> Representability {\n-        debug!(\"is_type_structurally_recursive: {}\", ty.repr());\n+        debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n         match ty.sty {\n             TyStruct(did, _) | TyEnum(did, _) => {\n@@ -4561,9 +4560,9 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                     match iter.next() {\n                         Some(&seen_type) => {\n                             if same_struct_or_enum_def_id(seen_type, did) {\n-                                debug!(\"SelfRecursive: {} contains {}\",\n-                                       seen_type.repr(),\n-                                       ty.repr());\n+                                debug!(\"SelfRecursive: {:?} contains {:?}\",\n+                                       seen_type,\n+                                       ty);\n                                 return SelfRecursive;\n                             }\n                         }\n@@ -4581,9 +4580,9 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                     for &seen_type in iter {\n                         if same_type(ty, seen_type) {\n-                            debug!(\"ContainsRecursive: {} contains {}\",\n-                                   seen_type.repr(),\n-                                   ty.repr());\n+                            debug!(\"ContainsRecursive: {:?} contains {:?}\",\n+                                   seen_type,\n+                                   ty);\n                             return ContainsRecursive;\n                         }\n                     }\n@@ -4603,14 +4602,14 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n         }\n     }\n \n-    debug!(\"is_type_representable: {}\", ty.repr());\n+    debug!(\"is_type_representable: {:?}\", ty);\n \n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<Ty> = Vec::new();\n     let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n-    debug!(\"is_type_representable: {} is {:?}\", ty.repr(), r);\n+    debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n     r\n }\n \n@@ -5012,7 +5011,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         _ => {\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                          {}\", unadjusted_ty.repr()));\n+                                          {:?}\", unadjusted_ty));\n                         }\n                     }\n                 }\n@@ -5053,7 +5052,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                         span,\n                                         &format!(\"the {}th autoderef failed: {}\",\n                                                 i,\n-                                                 adjusted_ty.user_string())\n+                                                 adjusted_ty)\n                                         );\n                                 }\n                             }\n@@ -5298,8 +5297,8 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n     match ty.sty {\n         TyBool | TyChar | TyInt(_) |\n-        TyUint(_) | TyFloat(_) | TyStr => ty.user_string(),\n-        TyTuple(ref tys) if tys.is_empty() => ty.user_string(),\n+        TyUint(_) | TyFloat(_) | TyStr => ty.to_string(),\n+        TyTuple(ref tys) if tys.is_empty() => ty.to_string(),\n \n         TyEnum(id, _) => format!(\"enum `{}`\", item_path_str(cx, id)),\n         TyBox(_) => \"box\".to_string(),\n@@ -6067,7 +6066,7 @@ fn report_discrim_overflow(cx: &ctxt,\n     let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n     let computed_value = repr_type.disr_string(computed_value);\n     let prev_val = repr_type.disr_string(prev_val);\n-    let repr_type = repr_type.to_ty(cx).user_string();\n+    let repr_type = repr_type.to_ty(cx);\n     span_err!(cx.sess, variant_span, E0370,\n               \"enum discriminant overflowed on value after {}: {}; \\\n                set explicitly via {} = {} if that is desired outcome\",\n@@ -6560,8 +6559,8 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                                     -> Vec<ty::Region>\n {\n     debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-           erased_self_ty.repr(),\n-           predicates.repr());\n+           erased_self_ty,\n+           predicates);\n \n     assert!(!erased_self_ty.has_escaping_regions());\n \n@@ -6679,7 +6678,7 @@ pub fn populate_implementations_for_trait_if_necessary(tcx: &ctxt, trait_id: ast\n         return;\n     }\n \n-    debug!(\"populate_implementations_for_trait_if_necessary: searching for {}\", def.repr());\n+    debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n \n     if csearch::is_defaulted_trait(&tcx.sess.cstore, trait_id) {\n         record_trait_has_default_impl(tcx, trait_id);\n@@ -6988,7 +6987,7 @@ pub fn construct_free_substs<'a,'tcx>(\n                                   defs: &[TypeParameterDef<'tcx>]) {\n         for def in defs {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                   def.repr());\n+                   def);\n             let ty = ty::mk_param_from_def(tcx, def);\n             types.push(def.space, ty);\n        }\n@@ -7021,8 +7020,8 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n            free_id,\n-           free_substs.repr(),\n-           predicates.repr());\n+           free_substs,\n+           predicates);\n \n     //\n     // Finally, we have to normalize the bounds in the environment, in"}, {"sha": "63c46032479a4f775bd3fbcb088a868a700aef8e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -45,7 +45,6 @@ use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // Two generic traits\n@@ -844,13 +843,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n-                debug!(\"RegionFolder.fold_region({}) skipped bound region (current depth={})\",\n-                       r.repr(), self.current_depth);\n+                debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n+                       r, self.current_depth);\n                 r\n             }\n             _ => {\n-                debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n-                       r.repr(), self.current_depth);\n+                debug!(\"RegionFolder.fold_region({:?}) folding free region (current_depth={})\",\n+                       r, self.current_depth);\n                 (self.fld_r)(r, self.current_depth)\n             }\n         }\n@@ -889,7 +888,7 @@ pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n     where F : FnMut(ty::BoundRegion) -> ty::Region,\n           T : TypeFoldable<'tcx>,\n {\n-    debug!(\"replace_late_bound_regions({})\", value.repr());\n+    debug!(\"replace_late_bound_regions({:?})\", value);\n     let mut replacer = RegionReplacer::new(tcx, &mut f);\n     let result = value.skip_binder().fold_with(&mut replacer);\n     (result, replacer.map)\n@@ -918,8 +917,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n-                debug!(\"RegionReplacer.fold_region({}) folding region (current_depth={})\",\n-                       r.repr(), self.current_depth);\n+                debug!(\"RegionReplacer.fold_region({:?}) folding region (current_depth={})\",\n+                       r, self.current_depth);\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n                 if let ty::ReLateBound(debruijn1, br) = region {\n@@ -998,8 +997,8 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n \n pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>,\n                                                  amount: u32, value: &T) -> T {\n-    debug!(\"shift_regions(value={}, amount={})\",\n-           value.repr(), amount);\n+    debug!(\"shift_regions(value={:?}, amount={})\",\n+           value, amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n         shift_region(region, amount)"}, {"sha": "135118820a771fae4eada9a2be38175051916c9a", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -10,7 +10,6 @@\n \n use middle::ty::{self, Ty};\n use middle::ty_relate::{self, Relate, TypeRelation, RelateResult};\n-use util::ppaux::Repr;\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n /// substituted with values so as to make it equal to A. Matching is\n@@ -53,16 +52,16 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(),\n-               b.repr());\n+               a,\n+               b);\n         Ok(a)\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(), b.repr());\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n+               a, b);\n         if a == b { return Ok(a); }\n \n         match (&a.sty, &b.sty) {"}, {"sha": "b8c212fe3f20b1a33296890628c93c0dd895b5ed", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -19,7 +19,6 @@ use middle::ty_fold::TypeFoldable;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n-use util::ppaux::Repr;\n \n pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n \n@@ -79,10 +78,10 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n                  -> RelateResult<'tcx, ty::mt<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n-        debug!(\"{}.mts({}, {})\",\n+        debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n-               a.repr(),\n-               b.repr());\n+               a,\n+               b);\n         if a.mutbl != b.mutbl {\n             Err(ty::terr_mutability)\n         } else {\n@@ -107,10 +106,10 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n                                     -> RelateResult<'tcx, Substs<'tcx>>\n     where R: TypeRelation<'a,'tcx>\n {\n-    debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n-           item_def_id.repr(),\n-           a_subst.repr(),\n-           b_subst.repr());\n+    debug!(\"substs: item_def_id={:?} a_subst={:?} b_subst={:?}\",\n+           item_def_id,\n+           a_subst,\n+           b_subst);\n \n     let variances;\n     let opt_variances = if relation.tcx().variance_computed.get() {\n@@ -193,11 +192,11 @@ fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n {\n     let num_region_params = a_rs.len();\n \n-    debug!(\"relate_region_params(a_rs={}, \\\n-            b_rs={}, variances={})\",\n-           a_rs.repr(),\n-           b_rs.repr(),\n-           variances.repr());\n+    debug!(\"relate_region_params(a_rs={:?}, \\\n+            b_rs={:?}, variances={:?})\",\n+           a_rs,\n+           b_rs,\n+           variances);\n \n     assert_eq!(num_region_params,\n                variances.map_or(num_region_params,"}, {"sha": "485d856ac2508a914e3c2e65e5c2621a71c0d07c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,28 +28,6 @@ use syntax::abi;\n use syntax::parse::token;\n use syntax::{ast, ast_util};\n \n-/// Produces a string suitable for debugging output.\n-pub trait Repr {\n-    fn repr(&self) -> String;\n-}\n-\n-/// Produces a string suitable for showing to the user.\n-pub trait UserString {\n-    fn user_string(&self) -> String;\n-}\n-\n-impl<T: fmt::Debug> Repr for T {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<T: fmt::Display> UserString for T {\n-    fn user_string(&self) -> String {\n-        format!(\"{}\", *self)\n-    }\n-}\n-\n pub fn verbose() -> bool {\n     ty::tls::with(|tcx| tcx.sess.verbose())\n }\n@@ -146,7 +124,7 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions {\n                 try!(start_or_continue(f, \"<\", \", \"));\n-                let s = r.user_string();\n+                let s = r.to_string();\n                 if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n@@ -316,7 +294,7 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n         // Region, if not obviously implied by builtin bounds.\n         if bounds.region_bound != ty::ReStatic {\n             // Region bound is implied by builtin bounds:\n-            let bound = bounds.region_bound.user_string();\n+            let bound = bounds.region_bound.to_string();\n             if !bound.is_empty() {\n                 try!(write!(f, \" + {}\", bound));\n             }\n@@ -589,7 +567,7 @@ impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n             }\n         };\n \n-        let region_str = self.region_bound.repr();\n+        let region_str = format!(\"{:?}\", self.region_bound);\n         if !region_str.is_empty() {\n             try!(maybe_continue(f));\n             try!(write!(f, \"{}\", region_str));\n@@ -693,7 +671,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             }\n             TyRef(r, ref tm) => {\n                 try!(write!(f, \"&\"));\n-                let s = r.user_string();\n+                let s = r.to_string();\n                 try!(write!(f, \"{}\", s));\n                 if !s.is_empty() {\n                     try!(write!(f, \" \"));"}, {"sha": "49933441cf01ec4b1b76160e9ded6c7842b4d812", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -24,7 +24,6 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -97,8 +96,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n-               consume_id, cmt.repr(), mode);\n+        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n+               consume_id, cmt, mode);\n \n         self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n@@ -112,9 +111,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n-               consume_pat.repr(),\n-               cmt.repr(),\n+        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n+               consume_pat,\n+               cmt,\n                mode);\n \n         self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n@@ -128,9 +127,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n                bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt.repr(), loan_region,\n+               borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n         match opt_loan_path(&cmt) {\n@@ -153,8 +152,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n-               assignment_id, assignee_cmt.repr());\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n+               assignment_id, assignee_cmt);\n \n         match opt_loan_path(&assignee_cmt) {\n             Some(lp) => {\n@@ -384,9 +383,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n-        debug!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n-               old_loan.repr(),\n-               new_loan.repr());\n+        debug!(\"report_error_if_loans_conflict(old_loan={:?}, new_loan={:?})\",\n+               old_loan,\n+               new_loan);\n \n         // Should only be called for loans that are in scope at the same time.\n         assert!(self.tcx().region_maps.scopes_intersect(old_loan.kill_scope,\n@@ -408,9 +407,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n         debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n-                loan1={}, loan2={})\",\n-               loan1.repr(),\n-               loan2.repr());\n+                loan1={:?}, loan2={:?})\",\n+               loan1,\n+               loan2);\n \n         if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n             return true;\n@@ -672,9 +671,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError<'tcx> {\n-        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n+        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={:?})\",\n                self.tcx().map.node_to_string(expr_id),\n-               use_path.repr());\n+               use_path);\n \n         let mut ret = UseOk;\n \n@@ -698,8 +697,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={})\",\n-               id, use_kind, lp.repr());\n+        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={:?})\",\n+               id, use_kind, lp);\n \n         // FIXME (22079): if you find yourself tempted to cut and paste\n         // the body below and then specializing the error reporting,\n@@ -792,7 +791,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span: Span,\n                         assignee_cmt: mc::cmt<'tcx>,\n                         mode: euv::MutateMode) {\n-        debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr());\n+        debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n@@ -884,7 +883,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //! `used_mut_nodes` table here.\n \n             loop {\n-                debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr());\n+                debug!(\"mark_variable_as_used_mut(cmt={:?})\", cmt);\n                 match cmt.cat.clone() {\n                     mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: id, .. }, .. }) |\n                     mc::cat_local(id) => {\n@@ -929,8 +928,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n-            debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n-                   cmt.repr(), guarantor.repr());\n+            debug!(\"check_for_aliasable_mutable_writes(cmt={:?}, guarantor={:?})\",\n+                   cmt, guarantor);\n             if let mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) = guarantor.cat {\n                 // Statically prohibit writes to `&mut` when aliasable\n                 check_for_aliasability_violation(this, span, b.clone());"}, {"sha": "93f5ac529d3fd2032ddea1b425e00fc7f3dbc9b3", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -22,7 +22,7 @@ use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n use rustc::middle::ty;\n use rustc::middle::mem_categorization as mc;\n-use rustc::util::ppaux::{Repr, UserString};\n+\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n@@ -43,18 +43,18 @@ enum Fragment {\n \n impl Fragment {\n     fn loan_path_repr(&self, move_data: &MoveData) -> String {\n-        let repr = |mpi| move_data.path_loan_path(mpi).repr();\n+        let lp = |mpi| move_data.path_loan_path(mpi);\n         match *self {\n-            Just(mpi) => repr(mpi),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", repr(mpi)),\n+            Just(mpi) => format!(\"{:?}\", lp(mpi)),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {:?})\", lp(mpi)),\n         }\n     }\n \n     fn loan_path_user_string(&self, move_data: &MoveData) -> String {\n-        let user_string = |mpi| move_data.path_loan_path(mpi).user_string();\n+        let lp = |mpi| move_data.path_loan_path(mpi);\n         match *self {\n-            Just(mpi) => user_string(mpi),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", user_string(mpi)),\n+            Just(mpi) => lp(mpi).to_string(),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", lp(mpi)),\n         }\n     }\n }\n@@ -124,12 +124,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n \n     let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n         for (i, mpi) in vec_rc.iter().enumerate() {\n-            let render = || this.path_loan_path(*mpi).user_string();\n+            let lp = || this.path_loan_path(*mpi);\n             if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, lp()));\n             }\n             if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n+                println!(\"id:{} {}[{}] `{}`\", id, kind, i, lp());\n             }\n         }\n     };\n@@ -170,7 +170,7 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n \n     let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n-        mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr()).collect()\n+        mpis.iter().map(|mpi| format!(\"{:?}\", this.path_loan_path(*mpi))).collect()\n     };\n \n     let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n@@ -341,8 +341,8 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n-                    panic!(\"tuple type {} should not have named fields.\",\n-                           parent_ty.repr()),\n+                    panic!(\"tuple type {:?} should not have named fields.\",\n+                           parent_ty),\n             };\n             let tuple_len = v.len();\n             for i in 0..tuple_len {\n@@ -416,8 +416,8 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         ref sty_and_variant_info => {\n-            let msg = format!(\"type {} ({:?}) is not fragmentable\",\n-                              parent_ty.repr(), sty_and_variant_info);\n+            let msg = format!(\"type {:?} ({:?}) is not fragmentable\",\n+                              parent_ty, sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n             tcx.sess.opt_span_bug(opt_span, &msg[..])\n         }\n@@ -448,8 +448,8 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n     };\n     let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n     let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n-    debug!(\"add_fragment_sibling_core(new_lp={}, origin_lp={})\",\n-           new_lp.repr(), origin_lp.repr());\n+    debug!(\"add_fragment_sibling_core(new_lp={:?}, origin_lp={:?})\",\n+           new_lp, origin_lp);\n     let mp = this.move_path(tcx, Rc::new(new_lp));\n \n     // Do not worry about checking for duplicates here; we will sort"}, {"sha": "7b6c54dbaca44945fa2ba02cc411743836e34e4f", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n+\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -66,8 +66,8 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       cmt: mc::cmt<'tcx>,\n                                       mode: euv::MatchMode) {\n     let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={:?})\",\n-           move_pat.id, cmt.repr(), mode);\n+    debug!(\"gather_match_variant(move_pat={}, cmt={:?}, mode={:?})\",\n+           move_pat.id, cmt, mode);\n \n     let opt_lp = opt_loan_path(&cmt);\n     match opt_lp {\n@@ -115,14 +115,14 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n-    debug!(\"gather_move(move_id={}, cmt={})\",\n-           move_info.id, move_info.cmt.repr());\n+    debug!(\"gather_move(move_id={}, cmt={:?})\",\n+           move_info.id, move_info.cmt);\n \n     let potentially_illegal_move =\n                 check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n     match potentially_illegal_move {\n         Some(illegal_move_origin) => {\n-            debug!(\"illegal_move_origin={}\", illegal_move_origin.repr());\n+            debug!(\"illegal_move_origin={:?}\", illegal_move_origin);\n             let error = MoveError::with_move_info(illegal_move_origin,\n                                                   move_info.span_path_opt);\n             move_error_collector.add_error(error);"}, {"sha": "427d78e89b3e2dbe11a787298ac418e45c1f7d5d", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n+\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -33,8 +33,8 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     //! Reports error if `loan_region` is larger than S\n     //! where S is `item_scope` if `cmt` is an upvar,\n     //! and is scope of `cmt` otherwise.\n-    debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n-           cmt.repr(), loan_region.repr());\n+    debug!(\"guarantee_lifetime(cmt={:?}, loan_region={:?})\",\n+           cmt, loan_region);\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope: item_scope,\n                                          span: span,\n@@ -65,9 +65,9 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! Main routine. Walks down `cmt` until we find the\n         //! \"guarantor\".  Reports an error if `self.loan_region` is\n         //! larger than scope of `cmt`.\n-        debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n-               cmt.repr(),\n-               self.loan_region.repr());\n+        debug!(\"guarantee_lifetime.check(cmt={:?}, loan_region={:?})\",\n+               cmt,\n+               self.loan_region);\n \n         match cmt.cat {\n             mc::cat_rvalue(..) |"}, {"sha": "f00eb872642f4e5173c447878e7f23caf7b108d2", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n+\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -76,8 +76,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                _consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n-               consume_id, cmt.repr(), mode);\n+        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n+               consume_id, cmt, mode);\n \n         match mode {\n             euv::Move(move_reason) => {\n@@ -93,9 +93,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    matched_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::MatchMode) {\n-        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={:?})\",\n-               matched_pat.repr(),\n-               cmt.repr(),\n+        debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n+               matched_pat,\n+               cmt,\n                mode);\n \n         if let mc::cat_downcast(..) = cmt.cat {\n@@ -109,9 +109,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n-               consume_pat.repr(),\n-               cmt.repr(),\n+        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n+               consume_pat,\n+               cmt,\n                mode);\n \n         match mode {\n@@ -132,9 +132,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n                bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt.repr(), loan_region,\n+               borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n         self.guarantee_valid(borrow_id,\n@@ -152,8 +152,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               mode: euv::MutateMode)\n     {\n         let opt_lp = opt_loan_path(&assignee_cmt);\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={}) opt_lp={:?}\",\n-               assignment_id, assignee_cmt.repr(), opt_lp);\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={:?}) opt_lp={:?}\",\n+               assignment_id, assignee_cmt, opt_lp);\n \n         match opt_lp {\n             Some(lp) => {\n@@ -234,10 +234,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region,\n                        cause: euv::LoanCause) {\n-        debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n+        debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n-               cmt.repr(),\n+               cmt,\n                req_kind,\n                loan_region);\n \n@@ -336,8 +336,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={}), loan={}\",\n-               borrow_id, loan.repr());\n+        debug!(\"guarantee_valid(borrow_id={}), loan={:?}\",\n+               borrow_id, loan);\n \n         // let loan_path = loan.loan_path;\n         // let loan_gen_scope = loan.gen_scope;\n@@ -376,8 +376,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n             //! Implements the M-* rules in README.md.\n-            debug!(\"check_mutability(cause={:?} cmt={} req_kind={:?}\",\n-                   cause, cmt.repr(), req_kind);\n+            debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n+                   cause, cmt, req_kind);\n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {\n                     match cmt.mutbl {\n@@ -507,7 +507,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n \n pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n \n-    debug!(\"gather_loans_in_static_initializer(expr={})\", expr.repr());\n+    debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx"}, {"sha": "9a29ed91339e2468646da1c59d408dc1b7b35870", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -12,7 +12,6 @@ use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n-use rustc::util::ppaux::UserString;\n use std::cell::RefCell;\n use syntax::ast;\n use syntax::codemap;\n@@ -130,7 +129,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 bccx.span_err(move_from.span,\n                               &format!(\"cannot move out of type `{}`, \\\n                                         a non-copy fixed-size array\",\n-                                       b.ty.user_string()));\n+                                       b.ty));\n             }\n         }\n \n@@ -143,7 +142,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string()));\n+                                b.ty));\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")"}, {"sha": "345f5378f69e106c0fd3142f66d31f94229f3de1", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use borrowck::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n use syntax::codemap::Span;\n \n use borrowck::ToInteriorKind;\n@@ -58,7 +57,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n                 cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n-        debug!(\"restrict(cmt={})\", cmt.repr());\n+        debug!(\"restrict(cmt={:?})\", cmt);\n \n         let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n "}, {"sha": "6369621779cbd5ed3e99eb557328e1c9ff8de881", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -33,7 +33,6 @@ use rustc::middle::infer::error_reporting::note_and_explain_region;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n-use rustc::util::ppaux::{Repr, UserString};\n \n use std::fmt;\n use std::mem;\n@@ -683,15 +682,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                   which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n-                                 expr_ty.user_string(),\n+                                 expr_ty,\n                                  suggestion));\n                 } else {\n                     self.tcx.sess.span_note(\n                         expr_span,\n                         &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n-                                 expr_ty.user_string(),\n+                                 expr_ty,\n                                  suggestion));\n                 }\n             }\n@@ -704,7 +703,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string()));\n+                            pat_ty));\n                 self.tcx.sess.fileline_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -735,7 +734,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n-                            expr_ty.user_string(),\n+                            expr_ty,\n                             suggestion));\n                 self.tcx.sess.fileline_help(expr_span, help);\n             }\n@@ -1187,7 +1186,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n                     ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n                 } else {\n-                    variant_def_id.repr()\n+                    format!(\"{:?}\", variant_def_id)\n                 };\n                 write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n@@ -1219,7 +1218,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n                     ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n                 } else {\n-                    variant_def_id.repr()\n+                    format!(\"{:?}\", variant_def_id)\n                 };\n                 write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }"}, {"sha": "b38915612c5b0c453d83b30148a024e473acd553", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::ty;\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n-use rustc::util::ppaux::Repr;\n+\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n@@ -313,8 +313,8 @@ impl<'tcx> MoveData<'tcx> {\n             }\n         };\n \n-        debug!(\"move_path(lp={}, index={:?})\",\n-               lp.repr(),\n+        debug!(\"move_path(lp={:?}, index={:?})\",\n+               lp,\n                index);\n \n         assert_eq!(index.get(), self.paths.borrow().len() - 1);\n@@ -364,8 +364,8 @@ impl<'tcx> MoveData<'tcx> {\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n-        debug!(\"add_move(lp={}, id={}, kind={:?})\",\n-               lp.repr(),\n+        debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n+               lp,\n                id,\n                kind);\n \n@@ -394,8 +394,8 @@ impl<'tcx> MoveData<'tcx> {\n                           span: Span,\n                           assignee_id: ast::NodeId,\n                           mode: euv::MutateMode) {\n-        debug!(\"add_assignment(lp={}, assign_id={}, assignee_id={}\",\n-               lp.repr(), assign_id, assignee_id);\n+        debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n+               lp, assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n@@ -415,13 +415,13 @@ impl<'tcx> MoveData<'tcx> {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n-                   lp.repr(), self.var_assignments.borrow().len(), path_index);\n+            debug!(\"add_assignment[var](lp={:?}, assignment={}, path_index={:?})\",\n+                   lp, self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n-                   lp.repr(), path_index);\n+            debug!(\"add_assignment[path](lp={:?}, path_index={:?})\",\n+                   lp, path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);\n         }\n@@ -437,8 +437,8 @@ impl<'tcx> MoveData<'tcx> {\n                              pattern_id: ast::NodeId,\n                              base_lp: Rc<LoanPath<'tcx>>,\n                              mode: euv::MatchMode) {\n-        debug!(\"add_variant_match(lp={}, pattern_id={})\",\n-               lp.repr(), pattern_id);\n+        debug!(\"add_variant_match(lp={:?}, pattern_id={})\",\n+               lp, pattern_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n         let base_path_index = self.move_path(tcx, base_lp.clone());"}, {"sha": "a40cb94204d9c82b34fb14eff8b409adf69d4bac", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -25,7 +25,6 @@ use rustc::middle::cfg;\n use rustc::middle::cfg::graphviz::LabelledCFG;\n use rustc::session::Session;\n use rustc::session::config::Input;\n-use rustc::util::ppaux::UserString;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n@@ -318,7 +317,7 @@ impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              &ty::expr_ty(self.tcx, expr).user_string()));\n+                              &ty::expr_ty(self.tcx, expr).to_string()));\n                 s.pclose()\n             }\n             _ => Ok(())"}, {"sha": "5183fa01a8ac414425809ab051b0033969d2b51a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n-use rustc_typeck::util::ppaux::{Repr, UserString};\n use rustc::ast_map;\n use rustc::session::{self,config};\n use syntax::{abi, ast};\n@@ -188,7 +187,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.items {\n-                if item.ident.user_string() == names[idx] {\n+                if item.ident.to_string() == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }\n@@ -240,9 +239,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         if !self.is_subtype(a, b) {\n-            panic!(\"{} is not a subtype of {}, but it should be\",\n-                  self.ty_to_string(a),\n-                  self.ty_to_string(b));\n+            panic!(\"{} is not a subtype of {}, but it should be\", a, b);\n         }\n     }\n \n@@ -251,10 +248,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_string(&self, a: Ty<'tcx>) -> String {\n-         a.user_string()\n-    }\n-\n     pub fn t_fn(&self,\n                 input_tys: &[Ty<'tcx>],\n                 output_ty: Ty<'tcx>)\n@@ -385,9 +378,9 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         match self.sub().relate(&t1, &t2) {\n             Ok(_) => { }\n             Err(ref e) => {\n-                panic!(\"unexpected error computing sub({},{}): {}\",\n-                       t1.repr(),\n-                       t2.repr(),\n+                panic!(\"unexpected error computing sub({:?},{:?}): {}\",\n+                       t1,\n+                       t2,\n                        e);\n             }\n         }\n@@ -399,9 +392,9 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         match self.sub().relate(&t1, &t2) {\n             Err(_) => { }\n             Ok(_) => {\n-                panic!(\"unexpected success computing sub({},{})\",\n-                       t1.repr(),\n-                       t2.repr());\n+                panic!(\"unexpected success computing sub({:?},{:?})\",\n+                       t1,\n+                       t2);\n             }\n         }\n     }\n@@ -420,10 +413,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n-        debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n-               self.ty_to_string(t1),\n-               self.ty_to_string(t2),\n-               self.ty_to_string(t_glb));\n+        debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n         match self.glb().relate(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n@@ -656,7 +646,7 @@ fn glb_bound_free_infer() {\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n             ty::TyRef(..) => { }\n-            _ => { panic!(\"t_resolve1={}\", t_resolve1.repr()); }\n+            _ => { panic!(\"t_resolve1={:?}\", t_resolve1); }\n         }\n     })\n }\n@@ -698,11 +688,11 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(),\n-               substs.repr(),\n-               t_substituted.repr(),\n-               t_expected.repr());\n+        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+               t_source,\n+               substs,\n+               t_substituted,\n+               t_expected);\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -735,11 +725,11 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n         };\n \n-        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(),\n-               substs.repr(),\n-               t_substituted.repr(),\n-               t_expected.repr());\n+        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+               t_source,\n+               substs,\n+               t_substituted,\n+               t_expected);\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -796,11 +786,11 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[t_rptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(),\n-               substs.repr(),\n-               t_substituted.repr(),\n-               t_expected.repr());\n+        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+               t_source,\n+               substs,\n+               t_substituted,\n+               t_expected);\n \n         assert_eq!(t_substituted, t_expected);\n     })"}, {"sha": "47713859dd8cbda4196051f0ecb7d8f9c66956b2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -37,7 +37,6 @@ use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n use middle::cfg;\n use rustc::ast_map;\n use util::nodemap::{FnvHashMap, NodeSet};\n-use util::ppaux::UserString;\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n use std::collections::{HashSet, BitSet};\n@@ -495,8 +494,7 @@ impl BoxPointers {\n         });\n \n         if n_uniq > 0 {\n-            let s =  ty.user_string();\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n             cx.span_lint(BOX_POINTERS, span, &m[..]);\n         }\n     }"}, {"sha": "f6f9afa02215a9a35b494a60e2ae691ce98bf3be", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{self, Ty};\n use rustc::ast_map::{PathElem, PathElems, PathName};\n use trans::{CrateContext, CrateTranslation, gensym_name};\n use util::common::time;\n-use util::ppaux::UserString;\n use util::sha2::{Digest, Sha256};\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc_back::tempdir::TempDir;\n@@ -347,7 +346,7 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n-    let path = [PathName(token::intern(&t.user_string())),\n+    let path = [PathName(token::intern(&t.to_string())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(path.iter().cloned(), Some(&hash[..]))"}, {"sha": "65d9d9809c926ce8ef1afc98512bb79d70470089", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -52,8 +52,6 @@ use syntax::ptr::P;\n use super::span_utils::SpanUtils;\n use super::recorder::{Recorder, FmtStrs};\n \n-use util::ppaux::UserString;\n-\n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n@@ -287,7 +285,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, _, _) in &collector.collected_paths {\n-                let typ = self.tcx.node_types().get(&id).unwrap().user_string();\n+                let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -1392,7 +1390,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 \"<mutable>\".to_string()\n             };\n             let types = self.tcx.node_types();\n-            let typ = types.get(&id).unwrap().user_string();\n+            let typ = types.get(&id).unwrap().to_string();\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "fdfb101ed78cc4be6485a13a7caa40a30869469d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -23,8 +23,6 @@ use syntax::parse::token::{self, get_ident, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n-use util::ppaux::UserString;\n-\n use self::span_utils::SpanUtils;\n \n \n@@ -293,7 +291,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                        self.tcx.map.path_to_string(parent),\n                                        name);\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n-                                               .user_string();\n+                                               .to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 Some(Data::VariableData(VariableData {\n                     id: field.node.id,"}, {"sha": "05672153b018a5899f3d0b2860d0def701860a1f", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -217,7 +217,7 @@ use middle::ty::{self, Ty};\n use session::config::{NoDebugInfo, FullDebugInfo};\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::{self, Repr};\n+use util::ppaux;\n \n use std;\n use std::cmp::Ordering;\n@@ -398,9 +398,9 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               col: usize,\n                                               val: ValueRef)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(),\n+           m,\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -438,9 +438,9 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n     F: FnMut(&[&'p ast::Pat]) -> Option<Vec<&'p ast::Pat>>,\n {\n-    debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(),\n+           m,\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -481,9 +481,9 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      col: usize,\n                                      val: ValueRef)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(),\n+           m,\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -538,9 +538,9 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: usize,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(),\n+           m,\n            *opt,\n            col,\n            bcx.val_to_string(val));\n@@ -826,8 +826,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n-                           &format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t)),\n+                           &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n         let t = ty::mk_str_slice(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ast::MutImmutable);\n         // The comparison function gets the slices by value, so we have to make copies here. Even\n@@ -938,10 +937,10 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n-    debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals=[{}])\",\n+    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n-           bcx.expr_to_string(guard_expr),\n-           m.repr(),\n+           guard_expr,\n+           m,\n            vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n \n@@ -984,9 +983,9 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         vals: &[ValueRef],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n-    debug!(\"compile_submatch(bcx={}, m={}, vals=[{}])\",\n+    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n-           m.repr(),\n+           m,\n            vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n@@ -1697,13 +1696,13 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: ValueRef,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={})\",\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?})\",\n            bcx.to_str(),\n-           pat.repr());\n+           pat);\n \n     if bcx.sess().asm_comments() {\n-        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr()));\n+        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={:?})\",\n+                                 pat));\n     }\n \n     let _indenter = indenter();"}, {"sha": "2a1c2457b9d32d5a6d7d287a07710698809ae5a8", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -66,7 +66,6 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use util::ppaux::Repr as PrettyPrintRepr;\n \n type Hint = attr::ReprAttr;\n \n@@ -143,7 +142,7 @@ pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 t: Ty<'tcx>)\n                                 -> Rc<Repr<'tcx>> {\n-    debug!(\"Representing: {}\", t.repr());\n+    debug!(\"Representing: {}\", t);\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n@@ -381,8 +380,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             General(ity, fields, dtor_to_init_u8(dtor))\n         }\n-        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           t.repr()))\n+        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\", t))\n     }\n }\n "}, {"sha": "eb0d19efef00a25de7309bf98cf5e6d05ceb1234", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -80,7 +80,6 @@ use trans::type_of;\n use trans::type_of::*;\n use trans::value::Value;\n use util::common::indenter;\n-use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n@@ -250,9 +249,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n-            bcx.sess().fatal(&format!(\"allocation of `{}` {}\",\n-                                     bcx.ty_to_string(info_ty),\n-                                     s));\n+            bcx.sess().fatal(&format!(\"allocation of `{}` {}\", info_ty, s));\n         }\n     }\n }\n@@ -530,8 +527,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           }\n       }\n       _ => {\n-          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n-                                    t.repr()))\n+          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\", t))\n       }\n     }\n     return cx;\n@@ -640,8 +636,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             (res, false)\n         }\n         _ => {\n-            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n-                                   rhs_t.repr()));\n+            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\", rhs_t));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1187,13 +1182,13 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              -> FunctionContext<'a, 'tcx> {\n     common::validate_substs(param_substs);\n \n-    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n+    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={:?})\",\n            if id == !0 {\n                \"\".to_string()\n            } else {\n                ccx.tcx().map.path_to_string(id).to_string()\n            },\n-           id, param_substs.repr());\n+           id, param_substs);\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n@@ -1510,8 +1505,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n \n-    debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.repr());\n+    debug!(\"trans_closure(..., param_substs={:?})\",\n+           param_substs);\n \n     let has_env = match closure_env {\n         closure::ClosureEnv::Closure(_) => true,\n@@ -1553,8 +1548,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n     for monomorphized_arg_type in &monomorphized_arg_types {\n-        debug!(\"trans_closure: monomorphized_arg_type: {}\",\n-               monomorphized_arg_type.repr());\n+        debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n+               monomorphized_arg_type);\n     }\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n@@ -1636,7 +1631,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           id: ast::NodeId,\n                           attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n-    debug!(\"trans_fn(param_substs={})\", param_substs.repr());\n+    debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n     let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n@@ -1679,7 +1674,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr()))\n+                     ctor_ty))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -1757,7 +1752,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ctor_ty.repr()))\n+                    ctor_ty))\n     };\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "46f762a5195851877ab1ae8bcf55545d544780a1", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -54,7 +54,6 @@ use trans::type_of;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use rustc::ast_map;\n-use util::ppaux::Repr;\n \n use syntax::abi as synabi;\n use syntax::ast;\n@@ -89,7 +88,7 @@ pub struct Callee<'blk, 'tcx: 'blk> {\n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                      -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr={})\", expr.repr());\n+    debug!(\"callee::trans(expr={:?})\", expr);\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n@@ -117,7 +116,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n                     &format!(\"type of callee is neither bare-fn nor closure: {}\",\n-                             bcx.ty_to_string(datum.ty)));\n+                             datum.ty));\n             }\n         }\n     }\n@@ -134,7 +133,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                              def: def::Def,\n                              ref_expr: &ast::Expr)\n                              -> Callee<'blk, 'tcx> {\n-        debug!(\"trans_def(def={}, ref_expr={})\", def.repr(), ref_expr.repr());\n+        debug!(\"trans_def(def={:?}, ref_expr={:?})\", def, ref_expr);\n         let expr_ty = common::node_id_type(bcx, ref_expr.id);\n         match def {\n             def::DefFn(did, _) if {\n@@ -228,10 +227,10 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = common::node_id_substs(ccx, node, param_substs);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n-           def_id.repr(),\n+    debug!(\"trans_fn_ref(def_id={:?}, node={:?}, substs={:?})\",\n+           def_id,\n            node,\n-           substs.repr());\n+           substs);\n     trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n }\n \n@@ -291,8 +290,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         None => { }\n     }\n \n-    debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n-           bare_fn_ty.repr());\n+    debug!(\"trans_fn_pointer_shim(bare_fn_ty={:?})\",\n+           bare_fn_ty);\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n@@ -307,7 +306,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr()));\n+                                      bare_fn_ty));\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);\n@@ -323,7 +322,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                              output: sig.output,\n                                              variadic: false\n                                          })}));\n-    debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr());\n+    debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n@@ -401,12 +400,12 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={}, node={:?}, \\\n-            param_substs={}, substs={})\",\n-           def_id.repr(),\n+    debug!(\"trans_fn_ref_with_substs(def_id={:?}, node={:?}, \\\n+            param_substs={:?}, substs={:?})\",\n+           def_id,\n            node,\n-           param_substs.repr(),\n-           substs.repr());\n+           param_substs,\n+           substs);\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n     assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n@@ -457,10 +456,10 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                     let new_substs = tcx.mk_substs(first_subst.subst(tcx, &substs));\n \n                     debug!(\"trans_fn_with_vtables - default method: \\\n-                            substs = {}, trait_subst = {}, \\\n-                            first_subst = {}, new_subst = {}\",\n-                           substs.repr(), trait_ref.substs.repr(),\n-                           first_subst.repr(), new_substs.repr());\n+                            substs = {:?}, trait_subst = {:?}, \\\n+                            first_subst = {:?}, new_subst = {:?}\",\n+                           substs, trait_ref.substs,\n+                           first_subst, new_substs);\n \n                     (true, source_id, new_substs)\n                 }\n@@ -504,8 +503,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         false\n     };\n \n-    debug!(\"trans_fn_ref_with_substs({}) must_monomorphise: {}\",\n-           def_id.repr(), must_monomorphise);\n+    debug!(\"trans_fn_ref_with_substs({:?}) must_monomorphise: {}\",\n+           def_id, must_monomorphise);\n \n     // Create a monomorphic version of generic functions\n     if must_monomorphise {\n@@ -615,7 +614,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                          dest: expr::Dest)\n                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_expr={})\", call_expr.repr());\n+    debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n     let method_call = MethodCall::expr(call_expr.id);\n     let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n         Some(method) => match method.origin {\n@@ -1125,8 +1124,8 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_datum({})\",\n-           formal_arg_ty.repr());\n+    debug!(\"trans_arg_datum({:?})\",\n+           formal_arg_ty);\n \n     let arg_datum_ty = arg_datum.ty;\n \n@@ -1165,8 +1164,8 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n         debug!(\"casting actual type ({}) to match formal ({})\",\n                bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n-        debug!(\"Rust types: {}; {}\", arg_datum_ty.repr(),\n-                                     formal_arg_ty.repr());\n+        debug!(\"Rust types: {:?}; {:?}\", arg_datum_ty,\n+                                     formal_arg_ty);\n         val = PointerCast(bcx, val, llformal_arg_ty);\n     }\n "}, {"sha": "6355a713a2ce61b1898062f89b5fd57598d3a955", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -133,7 +133,6 @@ use trans::type_::Type;\n use middle::ty::{self, Ty};\n use std::fmt;\n use syntax::ast;\n-use util::ppaux::Repr;\n \n pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     // The id of this cleanup scope. If the id is None,\n@@ -397,10 +396,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -423,10 +422,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={}, fill_on_drop={}, skip_dtor={})\",\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?}, fill_on_drop={}, skip_dtor={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -455,10 +454,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -484,7 +483,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n "}, {"sha": "91b0a6c00696fb08998c15f402d869b3f603c481", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use trans::type_of::*;\n use middle::ty::{self, ClosureTyper};\n use middle::subst::Substs;\n use session::config::FullDebugInfo;\n-use util::ppaux::Repr;\n \n use syntax::abi::RustCall;\n use syntax::ast;\n@@ -353,9 +352,9 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     llreffn: ValueRef)\n     -> ValueRef\n {\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={}, substs={}, llreffn={})\",\n-           closure_def_id.repr(),\n-           substs.repr(),\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={})\",\n+           closure_def_id,\n+           substs,\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n@@ -374,8 +373,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                                                                abi: abi,\n                                                                sig: sig.clone() });\n     let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={}\",\n-           llref_fn_ty.repr());\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n+           llref_fn_ty);\n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n@@ -423,8 +422,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let input_tys = match sig.inputs[1].sty {\n         ty::TyTuple(ref tys) => &**tys,\n         _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n-                                      closure_def_id={}\",\n-                                     closure_def_id.repr()))\n+                                      closure_def_id={:?}\",\n+                                     closure_def_id))\n     };\n     let llargs: Vec<_> =\n         input_tys.iter()"}, {"sha": "5dddf161e69fbf802adf6622a01923356213f7f4", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -41,7 +41,6 @@ use middle::ty::{self, HasProjectionTypes, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rustc::ast_map::{PathElem, PathName};\n-use util::ppaux::Repr;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n@@ -67,8 +66,8 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx>\n {\n     let value1 = value.fold_with(&mut RegionEraser(cx));\n-    debug!(\"erase_regions({}) = {}\",\n-           value.repr(), value1.repr());\n+    debug!(\"erase_regions({:?}) = {:?}\",\n+           value, value1);\n     return value1;\n \n     struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n@@ -212,7 +211,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // destructor (e.g. zero its memory on move).\n \n     let contents = ty::type_contents(cx, ty);\n-    debug!(\"type_needs_drop ty={} contents={:?}\", ty.repr(), contents);\n+    debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n     contents.needs_drop(cx)\n }\n \n@@ -593,10 +592,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.tcx().map.node_to_string(id).to_string()\n     }\n \n-    pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n-        e.repr()\n-    }\n-\n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.full_def(),\n@@ -615,10 +610,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.ccx().tn().type_to_string(ty)\n     }\n \n-    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        t.repr()\n-    }\n-\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n@@ -994,14 +985,14 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // First check the cache.\n     match ccx.trait_cache().borrow().get(&trait_ref) {\n         Some(vtable) => {\n-            info!(\"Cache hit: {}\", trait_ref.repr());\n+            info!(\"Cache hit: {:?}\", trait_ref);\n             return (*vtable).clone();\n         }\n         None => { }\n     }\n \n-    debug!(\"trans fulfill_obligation: trait_ref={} def_id={:?}\",\n-           trait_ref.repr(), trait_ref.def_id());\n+    debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n+           trait_ref, trait_ref.def_id());\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n@@ -1022,19 +1013,19 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // leading to an ambiguous result. So report this as an\n             // overflow bug, since I believe this is the only case\n             // where ambiguity can result.\n-            debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n+            debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n                     presuming due to overflow\",\n-                   trait_ref.repr());\n+                   trait_ref);\n             ccx.sess().span_fatal(\n                 span,\n                 \"reached the recursion limit during monomorphization\");\n         }\n         Err(e) => {\n             tcx.sess.span_bug(\n                 span,\n-                &format!(\"Encountered error `{}` selecting `{}` during trans\",\n-                        e.repr(),\n-                        trait_ref.repr()))\n+                &format!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                        e,\n+                        trait_ref))\n         }\n     };\n \n@@ -1047,7 +1038,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     let vtable = drain_fulfillment_cx_or_panic(span, &infcx, &mut fulfill_cx, &vtable);\n \n-    info!(\"Cache miss: {}\", trait_ref.repr());\n+    info!(\"Cache miss: {:?}\", trait_ref);\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n                                           vtable.clone());\n \n@@ -1062,8 +1053,8 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                predicates: Vec<ty::Predicate<'tcx>>)\n                                                -> bool\n {\n-    debug!(\"normalize_and_test_predicates(predicates={})\",\n-           predicates.repr());\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n+           predicates);\n \n     let tcx = ccx.tcx();\n     let infcx = infer::new_infer_ctxt(tcx);\n@@ -1142,8 +1133,8 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n         Err(errors) => {\n             infcx.tcx.sess.span_bug(\n                 span,\n-                &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                         errors.repr()));\n+                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n+                         errors));\n         }\n     }\n }\n@@ -1161,8 +1152,8 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n                                        -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n-    debug!(\"drain_fulfillment_cx(result={})\",\n-           result.repr());\n+    debug!(\"drain_fulfillment_cx(result={:?})\",\n+           result);\n \n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n@@ -1210,7 +1201,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                                 node, substs.repr()));\n+                                 node, substs));\n         }\n \n         monomorphize::apply_param_substs(tcx,"}, {"sha": "ad6358e057367fbf270a65f8d5a580a4144717e8", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -32,7 +32,6 @@ use trans::type_of;\n use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n-use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use std::iter::repeat;\n@@ -66,9 +65,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n-                        &format!(\"integer literal has type {} (expected int \\\n+                        &format!(\"integer literal has type {:?} (expected int \\\n                                  or usize)\",\n-                                lit_int_ty.repr()))\n+                                lit_int_ty))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -160,8 +159,8 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         None => {\n-            cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                   ty.repr()))\n+            cx.sess().bug(&format!(\"unexpected dereferenceable type {:?}\",\n+                                   ty))\n         }\n     }\n }\n@@ -368,8 +367,8 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(), ety_adjusted.repr(),\n+        cx.sess().bug(&format!(\"const {:?} of type {:?} has size {} instead of {}\",\n+                         e, ety_adjusted,\n                          csize, tsize));\n     }\n     (llconst, ety_adjusted)\n@@ -476,10 +475,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    fn_args: FnArgMap)\n                                    -> ValueRef\n {\n-    debug!(\"const_expr_unadjusted(e={}, ety={}, param_substs={})\",\n-           e.repr(),\n-           ety.repr(),\n-           param_substs.repr());\n+    debug!(\"const_expr_unadjusted(e={:?}, ety={:?}, param_substs={:?})\",\n+           e,\n+           ety,\n+           param_substs);\n \n     let map_list = |exprs: &[P<ast::Expr>]| -> Vec<ValueRef> {\n         exprs.iter()\n@@ -496,9 +495,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n             let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n-            debug!(\"const_expr_unadjusted: te1={}, ty={}\",\n+            debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n-                   ty.repr());\n+                   ty);\n             let is_simd = ty::type_is_simd(cx.tcx(), ty);\n             let intype = if is_simd {\n                 ty::simd_type(cx.tcx(), ty)\n@@ -620,13 +619,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       },\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n-                                                       or string type, found {}\",\n-                                                      bt.repr()))\n+                                                       or string type, found {:?}\",\n+                                                      bt))\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           &format!(\"index-expr base must be a vector \\\n-                                                   or string type, found {}\",\n-                                                  bt.repr()))\n+                                                   or string type, found {:?}\",\n+                                                  bt))\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -654,7 +653,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n             let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n-            debug!(\"trans_const_cast({} as {})\", t_expr.repr(), t_cast.repr());\n+            debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n             }"}, {"sha": "0ae69682f914ac591276604014a3ec698dea5ebf", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use session::config::NoDebugInfo;\n use session::Session;\n-use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n@@ -766,8 +765,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n-            &format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr()))\n+            &format!(\"the type `{:?}` is too big for the current architecture\",\n+                    obj))\n     }\n \n     pub fn check_overflow(&self) -> bool {"}, {"sha": "ceef07207acb837f92a38ea58a66027d63156d4e", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -24,7 +24,6 @@ use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans;\n use middle::ty;\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::ast_util;\n@@ -36,14 +35,14 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt\");\n     let fcx = cx.fcx;\n-    debug!(\"trans_stmt({})\", s.repr());\n+    debug!(\"trans_stmt({:?})\", s);\n \n     if cx.unreachable.get() {\n         return cx;\n     }\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, &s.repr());\n+        add_span_comment(cx, s.span, &format!(\"{:?}\", s));\n     }\n \n     let mut bcx = cx;\n@@ -151,8 +150,8 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             els: Option<&ast::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={}, dest={})\",\n-           bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={})\",\n+           bcx.to_str(), if_id, cond, thn.id,\n            dest.to_string(bcx.ccx()));\n     let _icx = push_ctxt(\"trans_if\");\n "}, {"sha": "e60e4e4abe05336712dda9d90333015cb4a68833", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -102,7 +102,6 @@ use trans::expr;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use util::ppaux::Repr;\n \n use std::fmt;\n use syntax::ast;\n@@ -614,9 +613,9 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n \n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"Datum({}, {}, {:?})\",\n+        format!(\"Datum({}, {:?}, {:?})\",\n                 ccx.tn().val_to_string(self.val),\n-                self.ty.repr(),\n+                self.ty,\n                 self.kind)\n     }\n "}, {"sha": "7660f59e1d08b0061bd79a92b0164083f8354cbe", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -34,7 +34,6 @@ use trans::type_::Type;\n use middle::ty::{self, Ty, ClosureTyper};\n use session::config::{self, FullDebugInfo};\n use util::nodemap::FnvHashMap;\n-use util::ppaux::{Repr, UserString};\n use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n@@ -105,7 +104,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   type_.repr()));\n+                                   type_));\n         }\n     }\n \n@@ -297,8 +296,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                       type_.repr(), type_.sty))\n+                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n+                                       type_))\n             }\n         };\n \n@@ -488,8 +487,8 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n                         cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n-                                              '{}' was not found in TypeMap!\",\n-                                              unfinished_type.repr())\n+                                              '{:?}' was not found in TypeMap!\",\n+                                              unfinished_type)\n                                       );\n                     }\n                 }\n@@ -676,8 +675,8 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTrait(ref data) => data.principal_def_id(),\n         _ => {\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n-                                   trait_pointer_metadata(): {}\",\n-                                   trait_type.repr()));\n+                                   trait_pointer_metadata(): {:?}\",\n+                                   trait_type));\n         }\n     };\n \n@@ -839,7 +838,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n                                                 &unique_type_id_str[..],\n-                                                t.user_string());\n+                                                t);\n                     cx.sess().span_bug(usage_site_span, &error_message[..]);\n                 }\n             };\n@@ -854,7 +853,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n                             &unique_type_id_str[..],\n-                            t.user_string());\n+                            t);\n                         cx.sess().span_bug(usage_site_span, &error_message[..]);\n                     }\n                 }"}, {"sha": "5ba5ecb02c024c1b9f51cd63d0b78fc77bf527df", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -15,7 +15,6 @@ use super::namespace::crate_root_namespace;\n use trans::common::CrateContext;\n use middle::subst::{self, Substs};\n use middle::ty::{self, Ty, ClosureTyper};\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::parse::token;\n@@ -163,7 +162,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", t.repr()));\n+                unexpected type: {:?}\", t));\n         }\n     }\n "}, {"sha": "8bc3326d30093ea598f9b11f0ed6dcde339faf5f", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -29,7 +29,6 @@ use trans::context::CrateContext;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use util::ppaux::Repr;\n \n use std::ffi::CString;\n use libc::c_uint;\n@@ -106,11 +105,11 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n /// update the declaration and return existing ValueRef instead.\n pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                  fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name,\n-           fn_type.repr());\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name,\n+           fn_type);\n     let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n-    debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n-           fn_type.repr());\n+    debug!(\"declare_rust_fn (after normalised associated types) fn_type={:?}\",\n+           fn_type);\n \n     let function_type; // placeholder so that the memory ownership works out ok\n     let (sig, abi, env) = match fn_type.sty {\n@@ -122,15 +121,15 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n-            debug!(\"declare_rust_fn function_type={} self_type={}\",\n-                   function_type.repr(), self_type.repr());\n+            debug!(\"declare_rust_fn function_type={:?} self_type={:?}\",\n+                   function_type, self_type);\n             (&function_type.sig, abi::RustCall, Some(llenvironment_type))\n         }\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n     let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n-    debug!(\"declare_rust_fn (after region erasure) sig={}\", sig.repr());\n+    debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n "}, {"sha": "48deceeeef73f5b839b56d2f56c5cb72b21ac11b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -78,7 +78,6 @@ use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::common::indenter;\n-use util::ppaux::Repr;\n use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n@@ -181,7 +180,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    debug!(\"trans_into() expr={}\", expr.repr());\n+    debug!(\"trans_into() expr={:?}\", expr);\n \n     let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n                                                                           expr.id,\n@@ -211,7 +210,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          expr: &ast::Expr)\n                          -> DatumBlock<'blk, 'tcx, Expr> {\n-    debug!(\"trans(expr={})\", bcx.expr_to_string(expr));\n+    debug!(\"trans(expr={:?})\", expr);\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n@@ -329,9 +328,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n-        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {} -> {}\",\n-                                     source.repr(),\n-                                     target.repr()))\n+        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                                     source,\n+                                     target))\n     }\n }\n \n@@ -350,8 +349,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum for expr {}: {} adjustment={:?}\",\n-           expr.repr(),\n+    debug!(\"unadjusted datum for expr {:?}: {} adjustment={:?}\",\n+           expr,\n            datum.to_string(bcx.ccx()),\n            adjustment);\n     match adjustment {\n@@ -501,8 +500,8 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     ty::custom_coerce_unsized_kind(bcx.tcx(), impl_def_id)\n                 }\n                 vtable => {\n-                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {}\",\n-                                                       vtable.repr()));\n+                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {:?}\",\n+                                                       vtable));\n                 }\n             };\n \n@@ -545,9 +544,9 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {} -> {}\",\n-                                     source.ty.repr(),\n-                                     target.ty.repr()))\n+        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n+                                     source.ty,\n+                                     target.ty))\n     }\n     bcx\n }\n@@ -575,7 +574,7 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n \n-    debug!(\"trans_unadjusted(expr={})\", bcx.expr_to_string(expr));\n+    debug!(\"trans_unadjusted(expr={:?})\", expr);\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n@@ -1281,9 +1280,9 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n-                    \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n+                    \"trans_def_fn_unadjusted invoked on: {:?} for {:?}\",\n                     def,\n-                    ref_expr.repr()));\n+                    ref_expr));\n         }\n     }\n }\n@@ -1317,7 +1316,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n-                   nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n+                   nid, bcx.val_to_string(datum.val), datum.ty);\n             datum\n         }\n         _ => {\n@@ -1354,9 +1353,9 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n             match node_id_opt {\n                 None => {\n                     tcx.sess.bug(&format!(\n-                        \"cannot get field types from the enum type {} \\\n+                        \"cannot get field types from the enum type {:?} \\\n                          without a node ID\",\n-                        ty.repr()));\n+                        ty));\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n@@ -1378,8 +1377,8 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n \n         _ => {\n             tcx.sess.bug(&format!(\n-                \"cannot get field types from the type {}\",\n-                ty.repr()));\n+                \"cannot get field types from the type {:?}\",\n+                ty));\n         }\n     }\n }\n@@ -2060,7 +2059,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let t_in = expr_ty_adjusted(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n \n-    debug!(\"trans_cast({} as {})\", t_in.repr(), t_out.repr());\n+    debug!(\"trans_cast({:?} as {:?})\", t_in, t_out);\n     let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n     let ll_t_out = type_of::arg_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n@@ -2123,9 +2122,9 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         _ => ccx.sess().span_bug(expr.span,\n                                   &format!(\"translating unsupported cast: \\\n-                                            {} -> {}\",\n-                                           t_in.repr(),\n-                                           t_out.repr())\n+                                            {:?} -> {:?}\",\n+                                           t_in,\n+                                           t_out)\n                                  )\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n@@ -2140,7 +2139,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_assign_op(expr={})\", bcx.expr_to_string(expr));\n+    debug!(\"trans_assign_op(expr={:?})\", expr);\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n     assert!(!bcx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n@@ -2210,8 +2209,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n-    debug!(\"deref_once(expr={}, datum={}, method_call={:?})\",\n-           expr.repr(),\n+    debug!(\"deref_once(expr={:?}, datum={}, method_call={:?})\",\n+           expr,\n            datum.to_string(ccx),\n            method_call);\n \n@@ -2295,8 +2294,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                &format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr()));\n+                &format!(\"deref invoked on expr of illegal type {:?}\",\n+                        datum.ty));\n         }\n     };\n "}, {"sha": "977d636d253e4cee7053ca35e257e1c84b68edd3", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -40,7 +40,6 @@ use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n use syntax::print::pprust;\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // Type definitions\n@@ -183,11 +182,11 @@ pub fn get_extern_fn(ccx: &CrateContext,\n pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           abi: Abi, fty: Ty<'tcx>,\n                                           name: &str) -> ValueRef {\n-    debug!(\"register_foreign_item_fn(abi={}, \\\n-            ty={}, \\\n+    debug!(\"register_foreign_item_fn(abi={:?}, \\\n+            ty={:?}, \\\n             name={})\",\n-           abi.repr(),\n-           fty.repr(),\n+           abi,\n+           fty,\n            name);\n \n     let cc = llvm_calling_convention(ccx, abi);\n@@ -234,10 +233,10 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n {\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_native_call(callee_ty={}, \\\n+    debug!(\"trans_native_call(callee_ty={:?}, \\\n             llfn={}, \\\n             llretptr={})\",\n-           callee_ty.repr(),\n+           callee_ty,\n            ccx.tn().val_to_string(llfn),\n            ccx.tn().val_to_string(llretptr));\n \n@@ -609,16 +608,16 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n-                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n+                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr()));\n+                                       t));\n             }\n         };\n \n-        debug!(\"build_rust_fn: path={} id={} t={}\",\n+        debug!(\"build_rust_fn: path={} id={} t={:?}\",\n                ccx.tcx().map.path_to_string(id),\n-               id, t.repr());\n+               id, t);\n \n         let llfn = declare::define_internal_rust_fn(ccx, &ps[..], t).unwrap_or_else(||{\n             ccx.sess().bug(&format!(\"symbol `{}` already defined\", ps));\n@@ -636,10 +635,10 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n \n-        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n+        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={:?})\",\n                ccx.tn().val_to_string(llrustfn),\n                ccx.tn().val_to_string(llwrapfn),\n-               t.repr());\n+               t);\n \n         // Avoid all the Rust generation stuff and just generate raw\n         // LLVM here.\n@@ -721,10 +720,10 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     debug!(\"out pointer, \\\n                             allocad={}, \\\n                             llrust_ret_ty={}, \\\n-                            return_ty={}\",\n+                            return_ty={:?}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.output.repr());\n+                           tys.fn_sig.output);\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -815,8 +814,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {}\",\n-               ccx.tn().val_to_string(llrustfn), t.repr());\n+        debug!(\"calling llrustfn = {}, t = {:?}\",\n+               ccx.tn().val_to_string(llrustfn), t);\n         let attributes = attributes::from_fn_type(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n \n@@ -934,11 +933,11 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n-           ty={}, \\\n+           ty={:?}, \\\n            llsig={} -> {}, \\\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n-           ty.repr(),\n+           ty,\n            ccx.tn().types_to_str(&llsig.llarg_tys),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),"}, {"sha": "6caf00634b63aa65b6fb7d4e487b5da47287ab47", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -39,7 +39,6 @@ use trans::machine::*;\n use trans::monomorphize;\n use trans::type_of::{type_of, type_of_dtor, sizing_type_of, align_of};\n use trans::type_::Type;\n-use util::ppaux::Repr;\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -140,7 +139,7 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 debug_loc: DebugLoc,\n                                 skip_dtor: bool) -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(), skip_dtor);\n+    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n@@ -207,9 +206,9 @@ impl<'tcx> DropGlueKind<'tcx> {\n \n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {}\", g.repr());\n+    debug!(\"make drop glue for {:?}\", g);\n     let g = g.map_ty(|t| get_drop_glue_type(ccx, t));\n-    debug!(\"drop glue type {}\", g.repr());\n+    debug!(\"drop glue type {:?}\", g);\n     match ccx.drop_glues().borrow().get(&g) {\n         Some(&glue) => return glue,\n         _ => { }\n@@ -238,7 +237,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n-    let _s = StatRecorder::new(ccx, format!(\"drop {}\", t.repr()));\n+    let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n \n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -346,7 +345,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx>\n {\n-    debug!(\"trans_struct_drop t: {}\", bcx.ty_to_string(t));\n+    debug!(\"trans_struct_drop t: {}\", t);\n \n     // Find and call the actual destructor\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t, class_did, substs);\n@@ -381,7 +380,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                          -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n-           bcx.ty_to_string(t), bcx.val_to_string(info));\n+           t, bcx.val_to_string(info));\n     if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n@@ -436,8 +435,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n              C_uint(bcx.ccx(), unit_align))\n         }\n-        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t)))\n+        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\", t))\n     }\n }\n \n@@ -511,8 +509,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                         // stupid and dangerous.\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n-                                                 #16758\",\n-                                                bcx.ty_to_string(t)));\n+                                                 #16758\", t));\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }"}, {"sha": "41d150ac265c93f6a278e0acd1c5033a450eb1df", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -34,7 +34,6 @@ use middle::ty::{self, Ty};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n-use util::ppaux::{Repr, UserString};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match &token::get_ident(item.ident)[..] {\n@@ -102,7 +101,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n             continue;\n         }\n \n-        debug!(\"transmute_restriction: {}\", transmute_restriction.repr());\n+        debug!(\"transmute_restriction: {:?}\", transmute_restriction);\n \n         assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n         assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n@@ -121,21 +120,21 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with potentially different sizes: \\\n                               {} (could be {} bit{}) to {} (could be {} bit{})\",\n-                             transmute_restriction.original_from.user_string(),\n+                             transmute_restriction.original_from,\n                              from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n-                             transmute_restriction.original_to.user_string(),\n+                             transmute_restriction.original_to,\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with different sizes: \\\n                               {} ({} bit{}) to {} ({} bit{})\",\n-                             transmute_restriction.original_from.user_string(),\n+                             transmute_restriction.original_from,\n                              from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n-                             transmute_restriction.original_to.user_string(),\n+                             transmute_restriction.original_to,\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             }\n@@ -405,7 +404,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ty_name = token::intern_and_get_ident(&tp_ty.user_string());\n+            let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {"}, {"sha": "eca6eecff4279294d1d11d6dc5602be3ec69f8f7", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -39,7 +39,6 @@ use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n-use util::ppaux::Repr;\n \n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n@@ -136,15 +135,15 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }) => {\n             let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n-            debug!(\"method_call={:?} trait_ref={} trait_ref id={:?} substs={:?}\",\n+            debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n                    method_call,\n-                   trait_ref.repr(),\n+                   trait_ref,\n                    trait_ref.0.def_id,\n                    trait_ref.0.substs);\n             let origin = fulfill_obligation(bcx.ccx(),\n                                             span,\n                                             trait_ref.clone());\n-            debug!(\"origin = {}\", origin.repr());\n+            debug!(\"origin = {:?}\", origin);\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n                                        trait_ref.def_id(),\n@@ -234,7 +233,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              rcvr_self,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"trait_substs={}\", trait_substs.repr());\n+    debug!(\"trait_substs={:?}\", trait_substs);\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n     let vtbl = fulfill_obligation(ccx,\n@@ -296,8 +295,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             immediate_rvalue(llfn, ty)\n         }\n         _ => {\n-            tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr()));\n+            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n+                                 vtbl));\n         }\n     }\n }\n@@ -390,8 +389,8 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableDefaultImpl(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n-                &format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr()));\n+                &format!(\"resolved vtable bad vtable {:?} in trans\",\n+                        vtable));\n         }\n     }\n }\n@@ -415,8 +414,8 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let node_substs = node_id_substs(ccx, node, bcx.fcx.param_substs);\n \n-    debug!(\"rcvr_substs={}\", rcvr_substs.repr());\n-    debug!(\"node_substs={}\", node_substs.repr());\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs);\n+    debug!(\"node_substs={:?}\", node_substs);\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n@@ -484,7 +483,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Load the data pointer from the object.\n     debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n-           callee_ty.repr(),\n+           callee_ty,\n            vtable_index,\n            bcx.val_to_string(llpair));\n     let llboxptr = GEPi(bcx, llpair, &[0, abi::FAT_PTR_ADDR]);\n@@ -556,9 +555,9 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let tcx = ccx.tcx();\n     let trait_id = upcast_trait_ref.def_id();\n \n-    debug!(\"trans_object_shim(object_ty={}, upcast_trait_ref={}, method_offset_in_trait={})\",\n-           object_ty.repr(),\n-           upcast_trait_ref.repr(),\n+    debug!(\"trans_object_shim(object_ty={:?}, upcast_trait_ref={:?}, method_offset_in_trait={})\",\n+           object_ty,\n+           upcast_trait_ref,\n            method_offset_in_trait);\n \n     let object_trait_ref =\n@@ -567,15 +566,15 @@ pub fn trans_object_shim<'a, 'tcx>(\n                 data.principal_trait_ref_with_self_ty(tcx, object_ty)\n             }\n             _ => {\n-                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {}\",\n-                                      object_ty.repr()));\n+                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {:?}\",\n+                                      object_ty));\n             }\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n-    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr());\n+    debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n@@ -587,7 +586,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n     let method_ty = opaque_method_ty(tcx, fty);\n-    debug!(\"trans_object_shim: fty={} method_ty={}\", fty.repr(), method_ty.repr());\n+    debug!(\"trans_object_shim: fty={:?} method_ty={:?}\", fty, method_ty);\n \n     //\n     let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n@@ -627,8 +626,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n                     ty::TyTuple(ref tys) => &**tys,\n                     _ => {\n                         bcx.sess().bug(\n-                            &format!(\"rust-call expects a tuple not {}\",\n-                                     sig.inputs[1].repr()));\n+                            &format!(\"rust-call expects a tuple not {:?}\",\n+                                     sig.inputs[1]));\n                     }\n                 }\n             }\n@@ -692,7 +691,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(trait_ref={})\", trait_ref.repr());\n+    debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n     // Check the cache.\n     match ccx.vtables().borrow().get(&trait_ref) {\n@@ -739,14 +738,14 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n                 tcx.sess.bug(\n-                    &format!(\"cannot get vtable for an object type: {}\",\n-                            data.repr()));\n+                    &format!(\"cannot get vtable for an object type: {:?}\",\n+                            data));\n             }\n             traits::VtableParam(..) => {\n                 tcx.sess.bug(\n-                    &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n-                            trait_ref.repr(),\n-                            vtable.repr()));\n+                    &format!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n+                            trait_ref,\n+                            vtable));\n             }\n         }\n     });\n@@ -776,10 +775,10 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n {\n     let tcx = ccx.tcx();\n \n-    debug!(\"emit_vtable_methods(impl_id={}, substs={}, param_substs={})\",\n-           impl_id.repr(),\n-           substs.repr(),\n-           param_substs.repr());\n+    debug!(\"emit_vtable_methods(impl_id={:?}, substs={:?}, param_substs={:?})\",\n+           impl_id,\n+           substs,\n+           param_substs);\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n@@ -806,8 +805,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // method could never be called from this object, just supply\n         // null.\n         .map(|trait_method_def_id| {\n-            debug!(\"emit_vtable_methods: trait_method_def_id={}\",\n-                   trait_method_def_id.repr());\n+            debug!(\"emit_vtable_methods: trait_method_def_id={:?}\",\n+                   trait_method_def_id);\n \n             let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n@@ -821,8 +820,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 return nullptr;\n             }\n \n-            debug!(\"emit_vtable_methods: trait_method_type={}\",\n-                   trait_method_type.repr());\n+            debug!(\"emit_vtable_methods: trait_method_type={:?}\",\n+                   trait_method_type);\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n@@ -832,8 +831,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n \n-            debug!(\"emit_vtable_methods: impl_method_type={}\",\n-                   impl_method_type.repr());\n+            debug!(\"emit_vtable_methods: impl_method_type={:?}\",\n+                   impl_method_type);\n \n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this"}, {"sha": "f4bad313bafb1c95e2772b3655a6e8250d096a7d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -26,7 +26,6 @@ use trans::common::*;\n use trans::declare;\n use trans::foreign;\n use middle::ty::{self, HasProjectionTypes, Ty};\n-use util::ppaux::Repr;\n \n use syntax::abi;\n use syntax::ast;\n@@ -41,11 +40,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n     -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n-            fn_id={}, \\\n-            real_substs={}, \\\n+            fn_id={:?}, \\\n+            real_substs={:?}, \\\n             ref_id={:?})\",\n-           fn_id.repr(),\n-           psubsts.repr(),\n+           fn_id,\n+           psubsts,\n            ref_id);\n \n     assert!(psubsts.types.all(|t| {\n@@ -61,7 +60,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n \n-    debug!(\"monomorphic_fn about to subst into {}\", item_ty.repr());\n+    debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n     let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n@@ -74,11 +73,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"monomorphic_fn(\\\n-            fn_id={}, \\\n-            psubsts={}, \\\n+            fn_id={:?}, \\\n+            psubsts={:?}, \\\n             hash_id={:?})\",\n-           fn_id.repr(),\n-           psubsts.repr(),\n+           fn_id,\n+           psubsts,\n            hash_id);\n \n \n@@ -99,10 +98,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr());\n+    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n \n     let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n-    debug!(\"mono_ty = {} (post-normalization)\", mono_ty.repr());\n+    debug!(\"mono_ty = {:?} (post-normalization)\", mono_ty);\n \n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n@@ -316,7 +315,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n-    debug!(\"normalize_associated_type(t={})\", value.repr());\n+    debug!(\"normalize_associated_type(t={:?})\", value);\n \n     let value = erase_regions(tcx, value);\n \n@@ -333,9 +332,9 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, &value);\n \n-    debug!(\"normalize_associated_type: result={} obligations={}\",\n-           result.repr(),\n-           obligations.repr());\n+    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n+           result,\n+           obligations);\n \n     let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     for obligation in obligations {"}, {"sha": "bba0f6d26083a6d04e4fd1e7c72a7dd4c0540835", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use util::ppaux::UserString;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -42,7 +41,7 @@ struct VecTypes<'tcx> {\n impl<'tcx> VecTypes<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n-                self.unit_ty.user_string(),\n+                self.unit_ty,\n                 ccx.tn().type_to_string(self.llunit_ty))\n     }\n }\n@@ -58,8 +57,8 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(expr={}, dest={})\",\n-           bcx.expr_to_string(expr), dest.to_string(bcx.ccx()));\n+    debug!(\"trans_fixed_vstore(expr={:?}, dest={})\",\n+           expr, dest.to_string(bcx.ccx()));\n \n     let vt = vec_types_from_expr(bcx, expr);\n \n@@ -85,8 +84,8 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = fcx.ccx;\n     let mut bcx = bcx;\n \n-    debug!(\"trans_slice_vec(slice_expr={})\",\n-           bcx.expr_to_string(slice_expr));\n+    debug!(\"trans_slice_vec(slice_expr={:?})\",\n+           slice_expr);\n \n     let vec_ty = node_id_type(bcx, slice_expr.id);\n \n@@ -139,8 +138,8 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  str_lit: InternedString,\n                                  dest: Dest)\n                                  -> Block<'blk, 'tcx> {\n-    debug!(\"trans_lit_str(lit_expr={}, dest={})\",\n-           bcx.expr_to_string(lit_expr),\n+    debug!(\"trans_lit_str(lit_expr={:?}, dest={})\",\n+           lit_expr,\n            dest.to_string(bcx.ccx()));\n \n     match dest {\n@@ -167,10 +166,10 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt={}, dest={}, vstore_expr={})\",\n+    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n            vt.to_string(bcx.ccx()),\n            dest.to_string(bcx.ccx()),\n-           bcx.expr_to_string(vstore_expr));\n+           vstore_expr);\n \n     match content_expr.node {\n         ast::ExprLit(ref lit) => {"}, {"sha": "26b54142d63160b403736cda7bd4a8c673698869", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use trans::common::*;\n use trans::foreign;\n use trans::machine;\n use middle::ty::{self, RegionEscape, Ty};\n-use util::ppaux::Repr;\n \n use trans::type_::Type;\n \n@@ -99,8 +98,8 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  abi: abi::Abi)\n                                  -> Type\n {\n-    debug!(\"type_of_rust_fn(sig={},abi={:?})\",\n-           sig.repr(),\n+    debug!(\"type_of_rust_fn(sig={:?},abi={:?})\",\n+           sig,\n            abi);\n \n     let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n@@ -228,8 +227,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError(..) => {\n-            cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n-                                   t.repr()))\n+            cx.sess().bug(&format!(\"fictitious type {:?} in sizing_type_of()\",\n+                                   t))\n         }\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n@@ -298,7 +297,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(), t.sty);\n+    debug!(\"type_of {:?}\", t);\n \n     assert!(!t.has_escaping_regions());\n \n@@ -311,10 +310,10 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     if t != t_norm {\n         let llty = in_memory_type_of(cx, t_norm);\n-        debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n-                t.repr(),\n+        debug!(\"--> normalized {:?} {:?} to {:?} {:?} llty={}\",\n                 t,\n-                t_norm.repr(),\n+                t,\n+                t_norm,\n                 t_norm,\n                 cx.tn().type_to_string(llty));\n         cx.lltypes().borrow_mut().insert(t, llty);\n@@ -363,8 +362,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                       }\n                       ty::TyTrait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\\n-                                   struct_tail: {} for ty={}\",\n-                                  unsized_part.repr(), ty.repr())\n+                                   struct_tail: {:?} for ty={:?}\",\n+                                  unsized_part, ty)\n                   };\n                   Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n@@ -418,8 +417,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyError(..) => cx.sess().bug(\"type_of with TyError\"),\n     };\n \n-    debug!(\"--> mapped t={} {:?} to llty={}\",\n-            t.repr(),\n+    debug!(\"--> mapped t={:?} {:?} to llty={}\",\n+            t,\n             t,\n             cx.tn().type_to_string(llty));\n \n@@ -449,7 +448,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             tps: &[Ty<'tcx>])\n                             -> String {\n     let base = ty::item_path_str(cx.tcx(), did);\n-    let strings: Vec<String> = tps.iter().map(|t| t.repr()).collect();\n+    let strings: Vec<String> = tps.iter().map(|t| t.to_string()).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {"}, {"sha": "8e838d991fbe7df35e1d28b0b6dca4ddb693ec5d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -61,7 +61,6 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n-use util::ppaux::{Repr, UserString};\n \n use std::iter::repeat;\n use std::slice;\n@@ -178,10 +177,10 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n         }\n     };\n \n-    debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n-           lifetime.repr(),\n+    debug!(\"ast_region_to_region(lifetime={:?} id={}) yields {:?}\",\n+           lifetime,\n            lifetime.id,\n-           r.repr());\n+           r);\n \n     r\n }\n@@ -256,9 +255,9 @@ pub fn opt_ast_region_to_region<'tcx>(\n         }\n     };\n \n-    debug!(\"opt_ast_region_to_region(opt_lifetime={}) yields {}\",\n-            opt_lifetime.repr(),\n-            r.repr());\n+    debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n+            opt_lifetime,\n+            r);\n \n     r\n }\n@@ -373,10 +372,10 @@ fn create_substs_for_ast_path<'tcx>(\n {\n     let tcx = this.tcx();\n \n-    debug!(\"create_substs_for_ast_path(decl_generics={}, self_ty={}, \\\n-           types_provided={}, region_substs={}\",\n-           decl_generics.repr(), self_ty.repr(), types_provided.repr(),\n-           region_substs.repr());\n+    debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n+           types_provided={:?}, region_substs={:?}\",\n+           decl_generics, self_ty, types_provided,\n+           region_substs);\n \n     assert_eq!(region_substs.regions().len(TypeSpace), decl_generics.regions.len(TypeSpace));\n     assert!(region_substs.types.is_empty());\n@@ -441,8 +440,8 @@ fn create_substs_for_ast_path<'tcx>(\n                           \"the type parameter `{}` must be explicitly specified \\\n                            in an object type because its default value `{}` references \\\n                            the type `Self`\",\n-                          param.name.user_string(),\n-                          default.user_string());\n+                          param.name,\n+                          default);\n                 substs.types.push(TypeSpace, tcx.types.err);\n             } else {\n                 // This is a default type parameter.\n@@ -649,7 +648,7 @@ fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::D\n         def::DefTrait(trait_def_id) => trait_def_id,\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                        path.user_string());\n+                        path);\n         }\n     }\n }\n@@ -879,7 +878,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n \n     let candidate = try!(one_bound_for_assoc_type(tcx,\n                                                   candidates,\n-                                                  &trait_ref.user_string(),\n+                                                  &trait_ref.to_string(),\n                                                   &token::get_name(binding.item_name),\n                                                   binding.span));\n \n@@ -1030,8 +1029,8 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n                                                      bounds);\n \n     let result = make_object_type(this, span, trait_ref, existential_bounds);\n-    debug!(\"trait_ref_to_object_type: result={}\",\n-           result.repr());\n+    debug!(\"trait_ref_to_object_type: result={:?}\",\n+           result);\n \n     result\n }\n@@ -1074,7 +1073,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     for (trait_def_id, name) in associated_types {\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(),\n+                    name,\n                     ty::item_path_str(tcx, trait_def_id));\n     }\n \n@@ -1160,7 +1159,7 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_note!(tcx.sess, span,\n                        \"associated type `{}` could derive from `{}`\",\n                        ty_param_name,\n-                       bound.user_string());\n+                       bound);\n         }\n     }\n \n@@ -1183,7 +1182,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let tcx = this.tcx();\n     let assoc_name = item_segment.identifier.name;\n \n-    debug!(\"associated_path_def_to_ty: {}::{}\", ty.repr(), token::get_name(assoc_name));\n+    debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n     check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n \n@@ -1239,7 +1238,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         _ => {\n             report_ambiguous_associated_type(tcx,\n                                              span,\n-                                             &ty.user_string(),\n+                                             &ty.to_string(),\n                                              \"Trait\",\n                                              &token::get_name(assoc_name));\n             return (tcx.types.err, ty_path_def);\n@@ -1296,7 +1295,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return tcx.types.err;\n     };\n \n-    debug!(\"qpath_to_ty: self_type={}\", self_ty.repr());\n+    debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n     let trait_ref = ast_path_to_mono_trait_ref(this,\n                                                rscope,\n@@ -1306,7 +1305,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                Some(self_ty),\n                                                trait_segment);\n \n-    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr());\n+    debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n     this.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n@@ -1495,8 +1494,8 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                           ast_ty: &ast::Ty)\n                           -> Ty<'tcx>\n {\n-    debug!(\"ast_ty_to_ty(ast_ty={})\",\n-           ast_ty.repr());\n+    debug!(\"ast_ty_to_ty(ast_ty={:?})\",\n+           ast_ty);\n \n     let tcx = this.tcx();\n \n@@ -1531,7 +1530,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         ast::TyRptr(ref region, ref mt) => {\n             let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-            debug!(\"TyRef r={}\", r.repr());\n+            debug!(\"TyRef r={:?}\", r);\n             let rscope1 =\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n@@ -1568,8 +1567,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-                tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\", ast_ty.repr()))\n+                tcx.sess.span_bug(ast_ty.span, &format!(\"unbound path {:?}\", ast_ty))\n             };\n             let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n@@ -1843,11 +1841,11 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n             let impl_modifiers = count_modifiers(self_info.untransformed_self_ty);\n             let method_modifiers = count_modifiers(explicit_type);\n \n-            debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={} \\\n-                   explicit_type={} \\\n+            debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={:?} \\\n+                   explicit_type={:?} \\\n                    modifiers=({},{})\",\n-                   self_info.untransformed_self_ty.repr(),\n-                   explicit_type.repr(),\n+                   self_info.untransformed_self_ty,\n+                   explicit_type,\n                    impl_modifiers,\n                    method_modifiers);\n \n@@ -1880,8 +1878,8 @@ pub fn ty_of_closure<'tcx>(\n     expected_sig: Option<ty::FnSig<'tcx>>)\n     -> ty::ClosureTy<'tcx>\n {\n-    debug!(\"ty_of_closure(expected_sig={})\",\n-           expected_sig.repr());\n+    debug!(\"ty_of_closure(expected_sig={:?})\",\n+           expected_sig);\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -1919,8 +1917,8 @@ pub fn ty_of_closure<'tcx>(\n         ast::NoReturn(..) => ty::FnDiverging\n     };\n \n-    debug!(\"ty_of_closure: input_tys={}\", input_tys.repr());\n-    debug!(\"ty_of_closure: output_ty={}\", output_ty.repr());\n+    debug!(\"ty_of_closure: input_tys={:?}\", input_tys);\n+    debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n \n     ty::ClosureTy {\n         unsafety: unsafety,\n@@ -2037,10 +2035,10 @@ fn compute_object_lifetime_bound<'tcx>(\n     let tcx = this.tcx();\n \n     debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-           principal_trait_ref={}, builtin_bounds={})\",\n+           principal_trait_ref={:?}, builtin_bounds={:?})\",\n            explicit_region_bounds,\n-           principal_trait_ref.repr(),\n-           builtin_bounds.repr());\n+           principal_trait_ref,\n+           builtin_bounds);\n \n     if explicit_region_bounds.len() > 1 {\n         span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,"}, {"sha": "cf086a32ae599b27803a0437e3b973ced446c067", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -22,7 +22,6 @@ use check::{check_expr_with_lvalue_pref, LvaluePreference};\n use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n use std::cmp::{self, Ordering};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -40,9 +39,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    debug!(\"check_pat(pat={},expected={})\",\n-           pat.repr(),\n-           expected.repr());\n+    debug!(\"check_pat(pat={:?},expected={:?})\",\n+           pat,\n+           expected);\n \n     match pat.node {\n         ast::PatWild(_) => {\n@@ -222,7 +221,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             } else {\n                 tcx.sess.span_bug(pat.span,\n-                                  &format!(\"unbound path {}\", pat.repr()))\n+                                  &format!(\"unbound path {:?}\", pat))\n             };\n             if let Some((opt_ty, segments, def)) =\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),"}, {"sha": "df9fe6b002efba6efaeee2a74779a969eb4d366a", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -15,7 +15,6 @@ use middle::ty::{self, HasProjectionTypes};\n use middle::ty_fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 typer: &(ty::ClosureTyper<'tcx>+'a),\n@@ -26,13 +25,13 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 -> T\n     where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n-    debug!(\"normalize_associated_types_in(value={})\", value.repr());\n+    debug!(\"normalize_associated_types_in(value={:?})\", value);\n     let mut selcx = SelectionContext::new(infcx, typer);\n     let cause = ObligationCause::new(span, body_id, MiscObligation);\n     let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n-    debug!(\"normalize_associated_types_in: result={} predicates={}\",\n-           result.repr(),\n-           obligations.repr());\n+    debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n+           result,\n+           obligations);\n     for obligation in obligations {\n         fulfillment_cx.register_predicate_obligation(infcx, obligation);\n     }"}, {"sha": "e7271d2fa88cf1ef123f12f452208d5292567e57", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -32,7 +32,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use util::ppaux::Repr;\n \n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -120,9 +119,9 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       autoderefs: usize)\n                                       -> Option<CallStep<'tcx>>\n {\n-    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefs={})\",\n-           call_expr.repr(),\n-           adjusted_ty.repr(),\n+    debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n+           call_expr,\n+           adjusted_ty,\n            autoderefs);\n \n     // If the callee is a bare function or a closure, then we're all set.\n@@ -340,8 +339,8 @@ struct CallResolution<'tcx> {\n \n impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n     fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) {\n-        debug!(\"DeferredCallResolution::resolve() {}\",\n-               self.repr());\n+        debug!(\"DeferredCallResolution::resolve() {:?}\",\n+               self);\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n@@ -363,8 +362,8 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                     ty::no_late_bound_regions(fcx.tcx(),\n                                               ty::ty_fn_sig(method_callee.ty)).unwrap();\n \n-                debug!(\"attempt_resolution: method_callee={}\",\n-                       method_callee.repr());\n+                debug!(\"attempt_resolution: method_callee={:?}\",\n+                       method_callee);\n \n                 for (&method_arg_ty, &self_arg_ty) in\n                     method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs)"}, {"sha": "9522a21b69ec663d0b19f9aecc7fd73b010a6a6c", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -45,7 +45,6 @@ use middle::ty::Ty;\n use syntax::ast;\n use syntax::ast::UintTy::{TyU8};\n use syntax::codemap::Span;\n-use util::ppaux::Repr;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -192,8 +191,8 @@ impl<'tcx> CastCheck<'tcx> {\n         self.expr_ty = structurally_resolved_type(fcx, self.span, self.expr_ty);\n         self.cast_ty = structurally_resolved_type(fcx, self.span, self.cast_ty);\n \n-        debug!(\"check_cast({}, {} as {})\", self.expr.id, self.expr_ty.repr(),\n-               self.cast_ty.repr());\n+        debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n+               self.cast_ty);\n \n         if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n             // No sense in giving duplicate error messages\n@@ -273,8 +272,8 @@ impl<'tcx> CastCheck<'tcx> {\n                               m_cast: &'tcx ty::mt<'tcx>)\n                               -> Result<CastKind, CastError>\n     {\n-        debug!(\"check_ptr_ptr_cast m_expr={} m_cast={}\",\n-               m_expr.repr(), m_cast.repr());\n+        debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\",\n+               m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n \n         // Cast to sized is OK"}, {"sha": "10b2459b220f2a8ffeb62d94c425d98a9b216553", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -20,17 +20,16 @@ use std::cmp;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n-use util::ppaux::Repr;\n \n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n                                    decl: &'tcx ast::FnDecl,\n                                    body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n-    debug!(\"check_expr_closure(expr={},expected={})\",\n-           expr.repr(),\n-           expected.repr());\n+    debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n+           expr,\n+           expected);\n \n     // It's always helpful for inference if we know the kind of\n     // closure sooner rather than later, so first examine the expected\n@@ -50,9 +49,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n-    debug!(\"check_closure opt_kind={:?} expected_sig={}\",\n+    debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,\n-           expected_sig.repr());\n+           expected_sig);\n \n     let mut fn_ty = astconv::ty_of_closure(\n         fcx,\n@@ -86,9 +85,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // the `closures` table.\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n-    debug!(\"closure for {} --> sig={} opt_kind={:?}\",\n-           expr_def_id.repr(),\n-           fn_ty.sig.repr(),\n+    debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n+           expr_def_id,\n+           fn_ty.sig,\n            opt_kind);\n \n     fcx.inh.closure_tys.borrow_mut().insert(expr_def_id, fn_ty);\n@@ -103,8 +102,8 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n     expected_ty: Ty<'tcx>)\n     -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n {\n-    debug!(\"deduce_expectations_from_expected_type(expected_ty={})\",\n-           expected_ty.repr());\n+    debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n+           expected_ty);\n \n     match expected_ty.sty {\n         ty::TyTrait(ref object_type) => {\n@@ -138,8 +137,8 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         .pending_obligations()\n         .iter()\n         .filter_map(|obligation| {\n-            debug!(\"deduce_expectations_from_obligations: obligation.predicate={}\",\n-                   obligation.predicate.repr());\n+            debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n+                   obligation.predicate);\n \n             match obligation.predicate {\n                 // Given a Projection predicate, we can potentially infer\n@@ -200,8 +199,8 @@ fn deduce_sig_from_projection<'a,'tcx>(\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_sig_from_projection({})\",\n-           projection.repr());\n+    debug!(\"deduce_sig_from_projection({:?})\",\n+           projection);\n \n     let trait_ref = projection.to_poly_trait_ref();\n \n@@ -211,24 +210,24 @@ fn deduce_sig_from_projection<'a,'tcx>(\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr());\n+    debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n \n     let input_tys = match arg_param_ty.sty {\n         ty::TyTuple(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n-    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr());\n+    debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n     let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr());\n+    debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n     let fn_sig = ty::FnSig {\n         inputs: input_tys,\n         output: ty::FnConverging(ret_param_ty),\n         variadic: false\n     };\n-    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr());\n+    debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n     Some(fn_sig)\n }\n@@ -240,9 +239,9 @@ fn self_type_matches_expected_vid<'a,'tcx>(\n     -> Option<ty::PolyTraitRef<'tcx>>\n {\n     let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-    debug!(\"self_type_matches_expected_vid(trait_ref={}, self_ty={})\",\n-           trait_ref.repr(),\n-           self_ty.repr());\n+    debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n+           trait_ref,\n+           self_ty);\n     match self_ty.sty {\n         ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n         _ => None,"}, {"sha": "785202de92159e03302f641caebf0f9f4790518b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -69,7 +69,6 @@ use middle::ty::{AutoDerefRef, AdjustDerefRef};\n use middle::ty::{self, mt, Ty};\n use middle::ty_relate::RelateResult;\n use util::common::indent;\n-use util::ppaux::Repr;\n \n use std::cell::RefCell;\n use std::collections::VecDeque;\n@@ -104,9 +103,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n               a: Ty<'tcx>,\n               b: Ty<'tcx>)\n               -> CoerceResult<'tcx> {\n-        debug!(\"Coerce.tys({} => {})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"Coerce.tys({:?} => {:?})\",\n+               a,\n+               b);\n \n         // Consider coercing the subtype to a DST\n         let unsize = self.unpack_actual_value(a, |a| {\n@@ -166,9 +165,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                b: Ty<'tcx>,\n                                mutbl_b: ast::Mutability)\n                                -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\",\n+               a,\n+               b);\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -238,9 +237,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       source: Ty<'tcx>,\n                       target: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(source={}, target={})\",\n-               source.repr(),\n-               target.repr());\n+        debug!(\"coerce_unsized(source={:?}, target={:?})\",\n+               source,\n+               target);\n \n         let traits = (self.tcx().lang_items.unsize_trait(),\n                       self.tcx().lang_items.coerce_unsized_trait());\n@@ -294,7 +293,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n-            debug!(\"coerce_unsized resolve step: {}\", obligation.repr());\n+            debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref =  match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     tr.clone()\n@@ -336,7 +335,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             autoref: reborrow,\n             unsize: Some(target)\n         };\n-        debug!(\"Success, coerced with {}\", adjustment.repr());\n+        debug!(\"Success, coerced with {:?}\", adjustment);\n         Ok(Some(AdjustDerefRef(adjustment)))\n     }\n \n@@ -352,8 +351,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n          */\n \n         self.unpack_actual_value(b, |b| {\n-            debug!(\"coerce_from_fn_pointer(a={}, b={})\",\n-                   a.repr(), b.repr());\n+            debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\",\n+                   a, b);\n \n             if let ty::TyBareFn(None, fn_ty_b) = b.sty {\n                 match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n@@ -380,8 +379,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n          */\n \n         self.unpack_actual_value(b, |b| {\n-            debug!(\"coerce_from_fn_item(a={}, b={})\",\n-                   a.repr(), b.repr());\n+            debug!(\"coerce_from_fn_item(a={:?}, b={:?})\",\n+                   a, b);\n \n             match b.sty {\n                 ty::TyBareFn(None, _) => {\n@@ -399,9 +398,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                          b: Ty<'tcx>,\n                          mutbl_b: ast::Mutability)\n                          -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n-               a.repr(),\n-               b.repr());\n+        debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\",\n+               a,\n+               b);\n \n         let (is_ref, mt_a) = match a.sty {\n             ty::TyRef(_, mt) => (true, mt),\n@@ -436,7 +435,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n                              -> RelateResult<'tcx, ()> {\n-    debug!(\"mk_assignty({} -> {})\", a.repr(), b.repr());\n+    debug!(\"mk_assignty({:?} -> {:?})\", a, b);\n     let mut unsizing_obligations = vec![];\n     let adjustment = try!(indent(|| {\n         fcx.infcx().commit_if_ok(|_| {\n@@ -460,7 +459,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     if let Some(adjustment) = adjustment {\n-        debug!(\"Success, coerced with {}\", adjustment.repr());\n+        debug!(\"Success, coerced with {:?}\", adjustment);\n         fcx.write_adjustment(expr.id, adjustment);\n     }\n     Ok(())"}, {"sha": "7cd5e4548ec2b74b4c6c54227274dcd093cf50f9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -13,7 +13,6 @@ use middle::infer;\n use middle::traits;\n use middle::ty::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -38,11 +37,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  impl_m_body_id: ast::NodeId,\n                                  trait_m: &ty::Method<'tcx>,\n                                  impl_trait_ref: &ty::TraitRef<'tcx>) {\n-    debug!(\"compare_impl_method(impl_trait_ref={})\",\n-           impl_trait_ref.repr());\n+    debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n+           impl_trait_ref);\n \n-    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {}\",\n-           impl_trait_ref.repr());\n+    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n+           impl_trait_ref);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n@@ -63,16 +62,16 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_err!(tcx.sess, impl_m_span, E0185,\n                 \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n-                        token::get_name(trait_m.name),\n-                        impl_m.explicit_self.repr());\n+                        trait_m.name,\n+                        impl_m.explicit_self);\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n             span_err!(tcx.sess, impl_m_span, E0186,\n                 \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n-                        token::get_name(trait_m.name),\n-                        trait_m.explicit_self.repr());\n+                        trait_m.name,\n+                        trait_m.explicit_self);\n             return;\n         }\n         _ => {\n@@ -183,8 +182,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .subst(tcx, impl_to_skol_substs)\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n-    debug!(\"compare_impl_method: trait_to_skol_substs={}\",\n-           trait_to_skol_substs.repr());\n+    debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n+           trait_to_skol_substs);\n \n     // Check region bounds. FIXME(@jroesch) refactor this away when removing\n     // ParamBounds.\n@@ -211,8 +210,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             impl_m_span,\n             infer::HigherRankedType,\n             &ty::Binder(impl_bounds));\n-    debug!(\"compare_impl_method: impl_bounds={}\",\n-           impl_bounds.repr());\n+    debug!(\"compare_impl_method: impl_bounds={:?}\",\n+           impl_bounds);\n \n     // Normalize the associated types in the trait_bounds.\n     let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n@@ -242,8 +241,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n                                                                normalize_cause.clone());\n \n-    debug!(\"compare_impl_method: trait_bounds={}\",\n-        trait_param_env.caller_bounds.repr());\n+    debug!(\"compare_impl_method: trait_bounds={:?}\",\n+        trait_param_env.caller_bounds);\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n@@ -303,8 +302,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                            tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n                                                          abi: impl_m.fty.abi,\n                                                          sig: ty::Binder(impl_sig) }));\n-        debug!(\"compare_impl_method: impl_fty={}\",\n-               impl_fty.repr());\n+        debug!(\"compare_impl_method: impl_fty={:?}\",\n+               impl_fty);\n \n         let (trait_sig, skol_map) =\n             infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n@@ -324,8 +323,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                          abi: trait_m.fty.abi,\n                                                          sig: ty::Binder(trait_sig) }));\n \n-        debug!(\"compare_impl_method: trait_fty={}\",\n-               trait_fty.repr());\n+        debug!(\"compare_impl_method: trait_fty={:?}\",\n+               trait_fty);\n \n         try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n \n@@ -335,9 +334,9 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match err {\n         Ok(()) => { }\n         Err(terr) => {\n-            debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n-                   impl_fty.repr(),\n-                   trait_fty.repr());\n+            debug!(\"checking trait method for compatibility: impl ty {:?}, trait ty {:?}\",\n+                   impl_fty,\n+                   trait_fty);\n             span_err!(tcx.sess, impl_m_span, E0053,\n                       \"method `{}` has an incompatible type for trait: {}\",\n                       token::get_name(trait_m.name),\n@@ -381,14 +380,14 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n \n         debug!(\"check_region_bounds_on_impl_method: \\\n-               trait_generics={} \\\n-               impl_generics={} \\\n-               trait_to_skol_substs={} \\\n-               impl_to_skol_substs={}\",\n-               trait_generics.repr(),\n-               impl_generics.repr(),\n-               trait_to_skol_substs.repr(),\n-               impl_to_skol_substs.repr());\n+               trait_generics={:?} \\\n+               impl_generics={:?} \\\n+               trait_to_skol_substs={:?} \\\n+               impl_to_skol_substs={:?}\",\n+               trait_generics,\n+               impl_generics,\n+               trait_to_skol_substs,\n+               impl_to_skol_substs);\n \n         // Must have same number of early-bound lifetime parameters.\n         // Unfortunately, if the user screws up the bounds, then this\n@@ -416,8 +415,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 impl_c_span: Span,\n                                 trait_c: &ty::AssociatedConst<'tcx>,\n                                 impl_trait_ref: &ty::TraitRef<'tcx>) {\n-    debug!(\"compare_const_impl(impl_trait_ref={})\",\n-           impl_trait_ref.repr());\n+    debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n+           impl_trait_ref);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n@@ -443,8 +442,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .subst(tcx, impl_to_skol_substs)\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n-    debug!(\"compare_const_impl: trait_to_skol_substs={}\",\n-           trait_to_skol_substs.repr());\n+    debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n+           trait_to_skol_substs);\n \n     // Compute skolemized form of impl and trait const tys.\n     let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n@@ -461,8 +460,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_c_span,\n                                                  0,\n                                                  &impl_ty);\n-        debug!(\"compare_const_impl: impl_ty={}\",\n-               impl_ty.repr());\n+        debug!(\"compare_const_impl: impl_ty={:?}\",\n+               impl_ty);\n \n         let trait_ty =\n             assoc::normalize_associated_types_in(&infcx,\n@@ -471,18 +470,18 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_c_span,\n                                                  0,\n                                                  &trait_ty);\n-        debug!(\"compare_const_impl: trait_ty={}\",\n-               trait_ty.repr());\n+        debug!(\"compare_const_impl: trait_ty={:?}\",\n+               trait_ty);\n \n         infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n     });\n \n     match err {\n         Ok(()) => { }\n         Err(terr) => {\n-            debug!(\"checking associated const for compatibility: impl ty {}, trait ty {}\",\n-                   impl_ty.repr(),\n-                   trait_ty.repr());\n+            debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n+                   impl_ty,\n+                   trait_ty);\n             span_err!(tcx.sess, impl_c_span, E0326,\n                       \"implemented const `{}` has an incompatible type for \\\n                       trait: {}\","}, {"sha": "392515926da0c9b71735ffd7423f62b9e92e8877", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use middle::infer;\n use std::result::Result::{Err, Ok};\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::Repr;\n \n // Requires that the two types unify, and prints an error message if\n // they don't.\n@@ -59,9 +58,9 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         expected: Ty<'tcx>,\n                         expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n-    debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n-           expected.repr(),\n-           expr_ty.repr());\n+    debug!(\"demand::coerce(expected = {:?}, expr_ty = {:?})\",\n+           expected,\n+           expr_ty);\n     let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n     match coercion::mk_assignty(fcx, expr, expr_ty, expected) {"}, {"sha": "fb17f41d88d9a354c4f0bc9898062a61259803b5", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -14,7 +14,6 @@ use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n use middle::ty::{self, Ty};\n-use util::ppaux::{Repr, UserString};\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n@@ -38,7 +37,7 @@ use syntax::codemap::{self, Span};\n ///\n pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n     let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: ref dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n+                         ty: dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n     let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(self_type_did, self_to_impl_substs) |\n@@ -47,7 +46,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,\n-                                                               dtor_self_type,\n+                                                               &dtor_self_type,\n                                                                self_type_did));\n \n             ensure_drop_predicates_are_implied_by_item_defn(tcx,\n@@ -62,7 +61,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n             let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n             tcx.sess.span_bug(\n                 span, &format!(\"should have been rejected by coherence check: {}\",\n-                               dtor_self_type.repr()));\n+                               dtor_self_type));\n         }\n     }\n }\n@@ -212,9 +211,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n             let item_span = tcx.map.span(self_type_did.node);\n-            let req = predicate.user_string();\n             span_err!(tcx.sess, drop_impl_span, E0367,\n-                      \"The requirement `{}` is added only by the Drop impl.\", req);\n+                      \"The requirement `{}` is added only by the Drop impl.\", predicate);\n             tcx.sess.span_note(item_span,\n                                \"The same requirement must be part of \\\n                                 the struct/enum definition\");\n@@ -257,8 +255,8 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                                                      typ: ty::Ty<'tcx>,\n                                                      span: Span,\n                                                      scope: region::CodeExtent) {\n-    debug!(\"check_safety_of_destructor_if_necessary typ: {} scope: {:?}\",\n-           typ.repr(), scope);\n+    debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n+           typ, scope);\n \n     // types that have been traversed so far by `traverse_type_if_unseen`\n     let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n@@ -277,8 +275,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n         Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n             let tcx = rcx.tcx();\n             span_err!(tcx.sess, span, E0320,\n-                      \"overflow while adding drop-check rules for {}\",\n-                      typ.user_string());\n+                      \"overflow while adding drop-check rules for {}\", typ);\n             match *ctxt {\n                 TypeContext::Root => {\n                     // no need for an additional note if the overflow\n@@ -294,7 +291,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         ty::item_path_str(tcx, def_id),\n                         variant,\n                         arg_index,\n-                        detected_on_typ.user_string());\n+                        detected_on_typ);\n                 }\n                 TypeContext::Struct { def_id, field } => {\n                     span_note!(\n@@ -303,7 +300,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         \"overflowed on struct {} field {} type: {}\",\n                         ty::item_path_str(tcx, def_id),\n                         field,\n-                        detected_on_typ.user_string());\n+                        detected_on_typ);\n                 }\n             }\n         }\n@@ -372,8 +369,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     let tp_def = item_type.generics.types\n                         .opt_get(subst::TypeSpace, 0).unwrap();\n                     let new_typ = substs.type_for_def(tp_def);\n-                    debug!(\"replacing phantom {} with {}\",\n-                           typ.repr(), new_typ.repr());\n+                    debug!(\"replacing phantom {:?} with {:?}\",\n+                           typ, new_typ);\n                     (new_typ, xref_depth_orig + 1)\n                 } else {\n                     (typ, xref_depth_orig)\n@@ -384,8 +381,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             // definition of `Box<T>` must carry a PhantomData that\n             // puts us into the previous case.\n             ty::TyBox(new_typ) => {\n-                debug!(\"replacing TyBox {} with {}\",\n-                       typ.repr(), new_typ.repr());\n+                debug!(\"replacing TyBox {:?} with {:?}\",\n+                       typ, new_typ);\n                 (new_typ, xref_depth_orig + 1)\n             }\n \n@@ -411,7 +408,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}typ: {} scope: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(), scope, xref_depth);\n+               typ, scope, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -467,8 +464,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             match typ.sty {\n                 ty::TyStruct(struct_did, substs) => {\n-                    debug!(\"typ: {} is struct; traverse structure and not type-expression\",\n-                           typ.repr());\n+                    debug!(\"typ: {:?} is struct; traverse structure and not type-expression\",\n+                           typ);\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -497,8 +494,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                 }\n \n                 ty::TyEnum(enum_did, substs) => {\n-                    debug!(\"typ: {} is enum; traverse structure and not type-expression\",\n-                           typ.repr());\n+                    debug!(\"typ: {:?} is enum; traverse structure and not type-expression\",\n+                           typ);\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -571,24 +568,24 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match dtor_kind {\n         DtorKind::PureRecur => {\n             has_dtor_of_interest = false;\n-            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n-                   typ.repr());\n+            debug!(\"typ: {:?} has no dtor, and thus is uninteresting\",\n+                   typ);\n         }\n         DtorKind::Unknown(bounds) => {\n             match bounds.region_bound {\n                 ty::ReStatic => {\n-                    debug!(\"trait: {} has 'static bound, and thus is uninteresting\",\n-                           typ.repr());\n+                    debug!(\"trait: {:?} has 'static bound, and thus is uninteresting\",\n+                           typ);\n                     has_dtor_of_interest = false;\n                 }\n                 ty::ReEmpty => {\n-                    debug!(\"trait: {} has empty region bound, and thus is uninteresting\",\n-                           typ.repr());\n+                    debug!(\"trait: {:?} has empty region bound, and thus is uninteresting\",\n+                           typ);\n                     has_dtor_of_interest = false;\n                 }\n                 r => {\n-                    debug!(\"trait: {} has non-static bound: {}; assumed interesting\",\n-                           typ.repr(), r.repr());\n+                    debug!(\"trait: {:?} has non-static bound: {:?}; assumed interesting\",\n+                           typ, r);\n                     has_dtor_of_interest = true;\n                 }\n             }\n@@ -645,8 +642,8 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                     if result {\n                         has_pred_of_interest = true;\n-                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                               typ.repr(), pred.repr());\n+                        debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                               typ, pred);\n                         break 'items;\n                     }\n                 }\n@@ -670,14 +667,14 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 has_pred_of_interest;\n \n             if has_dtor_of_interest {\n-                debug!(\"typ: {} has interesting dtor, due to \\\n+                debug!(\"typ: {:?} has interesting dtor, due to \\\n                         region params: {} or pred: {}\",\n-                       typ.repr(),\n+                       typ,\n                        has_region_param_of_interest,\n                        has_pred_of_interest);\n             } else {\n-                debug!(\"typ: {} has dtor, but it is uninteresting\",\n-                       typ.repr());\n+                debug!(\"typ: {:?} has dtor, but it is uninteresting\",\n+                       typ);\n             }\n         }\n     }"}, {"sha": "fd93a2493db5aac32ba00ba579696fabd73946e3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -24,7 +24,6 @@ use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::iter::repeat;\n-use util::ppaux::Repr;\n \n struct ConfirmContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -56,10 +55,10 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n                          -> MethodCallee<'tcx>\n {\n-    debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n-           unadjusted_self_ty.repr(),\n-           pick.repr(),\n-           supplied_method_types.repr());\n+    debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n+           unadjusted_self_ty,\n+           pick,\n+           supplied_method_types);\n \n     let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr, call_expr);\n     confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n@@ -93,7 +92,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (method_types, method_regions) =\n             self.instantiate_method_substs(&pick, supplied_method_types);\n         let all_substs = rcvr_substs.with_method(method_types, method_regions);\n-        debug!(\"all_substs={}\", all_substs.repr());\n+        debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n@@ -225,10 +224,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n                         this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n-                    debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n-                           original_poly_trait_ref.repr(),\n-                           upcast_trait_ref.repr(),\n-                           trait_def_id.repr());\n+                    debug!(\"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n+                           original_poly_trait_ref,\n+                           upcast_trait_ref,\n+                           trait_def_id);\n                     let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n                         trait_ref: upcast_trait_ref,\n@@ -322,7 +321,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr()))\n+                            self_ty))\n             }\n         }\n     }\n@@ -376,10 +375,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             Err(_) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    &format!(\n-                        \"{} was a subtype of {} but now is not?\",\n-                        self_ty.repr(),\n-                        method_self_ty.repr()));\n+                    &format!(\"{} was a subtype of {} but now is not?\",\n+                             self_ty, method_self_ty));\n             }\n         }\n     }\n@@ -392,9 +389,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                               all_substs: subst::Substs<'tcx>)\n                               -> InstantiatedMethodSig<'tcx>\n     {\n-        debug!(\"instantiate_method_sig(pick={}, all_substs={})\",\n-               pick.repr(),\n-               all_substs.repr());\n+        debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n+               pick,\n+               all_substs);\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n@@ -404,8 +401,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n                                                                        &method_predicates);\n \n-        debug!(\"method_predicates after subst = {}\",\n-               method_predicates.repr());\n+        debug!(\"method_predicates after subst = {:?}\",\n+               method_predicates);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -415,12 +412,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // may reference those regions.\n         let method_sig = self.replace_late_bound_regions_with_fresh_var(\n             &pick.item.as_opt_method().unwrap().fty.sig);\n-        debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n-               method_sig.repr());\n+        debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n+               method_sig);\n \n         let method_sig = self.fcx.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n-        debug!(\"type scheme substituted, method_sig={}\",\n-               method_sig.repr());\n+        debug!(\"type scheme substituted, method_sig={:?}\",\n+               method_sig);\n \n         InstantiatedMethodSig {\n             method_sig: method_sig,\n@@ -433,10 +430,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                        pick: &probe::Pick<'tcx>,\n                        all_substs: &subst::Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n-        debug!(\"add_obligations: pick={} all_substs={} method_predicates={}\",\n-               pick.repr(),\n-               all_substs.repr(),\n-               method_predicates.repr());\n+        debug!(\"add_obligations: pick={:?} all_substs={:?} method_predicates={:?}\",\n+               pick,\n+               all_substs,\n+               method_predicates);\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n@@ -483,8 +480,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             }\n         }\n \n-        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n-               exprs.repr());\n+        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={:?}\",\n+               exprs);\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n@@ -498,8 +495,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 Some(_) | None => 0,\n             };\n \n-            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n-                   i, expr.repr(), autoderef_count);\n+            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={:?} \\\n+                                                                  autoderef_count={}\",\n+                   i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n@@ -545,8 +543,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 Some(_) => {\n                                     self.tcx().sess.span_bug(\n                                         base_expr.span,\n-                                        &format!(\"unexpected adjustment autoref {}\",\n-                                                adr.repr()));\n+                                        &format!(\"unexpected adjustment autoref {:?}\",\n+                                                adr));\n                                 }\n                             },\n                             None => (0, None),\n@@ -647,10 +645,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         if upcast_trait_refs.len() != 1 {\n             self.tcx().sess.span_bug(\n                 self.span,\n-                &format!(\"cannot uniquely upcast `{}` to `{}`: `{}`\",\n-                         source_trait_ref.repr(),\n-                         target_trait_def_id.repr(),\n-                         upcast_trait_refs.repr()));\n+                &format!(\"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n+                         source_trait_ref,\n+                         target_trait_def_id,\n+                         upcast_trait_refs));\n         }\n \n         upcast_trait_refs.into_iter().next().unwrap()"}, {"sha": "85a4b02cf804e5bf36f4f96f4a51c8a45cce59fd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -18,7 +18,6 @@ use middle::subst;\n use middle::traits;\n use middle::ty::{self, AsPredicate, ToPolyTraitRef};\n use middle::infer;\n-use util::ppaux::Repr;\n \n use syntax::ast::DefId;\n use syntax::ast;\n@@ -96,11 +95,11 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         self_expr: &'tcx ast::Expr)\n                         -> Result<ty::MethodCallee<'tcx>, MethodError>\n {\n-    debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\",\n-           method_name.repr(),\n-           self_ty.repr(),\n-           call_expr.repr(),\n-           self_expr.repr());\n+    debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n+           method_name,\n+           self_ty,\n+           call_expr,\n+           self_expr);\n \n     let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n@@ -141,11 +140,11 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n                                           -> Option<ty::MethodCallee<'tcx>>\n {\n-    debug!(\"lookup_in_trait_adjusted(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n-           self_ty.repr(),\n-           self_expr.repr(),\n-           m_name.repr(),\n-           trait_def_id.repr());\n+    debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, m_name={}, trait_def_id={:?})\",\n+           self_ty,\n+           self_expr,\n+           m_name,\n+           trait_def_id);\n \n     let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n \n@@ -190,8 +189,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n-    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n-           method_num, method_ty.repr());\n+    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={:?}\",\n+           method_num, method_ty);\n \n     // Instantiate late-bound regions and substitute the trait\n     // parameters into the method type to get the actual method type.\n@@ -210,9 +209,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         abi: method_ty.fty.abi.clone(),\n     }));\n \n-    debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\",\n-           fty.repr(),\n-           obligation.repr());\n+    debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n+           fty,\n+           obligation);\n \n     // Register obligations for the parameters.  This will include the\n     // `Self` parameter, which in turn has a bound of the main trait,\n@@ -272,7 +271,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 span,\n                                 &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr()));\n+                                    transformed_self_ty));\n                         }\n                     }\n                 }\n@@ -296,7 +295,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         substs: trait_ref.substs.clone()\n     };\n \n-    debug!(\"callee = {}\", callee.repr());\n+    debug!(\"callee = {:?}\", callee);\n \n     Some(callee)\n }"}, {"sha": "ecf6cad32be76430544ca03e6b736665197d543a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -28,7 +28,6 @@ use syntax::codemap::{Span, DUMMY_SP};\n use std::collections::HashSet;\n use std::mem;\n use std::rc::Rc;\n-use util::ppaux::Repr;\n \n use self::CandidateKind::*;\n pub use self::PickKind::*;\n@@ -127,8 +126,8 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, item_name={}, scope_expr_id={})\",\n-           self_ty.repr(),\n+    debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n+           self_ty,\n            item_name,\n            scope_expr_id);\n \n@@ -167,9 +166,9 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             Some(simplified_steps)\n         };\n \n-    debug!(\"ProbeContext: steps for self_ty={} are {}\",\n-           self_ty.repr(),\n-           steps.repr());\n+    debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n+           self_ty,\n+           steps);\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n@@ -272,8 +271,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n-        debug!(\"assemble_probe: self_ty={}\",\n-               self_ty.repr());\n+        debug!(\"assemble_probe: self_ty={:?}\",\n+               self_ty);\n \n         match self_ty.sty {\n             ty::TyTrait(box ref data) => {\n@@ -416,7 +415,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-               xform_self_ty.repr());\n+               xform_self_ty);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n@@ -428,8 +427,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n                                                 data: &ty::TraitTy<'tcx>) {\n-        debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n-               self_ty.repr());\n+        debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n+               self_ty);\n \n         let tcx = self.tcx();\n \n@@ -500,10 +499,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                    trait_ref.substs);\n \n             if let Some(ref m) = item.as_opt_method() {\n-                debug!(\"found match: trait_ref={} substs={} m={}\",\n-                       trait_ref.repr(),\n-                       trait_ref.substs.repr(),\n-                       m.repr());\n+                debug!(\"found match: trait_ref={:?} substs={:?} m={:?}\",\n+                       trait_ref,\n+                       trait_ref.substs,\n+                       m);\n                 assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n                            trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n@@ -543,7 +542,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             usize,\n         ),\n     {\n-        debug!(\"elaborate_bounds(bounds={})\", bounds.repr());\n+        debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n@@ -592,8 +591,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                trait_def_id: ast::DefId)\n                                                -> Result<(),MethodError>\n     {\n-        debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n-               trait_def_id.repr());\n+        debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n+               trait_def_id);\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n@@ -642,24 +641,25 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n         trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n-            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n-                   trait_def_id.repr(),\n-                   impl_def_id.repr());\n+            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n+                                                                  impl_def_id={:?}\",\n+                   trait_def_id,\n+                   impl_def_id);\n \n             if !self.impl_can_possibly_match(impl_def_id) {\n                 return;\n             }\n \n             let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n \n-            debug!(\"impl_substs={}\", impl_substs.repr());\n+            debug!(\"impl_substs={:?}\", impl_substs);\n \n             let impl_trait_ref =\n                 ty::impl_trait_ref(self.tcx(), impl_def_id)\n                 .unwrap() // we know this is a trait impl\n                 .subst(self.tcx(), &impl_substs);\n \n-            debug!(\"impl_trait_ref={}\", impl_trait_ref.repr());\n+            debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n@@ -675,7 +675,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n-            debug!(\"xform_self_ty={}\", xform_self_ty.repr());\n+            debug!(\"xform_self_ty={:?}\", xform_self_ty);\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -773,50 +773,50 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                       item_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n-               trait_def_id={}, \\\n-               item={}, \\\n+               trait_def_id={:?}, \\\n+               item={:?}, \\\n                item_index={})\",\n-               trait_def_id.repr(),\n-               item.repr(),\n+               trait_def_id,\n+               item,\n                item_index);\n \n         for step in self.steps.iter() {\n-            debug!(\"assemble_projection_candidates: step={}\",\n-                   step.repr());\n+            debug!(\"assemble_projection_candidates: step={:?}\",\n+                   step);\n \n             let projection_trait_ref = match step.self_ty.sty {\n                 ty::TyProjection(ref data) => &data.trait_ref,\n                 _ => continue,\n             };\n \n-            debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n-                   projection_trait_ref.repr());\n+            debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n+                   projection_trait_ref);\n \n             let trait_predicates = ty::lookup_predicates(self.tcx(),\n                                                          projection_trait_ref.def_id);\n             let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n-            debug!(\"assemble_projection_candidates: predicates={}\",\n-                   predicates.repr());\n+            debug!(\"assemble_projection_candidates: predicates={:?}\",\n+                   predicates);\n             for poly_bound in\n                 traits::elaborate_predicates(self.tcx(), predicates)\n                 .filter_map(|p| p.to_opt_poly_trait_ref())\n                 .filter(|b| b.def_id() == trait_def_id)\n             {\n                 let bound = self.erase_late_bound_regions(&poly_bound);\n \n-                debug!(\"assemble_projection_candidates: projection_trait_ref={} bound={}\",\n-                       projection_trait_ref.repr(),\n-                       bound.repr());\n+                debug!(\"assemble_projection_candidates: projection_trait_ref={:?} bound={:?}\",\n+                       projection_trait_ref,\n+                       bound);\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n \n-                    debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n-                           bound.repr(),\n-                           xform_self_ty.repr());\n+                    debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n+                           bound,\n+                           xform_self_ty);\n \n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n@@ -833,8 +833,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                         item: ty::ImplOrTraitItem<'tcx>,\n                                         item_index: usize)\n     {\n-        debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n-               trait_def_id.repr());\n+        debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n+               trait_def_id);\n \n         let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n@@ -846,9 +846,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                    bound.self_ty(),\n                                                    bound.substs);\n \n-            debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n-                   bound.repr(),\n-                   xform_self_ty.repr());\n+            debug!(\"assemble_where_clause_candidates: bound={:?} xform_self_ty={:?}\",\n+                   bound,\n+                   xform_self_ty);\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -914,7 +914,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_step: step={}\", step.repr());\n+        debug!(\"pick_step: step={:?}\", step);\n \n         if ty::type_is_error(step.self_ty) {\n             return None;\n@@ -1012,7 +1012,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                   .filter(|&probe| self.consider_probe(self_ty, probe))\n                   .collect();\n \n-        debug!(\"applicable_candidates: {}\", applicable_candidates.repr());\n+        debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n             match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n@@ -1033,9 +1033,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>) -> bool {\n-        debug!(\"consider_probe: self_ty={} probe={}\",\n-               self_ty.repr(),\n-               probe.repr());\n+        debug!(\"consider_probe: self_ty={:?} probe={:?}\",\n+               self_ty,\n+               probe);\n \n         self.infcx().probe(|_| {\n             // First check that the self type can be related.\n@@ -1068,7 +1068,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     let obligations =\n                         traits::predicates_for_generics(cause.clone(),\n                                                         &impl_bounds);\n-                    debug!(\"impl_obligations={}\", obligations.repr());\n+                    debug!(\"impl_obligations={:?}\", obligations);\n \n                     // Evaluate those obligations to see if they might possibly hold.\n                     obligations.iter()\n@@ -1180,10 +1180,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                             substs: &subst::Substs<'tcx>)\n                             -> Ty<'tcx>\n     {\n-        debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n-               impl_ty.repr(),\n-               method.fty.sig.0.inputs.get(0).repr(),\n-               substs.repr());\n+        debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n+               impl_ty,\n+               method.fty.sig.0.inputs.get(0),\n+               substs);\n \n         assert!(!substs.has_escaping_regions());\n "}, {"sha": "b098fb56d4db62b20365cdc5d39cc0d7ea02f5d9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -18,7 +18,6 @@ use check::{self, FnCtxt};\n use middle::ty::{self, Ty};\n use middle::def;\n use metadata::{csearch, cstore, decoder};\n-use util::ppaux::UserString;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n@@ -45,7 +44,6 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match error {\n         MethodError::NoMatch(static_sources, out_of_scope_traits, mode) => {\n             let cx = fcx.tcx();\n-            let item_ustring = item_name.user_string();\n \n             fcx.type_error_message(\n                 span,\n@@ -54,7 +52,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              in the current scope\",\n                             if mode == Mode::MethodCall { \"method\" }\n                             else { \"associated item\" },\n-                            item_ustring,\n+                            item_name,\n                             actual)\n                 },\n                 rcvr_ty,\n@@ -66,7 +64,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if fields.iter().any(|f| f.name == item_name) {\n                     cx.sess.span_note(span,\n                         &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                                 function stored in the `{0}` field\", item_ustring));\n+                                 function stored in the `{0}` field\", item_name));\n                 }\n             }\n \n@@ -93,7 +91,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n-                               item_name.user_string(),\n+                               item_name,\n                                ty::item_path_str(fcx.tcx(), trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n@@ -134,7 +132,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n                                idx + 1,\n                                insertion,\n-                               impl_ty.user_string());\n+                               impl_ty);\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n                     let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n@@ -160,7 +158,6 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n-    let item_ustring = item_name.user_string();\n \n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n@@ -217,7 +214,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n              perhaps you need to implement {one_of_them}:\",\n             traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n-            name = item_ustring);\n+            name = item_name);\n \n         fcx.sess().fileline_help(span, &msg[..]);\n "}, {"sha": "34df349b7a3db373c885c57ea970eb468f85cf45", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 76, "deletions": 81, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -106,7 +106,6 @@ use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n-use util::ppaux::{Repr, UserString};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n@@ -567,8 +566,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n             None => None\n         };\n         self.assign(local.span, local.id, o_ty);\n-        debug!(\"Local variable {} is assigned type {}\",\n-               self.fcx.pat_to_string(&*local.pat),\n+        debug!(\"Local variable {:?} is assigned type {}\",\n+               local.pat,\n                self.fcx.infcx().ty_to_string(\n                    self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n         visit::walk_local(self, local);\n@@ -583,11 +582,11 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 self.fcx.require_type_is_sized(var_ty, p.span,\n                                                traits::VariableType(p.id));\n \n-                debug!(\"Pattern binding {} is assigned to {} with type {}\",\n+                debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                        token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_string(\n                            self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n-                       var_ty.repr());\n+                       var_ty);\n             }\n         }\n         visit::walk_pat(self, p);\n@@ -641,9 +640,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n-           arg_tys.repr(),\n-           ret_ty.repr(),\n+    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?}, fn_id={})\",\n+           arg_tys,\n+           ret_ty,\n            fn_id);\n \n     // Create the function context.  This is either derived from scratch or,\n@@ -669,9 +668,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fn_sig_tys.push(ret_ty);\n     }\n \n-    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={}\",\n+    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={:?}\",\n            fn_id,\n-           fn_sig_tys.repr());\n+           fn_sig_tys);\n \n     inherited.fn_sig_map.borrow_mut().insert(fn_id, fn_sig_tys);\n \n@@ -918,12 +917,12 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                sig: &'tcx ast::MethodSig,\n                                body: &'tcx ast::Block,\n                                id: ast::NodeId, span: Span) {\n-    debug!(\"check_method_body(item_generics={}, id={})\",\n-            item_generics.repr(), id);\n+    debug!(\"check_method_body(item_generics={:?}, id={})\",\n+            item_generics, id);\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    debug!(\"check_method_body: fty={}\", fty.repr());\n+    debug!(\"check_method_body: fty={:?}\", fty);\n \n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n@@ -963,9 +962,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             _ => {\n                                 span_err!(tcx.sess, impl_item.span, E0323,\n                                           \"item `{}` is an associated const, \\\n-                                          which doesn't match its trait `{}`\",\n+                                          which doesn't match its trait `{:?}`\",\n                                           token::get_name(impl_const_ty.name()),\n-                                          impl_trait_ref.repr())\n+                                          impl_trait_ref)\n                             }\n                         }\n                     }\n@@ -976,9 +975,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             impl_item.span,\n                             &format!(\n                                 \"associated const `{}` is not a member of \\\n-                                 trait `{}`\",\n+                                 trait `{:?}`\",\n                                 token::get_name(impl_const_ty.name()),\n-                                impl_trait_ref.repr()));\n+                                impl_trait_ref));\n                     }\n                 }\n             }\n@@ -1009,9 +1008,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             _ => {\n                                 span_err!(tcx.sess, impl_item.span, E0324,\n                                           \"item `{}` is an associated method, \\\n-                                          which doesn't match its trait `{}`\",\n+                                          which doesn't match its trait `{:?}`\",\n                                           token::get_name(impl_item_ty.name()),\n-                                          impl_trait_ref.repr())\n+                                          impl_trait_ref)\n                             }\n                         }\n                     }\n@@ -1020,9 +1019,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n                             impl_item.span,\n-                            &format!(\"method `{}` is not a member of trait `{}`\",\n+                            &format!(\"method `{}` is not a member of trait `{:?}`\",\n                                      token::get_name(impl_item_ty.name()),\n-                                     impl_trait_ref.repr()));\n+                                     impl_trait_ref));\n                     }\n                 }\n             }\n@@ -1043,9 +1042,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             _ => {\n                                 span_err!(tcx.sess, impl_item.span, E0325,\n                                           \"item `{}` is an associated type, \\\n-                                          which doesn't match its trait `{}`\",\n+                                          which doesn't match its trait `{:?}`\",\n                                           token::get_name(typedef_ty.name()),\n-                                          impl_trait_ref.repr())\n+                                          impl_trait_ref)\n                             }\n                         }\n                     }\n@@ -1056,9 +1055,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             impl_item.span,\n                             &format!(\n                                 \"associated type `{}` is not a member of \\\n-                                 trait `{}`\",\n+                                 trait `{:?}`\",\n                                 token::get_name(typedef_ty.name()),\n-                                impl_trait_ref.repr()));\n+                                impl_trait_ref));\n                     }\n                 }\n             }\n@@ -1295,26 +1294,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// version, this version will also select obligations if it seems\n     /// useful, in an effort to get more type information.\n     fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type_vars_if_possible(ty={})\", ty.repr());\n+        debug!(\"resolve_type_vars_if_possible(ty={:?})\", ty);\n \n         // No ty::infer()? Nothing needs doing.\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n+            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n+            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n         self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n+            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n@@ -1325,7 +1324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.select_obligations_where_possible();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n \n-        debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n+        debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n         ty\n     }\n \n@@ -1395,16 +1394,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-        debug!(\"write_ty({}, {}) in fcx {}\",\n-               node_id, ty.repr(), self.tag());\n+        debug!(\"write_ty({}, {:?}) in fcx {}\",\n+               node_id, ty, self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n-            debug!(\"write_substs({}, {}) in fcx {}\",\n+            debug!(\"write_substs({}, {:?}) in fcx {}\",\n                    node_id,\n-                   substs.repr(),\n+                   substs,\n                    self.tag());\n \n             self.inh.item_substs.borrow_mut().insert(node_id, substs);\n@@ -1427,7 +1426,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             adj: ty::AutoAdjustment<'tcx>) {\n-        debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj.repr());\n+        debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n             return;\n@@ -1448,10 +1447,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n-        debug!(\"instantiate_type_scheme(value={}, substs={}) = {}\",\n-               value.repr(),\n-               substs.repr(),\n-               result.repr());\n+        debug!(\"instantiate_type_scheme(value={:?}, substs={:?}) = {:?}\",\n+               value,\n+               substs,\n+               result);\n         result\n     }\n \n@@ -1615,8 +1614,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn register_predicate(&self,\n                               obligation: traits::PredicateObligation<'tcx>)\n     {\n-        debug!(\"register_predicate({})\",\n-               obligation.repr());\n+        debug!(\"register_predicate({:?})\",\n+               obligation);\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self.infcx(), obligation);\n@@ -1633,10 +1632,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         t\n     }\n \n-    pub fn pat_to_string(&self, pat: &ast::Pat) -> String {\n-        pat.repr()\n-    }\n-\n     pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n@@ -1784,8 +1779,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         assert!(!predicates.has_escaping_regions());\n \n-        debug!(\"add_obligations_for_parameters(predicates={})\",\n-               predicates.repr());\n+        debug!(\"add_obligations_for_parameters(predicates={:?})\",\n+               predicates);\n \n         for obligation in traits::predicates_for_generics(cause, predicates) {\n             self.register_predicate(obligation);\n@@ -1940,9 +1935,9 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  -> (Ty<'tcx>, usize, Option<T>)\n     where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n-    debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n-           base_ty.repr(),\n-           opt_expr.repr(),\n+    debug!(\"autoderef(base_ty={:?}, opt_expr={:?}, lvalue_pref={:?})\",\n+           base_ty,\n+           opt_expr,\n            lvalue_pref);\n \n     let mut t = base_ty;\n@@ -2002,8 +1997,8 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // We've reached the recursion limit, error gracefully.\n     span_err!(fcx.tcx().sess, sp, E0055,\n-        \"reached the recursion limit while auto-dereferencing {}\",\n-        base_ty.repr());\n+        \"reached the recursion limit while auto-dereferencing {:?}\",\n+        base_ty);\n     (fcx.tcx().types.err, 0, None)\n }\n \n@@ -2118,14 +2113,14 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     let tcx = fcx.tcx();\n-    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, \\\n-                           autoderefs={}, unsize={}, index_ty={})\",\n-           expr.repr(),\n-           base_expr.repr(),\n-           adjusted_ty.repr(),\n+    debug!(\"try_index_step(expr={:?}, base_expr.id={:?}, adjusted_ty={:?}, \\\n+                           autoderefs={}, unsize={}, index_ty={:?})\",\n+           expr,\n+           base_expr,\n+           adjusted_ty,\n            autoderefs,\n            unsize,\n-           index_ty.repr());\n+           index_ty);\n \n     let input_ty = fcx.infcx().next_ty_var();\n \n@@ -2604,9 +2599,9 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             None\n         }\n     }).unwrap_or(vec![]);\n-    debug!(\"expected_types_for_fn_args(formal={} -> {}, expected={} -> {})\",\n-           formal_args.repr(), formal_ret.repr(),\n-           expected_args.repr(), expected_ret.repr());\n+    debug!(\"expected_types_for_fn_args(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n+           formal_args, formal_ret,\n+           expected_args, expected_ret);\n     expected_args\n }\n \n@@ -2627,8 +2622,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                         unifier: F) where\n     F: FnOnce(),\n {\n-    debug!(\">> typechecking: expr={} expected={}\",\n-           expr.repr(), expected.repr());\n+    debug!(\">> typechecking: expr={:?} expected={:?}\",\n+           expr, expected);\n \n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2744,7 +2739,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   |base_t, _| {\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n-                        debug!(\"struct named {}\",  base_t.repr());\n+                        debug!(\"struct named {:?}\",  base_t);\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n                         fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n@@ -2848,7 +2843,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::TyStruct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n-                            debug!(\"tuple struct named {}\",  base_t.repr());\n+                            debug!(\"tuple struct named {:?}\",  base_t);\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n                             fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n@@ -3274,7 +3269,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             } else {\n               tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {}\", expr.repr()))\n+                                &format!(\"unbound path {:?}\", expr))\n           };\n \n           if let Some((opt_ty, segments, def)) =\n@@ -3744,9 +3739,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     debug!(\"type of expr({}) {} is...\", expr.id,\n            syntax::print::pprust::expr_to_string(expr));\n-    debug!(\"... {}, expected is {}\",\n-           fcx.expr_ty(expr).repr(),\n-           expected.repr());\n+    debug!(\"... {:?}, expected is {:?}\",\n+           fcx.expr_ty(expr),\n+           expected);\n \n     unifier();\n }\n@@ -4179,8 +4174,8 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n         span_err!(tcx.sess, sp, E0073,\n             \"this type cannot be instantiated without an \\\n              instance of itself\");\n-        fileline_help!(tcx.sess, sp, \"consider using `Option<{}>`\",\n-             item_ty.repr());\n+        fileline_help!(tcx.sess, sp, \"consider using `Option<{:?}>`\",\n+             item_ty);\n         false\n     } else {\n         true\n@@ -4371,11 +4366,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n-    debug!(\"instantiate_path(path={:?}, def={}, node_id={}, type_scheme={})\",\n+    debug!(\"instantiate_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n            segments,\n-           def.repr(),\n+           def,\n            node_id,\n-           type_scheme.repr());\n+           type_scheme);\n \n     // We need to extract the type parameters supplied by the user in\n     // the path `path`. Due to the current setup, this is a bit of a\n@@ -4615,9 +4610,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         if fcx.mk_subty(false, infer::Misc(span), self_ty, impl_ty).is_err() {\n             fcx.tcx().sess.span_bug(span,\n             &format!(\n-                \"instantiate_path: (UFCS) {} was a subtype of {} but now is not?\",\n-                self_ty.repr(),\n-                impl_ty.repr()));\n+                \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                self_ty,\n+                impl_ty));\n         }\n     }\n \n@@ -4822,7 +4817,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         assert_eq!(substs.types.len(space), desired.len());\n \n-        debug!(\"Final substs: {}\", substs.repr());\n+        debug!(\"Final substs: {:?}\", substs);\n     }\n \n     fn adjust_region_parameters(\n@@ -4931,8 +4926,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        span: Span,\n                                        tps: &OwnedSlice<ast::TyParam>,\n                                        ty: Ty<'tcx>) {\n-    debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n-           tps.len(),  ty.repr());\n+    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n+           tps.len(),  ty);\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.is_empty() { return; }\n@@ -5255,7 +5250,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                            fty,\n                            || {\n                 format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty.user_string())\n+                         fty)\n             });\n     }\n }"}, {"sha": "a5e4e0fab5963795012ea8be23f324817368e787", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{self, Ty};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n-use util::ppaux::{Repr, UserString};\n \n /// Check a `a <op>= b`\n pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -51,8 +50,8 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         span_err!(tcx.sess, lhs_expr.span, E0368,\n                   \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n                   ast_util::binop_to_string(op.node),\n-                  lhs_ty.user_string(),\n-                  rhs_ty.user_string());\n+                  lhs_ty,\n+                  rhs_ty);\n         fcx.write_error(expr.id);\n     }\n \n@@ -73,12 +72,12 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let tcx = fcx.ccx.tcx;\n \n-    debug!(\"check_binop(expr.id={}, expr={}, op={:?}, lhs_expr={}, rhs_expr={})\",\n+    debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n            expr.id,\n-           expr.repr(),\n+           expr,\n            op,\n-           lhs_expr.repr(),\n-           rhs_expr.repr());\n+           lhs_expr,\n+           rhs_expr);\n \n     check_expr(fcx, lhs_expr);\n     let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n@@ -180,16 +179,16 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // if this is simd, result is same as lhs, else bool\n             if ty::type_is_simd(tcx, lhs_ty) {\n                 let unit_ty = ty::simd_type(tcx, lhs_ty);\n-                debug!(\"enforce_builtin_binop_types: lhs_ty={} unit_ty={}\",\n-                       lhs_ty.repr(),\n-                       unit_ty.repr());\n+                debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n+                       lhs_ty,\n+                       unit_ty);\n                 if !ty::type_is_integral(unit_ty) {\n                     tcx.sess.span_err(\n                         lhs_expr.span,\n                         &format!(\"binary comparison operation `{}` not supported \\\n                                   for floating point SIMD vector `{}`\",\n                                  ast_util::binop_to_string(op.node),\n-                                 lhs_ty.user_string()));\n+                                 lhs_ty));\n                     tcx.types.err\n                 } else {\n                     lhs_ty\n@@ -209,9 +208,9 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     op: ast::BinOp)\n                                     -> (Ty<'tcx>, Ty<'tcx>)\n {\n-    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={})\",\n+    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?})\",\n            expr.id,\n-           lhs_ty.repr());\n+           lhs_ty);\n \n     let (name, trait_def_id) = name_and_trait_def_id(fcx, op);\n \n@@ -233,7 +232,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n                           \"binary operation `{}` cannot be applied to type `{}`\",\n                           ast_util::binop_to_string(op.node),\n-                          lhs_ty.user_string());\n+                          lhs_ty);\n             }\n             fcx.tcx().types.err\n         }\n@@ -304,12 +303,12 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                               lhs_expr: &'a ast::Expr)\n                               -> Result<Ty<'tcx>,()>\n {\n-    debug!(\"lookup_op_method(expr={}, lhs_ty={}, opname={:?}, trait_did={}, lhs_expr={})\",\n-           expr.repr(),\n-           lhs_ty.repr(),\n+    debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, trait_did={:?}, lhs_expr={:?})\",\n+           expr,\n+           lhs_ty,\n            opname,\n-           trait_did.repr(),\n-           lhs_expr.repr());\n+           trait_did,\n+           lhs_expr);\n \n     let method = match trait_did {\n         Some(trait_did) => {"}, {"sha": "a96e7864fe679c8a4d63e69d16c8e79e4100f48c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -94,7 +94,6 @@ use middle::traits;\n use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n-use util::ppaux::{Repr, UserString};\n \n use std::mem;\n use syntax::{ast, ast_util};\n@@ -321,8 +320,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                                        .to_vec();\n \n         for r_o in &region_obligations {\n-            debug!(\"visit_region_obligations: r_o={}\",\n-                   r_o.repr());\n+            debug!(\"visit_region_obligations: r_o={:?}\",\n+                   r_o);\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateParamBound(r_o.cause.span, sup_type);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n@@ -351,7 +350,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n-            debug!(\"relate_free_regions(t={})\", ty.repr());\n+            debug!(\"relate_free_regions(t={:?})\", ty);\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n             let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n@@ -364,16 +363,16 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             // that don't go into the free-region-map but which we use\n             // here.\n             for implication in implications {\n-                debug!(\"implication: {}\", implication.repr());\n+                debug!(\"implication: {:?}\", implication);\n                 match implication {\n                     implicator::Implication::RegionSubRegion(_,\n                                                              ty::ReFree(free_a),\n                                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n                     implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGeneric: {} <= {}\",\n-                               r_a.repr(), generic_b.repr());\n+                        debug!(\"RegionSubGeneric: {:?} <= {:?}\",\n+                               r_a, generic_b);\n \n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n@@ -464,7 +463,7 @@ fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n \n fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n-    debug!(\"regionck::visit_pat(pat={})\", pat.repr());\n+    debug!(\"regionck::visit_pat(pat={:?})\", pat);\n     pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n@@ -501,8 +500,8 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n-    debug!(\"regionck::visit_expr(e={}, repeating_scope={})\",\n-           expr.repr(), rcx.repeating_scope);\n+    debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+           expr, rcx.repeating_scope);\n \n     // No matter what, the type of each expression must outlive the\n     // scope of that expression. This also guarantees basic WF.\n@@ -744,9 +743,9 @@ fn constrain_cast(rcx: &mut Rcx,\n                   cast_expr: &ast::Expr,\n                   source_expr: &ast::Expr)\n {\n-    debug!(\"constrain_cast(cast_expr={}, source_expr={})\",\n-           cast_expr.repr(),\n-           source_expr.repr());\n+    debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n+           cast_expr,\n+           source_expr);\n \n     let source_ty = rcx.resolve_node_type(source_expr.id);\n     let target_ty = rcx.resolve_node_type(cast_expr.id);\n@@ -757,9 +756,9 @@ fn constrain_cast(rcx: &mut Rcx,\n                            cast_expr: &ast::Expr,\n                            from_ty: Ty<'tcx>,\n                            to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={}, to_ty={})\",\n-               from_ty.repr(),\n-               to_ty.repr());\n+        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\",\n+               from_ty,\n+               to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n@@ -807,7 +806,7 @@ fn constrain_callee(rcx: &mut Rcx,\n             //\n             // tcx.sess.span_bug(\n             //     callee_expr.span,\n-            //     format!(\"Calling non-function: {}\", callee_ty.repr()));\n+            //     format!(\"Calling non-function: {}\", callee_ty));\n         }\n     }\n }\n@@ -822,11 +821,11 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     //! in the type of the function. Also constrains the regions that\n     //! appear in the arguments appropriately.\n \n-    debug!(\"constrain_call(call_expr={}, \\\n-            receiver={}, \\\n+    debug!(\"constrain_call(call_expr={:?}, \\\n+            receiver={:?}, \\\n             implicitly_ref_args={})\",\n-            call_expr.repr(),\n-            receiver.repr(),\n+            call_expr,\n+            receiver,\n             implicitly_ref_args);\n \n     // `callee_region` is the scope representing the time in which the\n@@ -836,10 +835,10 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     let callee_scope = CodeExtent::from_node_id(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n-    debug!(\"callee_region={}\", callee_region.repr());\n+    debug!(\"callee_region={:?}\", callee_region);\n \n     for arg_expr in arg_exprs {\n-        debug!(\"Argument: {}\", arg_expr.repr());\n+        debug!(\"Argument: {:?}\", arg_expr);\n \n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n@@ -858,7 +857,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n \n     // as loop above, but for receiver\n     if let Some(r) = receiver {\n-        debug!(\"receiver: {}\", r.repr());\n+        debug!(\"receiver: {:?}\", r);\n         type_of_node_must_outlive(\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n@@ -875,10 +874,10 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   derefs: usize,\n                                   mut derefd_ty: Ty<'tcx>)\n {\n-    debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n-           deref_expr.repr(),\n+    debug!(\"constrain_autoderefs(deref_expr={:?}, derefs={}, derefd_ty={:?})\",\n+           deref_expr,\n            derefs,\n-           derefd_ty.repr());\n+           derefd_ty);\n \n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in 0..derefs {\n@@ -887,8 +886,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n         derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n-                debug!(\"constrain_autoderefs: #{} is overloaded, method={}\",\n-                       i, method.repr());\n+                debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n+                       i, method);\n \n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n@@ -901,19 +900,19 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     _ => {\n                         rcx.tcx().sess.span_bug(\n                             deref_expr.span,\n-                            &format!(\"bad overloaded deref type {}\",\n-                                     method.ty.repr()))\n+                            &format!(\"bad overloaded deref type {:?}\",\n+                                     method.ty))\n                     }\n                 };\n \n                 debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n-                       r.repr(), m);\n+                       r, m);\n \n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n-                           self_cmt.repr());\n+                           self_cmt);\n                     link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -974,8 +973,8 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n                        .sess\n                        .span_bug(span,\n                                  &format!(\"unexpected rvalue region in rvalue \\\n-                                           destructor safety checking: `{}`\",\n-                                          region.repr()));\n+                                           destructor safety checking: `{:?}`\",\n+                                          region));\n                 }\n             }\n         }\n@@ -1023,7 +1022,7 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n-            ty.user_string(),  ty0.user_string(),\n+            ty,  ty0,\n            id, minimum_lifetime);\n     type_must_outlive(rcx, origin, ty, minimum_lifetime);\n }\n@@ -1032,14 +1031,14 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n                 mutability: ast::Mutability, base: &ast::Expr) {\n-    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(), base.repr());\n+    debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n \n-    debug!(\"link_addr_of: cmt={}\", cmt.repr());\n+    debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1065,7 +1064,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n-    debug!(\"discr_cmt={}\", discr_cmt.repr());\n+    debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n         for root_pat in &arm.pats {\n             link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n@@ -1083,9 +1082,9 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n-        debug!(\"arg_ty={} arg_cmt={}\",\n-               arg_ty.repr(),\n-               arg_cmt.repr());\n+        debug!(\"arg_ty={:?} arg_cmt={:?}\",\n+               arg_ty,\n+               arg_cmt);\n         link_pattern(rcx, mc, arg_cmt, &*arg.pat);\n     }\n }\n@@ -1096,9 +1095,9 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                           mc: mc::MemCategorizationContext<FnCtxt<'a, 'tcx>>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n-    debug!(\"link_pattern(discr_cmt={}, root_pat={})\",\n-           discr_cmt.repr(),\n-           root_pat.repr());\n+    debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n+           discr_cmt,\n+           root_pat);\n     let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n             match sub_pat.node {\n                 // `ref x` pattern\n@@ -1134,7 +1133,7 @@ fn link_autoref(rcx: &Rcx,\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n-    debug!(\"expr_cmt={}\", expr_cmt.repr());\n+    debug!(\"expr_cmt={:?}\", expr_cmt);\n \n     match *autoref {\n         ty::AutoPtr(r, m) => {\n@@ -1154,8 +1153,8 @@ fn link_autoref(rcx: &Rcx,\n fn link_by_ref(rcx: &Rcx,\n                expr: &ast::Expr,\n                callee_scope: CodeExtent) {\n-    debug!(\"link_by_ref(expr={}, callee_scope={:?})\",\n-           expr.repr(), callee_scope);\n+    debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n+           expr, callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n@@ -1169,13 +1168,13 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                         id: ast::NodeId,\n                                         mutbl: ast::Mutability,\n                                         cmt_borrowed: mc::cmt<'tcx>) {\n-    debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={})\",\n-           id, mutbl, cmt_borrowed.repr());\n+    debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n+           id, mutbl, cmt_borrowed);\n \n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"rptr_ty={}\",  rptr_ty.user_string());\n+        debug!(\"rptr_ty={}\",  rptr_ty);\n         let r = ty::ty_region(tcx, span, rptr_ty);\n         link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);\n@@ -1194,10 +1193,10 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let mut borrow_kind = borrow_kind;\n \n     loop {\n-        debug!(\"link_region(borrow_region={}, borrow_kind={}, borrow_cmt={})\",\n-               borrow_region.repr(),\n-               borrow_kind.repr(),\n-               borrow_cmt.repr());\n+        debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n+               borrow_region,\n+               borrow_kind,\n+               borrow_cmt);\n         match borrow_cmt.cat.clone() {\n             mc::cat_deref(ref_cmt, _,\n                           mc::Implicit(ref_kind, ref_region)) |\n@@ -1307,8 +1306,8 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 _ => {\n                     rcx.tcx().sess.span_bug(\n                         span,\n-                        &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr()));\n+                        &format!(\"Illegal upvar id: {:?}\",\n+                                upvar_id));\n                 }\n             }\n         }\n@@ -1323,9 +1322,9 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"link_reborrowed_region: {} <= {}\",\n-           borrow_region.repr(),\n-           ref_region.repr());\n+    debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n+           borrow_region,\n+           ref_region);\n     rcx.fcx.mk_subr(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n@@ -1398,14 +1397,14 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                ty: Ty<'tcx>,\n                                region: ty::Region)\n {\n-    debug!(\"type_must_outlive(ty={}, region={})\",\n-           ty.repr(),\n-           region.repr());\n+    debug!(\"type_must_outlive(ty={:?}, region={:?})\",\n+           ty,\n+           region);\n \n     let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n                                                 ty, region, origin.span());\n     for implication in implications {\n-        debug!(\"implication: {}\", implication.repr());\n+        debug!(\"implication: {:?}\", implication);\n         match implication {\n             implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n                 rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n@@ -1440,8 +1439,8 @@ fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   region: ty::Region,\n                                   def_id: ast::DefId,\n                                   substs: &'tcx Substs<'tcx>) {\n-    debug!(\"closure_must_outlive(region={}, def_id={}, substs={})\",\n-           region.repr(), def_id.repr(), substs.repr());\n+    debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n+           region, def_id, substs);\n \n     let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n     for upvar in upvars {\n@@ -1458,9 +1457,9 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   generic: &GenericKind<'tcx>) {\n     let param_env = &rcx.fcx.inh.param_env;\n \n-    debug!(\"param_must_outlive(region={}, generic={})\",\n-           region.repr(),\n-           generic.repr());\n+    debug!(\"param_must_outlive(region={:?}, generic={:?})\",\n+           region,\n+           generic);\n \n     // To start, collect bounds from user:\n     let mut param_bounds =\n@@ -1493,9 +1492,9 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n     for &(ref r, ref p) in &rcx.region_bound_pairs {\n-        debug!(\"generic={} p={}\",\n-               generic.repr(),\n-               p.repr());\n+        debug!(\"generic={:?} p={:?}\",\n+               generic,\n+               p);\n         if generic == p {\n             param_bounds.push(*r);\n         }\n@@ -1518,8 +1517,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let tcx = fcx.tcx();\n     let infcx = fcx.infcx();\n \n-    debug!(\"projection_bounds(projection_ty={})\",\n-           projection_ty.repr());\n+    debug!(\"projection_bounds(projection_ty={:?})\",\n+           projection_ty);\n \n     let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n \n@@ -1543,16 +1542,16 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 _ => { return None; }\n             };\n \n-            debug!(\"projection_bounds: outlives={} (1)\",\n-                   outlives.repr());\n+            debug!(\"projection_bounds: outlives={:?} (1)\",\n+                   outlives);\n \n             // apply the substitutions (and normalize any projected types)\n             let outlives = fcx.instantiate_type_scheme(span,\n                                                        projection_ty.trait_ref.substs,\n                                                        &outlives);\n \n-            debug!(\"projection_bounds: outlives={} (2)\",\n-                   outlives.repr());\n+            debug!(\"projection_bounds: outlives={:?} (2)\",\n+                   outlives);\n \n             let region_result = infcx.commit_if_ok(|_| {\n                 let (outlives, _) =\n@@ -1561,8 +1560,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                         infer::AssocTypeProjection(projection_ty.item_name),\n                         &outlives);\n \n-                debug!(\"projection_bounds: outlives={} (3)\",\n-                       outlives.repr());\n+                debug!(\"projection_bounds: outlives={:?} (3)\",\n+                       outlives);\n \n                 // check whether this predicate applies to our current projection\n                 match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n@@ -1571,8 +1570,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 }\n             });\n \n-            debug!(\"projection_bounds: region_result={}\",\n-                   region_result.repr());\n+            debug!(\"projection_bounds: region_result={:?}\",\n+                   region_result);\n \n             region_result.ok()\n         })"}, {"sha": "99e6309918c9728860f23de91cd4efafc41b10ab", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -51,7 +51,6 @@ use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -133,8 +132,8 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n         if !self.fcx.inh.closure_kinds.borrow().contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n             self.fcx.inh.closure_kinds.borrow_mut().insert(closure_def_id, ty::FnClosureKind);\n-            debug!(\"check_closure: adding closure_id={} to closures_with_inferred_kinds\",\n-                   closure_def_id.repr());\n+            debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n+                   closure_def_id);\n         }\n \n         ty::with_freevars(self.tcx(), expr.id, |freevars| {\n@@ -241,8 +240,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n     {\n-        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={}, mode={:?})\",\n-               cmt.repr(), mode);\n+        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n+               cmt, mode);\n \n         // we only care about moves\n         match mode {\n@@ -254,8 +253,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         // for that to be legal, the upvar would have to be borrowed\n         // by value instead\n         let guarantor = cmt.guarantor();\n-        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={}\",\n-               guarantor.repr());\n+        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n+               guarantor);\n         match guarantor.cat {\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(_, _, mc::Implicit(..)) => {\n@@ -292,8 +291,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n     fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n-               cmt.repr());\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\",\n+               cmt);\n \n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::Unique) |\n@@ -326,8 +325,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     }\n \n     fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n-               cmt.repr());\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\",\n+               cmt);\n \n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::Unique) |\n@@ -494,7 +493,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode)\n     {\n-        debug!(\"consume(cmt={},mode={:?})\", cmt.repr(), mode);\n+        debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n@@ -509,7 +508,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode)\n     {\n-        debug!(\"consume_pat(cmt={},mode={:?})\", cmt.repr(), mode);\n+        debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n@@ -521,8 +520,8 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, bk={:?})\",\n-               borrow_id, cmt.repr(), bk);\n+        debug!(\"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n+               borrow_id, cmt, bk);\n \n         match bk {\n             ty::ImmBorrow => { }\n@@ -546,8 +545,8 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               _mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignee_cmt={})\",\n-               assignee_cmt.repr());\n+        debug!(\"mutate(assignee_cmt={:?})\",\n+               assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }"}, {"sha": "c048845892c4b7f1d364958bdc65526647da6d35", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -18,7 +18,6 @@ use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n-use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use syntax::ast;\n@@ -350,15 +349,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          param_name: ast::Name)\n     {\n         span_err!(self.tcx().sess, span, E0392,\n-            \"parameter `{}` is never used\", param_name.user_string());\n+            \"parameter `{}` is never used\", param_name);\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 self.tcx().sess.fileline_help(\n                     span,\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                             param_name.user_string(),\n+                             param_name,\n                              ty::item_path_str(self.tcx(), def_id)));\n             }\n             None => {\n@@ -395,7 +394,7 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n             \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr())\n+                bounded_ty)\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -543,16 +542,16 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n             self.fcx.tcx(),\n             region::DestructionScopeData::new(self.scope),\n             binder);\n-        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {} at scope: {:?}\",\n-               value.repr(), self.scope);\n+        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {:?} at scope: {:?}\",\n+               value, self.scope);\n         let value = value.fold_with(self);\n         self.binding_count -= 1;\n         ty::Binder(value)\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"BoundsChecker t={}\",\n-               t.repr());\n+        debug!(\"BoundsChecker t={:?}\",\n+               t);\n \n         match self.cache {\n             Some(ref mut cache) => {"}, {"sha": "05cc3077fc9fbb6d706fa2174d66cb8a5bdda35a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -21,7 +21,6 @@ use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::infer;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n-use util::ppaux::Repr;\n \n use std::cell::Cell;\n \n@@ -169,10 +168,10 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n \n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n-        debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n+        debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               ty::node_id_to_type(self.tcx(), p.id).repr());\n+               ty::node_id_to_type(self.tcx(), p.id));\n \n         visit::walk_pat(self, p);\n     }\n@@ -215,9 +214,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n                 }\n             };\n-            debug!(\"Upvar capture for {} resolved to {}\",\n-                   upvar_id.repr(),\n-                   new_upvar_capture.repr());\n+            debug!(\"Upvar capture for {:?} resolved to {:?}\",\n+                   upvar_id,\n+                   new_upvar_capture);\n             self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n         }\n     }\n@@ -245,7 +244,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n         write_ty_to_tcx(self.tcx(), id, n_ty);\n-        debug!(\"Node {} has type {}\", id, n_ty.repr());\n+        debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n@@ -294,9 +293,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve any method map entry\n         match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n             Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n+                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                        method_call,\n-                       method.repr());\n+                       method);\n                 let new_method = MethodCallee {\n                     origin: self.resolve(&method.origin, reason),\n                     ty: self.resolve(&method.ty, reason),\n@@ -427,8 +426,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n             Err(e) => {\n-                debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n-                       t.repr());\n+                debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n+                       t);\n                 self.report_error(e);\n                 self.tcx().types.err\n             }"}, {"sha": "b66c76048c639db3b0e7531602e3a6396f59c8cb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -44,7 +44,6 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use util::nodemap::{DefIdMap, FnvHashMap};\n-use util::ppaux::Repr;\n \n mod orphan;\n mod overlap;\n@@ -82,7 +81,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             inference_context.tcx.sess.span_bug(\n                 span,\n                 &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr()));\n+                         ty));\n         }\n     }\n }\n@@ -149,9 +148,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n                                                     impl_did) {\n-            debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n-                   trait_ref.repr(),\n-                   token::get_ident(item.ident));\n+            debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+                   trait_ref,\n+                   item.ident);\n \n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,\n@@ -179,8 +178,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             trait_ref: &ty::TraitRef<'tcx>,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n-               impl_id, trait_ref.repr());\n+        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={:?})\",\n+               impl_id, trait_ref);\n \n         let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n@@ -190,7 +189,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr());\n+            debug!(\"new_did={:?} trait_method={:?}\", new_did, trait_method);\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -203,7 +202,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     &**trait_method,\n                     Some(trait_method.def_id)));\n \n-            debug!(\"new_method_ty={}\", new_method_ty.repr());\n+            debug!(\"new_method_ty={:?}\", new_method_ty);\n             all_impl_items.push(MethodTraitItemId(new_did));\n \n             // construct the polytype for the method based on the\n@@ -214,7 +213,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 ty: ty::mk_bare_fn(tcx, Some(new_did),\n                                    tcx.mk_bare_fn(new_method_ty.fty.clone()))\n             };\n-            debug!(\"new_polytype={}\", new_polytype.repr());\n+            debug!(\"new_polytype={:?}\", new_polytype);\n \n             tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n             tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n@@ -360,8 +359,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={}\",\n-                   impl_did.repr());\n+            debug!(\"check_implementations_of_copy: impl_did={:?}\",\n+                   impl_did);\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n@@ -370,16 +369,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n \n             let self_type = ty::lookup_item_type(tcx, impl_did);\n-            debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n-                   self_type.repr());\n+            debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n+                   self_type);\n \n             let span = tcx.map.span(impl_did.node);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n-            debug!(\"check_implementations_of_copy: self_type={} (free)\",\n-                   self_type.repr());\n+            debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n+                   self_type);\n \n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n@@ -429,8 +428,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, coerce_unsized_trait);\n \n         trait_def.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_coerce_unsized: impl_did={}\",\n-                   impl_did.repr());\n+            debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n+                   impl_did);\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n@@ -442,17 +441,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let trait_ref = ty::impl_trait_ref(self.crate_context.tcx,\n                                                impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n-            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n-                   source.repr(), target.repr());\n+            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n+                   source, target);\n \n             let span = tcx.map.span(impl_did.node);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let source = source.subst(tcx, &param_env.free_substs);\n             let target = target.subst(tcx, &param_env.free_substs);\n             assert!(!source.has_escaping_regions());\n \n-            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (free)\",\n-                   source.repr(), target.repr());\n+            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n+                   source, target);\n \n             let infcx = new_infer_ctxt(tcx);\n \n@@ -518,10 +517,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                 if name == token::special_names::unnamed_field {\n                                                     i.to_string()\n                                                 } else {\n-                                                    token::get_name(name).to_string()\n-                                                },\n-                                                a.repr(),\n-                                                b.repr())\n+                                                    name.to_string()\n+                                                }, a, b)\n                                    }).collect::<Vec<_>>().connect(\", \"));\n                         return;\n                     }\n@@ -597,8 +594,8 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let combined_substs = ty::make_substs_for_receiver_types(tcx, trait_ref, method);\n \n-    debug!(\"subst_receiver_types_in_method_ty: combined_substs={}\",\n-           combined_substs.repr());\n+    debug!(\"subst_receiver_types_in_method_ty: combined_substs={:?}\",\n+           combined_substs);\n \n     let method_predicates = method.predicates.subst(tcx, &combined_substs);\n     let mut method_generics = method.generics.subst(tcx, &combined_substs);\n@@ -614,13 +611,13 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n             impl_type_scheme.generics.regions.get_slice(space).to_vec());\n     }\n \n-    debug!(\"subst_receiver_types_in_method_ty: method_generics={}\",\n-           method_generics.repr());\n+    debug!(\"subst_receiver_types_in_method_ty: method_generics={:?}\",\n+           method_generics);\n \n     let method_fty = method.fty.subst(tcx, &combined_substs);\n \n-    debug!(\"subst_receiver_types_in_method_ty: method_ty={}\",\n-           method.fty.repr());\n+    debug!(\"subst_receiver_types_in_method_ty: method_ty={:?}\",\n+           method.fty);\n \n     ty::Method::new(\n         method.name,"}, {"sha": "8376b92da3dea667c3926ad14c169d0b7de6af51", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -18,7 +18,6 @@ use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n-use util::ppaux::{Repr, UserString};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n@@ -229,7 +228,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                 \"type parameter `{}` must be used as the type parameter for \\\n                                  some local type (e.g. `MyStruct<T>`); only traits defined in \\\n                                  the current crate can be implemented for a type parameter\",\n-                                param_ty.user_string());\n+                                param_ty);\n                         return;\n                     }\n                 }\n@@ -267,9 +266,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // This final impl is legal according to the orpan\n                 // rules, but it invalidates the reasoning from\n                 // `two_foos` above.\n-                debug!(\"trait_ref={} trait_def_id={} trait_has_default_impl={}\",\n-                       trait_ref.repr(),\n-                       trait_def_id.repr(),\n+                debug!(\"trait_ref={:?} trait_def_id={:?} trait_has_default_impl={}\",\n+                       trait_ref,\n+                       trait_def_id,\n                        ty::trait_has_default_impl(self.tcx, trait_def_id));\n                 if\n                     ty::trait_has_default_impl(self.tcx, trait_def_id) &&\n@@ -307,7 +306,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                  can only be implemented for a struct/enum type, \\\n                                  not `{}`\",\n                                 ty::item_path_str(self.tcx, trait_def_id),\n-                                self_ty.user_string()))\n+                                self_ty))\n                         }\n                     };\n "}, {"sha": "0e8067e7181bd4d821ce364639c46710c384b2b0", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -21,7 +21,6 @@ use syntax::ast_util;\n use syntax::visit;\n use syntax::codemap::Span;\n use util::nodemap::DefIdMap;\n-use util::ppaux::{Repr, UserString};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut overlap = OverlapChecker { tcx: tcx, default_impls: DefIdMap() };\n@@ -61,8 +60,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn check_for_overlapping_impls_of_trait(&self,\n                                             trait_def: &'tcx ty::TraitDef<'tcx>)\n     {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def={})\",\n-               trait_def.repr());\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def={:?})\",\n+               trait_def);\n \n         // We should already know all impls of this trait, so these\n         // borrows are safe.\n@@ -131,10 +130,10 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n             impl1_def_id, impl2_def_id)\n         {\n-            debug!(\"check_if_impls_overlap({}, {}, {})\",\n-                   trait_def_id.repr(),\n-                   impl1_def_id.repr(),\n-                   impl2_def_id.repr());\n+            debug!(\"check_if_impls_overlap({:?}, {:?}, {:?})\",\n+                   trait_def_id,\n+                   impl1_def_id,\n+                   impl2_def_id);\n \n             let infcx = infer::new_infer_ctxt(self.tcx);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n@@ -217,7 +216,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                                 span_err!(self.tcx.sess, item.span, E0371,\n                                           \"the object type `{}` automatically \\\n                                            implements the trait `{}`\",\n-                                          trait_ref.self_ty().user_string(),\n+                                          trait_ref.self_ty(),\n                                           ty::item_path_str(self.tcx, trait_def_id));\n                             }\n                         }"}, {"sha": "fa39e9d0491f9566136934475229e627fdd18897", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -16,7 +16,6 @@ use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::visit;\n-use util::ppaux::UserString;\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n@@ -55,14 +54,14 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                     (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n                         span_err!(self.tcx.sess, item.span, E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n-                                  trait_ref.user_string());\n+                                  trait_ref);\n                     }\n \n                     (ast::Unsafety::Unsafe,\n                      ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess, item.span, E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n-                                  trait_ref.user_string());\n+                                  trait_ref);\n                     }\n \n                     (ast::Unsafety::Unsafe,"}, {"sha": "13d2cf25e0665352106c7a28c26440666dc0c04f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -80,7 +80,6 @@ use rscope::*;\n use rustc::ast_map;\n use util::common::{ErrorReported, memoized};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::{Repr, UserString};\n use write_ty_to_tcx;\n \n use std::cell::{Cell, RefCell};\n@@ -255,7 +254,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when computing the bounds \\\n                               for type parameter `{}`...\",\n-                             def.name.user_string()));\n+                             def.name));\n             }\n         }\n \n@@ -277,7 +276,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     tcx.sess.note(\n                         &format!(\"...which then requires computing the bounds \\\n                                   for type parameter `{}`...\",\n-                                 def.name.user_string()));\n+                                 def.name));\n                 }\n             }\n         }\n@@ -300,7 +299,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires computing the bounds \\\n                               for type parameter `{}`, completing the cycle.\",\n-                             def.name.user_string()));\n+                             def.name));\n             }\n         }\n     }\n@@ -317,7 +316,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         let item = match tcx.map.get(trait_id.node) {\n             ast_map::NodeItem(item) => item,\n-            _ => tcx.sess.bug(&format!(\"get_trait_def({}): not an item\", trait_id.repr()))\n+            _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n         };\n \n         trait_def_of_item(self, &*item)\n@@ -371,8 +370,8 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                                trait_def_id: ast::DefId)\n                                -> Result<(), ErrorReported>\n     {\n-        debug!(\"ensure_super_predicates(trait_def_id={})\",\n-               trait_def_id.repr());\n+        debug!(\"ensure_super_predicates(trait_def_id={:?})\",\n+               trait_def_id);\n \n         self.ccx.ensure_super_predicates(span, trait_def_id)\n     }\n@@ -634,8 +633,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n                              ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n-    debug!(\"method {} (id {}) has type {}\",\n-            ident, id, fty.repr());\n+    debug!(\"method {} (id {}) has type {:?}\",\n+            ident, id, fty);\n     ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n         generics: ty_method.generics.clone(),\n         ty: fty\n@@ -644,8 +643,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     write_ty_to_tcx(ccx.tcx, id, fty);\n \n-    debug!(\"writing method type: def_id={:?} mty={}\",\n-            def_id, ty_method.repr());\n+    debug!(\"writing method type: def_id={:?} mty={:?}\",\n+            def_id, ty_method);\n \n     ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n         ty::MethodTraitItem(Rc::new(ty_method)));\n@@ -742,10 +741,11 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n     where I: Iterator<Item=(&'i ast::MethodSig, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n {\n-    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n-           untransformed_rcvr_ty.repr(),\n-           rcvr_ty_generics.repr(),\n-           rcvr_ty_predicates.repr());\n+    debug!(\"convert_methods(untransformed_rcvr_ty={:?}, rcvr_ty_generics={:?}, \\\n+                            rcvr_ty_predicates={:?})\",\n+           untransformed_rcvr_ty,\n+           rcvr_ty_generics,\n+           rcvr_ty_predicates);\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n@@ -1139,7 +1139,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n \n-    debug!(\"ensure_super_predicates_step(trait_def_id={})\", trait_def_id.repr());\n+    debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n     if trait_def_id.krate != ast::LOCAL_CRATE {\n         // If this trait comes from an external crate, then all of the\n@@ -1191,9 +1191,9 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         let superpredicates = ty::GenericPredicates {\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n-        debug!(\"superpredicates for trait {} = {}\",\n-               local_def(item.id).repr(),\n-               superpredicates.repr());\n+        debug!(\"superpredicates for trait {:?} = {:?}\",\n+               local_def(item.id),\n+               superpredicates);\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n \n@@ -1206,7 +1206,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                                          .map(|tr| tr.def_id())\n                                          .collect();\n \n-    debug!(\"ensure_super_predicates_step: def_ids={}\", def_ids.repr());\n+    debug!(\"ensure_super_predicates_step: def_ids={:?}\", def_ids);\n \n     def_ids\n }\n@@ -1532,9 +1532,8 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n                                      Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n-                                         r.user_string(),\n-                                     d =>\n-                                         d.repr(),\n+                                         r.to_string(),\n+                                     d => format!(\"{:?}\", d),\n                                  })\n                                  .collect::<Vec<String>>()\n                                  .connect(\",\");\n@@ -1620,8 +1619,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    ast_generics: &ast::Generics)\n                                    -> ty::Generics<'tcx>\n {\n-    debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n-           local_def(trait_id).repr(), substs.repr());\n+    debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n+           local_def(trait_id), substs);\n \n     let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n@@ -2200,12 +2199,12 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                 &ty::liberate_late_bound_regions(\n                     tcx, body_scope, &ty::Binder(base_type)));\n \n-        debug!(\"required_type={} required_type_free={} \\\n-                base_type={} base_type_free={}\",\n-               required_type.repr(),\n-               required_type_free.repr(),\n-               base_type.repr(),\n-               base_type_free.repr());\n+        debug!(\"required_type={:?} required_type_free={:?} \\\n+                base_type={:?} base_type_free={:?}\",\n+               required_type,\n+               required_type_free,\n+               base_type,\n+               base_type_free);\n \n         let infcx = infer::new_infer_ctxt(tcx);\n         drop(::require_same_types(tcx,\n@@ -2216,7 +2215,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                         required_type.user_string())\n+                         required_type)\n         }));\n \n         // We could conceviably add more free-region relations here,\n@@ -2286,7 +2285,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      idx: index as u32,\n                                      name: ty_param.ident.name };\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n-            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.user_string());\n+            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.to_string());\n         }\n     }\n \n@@ -2316,7 +2315,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             !input_parameters.contains(&ctp::Parameter::Region(region))\n         {\n             report_unused_parameter(tcx, lifetime_def.lifetime.span,\n-                                    \"lifetime\", &region.name.user_string());\n+                                    \"lifetime\", &region.name.to_string());\n         }\n     }\n "}, {"sha": "8feecd15613119931074cec6ad343c157bedb675", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -109,7 +109,6 @@ use middle::ty::{self, Ty};\n use rustc::ast_map;\n use session::config;\n use util::common::time;\n-use util::ppaux::{Repr, UserString};\n \n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n@@ -148,7 +147,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-    debug!(\"write_ty_to_tcx({}, {})\", node_id,  ty.repr());\n+    debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_type_insert(node_id, ty);\n }\n@@ -157,9 +156,9 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  node_id: ast::NodeId,\n                                  item_substs: ty::ItemSubsts<'tcx>) {\n     if !item_substs.is_noop() {\n-        debug!(\"write_substs_to_tcx({}, {})\",\n+        debug!(\"write_substs_to_tcx({}, {:?})\",\n                node_id,\n-               item_substs.repr());\n+               item_substs);\n \n         assert!(item_substs.substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n@@ -240,14 +239,13 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n                 || {\n                     format!(\"main function expects type: `{}`\",\n-                             se_ty.user_string())\n+                             se_ty)\n                 });\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              &format!(\"main has a non-function type: found \\\n-                                       `{}`\",\n-                                      main_t.repr()));\n+                              &format!(\"main has a non-function type: found `{}`\",\n+                                       main_t));\n         }\n     }\n }\n@@ -290,15 +288,14 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n                 || {\n                     format!(\"start function expects type: `{}`\",\n-                             se_ty.user_string())\n+                             se_ty)\n                 });\n \n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              &format!(\"start has a non-function type: found \\\n-                                       `{}`\",\n-                                       start_t.repr()));\n+                              &format!(\"start has a non-function type: found `{}`\",\n+                                       start_t));\n         }\n     }\n }"}, {"sha": "1f4e13436512179f729084b162d2d566b81e2a33", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b58fdf9252ccd08bf610e13625f49380e769e06/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=0b58fdf9252ccd08bf610e13625f49380e769e06", "patch": "@@ -278,7 +278,6 @@ use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n-use util::ppaux::Repr;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n     let krate = tcx.map.krate();\n@@ -845,8 +844,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                       generics: &ty::Generics<'tcx>,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n-               trait_ref.repr(),\n+        debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n+               trait_ref,\n                variance);\n \n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n@@ -867,8 +866,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                generics: &ty::Generics<'tcx>,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_ty(ty={}, variance={:?})\",\n-               ty.repr(),\n+        debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n+               ty,\n                variance);\n \n         match ty.sty {\n@@ -981,8 +980,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyInfer(..) => {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n-                            variance inference: {}\",\n-                            ty.repr()));\n+                              variance inference: {}\", ty));\n             }\n         }\n     }\n@@ -997,9 +995,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={}, substs={}, variance={:?})\",\n-               def_id.repr(),\n-               substs.repr(),\n+        debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n+               def_id,\n+               substs,\n                variance);\n \n         for p in type_param_defs {\n@@ -1066,8 +1064,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx()\n                     .sess\n                     .bug(&format!(\"unexpected region encountered in variance \\\n-                                  inference: {}\",\n-                                 region.repr()));\n+                                  inference: {:?}\",\n+                                 region));\n             }\n         }\n     }\n@@ -1194,17 +1192,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 types: types,\n                 regions: regions\n             };\n-            debug!(\"item_id={} item_variances={}\",\n+            debug!(\"item_id={} item_variances={:?}\",\n                     item_id,\n-                    item_variances.repr());\n+                    item_variances);\n \n             let item_def_id = ast_util::local_def(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n-                let found = item_variances.repr();\n-                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[..]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}]}