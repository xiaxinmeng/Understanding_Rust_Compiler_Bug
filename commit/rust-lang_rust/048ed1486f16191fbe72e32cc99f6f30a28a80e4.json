{"sha": "048ed1486f16191fbe72e32cc99f6f30a28a80e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OGVkMTQ4NmYxNjE5MWZiZTcyZTMyY2M5OWY2ZjMwYTI4YTgwZTQ=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-06-17T04:23:24Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:38:40Z"}, "message": "Move count-llvm-insn code into task-local storage", "tree": {"sha": "f56cfbad929cf26c5f31f4a170efad077a6352bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f56cfbad929cf26c5f31f4a170efad077a6352bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/048ed1486f16191fbe72e32cc99f6f30a28a80e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/048ed1486f16191fbe72e32cc99f6f30a28a80e4", "html_url": "https://github.com/rust-lang/rust/commit/048ed1486f16191fbe72e32cc99f6f30a28a80e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/048ed1486f16191fbe72e32cc99f6f30a28a80e4/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "html_url": "https://github.com/rust-lang/rust/commit/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04"}], "stats": {"total": 448, "additions": 225, "deletions": 223}, "files": [{"sha": "958677eab4ae5946f739ce703e20ce9c948c9cbf", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -259,7 +259,7 @@ pub enum opt_result {\n     range_result(Result, Result),\n }\n pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n-    let _icx = bcx.insn_ctxt(\"match::trans_opt\");\n+    let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n     match *o {\n@@ -870,7 +870,7 @@ pub fn extract_variant_args(bcx: block,\n                             disr_val: int,\n                             val: ValueRef)\n     -> ExtractedBlock {\n-    let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n+    let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     };\n@@ -896,7 +896,7 @@ pub fn extract_vec_elems(bcx: block,\n                          val: ValueRef,\n                          count: ValueRef)\n                       -> ExtractedBlock {\n-    let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n+    let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n     let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span,\n                                                           pat_id, 0);\n@@ -1088,7 +1088,7 @@ pub fn compare_values(cx: block,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n                    -> Result {\n-    let _icx = cx.insn_ctxt(\"compare_values\");\n+    let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::eq);\n       return rslt(rs.bcx, rs.val);\n@@ -1277,7 +1277,7 @@ pub fn compile_submatch(bcx: block,\n       For an empty match, a fall-through case must exist\n      */\n     assert!((m.len() > 0u || chk.is_some()));\n-    let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n+    let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n     let dm = tcx.def_map;\n@@ -1617,7 +1617,7 @@ pub fn trans_match(bcx: block,\n                    discr_expr: @ast::expr,\n                    arms: ~[ast::arm],\n                    dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"match::trans_match\");\n+    let _icx = push_ctxt(\"match::trans_match\");\n     do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n@@ -1664,7 +1664,7 @@ pub fn trans_match_inner(scope_cx: block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n                          dest: Dest) -> block {\n-    let _icx = scope_cx.insn_ctxt(\"match::trans_match_inner\");\n+    let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n \n@@ -1751,7 +1751,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             make_copy: bool,\n                             binding_mode: IrrefutablePatternBindingMode)\n                          -> block {\n-    let _icx = bcx.insn_ctxt(\"match::bind_irrefutable_pat\");\n+    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n "}, {"sha": "bd57a709a90b4061852fa8ca5ec32d6eaf231bd6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -73,6 +73,7 @@ use core::libc::c_uint;\n use core::str;\n use core::uint;\n use core::vec;\n+use core::local_data;\n use extra::time;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n@@ -88,49 +89,52 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::task_llcx;\n \n-pub struct icx_popper {\n-    ccx: @mut CrateContext,\n-}\n+fn task_local_insn_key(_v: @~[&'static str]) {}\n \n-#[unsafe_destructor]\n-impl Drop for icx_popper {\n-    fn finalize(&self) {\n-        if self.ccx.sess.count_llvm_insns() {\n-            self.ccx.stats.llvm_insn_ctxt.pop();\n+pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n+    unsafe {\n+        let opt = local_data::local_data_get(task_local_insn_key);\n+        if opt.is_some() {\n+            blk(*opt.unwrap());\n         }\n     }\n }\n \n-pub fn icx_popper(ccx: @mut CrateContext) -> icx_popper {\n-    icx_popper {\n-        ccx: ccx\n+pub fn init_insn_ctxt() {\n+    unsafe {\n+        local_data::local_data_set(task_local_insn_key, @~[]);\n     }\n }\n \n-pub trait get_insn_ctxt {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper;\n-}\n+pub struct _InsnCtxt { _x: () }\n \n-impl get_insn_ctxt for @mut CrateContext {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper {\n-        debug!(\"new insn_ctxt: %s\", s);\n-        if self.sess.count_llvm_insns() {\n-            self.stats.llvm_insn_ctxt.push(str::to_owned(s));\n+#[unsafe_destructor]\n+impl Drop for _InsnCtxt {\n+    fn finalize(&self) {\n+        unsafe {\n+            do local_data::local_data_modify(task_local_insn_key) |c| {\n+                do c.map_consume |@ctx| {\n+                    let mut ctx = ctx;\n+                    ctx.pop();\n+                    @ctx\n+                }\n+            }\n         }\n-        icx_popper(*self)\n-    }\n-}\n-\n-impl get_insn_ctxt for block {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper {\n-        self.ccx().insn_ctxt(s)\n     }\n }\n \n-impl get_insn_ctxt for fn_ctxt {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper {\n-        self.ccx.insn_ctxt(s)\n+pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n+    debug!(\"new InsnCtxt: %s\", s);\n+    unsafe {\n+        do local_data::local_data_modify(task_local_insn_key) |c| {\n+            do c.map_consume |@ctx| {\n+                let mut ctx = ctx;\n+                ctx.push(s);\n+                @ctx\n+            }\n+        }\n     }\n+    _InsnCtxt { _x: () }\n }\n \n fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n@@ -189,13 +193,13 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n     }\n }\n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"umax\");\n+    let _icx = push_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, b, a);\n }\n \n pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"umin\");\n+    let _icx = push_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, a, b);\n }\n@@ -204,7 +208,7 @@ pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"ptr_offs\");\n+    let _icx = push_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, Type::i8p());\n     InBoundsGEP(bcx, raw, [sz])\n }\n@@ -213,7 +217,7 @@ pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n // to a given type.\n pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let _icx = bcx.insn_ctxt(\"bump_ptr\");\n+    let _icx = push_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n     let typ = type_of(ccx, t).ptr_to();\n@@ -228,7 +232,7 @@ pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n pub fn opaque_box_body(bcx: block,\n                        body_t: ty::t,\n                        boxptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n+    let _icx = push_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let ty = type_of(ccx, body_t);\n     let ty = Type::box(ccx, &ty);\n@@ -242,7 +246,7 @@ pub fn malloc_raw_dyn(bcx: block,\n                       t: ty::t,\n                       heap: heap,\n                       size: ValueRef) -> Result {\n-    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n+    let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n     let (mk_fn, langcall) = match heap {\n@@ -306,7 +310,7 @@ pub struct MallocResult {\n // and pulls out the body\n pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n-    let _icx = bcx.insn_ctxt(\"malloc_general\");\n+    let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, llbox);\n     let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n@@ -457,7 +461,7 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                     parent_id: ast::def_id,\n                     substs: &[ty::t])\n                  -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n+    let _icx = push_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n@@ -547,7 +551,7 @@ pub fn compare_scalar_values(cx: block,\n                              nt: scalar_type,\n                              op: ast::binop)\n                           -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n+    let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n                            comparison operator\");\n@@ -616,12 +620,12 @@ pub fn store_inbounds(cx: block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                           f: val_and_ty_fn) -> block {\n-    let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n+    let _icx = push_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n                     variant: ty::VariantInfo,\n                     tps: &[ty::t], f: val_and_ty_fn) -> block {\n-        let _icx = cx.insn_ctxt(\"iter_variant\");\n+        let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n@@ -795,7 +799,7 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n \n pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n            -> (ValueRef, block) {\n-    let _icx = bcx.insn_ctxt(\"invoke_\");\n+    let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable {\n         return (C_null(Type::i8()), bcx);\n     }\n@@ -911,7 +915,7 @@ pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n }\n \n pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n-    let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n+    let _icx = push_ctxt(\"get_landing_pad\");\n \n     let mut cached = None;\n     let mut pad_bcx = bcx; // Guaranteed to be set below\n@@ -1004,20 +1008,20 @@ pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n }\n \n pub fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n+    let _icx = push_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"load_if_immediate\");\n+    let _icx = push_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(t) { return Load(cx, v); }\n     return v;\n }\n \n pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n     if !bcx.sess().trace() { return; }\n-    let _icx = bcx.insn_ctxt(\"trans_trace\");\n+    let _icx = push_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let (V_filename, V_line) = match sp_opt {\n@@ -1038,7 +1042,7 @@ pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n }\n \n pub fn build_return(bcx: block) {\n-    let _icx = bcx.insn_ctxt(\"build_return\");\n+    let _icx = push_ctxt(\"build_return\");\n     Br(bcx, bcx.fcx.llreturn);\n }\n \n@@ -1054,7 +1058,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n            bcx.to_str(), local.node.id);\n     let _indenter = indenter();\n \n-    let _icx = bcx.insn_ctxt(\"init_local\");\n+    let _icx = push_ctxt(\"init_local\");\n     let ty = node_id_type(bcx, local.node.id);\n \n     debug!(\"ty=%s\", bcx.ty_to_str(ty));\n@@ -1102,7 +1106,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n }\n \n pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_stmt\");\n+    let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n     if cx.sess().asm_comments() {\n@@ -1230,7 +1234,7 @@ pub fn trans_block_cleanups_(bcx: block,\n                              cleanups: &[cleanup],\n                              /* cleanup_cx: block, */\n                              is_lpad: bool) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n+    let _icx = push_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n     let no_lpads =\n@@ -1257,7 +1261,7 @@ pub fn trans_block_cleanups_(bcx: block,\n pub fn cleanup_and_leave(bcx: block,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n-    let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n+    let _icx = push_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     let is_lpad = leave == None;\n@@ -1324,12 +1328,12 @@ pub fn cleanup_and_leave(bcx: block,\n }\n \n pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n-    let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n+    let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n pub fn leave_block(bcx: block, out_of: block) -> block {\n-    let _icx = bcx.insn_ctxt(\"leave_block\");\n+    let _icx = push_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n@@ -1340,7 +1344,7 @@ pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n                   f: &fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(\"with_scope\");\n+    let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n            bcx.to_str(), opt_node_info, name);\n@@ -1355,7 +1359,7 @@ pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n                          name: &str,\n                          f: &fn(block) -> Result) -> Result {\n-    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n+    let _icx = push_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let Result {bcx, val} = f(scope_cx);\n@@ -1367,7 +1371,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n-    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n+    let _icx = push_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let DatumBlock {bcx, datum} = f(scope_cx);\n@@ -1389,7 +1393,7 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n }\n \n pub fn alloc_local(cx: block, local: @ast::local) -> block {\n-    let _icx = cx.insn_ctxt(\"alloc_local\");\n+    let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n       ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n@@ -1411,7 +1415,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n \n \n pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(\"with_cond\");\n+    let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n@@ -1421,7 +1425,7 @@ pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n }\n \n pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n-    let _icx = cx.insn_ctxt(\"call_memcpy\");\n+    let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n@@ -1437,7 +1441,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n }\n \n pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(\"memcpy_ty\");\n+    let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n         let llty = type_of::type_of(ccx, t);\n@@ -1450,7 +1454,7 @@ pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n }\n \n pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n-    let _icx = cx.insn_ctxt(\"zero_mem\");\n+    let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of::type_of(ccx, t);\n@@ -1463,7 +1467,7 @@ pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n-    let _icx = cx.insn_ctxt(\"memzero\");\n+    let _icx = push_ctxt(\"memzero\");\n     let ccx = cx.ccx();\n \n     let intrinsic_key = match ccx.sess.targ_cfg.arch {\n@@ -1481,7 +1485,7 @@ pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n }\n \n pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"alloc_ty\");\n+    let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n@@ -1494,7 +1498,7 @@ pub fn alloca(cx: block, ty: Type) -> ValueRef {\n }\n \n pub fn alloca_maybe_zeroed(cx: block, ty: Type, zero: bool) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"alloca\");\n+    let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.to_ref());\n@@ -1507,7 +1511,7 @@ pub fn alloca_maybe_zeroed(cx: block, ty: Type, zero: bool) -> ValueRef {\n }\n \n pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"arrayalloca\");\n+    let _icx = push_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.to_ref());\n@@ -1639,7 +1643,7 @@ pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n                                  self_arg: self_arg,\n                                  args: &[ast::arg])\n                               -> ~[ValueRef] {\n-    let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n+    let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n       impl_self(tt) => {\n@@ -1687,7 +1691,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::t]) -> block {\n-    let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n+    let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n     match fcx.llself {\n@@ -1753,7 +1757,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(\"finish_fn\");\n+    let _icx = push_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n     build_return_block(fcx);\n }\n@@ -1771,7 +1775,7 @@ pub fn build_return_block(fcx: fn_ctxt) {\n }\n \n pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n+    let _icx = push_ctxt(\"tie_up_header_blocks\");\n     match fcx.llloadenv {\n         Some(ll) => {\n             Br(raw_block(fcx, false, fcx.llstaticallocas), ll);\n@@ -1802,7 +1806,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      maybe_load_env: &fn(fn_ctxt),\n                      finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n-    let _icx = ccx.insn_ctxt(\"trans_closure\");\n+    let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     debug!(\"trans_closure(..., param_substs=%s)\",\n@@ -1891,7 +1895,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n     debug!(\"trans_fn(self_arg=%?, param_substs=%s)\",\n            self_arg,\n            param_substs.repr(ccx.tcx));\n-    let _icx = ccx.insn_ctxt(\"trans_fn\");\n+    let _icx = push_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     let the_path_str = path_str(ccx.sess, path);\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n@@ -1926,7 +1930,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n                           disr: int,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n+    let _icx = push_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n     let fn_args = do args.map |varg| {\n         ast::arg {\n@@ -2000,7 +2004,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(\"trans_tuple_struct\");\n+    let _icx = push_ctxt(\"trans_tuple_struct\");\n \n     // Translate struct fields to function arguments.\n     let fn_args = do fields.map |field| {\n@@ -2086,7 +2090,7 @@ pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n }\n \n pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n-    let _icx = ccx.insn_ctxt(\"trans_item\");\n+    let _icx = push_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n@@ -2193,7 +2197,7 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n-    let _icx = ccx.insn_ctxt(\"trans_mod\");\n+    let _icx = push_ctxt(\"trans_mod\");\n     for m.items.each |item| {\n         trans_item(ccx, *item);\n     }\n@@ -2560,7 +2564,7 @@ pub fn register_method(ccx: @mut CrateContext,\n \n // The constant translation pass.\n pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n-    let _icx = ccx.insn_ctxt(\"trans_constant\");\n+    let _icx = push_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n         let vi = ty::enum_variants(ccx.tcx,\n@@ -2922,19 +2926,13 @@ pub fn trans_crate(sess: session::Session,\n \n     let ccx = @mut CrateContext::new(sess, llmod_id, tcx, emap2, maps,\n                                  symbol_hasher, link_meta, reachable);\n-    // FIXME(#6511): get LLVM building with --enable-threads so this\n-    //               function can be called\n-    // if !llvm::LLVMRustStartMultithreading() {\n-    //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n-    // }\n-\n     {\n-        let _icx = ccx.insn_ctxt(\"data\");\n+        let _icx = push_ctxt(\"data\");\n         trans_constants(ccx, crate);\n     }\n \n     {\n-        let _icx = ccx.insn_ctxt(\"text\");\n+        let _icx = push_ctxt(\"text\");\n         trans_mod(ccx, &crate.node.module);\n     }\n \n@@ -2963,6 +2961,12 @@ pub fn trans_crate(sess: session::Session,\n         io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n     }\n \n+    if ccx.sess.count_llvm_insns() {\n+        for ccx.stats.llvm_insns.each |&k, &v| {\n+            io::println(fmt!(\"%-7u %s\", v, k));\n+        }\n+    }\n+\n     let llcx = ccx.llcx;\n     let link_meta = ccx.link_meta;\n     let llmod = ccx.llmod;"}, {"sha": "83c1a3c80db24fd457af36e25acb989061eca6e4", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -19,6 +19,7 @@ use middle::trans::common::*;\n use middle::trans::machine::llalign_of_min;\n use syntax::codemap::span;\n \n+use middle::trans::base;\n use middle::trans::type_::Type;\n \n use core::cast;\n@@ -46,10 +47,8 @@ pub fn B(cx: block) -> BuilderRef {\n }\n \n pub fn count_insn(cx: block, category: &str) {\n-    if cx.ccx().sess.count_llvm_insns() {\n-\n+    do base::with_insn_ctxt |v| {\n         let h = &mut cx.ccx().stats.llvm_insns;\n-        let v : &[~str] = cx.ccx().stats.llvm_insn_ctxt;\n \n         // Build version of path with cycles removed.\n "}, {"sha": "0809b1c124e0ffde2ec2a4c44c8666fb69a8e0a2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -78,7 +78,7 @@ pub struct Callee {\n }\n \n pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n-    let _icx = bcx.insn_ctxt(\"trans_callee\");\n+    let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n@@ -172,7 +172,7 @@ pub fn trans_fn_ref(bcx: block,\n      * with id `def_id` into a function pointer.  This may require\n      * monomorphization or inlining. */\n \n-    let _icx = bcx.insn_ctxt(\"trans_fn_ref\");\n+    let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let type_params = node_id_type_params(bcx, ref_id);\n     let vtables = node_vtables(bcx, ref_id);\n@@ -216,7 +216,7 @@ pub fn trans_fn_ref_with_vtables(\n     // - `type_params`: values for each of the fn/method's type parameters\n     // - `vtables`: values for each bound on each of the type parameters\n \n-    let _icx = bcx.insn_ctxt(\"trans_fn_ref_with_vtables\");\n+    let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n@@ -357,7 +357,7 @@ pub fn trans_call(in_cx: block,\n                   id: ast::node_id,\n                   dest: expr::Dest)\n                   -> block {\n-    let _icx = in_cx.insn_ctxt(\"trans_call\");\n+    let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      call_ex.info(),\n                      expr_ty(in_cx, f),\n@@ -375,7 +375,7 @@ pub fn trans_method_call(in_cx: block,\n                          args: CallArgs,\n                          dest: expr::Dest)\n                          -> block {\n-    let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n+    let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n            call_ex.repr(in_cx.tcx()),\n            rcvr.repr(in_cx.tcx()));\n@@ -671,7 +671,7 @@ pub fn trans_args(cx: block,\n                   autoref_arg: AutorefArg,\n                   llargs: &mut ~[ValueRef]) -> block\n {\n-    let _icx = cx.insn_ctxt(\"trans_args\");\n+    let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n \n@@ -725,7 +725,7 @@ pub fn trans_arg_expr(bcx: block,\n                       temp_cleanups: &mut ~[ValueRef],\n                       ret_flag: Option<ValueRef>,\n                       autoref_arg: AutorefArg) -> Result {\n-    let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n+    let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s, \\"}, {"sha": "613bd86ab91818ac5cfe9c778a3e042b35c26a04", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -162,12 +162,12 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n \n pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n-    let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n+    let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, llbox: ValueRef) {\n-        let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n+        let _icx = push_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let llbox = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n@@ -206,7 +206,7 @@ pub struct ClosureResult {\n pub fn store_environment(bcx: block,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil) -> ClosureResult {\n-    let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n+    let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n@@ -260,7 +260,7 @@ pub fn build_closure(bcx0: block,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil,\n                      include_ret_handle: Option<ValueRef>) -> ClosureResult {\n-    let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n+    let _icx = push_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let bcx = bcx0;\n \n@@ -322,7 +322,7 @@ pub fn load_environment(fcx: fn_ctxt,\n                         cap_vars: &[moves::CaptureVar],\n                         load_ret_handle: bool,\n                         sigil: ast::Sigil) {\n-    let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n+    let _icx = push_ctxt(\"closure::load_environment\");\n \n     let llloadenv = match fcx.llloadenv {\n         Some(ll) => ll,\n@@ -393,7 +393,7 @@ pub fn trans_expr_fn(bcx: block,\n          (fn ptr, env) pair\n      */\n \n-    let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n+    let _icx = push_ctxt(\"closure::trans_expr_fn\");\n \n     let dest_addr = match dest {\n         expr::SaveIn(p) => p,\n@@ -470,7 +470,7 @@ pub fn make_closure_glue(\n         v: ValueRef,\n         t: ty::t,\n         glue_fn: @fn(block, v: ValueRef, t: ty::t) -> block) -> block {\n-    let _icx = cx.insn_ctxt(\"closure::make_closure_glue\");\n+    let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n@@ -494,7 +494,7 @@ pub fn make_opaque_cbox_take_glue(\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n-    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n+    let _icx = push_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match sigil {\n         ast::BorrowedSigil => {\n             return bcx;\n@@ -553,7 +553,7 @@ pub fn make_opaque_cbox_drop_glue(\n     sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n+    let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match sigil {\n         ast::BorrowedSigil => bcx,\n         ast::ManagedSigil => {\n@@ -574,7 +574,7 @@ pub fn make_opaque_cbox_free_glue(\n     sigil: ast::Sigil,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n+    let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match sigil {\n         ast::BorrowedSigil => {\n             return bcx;"}, {"sha": "21e173fd0b435b3a27a8981122f6fe90694f3654", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -101,7 +101,6 @@ pub struct Stats {\n     n_monos: uint,\n     n_inlines: uint,\n     n_closures: uint,\n-    llvm_insn_ctxt: ~[~str],\n     llvm_insns: HashMap<~str, uint>,\n     fn_times: ~[(~str, int)] // (ident, time)\n }"}, {"sha": "e40534773c2d0916e1ff9c62eca4f86ce0928c00", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch;\n use middle::const_eval;\n use middle::trans::adt;\n use middle::trans::base;\n-use middle::trans::base::get_insn_ctxt;\n+use middle::trans::base::push_ctxt;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::expr;\n@@ -37,7 +37,7 @@ use syntax::{ast, ast_util, ast_map};\n \n pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"trans_lit\");\n+    let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n       ast::lit_int(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n       ast::lit_uint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n@@ -249,7 +249,7 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n \n fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n-        let _icx = cx.insn_ctxt(\"const_expr\");\n+        let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n           ast::expr_binary(_, b, e1, e2) => {\n@@ -589,7 +589,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n \n pub fn trans_const(ccx: @mut CrateContext, _e: @ast::expr, id: ast::node_id) {\n     unsafe {\n-        let _icx = ccx.insn_ctxt(\"trans_const\");\n+        let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type."}, {"sha": "715b1c88327f5e3feb191945eb8c3be7350a2ad6", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -162,6 +162,10 @@ impl CrateContext {\n                 None\n             };\n \n+            if sess.count_llvm_insns() {\n+                base::init_insn_ctxt()\n+            }\n+\n             CrateContext {\n                   sess: sess,\n                   llmod: llmod,\n@@ -210,7 +214,6 @@ impl CrateContext {\n                     n_monos: 0u,\n                     n_inlines: 0u,\n                     n_closures: 0u,\n-                    llvm_insn_ctxt: ~[],\n                     llvm_insns: HashMap::new(),\n                     fn_times: ~[]\n                   },\n@@ -234,7 +237,6 @@ impl CrateContext {\n             ((end.nsec as int) - (start.nsec as int)) / 1000000;\n         self.stats.fn_times.push((name, elapsed));\n     }\n-\n }\n \n #[unsafe_destructor]\n@@ -247,7 +249,6 @@ impl Drop for CrateContext {\n }\n \n fn task_local_llcx_key(_v: @ContextRef) {}\n-\n pub fn task_llcx() -> ContextRef {\n     let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")"}, {"sha": "6be26354db1635a74e24e862d123918c211a4647", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -35,7 +35,7 @@ use syntax::ast_util;\n use syntax::codemap::span;\n \n pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_block\");\n+    let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| {\n         bcx = alloc_local(bcx, local);\n@@ -67,7 +67,7 @@ pub fn trans_if(bcx: block,\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n-    let _icx = bcx.insn_ctxt(\"trans_if\");\n+    let _icx = push_ctxt(\"trans_if\");\n     let Result {bcx, val: cond_val} =\n         expr::trans_to_datum(bcx, cond).to_result();\n \n@@ -126,7 +126,7 @@ pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n }\n \n pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::blk) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_while\");\n+    let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n     //            bcx\n@@ -168,7 +168,7 @@ pub fn trans_loop(bcx:block,\n                   body: &ast::blk,\n                   opt_label: Option<ident>)\n                -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_loop\");\n+    let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n                                        body.info());\n@@ -182,7 +182,7 @@ pub fn trans_log(log_ex: @ast::expr,\n                  lvl: @ast::expr,\n                  bcx: block,\n                  e: @ast::expr) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_log\");\n+    let _icx = push_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n@@ -244,7 +244,7 @@ pub fn trans_break_cont(bcx: block,\n                         opt_label: Option<ident>,\n                         to_end: bool)\n                      -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n+    let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut target;\n@@ -298,7 +298,7 @@ pub fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n }\n \n pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_ret\");\n+    let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let dest = match copy bcx.fcx.loop_ret {\n       Some((flagptr, retptr)) => {\n@@ -333,7 +333,7 @@ pub fn trans_fail_expr(bcx: block,\n                        sp_opt: Option<span>,\n                        fail_expr: Option<@ast::expr>)\n                     -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n+    let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n         Some(arg_expr) => {\n@@ -361,7 +361,7 @@ pub fn trans_fail(bcx: block,\n                   sp_opt: Option<span>,\n                   fail_str: @str)\n                -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail\");\n+    let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n@@ -370,7 +370,7 @@ fn trans_fail_value(bcx: block,\n                     sp_opt: Option<span>,\n                     V_fail_str: ValueRef)\n                  -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n+    let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let (V_filename, V_line) = match sp_opt {\n       Some(sp) => {\n@@ -394,7 +394,7 @@ fn trans_fail_value(bcx: block,\n \n pub fn trans_fail_bounds_check(bcx: block, sp: span,\n                                index: ValueRef, len: ValueRef) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail_bounds_check\");\n+    let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];\n     let bcx = callee::trans_lang_call("}, {"sha": "32d0f8887b90dbfb8751331ddb34b6c002dc4c39", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -273,7 +273,7 @@ impl Datum {\n          * `store_to()` instead, which will move if possible but copy if\n          * neccessary. */\n \n-        let _icx = bcx.insn_ctxt(\"copy_to\");\n+        let _icx = push_ctxt(\"copy_to\");\n \n         if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n             return bcx;\n@@ -317,7 +317,7 @@ impl Datum {\n          * A helper for `copy_to()` which does not check to see if we\n          * are copying to/from the same value. */\n \n-        let _icx = bcx.insn_ctxt(\"copy_to_no_check\");\n+        let _icx = push_ctxt(\"copy_to_no_check\");\n         let mut bcx = bcx;\n \n         if action == DROP_EXISTING {\n@@ -341,7 +341,7 @@ impl Datum {\n     //\n     pub fn move_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n                    -> block {\n-        let _icx = bcx.insn_ctxt(\"move_to\");\n+        let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n         debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n@@ -740,7 +740,7 @@ impl Datum {\n                      expr_id: ast::node_id,\n                      max: uint)\n                      -> DatumBlock {\n-        let _icx = bcx.insn_ctxt(\"autoderef\");\n+        let _icx = push_ctxt(\"autoderef\");\n \n         debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n                expr_id, max, self.to_str(bcx.ccx()));"}, {"sha": "44e571dfb2ffee71e61a4080707b0e5e367addc1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -451,7 +451,7 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_datum_unadjusted\");\n+    let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n@@ -502,7 +502,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n     let mut bcx = bcx;\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_stmt\");\n+    let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n     if bcx.unreachable {\n         return bcx;\n@@ -558,7 +558,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n \n fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                                dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_dps_unadjusted\");\n+    let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -707,7 +707,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n \n fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                             def: ast::def, dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_def_dps_unadjusted\");\n+    let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n     let lldest = match dest {\n@@ -755,7 +755,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n                               ref_expr: @ast::expr,\n                               def: ast::def) -> DatumBlock\n {\n-    let _icx = bcx.insn_ctxt(\"trans_def_datum_unadjusted\");\n+    let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     match def {\n         ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n@@ -816,7 +816,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n      * Translates an lvalue expression, always yielding a by-ref\n      * datum.  Does not apply any adjustments. */\n \n-    let _icx = bcx.insn_ctxt(\"trans_lval\");\n+    let _icx = push_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n \n     debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n@@ -855,7 +855,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         //! Translates `base.field`.\n \n         let mut bcx = bcx;\n-        let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n+        let _icx = push_ctxt(\"trans_rec_field\");\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n         let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n@@ -878,7 +878,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                    idx: @ast::expr) -> DatumBlock {\n         //! Translates `base[idx]`.\n \n-        let _icx = bcx.insn_ctxt(\"trans_index\");\n+        let _icx = push_ctxt(\"trans_index\");\n         let ccx = bcx.ccx();\n         let base_ty = expr_ty(bcx, base);\n         let mut bcx = bcx;\n@@ -942,7 +942,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     {\n         //! Translates a reference to a path.\n \n-        let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n+        let _icx = push_ctxt(\"trans_def_lvalue\");\n         let ccx = bcx.ccx();\n         match def {\n             ast::def_const(did) => {\n@@ -1012,7 +1012,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n-    let _icx = bcx.insn_ctxt(\"trans_local_var\");\n+    let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n         ast::def_upvar(nid, _, _, _) => {\n@@ -1143,7 +1143,7 @@ fn trans_rec_or_struct(bcx: block,\n                        id: ast::node_id,\n                        dest: Dest) -> block\n {\n-    let _icx = bcx.insn_ctxt(\"trans_rec\");\n+    let _icx = push_ctxt(\"trans_rec\");\n     let bcx = bcx;\n \n     let ty = node_id_type(bcx, id);\n@@ -1217,7 +1217,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_adt\");\n+    let _icx = push_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n@@ -1263,7 +1263,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n-    let _icx = bcx.insn_ctxt(\"trans_immediate_lit\");\n+    let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n }\n@@ -1272,7 +1272,7 @@ fn trans_unary_datum(bcx: block,\n                      un_expr: @ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n+    let _icx = push_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n     assert!(op != ast::deref);\n@@ -1333,7 +1333,7 @@ fn trans_unary_datum(bcx: block,\n                         contents: @ast::expr,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n-        let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n+        let _icx = push_ctxt(\"trans_boxed_expr\");\n         let base::MallocResult { bcx, box: bx, body } =\n             base::malloc_general(bcx, contents_ty, heap);\n         add_clean_free(bcx, bx, heap);\n@@ -1345,7 +1345,7 @@ fn trans_unary_datum(bcx: block,\n \n fn trans_addr_of(bcx: block, expr: @ast::expr,\n                  subexpr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_addr_of\");\n+    let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n     let llval = sub_datum.to_ref_llval(bcx);\n@@ -1361,7 +1361,7 @@ fn trans_eager_binop(bcx: block,\n                      lhs_datum: &Datum,\n                      rhs_datum: &Datum)\n                   -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n+    let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let lhs = lhs_datum.to_appropriate_llval(bcx);\n     let lhs_t = lhs_datum.ty;\n@@ -1457,7 +1457,7 @@ fn trans_lazy_binop(bcx: block,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n                     b: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n+    let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let bcx = bcx;\n \n@@ -1503,7 +1503,7 @@ fn trans_binary(bcx: block,\n                 lhs: @ast::expr,\n                 rhs: @ast::expr) -> DatumBlock\n {\n-    let _icx = bcx.insn_ctxt(\"trans_binary\");\n+    let _icx = push_ctxt(\"trans_binary\");\n \n     match op {\n         ast::and => {\n@@ -1550,7 +1550,7 @@ fn trans_overloaded_op(bcx: block,\n \n fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"int_cast\");\n+    let _icx = push_ctxt(\"int_cast\");\n     unsafe {\n         let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype.to_ref());\n         let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype.to_ref());\n@@ -1568,7 +1568,7 @@ fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n \n fn float_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"float_cast\");\n+    let _icx = push_ctxt(\"float_cast\");\n     let srcsz = llsrctype.float_width();\n     let dstsz = lldsttype.float_width();\n     return if dstsz > srcsz {\n@@ -1602,7 +1602,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n \n fn trans_imm_cast(bcx: block, expr: @ast::expr,\n                   id: ast::node_id) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_cast\");\n+    let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n \n     let t_out = node_id_type(bcx, id);\n@@ -1669,7 +1669,7 @@ fn trans_assign_op(bcx: block,\n                    dst: @ast::expr,\n                    src: @ast::expr) -> block\n {\n-    let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n+    let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n     debug!(\"trans_assign_op(expr=%s)\", bcx.expr_to_str(expr));"}, {"sha": "2d23942f601fd2e2c77fd2ab5093c08644a8098a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -188,7 +188,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n                   needs_c_return: bool,\n                   arg_builder: wrap_arg_builder,\n                   ret_builder: wrap_ret_builder) {\n-    let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n+    let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n \n     // Patch up the return type if it's not immediate and we're returning via\n@@ -274,7 +274,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                          path: &ast_map::path,\n                          foreign_mod: &ast::foreign_mod) {\n-    let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n+    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n \n     let arch = ccx.sess.targ_cfg.arch;\n     let abi = match foreign_mod.abis.for_arch(arch) {\n@@ -370,19 +370,19 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n          *     }\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n+        let _icx = push_ctxt(\"foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n                    -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n+            let _icx = push_ctxt(\"foreign::shim::build_args\");\n             tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n         }\n \n         fn build_ret(bcx: block,\n                      tys: &ShimTypes,\n                      llargbundle: ValueRef,\n                      llretval: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n+            let _icx = push_ctxt(\"foreign::shim::build_ret\");\n             tys.fn_ty.build_shim_ret(bcx,\n                                      tys.llsig.llarg_tys,\n                                      tys.ret_def,\n@@ -488,7 +488,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n          * account for the Rust modes.\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n+        let _icx = push_ctxt(\"foreign::build_wrap_fn\");\n \n         build_wrap_fn_(ccx,\n                        tys,\n@@ -503,7 +503,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                       tys: &ShimTypes,\n                       llwrapfn: ValueRef,\n                       llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n+            let _icx = push_ctxt(\"foreign::wrap::build_args\");\n             let ccx = bcx.ccx();\n             let n = tys.llsig.llarg_tys.len();\n             for uint::range(0, n) |i| {\n@@ -528,7 +528,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         fn build_ret(bcx: block,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n+            let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n             let arg_count = shim_types.fn_sig.inputs.len();\n             for bcx.fcx.llretptr.iter().advance |&retptr| {\n                 let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n@@ -1155,15 +1155,15 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                         body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n+    let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @mut CrateContext,\n                      path: ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      id: ast::node_id)\n                   -> ValueRef {\n-        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n+        let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         // XXX: Bad copy.\n         let ps = link::mangle_internal_name_by_path(\n@@ -1205,11 +1205,11 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n          * one of those types that is passed by pointer in Rust.\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n+        let _icx = push_ctxt(\"foreign::foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n                       -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n+            let _icx = push_ctxt(\"foreign::extern::shim::build_args\");\n             let ccx = bcx.ccx();\n             let mut llargvals = ~[];\n             let mut i = 0u;\n@@ -1284,7 +1284,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n          *    }\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n+        let _icx = push_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n         build_wrap_fn_(ccx,\n                        tys,\n@@ -1299,15 +1299,15 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                       tys: &ShimTypes,\n                       llwrapfn: ValueRef,\n                       llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n+            let _icx = push_ctxt(\"foreign::foreign::wrap::build_args\");\n             tys.fn_ty.build_wrap_args(bcx,\n                                       tys.llsig.llret_ty,\n                                       llwrapfn,\n                                       llargbundle);\n         }\n \n         fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n+            let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n             tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n             build_return(bcx);\n         }\n@@ -1329,7 +1329,7 @@ pub fn register_foreign_fn(ccx: @mut CrateContext,\n                            node_id: ast::node_id,\n                            attrs: &[ast::attribute])\n                            -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n+    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n \n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n "}, {"sha": "127177118a07d9a737634cab2281e39d4afa7faa", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -45,15 +45,15 @@ use extra::time;\n use syntax::ast;\n \n pub fn trans_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_free\");\n+    let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         cx.tcx().lang_items.free_fn(),\n         [PointerCast(cx, v, Type::i8p())],\n         expr::Ignore)\n }\n \n pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_exchange_free\");\n+    let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         cx.tcx().lang_items.exchange_free_fn(),\n         [PointerCast(cx, v, Type::i8p())],\n@@ -62,7 +62,7 @@ pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n \n pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(\"take_ty\");\n+    let _icx = push_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n@@ -71,15 +71,15 @@ pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(\"drop_ty\");\n+    let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     return cx;\n }\n \n pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n+    let _icx = push_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).sty {\n         ty::ty_uniq(_)\n       | ty::ty_evec(_, ty::vstore_uniq)\n@@ -96,7 +96,7 @@ pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n-    let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n+    let _icx = push_ctxt(\"take_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n@@ -117,15 +117,15 @@ pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n \n pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(\"free_ty\");\n+    let _icx = push_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     return cx;\n }\n \n pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n+    let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -207,7 +207,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n                                           field: uint,\n                                           ti: @mut tydesc_info) -> bool {\n-    let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n+    let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n         let simpl_ti = get_tydesc(ccx, simpl);\n@@ -232,7 +232,7 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n-    let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n+    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx);\n \n     if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n@@ -300,7 +300,7 @@ pub fn call_tydesc_glue_full(bcx: block,\n                              tydesc: ValueRef,\n                              field: uint,\n                              static_ti: Option<@mut tydesc_info>) {\n-    let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n+    let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n@@ -347,14 +347,14 @@ pub fn call_tydesc_glue_full(bcx: block,\n // See [Note-arg-mode]\n pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n-    let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n+    let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n+    let _icx = push_ctxt(\"make_visit_glue\");\n     let bcx = do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n@@ -369,7 +369,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(\"make_free_glue\");\n+    let _icx = push_ctxt(\"make_free_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(body_mt) => {\n@@ -461,7 +461,7 @@ pub fn trans_struct_drop(bcx: block,\n \n pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n+    let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -532,7 +532,7 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n                               box_ptr_ptr: Option<ValueRef>,\n                               t: ty::t)\n                            -> block {\n-    let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n+    let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n     do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n@@ -551,7 +551,7 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n \n \n pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(\"make_take_glue\");\n+    let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -600,7 +600,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n }\n \n pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n-    let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n+    let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n@@ -650,7 +650,7 @@ pub type glue_helper = @fn(block, ValueRef, ty::t);\n \n pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: Type,\n                             name: ~str) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n+    let _icx = push_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n     debug!(\"%s is for type %s\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n@@ -665,7 +665,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n                                llfn: ValueRef,\n                                helper: glue_helper)\n                             -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n+    let _icx = push_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n@@ -695,7 +695,7 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n                          helper: glue_helper,\n                          name: &str)\n                       -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n+    let _icx = push_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n         return make_generic_glue_inner(ccx, t, llfn, helper);\n     }\n@@ -708,7 +708,7 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n }\n \n pub fn emit_tydescs(ccx: &mut CrateContext) {\n-    //let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n+    let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n     let glue_fn_ty = Type::generic_glue_fn(ccx);"}, {"sha": "01849ac6e8f182c5e3636ac327c65e01e8be551a", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -12,8 +12,7 @@ use core::prelude::*;\n \n use metadata::csearch;\n use middle::astencode;\n-use middle::trans::base::{get_insn_ctxt};\n-use middle::trans::base::{impl_owned_self, impl_self, no_self};\n+use middle::trans::base::{push_ctxt,impl_owned_self, impl_self, no_self};\n use middle::trans::base::{trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n@@ -30,7 +29,7 @@ use syntax::ast_util::local_def;\n pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id,\n                                 translate: bool)\n     -> ast::def_id {\n-    let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n+    let _icx = push_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline"}, {"sha": "3a8efb55c151bf6d02619c5b0c0da05c880d94af", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -51,7 +51,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n                   generics: &ast::Generics,\n                   self_ty: Option<ty::t>,\n                   id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n+    let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n     debug!(\"trans_impl(path=%s, name=%s, self_ty=%s, id=%?)\",\n@@ -159,7 +159,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n pub fn trans_self_arg(bcx: block,\n                       base: @ast::expr,\n                       mentry: typeck::method_map_entry) -> Result {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n+    let _icx = push_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n \n     // Compute the type of self.\n@@ -187,7 +187,7 @@ pub fn trans_method_callee(bcx: block,\n                            this: @ast::expr,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n+    let _icx = push_ctxt(\"impl::trans_method_callee\");\n     let tcx = bcx.tcx();\n \n     debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n@@ -293,7 +293,7 @@ pub fn trans_static_method_callee(bcx: block,\n                                   trait_id: ast::def_id,\n                                   callee_id: ast::node_id)\n                                -> FnData {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_static_method_callee\");\n+    let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_static_method_callee(method_id=%?, trait_id=%s, \\\n@@ -437,7 +437,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n                                   -> Callee {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n+    let _icx = push_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n@@ -586,7 +586,7 @@ pub fn trans_trait_callee(bcx: block,\n     // first evaluate the self expression (expected a by-ref result) and then\n     // extract the self data and vtable out of the pair.\n \n-    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n+    let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n     let self_datum = unpack_datum!(bcx,\n         expr::trans_to_datum(bcx, self_expr));\n@@ -619,7 +619,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     // Same as `trans_trait_callee()` above, except that it is given\n     // a by-ref pointer to the @Trait pair.\n \n-    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n+    let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n@@ -770,7 +770,7 @@ pub fn make_vtable(ccx: @mut CrateContext,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n     unsafe {\n-        let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n+        let _icx = push_ctxt(\"impl::make_vtable\");\n \n         let mut components = ~[ tydesc.tydesc ];\n         for ptrs.each |&ptr| {\n@@ -797,7 +797,7 @@ pub fn make_impl_vtable(bcx: block,\n                         vtables: typeck::vtable_res)\n                         -> ValueRef {\n     let ccx = bcx.ccx();\n-    let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n+    let _icx = push_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n@@ -841,7 +841,7 @@ pub fn trans_trait_cast(bcx: block,\n                         _store: ty::TraitStore)\n                      -> block {\n     let mut bcx = bcx;\n-    let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n+    let _icx = push_ctxt(\"impl::trans_cast\");\n \n     let lldest = match dest {\n         Ignore => {"}, {"sha": "17605fdd5be65dfd37028bd7a2386de923dd3cd5", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -13,9 +13,8 @@ use core::prelude::*;\n use back::link::mangle_exported_name;\n use driver::session;\n use lib::llvm::ValueRef;\n-use middle::trans::base::{get_insn_ctxt};\n use middle::trans::base::{set_inline_hint_if_appr, set_inline_hint};\n-use middle::trans::base::{trans_enum_variant};\n+use middle::trans::base::{trans_enum_variant,push_ctxt};\n use middle::trans::base::{trans_fn, decl_internal_cdecl_fn};\n use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n@@ -61,6 +60,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n            ref_id);\n \n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n+    let _icx = push_ctxt(\"monomorphic_fn\");\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs.tps, |t| {"}, {"sha": "d7c8c06c70717f417376a25aa38d6e8e6993e570", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -53,7 +53,7 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n }\n \n pub fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n+    let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n pub fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n@@ -68,20 +68,20 @@ pub fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n }\n \n pub fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n+    let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n pub fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n+    let _icx = push_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n                  fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n+    let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n@@ -105,7 +105,7 @@ pub fn alloc_vec(bcx: block,\n                  elts: uint,\n                  heap: heap)\n               -> Result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n+    let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = nonzero_llsize_of(ccx, llunitty);\n@@ -119,7 +119,7 @@ pub fn alloc_vec(bcx: block,\n }\n \n pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n-    let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n+    let _icx = push_ctxt(\"tvec::duplicate_uniq\");\n \n     let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -137,7 +137,7 @@ pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n \n pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n+    let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n@@ -349,7 +349,7 @@ pub fn write_content(bcx: block,\n                      content_expr: @ast::expr,\n                      dest: Dest)\n                   -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::write_content\");\n+    let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n     debug!(\"write_content(vt=%s, dest=%s, vstore_expr=%?)\",\n@@ -548,7 +548,7 @@ pub type iter_vec_block<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                     fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n+    let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n@@ -579,14 +579,14 @@ pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n \n pub fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                      fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n+    let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n pub fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n                         f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n+    let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);\n     return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);"}, {"sha": "d27d6efb2416f59a2ba439c971222157581ca997", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048ed1486f16191fbe72e32cc99f6f30a28a80e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=048ed1486f16191fbe72e32cc99f6f30a28a80e4", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n-    let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n+    let _icx = push_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n \n     let not_null = IsNotNull(bcx, box_datum.val);\n@@ -38,7 +38,7 @@ pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n }\n \n pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n-    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n+    let _icx = push_ctxt(\"uniq::duplicate\");\n \n     // Load the body of the source (*src)\n     let src_datum = immediate_rvalue(src_box, src_ty);"}]}