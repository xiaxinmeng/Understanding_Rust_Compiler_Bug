{"sha": "7f42e58effa3871dda6a41e250dea60cf88868ca", "node_id": "C_kwDOAAsO6NoAKDdmNDJlNThlZmZhMzg3MWRkYTZhNDFlMjUwZGVhNjBjZjg4ODY4Y2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-20T03:52:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-20T03:52:43Z"}, "message": "Auto merge of #105575 - compiler-errors:impl-wf-lint, r=oli-obk\n\nAdd `IMPLIED_BOUNDS_ENTAILMENT` lint\n\nImplements a lint (#105572) version of the hard-error introduced in #105483. Context is in that PR.\n\nr? `@lcnr`\ncc `@oli-obk` who had asked for this to be a lint first\n\nNot sure if this needs to be an FCP, since it's a lint for now.", "tree": {"sha": "99bf1fe8df70d9ec787a68f3cea44b16bb5bd328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99bf1fe8df70d9ec787a68f3cea44b16bb5bd328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f42e58effa3871dda6a41e250dea60cf88868ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f42e58effa3871dda6a41e250dea60cf88868ca", "html_url": "https://github.com/rust-lang/rust/commit/7f42e58effa3871dda6a41e250dea60cf88868ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f42e58effa3871dda6a41e250dea60cf88868ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c43bc135628bc0d472e1a1259d56b72b7de0a274", "url": "https://api.github.com/repos/rust-lang/rust/commits/c43bc135628bc0d472e1a1259d56b72b7de0a274", "html_url": "https://github.com/rust-lang/rust/commit/c43bc135628bc0d472e1a1259d56b72b7de0a274"}, {"sha": "8c86773fd37b26924d53cea518a136860e620265", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c86773fd37b26924d53cea518a136860e620265", "html_url": "https://github.com/rust-lang/rust/commit/8c86773fd37b26924d53cea518a136860e620265"}], "stats": {"total": 238, "additions": 223, "deletions": 15}, "files": [{"sha": "cddd307c13dbbe72d07c7259a8f41770ac83bef2", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 98, "deletions": 12, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -71,8 +71,14 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_predicate_entailment(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n-    {\n+    if let Err(_) = compare_predicate_entailment(\n+        tcx,\n+        impl_m,\n+        impl_m_span,\n+        trait_m,\n+        impl_trait_ref,\n+        CheckImpliedWfMode::Check,\n+    ) {\n         return;\n     }\n }\n@@ -150,6 +156,7 @@ fn compare_predicate_entailment<'tcx>(\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n+    check_implied_wf: CheckImpliedWfMode,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n@@ -255,15 +262,15 @@ fn compare_predicate_entailment<'tcx>(\n \n     let mut wf_tys = FxIndexSet::default();\n \n-    let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n+    let unnormalized_impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n         impl_m_span,\n         infer::HigherRankedType,\n         tcx.fn_sig(impl_m.def_id),\n     );\n+    let unnormalized_impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(unnormalized_impl_sig));\n \n     let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n-    let impl_sig = ocx.normalize(&norm_cause, param_env, impl_sig);\n-    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+    let impl_fty = ocx.normalize(&norm_cause, param_env, unnormalized_impl_fty);\n     debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n     let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n@@ -304,29 +311,108 @@ fn compare_predicate_entailment<'tcx>(\n         return Err(emitted);\n     }\n \n+    if check_implied_wf == CheckImpliedWfMode::Check {\n+        // We need to check that the impl's args are well-formed given\n+        // the hybrid param-env (impl + trait method where-clauses).\n+        ocx.register_obligation(traits::Obligation::new(\n+            infcx.tcx,\n+            ObligationCause::dummy(),\n+            param_env,\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n+        ));\n+    }\n+    let emit_implied_wf_lint = || {\n+        infcx.tcx.struct_span_lint_hir(\n+            rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n+            impl_m_hir_id,\n+            infcx.tcx.def_span(impl_m.def_id),\n+            \"impl method assumes more implied bounds than the corresponding trait method\",\n+            |lint| lint,\n+        );\n+    };\n+\n     // Check that all obligations are satisfied by the implementation's\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-        return Err(reported);\n+        match check_implied_wf {\n+            CheckImpliedWfMode::Check => {\n+                return compare_predicate_entailment(\n+                    tcx,\n+                    impl_m,\n+                    impl_m_span,\n+                    trait_m,\n+                    impl_trait_ref,\n+                    CheckImpliedWfMode::Skip,\n+                )\n+                .map(|()| {\n+                    // If the skip-mode was successful, emit a lint.\n+                    emit_implied_wf_lint();\n+                });\n+            }\n+            CheckImpliedWfMode::Skip => {\n+                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+                return Err(reported);\n+            }\n+        }\n     }\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n+    let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys.clone()),\n     );\n-    infcx.check_region_obligations_and_report_errors(\n-        impl_m.def_id.expect_local(),\n-        &outlives_environment,\n+    infcx.process_registered_region_obligations(\n+        outlives_env.region_bound_pairs(),\n+        outlives_env.param_env,\n     );\n+    let errors = infcx.resolve_regions(&outlives_env);\n+    if !errors.is_empty() {\n+        // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n+        // becomes a hard error (i.e. ideally we'd just call `resolve_regions_and_report_errors`\n+        match check_implied_wf {\n+            CheckImpliedWfMode::Check => {\n+                return compare_predicate_entailment(\n+                    tcx,\n+                    impl_m,\n+                    impl_m_span,\n+                    trait_m,\n+                    impl_trait_ref,\n+                    CheckImpliedWfMode::Skip,\n+                )\n+                .map(|()| {\n+                    // If the skip-mode was successful, emit a lint.\n+                    emit_implied_wf_lint();\n+                });\n+            }\n+            CheckImpliedWfMode::Skip => {\n+                if infcx.tainted_by_errors().is_none() {\n+                    infcx.err_ctxt().report_region_errors(impl_m.def_id.expect_local(), &errors);\n+                }\n+                return Err(tcx\n+                    .sess\n+                    .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"));\n+            }\n+        }\n+    }\n \n     Ok(())\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+enum CheckImpliedWfMode {\n+    /// Checks implied well-formedness of the impl method. If it fails, we will\n+    /// re-check with `Skip`, and emit a lint if it succeeds.\n+    Check,\n+    /// Skips checking implied well-formedness of the impl method, but will emit\n+    /// a lint if the `compare_predicate_entailment` succeeded. This means that\n+    /// the reason that we had failed earlier during `Check` was due to the impl\n+    /// having stronger requirements than the trait.\n+    Skip,\n+}\n+\n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,"}, {"sha": "a9ef91db059a1ccf381749b61b61b92407559152", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -1693,7 +1693,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n+    ) -> Option<ErrorGuaranteed> {\n         let errors = self.resolve_regions(outlives_env);\n \n         if let None = self.tainted_by_errors() {\n@@ -1704,6 +1704,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             // errors from silly ones.\n             self.report_region_errors(generic_param_scope, &errors);\n         }\n+\n+        (!errors.is_empty()).then(|| {\n+            self.tcx.sess.delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\")\n+        })\n     }\n \n     // [Note-Type-error-reporting]"}, {"sha": "47bd1564f0828ab1a36cb97f74d81b3f05143128", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -68,6 +68,7 @@ use crate::infer::{\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::ConstraintCategory;\n@@ -177,7 +178,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n+    ) -> Option<ErrorGuaranteed> {\n         self.process_registered_region_obligations(\n             outlives_env.region_bound_pairs(),\n             outlives_env.param_env,"}, {"sha": "f7a4103f4d5c1a06a4b6e4e7cd050684b926b31f", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -3311,6 +3311,7 @@ declare_lint_pass! {\n         FFI_UNWIND_CALLS,\n         REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n         NAMED_ARGUMENTS_USED_POSITIONALLY,\n+        IMPLIED_BOUNDS_ENTAILMENT,\n     ]\n }\n \n@@ -3998,3 +3999,44 @@ declare_lint! {\n     Warn,\n     \"named arguments in format used positionally\"\n }\n+\n+declare_lint! {\n+    /// The `implied_bounds_entailment` lint detects cases where the arguments of an impl method\n+    /// have stronger implied bounds than those from the trait method it's implementing.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(implied_bounds_entailment)]\n+    ///\n+    /// trait Trait {\n+    ///     fn get<'s>(s: &'s str, _: &'static &'static ()) -> &'static str;\n+    /// }\n+    ///\n+    /// impl Trait for () {\n+    ///     fn get<'s>(s: &'s str, _: &'static &'s ()) -> &'static str {\n+    ///         s\n+    ///     }\n+    /// }\n+    ///\n+    /// let val = <() as Trait>::get(&String::from(\"blah blah blah\"), &&());\n+    /// println!(\"{}\", val);\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Neither the trait method, which provides no implied bounds about `'s`, nor the impl,\n+    /// requires the main function to prove that 's: 'static, but the impl method is allowed\n+    /// to assume that `'s: 'static` within its own body.\n+    ///\n+    /// This can be used to implement an unsound API if used incorrectly.\n+    pub IMPLIED_BOUNDS_ENTAILMENT,\n+    Warn,\n+    \"impl method assumes more implied bounds than its corresponding trait method\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #105572 <https://github.com/rust-lang/rust/issues/105572>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseError,\n+    };\n+}"}, {"sha": "6ccbb5bb26651a6538a26578667b5b7aa4e30bb1", "filename": "src/test/ui/implied-bounds/impl-implied-bounds-compatibility-unnormalized.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -0,0 +1,22 @@\n+#![deny(implied_bounds_entailment)]\n+\n+trait Project {\n+    type Ty;\n+}\n+impl Project for &'_ &'_ () {\n+    type Ty = ();\n+}\n+trait Trait {\n+    fn get<'s>(s: &'s str, _: ()) -> &'static str;\n+}\n+impl Trait for () {\n+    fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n+        //~^ ERROR impl method assumes more implied bounds than the corresponding trait method\n+        //~| WARN this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+        s\n+    }\n+}\n+fn main() {\n+    let val = <() as Trait>::get(&String::from(\"blah blah blah\"), ());\n+    println!(\"{}\", val);\n+}"}, {"sha": "0ac31c642eb12ecc27853ad4ffd1041c8618b27b", "filename": "src/test/ui/implied-bounds/impl-implied-bounds-compatibility-unnormalized.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -0,0 +1,16 @@\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:5\n+   |\n+LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d097bc16a2214075d8f1fcc10e098354a2cd6ab3", "filename": "src/test/ui/implied-bounds/impl-implied-bounds-compatibility.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -0,0 +1,21 @@\n+#![deny(implied_bounds_entailment)]\n+\n+use std::cell::RefCell;\n+\n+pub struct MessageListeners<'a> {\n+    listeners: RefCell<Vec<Box<dyn FnMut(()) + 'a>>>,\n+}\n+\n+pub trait MessageListenersInterface {\n+    fn listeners<'c>(&'c self) -> &'c MessageListeners<'c>;\n+}\n+\n+impl<'a> MessageListenersInterface for MessageListeners<'a> {\n+    fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n+        //~^ ERROR impl method assumes more implied bounds than the corresponding trait method\n+        //~| WARN this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+        self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0dfa8167a99661d792c30da429d7d18a7c8d83fb", "filename": "src/test/ui/implied-bounds/impl-implied-bounds-compatibility.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -0,0 +1,16 @@\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:5\n+   |\n+LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7c57864245a9446f5849fac3c732557eb0b53ca3", "filename": "src/tools/clippy/tests/ui/borrow_interior_mutable_const/others.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f42e58effa3871dda6a41e250dea60cf88868ca/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs?ref=7f42e58effa3871dda6a41e250dea60cf88868ca", "patch": "@@ -42,7 +42,7 @@ impl<T> StaticRef<T> {\n impl<T> std::ops::Deref for StaticRef<T> {\n     type Target = T;\n \n-    fn deref(&self) -> &'static T {\n+    fn deref(&self) -> &T {\n         unsafe { &*self.ptr }\n     }\n }"}]}