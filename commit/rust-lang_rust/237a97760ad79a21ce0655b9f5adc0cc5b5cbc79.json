{"sha": "237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzN2E5Nzc2MGFkNzlhMjFjZTA2NTViOWY1YWRjMGNjNWI1Y2JjNzk=", "commit": {"author": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-01-14T03:34:23Z"}, "committer": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-07-16T21:25:32Z"}, "message": "integrate Lazy into std layout\n\nThis commit refactors the initial implementation to fit into std and\nmakes some other changes:\n\n- use MaybeUninit internally in SyncOnceCell\n- correctly impl Drop for lazy::Once\n- port Lazy::take from once_cell from: https://github.com/matklad/once_cell/pull/100\n\nCo-Authored-By: Paul Dicker <pitdicker@users.noreply.github.com>", "tree": {"sha": "e02cbdb97e7c2816dc0c7dc3178c34c9146e3fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e02cbdb97e7c2816dc0c7dc3178c34c9146e3fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "html_url": "https://github.com/rust-lang/rust/commit/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cac1768b03c8d6673c51605dca03997876979d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac1768b03c8d6673c51605dca03997876979d68", "html_url": "https://github.com/rust-lang/rust/commit/cac1768b03c8d6673c51605dca03997876979d68"}], "stats": {"total": 1548, "additions": 1002, "deletions": 546}, "files": [{"sha": "2027b5200eb70257174502fb26259e4411800a5c", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -1372,8 +1372,8 @@ checksum = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n- \"anyhow\",\n  \"clap\",\n+ \"failure\",\n  \"flate2\",\n  \"lazy_static\",\n  \"num_cpus\","}, {"sha": "e9af66ff6426472d499e4e2d62b856457a391b15", "filename": "src/libcore/lazy.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flazy.rs?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -0,0 +1,379 @@\n+//! Lazy values and one-time initialization of static data.\n+\n+use crate::cell::{Cell, UnsafeCell};\n+use crate::fmt;\n+use crate::mem;\n+use crate::ops::Deref;\n+\n+/// A cell which can be written to only once.\n+///\n+/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n+/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::OnceCell;\n+///\n+/// let cell = OnceCell::new();\n+/// assert!(cell.get().is_none());\n+///\n+/// let value: &String = cell.get_or_init(|| {\n+///     \"Hello, World!\".to_string()\n+/// });\n+/// assert_eq!(value, \"Hello, World!\");\n+/// assert!(cell.get().is_some());\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+pub struct OnceCell<T> {\n+    // Invariant: written to at most once.\n+    inner: UnsafeCell<Option<T>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T> Default for OnceCell<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n+            None => f.write_str(\"OnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: Clone> Clone for OnceCell<T> {\n+    fn clone(&self) -> OnceCell<T> {\n+        let res = OnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: Eq> Eq for OnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T> From<T> for OnceCell<T> {\n+    fn from(value: T) -> Self {\n+        OnceCell { inner: UnsafeCell::new(Some(value)) }\n+    }\n+}\n+\n+impl<T> OnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub const fn new() -> OnceCell<T> {\n+        OnceCell { inner: UnsafeCell::new(None) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn get(&self) -> Option<&T> {\n+        // Safety: Safe due to `inner`'s invariant\n+        unsafe { &*self.inner.get() }.as_ref()\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        // Safety: Safe because we have unique access\n+        unsafe { &mut *self.inner.get() }.as_mut()\n+    }\n+\n+    /// Sets the contents of the cell to `value`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n+    /// it was full.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert!(cell.get().is_none());\n+    ///\n+    /// assert_eq!(cell.set(92), Ok(()));\n+    /// assert_eq!(cell.set(62), Err(62));\n+    ///\n+    /// assert!(cell.get().is_some());\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        // Safety: Safe because we cannot have overlapping mutable borrows\n+        let slot = unsafe { &*self.inner.get() };\n+        if slot.is_some() {\n+            return Err(value);\n+        }\n+\n+        // Safety: This is the only place where we set the slot, no races\n+        // due to reentrancy/concurrency are possible, and we've\n+        // checked that slot is currently `None`, so this write\n+        // maintains the `inner`'s invariant.\n+        let slot = unsafe { &mut *self.inner.get() };\n+        *slot = Some(value);\n+        Ok(())\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f`\n+    /// if the cell was empty.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        if let Some(val) = self.get() {\n+            return Ok(val);\n+        }\n+        let val = f()?;\n+        // Note that *some* forms of reentrant initialization might lead to\n+        // UB (see `reentrant_init` test). I believe that just removing this\n+        // `assert`, while keeping `set/get` would be sound, but it seems\n+        // better to panic, rather than to silently use an old value.\n+        assert!(self.set(val).is_ok(), \"reentrant init\");\n+        Ok(self.get().unwrap())\n+    }\n+\n+    /// Consumes the cell, returning the wrapped value.\n+    ///\n+    /// Returns `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.inner.into_inner()\n+    }\n+\n+    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let mut cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+}\n+\n+/// A value which is initialized on the first access.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::Lazy;\n+///\n+/// let lazy: Lazy<i32> = Lazy::new(|| {\n+///     println!(\"initializing\");\n+///     92\n+/// });\n+/// println!(\"ready\");\n+/// println!(\"{}\", *lazy);\n+/// println!(\"{}\", *lazy);\n+///\n+/// // Prints:\n+/// //   ready\n+/// //   initializing\n+/// //   92\n+/// //   92\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+pub struct Lazy<T, F = fn() -> T> {\n+    cell: OnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+impl<T, F> Lazy<T, F> {\n+    /// Creates a new lazy value with the given initializing function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// # fn main() {\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let hello = \"Hello, World!\".to_string();\n+    ///\n+    /// let lazy = Lazy::new(|| hello.to_uppercase());\n+    ///\n+    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub const fn new(init: F) -> Lazy<T, F> {\n+        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> Lazy<T, F> {\n+    /// Forces the evaluation of this lazy value and returns a reference to\n+    /// the result.\n+    ///\n+    /// This is equivalent to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let lazy = Lazy::new(|| 92);\n+    ///\n+    /// assert_eq!(Lazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn force(this: &Lazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        Lazy::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: Default> Default for Lazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> Lazy<T> {\n+        Lazy::new(T::default)\n+    }\n+}"}, {"sha": "1e6a27cff0ce1b032af2edd7d1f45564fdcadb42", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -239,6 +239,8 @@ pub mod char;\n pub mod ffi;\n #[cfg(not(test))] // See #65860\n pub mod iter;\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+pub mod lazy;\n pub mod option;\n pub mod panic;\n pub mod panicking;"}, {"sha": "1c0bddb9aef624c4671ae98aa201f4ed10c02dae", "filename": "src/libcore/tests/lazy.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flazy.rs?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -0,0 +1,124 @@\n+use core::{\n+    cell::Cell,\n+    lazy::{Lazy, OnceCell},\n+    sync::atomic::{AtomicUsize, Ordering::SeqCst},\n+};\n+\n+#[test]\n+fn once_cell() {\n+    let c = OnceCell::new();\n+    assert!(c.get().is_none());\n+    c.get_or_init(|| 92);\n+    assert_eq!(c.get(), Some(&92));\n+\n+    c.get_or_init(|| panic!(\"Kabom!\"));\n+    assert_eq!(c.get(), Some(&92));\n+}\n+\n+#[test]\n+fn once_cell_get_mut() {\n+    let mut c = OnceCell::new();\n+    assert!(c.get_mut().is_none());\n+    c.set(90).unwrap();\n+    *c.get_mut().unwrap() += 2;\n+    assert_eq!(c.get_mut(), Some(&mut 92));\n+}\n+\n+#[test]\n+fn once_cell_drop() {\n+    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+    struct Dropper;\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROP_CNT.fetch_add(1, SeqCst);\n+        }\n+    }\n+\n+    let x = OnceCell::new();\n+    x.get_or_init(|| Dropper);\n+    assert_eq!(DROP_CNT.load(SeqCst), 0);\n+    drop(x);\n+    assert_eq!(DROP_CNT.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn unsync_once_cell_drop_empty() {\n+    let x = OnceCell::<&'static str>::new();\n+    drop(x);\n+}\n+\n+#[test]\n+fn clone() {\n+    let s = OnceCell::new();\n+    let c = s.clone();\n+    assert!(c.get().is_none());\n+\n+    s.set(\"hello\").unwrap();\n+    let c = s.clone();\n+    assert_eq!(c.get().map(|c| *c), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn from_impl() {\n+    assert_eq!(OnceCell::from(\"value\").get(), Some(&\"value\"));\n+    assert_ne!(OnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+}\n+\n+#[test]\n+fn partialeq_impl() {\n+    assert!(OnceCell::from(\"value\") == OnceCell::from(\"value\"));\n+    assert!(OnceCell::from(\"foo\") != OnceCell::from(\"bar\"));\n+\n+    assert!(OnceCell::<&'static str>::new() == OnceCell::new());\n+    assert!(OnceCell::<&'static str>::new() != OnceCell::from(\"value\"));\n+}\n+\n+#[test]\n+fn into_inner() {\n+    let cell: OnceCell<&'static str> = OnceCell::new();\n+    assert_eq!(cell.into_inner(), None);\n+    let cell = OnceCell::new();\n+    cell.set(\"hello\").unwrap();\n+    assert_eq!(cell.into_inner(), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn lazy_new() {\n+    let called = Cell::new(0);\n+    let x = Lazy::new(|| {\n+        called.set(called.get() + 1);\n+        92\n+    });\n+\n+    assert_eq!(called.get(), 0);\n+\n+    let y = *x - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(called.get(), 1);\n+\n+    let y = *x - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(called.get(), 1);\n+}\n+\n+#[test]\n+fn aliasing_in_get() {\n+    let x = OnceCell::new();\n+    x.set(42).unwrap();\n+    let at_x = x.get().unwrap(); // --- (shared) borrow of inner `Option<T>` --+\n+    let _ = x.set(27); // <-- temporary (unique) borrow of inner `Option<T>`   |\n+    println!(\"{}\", at_x); // <------- up until here ---------------------------+\n+}\n+\n+#[test]\n+#[should_panic(expected = \"reentrant init\")]\n+fn reentrant_init() {\n+    let x: OnceCell<Box<i32>> = OnceCell::new();\n+    let dangling_ref: Cell<Option<&i32>> = Cell::new(None);\n+    x.get_or_init(|| {\n+        let r = x.get_or_init(|| Box::new(92));\n+        dangling_ref.set(Some(r));\n+        Box::new(62)\n+    });\n+    eprintln!(\"use after free: {:?}\", dangling_ref.get().unwrap());\n+}"}, {"sha": "47ed6db6c677b17428d423aa2cd40379df8e3645", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -43,6 +43,7 @@\n #![feature(option_unwrap_none)]\n #![feature(peekable_next_if)]\n #![feature(partition_point)]\n+#![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n@@ -62,6 +63,7 @@ mod fmt;\n mod hash;\n mod intrinsics;\n mod iter;\n+mod lazy;\n mod manually_drop;\n mod mem;\n mod nonzero;"}, {"sha": "c7553caa4c056cc101d68119ae28f17b275430f3", "filename": "src/libstd/lazy.rs", "status": "modified", "additions": 491, "deletions": 541, "changes": 1032, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibstd%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibstd%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flazy.rs?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -1,508 +1,32 @@\n-//! `lazy` modules provides lazy values and one-time initialization of static data.\n-//!\n-//! `lazy` provides two new cell-like types, `OnceCell` and `SyncOnceCell`. `OnceCell`\n-//! might store arbitrary non-`Copy` types, can be assigned to at most once and provide direct access\n-//! to the stored contents. In a nutshell, API looks *roughly* like this:\n-//!\n-//! ```rust,ignore\n-//! impl<T> OnceCell<T> {\n-//!     fn new() -> OnceCell<T> { ... }\n-//!     fn set(&self, value: T) -> Result<(), T> { ... }\n-//!     fn get(&self) -> Option<&T> { ... }\n-//! }\n-//! ```\n-//!\n-//! Note that, like with `RefCell` and `Mutex`, the `set` method requires only a shared reference.\n-//! Because of the single assignment restriction `get` can return an `&T` instead of `Ref<T>`\n-//! or `MutexGuard<T>`.\n-//!\n-//! The `SyncOnceCell` flavor is thread-safe (that is, implements [`Sync`]) trait, while  `OnceCell` one is not.\n-//!\n-//! [`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n-//!\n-//! # Patterns\n-//!\n-//! `OnceCell` might be useful for a variety of patterns.\n-//!\n-//! ## Safe Initialization of global data\n-//!\n-//! ```rust\n-//! use std::{env, io};\n-//! use std::lazy::SyncOnceCell;\n-//!\n-//! #[derive(Debug)]\n-//! pub struct Logger {\n-//!     // ...\n-//! }\n-//! static INSTANCE: OnceCell<Logger> = OnceCell::new();\n-//!\n-//! impl Logger {\n-//!     pub fn global() -> &'static Logger {\n-//!         INSTANCE.get().expect(\"logger is not initialized\")\n-//!     }\n-//!\n-//!     fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n-//!        // ...\n-//! #      Ok(Logger {})\n-//!     }\n-//! }\n-//!\n-//! fn main() {\n-//!     let logger = Logger::from_cli(env::args()).unwrap();\n-//!     INSTANCE.set(logger).unwrap();\n-//!     // use `Logger::global()` from now on\n-//! }\n-//! ```\n-//!\n-//! ## Lazy initialized global data\n-//!\n-//! This is essentially `lazy_static!` macro, but without a macro.\n-//!\n-//! ```rust\n-//! use std::{sync::Mutex, collections::HashMap};\n-//! use lazy::SyncOnceCell;\n-//!\n-//! fn global_data() -> &'static Mutex<HashMap<i32, String>> {\n-//!     static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n-//!     INSTANCE.get_or_init(|| {\n-//!         let mut m = HashMap::new();\n-//!         m.insert(13, \"Spica\".to_string());\n-//!         m.insert(74, \"Hoyten\".to_string());\n-//!         Mutex::new(m)\n-//!     })\n-//! }\n-//! ```\n-//!\n-//! There are also `sync::Lazy` and `unsync::Lazy` convenience types to streamline this pattern:\n-//!\n-//! ```rust\n-//! use std::{sync::Mutex, collections::HashMap};\n-//! use lazy::SyncLazy;\n-//!\n-//! static GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n-//!     let mut m = HashMap::new();\n-//!     m.insert(13, \"Spica\".to_string());\n-//!     m.insert(74, \"Hoyten\".to_string());\n-//!     Mutex::new(m)\n-//! });\n-//!\n-//! fn main() {\n-//!     println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n-//! }\n-//! ```\n-//!\n-//! ## General purpose lazy evaluation\n-//!\n-//! `Lazy` also works with local variables.\n-//!\n-//! ```rust\n-//! use std::lazy::Lazy;\n-//!\n-//! fn main() {\n-//!     let ctx = vec![1, 2, 3];\n-//!     let thunk = Lazy::new(|| {\n-//!         ctx.iter().sum::<i32>()\n-//!     });\n-//!     assert_eq!(*thunk, 6);\n-//! }\n-//! ```\n-//!\n-//! If you need a lazy field in a struct, you probably should use `OnceCell`\n-//! directly, because that will allow you to access `self` during initialization.\n-//!\n-//! ```rust\n-//! use std::{fs, path::PathBuf};\n-//!\n-//! use std::lazy::OnceCell;\n-//!\n-//! struct Ctx {\n-//!     config_path: PathBuf,\n-//!     config: OnceCell<String>,\n-//! }\n-//!\n-//! impl Ctx {\n-//!     pub fn get_config(&self) -> Result<&str, std::io::Error> {\n-//!         let cfg = self.config.get_or_try_init(|| {\n-//!             fs::read_to_string(&self.config_path)\n-//!         })?;\n-//!         Ok(cfg.as_str())\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! ## Building block\n-//!\n-//! Naturally, it is  possible to build other abstractions on top of `OnceCell`.\n-//! For example, this is a `regex!` macro which takes a string literal and returns an\n-//! *expression* that evaluates to a `&'static Regex`:\n-//!\n-//! ```\n-//! macro_rules! regex {\n-//!     ($re:literal $(,)?) => {{\n-//!         static RE: std::lazy::SyncOnceCell<regex::Regex> = std::lazy::SyncOnceCell::new();\n-//!         RE.get_or_init(|| regex::Regex::new($re).unwrap())\n-//!     }};\n-//! }\n-//! ```\n-//!\n-//! This macro can be useful to avoid \"compile regex on every loop iteration\" problem.\n-//!\n-//! # Comparison with other interior mutatbility types\n-//!\n-//! |`!Sync` types         | Access Mode            | Drawbacks                                     |\n-//! |----------------------|------------------------|-----------------------------------------------|\n-//! |`Cell<T>`             | `T`                    | requires `T: Copy` for `get`                  |\n-//! |`RefCell<T>`          | `RefMut<T>` / `Ref<T>` | may panic at runtime                          |\n-//! |`OnceCell<T>`         | `&T`                   | assignable only once                          |\n-//!\n-//! |`Sync` types          | Access Mode            | Drawbacks                                     |\n-//! |----------------------|------------------------|-----------------------------------------------|\n-//! |`AtomicT`             | `T`                    | works only with certain `Copy` types          |\n-//! |`Mutex<T>`            | `MutexGuard<T>`        | may deadlock at runtime, may block the thread |\n-//! |`SyncOnceCell<T>`     | `&T`                   | assignable only once, may block the thread    |\n-//!\n-//! Technically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls\n-//! itself. However, because the assignment can happen only once, such cases should be more rare than\n-//! equivalents with `RefCell` and `Mutex`.\n+//! Lazy values and one-time initialization of static data.\n \n use crate::{\n     cell::{Cell, UnsafeCell},\n     fmt,\n-    hint::unreachable_unchecked,\n     marker::PhantomData,\n-    ops::Deref,\n+    mem::{self, MaybeUninit},\n+    ops::{Deref, Drop},\n     panic::{RefUnwindSafe, UnwindSafe},\n     sync::atomic::{AtomicBool, AtomicUsize, Ordering},\n     thread::{self, Thread},\n };\n \n-/// A cell which can be written to only once. Not thread safe.\n-///\n-/// Unlike `:td::cell::RefCell`, a `OnceCell` provides simple `&`\n-/// references to the contents.\n-///\n-/// # Example\n-/// ```\n-/// use std::lazy::OnceCell;\n-///\n-/// let cell = OnceCell::new();\n-/// assert!(cell.get().is_none());\n-///\n-/// let value: &String = cell.get_or_init(|| {\n-///     \"Hello, World!\".to_string()\n-/// });\n-/// assert_eq!(value, \"Hello, World!\");\n-/// assert!(cell.get().is_some());\n-/// ```\n-pub struct OnceCell<T> {\n-    // Invariant: written to at most once.\n-    inner: UnsafeCell<Option<T>>,\n-}\n-\n-// Similarly to a `Sync` bound on `SyncOnceCell`, we can use\n-// `&OnceCell` to sneak a `T` through `catch_unwind`,\n-// by initializing the cell in closure and extracting the value in the\n-// `Drop`.\n-#[cfg(feature = \"std\")]\n-impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for OnceCell<T> {}\n-#[cfg(feature = \"std\")]\n-impl<T: UnwindSafe> UnwindSafe for OnceCell<T> {}\n-\n-impl<T> Default for OnceCell<T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n-            None => f.write_str(\"OnceCell(Uninit)\"),\n-        }\n-    }\n-}\n-\n-impl<T: Clone> Clone for OnceCell<T> {\n-    fn clone(&self) -> OnceCell<T> {\n-        let res = OnceCell::new();\n-        if let Some(value) = self.get() {\n-            match res.set(value.clone()) {\n-                Ok(()) => (),\n-                Err(_) => unreachable!(),\n-            }\n-        }\n-        res\n-    }\n-}\n-\n-impl<T: PartialEq> PartialEq for OnceCell<T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.get() == other.get()\n-    }\n-}\n-\n-impl<T: Eq> Eq for OnceCell<T> {}\n-\n-impl<T> From<T> for OnceCell<T> {\n-    fn from(value: T) -> Self {\n-        OnceCell { inner: UnsafeCell::new(Some(value)) }\n-    }\n-}\n-\n-impl<T> OnceCell<T> {\n-    /// Creates a new empty cell.\n-    pub const fn new() -> OnceCell<T> {\n-        OnceCell { inner: UnsafeCell::new(None) }\n-    }\n-\n-    /// Gets the reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty.\n-    pub fn get(&self) -> Option<&T> {\n-        // Safe due to `inner`'s invariant\n-        unsafe { &*self.inner.get() }.as_ref()\n-    }\n-\n-    /// Gets the mutable reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty.\n-    pub fn get_mut(&mut self) -> Option<&mut T> {\n-        // Safe because we have unique access\n-        unsafe { &mut *self.inner.get() }.as_mut()\n-    }\n-\n-    /// Sets the contents of this cell to `value`.\n-    ///\n-    /// Returns `Ok(())` if the cell was empty and `Err(value)` if it was\n-    /// full.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// assert!(cell.get().is_none());\n-    ///\n-    /// assert_eq!(cell.set(92), Ok(()));\n-    /// assert_eq!(cell.set(62), Err(62));\n-    ///\n-    /// assert!(cell.get().is_some());\n-    /// ```\n-    pub fn set(&self, value: T) -> Result<(), T> {\n-        let slot = unsafe { &*self.inner.get() };\n-        if slot.is_some() {\n-            return Err(value);\n-        }\n-        let slot = unsafe { &mut *self.inner.get() };\n-        // This is the only place where we set the slot, no races\n-        // due to reentrancy/concurrency are possible, and we've\n-        // checked that slot is currently `None`, so this write\n-        // maintains the `inner`'s invariant.\n-        *slot = Some(value);\n-        Ok(())\n-    }\n+#[doc(inline)]\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+pub use core::lazy::*;\n \n-    /// Gets the contents of the cell, initializing it with `f`\n-    /// if the cell was empty.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. Doing\n-    /// so results in a panic.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// let value = cell.get_or_init(|| 92);\n-    /// assert_eq!(value, &92);\n-    /// let value = cell.get_or_init(|| unreachable!());\n-    /// assert_eq!(value, &92);\n-    /// ```\n-    pub fn get_or_init<F>(&self, f: F) -> &T\n-    where\n-        F: FnOnce() -> T,\n-    {\n-        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n-            Ok(val) => val,\n-        }\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f` if\n-    /// the cell was empty. If the cell was empty and `f` failed, an\n-    /// error is returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. Doing\n-    /// so results in a panic.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n-    /// assert!(cell.get().is_none());\n-    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n-    ///     Ok(92)\n-    /// });\n-    /// assert_eq!(value, Ok(&92));\n-    /// assert_eq!(cell.get(), Some(&92))\n-    /// ```\n-    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n-    where\n-        F: FnOnce() -> Result<T, E>,\n-    {\n-        if let Some(val) = self.get() {\n-            return Ok(val);\n-        }\n-        let val = f()?;\n-        // Note that *some* forms of reentrant initialization might lead to\n-        // UB (see `reentrant_init` test). I believe that just removing this\n-        // `assert`, while keeping `set/get` would be sound, but it seems\n-        // better to panic, rather than to silently use an old value.\n-        assert!(self.set(val).is_ok(), \"reentrant init\");\n-        Ok(self.get().unwrap())\n-    }\n-\n-    /// Consumes the `OnceCell`, returning the wrapped value.\n-    ///\n-    /// Returns `None` if the cell was empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell: OnceCell<String> = OnceCell::new();\n-    /// assert_eq!(cell.into_inner(), None);\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n-    /// ```\n-    pub fn into_inner(self) -> Option<T> {\n-        // Because `into_inner` takes `self` by value, the compiler statically verifies\n-        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n-        self.inner.into_inner()\n-    }\n-}\n-\n-/// A value which is initialized on the first access.\n+/// A synchronization primitive which can be written to only once.\n ///\n-/// # Example\n-/// ```\n-/// use std::lazy::Lazy;\n+/// This type is a thread-safe `OnceCell`.\n ///\n-/// let lazy: Lazy<i32> = Lazy::new(|| {\n-///     println!(\"initializing\");\n-///     92\n-/// });\n-/// println!(\"ready\");\n-/// println!(\"{}\", *lazy);\n-/// println!(\"{}\", *lazy);\n+/// # Examples\n ///\n-/// // Prints:\n-/// //   ready\n-/// //   initializing\n-/// //   92\n-/// //   92\n /// ```\n-pub struct Lazy<T, F = fn() -> T> {\n-    cell: OnceCell<T>,\n-    init: Cell<Option<F>>,\n-}\n-\n-#[cfg(feature = \"std\")]\n-impl<T, F: RefUnwindSafe> RefUnwindSafe for Lazy<T, F> where OnceCell<T>: RefUnwindSafe {}\n-\n-impl<T: fmt::Debug, F: fmt::Debug> fmt::Debug for Lazy<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n-    }\n-}\n-\n-impl<T, F> Lazy<T, F> {\n-    /// Creates a new lazy value with the given initializing function.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// # fn main() {\n-    /// use std::lazy::Lazy;\n-    ///\n-    /// let hello = \"Hello, World!\".to_string();\n-    ///\n-    /// let lazy = Lazy::new(|| hello.to_uppercase());\n-    ///\n-    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n-    /// # }\n-    /// ```\n-    pub const fn new(init: F) -> Lazy<T, F> {\n-        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n-    }\n-}\n-\n-impl<T, F: FnOnce() -> T> Lazy<T, F> {\n-    /// Forces the evaluation of this lazy value and returns a reference to\n-    /// the result.\n-    ///\n-    /// This is equivalent to the `Deref` impl, but is explicit.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use std::lazy::Lazy;\n-    ///\n-    /// let lazy = Lazy::new(|| 92);\n-    ///\n-    /// assert_eq!(Lazy::force(&lazy), &92);\n-    /// assert_eq!(&*lazy, &92);\n-    /// ```\n-    pub fn force(this: &Lazy<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"Lazy instance has previously been poisoned\"),\n-        })\n-    }\n-}\n-\n-impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        Lazy::force(self)\n-    }\n-}\n-\n-impl<T: Default> Default for Lazy<T> {\n-    /// Creates a new lazy value using `Default` as the initializing function.\n-    fn default() -> Lazy<T> {\n-        Lazy::new(T::default)\n-    }\n-}\n-\n-/// A thread-safe cell which can be written to only once.\n+/// #![feature(once_cell)]\n ///\n-/// `OnceCell` provides `&` references to the contents without RAII guards.\n-///\n-/// Reading a non-`None` value out of `OnceCell` establishes a\n-/// happens-before relationship with a corresponding write. For example, if\n-/// thread A initializes the cell with `get_or_init(f)`, and thread B\n-/// subsequently reads the result of this call, B also observes all the side\n-/// effects of `f`.\n-///\n-/// # Example\n-/// ```\n /// use std::lazy::SyncOnceCell;\n ///\n-/// static CELL: OnceCell<String> = OnceCell::new();\n+/// static CELL: SyncOnceCell<String> = SyncOnceCell::new();\n /// assert!(CELL.get().is_none());\n ///\n /// std::thread::spawn(|| {\n@@ -516,44 +40,49 @@ impl<T: Default> Default for Lazy<T> {\n /// assert!(value.is_some());\n /// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n /// ```\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n pub struct SyncOnceCell<T> {\n     // This `state` word is actually an encoded version of just a pointer to a\n     // `Waiter`, so we add the `PhantomData` appropriately.\n     state_and_queue: AtomicUsize,\n     _marker: PhantomData<*mut Waiter>,\n-    // FIXME: switch to `std::mem::MaybeUninit` once we are ready to bump MSRV\n-    // that far. It was stabilized in 1.36.0, so, if you are reading this and\n-    // it's higher than 1.46.0 outside, please send a PR! ;) (and do the same\n-    // for `Lazy`, while we are at it).\n-    pub(crate) value: UnsafeCell<Option<T>>,\n+    // Whether or not the value is initialized is tracked by `state_and_queue`.\n+    value: UnsafeCell<MaybeUninit<T>>,\n }\n \n // Why do we need `T: Send`?\n-// Thread A creates a `OnceCell` and shares it with\n+// Thread A creates a `SyncOnceCell` and shares it with\n // scoped thread B, which fills the cell, which is\n // then destroyed by A. That is, destructor observes\n // a sent value.\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n unsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n unsafe impl<T: Send> Send for SyncOnceCell<T> {}\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T> Default for SyncOnceCell<T> {\n     fn default() -> SyncOnceCell<T> {\n         SyncOnceCell::new()\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n-            Some(v) => f.debug_tuple(\"SyncOnceCell\").field(v).finish(),\n-            None => f.write_str(\"SyncOnceCell(Uninit)\"),\n+            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n+            None => f.write_str(\"Once(Uninit)\"),\n         }\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: Clone> Clone for SyncOnceCell<T> {\n     fn clone(&self) -> SyncOnceCell<T> {\n         let res = SyncOnceCell::new();\n@@ -567,6 +96,7 @@ impl<T: Clone> Clone for SyncOnceCell<T> {\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T> From<T> for SyncOnceCell<T> {\n     fn from(value: T) -> Self {\n         let cell = Self::new();\n@@ -575,28 +105,32 @@ impl<T> From<T> for SyncOnceCell<T> {\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n     fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n         self.get() == other.get()\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: Eq> Eq for SyncOnceCell<T> {}\n \n impl<T> SyncOnceCell<T> {\n     /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub const fn new() -> SyncOnceCell<T> {\n         SyncOnceCell {\n             state_and_queue: AtomicUsize::new(INCOMPLETE),\n             _marker: PhantomData,\n-            value: UnsafeCell::new(None),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n         }\n     }\n \n     /// Gets the reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty, or being initialized. This\n     /// method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn get(&self) -> Option<&T> {\n         if self.is_initialized() {\n             // Safe b/c checked is_initialize\n@@ -608,29 +142,14 @@ impl<T> SyncOnceCell<T> {\n \n     /// Gets the mutable reference to the underlying value.\n     ///\n-    /// Returns `None` if the cell is empty.\n+    /// Returns `None` if the cell is empty. This method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn get_mut(&mut self) -> Option<&mut T> {\n-        // Safe b/c we have a unique access.\n-        unsafe { &mut *self.value.get() }.as_mut()\n-    }\n-\n-    /// Get the reference to the underlying value, without checking if the\n-    /// cell is initialized.\n-    ///\n-    /// Safety:\n-    ///\n-    /// Caller must ensure that the cell is in initialized state, and that\n-    /// the contents are acquired by (synchronized to) this thread.\n-    pub unsafe fn get_unchecked(&self) -> &T {\n-        debug_assert!(self.is_initialized());\n-        let slot: &Option<T> = &*self.value.get();\n-        match slot {\n-            Some(value) => value,\n-            // This unsafe does improve performance, see `examples/bench`.\n-            None => {\n-                debug_assert!(false);\n-                unreachable_unchecked()\n-            }\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialize and we have a unique access\n+            Some(unsafe { self.get_unchecked_mut() })\n+        } else {\n+            None\n         }\n     }\n \n@@ -639,8 +158,11 @@ impl<T> SyncOnceCell<T> {\n     /// Returns `Ok(())` if the cell was empty and `Err(value)` if it was\n     /// full.\n     ///\n-    /// # Example\n+    /// # Examples\n+    ///\n     /// ```\n+    /// #![feature(once_cell)]\n+    ///\n     /// use std::lazy::SyncOnceCell;\n     ///\n     /// static CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n@@ -656,6 +178,7 @@ impl<T> SyncOnceCell<T> {\n     ///     assert_eq!(CELL.get(), Some(&92));\n     /// }\n     /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn set(&self, value: T) -> Result<(), T> {\n         let mut value = Some(value);\n         self.get_or_init(|| value.take().unwrap());\n@@ -681,8 +204,11 @@ impl<T> SyncOnceCell<T> {\n     /// exact outcome is unspecified. Current implementation deadlocks, but\n     /// this may be changed to a panic in the future.\n     ///\n-    /// # Example\n+    /// # Examples\n+    ///\n     /// ```\n+    /// #![feature(once_cell)]\n+    ///\n     /// use std::lazy::SyncOnceCell;\n     ///\n     /// let cell = SyncOnceCell::new();\n@@ -691,6 +217,7 @@ impl<T> SyncOnceCell<T> {\n     /// let value = cell.get_or_init(|| unreachable!());\n     /// assert_eq!(value, &92);\n     /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn get_or_init<F>(&self, f: F) -> &T\n     where\n         F: FnOnce() -> T,\n@@ -713,8 +240,11 @@ impl<T> SyncOnceCell<T> {\n     /// The exact outcome is unspecified. Current implementation\n     /// deadlocks, but this may be changed to a panic in the future.\n     ///\n-    /// # Example\n+    /// # Examples\n+    ///\n     /// ```\n+    /// #![feature(once_cell)]\n+    ///\n     /// use std::lazy::SyncOnceCell;\n     ///\n     /// let cell = SyncOnceCell::new();\n@@ -726,18 +256,22 @@ impl<T> SyncOnceCell<T> {\n     /// assert_eq!(value, Ok(&92));\n     /// assert_eq!(cell.get(), Some(&92))\n     /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n     where\n         F: FnOnce() -> Result<T, E>,\n     {\n         // Fast path check\n+        // NOTE: This acquire here is important to ensure\n+        // `SyncLazy::force` is correctly synchronized\n         if let Some(value) = self.get() {\n             return Ok(value);\n         }\n         self.initialize(f)?;\n \n-        // Safe b/c called initialize\n         debug_assert!(self.is_initialized());\n+\n+        // Safety: The inner value has been initialized\n         Ok(unsafe { self.get_unchecked() })\n     }\n \n@@ -747,6 +281,8 @@ impl<T> SyncOnceCell<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(once_cell)]\n+    ///\n     /// use std::lazy::SyncOnceCell;\n     ///\n     /// let cell: SyncOnceCell<String> = SyncOnceCell::new();\n@@ -756,10 +292,59 @@ impl<T> SyncOnceCell<T> {\n     /// cell.set(\"hello\".to_string()).unwrap();\n     /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n     /// ```\n-    pub fn into_inner(self) -> Option<T> {\n-        // Because `into_inner` takes `self` by value, the compiler statically verifies\n-        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n-        self.value.into_inner()\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn into_inner(mut self) -> Option<T> {\n+        // Safety: Safe because we immediately free `self` without dropping\n+        let inner = unsafe { self.take_inner() };\n+\n+        // Don't drop this `SyncOnceCell`. We just moved out one of the fields, but didn't set\n+        // the state to uninitialized.\n+        mem::ManuallyDrop::new(self);\n+        inner\n+    }\n+\n+    /// Takes the value out of this `SyncOnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `SyncOnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let mut cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = SyncOnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+\n+    /// Takes the wrapped value out of a `SyncOnceCell`.\n+    /// Afterwards the cell is no longer initialized.\n+    ///\n+    /// Safety: The cell must now be free'd WITHOUT dropping. No other usages of the cell\n+    /// are valid. Only used by `into_inner` and `drop`.\n+    unsafe fn take_inner(&mut self) -> Option<T> {\n+        // The mutable reference guarantees there are no other threads that can observe us\n+        // taking out the wrapped value.\n+        // Right after this function `self` is supposed to be freed, so it makes little sense\n+        // to atomically set the state to uninitialized.\n+        if self.is_initialized() {\n+            let value = mem::replace(&mut self.value, UnsafeCell::new(MaybeUninit::uninit()));\n+            Some(value.into_inner().assume_init())\n+        } else {\n+            None\n+        }\n     }\n \n     /// Safety: synchronizes with store to value via Release/(Acquire|SeqCst).\n@@ -787,7 +372,7 @@ impl<T> SyncOnceCell<T> {\n             let f = f.take().unwrap();\n             match f() {\n                 Ok(value) => {\n-                    unsafe { *slot.get() = Some(value) };\n+                    unsafe { (&mut *slot.get()).write(value) };\n                     true\n                 }\n                 Err(e) => {\n@@ -798,18 +383,33 @@ impl<T> SyncOnceCell<T> {\n         });\n         res\n     }\n+\n+    /// Safety: The value must be initialized\n+    unsafe fn get_unchecked(&self) -> &T {\n+        debug_assert!(self.is_initialized());\n+        (&*self.value.get()).get_ref()\n+    }\n+\n+    /// Safety: The value must be initialized\n+    unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n+        debug_assert!(self.is_initialized());\n+        (&mut *self.value.get()).get_mut()\n+    }\n+}\n+\n+impl<T> Drop for SyncOnceCell<T> {\n+    fn drop(&mut self) {\n+        // Safety: The cell is being dropped, so it can't be accessed again\n+        unsafe { self.take_inner() };\n+    }\n }\n \n-// region: copy-paste\n-// The following code is copied from `sync::Once`.\n-// This should be uncopypasted once we decide the right way to handle panics.\n const INCOMPLETE: usize = 0x0;\n const RUNNING: usize = 0x1;\n const COMPLETE: usize = 0x2;\n \n const STATE_MASK: usize = 0x3;\n \n-\n #[repr(align(4))]\n struct Waiter {\n     thread: Cell<Option<Thread>>,\n@@ -901,19 +501,21 @@ fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n         break;\n     }\n }\n-// endregion: copy-paste\n \n /// A value which is initialized on the first access.\n ///\n-/// This type is thread-safe and can be used in statics:\n+/// This type is a thread-safe `Lazy`, and can be used in statics.\n+///\n+/// # Examples\n ///\n-/// # Example\n /// ```\n+/// #![feature(once_cell)]\n+///\n /// use std::collections::HashMap;\n ///\n-/// use std::lazy::Lazy;\n+/// use std::lazy::SyncLazy;\n ///\n-/// static HASHMAP: Lazy<HashMap<i32, String>> = Lazy::new(|| {\n+/// static HASHMAP: SyncLazy<HashMap<i32, String>> = SyncLazy::new(|| {\n ///     println!(\"initializing\");\n ///     let mut m = HashMap::new();\n ///     m.insert(13, \"Spica\".to_string());\n@@ -935,14 +537,16 @@ fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n ///     //   Some(\"Hoyten\")\n /// }\n /// ```\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n pub struct SyncLazy<T, F = fn() -> T> {\n     cell: SyncOnceCell<T>,\n     init: Cell<Option<F>>,\n }\n \n-impl<T: fmt::Debug, F: fmt::Debug> fmt::Debug for SyncLazy<T, F> {\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n+impl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SyncLazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n     }\n }\n \n@@ -951,15 +555,17 @@ impl<T: fmt::Debug, F: fmt::Debug> fmt::Debug for SyncLazy<T, F> {\n // we do create a `&mut Option<F>` in `force`, but this is\n // properly synchronized, so it only happens once\n // so it also does not contribute to this impl.\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n // auto-derived `Send` impl is OK.\n \n-#[cfg(feature = \"std\")]\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T, F: RefUnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n \n impl<T, F> SyncLazy<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub const fn new(f: F) -> SyncLazy<T, F> {\n         SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n     }\n@@ -970,33 +576,377 @@ impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n     /// returns a reference to result. This is equivalent\n     /// to the `Deref` impl, but is explicit.\n     ///\n-    /// # Example\n+    /// # Examples\n+    ///\n     /// ```\n+    /// #![feature(once_cell)]\n+    ///\n     /// use std::lazy::SyncLazy;\n     ///\n     /// let lazy = SyncLazy::new(|| 92);\n     ///\n     /// assert_eq!(SyncLazy::force(&lazy), &92);\n     /// assert_eq!(&*lazy, &92);\n     /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn force(this: &SyncLazy<T, F>) -> &T {\n         this.cell.get_or_init(|| match this.init.take() {\n             Some(f) => f(),\n-            None => panic!(\"SyncLazy instance has previously been poisoned\"),\n+            None => panic!(\"Lazy instance has previously been poisoned\"),\n         })\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n     type Target = T;\n     fn deref(&self) -> &T {\n         SyncLazy::force(self)\n     }\n }\n \n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n impl<T: Default> Default for SyncLazy<T> {\n     /// Creates a new lazy value using `Default` as the initializing function.\n     fn default() -> SyncLazy<T> {\n         SyncLazy::new(T::default)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        lazy::{Lazy, SyncLazy, SyncOnceCell},\n+        panic,\n+        sync::{\n+            atomic::{AtomicUsize, Ordering::SeqCst},\n+            mpsc::channel,\n+            Mutex,\n+        },\n+    };\n+\n+    #[test]\n+    fn lazy_default() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct Foo(u8);\n+        impl Default for Foo {\n+            fn default() -> Self {\n+                CALLED.fetch_add(1, SeqCst);\n+                Foo(42)\n+            }\n+        }\n+\n+        let lazy: Lazy<Mutex<Foo>> = <_>::default();\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        assert_eq!(lazy.lock().unwrap().0, 42);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+\n+        lazy.lock().unwrap().0 = 21;\n+\n+        assert_eq!(lazy.lock().unwrap().0, 21);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn lazy_poisoning() {\n+        let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n+        for _ in 0..2 {\n+            let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    // miri doesn't support threads\n+    #[cfg(not(miri))]\n+    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+        crate::thread::spawn(f).join().unwrap()\n+    }\n+\n+    #[cfg(not(miri))]\n+    fn spawn(f: impl FnOnce() + Send + 'static) {\n+        let _ = crate::thread::spawn(f);\n+    }\n+\n+    // \"stub threads\" for Miri\n+    #[cfg(miri)]\n+    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+        f(())\n+    }\n+\n+    #[cfg(miri)]\n+    fn spawn(f: impl FnOnce() + Send + 'static) {\n+        f(())\n+    }\n+\n+    #[test]\n+    fn sync_once_cell() {\n+        static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+\n+        assert!(ONCE_CELL.get().is_none());\n+\n+        spawn_and_wait(|| {\n+            ONCE_CELL.get_or_init(|| 92);\n+            assert_eq!(ONCE_CELL.get(), Some(&92));\n+        });\n+\n+        ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n+        assert_eq!(ONCE_CELL.get(), Some(&92));\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_get_mut() {\n+        let mut c = SyncOnceCell::new();\n+        assert!(c.get_mut().is_none());\n+        c.set(90).unwrap();\n+        *c.get_mut().unwrap() += 2;\n+        assert_eq!(c.get_mut(), Some(&mut 92));\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_get_unchecked() {\n+        let c = SyncOnceCell::new();\n+        c.set(92).unwrap();\n+        unsafe {\n+            assert_eq!(c.get_unchecked(), &92);\n+        }\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_drop() {\n+        static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+        struct Dropper;\n+        impl Drop for Dropper {\n+            fn drop(&mut self) {\n+                DROP_CNT.fetch_add(1, SeqCst);\n+            }\n+        }\n+\n+        let x = SyncOnceCell::new();\n+        spawn_and_wait(move || {\n+            x.get_or_init(|| Dropper);\n+            assert_eq!(DROP_CNT.load(SeqCst), 0);\n+            drop(x);\n+        });\n+\n+        assert_eq!(DROP_CNT.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_drop_empty() {\n+        let x = SyncOnceCell::<String>::new();\n+        drop(x);\n+    }\n+\n+    #[test]\n+    fn clone() {\n+        let s = SyncOnceCell::new();\n+        let c = s.clone();\n+        assert!(c.get().is_none());\n+\n+        s.set(\"hello\".to_string()).unwrap();\n+        let c = s.clone();\n+        assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n+    }\n+\n+    #[test]\n+    fn get_or_try_init() {\n+        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+        assert!(cell.get().is_none());\n+\n+        let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n+        assert!(res.is_err());\n+        assert!(cell.get().is_none());\n+\n+        assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+\n+        assert_eq!(\n+            cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())),\n+            Ok(&\"hello\".to_string())\n+        );\n+        assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn from_impl() {\n+        assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n+        assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+    }\n+\n+    #[test]\n+    fn partialeq_impl() {\n+        assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n+        assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n+\n+        assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n+        assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+        assert_eq!(cell.into_inner(), None);\n+        let cell = SyncOnceCell::new();\n+        cell.set(\"hello\".to_string()).unwrap();\n+        assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn sync_lazy_new() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+        static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n+            CALLED.fetch_add(1, SeqCst);\n+            92\n+        });\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        spawn_and_wait(|| {\n+            let y = *SYNC_LAZY - 30;\n+            assert_eq!(y, 62);\n+            assert_eq!(CALLED.load(SeqCst), 1);\n+        });\n+\n+        let y = *SYNC_LAZY - 30;\n+        assert_eq!(y, 62);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn sync_lazy_default() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct Foo(u8);\n+        impl Default for Foo {\n+            fn default() -> Self {\n+                CALLED.fetch_add(1, SeqCst);\n+                Foo(42)\n+            }\n+        }\n+\n+        let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        assert_eq!(lazy.lock().unwrap().0, 42);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+\n+        lazy.lock().unwrap().0 = 21;\n+\n+        assert_eq!(lazy.lock().unwrap().0, 21);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // leaks memory\n+    fn static_sync_lazy() {\n+        static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n+            let mut xs = Vec::new();\n+            xs.push(1);\n+            xs.push(2);\n+            xs.push(3);\n+            xs\n+        });\n+\n+        spawn_and_wait(|| {\n+            assert_eq!(&*XS, &vec![1, 2, 3]);\n+        });\n+\n+        assert_eq!(&*XS, &vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // leaks memory\n+    fn static_sync_lazy_via_fn() {\n+        fn xs() -> &'static Vec<i32> {\n+            static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n+            XS.get_or_init(|| {\n+                let mut xs = Vec::new();\n+                xs.push(1);\n+                xs.push(2);\n+                xs.push(3);\n+                xs\n+            })\n+        }\n+        assert_eq!(xs(), &vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn sync_lazy_poisoning() {\n+        let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n+        for _ in 0..2 {\n+            let res = panic::catch_unwind(|| x.len());\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn is_sync_send() {\n+        fn assert_traits<T: Send + Sync>() {}\n+        assert_traits::<SyncOnceCell<String>>();\n+        assert_traits::<SyncLazy<String>>();\n+    }\n+\n+    #[test]\n+    fn eval_once_macro() {\n+        macro_rules! eval_once {\n+            (|| -> $ty:ty {\n+                $($body:tt)*\n+            }) => {{\n+                static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n+                fn init() -> $ty {\n+                    $($body)*\n+                }\n+                ONCE_CELL.get_or_init(init)\n+            }};\n+        }\n+\n+        let fib: &'static Vec<i32> = eval_once! {\n+            || -> Vec<i32> {\n+                let mut res = vec![1, 1];\n+                for i in 0..10 {\n+                    let next = res[i] + res[i + 1];\n+                    res.push(next);\n+                }\n+                res\n+            }\n+        };\n+        assert_eq!(fib[5], 8)\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // deadlocks without real threads\n+    fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n+        static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+\n+        let n_readers = 10;\n+        let n_writers = 3;\n+        const MSG: &str = \"Hello, World\";\n+\n+        let (tx, rx) = channel();\n+\n+        for _ in 0..n_readers {\n+            let tx = tx.clone();\n+            spawn(move || {\n+                loop {\n+                    if let Some(msg) = ONCE_CELL.get() {\n+                        tx.send(msg).unwrap();\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+        for _ in 0..n_writers {\n+            spawn(move || {\n+                let _ = ONCE_CELL.set(MSG.to_owned());\n+            });\n+        }\n+\n+        for _ in 0..n_readers {\n+            let msg = rx.recv().unwrap();\n+            assert_eq!(msg, MSG);\n+        }\n+    }\n+}"}, {"sha": "8178719ccc40a47f5c587e31a18eb9dc4bac4269", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237a97760ad79a21ce0655b9f5adc0cc5b5cbc79/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=237a97760ad79a21ce0655b9f5adc0cc5b5cbc79", "patch": "@@ -285,13 +285,15 @@\n #![feature(linkage)]\n #![feature(llvm_asm)]\n #![feature(log_syntax)]\n+#![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(once_cell)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(panic_info_message)]\n@@ -476,10 +478,7 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n-#[unstable(\n-    feature = \"std_lazy\",\n-    issue = \"99\",\n-)]\n+#[unstable(feature = \"once_cell\", issue = \"68198\")]\n pub mod lazy;\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]"}]}