{"sha": "d58abab2e74004f54ebbd778a9602b28314b9a39", "node_id": "C_kwDOAAsO6NoAKGQ1OGFiYWIyZTc0MDA0ZjU0ZWJiZDc3OGE5NjAyYjI4MzE0YjlhMzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-22T06:18:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-22T06:18:29Z"}, "message": "Auto merge of #2142 - saethlin:cleanup-data-race-ice, r=oli-obk\n\nMake allow_data_races_* public and use it during EnvVars::cleanup\n\nFixes https://github.com/rust-lang/miri/issues/2020\n\nI've tried for hours now to come up with a test case for this ICE with no luck. I suspect there's something about the way the data race detection works under these conditions that I just don't understand :weary:.\n\nBut I tried this change out on a handful of crates and I don't see any more ICEs of this form. For whatever reason it seems like `bastion==0.4.5` is a good way to run into this, with the flags\n```\nMIRIFLAGS=\"-Zmiri-tag-raw-pointers -Zmiri-panic-on-unsupported -Zmiri-disable-isolation\" cargo +miri miri test --no-fail-fast --doc\n```\nI think all the cases I've run into with this involve both `-Zmiri-panic-on-unsupported` and `-Zmiri-tag-raw-pointers`, so it could be that the combination of an unexpected panic and a machine halt is required.", "tree": {"sha": "9e6bbf53f00358cdc3b69768a3ab1019462890bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e6bbf53f00358cdc3b69768a3ab1019462890bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d58abab2e74004f54ebbd778a9602b28314b9a39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d58abab2e74004f54ebbd778a9602b28314b9a39", "html_url": "https://github.com/rust-lang/rust/commit/d58abab2e74004f54ebbd778a9602b28314b9a39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d58abab2e74004f54ebbd778a9602b28314b9a39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5fc544ae8a0f94bff025ca1be3de92af730cb61", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5fc544ae8a0f94bff025ca1be3de92af730cb61", "html_url": "https://github.com/rust-lang/rust/commit/b5fc544ae8a0f94bff025ca1be3de92af730cb61"}, {"sha": "3cfce6ffb23d8ea83593b4956212954a0459d372", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfce6ffb23d8ea83593b4956212954a0459d372", "html_url": "https://github.com/rust-lang/rust/commit/3cfce6ffb23d8ea83593b4956212954a0459d372"}], "stats": {"total": 91, "additions": 49, "deletions": 42}, "files": [{"sha": "5a6dd1d81d06112f51fae99830539cfc975ccd60", "filename": "src/data_race.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d58abab2e74004f54ebbd778a9602b28314b9a39/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58abab2e74004f54ebbd778a9602b28314b9a39/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=d58abab2e74004f54ebbd778a9602b28314b9a39", "patch": "@@ -437,6 +437,49 @@ impl MemoryCellClocks {\n /// Evaluation context extensions.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+    /// Temporarily allow data-races to occur. This should only be used in\n+    /// one of these cases:\n+    /// - One of the appropriate `validate_atomic` functions will be called to\n+    /// to treat a memory access as atomic.\n+    /// - The memory being accessed should be treated as internal state, that\n+    /// cannot be accessed by the interpreted program.\n+    /// - Execution of the interpreted program execution has halted.\n+    #[inline]\n+    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n+        let this = self.eval_context_ref();\n+        let old = if let Some(data_race) = &this.machine.data_race {\n+            data_race.multi_threaded.replace(false)\n+        } else {\n+            false\n+        };\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.multi_threaded.set(old);\n+        }\n+        result\n+    }\n+\n+    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n+    /// so should only be used for atomic operations or internal state that the program cannot\n+    /// access.\n+    #[inline]\n+    fn allow_data_races_mut<R>(\n+        &mut self,\n+        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n+    ) -> R {\n+        let this = self.eval_context_mut();\n+        let old = if let Some(data_race) = &this.machine.data_race {\n+            data_race.multi_threaded.replace(false)\n+        } else {\n+            false\n+        };\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.multi_threaded.set(old);\n+        }\n+        result\n+    }\n+\n     /// Atomic variant of read_scalar_at_offset.\n     fn read_scalar_at_offset_atomic(\n         &self,\n@@ -927,47 +970,6 @@ impl VClockAlloc {\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n-    // Temporarily allow data-races to occur, this should only be\n-    // used if either one of the appropriate `validate_atomic` functions\n-    // will be called to treat a memory access as atomic or if the memory\n-    // being accessed should be treated as internal state, that cannot be\n-    // accessed by the interpreted program.\n-    #[inline]\n-    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n-        let this = self.eval_context_ref();\n-        let old = if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.replace(false)\n-        } else {\n-            false\n-        };\n-        let result = op(this);\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.set(old);\n-        }\n-        result\n-    }\n-\n-    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n-    /// so should only be used for atomic operations or internal state that the program cannot\n-    /// access.\n-    #[inline]\n-    fn allow_data_races_mut<R>(\n-        &mut self,\n-        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n-    ) -> R {\n-        let this = self.eval_context_mut();\n-        let old = if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.replace(false)\n-        } else {\n-            false\n-        };\n-        let result = op(this);\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.set(old);\n-        }\n-        result\n-    }\n-\n     /// Generic atomic operation implementation\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,"}, {"sha": "c4d58eb77143ba04d080621a554257ec7d408e8d", "filename": "src/eval.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d58abab2e74004f54ebbd778a9602b28314b9a39/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58abab2e74004f54ebbd778a9602b28314b9a39/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=d58abab2e74004f54ebbd778a9602b28314b9a39", "patch": "@@ -344,7 +344,12 @@ pub fn eval_entry<'tcx>(\n     })();\n \n     // Machine cleanup.\n-    EnvVars::cleanup(&mut ecx).unwrap();\n+    // Execution of the program has halted so any memory access we do here\n+    // cannot produce a real data race. If we do not do something to disable\n+    // data race detection here, some uncommon combination of errors will\n+    // cause a data race to be detected:\n+    // https://github.com/rust-lang/miri/issues/2020\n+    ecx.allow_data_races_mut(|ecx| EnvVars::cleanup(ecx).unwrap());\n \n     // Process the result.\n     match res {"}]}