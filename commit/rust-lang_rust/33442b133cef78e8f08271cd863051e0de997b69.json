{"sha": "33442b133cef78e8f08271cd863051e0de997b69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNDQyYjEzM2NlZjc4ZThmMDgyNzFjZDg2MzA1MWUwZGU5OTdiNjk=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-02-28T18:54:19Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-03-15T18:15:06Z"}, "message": "overhaul intra-doc-link ambiguity warning\n\n- Makes the warning part of the `intra_doc_link_resolution_failure`\nlint.\n- Tightens the span to just the ambiguous link.\n- Reports ambiguities across all three namespaces.\n- Uses structured suggestions for disambiguation.\n- Adds a test for the warnings.", "tree": {"sha": "3a1be5f2de6a8aa6381bc75f53c8a44c79c1b1d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1be5f2de6a8aa6381bc75f53c8a44c79c1b1d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33442b133cef78e8f08271cd863051e0de997b69", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAlyL67EWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdDnuB/9TNQu9Co7st2vMf9hYiYlliQCI\nvHf0xa9gXeF2E/26tvVfCddMA8kX5Qnw/7Ievqd0nG4LcNSHuuDlmcQlXEAJAFjf\nxIVwGG788gvRCf6zXr/uh1z/tsOevlNWv0DI0h0FkkZ4s4SCESM3nxr/Y8Pz/91J\n6RRnndBpmESd863/rpckQNtYqPMbasTUQbgqdeNdDHKLRKTLlvUEIvLFASZgjPRd\nMhWsyBAP8MnS3iJa0nk4RxcWas+LcJ7Z48Z7+mI6Xg7aXxUyiACB5xGLeWPO4nVv\n2XAeGbP0zWRPBScmnyb4yDSdy4mhrTxvfZvt9BXF8UzL+QjugxreBjz+22Hr\n=hlKZ\n-----END PGP SIGNATURE-----", "payload": "tree 3a1be5f2de6a8aa6381bc75f53c8a44c79c1b1d2\nparent 16e7e05e95a6a5a1e0dba54ae722274bd7d725f7\nauthor Andy Russell <arussell123@gmail.com> 1551380059 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1552673706 -0400\n\noverhaul intra-doc-link ambiguity warning\n\n- Makes the warning part of the `intra_doc_link_resolution_failure`\nlint.\n- Tightens the span to just the ambiguous link.\n- Reports ambiguities across all three namespaces.\n- Uses structured suggestions for disambiguation.\n- Adds a test for the warnings.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33442b133cef78e8f08271cd863051e0de997b69", "html_url": "https://github.com/rust-lang/rust/commit/33442b133cef78e8f08271cd863051e0de997b69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33442b133cef78e8f08271cd863051e0de997b69/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e7e05e95a6a5a1e0dba54ae722274bd7d725f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7", "html_url": "https://github.com/rust-lang/rust/commit/16e7e05e95a6a5a1e0dba54ae722274bd7d725f7"}], "stats": {"total": 361, "additions": 266, "deletions": 95}, "files": [{"sha": "36bfe2fb2c3dacf1fe9936a4bf92a4143bfb2e5e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 146, "deletions": 94, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/33442b133cef78e8f08271cd863051e0de997b69/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33442b133cef78e8f08271cd863051e0de997b69/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=33442b133cef78e8f08271cd863051e0de997b69", "patch": "@@ -1,7 +1,8 @@\n-use rustc::lint as lint;\n-use rustc::hir;\n+use errors::Applicability;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::lint as lint;\n use rustc::ty;\n use syntax;\n use syntax::ast::{self, Ident};\n@@ -53,6 +54,13 @@ struct LinkCollector<'a, 'tcx> {\n     is_nightly_build: bool,\n }\n \n+#[derive(Debug, Copy, Clone)]\n+enum Namespace {\n+    Type,\n+    Value,\n+    Macro,\n+}\n+\n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n         LinkCollector {\n@@ -345,57 +353,52 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     PathKind::Unknown => {\n                         // Try everything!\n+                        let mut candidates = vec![];\n+\n                         if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                            if let Ok(type_def) =\n-                                self.resolve(path_str, false, &current_item, parent_node)\n-                            {\n-                                let (type_kind, article, type_disambig)\n-                                    = type_ns_kind(type_def.0, path_str);\n-                                ambiguity_error(cx, &item.attrs, path_str,\n-                                                article, type_kind, &type_disambig,\n-                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                                continue;\n-                            } else if let Ok(value_def) =\n-                                self.resolve(path_str, true, &current_item, parent_node)\n-                            {\n-                                let (value_kind, value_disambig)\n-                                    = value_ns_kind(value_def.0, path_str)\n-                                        .expect(\"struct and mod cases should have been \\\n-                                                 caught in previous branch\");\n-                                ambiguity_error(cx, &item.attrs, path_str,\n-                                                \"a\", value_kind, &value_disambig,\n-                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                            }\n-                            (macro_def, None)\n-                        } else if let Ok(type_def) =\n+                            candidates.push(((macro_def, None), Namespace::Macro));\n+                        }\n+\n+                        if let Ok(type_def) =\n                             self.resolve(path_str, false, &current_item, parent_node)\n                         {\n-                            // It is imperative we search for not-a-value first\n-                            // Otherwise we will find struct ctors for when we are looking\n-                            // for structs, and the link won't work if there is something in\n-                            // both namespaces.\n-                            if let Ok(value_def) =\n-                                self.resolve(path_str, true, &current_item, parent_node)\n-                            {\n-                                let kind = value_ns_kind(value_def.0, path_str);\n-                                if let Some((value_kind, value_disambig)) = kind {\n-                                    let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_def.0, path_str);\n-                                    ambiguity_error(cx, &item.attrs, path_str,\n-                                                    article, type_kind, &type_disambig,\n-                                                    \"a\", value_kind, &value_disambig);\n-                                    continue;\n-                                }\n-                            }\n-                            type_def\n-                        } else if let Ok(value_def) =\n+                            candidates.push((type_def, Namespace::Type));\n+                        }\n+\n+                        if let Ok(value_def) =\n                             self.resolve(path_str, true, &current_item, parent_node)\n                         {\n-                            value_def\n-                        } else {\n+                            // Structs, variants, and mods exist in both namespaces, skip them.\n+                            match value_def.0 {\n+                                Def::StructCtor(..)\n+                                | Def::Mod(..)\n+                                | Def::Variant(..)\n+                                | Def::VariantCtor(..)\n+                                | Def::SelfCtor(..) => (),\n+                                _ => candidates.push((value_def, Namespace::Value)),\n+                            }\n+                        }\n+\n+                        if candidates.len() == 1 {\n+                            candidates.remove(0).0\n+                        } else if candidates.is_empty() {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // this could just be a normal link\n                             continue;\n+                        } else {\n+                            let candidates = candidates.into_iter().map(|((def, _), ns)| {\n+                                (def, ns)\n+                            }).collect::<Vec<_>>();\n+\n+                            ambiguity_error(\n+                                cx,\n+                                &item.attrs,\n+                                path_str,\n+                                &dox,\n+                                link_range,\n+                                &candidates,\n+                            );\n+                            continue;\n                         }\n                     }\n                     PathKind::Macro => {\n@@ -505,59 +508,108 @@ fn resolution_failure(\n     diag.emit();\n }\n \n-fn ambiguity_error(cx: &DocContext<'_>, attrs: &Attributes,\n-                   path_str: &str,\n-                   article1: &str, kind1: &str, disambig1: &str,\n-                   article2: &str, kind2: &str, disambig2: &str) {\n+fn ambiguity_error(\n+    cx: &DocContext<'_>,\n+    attrs: &Attributes,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+    candidates: &[(Def, Namespace)],\n+) {\n     let sp = span_of_attrs(attrs);\n-    cx.sess()\n-      .struct_span_warn(sp,\n-                        &format!(\"`{}` is both {} {} and {} {}\",\n-                                 path_str, article1, kind1,\n-                                 article2, kind2))\n-      .help(&format!(\"try `{}` if you want to select the {}, \\\n-                      or `{}` if you want to \\\n-                      select the {}\",\n-                      disambig1, kind1, disambig2,\n-                      kind2))\n-      .emit();\n-}\n \n-/// Given a def, returns its name and disambiguator\n-/// for a value namespace.\n-///\n-/// Returns `None` for things which cannot be ambiguous since\n-/// they exist in both namespaces (structs and modules).\n-fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n-    match def {\n-        // Structs, variants, and mods exist in both namespaces; skip them.\n-        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) |\n-        Def::VariantCtor(..) | Def::SelfCtor(..)\n-            => None,\n-        Def::Fn(..)\n-            => Some((\"function\", format!(\"{}()\", path_str))),\n-        Def::Method(..)\n-            => Some((\"method\", format!(\"{}()\", path_str))),\n-        Def::Const(..)\n-            => Some((\"const\", format!(\"const@{}\", path_str))),\n-        Def::Static(..)\n-            => Some((\"static\", format!(\"static@{}\", path_str))),\n-        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n+    let mut msg = format!(\"`{}` is \", path_str);\n+\n+    match candidates {\n+        [(first_def, _), (second_def, _)] => {\n+            msg += &format!(\n+                \"both {} {} and {} {}\",\n+                first_def.article(),\n+                first_def.kind_name(),\n+                second_def.article(),\n+                second_def.kind_name(),\n+            );\n+        }\n+        _ => {\n+            let mut candidates = candidates.iter().peekable();\n+            while let Some((def, _)) = candidates.next() {\n+                if candidates.peek().is_some() {\n+                    msg += &format!(\"{} {}, \", def.article(), def.kind_name());\n+                } else {\n+                    msg += &format!(\"and {} {}\", def.article(), def.kind_name());\n+                }\n+            }\n+        }\n     }\n-}\n \n-/// Given a def, returns its name, the article to be used, and a disambiguator\n-/// for the type namespace.\n-fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n-    let (kind, article) = match def {\n-        // We can still have non-tuple structs.\n-        Def::Struct(..) => (\"struct\", \"a\"),\n-        Def::Enum(..) => (\"enum\", \"an\"),\n-        Def::Trait(..) => (\"trait\", \"a\"),\n-        Def::Union(..) => (\"union\", \"a\"),\n-        _ => (\"type\", \"a\"),\n-    };\n-    (kind, article, format!(\"{}@{}\", kind, path_str))\n+    let mut diag = cx.tcx.struct_span_lint_hir(\n+        lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        hir::CRATE_HIR_ID,\n+        sp,\n+        &msg,\n+    );\n+\n+    if let Some(link_range) = link_range {\n+        if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n+            diag.set_span(sp);\n+            diag.span_label(sp, \"ambiguous link\");\n+\n+            for (def, ns) in candidates {\n+                let (action, mut suggestion) = match def {\n+                    Def::Method(..) | Def::Fn(..) => {\n+                        (\"add parentheses\", format!(\"{}()\", path_str))\n+                    }\n+                    _ => {\n+                        let type_ = match (def, ns) {\n+                            (Def::Const(..), _) => \"const\",\n+                            (Def::Static(..), _) => \"static\",\n+                            (Def::Struct(..), _) => \"struct\",\n+                            (Def::Enum(..), _) => \"enum\",\n+                            (Def::Union(..), _) => \"union\",\n+                            (Def::Trait(..), _) => \"trait\",\n+                            (Def::Mod(..), _) => \"module\",\n+                            (_, Namespace::Type) => \"type\",\n+                            (_, Namespace::Value) => \"value\",\n+                            (_, Namespace::Macro) => \"macro\",\n+                        };\n+\n+                        // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n+                        (\"prefix with the item type\", format!(\"{}@{}\", type_, path_str))\n+                    }\n+                };\n+\n+                if dox.bytes().nth(link_range.start) == Some(b'`') {\n+                    suggestion = format!(\"`{}`\", suggestion);\n+                }\n+\n+                diag.span_suggestion(\n+                    sp,\n+                    &format!(\"to link to the {}, {}\", def.kind_name(), action),\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        } else {\n+            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+            //                       ^     ~~~~\n+            //                       |     link_range\n+            //                       last_new_line_offset\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                 {indicator: <before$}{indicator:^<found$}\",\n+                line=line,\n+                indicator=\"\",\n+                before=link_range.start - last_new_line_offset,\n+                found=link_range.len(),\n+            ));\n+        }\n+    }\n+\n+    diag.emit();\n }\n \n /// Given an enum variant's def, return the def of its enum and the associated fragment."}, {"sha": "7316fcdad677296c31011a90dc4a2690be2e1e22", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/33442b133cef78e8f08271cd863051e0de997b69/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33442b133cef78e8f08271cd863051e0de997b69/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs?ref=33442b133cef78e8f08271cd863051e0de997b69", "patch": "@@ -0,0 +1,36 @@\n+#![deny(intra_doc_link_resolution_failure)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_upper_case_globals)]\n+\n+pub fn ambiguous() {}\n+\n+pub struct ambiguous {}\n+\n+#[macro_export]\n+macro_rules! multi_conflict { () => {} }\n+\n+#[allow(non_camel_case_types)]\n+pub struct multi_conflict {}\n+\n+pub fn multi_conflict() {}\n+\n+pub mod type_and_value {}\n+\n+pub const type_and_value: i32 = 0;\n+\n+pub mod foo {\n+    pub enum bar {}\n+\n+    pub fn bar() {}\n+}\n+\n+/// [`ambiguous`] is ambiguous. //~ERROR `ambiguous`\n+///\n+/// [ambiguous] is ambiguous. //~ERROR ambiguous\n+///\n+/// [`multi_conflict`] is a three-way conflict. //~ERROR `multi_conflict`\n+///\n+/// Ambiguous [type_and_value]. //~ERROR type_and_value\n+///\n+/// Ambiguous non-implied shortcut link [`foo::bar`]. //~ERROR `foo::bar`\n+pub struct Docs {}"}, {"sha": "3506e7f29c413a5c580519f91f0815c126b41fdc", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/33442b133cef78e8f08271cd863051e0de997b69/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33442b133cef78e8f08271cd863051e0de997b69/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr?ref=33442b133cef78e8f08271cd863051e0de997b69", "patch": "@@ -0,0 +1,82 @@\n+error: `ambiguous` is both a struct and a function\n+  --> $DIR/intra-links-ambiguity.rs:27:6\n+   |\n+LL | /// [`ambiguous`] is ambiguous.\n+   |      ^^^^^^^^^^^ ambiguous link\n+   |\n+note: lint level defined here\n+  --> $DIR/intra-links-ambiguity.rs:1:9\n+   |\n+LL | #![deny(intra_doc_link_resolution_failure)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the struct, prefix with the item type\n+   |\n+LL | /// [`struct@ambiguous`] is ambiguous.\n+   |      ^^^^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// [`ambiguous()`] is ambiguous.\n+   |      ^^^^^^^^^^^^^\n+\n+error: `ambiguous` is both a struct and a function\n+  --> $DIR/intra-links-ambiguity.rs:29:6\n+   |\n+LL | /// [ambiguous] is ambiguous.\n+   |      ^^^^^^^^^ ambiguous link\n+help: to link to the struct, prefix with the item type\n+   |\n+LL | /// [struct@ambiguous] is ambiguous.\n+   |      ^^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// [ambiguous()] is ambiguous.\n+   |      ^^^^^^^^^^^\n+\n+error: `multi_conflict` is a macro, a struct, and a function\n+  --> $DIR/intra-links-ambiguity.rs:31:6\n+   |\n+LL | /// [`multi_conflict`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^ ambiguous link\n+help: to link to the macro, prefix with the item type\n+   |\n+LL | /// [`macro@multi_conflict`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the struct, prefix with the item type\n+   |\n+LL | /// [`struct@multi_conflict`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// [`multi_conflict()`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^^\n+\n+error: `type_and_value` is both a module and a constant\n+  --> $DIR/intra-links-ambiguity.rs:33:16\n+   |\n+LL | /// Ambiguous [type_and_value].\n+   |                ^^^^^^^^^^^^^^ ambiguous link\n+help: to link to the module, prefix with the item type\n+   |\n+LL | /// Ambiguous [module@type_and_value].\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the constant, prefix with the item type\n+   |\n+LL | /// Ambiguous [const@type_and_value].\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `foo::bar` is both an enum and a function\n+  --> $DIR/intra-links-ambiguity.rs:35:42\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`foo::bar`].\n+   |                                          ^^^^^^^^^^ ambiguous link\n+help: to link to the enum, prefix with the item type\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n+   |                                          ^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`foo::bar()`].\n+   |                                          ^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "c356ab3a8ac52d9de2b85e3c9c61d8a848deac86", "filename": "src/test/rustdoc/intra-links.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33442b133cef78e8f08271cd863051e0de997b69/src%2Ftest%2Frustdoc%2Fintra-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33442b133cef78e8f08271cd863051e0de997b69/src%2Ftest%2Frustdoc%2Fintra-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-links.rs?ref=33442b133cef78e8f08271cd863051e0de997b69", "patch": "@@ -22,6 +22,7 @@\n //! * [`ThisType::this_method`](ThisType::this_method)\n //! * [`ThisEnum`](ThisEnum)\n //! * [`ThisEnum::ThisVariant`](ThisEnum::ThisVariant)\n+//! * [`ThisEnum::ThisVariantCtor`](ThisEnum::ThisVariantCtor)\n //! * [`ThisTrait`](ThisTrait)\n //! * [`ThisTrait::this_associated_method`](ThisTrait::this_associated_method)\n //! * [`ThisTrait::ThisAssociatedType`](ThisTrait::ThisAssociatedType)\n@@ -50,7 +51,7 @@ pub struct ThisType;\n impl ThisType {\n     pub fn this_method() {}\n }\n-pub enum ThisEnum { ThisVariant, }\n+pub enum ThisEnum { ThisVariant, ThisVariantCtor(u32), }\n pub trait ThisTrait {\n     type ThisAssociatedType;\n     const THIS_ASSOCIATED_CONST: u8;"}]}