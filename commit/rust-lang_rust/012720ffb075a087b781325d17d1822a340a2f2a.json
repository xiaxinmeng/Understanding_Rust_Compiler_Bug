{"sha": "012720ffb075a087b781325d17d1822a340a2f2a", "node_id": "C_kwDOAAsO6NoAKDAxMjcyMGZmYjA3NWEwODdiNzgxMzI1ZDE3ZDE4MjJhMzQwYTJmMmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-12T07:02:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-12T07:02:05Z"}, "message": "Auto merge of #94733 - nnethercote:fix-AdtDef-interning, r=fee1-dead\n\nImprove `AdtDef` interning.\n\nThis commit makes `AdtDef` use `Interned`. Much of the commit is tedious\nchanges to introduce getter functions. The interesting changes are in\n`compiler/rustc_middle/src/ty/adt.rs`.\n\nr? `@fee1-dead`", "tree": {"sha": "b15255a31cb13666d304223eb7f2f4cf58ad2c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b15255a31cb13666d304223eb7f2f4cf58ad2c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012720ffb075a087b781325d17d1822a340a2f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012720ffb075a087b781325d17d1822a340a2f2a", "html_url": "https://github.com/rust-lang/rust/commit/012720ffb075a087b781325d17d1822a340a2f2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012720ffb075a087b781325d17d1822a340a2f2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "html_url": "https://github.com/rust-lang/rust/commit/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd"}, {"sha": "ca5525d5643f4eb7de5c5e69d0691fc8f1cacfca", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca5525d5643f4eb7de5c5e69d0691fc8f1cacfca", "html_url": "https://github.com/rust-lang/rust/commit/ca5525d5643f4eb7de5c5e69d0691fc8f1cacfca"}], "stats": {"total": 1389, "additions": 702, "deletions": 687}, "files": [{"sha": "ffea15bdc33ebd4593b8dd76e868c9862e615108", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -138,7 +138,7 @@ impl BorrowExplanation {\n                 let mut ty = local_decl.ty;\n                 if local_decl.source_info.span.desugaring_kind() == Some(DesugaringKind::ForLoop) {\n                     if let ty::Adt(adt, substs) = local_decl.ty.kind() {\n-                        if tcx.is_diagnostic_item(sym::Option, adt.did) {\n+                        if tcx.is_diagnostic_item(sym::Option, adt.did()) {\n                             // in for loop desugaring, only look at the `Some(..)` inner type\n                             ty = substs.type_at(0);\n                         }\n@@ -148,7 +148,7 @@ impl BorrowExplanation {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n                     ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => {\n-                        (\"`Drop` code\", format!(\"type `{}`\", tcx.def_path_str(adt.did)))\n+                        (\"`Drop` code\", format!(\"type `{}`\", tcx.def_path_str(adt.did())))\n                     }\n \n                     // Otherwise, just report the whole type (and use"}, {"sha": "c2b5c16517af56312d4a41aaf99992da200e8f18", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -370,7 +370,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ty::Adt(def, _) => {\n                     let variant = if let Some(idx) = variant_index {\n                         assert!(def.is_enum());\n-                        &def.variants[idx]\n+                        &def.variant(idx)\n                     } else {\n                         def.non_enum_variant()\n                     };\n@@ -701,7 +701,7 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefMutableRef => \"a mutable reference\".to_string(),\n             BorrowedContentSource::OverloadedDeref(ty) => ty\n                 .ty_adt_def()\n-                .and_then(|adt| match tcx.get_diagnostic_name(adt.did)? {\n+                .and_then(|adt| match tcx.get_diagnostic_name(adt.did())? {\n                     name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n                     _ => None,\n                 })\n@@ -731,7 +731,7 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n             }\n             BorrowedContentSource::OverloadedDeref(ty) => ty\n                 .ty_adt_def()\n-                .and_then(|adt| match tcx.get_diagnostic_name(adt.did)? {\n+                .and_then(|adt| match tcx.get_diagnostic_name(adt.did())? {\n                     name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n                     _ => None,\n                 })"}, {"sha": "48a70abc0b6046f5bec488f79f5134f7f52044c5", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         let ty = move_place.ty(self.body, self.infcx.tcx).ty;\n         let def_id = match *ty.kind() {\n-            ty::Adt(self_def, _) => self_def.did,\n+            ty::Adt(self_def, _) => self_def.did(),\n             ty::Foreign(def_id)\n             | ty::FnDef(def_id, _)\n             | ty::Closure(def_id, _)"}, {"sha": "1df7e826343bda8cb7313d9419aa8194b57eaab3", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -345,8 +345,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ty::Adt(adt, substs) => {\n                         let generic_arg = substs[param_index as usize];\n                         let identity_substs =\n-                            InternalSubsts::identity_for_item(self.infcx.tcx, adt.did);\n-                        let base_ty = self.infcx.tcx.mk_adt(adt, identity_substs);\n+                            InternalSubsts::identity_for_item(self.infcx.tcx, adt.did());\n+                        let base_ty = self.infcx.tcx.mk_adt(*adt, identity_substs);\n                         let base_generic_arg = identity_substs[param_index as usize];\n                         let adt_desc = adt.descr();\n \n@@ -410,7 +410,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 \"returns a closure that contains a reference to a captured variable, which then \\\n                  escapes the closure body\"\n             }\n-            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did) => {\n+            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) => {\n                 \"returns an `async` block that contains a reference to a captured variable, which then \\\n                  escapes the closure body\"\n             }"}, {"sha": "a7cf25d43d2301d67aa18f67d3fdab696d9e7514", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -736,13 +736,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             }\n             ProjectionElem::Downcast(maybe_name, index) => match base_ty.kind() {\n                 ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n-                    if index.as_usize() >= adt_def.variants.len() {\n+                    if index.as_usize() >= adt_def.variants().len() {\n                         PlaceTy::from_ty(span_mirbug_and_err!(\n                             self,\n                             place,\n                             \"cast to variant #{:?} but enum only has {:?}\",\n                             index,\n-                            adt_def.variants.len()\n+                            adt_def.variants().len()\n                         ))\n                     } else {\n                         PlaceTy { ty: base_ty, variant_index: Some(index) }\n@@ -816,7 +816,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let (variant, substs) = match base_ty {\n             PlaceTy { ty, variant_index: Some(variant_index) } => match *ty.kind() {\n-                ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                ty::Adt(adt_def, substs) => (adt_def.variant(variant_index), substs),\n                 ty::Generator(def_id, substs, _) => {\n                     let mut variants = substs.as_generator().state_tys(def_id, tcx);\n                     let Some(mut variant) = variants.nth(variant_index.into()) else {\n@@ -835,7 +835,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             },\n             PlaceTy { ty, variant_index: None } => match *ty.kind() {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() => {\n-                    (&adt_def.variants[VariantIdx::new(0)], substs)\n+                    (adt_def.variant(VariantIdx::new(0)), substs)\n                 }\n                 ty::Closure(_, substs) => {\n                     return match substs\n@@ -1449,7 +1449,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         );\n                     }\n                 };\n-                if variant_index.as_usize() >= adt.variants.len() {\n+                if variant_index.as_usize() >= adt.variants().len() {\n                     span_bug!(\n                         stmt.source_info.span,\n                         \"bad set discriminant ({:?} = {:?}): value of of range\",\n@@ -1928,7 +1928,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         match *ak {\n             AggregateKind::Adt(adt_did, variant_index, substs, _, active_field_index) => {\n                 let def = tcx.adt_def(adt_did);\n-                let variant = &def.variants[variant_index];\n+                let variant = &def.variant(variant_index);\n                 let adj_field_index = active_field_index.unwrap_or(field_index);\n                 if let Some(field) = variant.fields.get(adj_field_index) {\n                     Ok(self.normalize(field.ty(tcx, substs), location))"}, {"sha": "89fd0bfa8bbfa2f7fe4b99415d35a8b0efd94c28", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -67,7 +67,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n                 pointer_ty(tcx)\n             }\n         }\n-        ty::Adt(adt_def, _) if adt_def.repr.simd() => {\n+        ty::Adt(adt_def, _) if adt_def.repr().simd() => {\n             let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n             {\n                 Abi::Vector { element, count } => (element.clone(), *count),"}, {"sha": "fd63c3ecddbdfd9cdb2365ca0aec9bca6bc18d5e", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n+            for i in 0..def_a.variant(VariantIdx::new(0)).fields.len() {\n                 let src_f = src.value_field(fx, mir::Field::new(i));\n                 let dst_f = dst.place_field(fx, mir::Field::new(i));\n \n@@ -200,7 +200,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n \n             // Packed types ignore the alignment of their fields.\n             if let ty::Adt(def, _) = layout.ty.kind() {\n-                if def.repr.packed() {\n+                if def.repr().packed() {\n                     unsized_align = sized_align;\n                 }\n             }"}, {"sha": "afe8797a0300969ef7901b36142a2f9841a8b640", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -24,7 +24,7 @@ fn codegen_field<'tcx>(\n         }\n         match field_layout.ty.kind() {\n             ty::Slice(..) | ty::Str | ty::Foreign(..) => simple(fx),\n-            ty::Adt(def, _) if def.repr.packed() => {\n+            ty::Adt(def, _) if def.repr().packed() => {\n                 assert_eq!(layout.align.abi.bytes(), 1);\n                 simple(fx)\n             }\n@@ -816,7 +816,7 @@ pub(crate) fn assert_assignable<'tcx>(\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n         (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n-            if adt_def_a.did == adt_def_b.did =>\n+            if adt_def_a.did() == adt_def_b.did() =>\n         {\n             let mut types_a = substs_a.types();\n             let mut types_b = substs_b.types();"}, {"sha": "649ffc16249a68c13a03e73977299e0ea7633b1a", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -56,8 +56,8 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n             if let (&ty::Adt(def, _), &Variants::Single { index }) =\n                 (layout.ty.kind(), &layout.variants)\n             {\n-                if def.is_enum() && !def.variants.is_empty() {\n-                    write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n+                if def.is_enum() && !def.variants().is_empty() {\n+                    write!(&mut name, \"::{}\", def.variant(index).name).unwrap();\n                 }\n             }\n             if let (&ty::Generator(_, _, _), &Variants::Single { index }) ="}, {"sha": "f16a903ad2c5b9d00d147f231f8cac3ed12c3ff7", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -641,7 +641,7 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n             AdtKind::Struct => prepare_struct_metadata(cx, t, unique_type_id).finalize(cx),\n             AdtKind::Union => prepare_union_metadata(cx, t, unique_type_id).finalize(cx),\n             AdtKind::Enum => {\n-                prepare_enum_metadata(cx, t, def.did, unique_type_id, vec![]).finalize(cx)\n+                prepare_enum_metadata(cx, t, def.did(), unique_type_id, vec![]).finalize(cx)\n             }\n         },\n         ty::Tuple(tys) => {\n@@ -1209,7 +1209,7 @@ fn prepare_struct_metadata<'ll, 'tcx>(\n     let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n     let (struct_def_id, variant) = match struct_type.kind() {\n-        ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n+        ty::Adt(def, _) => (def.did(), def.non_enum_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\"),\n     };\n \n@@ -1386,7 +1386,7 @@ fn prepare_union_metadata<'ll, 'tcx>(\n     let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n     let (union_def_id, variant) = match union_type.kind() {\n-        ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n+        ty::Adt(def, _) => (def.did(), def.non_enum_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\"),\n     };\n \n@@ -1468,7 +1468,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n         };\n \n         let variant_info_for = |index: VariantIdx| match *self.enum_type.kind() {\n-            ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index], index),\n+            ty::Adt(adt, _) => VariantInfo::Adt(&adt.variant(index), index),\n             ty::Generator(def_id, _, _) => {\n                 let (generator_layout, generator_saved_local_names) =\n                     generator_variant_info_data.as_ref().unwrap();\n@@ -1492,7 +1492,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n         match self.layout.variants {\n             Variants::Single { index } => {\n                 if let ty::Adt(adt, _) = self.enum_type.kind() {\n-                    if adt.variants.is_empty() {\n+                    if adt.variants().is_empty() {\n                         return vec![];\n                     }\n                 }\n@@ -1942,7 +1942,7 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n \n     let discriminant_type_metadata = |discr: Primitive| {\n         let enumerators_metadata: Vec<_> = match enum_type.kind() {\n-            ty::Adt(def, _) => iter::zip(def.discriminants(tcx), &def.variants)\n+            ty::Adt(def, _) => iter::zip(def.discriminants(tcx), def.variants())\n                 .map(|((_, discr), v)| {\n                     let name = v.name.as_str();\n                     let is_unsigned = match discr.ty.kind() {\n@@ -2313,7 +2313,7 @@ fn set_members_of_composite_type<'ll, 'tcx>(\n fn compute_type_parameters<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIArray {\n     if let ty::Adt(def, substs) = *ty.kind() {\n         if substs.types().next().is_some() {\n-            let generics = cx.tcx.generics_of(def.did);\n+            let generics = cx.tcx.generics_of(def.did());\n             let names = get_parameter_names(cx, generics);\n             let template_params: Vec<_> = iter::zip(substs, names)\n                 .filter_map(|(kind, name)| {"}, {"sha": "34013b5f737c94cbc66d3c666eec608425e55cbb", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -524,7 +524,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             {\n                                 Some(type_metadata(cx, impl_self_ty))\n                             } else {\n-                                Some(namespace::item_namespace(cx, def.did))\n+                                Some(namespace::item_namespace(cx, def.did()))\n                             }\n                         }\n                         _ => None,"}, {"sha": "757aa9a10116702f60ead8aee71abe46c22abc0f", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -53,8 +53,8 @@ fn uncached_llvm_type<'a, 'tcx>(\n             if let (&ty::Adt(def, _), &Variants::Single { index }) =\n                 (layout.ty.kind(), &layout.variants)\n             {\n-                if def.is_enum() && !def.variants.is_empty() {\n-                    write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n+                if def.is_enum() && !def.variants().is_empty() {\n+                    write!(&mut name, \"::{}\", def.variant(index).name).unwrap();\n                 }\n             }\n             if let (&ty::Generator(_, _, _), &Variants::Single { index }) ="}, {"sha": "0b31e4b558261b52e4efb4a86297b92f0839b61a", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -255,7 +255,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n+            for i in 0..def_a.variant(VariantIdx::new(0)).fields.len() {\n                 let src_f = src.project_field(bx, i);\n                 let dst_f = dst.project_field(bx, i);\n "}, {"sha": "67df64e9b1baa6352bf1bd5d1e2f8428932dccd1", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -74,7 +74,7 @@ fn push_debuginfo_type_name<'tcx>(\n             if def.is_enum() && cpp_like_debuginfo {\n                 msvc_enum_fallback(tcx, t, def, substs, output, visited);\n             } else {\n-                push_item_name(tcx, def.did, qualified, output);\n+                push_item_name(tcx, def.did(), qualified, output);\n                 push_generic_params_internal(tcx, substs, output, visited);\n             }\n         }\n@@ -405,15 +405,15 @@ fn push_debuginfo_type_name<'tcx>(\n     fn msvc_enum_fallback<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n-        def: &AdtDef,\n+        def: AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n         output: &mut String,\n         visited: &mut FxHashSet<Ty<'tcx>>,\n     ) {\n-        let layout = tcx.layout_of(tcx.param_env(def.did).and(ty)).expect(\"layout error\");\n+        let layout = tcx.layout_of(tcx.param_env(def.did()).and(ty)).expect(\"layout error\");\n \n         output.push_str(\"enum$<\");\n-        push_item_name(tcx, def.did, true, output);\n+        push_item_name(tcx, def.did(), true, output);\n         push_generic_params_internal(tcx, substs, output, visited);\n \n         if let Variants::Multiple {\n@@ -435,14 +435,14 @@ fn push_debuginfo_type_name<'tcx>(\n             let max = dataful_discriminant_range.end;\n             let max = tag.value.size(&tcx).truncate(max);\n \n-            let dataful_variant_name = def.variants[*dataful_variant].name.as_str();\n+            let dataful_variant_name = def.variant(*dataful_variant).name.as_str();\n \n             output.push_str(&format!(\", {}, {}, {}\", min, max, dataful_variant_name));\n         } else if let Variants::Single { index: variant_idx } = &layout.variants {\n             // Uninhabited enums can't be constructed and should never need to be visualized so\n             // skip this step for them.\n-            if def.variants.len() != 0 {\n-                let variant = def.variants[*variant_idx].name.as_str();\n+            if def.variants().len() != 0 {\n+                let variant = def.variant(*variant_idx).name.as_str();\n \n                 output.push_str(&format!(\", {}\", variant));\n             }"}, {"sha": "694f5434e9afd029edf4624ff1da99989cac3e33", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -74,7 +74,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             // Packed types ignore the alignment of their fields.\n             if let ty::Adt(def, _) = t.kind() {\n-                if def.repr.packed() {\n+                if def.repr().packed() {\n                     unsized_align = sized_align;\n                 }\n             }"}, {"sha": "2b8fa3be56dd5c9f574fd9e5daeee8125f0c9afc", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             _ if !field.is_unsized() => return simple(),\n             ty::Slice(..) | ty::Str | ty::Foreign(..) => return simple(),\n             ty::Adt(def, _) => {\n-                if def.repr.packed() {\n+                if def.repr().packed() {\n                     // FIXME(eddyb) generalize the adjustment when we\n                     // start supporting packing to larger alignments.\n                     assert_eq!(self.layout.align.abi.bytes(), 1);"}, {"sha": "6fd7f707e7e5d4813805e892f394e16a33cc73be", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -105,13 +105,13 @@ fn const_to_valtree_inner<'tcx>(\n         ty::Array(_, len) => branches(usize::try_from(len.eval_usize(ecx.tcx.tcx, ecx.param_env)).unwrap(), None),\n \n         ty::Adt(def, _) => {\n-            if def.variants.is_empty() {\n+            if def.variants().is_empty() {\n                 bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n             }\n \n             let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n \n-            branches(def.variants[variant].fields.len(), def.is_enum().then_some(variant))\n+            branches(def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n         }\n \n         ty::Never\n@@ -150,11 +150,11 @@ pub(crate) fn try_destructure_const<'tcx>(\n         // Checks if we have any variants, to avoid downcasting to a non-existing variant (when\n         // there are no variants `read_discriminant` successfully returns a non-existing variant\n         // index).\n-        ty::Adt(def, _) if def.variants.is_empty() => throw_ub!(Unreachable),\n+        ty::Adt(def, _) if def.variants().is_empty() => throw_ub!(Unreachable),\n         ty::Adt(def, _) => {\n             let variant = ecx.read_discriminant(&op)?.1;\n             let down = ecx.operand_downcast(&op, variant)?;\n-            (def.variants[variant].fields.len(), Some(variant), down)\n+            (def.variant(variant).fields.len(), Some(variant), down)\n         }\n         ty::Tuple(substs) => (substs.len(), None, op),\n         _ => bug!(\"cannot destructure constant {:?}\", val),"}, {"sha": "9f507bface221766697db7bdf426e4a18099ecfa", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -174,7 +174,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         }\n \n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n-            if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+            if Some(def.did()) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations."}, {"sha": "5eff7d693c5a6dfe2bdc5c40aadca9f6159835f7", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -73,7 +73,9 @@ crate fn eval_nullary_intrinsic<'tcx>(\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n-            ty::Adt(ref adt, _) => ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx),\n+            ty::Adt(ref adt, _) => {\n+                ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n+            }\n             ty::Projection(_)\n             | ty::Opaque(_, _)\n             | ty::Param(_)"}, {"sha": "447797f915caf87759028a4f16f1adec031cd0c2", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1,3 +1,4 @@\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::definitions::DisambiguatedDefPathData;\n use rustc_middle::mir::interpret::{Allocation, ConstAllocation};\n@@ -56,7 +57,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             }\n \n             // Types with identity (print the module path).\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs)\n+            ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n             | ty::Opaque(def_id, substs)\n             | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })"}, {"sha": "2fae53bb9bdf5bc8c8db5966197c2f54e48974e6", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -759,7 +759,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 .ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n-                                .variants\n+                                .variants()\n                                 .len();\n                             assert!(usize::try_from(variant_index).unwrap() < variants_len);\n                             VariantIdx::from_u32(variant_index)"}, {"sha": "8fad5e63baf2671c51030fb80821865cd78ea4e9", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -267,7 +267,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 match layout.variants {\n                     Variants::Single { index } => {\n                         // Inside a variant\n-                        PathElem::Field(def.variants[index].fields[field].name)\n+                        PathElem::Field(def.variant(index).fields[field].name)\n                     }\n                     Variants::Multiple { .. } => bug!(\"we handled variants above\"),\n                 }\n@@ -734,7 +734,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         new_op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let name = match old_op.layout.ty.kind() {\n-            ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].name),\n+            ty::Adt(adt, _) => PathElem::Variant(adt.variant(variant_id).name),\n             // Generators also have variants\n             ty::Generator(..) => PathElem::GeneratorState(variant_id),\n             _ => bug!(\"Unexpected type with variant: {:?}\", old_op.layout.ty),\n@@ -771,7 +771,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Special check preventing `UnsafeCell` in the inner part of constants\n         if let Some(def) = op.layout.ty.ty_adt_def() {\n             if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. }))\n-                && Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type()\n+                && Some(def.did()) == self.ecx.tcx.lang_items().unsafe_cell_type()\n             {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n             }"}, {"sha": "4ea21b4d06d4bcd646864c1da9a3f58946c756fc", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -71,7 +71,7 @@ pub trait Qualif {\n     /// Returning `true` for `in_adt_inherently` but `false` for `in_any_value_of_ty` is unsound.\n     fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n-        adt: &'tcx AdtDef,\n+        adt: AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> bool;\n }\n@@ -96,12 +96,12 @@ impl Qualif for HasMutInterior {\n \n     fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n-        adt: &'tcx AdtDef,\n+        adt: AdtDef<'tcx>,\n         _: SubstsRef<'tcx>,\n     ) -> bool {\n         // Exactly one type, `UnsafeCell`, has the `HasMutInterior` qualif inherently.\n         // It arises structurally for all other types.\n-        Some(adt.did) == cx.tcx.lang_items().unsafe_cell_type()\n+        Some(adt.did()) == cx.tcx.lang_items().unsafe_cell_type()\n     }\n }\n \n@@ -126,7 +126,7 @@ impl Qualif for NeedsDrop {\n \n     fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n-        adt: &'tcx AdtDef,\n+        adt: AdtDef<'tcx>,\n         _: SubstsRef<'tcx>,\n     ) -> bool {\n         adt.has_dtor(cx.tcx)\n@@ -205,7 +205,7 @@ impl Qualif for NeedsNonConstDrop {\n \n     fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n-        adt: &'tcx AdtDef,\n+        adt: AdtDef<'tcx>,\n         _: SubstsRef<'tcx>,\n     ) -> bool {\n         adt.has_non_const_dtor(cx.tcx)\n@@ -233,7 +233,7 @@ impl Qualif for CustomEq {\n \n     fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n-        adt: &'tcx AdtDef,\n+        adt: AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> bool {\n         let ty = cx.tcx.mk_ty(ty::Adt(adt, substs));"}, {"sha": "fe4a726fe12a0df8481ff4f389685b2d65c83a76", "filename": "compiler/rustc_const_eval/src/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -55,7 +55,7 @@ where\n             ProjectionElem::Field(..) => {\n                 let ty = place_base.ty(local_decls, tcx).ty;\n                 match ty.kind() {\n-                    ty::Adt(def, _) => return def.repr.pack,\n+                    ty::Adt(def, _) => return def.repr().pack,\n                     _ => {}\n                 }\n             }"}, {"sha": "2165989b39808e551292f3800ac5318c6e63b539", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -132,7 +132,7 @@ pub fn call_kind<'tcx>(\n             .parent(method_did)\n             .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n             .and_then(|did| match tcx.type_of(did).kind() {\n-                ty::Adt(def, ..) => Some(def.did),\n+                ty::Adt(def, ..) => Some(def.did()),\n                 _ => None,\n             });\n         let is_option_or_result = parent_self_ty.map_or(false, |def_id| {"}, {"sha": "abc25d51776f396ff54c43b1626e44d8b57ff9de", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -582,7 +582,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) =\n                     (exp_found.expected.kind(), exp_found.found.kind())\n                 {\n-                    report_path_match(err, exp_adt.did, found_adt.did);\n+                    report_path_match(err, exp_adt.did(), found_adt.did());\n                 }\n             }\n             TypeError::Traits(ref exp_found) => {\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 return Some(());\n             }\n             if let ty::Adt(def, _) = ta.kind() {\n-                let path_ = self.tcx.def_path_str(def.did);\n+                let path_ = self.tcx.def_path_str(def.did());\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, other_ty);\n                     return Some(());\n@@ -1126,12 +1126,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // process starts here\n         match (t1.kind(), t2.kind()) {\n             (&ty::Adt(def1, sub1), &ty::Adt(def2, sub2)) => {\n-                let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n-                let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n+                let did1 = def1.did();\n+                let did2 = def2.did();\n+                let sub_no_defaults_1 = self.strip_generic_default_params(did1, sub1);\n+                let sub_no_defaults_2 = self.strip_generic_default_params(did2, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                let path1 = self.tcx.def_path_str(def1.did);\n-                let path2 = self.tcx.def_path_str(def2.did);\n-                if def1.did == def2.did {\n+                let path1 = self.tcx.def_path_str(did1);\n+                let path2 = self.tcx.def_path_str(did2);\n+                if did1 == did2 {\n                     // Easy case. Replace same types with `_` to shorten the output and highlight\n                     // the differing ones.\n                     //     let x: Foo<Bar, Qux> = y::<Foo<Quz, Qux>>();"}, {"sha": "a9a92fdbd6448c9cb7c92c3f1bbe8e026acb256c", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -958,7 +958,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n         let t = match t.kind() {\n             // We'll hide this type only if all its type params are hidden as well.\n             ty::Adt(def, substs) => {\n-                let generics = self.tcx().generics_of(def.did);\n+                let generics = self.tcx().generics_of(def.did());\n                 // Account for params with default values, like `Vec`, where we\n                 // want to show `Vec<T>`, not `Vec<T, _>`. If we replaced that\n                 // subst, then we'd get the incorrect output, so we passthrough.\n@@ -985,7 +985,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n                 };\n                 if self.level == 1 || substs.iter().any(should_keep) {\n                     let substs = self.tcx().intern_substs(&substs[..]);\n-                    self.tcx().mk_ty(ty::Adt(def, substs))\n+                    self.tcx().mk_ty(ty::Adt(*def, substs))\n                 } else {\n                     self.tcx().ty_error()\n                 }"}, {"sha": "53ad837434985719f9c8565fedbec1baddfa6993", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -658,7 +658,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n             let impl_ty = cx.tcx.type_of(parent);\n             let outerdef = match impl_ty.kind() {\n-                ty::Adt(def, _) => Some(def.did),\n+                ty::Adt(def, _) => Some(def.did()),\n                 ty::Foreign(def_id) => Some(*def_id),\n                 _ => None,\n             };\n@@ -841,7 +841,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             let mut impls = LocalDefIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                    if let Some(def_id) = ty_def.did.as_local() {\n+                    if let Some(def_id) = ty_def.did().as_local() {\n                         impls.insert(def_id);\n                     }\n                 }\n@@ -2535,9 +2535,9 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n \n         /// Test if this enum has several actually \"existing\" variants.\n         /// Zero-sized uninhabited variants do not always have a tag assigned and thus do not \"exist\".\n-        fn is_multi_variant(adt: &ty::AdtDef) -> bool {\n+        fn is_multi_variant<'tcx>(adt: ty::AdtDef<'tcx>) -> bool {\n             // As an approximation, we only count dataless variants. Those are definitely inhabited.\n-            let existing_variants = adt.variants.iter().filter(|v| v.fields.is_empty()).count();\n+            let existing_variants = adt.variants().iter().filter(|v| v.fields.is_empty()).count();\n             existing_variants > 1\n         }\n \n@@ -2571,7 +2571,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n-                    match tcx.layout_scalar_valid_range(adt_def.did) {\n+                    match tcx.layout_scalar_valid_range(adt_def.did()) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n@@ -2592,12 +2592,12 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         _ => {}\n                     }\n                     // Now, recurse.\n-                    match adt_def.variants.len() {\n+                    match adt_def.variants().len() {\n                         0 => Some((\"enums with no variants have no valid value\".to_string(), None)),\n                         1 => {\n                             // Struct, or enum with exactly one variant.\n                             // Proceed recursively, check all fields.\n-                            let variant = &adt_def.variants[VariantIdx::from_u32(0)];\n+                            let variant = &adt_def.variant(VariantIdx::from_u32(0));\n                             variant.fields.iter().find_map(|field| {\n                                 ty_find_init_error(tcx, field.ty(tcx, substs), init).map(\n                                     |(mut msg, span)| {\n@@ -2622,8 +2622,8 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         }\n                         // Multi-variant enum.\n                         _ => {\n-                            if init == InitKind::Uninit && is_multi_variant(adt_def) {\n-                                let span = tcx.def_span(adt_def.did);\n+                            if init == InitKind::Uninit && is_multi_variant(*adt_def) {\n+                                let span = tcx.def_span(adt_def.did());\n                                 Some((\n                                     \"enums have to be initialized to a variant\".to_string(),\n                                     Some(span),\n@@ -2819,15 +2819,15 @@ impl ClashingExternDeclarations {\n                 let mut ty = ty;\n                 loop {\n                     if let ty::Adt(def, substs) = *ty.kind() {\n-                        let is_transparent = def.subst(tcx, substs).repr.transparent();\n-                        let is_non_null = crate::types::nonnull_optimization_guaranteed(tcx, &def);\n+                        let is_transparent = def.subst(tcx, substs).repr().transparent();\n+                        let is_non_null = crate::types::nonnull_optimization_guaranteed(tcx, def);\n                         debug!(\n                             \"non_transparent_ty({:?}) -- type is transparent? {}, type is non-null? {}\",\n                             ty, is_transparent, is_non_null\n                         );\n                         if is_transparent && !is_non_null {\n-                            debug_assert!(def.variants.len() == 1);\n-                            let v = &def.variants[VariantIdx::new(0)];\n+                            debug_assert!(def.variants().len() == 1);\n+                            let v = &def.variant(VariantIdx::new(0));\n                             ty = transparent_newtype_field(tcx, v)\n                                 .expect(\n                                     \"single-variant transparent structure with zero-sized field\",\n@@ -2892,8 +2892,8 @@ impl ClashingExternDeclarations {\n                             }\n \n                             // Grab a flattened representation of all fields.\n-                            let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n-                            let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                            let a_fields = a_def.variants().iter().flat_map(|v| v.fields.iter());\n+                            let b_fields = b_def.variants().iter().flat_map(|v| v.fields.iter());\n \n                             // Perform a structural comparison for each field.\n                             a_fields.eq_by("}, {"sha": "d3c019ad70e3cf598f319ebb52c464134cde2b2b", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1050,7 +1050,7 @@ impl<'tcx> LateContext<'tcx> {\n             ) -> Result<Self::Path, Self::Error> {\n                 if trait_ref.is_none() {\n                     if let ty::Adt(def, substs) = self_ty.kind() {\n-                        return self.print_def_path(def.did, substs);\n+                        return self.print_def_path(def.did(), substs);\n                     }\n                 }\n "}, {"sha": "27d44da6dfc389d6d211cc797e143f638c0eadfe", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -202,7 +202,7 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n             Res::SelfTy { trait_: None, alias_to: Some((did, _)) } => {\n                 if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n                     if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n-                        cx.tcx.get_diagnostic_name(adt.did)\n+                        cx.tcx.get_diagnostic_name(adt.did())\n                     {\n                         // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n                         // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`"}, {"sha": "b6a45676a309373b8ff56ffd7d4800e01d42cbb4", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -84,9 +84,9 @@ fn lint_cstring_as_ptr(\n ) {\n     let source_type = cx.typeck_results().expr_ty(source);\n     if let ty::Adt(def, substs) = source_type.kind() {\n-        if cx.tcx.is_diagnostic_item(sym::Result, def.did) {\n+        if cx.tcx.is_diagnostic_item(sym::Result, def.did()) {\n             if let ty::Adt(adt, _) = substs.type_at(0).kind() {\n-                if cx.tcx.is_diagnostic_item(sym::cstring_type, adt.did) {\n+                if cx.tcx.is_diagnostic_item(sym::cstring_type, adt.did()) {\n                     cx.struct_span_lint(TEMPORARY_CSTRING_AS_PTR, as_ptr_span, |diag| {\n                         let mut diag = diag\n                             .build(\"getting the inner pointer of a temporary `CString`\");"}, {"sha": "f21f25c35847eb0b6dc0209271ac5c5f27aa0c20", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -149,7 +149,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 ty::Ref(_, r, _) if *r.kind() == ty::Str,\n             ) || matches!(\n                 ty.ty_adt_def(),\n-                Some(ty_def) if cx.tcx.is_diagnostic_item(sym::String, ty_def.did),\n+                Some(ty_def) if cx.tcx.is_diagnostic_item(sym::String, ty_def.did()),\n             );\n \n             let (suggest_display, suggest_debug) = cx.tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "2c8b41d7214031459287c74e181eb42fcf310168", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -57,8 +57,8 @@ fn path_for_pass_by_value(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> Option<Stri\n             }\n             Res::SelfTy { trait_: None, alias_to: Some((did, _)) } => {\n                 if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n-                    if cx.tcx.has_attr(adt.did, sym::rustc_pass_by_value) {\n-                        return Some(cx.tcx.def_path_str_with_substs(adt.did, substs));\n+                    if cx.tcx.has_attr(adt.did(), sym::rustc_pass_by_value) {\n+                        return Some(cx.tcx.def_path_str_with_substs(adt.did(), substs));\n                     }\n                 }\n             }"}, {"sha": "ed5578c754dd55c942e96f4e2db5bbc2dcef358b", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -667,8 +667,8 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: &ty::AdtDef) -> bool {\n-    tcx.get_attrs(def.did).iter().any(|a| a.has_name(sym::rustc_nonnull_optimization_guaranteed))\n+crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+    tcx.get_attrs(def.did()).iter().any(|a| a.has_name(sym::rustc_nonnull_optimization_guaranteed))\n }\n \n /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n@@ -692,20 +692,20 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n         ty::Adt(def, _) if def.is_box() && matches!(mode, CItemKind::Definition) => true,\n-        ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n-            let marked_non_null = nonnull_optimization_guaranteed(tcx, &def);\n+        ty::Adt(def, substs) if def.repr().transparent() && !def.is_union() => {\n+            let marked_non_null = nonnull_optimization_guaranteed(tcx, *def);\n \n             if marked_non_null {\n                 return true;\n             }\n \n             // Types with a `#[repr(no_niche)]` attribute have their niche hidden.\n             // The attribute is used by the UnsafeCell for example (the only use so far).\n-            if def.repr.hide_niche() {\n+            if def.repr().hide_niche() {\n                 return false;\n             }\n \n-            def.variants\n+            def.variants()\n                 .iter()\n                 .filter_map(|variant| transparent_newtype_field(cx.tcx, variant))\n                 .any(|field| ty_is_known_nonnull(cx, field.ty(tcx, substs), mode))\n@@ -721,8 +721,10 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n     Some(match *ty.kind() {\n         ty::Adt(field_def, field_substs) => {\n             let inner_field_ty = {\n-                let first_non_zst_ty =\n-                    field_def.variants.iter().filter_map(|v| transparent_newtype_field(cx.tcx, v));\n+                let first_non_zst_ty = field_def\n+                    .variants()\n+                    .iter()\n+                    .filter_map(|v| transparent_newtype_field(cx.tcx, v));\n                 debug_assert_eq!(\n                     first_non_zst_ty.clone().count(),\n                     1,\n@@ -771,7 +773,7 @@ crate fn repr_nullable_ptr<'tcx>(\n ) -> Option<Ty<'tcx>> {\n     debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n     if let ty::Adt(ty_def, substs) = ty.kind() {\n-        let field_ty = match &ty_def.variants.raw[..] {\n+        let field_ty = match &ty_def.variants().raw[..] {\n             [var_one, var_two] => match (&var_one.fields[..], &var_two.fields[..]) {\n                 ([], [field]) | ([field], []) => field.ty(cx.tcx, substs),\n                 _ => return None,\n@@ -845,13 +847,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         &self,\n         cache: &mut FxHashSet<Ty<'tcx>>,\n         ty: Ty<'tcx>,\n-        def: &ty::AdtDef,\n+        def: ty::AdtDef<'tcx>,\n         variant: &ty::VariantDef,\n         substs: SubstsRef<'tcx>,\n     ) -> FfiResult<'tcx> {\n         use FfiResult::*;\n \n-        if def.repr.transparent() {\n+        if def.repr().transparent() {\n             // Can assume that at most one field is not a ZST, so only check\n             // that field's type for FFI-safety.\n             if let Some(field) = transparent_newtype_field(self.cx.tcx, variant) {\n@@ -925,7 +927,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     AdtKind::Struct | AdtKind::Union => {\n                         let kind = if def.is_struct() { \"struct\" } else { \"union\" };\n \n-                        if !def.repr.c() && !def.repr.transparent() {\n+                        if !def.repr().c() && !def.repr().transparent() {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: format!(\"this {} has unspecified layout\", kind),\n@@ -939,7 +941,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         let is_non_exhaustive =\n                             def.non_enum_variant().is_field_list_non_exhaustive();\n-                        if is_non_exhaustive && !def.did.is_local() {\n+                        if is_non_exhaustive && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: format!(\"this {} is non-exhaustive\", kind),\n@@ -958,14 +960,15 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         self.check_variant_for_ffi(cache, ty, def, def.non_enum_variant(), substs)\n                     }\n                     AdtKind::Enum => {\n-                        if def.variants.is_empty() {\n+                        if def.variants().is_empty() {\n                             // Empty enums are okay... although sort of useless.\n                             return FfiSafe;\n                         }\n \n                         // Check for a repr() attribute to specify the size of the\n                         // discriminant.\n-                        if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n+                        if !def.repr().c() && !def.repr().transparent() && def.repr().int.is_none()\n+                        {\n                             // Special-case types like `Option<extern fn()>`.\n                             if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n@@ -981,7 +984,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             }\n                         }\n \n-                        if def.is_variant_list_non_exhaustive() && !def.did.is_local() {\n+                        if def.is_variant_list_non_exhaustive() && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: \"this enum is non-exhaustive\".into(),\n@@ -990,7 +993,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         }\n \n                         // Check the contained variants.\n-                        for variant in &def.variants {\n+                        for variant in def.variants() {\n                             let is_non_exhaustive = variant.is_field_list_non_exhaustive();\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n@@ -1161,7 +1164,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n             diag.note(note);\n             if let ty::Adt(def, _) = ty.kind() {\n-                if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n+                if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n                     diag.span_note(sp, \"the type is defined here\");\n                 }\n             }\n@@ -1464,9 +1467,9 @@ impl InvalidAtomicOrdering {\n             && let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def()\n             // skip extension traits, only lint functions from the standard library\n             && cx.tcx.trait_id_of_impl(impl_did).is_none()\n-            && let Some(parent) = cx.tcx.parent(adt.did)\n+            && let Some(parent) = cx.tcx.parent(adt.did())\n             && cx.tcx.is_diagnostic_item(sym::atomic_mod, parent)\n-            && ATOMIC_TYPES.contains(&cx.tcx.item_name(adt.did))\n+            && ATOMIC_TYPES.contains(&cx.tcx.item_name(adt.did()))\n         {\n             return Some((method_path.ident.name, args));\n         }"}, {"sha": "abe34a8a39f1470699f3dcd23cc6625b59b5b9db", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     let descr_pre = &format!(\"{}boxed \", descr_pre);\n                     check_must_use_ty(cx, boxed_ty, expr, span, descr_pre, descr_post, plural_len)\n                 }\n-                ty::Adt(def, _) => check_must_use_def(cx, def.did, span, descr_pre, descr_post),\n+                ty::Adt(def, _) => check_must_use_def(cx, def.did(), span, descr_pre, descr_post),\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for &(predicate, _) in cx.tcx.explicit_item_bounds(def) {"}, {"sha": "2e6ce7b7040f9dbc4e3ab86a008d38ea1dddfb43", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -979,7 +979,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::AdtDef<'tcx> {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n "}, {"sha": "924e5f921039e18b1139305fe2ecd17fb8882ae6", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1029,9 +1029,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n     }\n \n-    fn encode_enum_variant_info(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n+    fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n         let tcx = self.tcx;\n-        let variant = &def.variants[index];\n+        let variant = &def.variant(index);\n         let def_id = variant.def_id;\n         debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n \n@@ -1057,9 +1057,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_enum_variant_ctor(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n+    fn encode_enum_variant_ctor(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n         let tcx = self.tcx;\n-        let variant = &def.variants[index];\n+        let variant = &def.variant(index);\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n@@ -1122,11 +1122,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_field(\n         &mut self,\n-        adt_def: &ty::AdtDef,\n+        adt_def: ty::AdtDef<'tcx>,\n         variant_index: VariantIdx,\n         field_index: usize,\n     ) {\n-        let variant = &adt_def.variants[variant_index];\n+        let variant = &adt_def.variant(variant_index);\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n@@ -1137,7 +1137,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_item_type(def_id);\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def: &ty::AdtDef, def_id: DefId) {\n+    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let variant = adt_def.non_enum_variant();\n@@ -1149,7 +1149,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n+        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr()));\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1414,7 +1414,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.encode_explicit_item_bounds(def_id);\n                 EntryKind::OpaqueTy\n             }\n-            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr),\n+            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr()),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let variant = adt_def.non_enum_variant();\n@@ -1433,7 +1433,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         ctor,\n                         is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                     }),\n-                    adt_def.repr,\n+                    adt_def.repr(),\n                 )\n             }\n             hir::ItemKind::Union(..) => {\n@@ -1447,7 +1447,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         ctor: None,\n                         is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                     }),\n-                    adt_def.repr,\n+                    adt_def.repr(),\n                 )\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n@@ -1500,7 +1500,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n             hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n-                self.tcx.adt_def(def_id).variants.iter().map(|v| {\n+                self.tcx.adt_def(def_id).variants().iter().map(|v| {\n                     assert!(v.def_id.is_local());\n                     v.def_id.index\n                 })\n@@ -1926,8 +1926,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_fields(&mut self, adt_def: &ty::AdtDef) {\n-        for (variant_index, variant) in adt_def.variants.iter_enumerated() {\n+    fn encode_fields(&mut self, adt_def: ty::AdtDef<'tcx>) {\n+        for (variant_index, variant) in adt_def.variants().iter_enumerated() {\n             for (field_index, _field) in variant.fields.iter().enumerate() {\n                 self.encode_field(adt_def, variant_index, field_index);\n             }\n@@ -1991,7 +1991,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n \n-                for (i, variant) in def.variants.iter_enumerated() {\n+                for (i, variant) in def.variants().iter_enumerated() {\n                     self.encode_enum_variant_info(def, i);\n \n                     if let Some(_ctor_def_id) = variant.ctor_def_id {"}, {"sha": "f6d8fc5b81f65fe182a0699e84b1a2928d4b4a43", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -9,7 +9,7 @@ macro_rules! arena_types {\n             [] layout: rustc_target::abi::LayoutS<'tcx>,\n             [] fn_abi: rustc_target::abi::call::FnAbi<'tcx, rustc_middle::ty::Ty<'tcx>>,\n             // AdtDef are interned and compared by address\n-            [decode] adt_def: rustc_middle::ty::AdtDef,\n+            [decode] adt_def: rustc_middle::ty::AdtDefData,\n             [] steal_thir: rustc_data_structures::steal::Steal<rustc_middle::thir::Thir<'tcx>>,\n             [] steal_mir: rustc_data_structures::steal::Steal<rustc_middle::mir::Body<'tcx>>,\n             [decode] mir: rustc_middle::mir::Body<'tcx>,"}, {"sha": "a5468b3f4f2020d85c92d3e8d46c87d82746338b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -2455,7 +2455,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Adt(adt_did, variant, substs, _user_ty, _) => {\n                         ty::tls::with(|tcx| {\n-                            let variant_def = &tcx.adt_def(adt_did).variants[variant];\n+                            let variant_def = &tcx.adt_def(adt_did).variant(variant);\n                             let substs = tcx.lift(substs).expect(\"could not lift for printing\");\n                             let name = FmtPrinter::new(tcx, Namespace::ValueNS)\n                                 .print_def_path(variant_def.def_id, substs)?\n@@ -2783,7 +2783,7 @@ impl<'tcx> UserTypeProjections {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.leaf(field))\n     }\n \n-    pub fn variant(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx, field: Field) -> Self {\n+    pub fn variant(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx, field: Field) -> Self {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n     }\n }\n@@ -2834,12 +2834,12 @@ impl UserTypeProjection {\n \n     pub(crate) fn variant(\n         mut self,\n-        adt_def: &AdtDef,\n+        adt_def: AdtDef<'_>,\n         variant_index: VariantIdx,\n         field: Field,\n     ) -> Self {\n         self.projs.push(ProjectionElem::Downcast(\n-            Some(adt_def.variants[variant_index].name),\n+            Some(adt_def.variant(variant_index).name),\n             variant_index,\n         ));\n         self.projs.push(ProjectionElem::Field(field, ()));"}, {"sha": "51d8113840a930559accae6e1ac7884c08b2e909", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                     None => adt_def.non_enum_variant(),\n                     Some(variant_index) => {\n                         assert!(adt_def.is_enum());\n-                        &adt_def.variants[variant_index]\n+                        &adt_def.variant(variant_index)\n                     }\n                 };\n                 let field_def = &variant_def.fields[f.index()];"}, {"sha": "2acfede87aed01877b4885fc100585f4adc8bfd5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -523,7 +523,7 @@ rustc_queries! {\n         storage(ArenaCacheSelector<'tcx>)\n         separate_provide_extern\n     }\n-    query adt_def(key: DefId) -> &'tcx ty::AdtDef {\n+    query adt_def(key: DefId) -> ty::AdtDef<'tcx> {\n         desc { |tcx| \"computing ADT definition for `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern"}, {"sha": "785d3ee770985ff837c86ce13e9fb86b1e4dca84", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -128,7 +128,7 @@ pub struct Block {\n #[derive(Debug, HashStable)]\n pub struct Adt<'tcx> {\n     /// The ADT we're constructing.\n-    pub adt_def: &'tcx AdtDef,\n+    pub adt_def: AdtDef<'tcx>,\n     /// The variant of the ADT.\n     pub variant_index: VariantIdx,\n     pub substs: SubstsRef<'tcx>,\n@@ -617,7 +617,7 @@ pub enum PatKind<'tcx> {\n     /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n     /// multiple variants.\n     Variant {\n-        adt_def: &'tcx AdtDef,\n+        adt_def: AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n         variant_index: VariantIdx,\n         subpatterns: Vec<FieldPat<'tcx>>,\n@@ -714,7 +714,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n             PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n                 let variant = match *self.kind {\n                     PatKind::Variant { adt_def, variant_index, .. } => {\n-                        Some(&adt_def.variants[variant_index])\n+                        Some(adt_def.variant(variant_index))\n                     }\n                     _ => self.ty.ty_adt_def().and_then(|adt| {\n                         if !adt.is_enum() { Some(adt.non_enum_variant()) } else { None }"}, {"sha": "015bdb5783f36ef657d13af3cbc7ae46d70c8306", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -75,7 +75,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type InternedVariances = Vec<chalk_ir::Variance>;\n     type InternedConstraints = Vec<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>>;\n     type DefId = DefId;\n-    type InternedAdtId = &'tcx AdtDef;\n+    type InternedAdtId = AdtDef<'tcx>;\n     type Identifier = ();\n     type FnAbi = Abi;\n "}, {"sha": "cad77f6436ea26fe463beb7a34533ab043831b64", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 102, "deletions": 73, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -4,6 +4,7 @@ use crate::ty::util::{Discr, IntTypeExt};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n@@ -89,62 +90,62 @@ bitflags! {\n /// where `x` here represents the `DefId` of `S.x`. Then, the `DefId`\n /// can be used with [`TyCtxt::type_of()`] to get the type of the field.\n #[derive(TyEncodable, TyDecodable)]\n-pub struct AdtDef {\n+pub struct AdtDefData {\n     /// The `DefId` of the struct, enum or union item.\n     pub did: DefId,\n     /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n-    pub variants: IndexVec<VariantIdx, VariantDef>,\n+    variants: IndexVec<VariantIdx, VariantDef>,\n     /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n     flags: AdtFlags,\n     /// Repr options provided by the user.\n-    pub repr: ReprOptions,\n+    repr: ReprOptions,\n }\n \n-impl PartialOrd for AdtDef {\n-    fn partial_cmp(&self, other: &AdtDef) -> Option<Ordering> {\n+impl PartialOrd for AdtDefData {\n+    fn partial_cmp(&self, other: &AdtDefData) -> Option<Ordering> {\n         Some(self.cmp(&other))\n     }\n }\n \n /// There should be only one AdtDef for each `did`, therefore\n /// it is fine to implement `Ord` only based on `did`.\n-impl Ord for AdtDef {\n-    fn cmp(&self, other: &AdtDef) -> Ordering {\n+impl Ord for AdtDefData {\n+    fn cmp(&self, other: &AdtDefData) -> Ordering {\n         self.did.cmp(&other.did)\n     }\n }\n \n /// There should be only one AdtDef for each `did`, therefore\n /// it is fine to implement `PartialEq` only based on `did`.\n-impl PartialEq for AdtDef {\n+impl PartialEq for AdtDefData {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.did == other.did\n     }\n }\n \n-impl Eq for AdtDef {}\n+impl Eq for AdtDefData {}\n \n /// There should be only one AdtDef for each `did`, therefore\n /// it is fine to implement `Hash` only based on `did`.\n-impl Hash for AdtDef {\n+impl Hash for AdtDefData {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         self.did.hash(s)\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n+impl<'a> HashStable<StableHashingContext<'a>> for AdtDefData {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<(usize, HashingControls), Fingerprint>> = Default::default();\n         }\n \n         let hash: Fingerprint = CACHE.with(|cache| {\n-            let addr = self as *const AdtDef as usize;\n+            let addr = self as *const AdtDefData as usize;\n             let hashing_controls = hcx.hashing_controls();\n             *cache.borrow_mut().entry((addr, hashing_controls)).or_insert_with(|| {\n-                let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n+                let ty::AdtDefData { did, ref variants, ref flags, ref repr } = *self;\n \n                 let mut hasher = StableHasher::new();\n                 did.hash_stable(hcx, &mut hasher);\n@@ -160,6 +161,32 @@ impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct AdtDef<'tcx>(pub Interned<'tcx, AdtDefData>);\n+\n+impl<'tcx> AdtDef<'tcx> {\n+    pub fn did(self) -> DefId {\n+        self.0.0.did\n+    }\n+\n+    pub fn variants(self) -> &'tcx IndexVec<VariantIdx, VariantDef> {\n+        &self.0.0.variants\n+    }\n+\n+    pub fn variant(self, idx: VariantIdx) -> &'tcx VariantDef {\n+        &self.0.0.variants[idx]\n+    }\n+\n+    pub fn flags(self) -> AdtFlags {\n+        self.0.0.flags\n+    }\n+\n+    pub fn repr(self) -> ReprOptions {\n+        self.0.0.repr\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n pub enum AdtKind {\n     Struct,\n@@ -177,8 +204,8 @@ impl Into<DataTypeKind> for AdtKind {\n     }\n }\n \n-impl<'tcx> AdtDef {\n-    /// Creates a new `AdtDef`.\n+impl AdtDefData {\n+    /// Creates a new `AdtDefData`.\n     pub(super) fn new(\n         tcx: TyCtxt<'_>,\n         did: DefId,\n@@ -218,36 +245,38 @@ impl<'tcx> AdtDef {\n             flags |= AdtFlags::IS_MANUALLY_DROP;\n         }\n \n-        AdtDef { did, variants, flags, repr }\n+        AdtDefData { did, variants, flags, repr }\n     }\n+}\n \n+impl<'tcx> AdtDef<'tcx> {\n     /// Returns `true` if this is a struct.\n     #[inline]\n-    pub fn is_struct(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_STRUCT)\n+    pub fn is_struct(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_STRUCT)\n     }\n \n     /// Returns `true` if this is a union.\n     #[inline]\n-    pub fn is_union(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_UNION)\n+    pub fn is_union(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_UNION)\n     }\n \n     /// Returns `true` if this is an enum.\n     #[inline]\n-    pub fn is_enum(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_ENUM)\n+    pub fn is_enum(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_ENUM)\n     }\n \n     /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n     #[inline]\n-    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n+    pub fn is_variant_list_non_exhaustive(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n     }\n \n     /// Returns the kind of the ADT.\n     #[inline]\n-    pub fn adt_kind(&self) -> AdtKind {\n+    pub fn adt_kind(self) -> AdtKind {\n         if self.is_enum() {\n             AdtKind::Enum\n         } else if self.is_union() {\n@@ -258,7 +287,7 @@ impl<'tcx> AdtDef {\n     }\n \n     /// Returns a description of this abstract data type.\n-    pub fn descr(&self) -> &'static str {\n+    pub fn descr(self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\",\n             AdtKind::Union => \"union\",\n@@ -268,7 +297,7 @@ impl<'tcx> AdtDef {\n \n     /// Returns a description of a variant of this abstract data type.\n     #[inline]\n-    pub fn variant_descr(&self) -> &'static str {\n+    pub fn variant_descr(self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\",\n             AdtKind::Union => \"union\",\n@@ -278,65 +307,65 @@ impl<'tcx> AdtDef {\n \n     /// If this function returns `true`, it implies that `is_struct` must return `true`.\n     #[inline]\n-    pub fn has_ctor(&self) -> bool {\n-        self.flags.contains(AdtFlags::HAS_CTOR)\n+    pub fn has_ctor(self) -> bool {\n+        self.flags().contains(AdtFlags::HAS_CTOR)\n     }\n \n     /// Returns `true` if this type is `#[fundamental]` for the purposes\n     /// of coherence checking.\n     #[inline]\n-    pub fn is_fundamental(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n+    pub fn is_fundamental(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n     /// Returns `true` if this is `PhantomData<T>`.\n     #[inline]\n-    pub fn is_phantom_data(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n+    pub fn is_phantom_data(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n     /// Returns `true` if this is Box<T>.\n     #[inline]\n-    pub fn is_box(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_BOX)\n+    pub fn is_box(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_BOX)\n     }\n \n     /// Returns `true` if this is `ManuallyDrop<T>`.\n     #[inline]\n-    pub fn is_manually_drop(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n+    pub fn is_manually_drop(self) -> bool {\n+        self.flags().contains(AdtFlags::IS_MANUALLY_DROP)\n     }\n \n     /// Returns `true` if this type has a destructor.\n-    pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n+    pub fn has_dtor(self, tcx: TyCtxt<'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n     }\n \n-    pub fn has_non_const_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n+    pub fn has_non_const_dtor(self, tcx: TyCtxt<'tcx>) -> bool {\n         matches!(self.destructor(tcx), Some(Destructor { constness: hir::Constness::NotConst, .. }))\n     }\n \n     /// Asserts this is a struct or union and returns its unique variant.\n-    pub fn non_enum_variant(&self) -> &VariantDef {\n+    pub fn non_enum_variant(self) -> &'tcx VariantDef {\n         assert!(self.is_struct() || self.is_union());\n-        &self.variants[VariantIdx::new(0)]\n+        &self.variant(VariantIdx::new(0))\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n-        tcx.predicates_of(self.did)\n+    pub fn predicates(self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n+        tcx.predicates_of(self.did())\n     }\n \n     /// Returns an iterator over all fields contained\n     /// by this ADT.\n     #[inline]\n-    pub fn all_fields(&self) -> impl Iterator<Item = &FieldDef> + Clone {\n-        self.variants.iter().flat_map(|v| v.fields.iter())\n+    pub fn all_fields(self) -> impl Iterator<Item = &'tcx FieldDef> + Clone {\n+        self.variants().iter().flat_map(|v| v.fields.iter())\n     }\n \n     /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n     /// e.g., `enum Void {}` is considered payload free as well.\n-    pub fn is_payloadfree(&self) -> bool {\n+    pub fn is_payloadfree(self) -> bool {\n         // Treat the ADT as not payload-free if arbitrary_enum_discriminant is used (#88621).\n         // This would disallow the following kind of enum from being casted into integer.\n         // ```\n@@ -347,47 +376,47 @@ impl<'tcx> AdtDef {\n         // }\n         // ```\n         if self\n-            .variants\n+            .variants()\n             .iter()\n             .any(|v| matches!(v.discr, VariantDiscr::Explicit(_)) && v.ctor_kind != CtorKind::Const)\n         {\n             return false;\n         }\n-        self.variants.iter().all(|v| v.fields.is_empty())\n+        self.variants().iter().all(|v| v.fields.is_empty())\n     }\n \n     /// Return a `VariantDef` given a variant id.\n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n-        self.variants.iter().find(|v| v.def_id == vid).expect(\"variant_with_id: unknown variant\")\n+    pub fn variant_with_id(self, vid: DefId) -> &'tcx VariantDef {\n+        self.variants().iter().find(|v| v.def_id == vid).expect(\"variant_with_id: unknown variant\")\n     }\n \n     /// Return a `VariantDef` given a constructor id.\n-    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n-        self.variants\n+    pub fn variant_with_ctor_id(self, cid: DefId) -> &'tcx VariantDef {\n+        self.variants()\n             .iter()\n             .find(|v| v.ctor_def_id == Some(cid))\n             .expect(\"variant_with_ctor_id: unknown variant\")\n     }\n \n     /// Return the index of `VariantDef` given a variant id.\n-    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n-        self.variants\n+    pub fn variant_index_with_id(self, vid: DefId) -> VariantIdx {\n+        self.variants()\n             .iter_enumerated()\n             .find(|(_, v)| v.def_id == vid)\n             .expect(\"variant_index_with_id: unknown variant\")\n             .0\n     }\n \n     /// Return the index of `VariantDef` given a constructor id.\n-    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n-        self.variants\n+    pub fn variant_index_with_ctor_id(self, cid: DefId) -> VariantIdx {\n+        self.variants()\n             .iter_enumerated()\n             .find(|(_, v)| v.ctor_def_id == Some(cid))\n             .expect(\"variant_index_with_ctor_id: unknown variant\")\n             .0\n     }\n \n-    pub fn variant_of_res(&self, res: Res) -> &VariantDef {\n+    pub fn variant_of_res(self, res: Res) -> &'tcx VariantDef {\n         match res {\n             Res::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n             Res::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n@@ -402,10 +431,10 @@ impl<'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n+    pub fn eval_explicit_discr(self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n         assert!(self.is_enum());\n         let param_env = tcx.param_env(expr_did);\n-        let repr_type = self.repr.discr_type();\n+        let repr_type = self.repr().discr_type();\n         match tcx.const_eval_poly(expr_did) {\n             Ok(val) => {\n                 let ty = repr_type.to_ty(tcx);\n@@ -437,14 +466,14 @@ impl<'tcx> AdtDef {\n \n     #[inline]\n     pub fn discriminants(\n-        &'tcx self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n         assert!(self.is_enum());\n-        let repr_type = self.repr.discr_type();\n+        let repr_type = self.repr().discr_type();\n         let initial = repr_type.initial_discriminant(tcx);\n         let mut prev_discr = None::<Discr<'tcx>>;\n-        self.variants.iter_enumerated().map(move |(i, v)| {\n+        self.variants().iter_enumerated().map(move |(i, v)| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n@@ -458,8 +487,8 @@ impl<'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn variant_range(&self) -> Range<VariantIdx> {\n-        VariantIdx::new(0)..VariantIdx::new(self.variants.len())\n+    pub fn variant_range(self) -> Range<VariantIdx> {\n+        VariantIdx::new(0)..VariantIdx::new(self.variants().len())\n     }\n \n     /// Computes the discriminant value used by a specific variant.\n@@ -469,27 +498,27 @@ impl<'tcx> AdtDef {\n     /// assuming there are no constant-evaluation errors there.\n     #[inline]\n     pub fn discriminant_for_variant(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n         assert!(self.is_enum());\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n-            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n+            .unwrap_or_else(|| self.repr().discr_type().initial_discriminant(tcx));\n         explicit_value.checked_add(tcx, offset as u128).0\n     }\n \n     /// Yields a `DefId` for the discriminant and an offset to add to it\n     /// Alternatively, if there is no explicit discriminant, returns the\n     /// inferred discriminant directly.\n-    pub fn discriminant_def_for_variant(&self, variant_index: VariantIdx) -> (Option<DefId>, u32) {\n-        assert!(!self.variants.is_empty());\n+    pub fn discriminant_def_for_variant(self, variant_index: VariantIdx) -> (Option<DefId>, u32) {\n+        assert!(!self.variants().is_empty());\n         let mut explicit_index = variant_index.as_u32();\n         let expr_did;\n         loop {\n-            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n+            match self.variant(VariantIdx::from_u32(explicit_index)).discr {\n                 ty::VariantDiscr::Relative(0) => {\n                     expr_did = None;\n                     break;\n@@ -506,8 +535,8 @@ impl<'tcx> AdtDef {\n         (expr_did, variant_index.as_u32() - explicit_index)\n     }\n \n-    pub fn destructor(&self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n-        tcx.adt_destructor(self.did)\n+    pub fn destructor(self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n+        tcx.adt_destructor(self.did())\n     }\n \n     /// Returns a list of types such that `Self: Sized` if and only\n@@ -520,7 +549,7 @@ impl<'tcx> AdtDef {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n-        tcx.adt_sized_constraint(self.did).0\n+    pub fn sized_constraint(self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n+        tcx.adt_sized_constraint(self.did()).0\n     }\n }"}, {"sha": "1446f7dac36385c5f683ec43de579d79e98efb18", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> CapturedPlace<'tcx> {\n                         write!(\n                             &mut symbol,\n                             \"__{}\",\n-                            def.variants[variant].fields[idx as usize].name.as_str(),\n+                            def.variant(variant).fields[idx as usize].name.as_str(),\n                         )\n                         .unwrap();\n                     }\n@@ -330,7 +330,7 @@ pub fn place_to_string_for_capture<'tcx>(tcx: TyCtxt<'tcx>, place: &HirPlace<'tc\n                     curr_string = format!(\n                         \"{}.{}\",\n                         curr_string,\n-                        def.variants[variant].fields[idx as usize].name.as_str()\n+                        def.variant(variant).fields[idx as usize].name.as_str()\n                     );\n                 }\n                 ty::Tuple(_) => {"}, {"sha": "7fcc46cc7c206fd0b7d103bbbbb62d91d74412fb", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -15,7 +15,7 @@ use crate::mir::{\n use crate::thir;\n use crate::traits;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::Span;\n@@ -156,6 +156,12 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ConstAllocation<'tcx> {\n     }\n }\n \n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AdtDef<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.0.0.encode(e)\n+    }\n+}\n+\n impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.encode_alloc_id(self)\n@@ -178,8 +184,7 @@ encodable_via_deref! {\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n-    &'tcx mir::coverage::CodeRegion,\n-    &'tcx ty::AdtDef\n+    &'tcx mir::coverage::CodeRegion\n }\n \n pub trait TyDecoder<'tcx>: Decoder {\n@@ -367,6 +372,12 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ConstAllocation<'tcx> {\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AdtDef<'tcx> {\n+    fn decode(decoder: &mut D) -> Self {\n+        decoder.tcx().intern_adt_def(Decodable::decode(decoder))\n+    }\n+}\n+\n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         decoder.tcx().arena.alloc_from_iter(\n@@ -409,8 +420,7 @@ impl_decodable_via_ref! {\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n     &'tcx mir::coverage::CodeRegion,\n-    &'tcx ty::List<ty::BoundVariableKind>,\n-    &'tcx ty::AdtDef\n+    &'tcx ty::List<ty::BoundVariableKind>\n }\n \n #[macro_export]"}, {"sha": "494535f3d597ac1ca294ce2599cd6f322ccbe6e7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 48, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -17,7 +17,7 @@ use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n-    self, AdtDef, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n+    self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, ExistentialPredicate, FloatTy,\n     FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List,\n     ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy, Region,\n@@ -115,7 +115,7 @@ pub struct CtxtInterners<'tcx> {\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n     layout: InternedSet<'tcx, LayoutS<'tcx>>,\n-    adt_def: InternedSet<'tcx, AdtDef>,\n+    adt_def: InternedSet<'tcx, AdtDefData>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -1123,8 +1123,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         kind: AdtKind,\n         variants: IndexVec<VariantIdx, ty::VariantDef>,\n         repr: ReprOptions,\n-    ) -> &'tcx ty::AdtDef {\n-        self.intern_adt_def(ty::AdtDef::new(self, did, kind, variants, repr))\n+    ) -> ty::AdtDef<'tcx> {\n+        self.intern_adt_def(ty::AdtDefData::new(self, did, kind, variants, repr))\n     }\n \n     /// Allocates a read-only byte or string literal for `mir::interpret`.\n@@ -2147,47 +2147,7 @@ direct_interners! {\n     const_: mk_const(ConstS<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: intern_layout(LayoutS<'tcx>): Layout -> Layout<'tcx>,\n-}\n-\n-macro_rules! direct_interners_old {\n-    ($($name:ident: $method:ident($ty:ty),)+) => {\n-        $(impl<'tcx> Borrow<$ty> for InternedInSet<'tcx, $ty> {\n-            fn borrow<'a>(&'a self) -> &'a $ty {\n-                &self.0\n-            }\n-        }\n-\n-        impl<'tcx> PartialEq for InternedInSet<'tcx, $ty> {\n-            fn eq(&self, other: &Self) -> bool {\n-                // The `Borrow` trait requires that `x.borrow() == y.borrow()`\n-                // equals `x == y`.\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<'tcx> Eq for InternedInSet<'tcx, $ty> {}\n-\n-        impl<'tcx> Hash for InternedInSet<'tcx, $ty> {\n-            fn hash<H: Hasher>(&self, s: &mut H) {\n-                // The `Borrow` trait requires that `x.borrow().hash(s) ==\n-                // x.hash(s)`.\n-                self.0.hash(s)\n-            }\n-        }\n-\n-        impl<'tcx> TyCtxt<'tcx> {\n-            pub fn $method(self, v: $ty) -> &'tcx $ty {\n-                self.interners.$name.intern(v, |v| {\n-                    InternedInSet(self.interners.arena.alloc(v))\n-                }).0\n-            }\n-        })+\n-    }\n-}\n-\n-// FIXME: eventually these should all be converted to `direct_interners`.\n-direct_interners_old! {\n-    adt_def: intern_adt_def(AdtDef),\n+    adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n }\n \n macro_rules! slice_interners {\n@@ -2341,7 +2301,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_adt(self, def: &'tcx AdtDef, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         // Take a copy of substs so that we own the vectors inside.\n         self.mk_ty(Adt(def, substs))\n     }\n@@ -2563,12 +2523,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn mk_place_downcast(\n         self,\n         place: Place<'tcx>,\n-        adt_def: &'tcx AdtDef,\n+        adt_def: AdtDef<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Place<'tcx> {\n         self.mk_place_elem(\n             place,\n-            PlaceElem::Downcast(Some(adt_def.variants[variant_index].name), variant_index),\n+            PlaceElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index),\n         )\n     }\n "}, {"sha": "599845bae79f35b9c3124dedcb3d9b1cae83f721", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -247,7 +247,7 @@ impl<'tcx> Ty<'tcx> {\n             }\n             ty::Tuple(ref tys) if tys.is_empty() => format!(\"`{}`\", self).into(),\n \n-            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did())).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(t, n) => {\n                 if t.is_simple_ty() {"}, {"sha": "9c018dc685c46c2e9ff8f4dc1ec427567639979f", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -86,7 +86,7 @@ pub fn simplify_type<'tcx>(\n         ty::Int(int_type) => Some(IntSimplifiedType(int_type)),\n         ty::Uint(uint_type) => Some(UintSimplifiedType(uint_type)),\n         ty::Float(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::Adt(def, _) => Some(AdtSimplifiedType(def.did)),\n+        ty::Adt(def, _) => Some(AdtSimplifiedType(def.did())),\n         ty::Str => Some(StrSimplifiedType),\n         ty::Array(..) => Some(ArraySimplifiedType),\n         ty::Slice(..) => Some(SliceSimplifiedType),"}, {"sha": "2c78c1f63d8ff519328bdfd5adc8e1c544cd54e4", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -105,21 +105,21 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl<'tcx> AdtDef {\n+impl<'tcx> AdtDef<'tcx> {\n     /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n     fn uninhabited_from(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest<'tcx> {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n-        if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n+        if self.is_variant_list_non_exhaustive() && !self.did().is_local() {\n             DefIdForest::empty()\n         } else {\n             DefIdForest::intersection(\n                 tcx,\n-                self.variants\n+                self.variants()\n                     .iter()\n                     .map(|v| v.uninhabited_from(tcx, substs, self.adt_kind(), param_env)),\n             )"}, {"sha": "5b92b33f6d457574b22c0d6cae81887e7d66f636", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -733,7 +733,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // SIMD vector types.\n-            ty::Adt(def, substs) if def.repr.simd() => {\n+            ty::Adt(def, substs) if def.repr().simd() => {\n                 if !def.is_struct() {\n                     // Should have yielded E0517 by now.\n                     tcx.sess.delay_span_bug(\n@@ -853,7 +853,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Adt(def, substs) => {\n                 // Cache the field layouts.\n                 let variants = def\n-                    .variants\n+                    .variants()\n                     .iter()\n                     .map(|v| {\n                         v.fields\n@@ -864,22 +864,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n-                    if def.repr.pack.is_some() && def.repr.align.is_some() {\n+                    if def.repr().pack.is_some() && def.repr().align.is_some() {\n                         self.tcx.sess.delay_span_bug(\n-                            tcx.def_span(def.did),\n+                            tcx.def_span(def.did()),\n                             \"union cannot be packed and aligned\",\n                         );\n                         return Err(LayoutError::Unknown(ty));\n                     }\n \n                     let mut align =\n-                        if def.repr.pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+                        if def.repr().pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n \n-                    if let Some(repr_align) = def.repr.align {\n+                    if let Some(repr_align) = def.repr().align {\n                         align = align.max(AbiAndPrefAlign::new(repr_align));\n                     }\n \n-                    let optimize = !def.repr.inhibit_union_abi_opt();\n+                    let optimize = !def.repr().inhibit_union_abi_opt();\n                     let mut size = Size::ZERO;\n                     let mut abi = Abi::Aggregate { sized: true };\n                     let index = VariantIdx::new(0);\n@@ -915,7 +915,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         size = cmp::max(size, field.size);\n                     }\n \n-                    if let Some(pack) = def.repr.pack {\n+                    if let Some(pack) = def.repr().pack {\n                         align = align.min(AbiAndPrefAlign::new(pack));\n                     }\n \n@@ -963,7 +963,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // Only one variant is present.\n                     (present_second.is_none() &&\n                     // Representation optimizations are allowed.\n-                    !def.repr.inhibit_enum_layout_opt());\n+                    !def.repr().inhibit_enum_layout_opt());\n                 if is_struct {\n                     // Struct, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n@@ -972,8 +972,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let kind = if def.is_enum() || variants[v].is_empty() {\n                         StructKind::AlwaysSized\n                     } else {\n-                        let param_env = tcx.param_env(def.did);\n-                        let last_field = def.variants[v].fields.last().unwrap();\n+                        let param_env = tcx.param_env(def.did());\n+                        let last_field = def.variant(v).fields.last().unwrap();\n                         let always_sized =\n                             tcx.type_of(last_field.did).is_sized(tcx.at(DUMMY_SP), param_env);\n                         if !always_sized {\n@@ -983,9 +983,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         }\n                     };\n \n-                    let mut st = self.univariant_uninterned(ty, &variants[v], &def.repr, kind)?;\n+                    let mut st = self.univariant_uninterned(ty, &variants[v], &def.repr(), kind)?;\n                     st.variants = Variants::Single { index: v };\n-                    let (start, end) = self.tcx.layout_scalar_valid_range(def.did);\n+                    let (start, end) = self.tcx.layout_scalar_valid_range(def.did());\n                     match st.abi {\n                         Abi::Scalar(ref mut scalar) | Abi::ScalarPair(ref mut scalar, _) => {\n                             // the asserts ensure that we are not using the\n@@ -1011,7 +1011,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             }\n \n                             // Update `largest_niche` if we have introduced a larger niche.\n-                            let niche = if def.repr.hide_niche() {\n+                            let niche = if def.repr().hide_niche() {\n                                 None\n                             } else {\n                                 Niche::from_scalar(dl, Size::ZERO, *scalar)\n@@ -1049,14 +1049,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 // instead of actual discriminants, so dataful enums with\n                 // explicit discriminants (RFC #2363) would misbehave.\n                 let no_explicit_discriminants = def\n-                    .variants\n+                    .variants()\n                     .iter_enumerated()\n                     .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n \n                 let mut niche_filling_layout = None;\n \n                 // Niche-filling enum optimization.\n-                if !def.repr.inhibit_enum_layout_opt() && no_explicit_discriminants {\n+                if !def.repr().inhibit_enum_layout_opt() && no_explicit_discriminants {\n                     let mut dataful_variant = None;\n                     let mut niche_variants = VariantIdx::MAX..=VariantIdx::new(0);\n \n@@ -1107,7 +1107,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     let mut st = self.univariant_uninterned(\n                                         ty,\n                                         v,\n-                                        &def.repr,\n+                                        &def.repr(),\n                                         StructKind::AlwaysSized,\n                                     )?;\n                                     st.variants = Variants::Single { index: j };\n@@ -1169,7 +1169,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n \n                 let (mut min, mut max) = (i128::MAX, i128::MIN);\n-                let discr_type = def.repr.discr_type();\n+                let discr_type = def.repr().discr_type();\n                 let bits = Integer::from_attr(self, discr_type).size().bits();\n                 for (i, discr) in def.discriminants(tcx) {\n                     if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n@@ -1193,7 +1193,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     max = 0;\n                 }\n                 assert!(min <= max, \"discriminant range is {}...{}\", min, max);\n-                let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n+                let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr(), min, max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::ZERO;\n@@ -1208,7 +1208,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 // determining the alignment of the overall enum, and the\n                 // determining the alignment of the payload after the tag.)\n                 let mut prefix_align = min_ity.align(dl).abi;\n-                if def.repr.c() {\n+                if def.repr().c() {\n                     for fields in &variants {\n                         for field in fields {\n                             prefix_align = prefix_align.max(field.align.abi);\n@@ -1223,7 +1223,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         let mut st = self.univariant_uninterned(\n                             ty,\n                             &field_layouts,\n-                            &def.repr,\n+                            &def.repr(),\n                             StructKind::Prefixed(min_ity.size(), prefix_align),\n                         )?;\n                         st.variants = Variants::Single { index: i };\n@@ -1250,7 +1250,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n \n-                let typeck_ity = Integer::from_attr(dl, def.repr.discr_type());\n+                let typeck_ity = Integer::from_attr(dl, def.repr().discr_type());\n                 if typeck_ity < min_ity {\n                     // It is a bug if Layout decided on a greater discriminant size than typeck for\n                     // some reason at this point (based on values discriminant can take on). Mostly\n@@ -1280,7 +1280,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 // won't be so conservative.\n \n                 // Use the initial field alignment\n-                let mut ity = if def.repr.c() || def.repr.int.is_some() {\n+                let mut ity = if def.repr().c() || def.repr().int.is_some() {\n                     min_ity\n                 } else {\n                     Integer::for_align(dl, start_align).unwrap_or(min_ity)\n@@ -1821,7 +1821,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n-        let adt_packed = adt_def.repr.pack.is_some();\n+        let adt_packed = adt_def.repr().pack.is_some();\n \n         let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n             let mut min_size = Size::ZERO;\n@@ -1855,12 +1855,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         match layout.variants {\n             Variants::Single { index } => {\n-                if !adt_def.variants.is_empty() && layout.fields != FieldsShape::Primitive {\n+                if !adt_def.variants().is_empty() && layout.fields != FieldsShape::Primitive {\n                     debug!(\n                         \"print-type-size `{:#?}` variant {}\",\n-                        layout, adt_def.variants[index].name\n+                        layout,\n+                        adt_def.variant(index).name\n                     );\n-                    let variant_def = &adt_def.variants[index];\n+                    let variant_def = &adt_def.variant(index);\n                     let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n                     record(\n                         adt_kind.into(),\n@@ -1879,10 +1880,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 debug!(\n                     \"print-type-size `{:#?}` adt general variants def {}\",\n                     layout.ty,\n-                    adt_def.variants.len()\n+                    adt_def.variants().len()\n                 );\n                 let variant_infos: Vec<_> = adt_def\n-                    .variants\n+                    .variants()\n                     .iter_enumerated()\n                     .map(|(i, variant_def)| {\n                         let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n@@ -1964,17 +1965,17 @@ impl<'tcx> SizeSkeleton<'tcx> {\n \n             ty::Adt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n-                if def.is_union() || def.variants.is_empty() || def.variants.len() > 2 {\n+                if def.is_union() || def.variants().is_empty() || def.variants().len() > 2 {\n                     return Err(err);\n                 }\n \n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i| {\n                     let i = VariantIdx::new(i);\n-                    let fields = def.variants[i]\n-                        .fields\n-                        .iter()\n-                        .map(|field| SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env));\n+                    let fields =\n+                        def.variant(i).fields.iter().map(|field| {\n+                            SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env)\n+                        });\n                     let mut ptr = None;\n                     for field in fields {\n                         let field = field?;\n@@ -1997,11 +1998,11 @@ impl<'tcx> SizeSkeleton<'tcx> {\n \n                 let v0 = zero_or_ptr_variant(0)?;\n                 // Newtype.\n-                if def.variants.len() == 1 {\n+                if def.variants().len() == 1 {\n                     if let Some(SizeSkeleton::Pointer { non_zero, tail }) = v0 {\n                         return Ok(SizeSkeleton::Pointer {\n                             non_zero: non_zero\n-                                || match tcx.layout_scalar_valid_range(def.did) {\n+                                || match tcx.layout_scalar_valid_range(def.did()) {\n                                     (Bound::Included(start), Bound::Unbounded) => start > 0,\n                                     (Bound::Included(start), Bound::Included(end)) => {\n                                         0 < start && start < end\n@@ -2262,9 +2263,9 @@ where\n                 }\n \n                 let fields = match this.ty.kind() {\n-                    ty::Adt(def, _) if def.variants.is_empty() =>\n+                    ty::Adt(def, _) if def.variants().is_empty() =>\n                         bug!(\"for_variant called on zero-variant enum\"),\n-                    ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n+                    ty::Adt(def, _) => def.variant(variant_index).fields.len(),\n                     _ => bug!(),\n                 };\n                 tcx.intern_layout(LayoutS {\n@@ -2405,7 +2406,7 @@ where\n                 ty::Adt(def, substs) => {\n                     match this.variants {\n                         Variants::Single { index } => {\n-                            TyMaybeWithLayout::Ty(def.variants[index].fields[i].ty(tcx, substs))\n+                            TyMaybeWithLayout::Ty(def.variant(index).fields[i].ty(tcx, substs))\n                         }\n \n                         // Discriminant field for enums (where applicable)."}, {"sha": "c74b3e9d0fc3937d620350ad21b612c1086f789e", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -274,7 +274,7 @@ fn characteristic_def_id_of_type_cached<'a>(\n     visited: &mut SsoHashSet<Ty<'a>>,\n ) -> Option<DefId> {\n     match *ty.kind() {\n-        ty::Adt(adt_def, _) => Some(adt_def.did),\n+        ty::Adt(adt_def, _) => Some(adt_def.did()),\n \n         ty::Dynamic(data, ..) => data.principal_def_id(),\n "}, {"sha": "00cb9907d95a5dae0aebd50fa3f6e2cced010ef1", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -618,7 +618,7 @@ pub trait PrettyPrinter<'tcx>:\n                 ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n             },\n             ty::Adt(def, substs) => {\n-                p!(print_def_path(def.did, substs));\n+                p!(print_def_path(def.did(), substs));\n             }\n             ty::Dynamic(data, r) => {\n                 let print_r = self.should_print_region(r);\n@@ -1487,7 +1487,7 @@ pub trait PrettyPrinter<'tcx>:\n                         }\n                         p!(\")\");\n                     }\n-                    ty::Adt(def, _) if def.variants.is_empty() => {\n+                    ty::Adt(def, _) if def.variants().is_empty() => {\n                         self = self.typed_value(\n                             |mut this| {\n                                 write!(this, \"unreachable()\")?;\n@@ -1500,7 +1500,7 @@ pub trait PrettyPrinter<'tcx>:\n                     ty::Adt(def, substs) => {\n                         let variant_idx =\n                             contents.variant.expect(\"destructed const of adt without variant idx\");\n-                        let variant_def = &def.variants[variant_idx];\n+                        let variant_def = &def.variant(variant_idx);\n                         p!(print_value_path(variant_def.def_id, substs));\n \n                         match variant_def.ctor_kind {"}, {"sha": "81ee7942c4d3452da10a4c0d61b61493e2837f4f", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -406,7 +406,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => Ok(a),\n \n         (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs)) if a_def == b_def => {\n-            let substs = relation.relate_item_substs(a_def.did, a_substs, b_substs)?;\n+            let substs = relation.relate_item_substs(a_def.did(), a_substs, b_substs)?;\n             Ok(tcx.mk_adt(a_def, substs))\n         }\n "}, {"sha": "5c7910db362d290c2257e04daf031bdebffb8436", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -33,13 +33,13 @@ impl fmt::Debug for ty::TraitDef {\n     }\n }\n \n-impl fmt::Debug for ty::AdtDef {\n+impl<'tcx> fmt::Debug for ty::AdtDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             with_no_trimmed_paths!({\n                 f.write_str(\n                     &FmtPrinter::new(tcx, Namespace::TypeNS)\n-                        .print_def_path(self.did, &[])?\n+                        .print_def_path(self.did(), &[])?\n                         .into_buffer(),\n                 )\n             })\n@@ -672,7 +672,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n // TypeFoldable implementations.\n \n /// AdtDefs are basically the same as a DefId.\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::AdtDef<'tcx> {\n     fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n         self,\n         _folder: &mut F,"}, {"sha": "a49189ae92afb0e11e8dc51aff6c29414aea163a", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -109,7 +109,7 @@ pub enum TyKind<'tcx> {\n     ///\n     /// Note that generic parameters in fields only get lazily substituted\n     /// by using something like `adt_def.all_fields().map(|field| field.ty(tcx, substs))`.\n-    Adt(&'tcx AdtDef, SubstsRef<'tcx>),\n+    Adt(AdtDef<'tcx>, SubstsRef<'tcx>),\n \n     /// An unsized FFI type that is opaque to Rust. Written as `extern type T`.\n     Foreign(DefId),\n@@ -1903,7 +1903,7 @@ impl<'tcx> Ty<'tcx> {\n     #[inline]\n     pub fn is_simd(self) -> bool {\n         match self.kind() {\n-            Adt(def, _) => def.repr.simd(),\n+            Adt(def, _) => def.repr().simd(),\n             _ => false,\n         }\n     }\n@@ -1919,7 +1919,7 @@ impl<'tcx> Ty<'tcx> {\n     pub fn simd_size_and_type(self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {\n-                assert!(def.repr.simd(), \"`simd_size_and_type` called on non-SIMD type\");\n+                assert!(def.repr().simd(), \"`simd_size_and_type` called on non-SIMD type\");\n                 let variant = def.non_enum_variant();\n                 let f0_ty = variant.fields[0].ty(tcx, substs);\n \n@@ -2153,9 +2153,9 @@ impl<'tcx> Ty<'tcx> {\n     }\n \n     #[inline]\n-    pub fn ty_adt_def(self) -> Option<&'tcx AdtDef> {\n+    pub fn ty_adt_def(self) -> Option<AdtDef<'tcx>> {\n         match self.kind() {\n-            Adt(adt, _) => Some(adt),\n+            Adt(adt, _) => Some(*adt),\n             _ => None,\n         }\n     }\n@@ -2194,7 +2194,7 @@ impl<'tcx> Ty<'tcx> {\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.kind() {\n-            TyKind::Adt(adt, _) if adt.variants.is_empty() => {\n+            TyKind::Adt(adt, _) if adt.variants().is_empty() => {\n                 // This can actually happen during CTFE, see\n                 // https://github.com/rust-lang/rust/issues/89765.\n                 None\n@@ -2212,7 +2212,7 @@ impl<'tcx> Ty<'tcx> {\n     /// Returns the type of the discriminant of this type.\n     pub fn discriminant_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n-            ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n+            ty::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n \n             ty::Param(_) | ty::Projection(_) | ty::Opaque(..) | ty::Infer(ty::TyVar(_)) => {"}, {"sha": "6bde9e6d5e25c89a0b70790e37b51d264ac413ea", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -377,10 +377,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that this returns only the constraints for the\n     /// destructor of `def` itself. For the destructors of the\n     /// contents, you need `adt_dtorck_constraint`.\n-    pub fn destructor_constraints(self, def: &'tcx ty::AdtDef) -> Vec<ty::subst::GenericArg<'tcx>> {\n+    pub fn destructor_constraints(self, def: ty::AdtDef<'tcx>) -> Vec<ty::subst::GenericArg<'tcx>> {\n         let dtor = match def.destructor(self) {\n             None => {\n-                debug!(\"destructor_constraints({:?}) - no dtor\", def.did);\n+                debug!(\"destructor_constraints({:?}) - no dtor\", def.did());\n                 return vec![];\n             }\n             Some(dtor) => dtor.did,\n@@ -415,7 +415,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => bug!(),\n         };\n \n-        let item_substs = match *self.type_of(def.did).kind() {\n+        let item_substs = match *self.type_of(def.did()).kind() {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!(),\n         };\n@@ -445,7 +445,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             })\n             .map(|(item_param, _)| item_param)\n             .collect();\n-        debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n+        debug!(\"destructor_constraint({:?}) = {:?}\", def.did(), result);\n         result\n     }\n "}, {"sha": "3b93d127d2c29ea54b72ed18a455ef738f022f38", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -334,8 +334,8 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         self.project(PlaceElem::Deref)\n     }\n \n-    crate fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Self {\n-        self.project(PlaceElem::Downcast(Some(adt_def.variants[variant_index].name), variant_index))\n+    crate fn downcast(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx) -> Self {\n+        self.project(PlaceElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index))\n     }\n \n     fn index(self, index: Local) -> Self {"}, {"sha": "8092f999311230544793bce0c49624d19ebae303", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .collect();\n \n                 let field_names: Vec<_> =\n-                    (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect();\n+                    (0..adt_def.variant(variant_index).fields.len()).map(Field::new).collect();\n \n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n                     let place_builder =\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     })\n                 });\n                 let adt = Box::new(AggregateKind::Adt(\n-                    adt_def.did,\n+                    adt_def.did(),\n                     variant_index,\n                     substs,\n                     user_ty,"}, {"sha": "c724e3e1b8f2af94e4b97e5c4a211660af96dd2b", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -946,7 +946,7 @@ enum TestKind<'tcx> {\n     /// Test what enum variant a value is.\n     Switch {\n         /// The enum type being tested.\n-        adt_def: &'tcx ty::AdtDef,\n+        adt_def: ty::AdtDef<'tcx>,\n         /// The set of variants that we should create a branch for. We also\n         /// create an additional \"otherwise\" case.\n         variants: BitSet<VariantIdx>,"}, {"sha": "7f53d9dd70502ad10b0f567efdd81d9e77a9f3fa", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n-                let irrefutable = adt_def.variants.iter_enumerated().all(|(i, v)| {\n+                let irrefutable = adt_def.variants().iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.tcx.features().exhaustive_patterns\n                             && !v\n@@ -276,7 +276,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 )\n                                 .is_empty()\n                     }\n-                }) && (adt_def.did.is_local()\n+                }) && (adt_def.did().is_local()\n                     || !adt_def.is_variant_list_non_exhaustive());\n                 if irrefutable {\n                     let place_builder = match_pair.place.downcast(adt_def, variant_index);"}, {"sha": "96069f05b40f3ad30e5a3ef2515f294d579ec011", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -30,11 +30,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// It is a bug to call this with a not-fully-simplified pattern.\n     pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n-            PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {\n+            PatKind::Variant { adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {\n                 span: match_pair.pattern.span,\n                 kind: TestKind::Switch {\n                     adt_def,\n-                    variants: BitSet::new_empty(adt_def.variants.len()),\n+                    variants: BitSet::new_empty(adt_def.variants().len()),\n                 },\n             },\n \n@@ -174,7 +174,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             TestKind::Switch { adt_def, ref variants } => {\n                 let target_blocks = make_target_blocks(self);\n                 // Variants is a BitVec of indexes into adt_def.variants.\n-                let num_enum_variants = adt_def.variants.len();\n+                let num_enum_variants = adt_def.variants().len();\n                 debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n                 let otherwise_block = *target_blocks.last().unwrap();\n                 let tcx = self.tcx;\n@@ -201,7 +201,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     otherwise_block,\n                 );\n                 debug!(\"num_enum_variants: {}, variants: {:?}\", num_enum_variants, variants);\n-                let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n+                let discr_ty = adt_def.repr().discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n                 self.cfg.push_assign(\n                     block,\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn candidate_after_variant_switch<'pat>(\n         &mut self,\n         match_pair_index: usize,\n-        adt_def: &'tcx ty::AdtDef,\n+        adt_def: ty::AdtDef<'tcx>,\n         variant_index: VariantIdx,\n         subpatterns: &'pat [FieldPat<'tcx>],\n         candidate: &mut Candidate<'pat, 'tcx>,\n@@ -744,7 +744,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem =\n-            ProjectionElem::Downcast(Some(adt_def.variants[variant_index].name), variant_index);\n+            ProjectionElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index);\n         let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n@@ -798,7 +798,7 @@ impl Test<'_> {\n                 // variants, we have a target for each variant and the\n                 // otherwise case, and we make sure that all of the cases not\n                 // specified have the same block.\n-                adt_def.variants.len() + 1\n+                adt_def.variants().len() + 1\n             }\n             TestKind::SwitchInt { switch_ty, ref options, .. } => {\n                 if switch_ty.is_bool() {"}, {"sha": "2d1198edbc393899ec3c8d28281ad0698b2b1227", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for LayoutConstrainedPlaceVisitor<'a, 'tcx> {\n             ExprKind::Field { lhs, .. } => {\n                 if let ty::Adt(adt_def, _) = self.thir[lhs].ty.kind() {\n                     if (Bound::Unbounded, Bound::Unbounded)\n-                        != self.tcx.layout_scalar_valid_range(adt_def.did)\n+                        != self.tcx.layout_scalar_valid_range(adt_def.did())\n                     {\n                         self.found = true;\n                     }\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                         visit::walk_pat(self, pat);\n                         self.in_union_destructure = old_in_union_destructure;\n                     } else if (Bound::Unbounded, Bound::Unbounded)\n-                        != self.tcx.layout_scalar_valid_range(adt_def.did)\n+                        != self.tcx.layout_scalar_valid_range(adt_def.did())\n                     {\n                         let old_inside_adt = std::mem::replace(&mut self.inside_adt, true);\n                         visit::walk_pat(self, pat);\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 user_ty: _,\n                 fields: _,\n                 base: _,\n-            }) => match self.tcx.layout_scalar_valid_range(adt_def.did) {\n+            }) => match self.tcx.layout_scalar_valid_range(adt_def.did()) {\n                 (Bound::Unbounded, Bound::Unbounded) => {}\n                 _ => self.requires_unsafe(expr.span, InitializingTypeWith),\n             },"}, {"sha": "23ee982489db2069efca36e4dba41542a6891b5a", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -228,7 +228,7 @@ impl<'tcx> Cx<'tcx> {\n                         let user_ty =\n                             user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n                                 if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n-                                    *did = adt_def.did;\n+                                    *did = adt_def.did();\n                                 }\n                                 u_ty\n                             });\n@@ -376,7 +376,7 @@ impl<'tcx> Cx<'tcx> {\n                         let user_ty = user_provided_types.get(expr.hir_id).copied();\n                         debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                         ExprKind::Adt(Box::new(Adt {\n-                            adt_def: adt,\n+                            adt_def: *adt,\n                             variant_index: VariantIdx::new(0),\n                             substs,\n                             user_ty,\n@@ -402,7 +402,7 @@ impl<'tcx> Cx<'tcx> {\n                                 let user_ty = user_provided_types.get(expr.hir_id).copied();\n                                 debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n                                 ExprKind::Adt(Box::new(Adt {\n-                                    adt_def: adt,\n+                                    adt_def: *adt,\n                                     variant_index: index,\n                                     substs,\n                                     user_ty,\n@@ -680,7 +680,7 @@ impl<'tcx> Cx<'tcx> {\n                                     let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n                                     let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                     use rustc_middle::ty::util::IntTypeExt;\n-                                    let ty = adt_def.repr.discr_type();\n+                                    let ty = adt_def.repr().discr_type();\n                                     let ty = ty.to_ty(self.tcx());\n                                     Some((d, o, ty))\n                                 }\n@@ -924,7 +924,7 @@ impl<'tcx> Cx<'tcx> {\n                     // A unit struct/variant which is used as a value.\n                     // We return a completely different ExprKind here to account for this special case.\n                     ty::Adt(adt_def, substs) => ExprKind::Adt(Box::new(Adt {\n-                        adt_def,\n+                        adt_def: *adt_def,\n                         variant_index: adt_def.variant_index_with_ctor_id(def_id),\n                         substs,\n                         user_ty: user_provided_type,"}, {"sha": "e2c56df60148bd5b3b2102cbc007a8b24819b342", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -395,17 +395,17 @@ fn check_for_bindings_named_same_as_variants(\n             && let pat_ty = cx.typeck_results.pat_ty(p).peel_refs()\n             && let ty::Adt(edef, _) = pat_ty.kind()\n             && edef.is_enum()\n-            && edef.variants.iter().any(|variant| {\n+            && edef.variants().iter().any(|variant| {\n                 variant.ident(cx.tcx) == ident && variant.ctor_kind == CtorKind::Const\n             })\n         {\n-            let variant_count = edef.variants.len();\n+            let variant_count = edef.variants().len();\n             cx.tcx.struct_span_lint_hir(\n                 BINDINGS_WITH_VARIANT_NAME,\n                 p.hir_id,\n                 p.span,\n                 |lint| {\n-                    let ty_path = cx.tcx.def_path_str(edef.did);\n+                    let ty_path = cx.tcx.def_path_str(edef.did());\n                     let mut err = lint.build(&format!(\n                         \"pattern binding `{}` is named the same as one \\\n                          of the variants of the type `{}`\",\n@@ -573,7 +573,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n ) {\n     let is_empty_match = arms.is_empty();\n     let non_empty_enum = match scrut_ty.kind() {\n-        ty::Adt(def, _) => def.is_enum() && !def.variants.is_empty(),\n+        ty::Adt(def, _) => def.is_enum() && !def.variants().is_empty(),\n         _ => false,\n     };\n     // In the case of an empty match, replace the '`_` not covered' diagnostic with something more\n@@ -609,7 +609,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     };\n \n     let is_variant_list_non_exhaustive = match scrut_ty.kind() {\n-        ty::Adt(def, _) if def.is_variant_list_non_exhaustive() && !def.did.is_local() => true,\n+        ty::Adt(def, _) if def.is_variant_list_non_exhaustive() && !def.did().is_local() => true,\n         _ => false,\n     };\n \n@@ -762,17 +762,17 @@ fn adt_defined_here<'p, 'tcx>(\n     if let ty::Adt(def, _) = ty.kind() {\n         let mut spans = vec![];\n         if witnesses.len() < 5 {\n-            for sp in maybe_point_at_variant(cx, def, witnesses.iter()) {\n+            for sp in maybe_point_at_variant(cx, *def, witnesses.iter()) {\n                 spans.push(sp);\n             }\n         }\n         let def_span = cx\n             .tcx\n             .hir()\n-            .get_if_local(def.did)\n+            .get_if_local(def.did())\n             .and_then(|node| node.ident())\n             .map(|ident| ident.span)\n-            .unwrap_or_else(|| cx.tcx.def_span(def.did));\n+            .unwrap_or_else(|| cx.tcx.def_span(def.did()));\n         let mut span: MultiSpan =\n             if spans.is_empty() { def_span.into() } else { spans.clone().into() };\n \n@@ -786,17 +786,17 @@ fn adt_defined_here<'p, 'tcx>(\n \n fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n-    def: &AdtDef,\n+    def: AdtDef<'tcx>,\n     patterns: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n ) -> Vec<Span> {\n     use Constructor::*;\n     let mut covered = vec![];\n     for pattern in patterns {\n         if let Variant(variant_index) = pattern.ctor() {\n-            if let ty::Adt(this_def, _) = pattern.ty().kind() && this_def.did != def.did {\n+            if let ty::Adt(this_def, _) = pattern.ty().kind() && this_def.did() != def.did() {\n                 continue;\n             }\n-            let sp = def.variants[*variant_index].ident(cx.tcx).span;\n+            let sp = def.variant(*variant_index).ident(cx.tcx).span;\n             if covered.contains(&sp) {\n                 // Don't point at variants that have already been covered due to other patterns to avoid\n                 // visual clutter."}, {"sha": "ae9b44cee4bf8fe07dbf803c20fe3a28b1720a91", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -110,8 +110,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn adt_derive_msg(&self, adt_def: &AdtDef) -> String {\n-        let path = self.tcx().def_path_str(adt_def.did);\n+    fn adt_derive_msg(&self, adt_def: AdtDef<'tcx>) -> String {\n+        let path = self.tcx().def_path_str(adt_def.did());\n         format!(\n             \"to use a constant of type `{}` in a pattern, \\\n             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n@@ -346,7 +346,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     adt_def,\n                     cv.ty()\n                 );\n-                let path = tcx.def_path_str(adt_def.did);\n+                let path = tcx.def_path_str(adt_def.did());\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n                      `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n@@ -363,7 +363,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let destructured = tcx.destructure_const(param_env.and(cv));\n                 PatKind::Variant {\n-                    adt_def,\n+                    adt_def: *adt_def,\n                     substs,\n                     variant_index: destructured\n                         .variant"}, {"sha": "61f1069d5716b0389af3aa0a0aa058f30e568eb8", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -681,7 +681,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// This means that the variant has a stdlib unstable feature marking it.\n     pub(super) fn is_unstable_variant(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n         if let Constructor::Variant(idx) = self && let ty::Adt(adt, _) = pcx.ty.kind() {\n-            let variant_def_id = adt.variants[*idx].def_id;\n+            let variant_def_id = adt.variant(*idx).def_id;\n             // Filter variants that depend on a disabled unstable feature.\n             return matches!(\n                 pcx.cx.tcx.eval_stability(variant_def_id, None, DUMMY_SP, None),\n@@ -695,13 +695,13 @@ impl<'tcx> Constructor<'tcx> {\n     /// attribute.\n     pub(super) fn is_doc_hidden_variant(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n         if let Constructor::Variant(idx) = self && let ty::Adt(adt, _) = pcx.ty.kind() {\n-            let variant_def_id = adt.variants[*idx].def_id;\n+            let variant_def_id = adt.variant(*idx).def_id;\n             return pcx.cx.tcx.is_doc_hidden(variant_def_id);\n         }\n         false\n     }\n \n-    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n+    fn variant_index_for_adt(&self, adt: ty::AdtDef<'tcx>) -> VariantIdx {\n         match *self {\n             Variant(idx) => idx,\n             Single => {\n@@ -725,7 +725,7 @@ impl<'tcx> Constructor<'tcx> {\n                         // patterns. If we're here we can assume this is a box pattern.\n                         1\n                     } else {\n-                        let variant = &adt.variants[self.variant_index_for_adt(adt)];\n+                        let variant = &adt.variant(self.variant_index_for_adt(*adt));\n                         Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant).count()\n                     }\n                 }\n@@ -973,10 +973,10 @@ impl<'tcx> SplitWildcard<'tcx> {\n                 // exception is if the pattern is at the top level, because we want empty matches to be\n                 // considered exhaustive.\n                 let is_secretly_empty =\n-                    def.variants.is_empty() && !is_exhaustive_pat_feature && !pcx.is_top_level;\n+                    def.variants().is_empty() && !is_exhaustive_pat_feature && !pcx.is_top_level;\n \n                 let mut ctors: SmallVec<[_; 1]> = def\n-                    .variants\n+                    .variants()\n                     .iter_enumerated()\n                     .filter(|(_, v)| {\n                         // If `exhaustive_patterns` is enabled, we exclude variants known to be\n@@ -1179,7 +1179,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     ) -> impl Iterator<Item = (Field, Ty<'tcx>)> + Captures<'a> + Captures<'p> {\n         let ty::Adt(adt, substs) = ty.kind() else { bug!() };\n         // Whether we must not match the fields of this variant exhaustively.\n-        let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+        let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did().is_local();\n \n         variant.fields.iter().enumerate().filter_map(move |(i, field)| {\n             let ty = field.ty(cx.tcx, substs);\n@@ -1213,7 +1213,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // patterns. If we're here we can assume this is a box pattern.\n                         Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n                     } else {\n-                        let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n+                        let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n                         let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n                             .map(|(_, ty)| ty);\n                         Fields::wildcards_from_tys(cx, tys)\n@@ -1346,7 +1346,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                             PatKind::Variant { variant_index, .. } => Variant(*variant_index),\n                             _ => bug!(),\n                         };\n-                        let variant = &adt.variants[ctor.variant_index_for_adt(adt)];\n+                        let variant = &adt.variant(ctor.variant_index_for_adt(*adt));\n                         // For each field in the variant, we store the relevant index into `self.fields` if any.\n                         let mut field_id_to_id: Vec<Option<usize>> =\n                             (0..variant.fields.len()).map(|_| None).collect();\n@@ -1459,15 +1459,15 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     PatKind::Deref { subpattern: subpatterns.next().unwrap() }\n                 }\n                 ty::Adt(adt_def, substs) => {\n-                    let variant_index = self.ctor.variant_index_for_adt(adt_def);\n-                    let variant = &adt_def.variants[variant_index];\n+                    let variant_index = self.ctor.variant_index_for_adt(*adt_def);\n+                    let variant = &adt_def.variant(variant_index);\n                     let subpatterns = Fields::list_variant_nonhidden_fields(cx, self.ty, variant)\n                         .zip(subpatterns)\n                         .map(|((field, _ty), pattern)| FieldPat { field, pattern })\n                         .collect();\n \n                     if adt_def.is_enum() {\n-                        PatKind::Variant { adt_def, substs, variant_index, subpatterns }\n+                        PatKind::Variant { adt_def: *adt_def, substs, variant_index, subpatterns }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n                     }\n@@ -1640,9 +1640,7 @@ impl<'p, 'tcx> fmt::Debug for DeconstructedPat<'p, 'tcx> {\n                 }\n                 ty::Adt(..) | ty::Tuple(..) => {\n                     let variant = match self.ty.kind() {\n-                        ty::Adt(adt, _) => {\n-                            Some(&adt.variants[self.ctor.variant_index_for_adt(adt)])\n-                        }\n+                        ty::Adt(adt, _) => Some(adt.variant(self.ctor.variant_index_for_adt(*adt))),\n                         ty::Tuple(_) => None,\n                         _ => unreachable!(),\n                     };"}, {"sha": "d21fbb9edffb75ff648c8ae7ab3124e09d85466c", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -653,7 +653,7 @@ macro_rules! CloneImpls {\n \n CloneImpls! { <'tcx>\n     Span, Field, Mutability, Symbol, hir::HirId, usize, ty::Const<'tcx>,\n-    Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n+    Region<'tcx>, Ty<'tcx>, BindingMode, AdtDef<'tcx>,\n     SubstsRef<'tcx>, &'tcx GenericArg<'tcx>, UserType<'tcx>,\n     UserTypeProjection, PatTyProj<'tcx>\n }"}, {"sha": "176723ab28b676905d58445e753f7c0167a9c2f3", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub(super) fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind() {\n             ty::Adt(def, ..) => {\n-                def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n+                def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did().is_local()\n             }\n             _ => false,\n         }"}, {"sha": "82f97f22ccec4ed5cf792788c352e37791697a38", "filename": "compiler/rustc_mir_build/src/thir/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -20,7 +20,7 @@ crate trait UserAnnotatedTyHelpers<'tcx> {\n         match ty.kind() {\n             ty::Adt(adt_def, ..) => {\n                 if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {\n-                    *did = adt_def.did;\n+                    *did = adt_def.did();\n                 }\n                 Some(user_ty)\n             }"}, {"sha": "84491d0c2ad198d092b32332d4fa56be41238937", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -407,7 +407,7 @@ where\n         self.drop_ladder(fields, succ, unwind).0\n     }\n \n-    fn open_drop_for_box(&mut self, adt: &'tcx ty::AdtDef, substs: SubstsRef<'tcx>) -> BasicBlock {\n+    fn open_drop_for_box(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n         let interior = self.tcx().mk_place_deref(self.place);\n@@ -420,9 +420,9 @@ where\n         self.drop_subpath(interior, interior_path, succ, unwind_succ)\n     }\n \n-    fn open_drop_for_adt(&mut self, adt: &'tcx ty::AdtDef, substs: SubstsRef<'tcx>) -> BasicBlock {\n+    fn open_drop_for_adt(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", self, adt, substs);\n-        if adt.variants.is_empty() {\n+        if adt.variants().is_empty() {\n             return self.elaborator.patch().new_block(BasicBlockData {\n                 statements: vec![],\n                 terminator: Some(Terminator {\n@@ -434,7 +434,7 @@ where\n         }\n \n         let skip_contents =\n-            adt.is_union() || Some(adt.did) == self.tcx().lang_items().manually_drop();\n+            adt.is_union() || Some(adt.did()) == self.tcx().lang_items().manually_drop();\n         let contents_drop = if skip_contents {\n             (self.succ, self.unwind)\n         } else {\n@@ -450,15 +450,15 @@ where\n \n     fn open_drop_for_adt_contents(\n         &mut self,\n-        adt: &'tcx ty::AdtDef,\n+        adt: ty::AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> (BasicBlock, Unwind) {\n         let (succ, unwind) = self.drop_ladder_bottom();\n         if !adt.is_enum() {\n             let fields = self.move_paths_for_fields(\n                 self.place,\n                 self.path,\n-                &adt.variants[VariantIdx::new(0)],\n+                &adt.variant(VariantIdx::new(0)),\n                 substs,\n             );\n             self.drop_ladder(fields, succ, unwind)\n@@ -469,22 +469,22 @@ where\n \n     fn open_drop_for_multivariant(\n         &mut self,\n-        adt: &'tcx ty::AdtDef,\n+        adt: ty::AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n         succ: BasicBlock,\n         unwind: Unwind,\n     ) -> (BasicBlock, Unwind) {\n-        let mut values = Vec::with_capacity(adt.variants.len());\n-        let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n+        let mut values = Vec::with_capacity(adt.variants().len());\n+        let mut normal_blocks = Vec::with_capacity(adt.variants().len());\n         let mut unwind_blocks =\n-            if unwind.is_cleanup() { None } else { Some(Vec::with_capacity(adt.variants.len())) };\n+            if unwind.is_cleanup() { None } else { Some(Vec::with_capacity(adt.variants().len())) };\n \n         let mut have_otherwise_with_drop_glue = false;\n         let mut have_otherwise = false;\n         let tcx = self.tcx();\n \n         for (variant_index, discr) in adt.discriminants(tcx) {\n-            let variant = &adt.variants[variant_index];\n+            let variant = &adt.variant(variant_index);\n             let subpath = self.elaborator.downcast_subpath(self.path, variant_index);\n \n             if let Some(variant_path) = subpath {\n@@ -564,7 +564,7 @@ where\n \n     fn adt_switch_block(\n         &mut self,\n-        adt: &'tcx ty::AdtDef,\n+        adt: ty::AdtDef<'tcx>,\n         blocks: Vec<BasicBlock>,\n         values: &[u128],\n         succ: BasicBlock,\n@@ -577,7 +577,7 @@ where\n         // Additionally, we do not want to switch on the\n         // discriminant after it is free-ed, because that\n         // way lies only trouble.\n-        let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n+        let discr_ty = adt.repr().discr_type().to_ty(self.tcx());\n         let discr = Place::from(self.new_temp(discr_ty));\n         let discr_rv = Rvalue::Discriminant(self.place);\n         let switch_block = BasicBlockData {\n@@ -869,9 +869,9 @@ where\n             ty::Tuple(fields) => self.open_drop_for_tuple(fields),\n             ty::Adt(def, substs) => {\n                 if def.is_box() {\n-                    self.open_drop_for_box(def, substs)\n+                    self.open_drop_for_box(*def, substs)\n                 } else {\n-                    self.open_drop_for_adt(def, substs)\n+                    self.open_drop_for_adt(*def, substs)\n                 }\n             }\n             ty::Dynamic(..) => self.complete_drop(self.succ, self.unwind),\n@@ -927,7 +927,7 @@ where\n     /// The contained value will not be dropped.\n     fn box_free_block(\n         &mut self,\n-        adt: &'tcx ty::AdtDef,\n+        adt: ty::AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind,\n@@ -940,15 +940,16 @@ where\n     /// value).\n     fn unelaborated_free_block(\n         &mut self,\n-        adt: &'tcx ty::AdtDef,\n+        adt: ty::AdtDef<'tcx>,\n         substs: SubstsRef<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind,\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n         let free_func = tcx.require_lang_item(LangItem::BoxFree, Some(self.source_info.span));\n-        let args = adt.variants[VariantIdx::new(0)]\n+        let args = adt\n+            .variant(VariantIdx::new(0))\n             .fields\n             .iter()\n             .enumerate()"}, {"sha": "87c1060f55257b4fb840b838fc0d365266567250", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -705,14 +705,14 @@ fn switch_on_enum_discriminant<'mir, 'tcx>(\n     body: &'mir mir::Body<'tcx>,\n     block: &'mir mir::BasicBlockData<'tcx>,\n     switch_on: mir::Place<'tcx>,\n-) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n+) -> Option<(mir::Place<'tcx>, ty::AdtDef<'tcx>)> {\n     for statement in block.statements.iter().rev() {\n         match &statement.kind {\n             mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated)))\n                 if *lhs == switch_on =>\n             {\n-                match &discriminated.ty(body, tcx).ty.kind() {\n-                    ty::Adt(def, _) => return Some((*discriminated, def)),\n+                match discriminated.ty(body, tcx).ty.kind() {\n+                    ty::Adt(def, _) => return Some((*discriminated, *def)),\n \n                     // `Rvalue::Discriminant` is also used to get the active yield point for a\n                     // generator, but we do not need edge-specific effects in that case. This may"}, {"sha": "9d198ef2f7a05003aabadbaaeef8a35126526c4d", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n                 ProjectionElem::Field(..) => {\n                     let ty = place_base.ty(&self.body.local_decls, self.tcx).ty;\n                     if let ty::Adt(def, _) = ty.kind() {\n-                        if self.tcx.layout_scalar_valid_range(def.did)\n+                        if self.tcx.layout_scalar_valid_range(def.did())\n                             != (Bound::Unbounded, Bound::Unbounded)\n                         {\n                             let details = if is_mut_use {"}, {"sha": "8bc7f5e9ce2e0e467260c13ec16293e3e663935f", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -210,7 +210,7 @@ struct SuspensionPoint<'tcx> {\n \n struct TransformVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    state_adt_ref: &'tcx AdtDef,\n+    state_adt_ref: AdtDef<'tcx>,\n     state_substs: SubstsRef<'tcx>,\n \n     // The type of the discriminant in the generator struct\n@@ -243,11 +243,11 @@ impl<'tcx> TransformVisitor<'tcx> {\n         val: Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> impl Iterator<Item = Statement<'tcx>> {\n-        let kind = AggregateKind::Adt(self.state_adt_ref.did, idx, self.state_substs, None, None);\n-        assert_eq!(self.state_adt_ref.variants[idx].fields.len(), 1);\n+        let kind = AggregateKind::Adt(self.state_adt_ref.did(), idx, self.state_substs, None, None);\n+        assert_eq!(self.state_adt_ref.variant(idx).fields.len(), 1);\n         let ty = self\n             .tcx\n-            .type_of(self.state_adt_ref.variants[idx].fields[0].did)\n+            .type_of(self.state_adt_ref.variant(idx).fields[0].did)\n             .subst(self.tcx, self.state_substs);\n         expand_aggregate(\n             Place::return_place(),"}, {"sha": "d7fb706311434b8bcfd3a8509f2919fb26cf008e", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -124,7 +124,7 @@ fn is_needs_drop_and_init<'tcx>(\n             //\n             // If its projection *is* present in `MoveData`, then the field may have been moved\n             // from separate from its parent. Recurse.\n-            adt.variants.iter_enumerated().any(|(vid, variant)| {\n+            adt.variants().iter_enumerated().any(|(vid, variant)| {\n                 // Enums have multiple variants, which are discriminated with a `Downcast` projection.\n                 // Structs have a single variant, and don't use a `Downcast` projection.\n                 let mpi = if adt.is_enum() {"}, {"sha": "bf031b423c2e503e7841a6e335c6d1093798b548", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -760,10 +760,10 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     let statements = expand_aggregate(\n         Place::return_place(),\n-        adt_def.variants[variant_index].fields.iter().enumerate().map(|(idx, field_def)| {\n+        adt_def.variant(variant_index).fields.iter().enumerate().map(|(idx, field_def)| {\n             (Operand::Move(Place::from(Local::new(idx + 1))), field_def.ty(tcx, substs))\n         }),\n-        AggregateKind::Adt(adt_def.did, variant_index, substs, None, None),\n+        AggregateKind::Adt(adt_def.did(), variant_index, substs, None, None),\n         source_info,\n         tcx,\n     )"}, {"sha": "884c5fb765f421cbdc22dfdefba928b0d0e5963d", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -726,7 +726,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n                 );\n                 return StatementEquality::NotEqual;\n             }\n-            let variant_is_fieldless = adt.variants[variant_index].fields.is_empty();\n+            let variant_is_fieldless = adt.variant(variant_index).fields.is_empty();\n             if !variant_is_fieldless {\n                 trace!(\"NO: variant {:?} was not fieldless\", variant_index);\n                 return StatementEquality::NotEqual;"}, {"sha": "c777074df46411d1528bc6daba50c2bd6e5a4967", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 if self.tcx.has_attr(trait_of, sym::rustc_trivial_field_reads) {\n                     let trait_ref = self.tcx.impl_trait_ref(impl_of).unwrap();\n                     if let ty::Adt(adt_def, _) = trait_ref.self_ty().kind() {\n-                        if let Some(adt_def_id) = adt_def.did.as_local() {\n+                        if let Some(adt_def_id) = adt_def.did().as_local() {\n                             self.ignored_derived_traits\n                                 .entry(adt_def_id)\n                                 .or_default()\n@@ -297,7 +297,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 match item.kind {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def = self.tcx.adt_def(item.def_id);\n-                        self.repr_has_repr_c = def.repr.c();\n+                        self.repr_has_repr_c = def.repr().c();\n \n                         intravisit::walk_item(self, &item);\n                     }\n@@ -328,8 +328,8 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         self.repr_has_repr_c = had_repr_c;\n     }\n \n-    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &[hir::ExprField<'_>]) {\n-        if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n+    fn mark_as_used_if_union(&mut self, adt: ty::AdtDef<'tcx>, fields: &[hir::ExprField<'_>]) {\n+        if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did().is_local() {\n             for field in fields {\n                 let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n@@ -382,8 +382,8 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n             hir::ExprKind::Struct(ref qpath, ref fields, _) => {\n                 let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n-                if let ty::Adt(ref adt, _) = self.typeck_results().expr_ty(expr).kind() {\n-                    self.mark_as_used_if_union(adt, fields);\n+                if let ty::Adt(adt, _) = self.typeck_results().expr_ty(expr).kind() {\n+                    self.mark_as_used_if_union(*adt, fields);\n                 }\n             }\n             _ => (),"}, {"sha": "6316f3b845914e481acec254e899af541a5939ab", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -38,22 +38,22 @@ struct ExprVisitor<'tcx> {\n fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     let ty::Adt(def, substs) = *ty.kind() else { return ty };\n \n-    if def.variants.len() == 2 && !def.repr.c() && def.repr.int.is_none() {\n+    if def.variants().len() == 2 && !def.repr().c() && def.repr().int.is_none() {\n         let data_idx;\n \n         let one = VariantIdx::new(1);\n         let zero = VariantIdx::new(0);\n \n-        if def.variants[zero].fields.is_empty() {\n+        if def.variant(zero).fields.is_empty() {\n             data_idx = one;\n-        } else if def.variants[one].fields.is_empty() {\n+        } else if def.variant(one).fields.is_empty() {\n             data_idx = zero;\n         } else {\n             return ty;\n         }\n \n-        if def.variants[data_idx].fields.len() == 1 {\n-            return def.variants[data_idx].fields[0].ty(tcx, substs);\n+        if def.variant(data_idx).fields.len() == 1 {\n+            return def.variant(data_idx).fields[0].ty(tcx, substs);\n         }\n     }\n \n@@ -165,7 +165,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n                 Some(asm_ty_isize)\n             }\n-            ty::Adt(adt, substs) if adt.repr.simd() => {\n+            ty::Adt(adt, substs) if adt.repr().simd() => {\n                 let fields = &adt.non_enum_variant().fields;\n                 let elem_ty = fields[0].ty(self.tcx, substs);\n                 match elem_ty.kind() {"}, {"sha": "fdda77d01b3febd8d4e31bea13d516dd5561d1ab", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -9,6 +9,7 @@\n use rustc_ast::MacroDef;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -182,7 +183,7 @@ where\n         let tcx = self.def_id_visitor.tcx();\n         // InternalSubsts are not visited here because they are visited below in `super_visit_with`.\n         match *ty.kind() {\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..)\n+            ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), ..)\n             | ty::Foreign(def_id)\n             | ty::FnDef(def_id, ..)\n             | ty::Closure(def_id, ..)\n@@ -930,7 +931,7 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         &mut self,\n         use_ctxt: Span,        // syntax context of the field name at the use site\n         span: Span,            // span of the field pattern, e.g., `x: 0`\n-        def: &'tcx ty::AdtDef, // definition of the struct or enum\n+        def: ty::AdtDef<'tcx>, // definition of the struct or enum\n         field: &'tcx ty::FieldDef,\n         in_update_syntax: bool,\n     ) {\n@@ -941,7 +942,7 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         // definition of the field\n         let ident = Ident::new(kw::Empty, use_ctxt);\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(self.current_item);\n-        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, hir_id).1;\n+        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did(), hir_id).1;\n         if !field.vis.is_accessible_from(def_id, self.tcx) {\n             let label = if in_update_syntax {\n                 format!(\"field `{}` is private\", field.name)\n@@ -956,7 +957,7 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n                 \"field `{}` of {} `{}` is private\",\n                 field.name,\n                 def.variant_descr(),\n-                self.tcx.def_path_str(def.did)\n+                self.tcx.def_path_str(def.did())\n             )\n             .span_label(span, label)\n             .emit();"}, {"sha": "d071d66ffa6303149d3310576c75ef7266a8488c", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     Some(Data::RefData(Ref {\n                         kind: RefKind::Type,\n                         span,\n-                        ref_id: id_from_def_id(def.did),\n+                        ref_id: id_from_def_id(def.did()),\n                     }))\n                 }\n                 _ => {"}, {"sha": "c8fdf363f053eb24e81663977a63886908a24c34", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId};\n@@ -453,7 +454,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             }\n \n             // Mangle all nominal types as paths.\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs)\n+            ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n             | ty::Opaque(def_id, substs)\n             | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n@@ -684,7 +685,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                     ty::Adt(def, substs) => {\n                         let variant_idx =\n                             contents.variant.expect(\"destructed const of adt without variant idx\");\n-                        let variant_def = &def.variants[variant_idx];\n+                        let variant_def = &def.variant(variant_idx);\n \n                         self.push(\"V\");\n                         self = self.print_def_path(variant_def.def_id, substs)?;"}, {"sha": "a3d32acc6fb823ddf2e22f83b72d721020579c2c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -676,7 +676,7 @@ fn fundamental_ty_inner_tys<'tcx>(\n             match types.next() {\n                 None => {\n                     tcx.sess.span_err(\n-                        tcx.def_span(def.did),\n+                        tcx.def_span(def.did()),\n                         \"`#[fundamental]` requires at least one type parameter\",\n                     );\n \n@@ -729,7 +729,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n             InCrate::Remote => true,\n         },\n \n-        ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::Adt(def, _) => def_id_is_local(def.did(), in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n         ty::Opaque(..) => {\n             // This merits some explanation."}, {"sha": "28c596c4e53f0d9eaa537ef603a5118ad8ffbebe", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -813,7 +813,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     | ty::Foreign(did)\n                     | ty::FnDef(did, _)\n                     | ty::Generator(did, ..) => Some(did),\n-                    ty::Adt(def, _) => Some(def.did),\n+                    ty::Adt(def, _) => Some(def.did()),\n                     _ => None,\n                 };\n \n@@ -1467,7 +1467,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 ty::Bool => Some(0),\n                 ty::Char => Some(1),\n                 ty::Str => Some(2),\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::String, def.did) => Some(2),\n+                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::String, def.did()) => Some(2),\n                 ty::Int(..)\n                 | ty::Uint(..)\n                 | ty::Float(..)"}, {"sha": "d2b1fe2e0df9b8d17bc3db988d55711b28aae2a9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(def) = self_ty.ty_adt_def() {\n                 // We also want to be able to select self's original\n                 // signature with no type arguments resolved\n-                flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+                flags.push((sym::_Self, Some(self.tcx.type_of(def.did()).to_string())));\n             }\n \n             for param in generics.params.iter() {\n@@ -190,12 +190,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if let Some(def) = param_ty.ty_adt_def() {\n                         // We also want to be able to select the parameter's\n                         // original signature with no type arguments resolved\n-                        flags.push((name, Some(self.tcx.type_of(def.did).to_string())));\n+                        flags.push((name, Some(self.tcx.type_of(def.did()).to_string())));\n                     }\n                 }\n             }\n \n-            if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+            if let Some(true) = self_ty.ty_adt_def().map(|def| def.did().is_local()) {\n                 flags.push((sym::crate_local, None));\n             }\n \n@@ -214,7 +214,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let Some(def) = aty.ty_adt_def() {\n                     // We also want to be able to select the array's type's original\n                     // signature with no type arguments resolved\n-                    let type_string = self.tcx.type_of(def.did).to_string();\n+                    let type_string = self.tcx.type_of(def.did()).to_string();\n                     flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n \n                     let len ="}, {"sha": "b617067e66dddea6b1e38fa05075e92f0726c9c9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -2129,7 +2129,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if !is_upvar_tys_infer_tuple {\n                     let msg = format!(\"required because it appears within the type `{}`\", ty);\n                     match ty.kind() {\n-                        ty::Adt(def, _) => match self.tcx.opt_item_name(def.did) {\n+                        ty::Adt(def, _) => match self.tcx.opt_item_name(def.did()) {\n                             Some(ident) => err.span_note(ident.span, &msg),\n                             None => err.note(&msg),\n                         },"}, {"sha": "08308253ced5f15ef837f53e73bd1be6653318b1", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -43,7 +43,7 @@ pub fn can_type_implement_copy<'tcx>(\n         };\n \n         let mut infringing = Vec::new();\n-        for variant in &adt.variants {\n+        for variant in adt.variants() {\n             for field in &variant.fields {\n                 let ty = field.ty(tcx, substs);\n                 if ty.references_error() {\n@@ -56,7 +56,7 @@ pub fn can_type_implement_copy<'tcx>(\n                 // If it does not, then this field probably doesn't normalize\n                 // to begin with, and point to the bad field's span instead.\n                 let cause = if field\n-                    .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did))\n+                    .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n                     .has_param_types_or_consts()\n                 {\n                     cause.clone()"}, {"sha": "2df0d9f0f6fb223e0434c78e86a1d2542a516b66", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -112,7 +112,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::Adt(def, _) => {\n-            if Some(def.did) == tcx.lang_items().manually_drop() {\n+            if Some(def.did()) == tcx.lang_items().manually_drop() {\n                 // `ManuallyDrop` never has a dtor.\n                 true\n             } else {"}, {"sha": "67e3bf80486a822afd484c6e353881ad4e2c942e", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -12,7 +12,7 @@ use std::ops::ControlFlow;\n \n #[derive(Debug)]\n pub enum NonStructuralMatchTy<'tcx> {\n-    Adt(&'tcx AdtDef),\n+    Adt(AdtDef<'tcx>),\n     Param,\n     Dynamic,\n     Foreign,\n@@ -208,14 +208,14 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n             }\n         };\n \n-        if !self.seen.insert(adt_def.did) {\n+        if !self.seen.insert(adt_def.did()) {\n             debug!(\"Search already seen adt_def: {:?}\", adt_def);\n             return ControlFlow::CONTINUE;\n         }\n \n         if !self.type_marked_structural(ty) {\n             debug!(\"Search found ty: {:?}\", ty);\n-            return ControlFlow::Break(NonStructuralMatchTy::Adt(&adt_def));\n+            return ControlFlow::Break(NonStructuralMatchTy::Adt(adt_def));\n         }\n \n         // structural-match does not care about the"}, {"sha": "b4ed5b95b10473046e42665872548e633561f4d6", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n                 ty::Adt(def, substs) => {\n                     // WfNominalType\n-                    let obligations = self.nominal_obligations(def.did, substs);\n+                    let obligations = self.nominal_obligations(def.did(), substs);\n                     self.out.extend(obligations);\n                 }\n "}, {"sha": "9b85242e90a71ff5a8c6487c1f0314522dd6d284", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -166,13 +166,13 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AdtDatum<RustInterner<'tcx>>> {\n         let adt_def = adt_id.0;\n \n-        let bound_vars = bound_vars_for_item(self.interner.tcx, adt_def.did);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, adt_def.did());\n         let binders = binders_for(self.interner, bound_vars);\n \n-        let where_clauses = self.where_clauses_for(adt_def.did, bound_vars);\n+        let where_clauses = self.where_clauses_for(adt_def.did(), bound_vars);\n \n         let variants: Vec<_> = adt_def\n-            .variants\n+            .variants()\n             .iter()\n             .map(|variant| chalk_solve::rust_ir::AdtVariantDatum {\n                 fields: variant\n@@ -189,7 +189,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 chalk_solve::rust_ir::AdtDatumBound { variants, where_clauses },\n             ),\n             flags: chalk_solve::rust_ir::AdtFlags {\n-                upstream: !adt_def.did.is_local(),\n+                upstream: !adt_def.did().is_local(),\n                 fundamental: adt_def.is_fundamental(),\n                 phantom_data: adt_def.is_phantom_data(),\n             },\n@@ -209,9 +209,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i)).intern(self.interner);\n         let uint = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(i)).intern(self.interner);\n         Arc::new(chalk_solve::rust_ir::AdtRepr {\n-            c: adt_def.repr.c(),\n-            packed: adt_def.repr.packed(),\n-            int: adt_def.repr.int.map(|i| match i {\n+            c: adt_def.repr().c(),\n+            packed: adt_def.repr().packed(),\n+            int: adt_def.repr().int.map(|i| match i {\n                 attr::IntType::SignedInt(ty) => match ty {\n                     ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n                     ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n@@ -354,7 +354,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n             let provides = match (self_ty.kind(), chalk_ty) {\n-                (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did == id.0.did,\n+                (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did() == id.0.did(),\n                 (_, AssociatedType(_ty_id, ..)) => {\n                     // FIXME(chalk): See https://github.com/rust-lang/rust/pull/77152#discussion_r494484774\n                     false\n@@ -671,7 +671,7 @@ impl<'tcx> chalk_ir::UnificationDatabase<RustInterner<'tcx>> for RustIrDatabase<\n         &self,\n         adt_id: chalk_ir::AdtId<RustInterner<'tcx>>,\n     ) -> chalk_ir::Variances<RustInterner<'tcx>> {\n-        let variances = self.interner.tcx.variances_of(adt_id.0.did);\n+        let variances = self.interner.tcx.variances_of(adt_id.0.did());\n         chalk_ir::Variances::from_iter(\n             self.interner,\n             variances.iter().map(|v| v.lower_into(self.interner)),"}, {"sha": "df5df176186a16da84826e61cce915f3ecc9d04f", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -268,7 +268,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n \n         ty::Adt(def, substs) => {\n             let DtorckConstraint { dtorck_types, outlives, overflows } =\n-                tcx.at(span).adt_dtorck_constraint(def.did)?;\n+                tcx.at(span).adt_dtorck_constraint(def.did())?;\n             // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n             // there, but that needs some way to handle cycles.\n             constraints.dtorck_types.extend(dtorck_types.iter().map(|t| t.subst(tcx, substs)));"}, {"sha": "6195c712c58940b8dad828ebb2bd85ce1ff34c56", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -16,7 +16,7 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n     // parameter without a `Copy` bound, then we conservatively return that it\n     // needs drop.\n     let adt_has_dtor =\n-        |adt_def: &ty::AdtDef| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n+        |adt_def: ty::AdtDef<'tcx>| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n     let res =\n         drop_tys_helper(tcx, query.value, query.param_env, adt_has_dtor, false).next().is_some();\n \n@@ -78,7 +78,7 @@ impl<'tcx, F> NeedsDropTypes<'tcx, F> {\n \n impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n where\n-    F: Fn(&ty::AdtDef, SubstsRef<'tcx>) -> NeedsDropResult<I>,\n+    F: Fn(ty::AdtDef<'tcx>, SubstsRef<'tcx>) -> NeedsDropResult<I>,\n     I: Iterator<Item = Ty<'tcx>>,\n {\n     type Item = NeedsDropResult<Ty<'tcx>>;\n@@ -193,7 +193,7 @@ fn drop_tys_helper<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     param_env: rustc_middle::ty::ParamEnv<'tcx>,\n-    adt_has_dtor: impl Fn(&ty::AdtDef) -> Option<DtorType>,\n+    adt_has_dtor: impl Fn(ty::AdtDef<'tcx>) -> Option<DtorType>,\n     only_significant: bool,\n ) -> impl Iterator<Item = NeedsDropResult<Ty<'tcx>>> {\n     fn with_query_cache<'tcx>(\n@@ -203,7 +203,7 @@ fn drop_tys_helper<'tcx>(\n         iter.into_iter().try_fold(Vec::new(), |mut vec, subty| {\n             match subty.kind() {\n                 ty::Adt(adt_id, subst) => {\n-                    for subty in tcx.adt_drop_tys(adt_id.did)? {\n+                    for subty in tcx.adt_drop_tys(adt_id.did())? {\n                         vec.push(subty.subst(tcx, subst));\n                     }\n                 }\n@@ -213,7 +213,7 @@ fn drop_tys_helper<'tcx>(\n         })\n     }\n \n-    let adt_components = move |adt_def: &ty::AdtDef, substs: SubstsRef<'tcx>| {\n+    let adt_components = move |adt_def: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>| {\n         if adt_def.is_manually_drop() {\n             debug!(\"drop_tys_helper: `{:?}` is manually drop\", adt_def);\n             Ok(Vec::new())\n@@ -260,9 +260,9 @@ fn drop_tys_helper<'tcx>(\n \n fn adt_consider_insignificant_dtor<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-) -> impl Fn(&ty::AdtDef) -> Option<DtorType> + 'tcx {\n-    move |adt_def: &ty::AdtDef| {\n-        let is_marked_insig = tcx.has_attr(adt_def.did, sym::rustc_insignificant_dtor);\n+) -> impl Fn(ty::AdtDef<'tcx>) -> Option<DtorType> + 'tcx {\n+    move |adt_def: ty::AdtDef<'tcx>| {\n+        let is_marked_insig = tcx.has_attr(adt_def.did(), sym::rustc_insignificant_dtor);\n         if is_marked_insig {\n             // In some cases like `std::collections::HashMap` where the struct is a wrapper around\n             // a type that is a Drop type, and the wrapped type (eg: `hashbrown::HashMap`) lies\n@@ -281,11 +281,14 @@ fn adt_consider_insignificant_dtor<'tcx>(\n     }\n }\n \n-fn adt_drop_tys(tcx: TyCtxt<'_>, def_id: DefId) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n+fn adt_drop_tys<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> Result<&ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n     // This is for the \"adt_drop_tys\" query, that considers all `Drop` impls, therefore all dtors are\n     // significant.\n     let adt_has_dtor =\n-        |adt_def: &ty::AdtDef| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n+        |adt_def: ty::AdtDef<'tcx>| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n     // `tcx.type_of(def_id)` identical to `tcx.make_adt(def, identity_substs)`\n     drop_tys_helper(tcx, tcx.type_of(def_id), tcx.param_env(def_id), adt_has_dtor, false)\n         .collect::<Result<Vec<_>, _>>()"}, {"sha": "b8f3efe6462ead3ebc863767033ab19b1611f031", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -33,7 +33,7 @@ pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> R\n     // cleared when recursing to check A, but `shadow_seen` won't, so that we\n     // can catch cases of mutual recursion where A also contains B).\n     let mut seen: Vec<Ty<'_>> = Vec::new();\n-    let mut shadow_seen: Vec<&'tcx ty::AdtDef> = Vec::new();\n+    let mut shadow_seen: Vec<ty::AdtDef<'tcx>> = Vec::new();\n     let mut representable_cache = FxHashMap::default();\n     let mut force_result = false;\n     let r = is_type_structurally_recursive(\n@@ -63,7 +63,7 @@ fn are_inner_types_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n+    shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n     force_result: &mut bool,\n@@ -150,7 +150,7 @@ fn are_inner_types_recursive<'tcx>(\n                             .take(shadow_seen.len() - 1)\n                             .any(|seen_def| seen_def == def)\n                     {\n-                        let adt_def_id = def.did;\n+                        let adt_def_id = def.did();\n                         let raw_adt_ty = tcx.type_of(adt_def_id);\n                         debug!(\"are_inner_types_recursive: checking nested type: {:?}\", raw_adt_ty);\n \n@@ -236,7 +236,7 @@ fn are_inner_types_recursive<'tcx>(\n     }\n }\n \n-fn same_adt<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n+fn same_adt<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n     match *ty.kind() {\n         ty::Adt(ty_def, _) => ty_def == def,\n         _ => false,\n@@ -249,7 +249,7 @@ fn is_type_structurally_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n+    shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n     force_result: &mut bool,\n@@ -281,7 +281,7 @@ fn is_type_structurally_recursive_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n+    shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n     force_result: &mut bool,\n@@ -332,7 +332,7 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             // For structs and enums, track all previously seen types by pushing them\n             // onto the 'seen' stack.\n             seen.push(ty);\n-            shadow_seen.push(def);\n+            shadow_seen.push(*def);\n             let out = are_inner_types_recursive(\n                 tcx,\n                 sp,"}, {"sha": "44ef0a09a654bd2fff7ceea1e0fe9b4f834640d8", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -8,7 +8,7 @@ use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    adtdef: &ty::AdtDef,\n+    adtdef: ty::AdtDef<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Vec<Ty<'tcx>> {\n     use ty::TyKind::*;\n@@ -56,7 +56,7 @@ fn sized_constraint_for_ty<'tcx>(\n             })\n             .without_const()\n             .to_predicate(tcx);\n-            let predicates = tcx.predicates_of(adtdef.did).predicates;\n+            let predicates = tcx.predicates_of(adtdef.did()).predicates;\n             if predicates.iter().any(|(p, _)| *p == sized_predicate) { vec![] } else { vec![ty] }\n         }\n \n@@ -99,7 +99,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n     let def = tcx.adt_def(def_id);\n \n     let result = tcx.mk_type_list(\n-        def.variants\n+        def.variants()\n             .iter()\n             .flat_map(|v| v.fields.last())\n             .flat_map(|f| sized_constraint_for_ty(tcx, def, tcx.type_of(f.did))),\n@@ -454,7 +454,7 @@ pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n             // (a) It has no variants (i.e. an empty `enum`);\n             // (b) Each of its variants (a single one in the case of a `struct`) has at least\n             //     one uninhabited field.\n-            def.variants.iter().all(|var| {\n+            def.variants().iter().all(|var| {\n                 var.fields.iter().any(|field| {\n                     let ty = tcx.type_of(field.did).subst(tcx, substs);\n                     tcx.conservative_is_privately_uninhabited(param_env.and(ty))"}, {"sha": "144953caa4c3be3a4e5e7438bf3178632947cc82", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1788,9 +1788,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let ty::Adt(adt_def, _) = qself_ty.kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n-                    .variants\n+                    .variants()\n                     .iter()\n-                    .find(|vd| tcx.hygienic_eq(assoc_ident, vd.ident(tcx), adt_def.did));\n+                    .find(|vd| tcx.hygienic_eq(assoc_ident, vd.ident(tcx), adt_def.did()));\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span, None);\n@@ -1845,7 +1845,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     let adt_def = qself_ty.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggested_name) = find_best_match_for_name(\n                         &adt_def\n-                            .variants\n+                            .variants()\n                             .iter()\n                             .map(|variant| variant.name)\n                             .collect::<Vec<Symbol>>(),\n@@ -1865,7 +1865,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n \n-                    if let Some(sp) = tcx.hir().span_if_local(adt_def.did) {\n+                    if let Some(sp) = tcx.hir().span_if_local(adt_def.did()) {\n                         let sp = tcx.sess.source_map().guess_head_span(sp);\n                         err.span_label(sp, format!(\"variant `{}` not found here\", assoc_ident));\n                     }\n@@ -2154,7 +2154,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n                 let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                     debug_assert!(adt_def.is_enum());\n-                    (adt_def.did, last)\n+                    (adt_def.did(), last)\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n                     // Everything but the penultimate segment should have no\n                     // parameters at all."}, {"sha": "9016a8ffe9add582bc205c654db926165762a35a", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -269,7 +269,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n                     let arg_is_panic_info = match *inputs[0].kind() {\n                         ty::Ref(region, ty, mutbl) => match *ty.kind() {\n                             ty::Adt(ref adt, _) => {\n-                                adt.did == panic_info_did\n+                                adt.did() == panic_info_did\n                                     && mutbl == hir::Mutability::Not\n                                     && !region.is_static()\n                             }\n@@ -310,7 +310,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n                 let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].kind() {\n-                        ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n+                        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n                         _ => false,\n                     };\n \n@@ -345,7 +345,7 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n \n-    if def.repr.simd() {\n+    if def.repr().simd() {\n         check_simd(tcx, span, def_id);\n     }\n \n@@ -1086,7 +1086,7 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n             }\n \n             let len = if let ty::Array(_ty, c) = e.kind() {\n-                c.try_eval_usize(tcx, tcx.param_env(def.did))\n+                c.try_eval_usize(tcx, tcx.param_env(def.did()))\n             } else {\n                 Some(fields.len() as u64)\n             };\n@@ -1137,10 +1137,10 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     }\n }\n \n-pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n-    let repr = def.repr;\n+pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n+    let repr = def.repr();\n     if repr.packed() {\n-        for attr in tcx.get_attrs(def.did).iter() {\n+        for attr in tcx.get_attrs(def.did()).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess, attr) {\n                 if let attr::ReprPacked(pack) = r\n                     && let Some(repr_pack) = repr.pack\n@@ -1165,7 +1165,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n             )\n             .emit();\n         } else {\n-            if let Some(def_spans) = check_packed_inner(tcx, def.did, &mut vec![]) {\n+            if let Some(def_spans) = check_packed_inner(tcx, def.did(), &mut vec![]) {\n                 let mut err = struct_span_err!(\n                     tcx.sess,\n                     sp,\n@@ -1190,7 +1190,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n                             &if first {\n                                 format!(\n                                     \"`{}` contains a field of type `{}`\",\n-                                    tcx.type_of(def.did),\n+                                    tcx.type_of(def.did()),\n                                     ident\n                                 )\n                             } else {\n@@ -1214,16 +1214,16 @@ pub(super) fn check_packed_inner(\n ) -> Option<Vec<(DefId, Span)>> {\n     if let ty::Adt(def, substs) = tcx.type_of(def_id).kind() {\n         if def.is_struct() || def.is_union() {\n-            if def.repr.align.is_some() {\n-                return Some(vec![(def.did, DUMMY_SP)]);\n+            if def.repr().align.is_some() {\n+                return Some(vec![(def.did(), DUMMY_SP)]);\n             }\n \n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n                 if let ty::Adt(def, _) = field.ty(tcx, substs).kind() {\n-                    if !stack.contains(&def.did) {\n-                        if let Some(mut defs) = check_packed_inner(tcx, def.did, stack) {\n-                            defs.push((def.did, field.ident(tcx).span));\n+                    if !stack.contains(&def.did()) {\n+                        if let Some(mut defs) = check_packed_inner(tcx, def.did(), stack) {\n+                            defs.push((def.did(), field.ident(tcx).span));\n                             return Some(defs);\n                         }\n                     }\n@@ -1236,8 +1236,8 @@ pub(super) fn check_packed_inner(\n     None\n }\n \n-pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty::AdtDef) {\n-    if !adt.repr.transparent() {\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtDef<'tcx>) {\n+    if !adt.repr().transparent() {\n         return;\n     }\n     let sp = tcx.sess.source_map().guess_head_span(sp);\n@@ -1252,9 +1252,9 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty\n         .emit();\n     }\n \n-    if adt.variants.len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did);\n-        if adt.variants.is_empty() {\n+    if adt.variants().len() != 1 {\n+        bad_variant_count(tcx, adt, sp, adt.did());\n+        if adt.variants().is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n         }\n@@ -1317,7 +1317,7 @@ fn check_enum<'tcx>(\n         }\n     }\n \n-    let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n+    let repr_type_ty = def.repr().discr_type().to_ty(tcx);\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n         if !tcx.features().repr128 {\n             feature_err(\n@@ -1336,7 +1336,7 @@ fn check_enum<'tcx>(\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n+    if tcx.adt_def(def_id).repr().int.is_none() && tcx.features().arbitrary_enum_discriminant {\n         let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n \n         let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n@@ -1355,7 +1355,7 @@ fn check_enum<'tcx>(\n     for ((_, discr), v) in iter::zip(def.discriminants(tcx), vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_did = def.variants[VariantIdx::new(i)].def_id;\n+            let variant_did = def.variant(VariantIdx::new(i)).def_id;\n             let variant_i_hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.expect_local());\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {"}, {"sha": "58e5c9315c30c7c706702ef4135253f8d3f73c79", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -299,15 +299,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     if e.hir_id == id {\n                         if let Some(span) = expr.span.find_ancestor_inside(block_span) {\n-                            let return_suggestions =\n-                                if self.tcx.is_diagnostic_item(sym::Result, expected_adt.did) {\n-                                    vec![\"Ok(())\".to_string()]\n-                                } else if self.tcx.is_diagnostic_item(sym::Option, expected_adt.did)\n-                                {\n-                                    vec![\"None\".to_string(), \"Some(())\".to_string()]\n-                                } else {\n-                                    return;\n-                                };\n+                            let return_suggestions = if self\n+                                .tcx\n+                                .is_diagnostic_item(sym::Result, expected_adt.did())\n+                            {\n+                                vec![\"Ok(())\".to_string()]\n+                            } else if self.tcx.is_diagnostic_item(sym::Option, expected_adt.did()) {\n+                                vec![\"None\".to_string(), \"Some(())\".to_string()]\n+                            } else {\n+                                return;\n+                            };\n                             if let Some(indent) =\n                                 self.tcx.sess.source_map().indentation_before(span.shrink_to_lo())\n                             {\n@@ -333,7 +334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             let compatible_variants: Vec<String> = expected_adt\n-                .variants\n+                .variants()\n                 .iter()\n                 .filter(|variant| variant.fields.len() == 1)\n                 .filter_map(|variant| {\n@@ -378,7 +379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.multipart_suggestions(\n                         &format!(\n                             \"try wrapping the expression in a variant of `{}`\",\n-                            self.tcx.def_path_str(expected_adt.did)\n+                            self.tcx.def_path_str(expected_adt.did())\n                         ),\n                         compatible_variants.into_iter().map(|variant| {\n                             vec!["}, {"sha": "1849ece9f76d9aa1df6b11acfaf17fd5d2c1f8b7", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -40,13 +40,13 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n                 tcx,\n                 drop_impl_did.expect_local(),\n                 dtor_self_type,\n-                adt_def.did,\n+                adt_def.did(),\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n                 dtor_predicates,\n-                adt_def.did.expect_local(),\n+                adt_def.did().expect_local(),\n                 self_to_impl_substs,\n             )\n         }"}, {"sha": "d944bb76241773dcc11e7b511f702fa8b2cc252f", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1333,7 +1333,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Prohibit struct expressions when non-exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n-        if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n+        if !adt.did().is_local() && variant.is_field_list_non_exhaustive() {\n             self.tcx\n                 .sess\n                 .emit_err(StructExprNonExhaustive { span: expr.span, what: adt.variant_descr() });\n@@ -1863,7 +1863,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\", base_t);\n                     let (ident, def_scope) =\n-                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did(), self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n                     if let Some(index) = fields\n                         .iter()\n@@ -1882,7 +1882,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span, None);\n                             return field_ty;\n                         }\n-                        private_candidate = Some((adjustments, base_def.did, field_ty));\n+                        private_candidate = Some((adjustments, base_def.did(), field_ty));\n                     }\n                 }\n                 ty::Tuple(tys) => {\n@@ -2103,9 +2103,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             if let ty::RawPtr(ty_and_mut) = expr_t.kind() {\n                 if let ty::Adt(adt_def, _) = ty_and_mut.ty.kind() {\n-                    if adt_def.variants.len() == 1\n+                    if adt_def.variants().len() == 1\n                         && adt_def\n-                            .variants\n+                            .variants()\n                             .iter()\n                             .next()\n                             .unwrap()\n@@ -2154,7 +2154,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_fields_on_recordish(\n         &self,\n         err: &mut Diagnostic,\n-        def: &'tcx ty::AdtDef,\n+        def: ty::AdtDef<'tcx>,\n         field: Ident,\n         access_span: Span,\n     ) {"}, {"sha": "ed70b85e3f1478ad14a8c0c2366bcc55636d7661", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1166,7 +1166,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Some(self_ty) = self_ty =>\n             {\n                 let adt_def = self_ty.ty_adt_def().unwrap();\n-                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did, self_ty });\n+                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty });\n                 is_alias_variant_ctor = true;\n             }\n             Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {"}, {"sha": "d336573c254f8693f4475690e527469a0d30a68e", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -577,13 +577,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return None;\n             }\n             Res::Def(DefKind::Variant, _) => match ty.kind() {\n-                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did, substs)),\n+                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did(), substs)),\n                 _ => bug!(\"unexpected type: {:?}\", ty),\n             },\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n             | Res::SelfTy { .. } => match ty.kind() {\n                 ty::Adt(adt, substs) if !adt.is_enum() => {\n-                    Some((adt.non_enum_variant(), adt.did, substs))\n+                    Some((adt.non_enum_variant(), adt.did(), substs))\n                 }\n                 _ => None,\n             },"}, {"sha": "67d61668b6d8542cab03059ce5897ae15d5912bd", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pin_box_found = self.tcx.mk_lang_item(box_found, LangItem::Pin).unwrap();\n         let pin_found = self.tcx.mk_lang_item(found, LangItem::Pin).unwrap();\n         match expected.kind() {\n-            ty::Adt(def, _) if Some(def.did) == pin_did => {\n+            ty::Adt(def, _) if Some(def.did()) == pin_did => {\n                 if self.can_coerce(pin_box_found, expected) {\n                     debug!(\"can coerce {:?} to {:?}, suggesting Box::pin\", pin_box_found, expected);\n                     match found.kind() {"}, {"sha": "48d241700727ad39801732d2f8a310aef85a7bf2", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -496,7 +496,7 @@ pub fn check_must_not_suspend_ty<'tcx>(\n             let descr_pre = &format!(\"{}boxed \", data.descr_pre);\n             check_must_not_suspend_ty(fcx, boxed_ty, hir_id, SuspendCheckData { descr_pre, ..data })\n         }\n-        ty::Adt(def, _) => check_must_not_suspend_def(fcx.tcx, def.did, hir_id, data),\n+        ty::Adt(def, _) => check_must_not_suspend_def(fcx.tcx, def.did(), hir_id, data),\n         // FIXME: support adding the attribute to TAITs\n         ty::Opaque(def, _) => {\n             let mut has_emitted = false;"}, {"sha": "1ca9c1920961a0ceabfa99834aeba39f2c4185a0", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -589,9 +589,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let ty::Adt(adt_def, _) = self_ty.kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n-                    .variants\n+                    .variants()\n                     .iter()\n-                    .find(|vd| tcx.hygienic_eq(method_name, vd.ident(tcx), adt_def.did));\n+                    .find(|vd| tcx.hygienic_eq(method_name, vd.ident(tcx), adt_def.did()));\n                 if let Some(variant_def) = variant_def {\n                     // Braced variants generate unusable names in value namespace (reserved for\n                     // possible future use), so variants resolved as associated items may refer to"}, {"sha": "dbc4adfb0a3cf7df71fab58b57b96ff0df5bb077", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -297,7 +297,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // for a \"<\" in `self_ty_name`.\n             if !self_ty_name.contains('<') {\n                 if let Adt(def, _) = self_ty.kind() {\n-                    let generics = self.tcx.generics_of(def.did);\n+                    let generics = self.tcx.generics_of(def.did());\n                     if !generics.params.is_empty() {\n                         let counts = generics.own_counts();\n                         self_ty_name += &format!("}, {"sha": "e79085fdad28dda5ae5fd594631a716e31bea2b6", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -640,7 +640,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n-                self.assemble_inherent_impl_candidates_for_type(def.did);\n+                self.assemble_inherent_impl_candidates_for_type(def.did());\n             }\n             ty::Foreign(did) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);"}, {"sha": "c024f5b42e4a10092527d011cf4fdee696c1993a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let candidate_found = autoderef.any(|(ty, _)| {\n                                     if let ty::Adt(adt_deref, _) = ty.kind() {\n                                         self.tcx\n-                                            .inherent_impls(adt_deref.did)\n+                                            .inherent_impls(adt_deref.did())\n                                             .iter()\n                                             .filter_map(|def_id| {\n                                                 self.associated_value(*def_id, item_name)\n@@ -470,7 +470,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if let Some(def) = actual.ty_adt_def() {\n-                    if let Some(full_sp) = tcx.hir().span_if_local(def.did) {\n+                    if let Some(full_sp) = tcx.hir().span_if_local(def.did()) {\n                         let def_sp = tcx.sess.source_map().guess_head_span(full_sp);\n                         err.span_label(\n                             def_sp,\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                 .get(self.tcx.hir().local_def_id_to_hir_id(did)),\n                                         )\n                                     }\n-                                    ty::Adt(def, _) => def.did.as_local().map(|def_id| {\n+                                    ty::Adt(def, _) => def.did().as_local().map(|def_id| {\n                                         self.tcx\n                                             .hir()\n                                             .get(self.tcx.hir().local_def_id_to_hir_id(def_id))\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                         match &self_ty.kind() {\n                             // Point at the type that couldn't satisfy the bound.\n-                            ty::Adt(def, _) => bound_spans.push((def_span(def.did), msg)),\n+                            ty::Adt(def, _) => bound_spans.push((def_span(def.did()), msg)),\n                             // Point at the trait object that couldn't satisfy the bound.\n                             ty::Dynamic(preds, _) => {\n                                 for pred in preds.iter() {\n@@ -885,10 +885,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ty.is_str()\n                                     || matches!(\n                                         ty.kind(),\n-                                        ty::Adt(adt, _) if self.tcx.is_diagnostic_item(sym::String, adt.did)\n+                                        ty::Adt(adt, _) if self.tcx.is_diagnostic_item(sym::String, adt.did())\n                                     )\n                             }\n-                            ty::Adt(adt, _) => self.tcx.is_diagnostic_item(sym::String, adt.did),\n+                            ty::Adt(adt, _) => self.tcx.is_diagnostic_item(sym::String, adt.did()),\n                             _ => false,\n                         };\n                         if is_string_or_ref_str && item_name.name == sym::iter {\n@@ -903,7 +903,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let ty::Adt(adt, _) = rcvr_ty.kind() {\n                             let mut inherent_impls_candidate = self\n                                 .tcx\n-                                .inherent_impls(adt.did)\n+                                .inherent_impls(adt.did())\n                                 .iter()\n                                 .copied()\n                                 .filter(|def_id| {\n@@ -1046,7 +1046,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if unsatisfied_predicates.is_empty() && actual.is_enum() {\n                     let adt_def = actual.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggestion) = lev_distance::find_best_match_for_name(\n-                        &adt_def.variants.iter().map(|s| s.name).collect::<Vec<_>>(),\n+                        &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                         item_name.name,\n                         None,\n                     ) {\n@@ -1173,7 +1173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_local_types_needing_impls =\n             errors.iter().all(|e| match e.obligation.predicate.kind().skip_binder() {\n                 ty::PredicateKind::Trait(pred) => match pred.self_ty().kind() {\n-                    ty::Adt(def, _) => def.did.is_local(),\n+                    ty::Adt(def, _) => def.did().is_local(),\n                     _ => false,\n                 },\n                 _ => false,\n@@ -1189,7 +1189,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let def_ids = preds\n             .iter()\n             .filter_map(|pred| match pred.self_ty().kind() {\n-                ty::Adt(def, _) => Some(def.did),\n+                ty::Adt(def, _) => Some(def.did()),\n                 _ => None,\n             })\n             .collect::<FxHashSet<_>>();\n@@ -1207,7 +1207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match pred.self_ty().kind() {\n                 ty::Adt(def, _) => {\n                     spans.push_span_label(\n-                        sm.guess_head_span(self.tcx.def_span(def.did)),\n+                        sm.guess_head_span(self.tcx.def_span(def.did())),\n                         format!(\"must implement `{}`\", pred.trait_ref.print_only_trait_path()),\n                     );\n                 }\n@@ -1255,7 +1255,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (pred, _, _) in unsatisfied_predicates {\n             let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n-                Some(adt) if adt.did.is_local() => adt,\n+                Some(adt) if adt.did().is_local() => adt,\n                 _ => continue,\n             };\n             if let Some(diagnostic_name) = self.tcx.get_diagnostic_name(trait_pred.def_id()) {\n@@ -1273,7 +1273,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if can_derive {\n                     let self_name = trait_pred.self_ty().to_string();\n-                    let self_span = self.tcx.def_span(adt.did);\n+                    let self_span = self.tcx.def_span(adt.did());\n                     if let Some(poly_trait_ref) = pred.to_opt_poly_trait_pred() {\n                         for super_trait in supertraits(self.tcx, poly_trait_ref.to_poly_trait_ref())\n                         {\n@@ -1336,7 +1336,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Print out the type for use in value namespace.\n     fn ty_to_value_string(&self, ty: Ty<'tcx>) -> String {\n         match ty.kind() {\n-            ty::Adt(def, substs) => format!(\"{}\", ty::Instance::new(def.did, substs)),\n+            ty::Adt(def, substs) => format!(\"{}\", ty::Instance::new(def.did(), substs)),\n             _ => self.ty_to_string(ty),\n         }\n     }\n@@ -1930,7 +1930,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         fn is_local(ty: Ty<'_>) -> bool {\n             match ty.kind() {\n-                ty::Adt(def, _) => def.did.is_local(),\n+                ty::Adt(def, _) => def.did().is_local(),\n                 ty::Foreign(did) => did.is_local(),\n                 ty::Dynamic(tr, ..) => tr.principal().map_or(false, |d| d.def_id().is_local()),\n                 ty::Param(_) => true,"}, {"sha": "31cc3fa2ac648c59919365244ac91aa6928f82eb", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -822,13 +822,13 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n }\n \n /// Emit an error when encountering two or more variants in a transparent enum.\n-fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, did: DefId) {\n+fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>, sp: Span, did: DefId) {\n     let variant_spans: Vec<_> = adt\n-        .variants\n+        .variants()\n         .iter()\n         .map(|variant| tcx.hir().span_if_local(variant.def_id).unwrap())\n         .collect();\n-    let msg = format!(\"needs exactly one variant, but has {}\", adt.variants.len(),);\n+    let msg = format!(\"needs exactly one variant, but has {}\", adt.variants().len(),);\n     let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n     err.span_label(sp, &msg);\n     if let [start @ .., end] = &*variant_spans {\n@@ -844,7 +844,7 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, d\n /// enum.\n fn bad_non_zero_sized_fields<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    adt: &'tcx ty::AdtDef,\n+    adt: ty::AdtDef<'tcx>,\n     field_count: usize,\n     field_spans: impl Iterator<Item = Span>,\n     sp: Span,"}, {"sha": "af154e62a1e1629a89adc243e96f6c46ce222fd2", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let string_type = self.tcx.get_diagnostic_item(sym::String);\n         let is_std_string = |ty: Ty<'tcx>| match ty.ty_adt_def() {\n-            Some(ty_def) => Some(ty_def.did) == string_type,\n+            Some(ty_def) => Some(ty_def.did()) == string_type,\n             None => false,\n         };\n "}, {"sha": "26a1d0c473c60309b1cfc0da669ea016f8829146", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -850,7 +850,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     _ => {\n                         let (type_def_id, item_def_id) = match pat_ty.kind() {\n                             Adt(def, _) => match res {\n-                                Res::Def(DefKind::Const, def_id) => (Some(def.did), Some(def_id)),\n+                                Res::Def(DefKind::Const, def_id) => (Some(def.did()), Some(def_id)),\n                                 _ => (None, None),\n                             },\n                             _ => (None, None),\n@@ -1286,7 +1286,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Require `..` if struct has non_exhaustive attribute.\n-        let non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+        let non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did().is_local();\n         if non_exhaustive && !has_rest_pat {\n             self.error_foreign_non_exhaustive_spat(pat, adt.variant_descr(), fields.is_empty());\n         }\n@@ -2042,8 +2042,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .find_map(|(ty, _)| {\n                         match ty.kind() {\n                             ty::Adt(adt_def, _)\n-                                if self.tcx.is_diagnostic_item(sym::Option, adt_def.did)\n-                                    || self.tcx.is_diagnostic_item(sym::Result, adt_def.did) =>\n+                                if self.tcx.is_diagnostic_item(sym::Option, adt_def.did())\n+                                    || self.tcx.is_diagnostic_item(sym::Result, adt_def.did()) =>\n                             {\n                                 // Slicing won't work here, but `.as_deref()` might (issue #91328).\n                                 err.span_suggestion("}, {"sha": "42eec1776495e7ecd72c5b05cc14f20d40ecde07", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1,6 +1,7 @@\n use crate::check::method::MethodCallee;\n use crate::check::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_ast as ast;\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -125,7 +126,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ) = index_expr.kind\n         {\n             match adjusted_ty.kind() {\n-                ty::Adt(ty::AdtDef { did, .. }, _)\n+                ty::Adt(ty::AdtDef(Interned(ty::AdtDefData { did, .. }, _)), _)\n                     if self.tcx.is_diagnostic_item(sym::Vec, *did) =>\n                 {\n                     return self.negative_index(adjusted_ty, index_expr.span, base_expr);"}, {"sha": "1a94b7261f7abab1bfe39005782313e94ae8f5b6", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1413,7 +1413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Adt(def, substs) => {\n                 // Multi-varaint enums are captured in entirety,\n                 // which would've been handled in the case of single empty slice in `captured_by_move_projs`.\n-                assert_eq!(def.variants.len(), 1);\n+                assert_eq!(def.variants().len(), 1);\n \n                 // Only Field projections can be applied to a non-box Adt.\n                 assert!(\n@@ -1422,7 +1422,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ProjectionKind::Field(..)\n                     ))\n                 );\n-                def.variants.get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n+                def.variants().get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n                     |(i, field)| {\n                         let paths_using_field = captured_by_move_projs\n                             .iter()\n@@ -1649,7 +1649,7 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         // Return true for fields of packed structs, unless those fields have alignment 1.\n         match p.kind {\n             ProjectionKind::Field(..) => match ty.kind() {\n-                ty::Adt(def, _) if def.repr.packed() => {\n+                ty::Adt(def, _) if def.repr().packed() => {\n                     // We erase regions here because they cannot be hashed\n                     match tcx.layout_of(param_env.and(tcx.erase_regions(p.ty))) {\n                         Ok(layout) if layout.align.abi.bytes() == 1 => {"}, {"sha": "30603d6f487940434d49f38dc6f4235bf47ef1b1", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -995,7 +995,7 @@ fn check_type_defn<'tcx, F>(\n {\n     for_item(tcx, item).with_fcx(|fcx| {\n         let variants = lookup_fields(fcx);\n-        let packed = tcx.adt_def(item.def_id).repr.packed();\n+        let packed = tcx.adt_def(item.def_id).repr().packed();\n \n         for variant in &variants {\n             // For DST, or when drop needs to copy things around, all"}, {"sha": "ef59df0dc88f3556341be2ee33d131a481aa2989", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -154,8 +154,8 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                 if def_a.is_struct() && def_b.is_struct() =>\n             {\n                 if def_a != def_b {\n-                    let source_path = tcx.def_path_str(def_a.did);\n-                    let target_path = tcx.def_path_str(def_b.did);\n+                    let source_path = tcx.def_path_str(def_a.did());\n+                    let target_path = tcx.def_path_str(def_b.did());\n \n                     create_err(&format!(\n                         \"the trait `DispatchFromDyn` may only be implemented \\\n@@ -168,7 +168,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                     return;\n                 }\n \n-                if def_a.repr.c() || def_a.repr.packed() {\n+                if def_a.repr().c() || def_a.repr().packed() {\n                     create_err(\n                         \"structs implementing `DispatchFromDyn` may not have \\\n                              `#[repr(packed)]` or `#[repr(C)]`\",\n@@ -353,8 +353,8 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 if def_a.is_struct() && def_b.is_struct() =>\n             {\n                 if def_a != def_b {\n-                    let source_path = tcx.def_path_str(def_a.did);\n-                    let target_path = tcx.def_path_str(def_b.did);\n+                    let source_path = tcx.def_path_str(def_a.did());\n+                    let target_path = tcx.def_path_str(def_b.did());\n                     struct_span_err!(\n                         tcx.sess,\n                         span,"}, {"sha": "59c252dec05056b8b57bb9e4a2d147ccdafaa5cb", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n         let lang_items = self.tcx.lang_items();\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n-                self.check_def_id(item, def.did);\n+                self.check_def_id(item, def.did());\n             }\n             ty::Foreign(did) => {\n                 self.check_def_id(item, did);"}, {"sha": "a1bcd141e10634c3ec9abe59acadfd893ce010df", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -97,7 +97,7 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n     if tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n         let self_ty = trait_ref.self_ty();\n         let opt_self_def_id = match *self_ty.kind() {\n-            ty::Adt(self_def, _) => Some(self_def.did),\n+            ty::Adt(self_def, _) => Some(self_def.did()),\n             ty::Foreign(did) => Some(did),\n             _ => None,\n         };\n@@ -181,7 +181,7 @@ fn emit_orphan_check_error<'tcx>(\n                     // That way if we had `Vec<MyType>`, we will properly attribute the\n                     // problem to `Vec<T>` and avoid confusing the user if they were to see\n                     // `MyType` in the error.\n-                    ty::Adt(def, _) => tcx.mk_adt(def, ty::List::empty()),\n+                    ty::Adt(def, _) => tcx.mk_adt(*def, ty::List::empty()),\n                     _ => ty,\n                 };\n                 let this = \"this\".to_string();\n@@ -340,7 +340,7 @@ fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDef\n         assert_eq!(trait_ref.substs.len(), 1);\n         let self_ty = trait_ref.self_ty();\n         let (self_type_did, substs) = match self_ty.kind() {\n-            ty::Adt(def, substs) => (def.did, substs),\n+            ty::Adt(def, substs) => (def.did(), substs),\n             _ => {\n                 // FIXME: should also lint for stuff like `&i32` but\n                 // considering that auto traits are unstable, that\n@@ -443,7 +443,7 @@ fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty:\n                     // by only visiting each `DefId` once.\n                     //\n                     // This will be is incorrect in subtle cases, but I don't care :)\n-                    if self.seen.insert(def.did) {\n+                    if self.seen.insert(def.did()) {\n                         for ty in def.all_fields().map(|field| field.ty(tcx, substs)) {\n                             ty.visit_with(self)?;\n                         }\n@@ -457,7 +457,7 @@ fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty:\n     }\n \n     let self_ty_root = match self_ty.kind() {\n-        ty::Adt(def, _) => tcx.mk_adt(def, InternalSubsts::identity_for_item(tcx, def.did)),\n+        ty::Adt(def, _) => tcx.mk_adt(*def, InternalSubsts::identity_for_item(tcx, def.did())),\n         _ => unimplemented!(\"unexpected self ty {:?}\", self_ty),\n     };\n "}, {"sha": "cabdcdc214bbf586abc001262f7e8273e717c715", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -917,7 +917,7 @@ fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n \n fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n     let def = tcx.adt_def(def_id);\n-    let repr_type = def.repr.discr_type();\n+    let repr_type = def.repr().discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<Discr<'_>>;\n \n@@ -1012,7 +1012,7 @@ fn convert_variant(\n     )\n }\n \n-fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n+fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::AdtDef<'tcx> {\n     use rustc_hir::*;\n \n     let def_id = def_id.expect_local();"}, {"sha": "3247a292242a34a3740628e533970507d04e5940", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -464,7 +464,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n                 Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => tcx\n                     .adt_def(tcx.hir().get_parent_item(hir_id))\n-                    .repr\n+                    .repr()\n                     .discr_type()\n                     .to_ty(tcx),\n "}, {"sha": "be4958ea062763424156f4f8a24ee52417fad10b", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -855,7 +855,7 @@ fn is_multivariant_adt(ty: Ty<'_>) -> bool {\n             }\n             AdtKind::Enum => def.is_variant_list_non_exhaustive(),\n         };\n-        def.variants.len() > 1 || (!def.did.is_local() && is_non_exhaustive)\n+        def.variants().len() > 1 || (!def.did().is_local() && is_non_exhaustive)\n     } else {\n         false\n     }"}, {"sha": "1464420090bdadc61fe9b15e5b319b144996dc35", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> McResult<usize> {\n         let ty = self.typeck_results.node_type(pat_hir_id);\n         match ty.kind() {\n-            ty::Adt(adt_def, _) => Ok(adt_def.variants[variant_index].fields.len()),\n+            ty::Adt(adt_def, _) => Ok(adt_def.variant(variant_index).fields.len()),\n             _ => {\n                 self.tcx()\n                     .sess"}, {"sha": "00163c72974ad93482149675b88121ffc1ccc2e8", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -157,7 +157,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // `['b => 'a, U => T]` and thus get the requirement that `T:\n                 // 'a` holds for `Foo`.\n                 debug!(\"Adt\");\n-                if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n+                if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did()) {\n                     for (unsubstituted_predicate, &span) in unsubstituted_predicates {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n                         // example above.  So apply the substitution to\n@@ -178,7 +178,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // let _: () = substs.region_at(0);\n                 check_explicit_predicates(\n                     tcx,\n-                    def.did,\n+                    def.did(),\n                     substs,\n                     required_predicates,\n                     explicit_map,"}, {"sha": "76755de4964e1435bf1e4b6335519b953034ac5c", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::Adt(def, substs) => {\n-                self.add_constraints_from_substs(current, def.did, substs, variance);\n+                self.add_constraints_from_substs(current, def.did(), substs, variance);\n             }\n \n             ty::Projection(ref data) => {"}, {"sha": "353df68443f6bafe0bc1e7bde74a464e8f714131", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -244,7 +244,7 @@ fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n     clean::Enum {\n         generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         variants_stripped: false,\n-        variants: cx.tcx.adt_def(did).variants.iter().map(|v| v.clean(cx)).collect(),\n+        variants: cx.tcx.adt_def(did).variants().iter().map(|v| v.clean(cx)).collect(),\n     }\n }\n "}, {"sha": "52b556ae4b1db729962e9044169e8b7939da0c6c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1551,7 +1551,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 })\n             }\n             ty::Adt(def, substs) => {\n-                let did = def.did;\n+                let did = def.did();\n                 let kind = match def.adt_kind() {\n                     AdtKind::Struct => ItemType::Struct,\n                     AdtKind::Union => ItemType::Union,"}, {"sha": "e6c7745c6e10f16399ecd49ca742cdab27d2c59c", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1765,7 +1765,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n                     };\n \n                     for (index, layout) in variants.iter_enumerated() {\n-                        let name = adt.variants[index].name;\n+                        let name = adt.variant(index).name;\n                         write!(w, \"<li><code>{name}</code>: \", name = name);\n                         write_size_of_layout(w, *layout, tag_size);\n                         writeln!(w, \"</li>\");"}, {"sha": "e1ae0a19ef977b025808e3eb67274fe1f3b79148", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n-use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n+use rustc_data_structures::{fx::FxHashMap, intern::Interned, stable_set::FxHashSet};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::def::{\n     DefKind,\n@@ -439,7 +439,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             Err(ResolutionFailure::NotResolved {\n                                 item_id,\n                                 module_id,\n-                                partial_res: Some(Res::Def(DefKind::Enum, def.did)),\n+                                partial_res: Some(Res::Def(DefKind::Enum, def.did())),\n                                 unresolved: variant_field_name.to_string().into(),\n                             }\n                             .into())\n@@ -686,7 +686,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ty::FnDef(..) => panic!(\"type alias to a function definition\"),\n             ty::FnPtr(_) => Res::Primitive(Fn),\n             ty::Never => Res::Primitive(Never),\n-            ty::Adt(&ty::AdtDef { did, .. }, _) | ty::Foreign(did) => {\n+            ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) | ty::Foreign(did) => {\n                 Res::Def(self.cx.tcx.def_kind(did), did)\n             }\n             ty::Projection(_)\n@@ -779,7 +779,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 if ns == TypeNS && def_kind == DefKind::Enum {\n                     match tcx.type_of(did).kind() {\n                         ty::Adt(adt_def, _) => {\n-                            for variant in &adt_def.variants {\n+                            for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n                                     return Some((\n                                         root_res,\n@@ -1002,8 +1002,8 @@ fn trait_impls_for<'a>(\n             let saw_impl = impl_type == ty\n                 || match (impl_type.kind(), ty.kind()) {\n                     (ty::Adt(impl_def, _), ty::Adt(ty_def, _)) => {\n-                        debug!(\"impl def_id: {:?}, ty def_id: {:?}\", impl_def.did, ty_def.did);\n-                        impl_def.did == ty_def.did\n+                        debug!(\"impl def_id: {:?}, ty def_id: {:?}\", impl_def.did(), ty_def.did());\n+                        impl_def.did() == ty_def.did()\n                     }\n                     _ => false,\n                 };"}, {"sha": "4592ca7274888dd97b13552ea01ac9c75dd8bf50", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -149,7 +149,7 @@ impl LateLintPass<'_> for AwaitHolding {\n fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n-            if is_mutex_guard(cx, adt.did) {\n+            if is_mutex_guard(cx, adt.did()) {\n                 span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_LOCK,\n@@ -167,7 +167,7 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n                     },\n                 );\n             }\n-            if is_refcell_ref(cx, adt.did) {\n+            if is_refcell_ref(cx, adt.did()) {\n                 span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_REFCELL_REF,"}, {"sha": "df780747a0c759d5857bb924db6c99a66ddbf00f", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -55,7 +56,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n                 ty::Str => {\n                     return Some(span);\n                 },\n-                ty::Adt(&ty::AdtDef { did, .. }, _) => {\n+                ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) => {\n                     if ctx.tcx.is_diagnostic_item(sym::String, did) {\n                         return Some(span);\n                     }"}, {"sha": "421bd6f53f71b4a78f37788f2a16b61301c76a44", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -116,15 +116,15 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n                 && let Res::Def(DefKind::Ctor(..), id) = cx.qpath_res(p, cast_expr.hir_id)\n             {\n                 let i = def.variant_index_with_ctor_id(id);\n-                let variant = &def.variants[i];\n-                let nbits = utils::enum_value_nbits(get_discriminant_value(cx.tcx, def, i));\n+                let variant = def.variant(i);\n+                let nbits = utils::enum_value_nbits(get_discriminant_value(cx.tcx, *def, i));\n                 (nbits, Some(variant))\n             } else {\n-                (utils::enum_ty_to_nbits(def, cx.tcx), None)\n+                (utils::enum_ty_to_nbits(*def, cx.tcx), None)\n             };\n             let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n \n-            let cast_from_ptr_size = def.repr.int.map_or(true, |ty| {\n+            let cast_from_ptr_size = def.repr().int.map_or(true, |ty| {\n                 matches!(\n                     ty,\n                     IntType::SignedInt(ast::IntTy::Isize) | IntType::UnsignedInt(ast::UintTy::Usize)"}, {"sha": "5a4f20f099060c7f911c3cf4e5e10937b59547f4", "filename": "src/tools/clippy/clippy_lints/src/casts/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Futils.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -34,10 +34,10 @@ pub(super) fn enum_value_nbits(value: EnumValue) -> u64 {\n     .into()\n }\n \n-pub(super) fn enum_ty_to_nbits(adt: &AdtDef, tcx: TyCtxt<'_>) -> u64 {\n+pub(super) fn enum_ty_to_nbits(adt: AdtDef<'_>, tcx: TyCtxt<'_>) -> u64 {\n     let mut explicit = 0i128;\n     let (start, end) = adt\n-        .variants\n+        .variants()\n         .iter()\n         .fold((0, i128::MIN), |(start, end), variant| match variant.discr {\n             VariantDiscr::Relative(x) => match explicit.checked_add(i128::from(x)) {"}, {"sha": "f7e4bc24321c5a8ac58461d41ef60683a3bc9102", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n             then {\n                 // TODO: Work out a way to put \"whatever the imported way of referencing\n                 // this type in this file\" rather than a fully-qualified type.\n-                let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n+                let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did()));\n                 span_lint_and_sugg(\n                     cx,\n                     DEFAULT_TRAIT_ACCESS,\n@@ -137,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                 if let Some(adt) = binding_type.ty_adt_def();\n                 if adt.is_struct();\n                 let variant = adt.non_enum_variant();\n-                if adt.did.is_local() || !variant.is_field_list_non_exhaustive();\n+                if adt.did().is_local() || !variant.is_field_list_non_exhaustive();\n                 let module_did = cx.tcx.parent_module(stmt.hir_id).to_def_id();\n                 if variant\n                     .fields\n@@ -216,7 +216,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     if let ty::Adt(adt_def, substs) = binding_type.kind();\n                     if !substs.is_empty();\n                     then {\n-                        let adt_def_ty_name = cx.tcx.item_name(adt_def.did);\n+                        let adt_def_ty_name = cx.tcx.item_name(adt_def.did());\n                         let generic_args = substs.iter().collect::<Vec<_>>();\n                         let tys_str = generic_args\n                             .iter()"}, {"sha": "f3996e5b44d74c6ad52f87a8938393b718cd4185", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if_chain! {\n                     if let Some(adt_def) = ty.ty_adt_def();\n                     if adt_def.is_struct();\n-                    if let Some(variant) = adt_def.variants.iter().next();\n+                    if let Some(variant) = adt_def.variants().iter().next();\n                     then {\n                         let fields_def = &variant.fields;\n "}, {"sha": "14098340745b10b9a9654c0ccbd2d8684f5d8b3d", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                     _ => false,\n                 };\n                 if should_emit {\n-                    let path_string = cx.tcx.def_path_str(adt_def.did);\n+                    let path_string = cx.tcx.def_path_str(adt_def.did());\n                     span_lint_and_help(\n                         cx,\n                         DERIVABLE_IMPLS,"}, {"sha": "557e101494e3acd87c9188336c3198cdb89fd639", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -315,7 +315,7 @@ fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &T\n             let has_copy_impl = cx.tcx.all_local_trait_impls(()).get(&copy_id).map_or(false, |impls| {\n                 impls\n                     .iter()\n-                    .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did == adt.did))\n+                    .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did() == adt.did()))\n             });\n             if !has_copy_impl {\n                 return;\n@@ -357,10 +357,10 @@ fn check_unsafe_derive_deserialize<'tcx>(\n         if let Some(trait_def_id) = trait_ref.trait_def_id();\n         if match_def_path(cx, trait_def_id, &paths::SERDE_DESERIALIZE);\n         if let ty::Adt(def, _) = ty.kind();\n-        if let Some(local_def_id) = def.did.as_local();\n+        if let Some(local_def_id) = def.did().as_local();\n         let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         if !is_lint_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);\n-        if cx.tcx.inherent_impls(def.did)\n+        if cx.tcx.inherent_impls(def.did())\n             .iter()\n             .map(|imp_did| cx.tcx.hir().expect_item(imp_did.expect_local()))\n             .any(|imp| has_unsafe(cx, imp));"}, {"sha": "b5d6b3c7524baad8f64bea9069054624c990707e", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n         if let ItemKind::Enum(..) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n-            if adt.variants.is_empty() {\n+            if adt.variants().is_empty() {\n                 span_lint_and_help(\n                     cx,\n                     EMPTY_ENUM,"}, {"sha": "e2a5430da08c8c16bcfd1fdccbae12defb886b37", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                     if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n                         if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {\n-                                ty = adt.repr.discr_type().to_ty(cx.tcx);\n+                                ty = adt.repr().discr_type().to_ty(cx.tcx);\n                             }\n                         }\n                         match ty.kind() {"}, {"sha": "51c811b304cae663f71853125f579b5ea2e25576", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -306,7 +306,7 @@ fn in_impl<'tcx>(\n fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n-        if let Some(local_did) = adt_def.did.as_local();\n+        if let Some(local_did) = adt_def.did().as_local();\n         let item = cx.tcx.hir().expect_item(local_did);\n         let middle_ty_id = item.def_id.to_def_id();\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;"}, {"sha": "845863bd209c6ef4cc9696b68341bf9fee537437", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -224,7 +224,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: DefId) -> String {\n         ty::ImplContainer(def_id) => {\n             let ty = cx.tcx.type_of(def_id);\n             match ty.kind() {\n-                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did),\n+                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did()),\n                 _ => ty.to_string(),\n             }\n         },"}, {"sha": "64c41b565878b36772fe2d2e5d17882c2f867314", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n             if_chain! {\n                 if format_args.format_string_parts == [kw::Empty];\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n-                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did),\n+                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did()),\n                     ty::Str => true,\n                     _ => false,\n                 };"}, {"sha": "0709580c8adfdd2ad66a15af13efcf76ebc98d94", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -189,8 +189,8 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n-            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did(), path))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),"}, {"sha": "c8ec2f45137072539afbba571cb87541eb34bff7", "filename": "src/tools/clippy/clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let Some(adt_def) = ty.ty_adt_def();\n             if adt_def.is_struct();\n-            if let Some(variant) = adt_def.variants.iter().next();\n+            if let Some(variant) = adt_def.variants().iter().next();\n             if fields.iter().all(|f| f.is_shorthand);\n             then {\n                 let mut def_order_map = FxHashMap::default();"}, {"sha": "0f3889a2936188a8ffdb83aea483ce7504727785", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -81,11 +81,11 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n-            if adt.variants.len() <= 1 {\n+            if adt.variants().len() <= 1 {\n                 return;\n             }\n             let mut variants_size: Vec<VariantInfo> = Vec::new();\n-            for (i, variant) in adt.variants.iter().enumerate() {\n+            for (i, variant) in adt.variants().iter().enumerate() {\n                 let mut fields_size = Vec::new();\n                 for (i, f) in variant.fields.iter().enumerate() {\n                     let ty = cx.tcx.type_of(f.did);"}, {"sha": "dabbb8375f0a6ff97b030379624a2d3861cd8e7b", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -248,13 +248,13 @@ enum LenOutput<'tcx> {\n fn parse_len_output<'tcx>(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n     match *sig.output().kind() {\n         ty::Int(_) | ty::Uint(_) => Some(LenOutput::Integral),\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) => {\n-            subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did))\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) => {\n+            subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did()))\n         },\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Result, adt.did) => subs\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) => subs\n             .type_at(0)\n             .is_integral()\n-            .then(|| LenOutput::Result(adt.did, subs.type_at(1))),\n+            .then(|| LenOutput::Result(adt.did(), subs.type_at(1))),\n         _ => None,\n     }\n }\n@@ -263,8 +263,8 @@ impl LenOutput<'_> {\n     fn matches_is_empty_output(self, ty: Ty<'_>) -> bool {\n         match (self, ty.kind()) {\n             (_, &ty::Bool) => true,\n-            (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did => subs.type_at(0).is_bool(),\n-            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did => {\n+            (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did() => subs.type_at(0).is_bool(),\n+            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did() => {\n                 subs.type_at(0).is_bool() && subs.type_at(1) == err_ty\n             },\n             _ => false,\n@@ -488,7 +488,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 .any(|item| is_is_empty(cx, item))\n         }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n-        ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n+        ty::Adt(id, _) => has_is_empty_impl(cx, id.did()),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,\n         _ => false,\n     }"}, {"sha": "b31015d195b52007211e0bf97b04b39f9c19733e", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -334,7 +334,7 @@ struct Start<'hir> {\n \n fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.kind() {\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did) => Some(subs.type_at(0)),\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did()) => Some(subs.type_at(0)),\n         ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, *subty),\n         ty::Slice(ty) | ty::Array(ty, _) => Some(*ty),\n         _ => None,"}, {"sha": "93bf0dc62e076707e4228e784a016a96b80c2f61", "filename": "src/tools/clippy/clippy_lints/src/matches/match_wild_enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -45,8 +45,8 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n \n     // Accumulate the variants which should be put in place of the wildcard because they're not\n     // already covered.\n-    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n-    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n+    let has_hidden = adt_def.variants().iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def.variants().iter().filter(|x| !is_hidden(cx, x)).collect();\n \n     let mut path_prefix = CommonPrefixSearcher::None;\n     for arm in arms {\n@@ -118,7 +118,7 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n                 }\n                 s\n             } else {\n-                let mut s = cx.tcx.def_path_str(adt_def.did);\n+                let mut s = cx.tcx.def_path_str(adt_def.did());\n                 s.push_str(\"::\");\n                 s\n             },"}, {"sha": "eec232e6d0989dd731c44b47902780d8f66a6076", "filename": "src/tools/clippy/clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -145,7 +145,7 @@ pub(crate) trait BindInsteadOfMap {\n         if_chain! {\n             if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def();\n             if let Ok(vid) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM);\n-            if Some(adt.did) == cx.tcx.parent(vid);\n+            if Some(adt.did()) == cx.tcx.parent(vid);\n             then {} else { return false; }\n         }\n "}, {"sha": "6d30bb5a278bb42ca9606aceed73bee80b46c5c1", "filename": "src/tools/clippy/clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -15,7 +15,7 @@ pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span,\n     let inner_ty = match recv_ty.kind() {\n         // `Option<T>` -> `T`\n         ty::Adt(adt, subst)\n-            if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && meets_msrv(msrv, &msrvs::OPTION_COPIED) =>\n+            if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && meets_msrv(msrv, &msrvs::OPTION_COPIED) =>\n         {\n             subst.type_at(0)\n         },"}, {"sha": "558cb6bd64e7275a04e2ba49e27acb706eef8049", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -119,9 +119,9 @@ pub(super) fn check<'tcx>(\n             if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n             if let ExprKind::MethodCall(path, [filter_arg], _) = filter_body.value.kind;\n             if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n-            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did) {\n+            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n                 Some(false)\n-            } else if cx.tcx.is_diagnostic_item(sym::Result, opt_ty.did) {\n+            } else if cx.tcx.is_diagnostic_item(sym::Result, opt_ty.did()) {\n                 Some(true)\n             } else {\n                 None"}, {"sha": "6e64e7f62220704fa6759a79d690428a38f63664", "filename": "src/tools/clippy/clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -17,7 +17,7 @@ pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv\n         let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(recv);\n         let (input_type, ref_count) = peel_mid_ty_refs(input_type);\n-        if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n+        if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did()));\n         if return_type == input_type;\n         then {\n             let mut app = Applicability::MachineApplicable;"}, {"sha": "06ead144afa24b459a406639721ea06fdf7a7f1a", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -60,7 +60,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     }\n \n     if let ty::Adt(adt, substs) = ty.kind() {\n-        match_def_path(cx, adt.did, &paths::COW) && substs.type_at(1).is_str()\n+        match_def_path(cx, adt.did(), &paths::COW) && substs.type_at(1).is_str()\n     } else {\n         false\n     }"}, {"sha": "e1212c31cfb021e561bbbb81a0cdf03c801eb1ef", "filename": "src/tools/clippy/clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -55,9 +55,9 @@ pub(super) fn check<'tcx>(\n     // lint if caller of `.map().flatten()` is an Option or Result\n     let caller_type = match cx.typeck_results().expr_ty(recv).kind() {\n         ty::Adt(adt, _) => {\n-            if cx.tcx.is_diagnostic_item(sym::Option, adt.did) {\n+            if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) {\n                 \"Option\"\n-            } else if cx.tcx.is_diagnostic_item(sym::Result, adt.did) {\n+            } else if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) {\n                 \"Result\"\n             } else {\n                 return;"}, {"sha": "8125930b3046144053a7ab4bf8e4063e2ef42675", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -152,7 +152,7 @@ fn parse_iter_usage<'tcx>(\n                     return if_chain! {\n                         if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n                         if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n-                        if cx.tcx.is_diagnostic_item(sym::Option, adt_def.did);\n+                        if cx.tcx.is_diagnostic_item(sym::Option, adt_def.did());\n                         if let ty::Tuple(subs) = subs.type_at(0).kind();\n                         if subs.len() == 2;\n                         then {"}, {"sha": "a307e33875ebb08b6a7b6ca9a0c73105e3177c66", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -33,7 +33,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         } else if !found_mapping && !mutates_arg {\n             let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n             match cx.typeck_results().expr_ty(&body.value).kind() {\n-                ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && in_ty == subst.type_at(0) => {\n+                ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && in_ty == subst.type_at(0) => {\n                     \"filter\"\n                 },\n                 _ => return,"}, {"sha": "cba54e14212d0d18949213c00db27d684eea1237", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -125,7 +125,7 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     if let Adt(def, substs) = ty.kind() {\n         let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n             .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n         if is_keyed_type && is_interior_mutable_type(cx, substs.type_at(0), span) {\n             span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n         }\n@@ -159,8 +159,8 @@ fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Sp\n                 sym::Arc,\n             ]\n             .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n-            let is_box = Some(def.did) == cx.tcx.lang_items().owned_box();\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n+            let is_box = Some(def.did()) == cx.tcx.lang_items().owned_box();\n             if is_std_collection || is_box {\n                 // The type is mutable if any of its type parameters are\n                 substs.types().any(|ty| is_interior_mutable_type(cx, ty, span))"}, {"sha": "a57dc2b27986f93a294af0f03f9597ccb9e12574", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -198,7 +198,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                     // Dereference suggestion\n                     let sugg = |diag: &mut Diagnostic| {\n                         if let ty::Adt(def, ..) = ty.kind() {\n-                            if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n+                            if let Some(span) = cx.tcx.hir().span_if_local(def.did()) {\n                                 if can_type_implement_copy(cx.tcx, cx.param_env, ty, traits::ObligationCause::dummy_with_span(span)).is_ok() {\n                                     diag.span_help(span, \"consider marking this type as `Copy`\");\n                                 }"}, {"sha": "c87c174ef732cb71824640bd7932ee874402c0b4", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if fields.len() == def.non_enum_variant().fields.len()\n-                    && !def.variants[0_usize.into()].is_field_list_non_exhaustive()\n+                    && !def.variant(0_usize.into()).is_field_list_non_exhaustive()\n                 {\n                     span_lint(\n                         cx,"}, {"sha": "9419056be14325a39b7912c51dfbbdcbe9604fc2", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                                     let mut impls = HirIdSet::default();\n                                     cx.tcx.for_each_impl(default_trait_id, |d| {\n                                         if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                                            if let Some(local_def_id) = ty_def.did.as_local() {\n+                                            if let Some(local_def_id) = ty_def.did().as_local() {\n                                                 impls.insert(cx.tcx.hir().local_def_id_to_hir_id(local_def_id));\n                                             }\n                                         }\n@@ -126,7 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                                 if_chain! {\n                                     if let Some(ref impling_types) = self.impling_types;\n                                     if let Some(self_def) = cx.tcx.type_of(self_def_id).ty_adt_def();\n-                                    if let Some(self_local_did) = self_def.did.as_local();\n+                                    if let Some(self_local_did) = self_def.did().as_local();\n                                     let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n                                     if impling_types.contains(&self_id);\n                                     then {"}, {"sha": "8db41ba6ee296f399877221d2c24b77d6c0e6e06", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -140,7 +140,7 @@ fn is_value_unfrozen_raw<'tcx>(\n         match val.ty().kind() {\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n-            ty::Adt(ty_def, ..) if Some(ty_def.did) == cx.tcx.lang_items().unsafe_cell_type() => true,\n+            ty::Adt(ty_def, ..) if Some(ty_def.did()) == cx.tcx.lang_items().unsafe_cell_type() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n                 let val = cx.tcx.destructure_const(cx.param_env.and(val));\n                 val.fields.iter().any(|field| inner(cx, *field))"}, {"sha": "ddef7352de8891075d5a38ee8a6ae0f286e8d720", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n                 let mut non_send_fields = Vec::new();\n \n                 let hir_map = cx.tcx.hir();\n-                for variant in &adt_def.variants {\n+                for variant in adt_def.variants() {\n                     for field in &variant.fields {\n                         if_chain! {\n                             if let Some(field_hir_id) = field\n@@ -233,7 +233,7 @@ fn contains_pointer_like<'tcx>(cx: &LateContext<'tcx>, target_ty: Ty<'tcx>) -> b\n                     return true;\n                 },\n                 ty::Adt(adt_def, _) => {\n-                    if match_def_path(cx, adt_def.did, &paths::PTR_NON_NULL) {\n+                    if match_def_path(cx, adt_def.did(), &paths::PTR_NON_NULL) {\n                         return true;\n                     }\n                 },"}, {"sha": "9c776437d7fe5554efb0032f27930c6660854a21", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -405,13 +405,13 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                 // Check that the name as typed matches the actual name of the type.\n                 // e.g. `fn foo(_: &Foo)` shouldn't trigger the lint when `Foo` is an alias for `Vec`\n                 if let [.., name] = path.segments;\n-                if cx.tcx.item_name(adt.did) == name.ident.name;\n+                if cx.tcx.item_name(adt.did()) == name.ident.name;\n \n                 if !is_lint_allowed(cx, PTR_ARG, hir_ty.hir_id);\n                 if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n \n                 then {\n-                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did) {\n+                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did()) {\n                         Some(sym::Vec) => (\n                             [(\"clone\", \".to_owned()\")].as_slice(),\n                             DerefTy::Slice(\n@@ -462,7 +462,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                     return Some(PtrArg {\n                         idx: i,\n                         span: hir_ty.span,\n-                        ty_did: adt.did,\n+                        ty_did: adt.did(),\n                         ty_name: name.ident.name,\n                         method_renames,\n                         ref_prefix: RefPrefix {\n@@ -570,7 +570,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             .map(|sig| sig.input(i).skip_binder().peel_refs())\n                             .map_or(true, |ty| match *ty.kind() {\n                                 ty::Param(_) => true,\n-                                ty::Adt(def, _) => def.did == args.ty_did,\n+                                ty::Adt(def, _) => def.did() == args.ty_did,\n                                 _ => false,\n                             })\n                         {\n@@ -607,7 +607,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             // If the types match check for methods which exist on both types. e.g. `Vec::len` and\n                             // `slice::len`\n                             ty::Adt(def, _)\n-                                if def.did == args.ty_did\n+                                if def.did() == args.ty_did\n                                     && (i != 0\n                                         || self.cx.tcx.trait_of_item(id).is_some()\n                                         || !args.deref_assoc_items.map_or(false, |(id, items)| {"}, {"sha": "d07c26d7c8975da63108f5ec5e9af7efd2ab8ebd", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n \n         if_chain! {\n             if let Some(self_def) = self_ty.ty_adt_def();\n-            if let Some(self_local_did) = self_def.did.as_local();\n+            if let Some(self_local_did) = self_def.did().as_local();\n             let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n             if let Some(Node::Item(x)) = cx.tcx.hir().find(self_id);\n             let type_name = x.ident.name.as_str().to_lowercase();"}, {"sha": "6edff2240920f3665568ea762e39561de0e9be80", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -141,7 +141,7 @@ pub(super) fn check<'tcx>(\n                                 then {\n                                     diag.note(&format!(\n                                         \"two instances of the same generic type (`{}`) may have different layouts\",\n-                                        cx.tcx.item_name(from_def.did)\n+                                        cx.tcx.item_name(from_def.did())\n                                     ));\n                                 } else {\n                                     if from_ty_orig.peel_refs() != from_ty {\n@@ -304,13 +304,13 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     ty = sized_ty;\n                     continue;\n                 }\n-                if def.repr.inhibit_struct_field_reordering_opt() {\n+                if def.repr().inhibit_struct_field_reordering_opt() {\n                     ReducedTy::OrderedFields(ty)\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n             },\n-            ty::Adt(def, _) if def.is_enum() && (def.variants.is_empty() || is_c_void(cx, ty)) => {\n+            ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n                 ReducedTy::TypeErasure\n             },\n             ty::Foreign(_) => ReducedTy::TypeErasure,"}, {"sha": "831b0d450d20a7f933a6bd380dc370db37710a9e", "filename": "src/tools/clippy/clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -11,11 +11,11 @@ use rustc_span::symbol::sym;\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n-            if from_adt.did != to_adt.did {\n+            if from_adt.did() != to_adt.did() {\n                 return false;\n             }\n             if !matches!(\n-                cx.tcx.get_diagnostic_name(to_adt.did),\n+                cx.tcx.get_diagnostic_name(to_adt.did()),\n                 Some(\n                     sym::BTreeMap\n                         | sym::BTreeSet"}, {"sha": "80d6f3c633670dc207c315c15b667cdbc78f6da7", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -151,11 +151,11 @@ fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did, &paths::POLL);\n+        if match_def_path(cx, def.did(), &paths::POLL);\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Result, ready_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::Result, ready_def.did());\n         then {\n             Some(ready_subst.type_at(1))\n         } else {\n@@ -168,15 +168,15 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did, &paths::POLL);\n+        if match_def_path(cx, def.did(), &paths::POLL);\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Option, ready_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::Option, ready_def.did());\n         let some_ty = ready_subst.type_at(0);\n \n         if let ty::Adt(some_def, some_subst) = some_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Result, some_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::Result, some_def.did());\n         then {\n             Some(some_subst.type_at(1))\n         } else {"}, {"sha": "f4f5a4336a39ec7ad4ae0800207e429f986f1f4d", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -102,9 +102,9 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n \n         // Get the wrapper and inner types, if can't, abort.\n         let (return_type_label, lang_item, inner_type) = if let ty::Adt(adt_def, subst) = return_ty(cx, hir_id).kind() {\n-            if cx.tcx.is_diagnostic_item(sym::Option, adt_def.did) {\n+            if cx.tcx.is_diagnostic_item(sym::Option, adt_def.did()) {\n                 (\"Option\", OptionSome, subst.type_at(0))\n-            } else if cx.tcx.is_diagnostic_item(sym::Result, adt_def.did) {\n+            } else if cx.tcx.is_diagnostic_item(sym::Result, adt_def.did()) {\n                 (\"Result\", ResultOk, subst.type_at(0))\n             } else {\n                 return;"}, {"sha": "a6ef6d79fc023f33a83896292a35dec6db694103", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -73,7 +73,7 @@ fn fn_eagerness<'tcx>(\n         // than marker traits.\n         // Due to the limited operations on these types functions should be fairly cheap.\n         if def\n-            .variants\n+            .variants()\n             .iter()\n             .flat_map(|v| v.fields.iter())\n             .any(|x| matches!(cx.tcx.type_of(x.did).peel_refs().kind(), ty::Param(_)))"}, {"sha": "cd20abd94ed256811487649df709158ec74f4a01", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -268,7 +268,7 @@ pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str])\n pub fn is_diag_item_method(cx: &LateContext<'_>, def_id: DefId, diag_item: Symbol) -> bool {\n     if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n         if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n-            return cx.tcx.is_diagnostic_item(diag_item, adt.did);\n+            return cx.tcx.is_diagnostic_item(diag_item, adt.did());\n         }\n     }\n     false\n@@ -657,7 +657,7 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n                 if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n                     return std_types_symbols\n                         .iter()\n-                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did));\n+                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did()));\n                 }\n             }\n         }"}, {"sha": "3645a9a5228cc9da4fcdcd98532c44c9700cd915", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012720ffb075a087b781325d17d1822a340a2f2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=012720ffb075a087b781325d17d1822a340a2f2a", "patch": "@@ -51,7 +51,7 @@ pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n \n /// Walks into `ty` and returns `true` if any inner type is an instance of the given adt\n /// constructor.\n-pub fn contains_adt_constructor(ty: Ty<'_>, adt: &AdtDef) -> bool {\n+pub fn contains_adt_constructor(ty: Ty<'_>, adt: AdtDef<'_>) -> bool {\n     ty.walk().any(|inner| match inner.unpack() {\n         GenericArgKind::Type(inner_ty) => inner_ty.ty_adt_def() == Some(adt),\n         GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n@@ -112,7 +112,7 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n     let def_id = match ty_to_check.kind() {\n         ty::Array(..) => return Some(sym::array),\n         ty::Slice(..) => return Some(sym::slice),\n-        ty::Adt(adt, _) => adt.did,\n+        ty::Adt(adt, _) => adt.did(),\n         _ => return None,\n     };\n \n@@ -164,7 +164,7 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did)).is_some(),\n+        ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did())).is_some(),\n         ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n         ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n@@ -220,7 +220,7 @@ fn is_normalizable_helper<'tcx>(\n         let cause = rustc_middle::traits::ObligationCause::dummy();\n         if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n             match ty.kind() {\n-                ty::Adt(def, substs) => def.variants.iter().all(|variant| {\n+                ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n                     variant\n                         .fields\n                         .iter()\n@@ -264,7 +264,7 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n pub fn is_type_ref_to_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind() {\n         ty::Ref(_, ref_ty, _) => match ref_ty.kind() {\n-            ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n+            ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did()),\n             _ => false,\n         },\n         _ => false,\n@@ -284,7 +284,7 @@ pub fn is_type_ref_to_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_ite\n /// [Diagnostic Items]: https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n+        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did()),\n         _ => false,\n     }\n }\n@@ -294,7 +294,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n /// Returns `false` if the `LangItem` is not defined.\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).map_or(false, |li| li == adt.did),\n+        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).map_or(false, |li| li == adt.did()),\n         _ => false,\n     }\n }\n@@ -310,7 +310,7 @@ pub fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n /// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n+        ty::Adt(adt, _) => match_def_path(cx, adt.did(), path),\n         _ => false,\n     }\n }\n@@ -398,7 +398,7 @@ pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     match *ty.kind() {\n         ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n         ty::Tuple(types) => types.iter().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n-        ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n+        ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did()),\n         _ => false,\n     }\n }\n@@ -562,11 +562,11 @@ pub fn read_explicit_enum_value(tcx: TyCtxt<'_>, id: DefId) -> Option<EnumValue>\n }\n \n /// Gets the value of the given variant.\n-pub fn get_discriminant_value(tcx: TyCtxt<'_>, adt: &'_ AdtDef, i: VariantIdx) -> EnumValue {\n-    let variant = &adt.variants[i];\n+pub fn get_discriminant_value(tcx: TyCtxt<'_>, adt: AdtDef<'_>, i: VariantIdx) -> EnumValue {\n+    let variant = &adt.variant(i);\n     match variant.discr {\n         VariantDiscr::Explicit(id) => read_explicit_enum_value(tcx, id).unwrap(),\n-        VariantDiscr::Relative(x) => match adt.variants[(i.as_usize() - x as usize).into()].discr {\n+        VariantDiscr::Relative(x) => match adt.variant((i.as_usize() - x as usize).into()).discr {\n             VariantDiscr::Explicit(id) => read_explicit_enum_value(tcx, id).unwrap() + x,\n             VariantDiscr::Relative(_) => EnumValue::Unsigned(x.into()),\n         },\n@@ -577,7 +577,7 @@ pub fn get_discriminant_value(tcx: TyCtxt<'_>, adt: &'_ AdtDef, i: VariantIdx) -\n /// platform specific `libc::<platform>::c_void` types in libc.\n pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     if let ty::Adt(adt, _) = ty.kind()\n-        && let &[krate, .., name] = &*cx.get_def_path(adt.did)\n+        && let &[krate, .., name] = &*cx.get_def_path(adt.did())\n         && let sym::libc | sym::core | sym::std = krate\n         && name.as_str() == \"c_void\"\n     {"}]}