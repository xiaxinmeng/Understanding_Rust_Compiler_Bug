{"sha": "142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MmY2M2ZlNzg1Y2U4ZjJlNWQ5Y2M4ZWRjNmEwZWFmMWMyMWU0NmI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-05T10:23:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-05T10:23:18Z"}, "message": "Tie up the last ends in destination-passing-conversion\n\nCloses #667", "tree": {"sha": "fbfc44aba5a267af1bf749fe0a460446c9bab471", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbfc44aba5a267af1bf749fe0a460446c9bab471"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b", "html_url": "https://github.com/rust-lang/rust/commit/142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bc3f961386427a61d8858df232dcef6fa20486f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc3f961386427a61d8858df232dcef6fa20486f", "html_url": "https://github.com/rust-lang/rust/commit/3bc3f961386427a61d8858df232dcef6fa20486f"}], "stats": {"total": 59, "additions": 26, "deletions": 33}, "files": [{"sha": "3c7dbe4655272ff21852764995967282b7b6f5e0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=142f63fe785ce8f2e5d9cc8edc6a0eaf1c21e46b", "patch": "@@ -2112,9 +2112,8 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                              ty_to_str(tcx, t));\n }\n \n-// FIXME[DPS] rename to store_temp_expr\n-fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-                    src: lval_result, t: ty::t) -> @block_ctxt {\n+fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n+                   src: lval_result, t: ty::t) -> @block_ctxt {\n     // Lvals in memory are not temporaries. Copy them.\n     if src.is_mem {\n         ret copy_val(cx, action, dst, load_if_immediate(cx, src.val, t),\n@@ -2468,17 +2467,6 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n     }\n }\n \n-// FIXME[DPS] remove once all uses have been converted to join_returns\n-fn join_branches(parent_cx: @block_ctxt, ins: [result]) -> @block_ctxt {\n-    let out = new_sub_block_ctxt(parent_cx, \"join\");\n-    let branched = false;\n-    for r: result in ins {\n-        if !r.bcx.unreachable { Br(r.bcx, out.llbb); branched = true; }\n-    }\n-    if !branched { Unreachable(out); }\n-    ret out;\n-}\n-\n tag dest {\n     by_val(@mutable ValueRef);\n     save_in(ValueRef);\n@@ -3264,6 +3252,7 @@ fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n     }\n }\n \n+// Use this when you know you are compiling an lval.\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n@@ -3653,7 +3642,6 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n-        // FIXME[DPS] factor this out\n         ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n     }\n     let closure = alt f_res.env {\n@@ -4203,15 +4191,20 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     ret bcx;\n }\n \n+// Store the result of an expression in the given memory location, ensuring\n+// that nil or bot expressions get ignore rather than save_in as destination.\n fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n     -> @block_ctxt {\n     let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n-    let dst = if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n-        ignore\n-    } else { save_in(dest) };\n-    ret trans_expr(bcx, e, dst);\n+    let do_ignore = ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t);\n+    ret trans_expr(bcx, e, do_ignore ? ignore : save_in(dest));\n }\n \n+// Call this to compile an expression that you need as an intermediate value,\n+// and you want to know whether you're dealing with an lval or not (the is_mem\n+// field in the returned struct). For non-immediates, use trans_expr or\n+// trans_expr_save_in. For intermediates where you don't care about lval-ness,\n+// use trans_temp_expr.\n fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     if expr_is_lval(bcx_tcx(bcx), e) {\n         ret trans_lval(bcx, e);\n@@ -4235,6 +4228,8 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     }\n }\n \n+// Use only for intermediate values. See trans_expr and trans_expr_save_in for\n+// expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n     let {bcx, val, is_mem} = trans_temp_lval(bcx, e);\n     if is_mem && type_is_immediate(bcx_ccx(bcx),\n@@ -4244,13 +4239,11 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n     ret {bcx: bcx, val: val};\n }\n \n-// Invariants:\n-// - things returning nil get dest=ignore\n-// - any lvalue expr may be given dest=by_ref\n-// - exprs returning an immediate get by_val (or by_ref when lval)\n-// - exprs returning non-immediates get save_in (or by_ref when lval)\n-fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n-    -> @block_ctxt {\n+// Translate an expression, with the dest argument deciding what happens with\n+// the result. Invariants:\n+// - exprs returning nil or bot always get dest=ignore\n+// - exprs with non-immediate type never get dest=by_val\n+fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n     if expr_is_lval(tcx, e) { ret lval_to_dps(bcx, e, dest); }\n \n@@ -4356,11 +4349,11 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n \n         let then_cx = new_scope_block_ctxt(bcx, \"claim_then\");\n         let check_cx = trans_check_expr(then_cx, a, \"Claim\");\n-        let else_cx = new_scope_block_ctxt(bcx, \"else\");\n+        let next_cx = new_sub_block_ctxt(bcx, \"join\");\n \n-        CondBr(bcx, cond, then_cx.llbb, else_cx.llbb);\n-        ret join_branches(bcx, [rslt(check_cx, C_nil()),\n-                                rslt(else_cx, C_nil())]);\n+        CondBr(bcx, cond, then_cx.llbb, next_cx.llbb);\n+        Br(check_cx, next_cx.llbb);\n+        ret next_cx;\n       }\n       ast::expr_for(decl, seq, body) {\n         assert dest == ignore;\n@@ -4383,8 +4376,8 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         let src_r = trans_temp_lval(bcx, src);\n         let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n         assert is_mem;\n-        ret move_val_if_temp(bcx, DROP_EXISTING, addr, src_r,\n-                             ty::expr_ty(bcx_tcx(bcx), src));\n+        ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n+                            ty::expr_ty(bcx_tcx(bcx), src));\n       }\n       ast::expr_move(dst, src) {\n         // FIXME: calculate copy init-ness in typestate.\n@@ -4435,7 +4428,7 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n             *cell = Load(bcx, val);\n         }\n       }\n-      save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n+      save_in(loc) { bcx = store_temp_expr(bcx, INIT, loc, lv, ty); }\n       ignore. {}\n     }\n     ret bcx;"}]}