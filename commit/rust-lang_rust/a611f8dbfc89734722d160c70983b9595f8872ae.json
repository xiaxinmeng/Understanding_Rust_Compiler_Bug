{"sha": "a611f8dbfc89734722d160c70983b9595f8872ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTFmOGRiZmM4OTczNDcyMmQxNjBjNzA5ODNiOTU5NWY4ODcyYWU=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-12-17T02:43:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-17T02:43:59Z"}, "message": "Rollup merge of #79882 - wecing:master, r=oli-obk\n\nFix issue #78496\n\nEarlyOtherwiseBranch finds MIR structures like:\n\n```\nbb0: {\n  ...\n  _2 = discriminant(X)\n  ...\n  switchInt(_2) -> [1_isize: bb1, otherwise: bb3]\n}\nbb1: {\n  ...\n  _3 = discriminant(Y)\n  ...\n  switchInt(_3) -> [1_isize: bb2, otherwise: bb3]\n}\nbb2: {...}\nbb3: {...}\n```\n\nAnd transforms them into something like:\n\n```\nbb0: {\n  ...\n  _2 = discriminant(X)\n  _3 = discriminant(Y)\n  _4 = Eq(_2, _3)\n  switchInt(_4) -> [true: bb4, otherwise: bb3]\n}\nbb2: {...} // unchanged\nbb3: {...} // unchanged\nbb4: {\n  switchInt(_2) -> [1_isize: bb2, otherwise: bb3]\n}\n```\n\nBut that is not always a safe thing to do -- sometimes the early `otherwise` branch is necessary so the later block could assume the value of `discriminant(X)`.\n\nI am not totally sure what's the best way to detect that, but fixing #78496 should be easy -- we just check if `X` is a sub-expression of `Y`. A more precise test might be to check if `Y` contains a `Downcast(1)` of `X`, but I think this might be good enough.\n\nFix #78496", "tree": {"sha": "35dadda7231a13f32f09728949925de87952b2e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35dadda7231a13f32f09728949925de87952b2e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a611f8dbfc89734722d160c70983b9595f8872ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf2sXvCRBK7hj4Ov3rIwAAdHIIAKFJcJ4x0juERytRTgirVTK/\nFNYSu9425L6MxcirKm9++6fpwkAa0eqMYcEAR+FOuD1QdLEhDtV/ZVNMb5gHOfTq\nhTKi/YdPbeJeHHRUqxe6E6lsNgEcAy1WPcnZJ6Pca14flR1qcfZgEQMAuI+47EOF\nXs3XoUlLlaJ+YylczLYnDvc6g+kzoXC225mVlgFdbbU/6pGCLhAp7YIIVu9MSEbF\nwkpBOswQEPxK5yfpP91+pj7Othx5//VJwvCFLjTdW630mSr1XcPezUbD/dHE3EYe\n3/0yx6/O0V8VUuSoGZSZ4WYaQ0Zx882cBNTEYBZjqle6QBeIZetTnHNGhbfUFU0=\n=0BIo\n-----END PGP SIGNATURE-----\n", "payload": "tree 35dadda7231a13f32f09728949925de87952b2e7\nparent 3d42c00f0bbe76ea47081809b5525bda4f2149dd\nparent 3812f70355132b53092e826c9d1a753dfd8a1874\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1608173039 +0900\ncommitter GitHub <noreply@github.com> 1608173039 +0900\n\nRollup merge of #79882 - wecing:master, r=oli-obk\n\nFix issue #78496\n\nEarlyOtherwiseBranch finds MIR structures like:\n\n```\nbb0: {\n  ...\n  _2 = discriminant(X)\n  ...\n  switchInt(_2) -> [1_isize: bb1, otherwise: bb3]\n}\nbb1: {\n  ...\n  _3 = discriminant(Y)\n  ...\n  switchInt(_3) -> [1_isize: bb2, otherwise: bb3]\n}\nbb2: {...}\nbb3: {...}\n```\n\nAnd transforms them into something like:\n\n```\nbb0: {\n  ...\n  _2 = discriminant(X)\n  _3 = discriminant(Y)\n  _4 = Eq(_2, _3)\n  switchInt(_4) -> [true: bb4, otherwise: bb3]\n}\nbb2: {...} // unchanged\nbb3: {...} // unchanged\nbb4: {\n  switchInt(_2) -> [1_isize: bb2, otherwise: bb3]\n}\n```\n\nBut that is not always a safe thing to do -- sometimes the early `otherwise` branch is necessary so the later block could assume the value of `discriminant(X)`.\n\nI am not totally sure what's the best way to detect that, but fixing #78496 should be easy -- we just check if `X` is a sub-expression of `Y`. A more precise test might be to check if `Y` contains a `Downcast(1)` of `X`, but I think this might be good enough.\n\nFix #78496\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a611f8dbfc89734722d160c70983b9595f8872ae", "html_url": "https://github.com/rust-lang/rust/commit/a611f8dbfc89734722d160c70983b9595f8872ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a611f8dbfc89734722d160c70983b9595f8872ae/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d42c00f0bbe76ea47081809b5525bda4f2149dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d42c00f0bbe76ea47081809b5525bda4f2149dd", "html_url": "https://github.com/rust-lang/rust/commit/3d42c00f0bbe76ea47081809b5525bda4f2149dd"}, {"sha": "3812f70355132b53092e826c9d1a753dfd8a1874", "url": "https://api.github.com/repos/rust-lang/rust/commits/3812f70355132b53092e826c9d1a753dfd8a1874", "html_url": "https://github.com/rust-lang/rust/commit/3812f70355132b53092e826c9d1a753dfd8a1874"}], "stats": {"total": 43, "additions": 43, "deletions": 0}, "files": [{"sha": "b16a99d7f0dcaee9b7b0634d040653d5c1b9346f", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a611f8dbfc89734722d160c70983b9595f8872ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a611f8dbfc89734722d160c70983b9595f8872ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=a611f8dbfc89734722d160c70983b9595f8872ae", "patch": "@@ -284,6 +284,33 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n                 return None;\n             }\n \n+            // when the second place is a projection of the first one, it's not safe to calculate their discriminant values sequentially.\n+            // for example, this should not be optimized:\n+            //\n+            // ```rust\n+            // enum E<'a> { Empty, Some(&'a E<'a>), }\n+            // let Some(Some(_)) = e;\n+            // ```\n+            //\n+            // ```mir\n+            // bb0: {\n+            //   _2 = discriminant(*_1)\n+            //   switchInt(_2) -> [...]\n+            // }\n+            // bb1: {\n+            //   _3 = discriminant(*(((*_1) as Some).0: &E))\n+            //   switchInt(_3) -> [...]\n+            // }\n+            // ```\n+            let discr_place = discr_info.place_of_adt_discr_read;\n+            let this_discr_place = this_bb_discr_info.place_of_adt_discr_read;\n+            if discr_place.local == this_discr_place.local\n+                && this_discr_place.projection.starts_with(discr_place.projection)\n+            {\n+                trace!(\"NO: one target is the projection of another\");\n+                return None;\n+            }\n+\n             // if we reach this point, the optimization applies, and we should be able to optimize this case\n             // store the info that is needed to apply the optimization\n "}, {"sha": "1b0687cfac3f680fe5f8e0886ca139593d552636", "filename": "src/test/ui/mir/issue-78496.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a611f8dbfc89734722d160c70983b9595f8872ae/src%2Ftest%2Fui%2Fmir%2Fissue-78496.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a611f8dbfc89734722d160c70983b9595f8872ae/src%2Ftest%2Fui%2Fmir%2Fissue-78496.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-78496.rs?ref=a611f8dbfc89734722d160c70983b9595f8872ae", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+// compile-flags: -Z mir-opt-level=2 -C opt-level=0\n+\n+// example from #78496\n+pub enum E<'a> {\n+    Empty,\n+    Some(&'a E<'a>),\n+}\n+\n+fn f(e: &E) -> u32 {\n+   if let E::Some(E::Some(_)) = e { 1 } else { 2 }\n+}\n+\n+fn main() {\n+   assert_eq!(f(&E::Empty), 2);\n+}"}]}