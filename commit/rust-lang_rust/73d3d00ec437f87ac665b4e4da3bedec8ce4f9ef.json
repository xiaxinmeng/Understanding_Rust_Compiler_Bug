{"sha": "73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZDNkMDBlYzQzN2Y4N2FjNjY1YjRlNGRhM2JlZGVjOGNlNGY5ZWY=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-09-27T00:21:59Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T04:56:54Z"}, "message": "path2: Replace the path module outright\n\nRemove the old path.\nRename path2 to path.\nUpdate all clients for the new path.\n\nAlso make some miscellaneous changes to the Path APIs to help the\nadoption process.", "tree": {"sha": "7050b2b93e3c58d7766e9aecd7e973ea88d9210e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7050b2b93e3c58d7766e9aecd7e973ea88d9210e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "html_url": "https://github.com/rust-lang/rust/commit/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6741241f4046aea4014b1a23618593fb481c8606", "url": "https://api.github.com/repos/rust-lang/rust/commits/6741241f4046aea4014b1a23618593fb481c8606", "html_url": "https://github.com/rust-lang/rust/commit/6741241f4046aea4014b1a23618593fb481c8606"}], "stats": {"total": 5496, "additions": 2504, "deletions": 2992}, "files": [{"sha": "cc99f0d67d23438f2de2a8edc7725a4a695a6eb6", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -102,15 +102,15 @@ pub fn parse_config(args: ~[~str]) -> config {\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n-        Path(m.opt_str(nm).unwrap())\n+        Path::from_str(m.opt_str(nm).unwrap())\n     }\n \n     config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map(|s| Path(s)),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path(s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| Path::from_str(s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::from_str(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n@@ -123,10 +123,10 @@ pub fn parse_config(args: ~[~str]) -> config {\n             } else {\n                 None\n             },\n-        logfile: matches.opt_str(\"logfile\").map(|s| Path(s)),\n-        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path(s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| Path::from_str(s)),\n+        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::from_str(s)),\n         ratchet_metrics:\n-            matches.opt_str(\"ratchet-metrics\").map(|s| Path(s)),\n+            matches.opt_str(\"ratchet-metrics\").map(|s| Path::from_str(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n         runtool: matches.opt_str(\"runtool\"),\n@@ -155,9 +155,9 @@ pub fn log_config(config: &config) {\n     logv(c, format!(\"configuration:\"));\n     logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n     logv(c, format!(\"run_lib_path: {}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {}\", config.rustc_path.to_str()));\n-    logv(c, format!(\"src_base: {}\", config.src_base.to_str()));\n-    logv(c, format!(\"build_base: {}\", config.build_base.to_str()));\n+    logv(c, format!(\"rustc_path: {}\", config.rustc_path.display()));\n+    logv(c, format!(\"src_base: {}\", config.src_base.display()));\n+    logv(c, format!(\"build_base: {}\", config.build_base.display()));\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", mode_str(config.mode)));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n@@ -245,12 +245,12 @@ pub fn test_opts(config: &config) -> test::TestOpts {\n \n pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug2!(\"making tests from {}\",\n-           config.src_base.to_str());\n+           config.src_base.display());\n     let mut tests = ~[];\n     let dirs = os::list_dir_path(&config.src_base);\n     for file in dirs.iter() {\n         let file = file.clone();\n-        debug2!(\"inspecting file {}\", file.to_str());\n+        debug2!(\"inspecting file {}\", file.display());\n         if is_test(config, &file) {\n             let t = do make_test(config, &file) {\n                 match config.mode {\n@@ -272,7 +272,7 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n           _ => ~[~\".rc\", ~\".rs\"]\n         };\n     let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = testfile.filename().unwrap();\n+    let name = testfile.filename_str().unwrap();\n \n     let mut valid = false;\n \n@@ -303,9 +303,9 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n \n     // Try to elide redundant long paths\n     fn shorten(path: &Path) -> ~str {\n-        let filename = path.filename();\n-        let p = path.pop();\n-        let dir = p.filename();\n+        let filename = path.filename_str();\n+        let p = path.dir_path();\n+        let dir = p.filename_str();\n         format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n@@ -317,13 +317,15 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n     use std::cell::Cell;\n     let config = Cell::new((*config).clone());\n-    let testfile = Cell::new(testfile.to_str());\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let testfile = Cell::new(testfile.as_str().unwrap().to_owned());\n     test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })\n }\n \n pub fn make_metrics_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n     use std::cell::Cell;\n     let config = Cell::new((*config).clone());\n-    let testfile = Cell::new(testfile.to_str());\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let testfile = Cell::new(testfile.as_str().unwrap().to_owned());\n     test::DynMetricFn(|mm| { runtest::run_metrics(config.take(), testfile.take(), mm) })\n }"}, {"sha": "bf68371c7d2eff2b4d4710fd0c39302e059e9635", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -161,10 +161,10 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n-      Some(s) => Some(Path(s)),\n+      Some(s) => Some(Path::from_str(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            Some(testfile.file_path())\n+            testfile.file_path()\n         } else {\n             None\n         }"}, {"sha": "e1c4c34a5f4960d8894b52cb423a62d2c14cd1e4", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 80, "deletions": 54, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -62,8 +62,8 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(\"\\n\\n\");\n     }\n-    let testfile = Path(testfile);\n-    debug2!(\"running {}\", testfile.to_str());\n+    let testfile = Path::from_str(testfile);\n+    debug2!(\"running {}\", testfile.display());\n     let props = load_props(&testfile);\n     debug2!(\"loaded props\");\n     match config.mode {\n@@ -189,7 +189,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n-            let filepath = testfile.dir_path().push_rel(file);\n+            let filepath = testfile.dir_path().join_path(file);\n             io::read_whole_file_str(&filepath).unwrap()\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n@@ -221,7 +221,8 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     fn make_pp_args(config: &config, _testfile: &Path) -> ProcArgs {\n         let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n-        return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n     }\n \n     fn compare_source(expected: &str, actual: &str) {\n@@ -251,14 +252,17 @@ actual:\\n\\\n     }\n \n     fn make_typecheck_args(config: &config, props: &TestProps, testfile: &Path) -> ProcArgs {\n+        let aux_dir = aux_output_dir_name(config, testfile);\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = ~[~\"-\",\n                          ~\"--no-trans\", ~\"--lib\",\n-                         ~\"-L\", config.build_base.to_str(),\n+                         ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n                          ~\"-L\",\n-                         aux_output_dir_name(config, testfile).to_str()];\n+                         aux_dir.as_str().unwrap().to_owned()];\n         args.push_all_move(split_maybe_args(&config.rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n-        return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n     }\n }\n \n@@ -294,9 +298,11 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     #[cfg(unix)]\n     fn debugger() -> ~str { ~\"gdb\" }\n     let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n+    let exe_file = make_exe_name(config, testfile);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     let debugger_opts = ~[~\"-quiet\", ~\"-batch\", ~\"-nx\",\n-                          ~\"-command=\" + debugger_script.to_str(),\n-                          make_exe_name(config, testfile).to_str()];\n+                          ~\"-command=\" + debugger_script.as_str().unwrap().to_owned(),\n+                          exe_file.as_str().unwrap().to_owned()];\n     let ProcArgs = ProcArgs {prog: debugger(), args: debugger_opts};\n     ProcRes = compose_and_run(config, testfile, ProcArgs, ~[], \"\", None);\n     if ProcRes.status != 0 {\n@@ -328,7 +334,9 @@ fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         ProcRes: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(~\"no error pattern specified in \" + testfile.to_str());\n+        do testfile.with_display_str |s| {\n+            fatal(~\"no error pattern specified in \" + s);\n+        }\n     }\n \n     if ProcRes.status == 0 {\n@@ -378,7 +386,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{}:{}:\", testfile.to_str(), ee.line)\n+        format!(\"{}:{}:\", testfile.display(), ee.line)\n     }).collect::<~[~str]>();\n \n     fn to_lower( s : &str ) -> ~str {\n@@ -538,7 +546,9 @@ fn jit_test(config: &config, props: &TestProps, testfile: &Path) -> ProcRes {\n \n fn compile_test_(config: &config, props: &TestProps,\n                  testfile: &Path, extra_args: &[~str]) -> ProcRes {\n-    let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile).to_str()];\n+    let aux_dir = aux_output_dir_name(config, testfile);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n     let args = make_compile_args(config, props, link_args + extra_args,\n                                  make_exe_name, testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n@@ -579,11 +589,12 @@ fn compose_and_run_compiler(\n         ensure_dir(&aux_output_dir_name(config, testfile));\n     }\n \n-    let extra_link_args = ~[~\"-L\",\n-                            aux_output_dir_name(config, testfile).to_str()];\n+    let aux_dir = aux_output_dir_name(config, testfile);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let extra_link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n \n     for rel_ab in props.aux_builds.iter() {\n-        let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n+        let abs_ab = config.aux_base.join_str(*rel_ab);\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n                               |a,b| make_lib_name(a, b, testfile), &abs_ab);\n@@ -592,7 +603,7 @@ fn compose_and_run_compiler(\n         if auxres.status != 0 {\n             fatal_ProcRes(\n                 format!(\"auxiliary build of {} failed to compile: \",\n-                     abs_ab.to_str()),\n+                     abs_ab.display()),\n                 &auxres);\n         }\n \n@@ -615,7 +626,7 @@ fn compose_and_run_compiler(\n fn ensure_dir(path: &Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail2!(\"can't make dir {}\", path.to_str());\n+        fail2!(\"can't make dir {}\", path.display());\n     }\n }\n \n@@ -631,32 +642,38 @@ fn compose_and_run(config: &config, testfile: &Path,\n fn make_compile_args(config: &config, props: &TestProps, extras: ~[~str],\n                      xform: &fn(&config, (&Path)) -> Path,\n                      testfile: &Path) -> ProcArgs {\n-    let mut args = ~[testfile.to_str(),\n-                     ~\"-o\", xform(config, testfile).to_str(),\n-                     ~\"-L\", config.build_base.to_str()]\n+    let xform_file = xform(config, testfile);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let mut args = ~[testfile.as_str().unwrap().to_owned(),\n+                     ~\"-o\", xform_file.as_str().unwrap().to_owned(),\n+                     ~\"-L\", config.build_base.as_str().unwrap().to_owned()]\n         + extras;\n     args.push_all_move(split_maybe_args(&config.rustcflags));\n     args.push_all_move(split_maybe_args(&props.compile_flags));\n-    return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n+    return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n }\n \n fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n-    aux_output_dir_name(config, testfile).push_rel(&auxname)\n+    aux_output_dir_name(config, testfile).join_path(&auxname)\n }\n \n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n-    Path(output_base_name(config, testfile).to_str() + os::EXE_SUFFIX)\n+    let mut f = output_base_name(config, testfile);\n+    f.add_extension_str(os::EXE_EXTENSION);\n+    f\n }\n \n fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n     // If we've got another tool to run under (valgrind),\n     // then split apart its command\n     let mut args = split_maybe_args(&config.runtool);\n-    args.push(make_exe_name(config, testfile).to_str());\n+    let exe_file = make_exe_name(config, testfile);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    args.push(exe_file.as_str().unwrap().to_owned());\n     let prog = args.shift();\n     return ProcArgs {prog: prog, args: args};\n }\n@@ -725,21 +742,23 @@ fn dump_output_file(config: &config, testfile: &Path,\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n-    output_base_name(config, testfile).with_filetype(extension)\n+    output_base_name(config, testfile).with_extension_str(extension)\n }\n \n fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n-    Path(output_base_name(config, testfile).to_str() + \".libaux\")\n+    let mut f = output_base_name(config, testfile);\n+    f.add_extension_str(\"libaux\");\n+    f\n }\n \n fn output_testname(testfile: &Path) -> Path {\n-    Path(testfile.filestem().unwrap())\n+    Path::from_vec(testfile.filestem().unwrap())\n }\n \n fn output_base_name(config: &config, testfile: &Path) -> Path {\n     config.build_base\n-        .push_rel(&output_testname(testfile))\n-        .with_filetype(config.stage_id)\n+        .join_path(&output_testname(testfile))\n+        .with_extension_str(config.stage_id)\n }\n \n fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n@@ -875,20 +894,19 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n }\n \n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n-    let tstr = aux_output_dir_name(config, testfile).to_str();\n+    let tdir = aux_output_dir_name(config, testfile);\n \n-    let dirs = os::list_dir_path(&Path(tstr));\n+    let dirs = os::list_dir_path(&tdir);\n     for file in dirs.iter() {\n-\n-        if (file.filetype() == Some(\".so\")) {\n-\n+        if file.extension_str() == Some(\"so\") {\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\", config.adb_path,\n-                [~\"push\", file.to_str(), config.adb_test_dir.clone()],\n+                [~\"push\", file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {\n                 io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n-                    config.target, file.to_str(),\n+                    config.target, file.display(),\n                     copy_result.out, copy_result.err));\n             }\n         }\n@@ -898,21 +916,23 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n // codegen tests (vs. clang)\n \n fn make_o_name(config: &config, testfile: &Path) -> Path {\n-    output_base_name(config, testfile).with_filetype(\"o\")\n+    output_base_name(config, testfile).with_extension_str(\"o\")\n }\n \n fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n     } else {\n         let stem = p.filestem().unwrap();\n-        p.with_filestem(stem + \"-\" + suffix)\n+        p.with_filename(stem + bytes!(\"-\") + suffix.as_bytes())\n     }\n }\n \n fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n-    let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile).to_str()];\n+    let aux_dir = aux_output_dir_name(config, testfile);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n     let llvm_args = ~[~\"-c\", ~\"--lib\", ~\"--save-temps\"];\n     let args = make_compile_args(config, props,\n                                  link_args + llvm_args,\n@@ -922,50 +942,56 @@ fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n \n fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n                                           testfile: &Path) -> ProcRes {\n-    let bitcodefile = output_base_name(config, testfile).with_filetype(\"bc\");\n+    let bitcodefile = output_base_name(config, testfile).with_extension_str(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, \"clang\");\n+    let testcc = testfile.with_extension_str(\"cc\");\n     let ProcArgs = ProcArgs {\n-        prog: config.clang_path.get_ref().to_str(),\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n         args: ~[~\"-c\",\n                 ~\"-emit-llvm\",\n-                ~\"-o\", bitcodefile.to_str(),\n-                testfile.with_filetype(\"cc\").to_str() ]\n+                ~\"-o\", bitcodefile.as_str().unwrap().to_owned(),\n+                testcc.as_str().unwrap().to_owned() ]\n     };\n     compose_and_run(config, testfile, ProcArgs, ~[], \"\", None)\n }\n \n fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n                                  fname: &str, testfile: &Path,\n                                  suffix: &str) -> ProcRes {\n-    let bitcodefile = output_base_name(config, testfile).with_filetype(\"bc\");\n+    let bitcodefile = output_base_name(config, testfile).with_extension_str(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n+    let prog = config.llvm_bin_path.get_ref().join_str(\"llvm-extract\");\n     let ProcArgs = ProcArgs {\n-        prog: config.llvm_bin_path.get_ref().push(\"llvm-extract\").to_str(),\n-        args: ~[~\"-func=\" + fname,\n-                ~\"-o=\" + extracted_bc.to_str(),\n-                bitcodefile.to_str() ]\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        prog: prog.as_str().unwrap().to_owned(),\n+        args: ~[\"-func=\" + fname,\n+                \"-o=\" + extracted_bc.as_str().unwrap(),\n+                bitcodefile.as_str().unwrap().to_owned() ]\n     };\n     compose_and_run(config, testfile, ProcArgs, ~[], \"\", None)\n }\n \n fn disassemble_extract(config: &config, _props: &TestProps,\n                        testfile: &Path, suffix: &str) -> ProcRes {\n-    let bitcodefile = output_base_name(config, testfile).with_filetype(\"bc\");\n+    let bitcodefile = output_base_name(config, testfile).with_extension_str(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n-    let extracted_ll = extracted_bc.with_filetype(\"ll\");\n+    let extracted_ll = extracted_bc.with_extension_str(\"ll\");\n+    let prog = config.llvm_bin_path.get_ref().join_str(\"llvm-dis\");\n     let ProcArgs = ProcArgs {\n-        prog: config.llvm_bin_path.get_ref().push(\"llvm-dis\").to_str(),\n-        args: ~[~\"-o=\" + extracted_ll.to_str(),\n-                extracted_bc.to_str() ]\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        prog: prog.as_str().unwrap().to_owned(),\n+        args: ~[\"-o=\" + extracted_ll.as_str().unwrap(),\n+                extracted_bc.as_str().unwrap().to_owned() ]\n     };\n     compose_and_run(config, testfile, ProcArgs, ~[], \"\", None)\n }\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = io::read_whole_file_str(&p.with_filetype(\"ll\")).unwrap();\n+    let x = io::read_whole_file_str(&p.with_extension_str(\"ll\")).unwrap();\n     x.line_iter().len()\n }\n "}, {"sha": "08d1222ff4666f2a72b6d28e30908523079a1f04", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -362,7 +362,7 @@ pub fn make_path_option_vec(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>\n         if stdin_hyphen && \"-\" == *str {\n             None\n         } else {\n-            Some(Path(*str))\n+            Some(Path::from_str(*str))\n         }\n     }).collect()\n }\n@@ -435,14 +435,14 @@ mod test {\n     fn test_make_path_option_vec() {\n         let strs = [~\"some/path\",\n                     ~\"some/other/path\"];\n-        let paths = ~[Some(Path(\"some/path\")),\n-                      Some(Path(\"some/other/path\"))];\n+        let paths = ~[Some(Path::from_str(\"some/path\")),\n+                      Some(Path::from_str(\"some/other/path\"))];\n \n         assert_eq!(make_path_option_vec(strs, true), paths.clone());\n         assert_eq!(make_path_option_vec(strs, false), paths);\n \n         assert_eq!(make_path_option_vec([~\"-\"], true), ~[None]);\n-        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path(\"-\"))]);\n+        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path::from_str(\"-\"))]);\n     }\n \n     #[test]\n@@ -567,9 +567,9 @@ mod test {\n     #[test]\n     fn test_no_trailing_newline() {\n         let f1 =\n-            Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n+            Some(Path::from_str(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n         let f2 =\n-            Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n+            Some(Path::from_str(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n \n         {\n             let mut wr = file::open(f1.get_ref(), io::CreateOrTruncate,"}, {"sha": "e398f41c467b02a3a5347a8d9c2d4b73c84d60f5", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -35,7 +35,7 @@ pub struct GlobIterator {\n     priv root: Path,\n     priv dir_patterns: ~[Pattern],\n     priv options: MatchOptions,\n-    priv todo: ~[Path]\n+    priv todo: ~[(Path,uint)]\n }\n \n /**\n@@ -80,18 +80,32 @@ pub fn glob(pattern: &str) -> GlobIterator {\n  * Paths are yielded in alphabetical order, as absolute paths.\n  */\n pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n+    #[cfg(windows)]\n+    use is_sep = std::path::windows::is_sep2;\n+    #[cfg(not(windows))]\n+    fn is_sep(c: char) -> bool { c <= '\\x7F' && ::std::path::posix::is_sep(&(c as u8)) }\n+    #[cfg(windows)]\n+    fn check_windows_verbatim(p: &Path) -> bool { p.is_verbatim() }\n+    #[cfg(not(windows))]\n+    fn check_windows_verbatim(_: &Path) -> bool { false }\n+\n+    // calculate root this way to handle volume-relative Windows paths correctly\n+    let mut root = os::getcwd();\n+    let pat_root = Path::from_str(pattern).root_path();\n+    if pat_root.is_some() {\n+        if check_windows_verbatim(pat_root.get_ref()) {\n+            // XXX: How do we want to handle verbatim paths? I'm inclined to return nothing,\n+            // since we can't very well find all UNC shares with a 1-letter server name.\n+            return GlobIterator { root: root, dir_patterns: ~[], options: options, todo: ~[] };\n+        }\n+        root.push_path(pat_root.get_ref());\n+    }\n \n-    // note that this relies on the glob meta characters not\n-    // having any special meaning in actual pathnames\n-    let path = Path(pattern);\n-    let dir_patterns = path.components.map(|s| Pattern::new(*s));\n+    let root_len = pat_root.map_move_default(0u, |p| p.as_vec().len());\n+    let dir_patterns = pattern.slice_from(root_len.min(&pattern.len()))\n+                       .split_terminator_iter(is_sep).map(|s| Pattern::new(s)).to_owned_vec();\n \n-    let root = if path.is_absolute() {\n-        Path {components: ~[], .. path} // preserve windows path host/device\n-    } else {\n-        os::getcwd()\n-    };\n-    let todo = list_dir_sorted(&root);\n+    let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).to_owned_vec();\n \n     GlobIterator {\n         root: root,\n@@ -109,18 +123,24 @@ impl Iterator<Path> for GlobIterator {\n                 return None;\n             }\n \n-            let path = self.todo.pop();\n-            let pattern_index = path.components.len() - self.root.components.len() - 1;\n-            let ref pattern = self.dir_patterns[pattern_index];\n-\n-            if pattern.matches_with(*path.components.last(), self.options) {\n+            let (path,idx) = self.todo.pop();\n+            let ref pattern = self.dir_patterns[idx];\n \n-                if pattern_index == self.dir_patterns.len() - 1 {\n+            if pattern.matches_with(match path.filename_str() {\n+                // this ugly match needs to go here to avoid a borrowck error\n+                None => {\n+                    // FIXME (#9639): How do we handle non-utf8 filenames? Ignore them for now\n+                    // Ideally we'd still match them against a *\n+                    loop;\n+                }\n+                Some(x) => x\n+            }, self.options) {\n+                if idx == self.dir_patterns.len() - 1 {\n                     // it is not possible for a pattern to match a directory *AND* its children\n                     // so we don't need to check the children\n                     return Some(path);\n                 } else {\n-                    self.todo.push_all(list_dir_sorted(&path));\n+                    self.todo.extend(&mut list_dir_sorted(&path).move_iter().map(|x|(x,idx+1)));\n                 }\n             }\n         }\n@@ -130,7 +150,7 @@ impl Iterator<Path> for GlobIterator {\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n     let mut children = os::list_dir_path(path);\n-    sort::quick_sort(children, |p1, p2| p2.components.last() <= p1.components.last());\n+    sort::quick_sort(children, |p1, p2| p2.filename().unwrap() <= p1.filename().unwrap());\n     children\n }\n \n@@ -285,7 +305,10 @@ impl Pattern {\n      * using the default match options (i.e. `MatchOptions::new()`).\n      */\n     pub fn matches_path(&self, path: &Path) -> bool {\n-        self.matches(path.to_str())\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        do path.as_str().map_move_default(false) |s| {\n+            self.matches(s)\n+        }\n     }\n \n     /**\n@@ -300,7 +323,10 @@ impl Pattern {\n      * using the specified match options.\n      */\n     pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n-        self.matches_with(path.to_str(), options)\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        do path.as_str().map_move_default(false) |s| {\n+            self.matches_with(s, options)\n+        }\n     }\n \n     fn matches_from(&self,\n@@ -436,7 +462,7 @@ fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptio\n \n /// A helper function to determine if two chars are (possibly case-insensitively) equal.\n fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n-    if cfg!(windows) && path::windows::is_sep(a) && path::windows::is_sep(b) {\n+    if cfg!(windows) && path::windows::is_sep2(a) && path::windows::is_sep2(b) {\n         true\n     } else if !case_sensitive && a.is_ascii() && b.is_ascii() {\n         // FIXME: work with non-ascii chars properly (issue #1347)\n@@ -449,9 +475,9 @@ fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n /// A helper function to determine if a char is a path separator on the current platform.\n fn is_sep(c: char) -> bool {\n     if cfg!(windows) {\n-        path::windows::is_sep(c)\n+        path::windows::is_sep2(c)\n     } else {\n-        path::posix::is_sep(c)\n+        c <= '\\x7F' && path::posix::is_sep(&(c as u8))\n     }\n }\n \n@@ -522,8 +548,9 @@ mod test {\n         assert!(glob(\"//\").next().is_none());\n \n         // check windows absolute paths with host/device components\n-        let root_with_device = (Path {components: ~[], .. os::getcwd()}).to_str() + \"*\";\n-        assert!(glob(root_with_device).next().is_some());\n+        let root_with_device = os::getcwd().root_path().unwrap().join_str(\"*\");\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        assert!(glob(root_with_device.as_str().unwrap()).next().is_some());\n     }\n \n     #[test]\n@@ -745,9 +772,9 @@ mod test {\n \n     #[test]\n     fn test_matches_path() {\n-        // on windows, (Path(\"a/b\").to_str() == \"a\\\\b\"), so this\n+        // on windows, (Path::from_str(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n         // tests that / and \\ are considered equivalent on windows\n-        assert!(Pattern::new(\"a/b\").matches_path(&Path(\"a/b\")));\n+        assert!(Pattern::new(\"a/b\").matches_path(&Path::from_str(\"a/b\")));\n     }\n }\n "}, {"sha": "12263188787675335fdff51d7692741f1aad024b", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -35,7 +35,7 @@ impl TempDir {\n \n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n-            let p = tmpdir.push(r.gen_ascii_str(16) + suffix);\n+            let p = tmpdir.join_str(r.gen_ascii_str(16) + suffix);\n             if os::make_dir(&p, 0x1c0) { // 700\n                 return Some(TempDir { path: Some(p) });\n             }"}, {"sha": "cd4e487d70fe497038026ba33ededc6aebb369e2", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -14,10 +14,9 @@\n use std::{os, str};\n use std::os::getenv;\n use std::io::{file_reader, Reader};\n-use path = std::path::Path;\n \n /// Return path to database entry for `term`\n-pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n+pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n     if term.len() == 0 {\n         return None;\n     }\n@@ -29,40 +28,45 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n \n     // Find search directory\n     match getenv(\"TERMINFO\") {\n-        Some(dir) => dirs_to_search.push(path(dir)),\n+        Some(dir) => dirs_to_search.push(Path::from_str(dir)),\n         None => {\n             if homedir.is_some() {\n-                dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n+                // ncurses compatability;\n+                dirs_to_search.push(homedir.unwrap().join_str(\".terminfo\"))\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n                 Some(dirs) => for i in dirs.split_iter(':') {\n                     if i == \"\" {\n-                        dirs_to_search.push(path(\"/usr/share/terminfo\"));\n+                        dirs_to_search.push(Path::from_str(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(path(i.to_owned()));\n+                        dirs_to_search.push(Path::from_str(i.to_owned()));\n                     }\n                 },\n                 // Found nothing, use the default paths\n                 // /usr/share/terminfo is the de facto location, but it seems\n                 // Ubuntu puts it in /lib/terminfo\n                 None => {\n-                    dirs_to_search.push(path(\"/usr/share/terminfo\"));\n-                    dirs_to_search.push(path(\"/lib/terminfo\"));\n+                    dirs_to_search.push(Path::from_str(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(Path::from_str(\"/lib/terminfo\"));\n                 }\n             }\n         }\n     };\n \n     // Look for the terminal in all of the search directories\n     for p in dirs_to_search.iter() {\n-        let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n-        if os::path_exists(p) && os::path_exists(newp) {\n-            return Some(newp);\n-        }\n-        // on some installations the dir is named after the hex of the char (e.g. OS X)\n-        let newp = ~p.push_many(&[format!(\"{:x}\", first_char as uint), term.to_owned()]);\n-        if os::path_exists(p) && os::path_exists(newp) {\n-            return Some(newp);\n+        if os::path_exists(p) {\n+            let f = str::from_char(first_char);\n+            let newp = p.join_many_str([f.as_slice(), term]);\n+            if os::path_exists(&newp) {\n+                return Some(~newp);\n+            }\n+            // on some installations the dir is named after the hex of the char (e.g. OS X)\n+            let f = format!(\"{:x}\", first_char as uint);\n+            let newp = p.join_many_str([f.as_slice(), term]);\n+            if os::path_exists(&newp) {\n+                return Some(~newp);\n+            }\n         }\n     }\n     None\n@@ -82,7 +86,11 @@ fn test_get_dbpath_for_term() {\n     // woefully inadequate test coverage\n     // note: current tests won't work with non-standard terminfo hierarchies (e.g. OS X's)\n     use std::os::{setenv, unsetenv};\n-    fn x(t: &str) -> ~str { get_dbpath_for_term(t).expect(\"no terminfo entry found\").to_str() };\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    fn x(t: &str) -> ~str {\n+        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n+        p.as_str().unwrap().to_owned()\n+    };\n     assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n     assert!(get_dbpath_for_term(\"\") == None);\n     setenv(\"TERMINFO_DIRS\", \":\");"}, {"sha": "20690283dd5a1c5486e5795fc288a5586dcfbe30", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -271,20 +271,20 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| Path(s));\n+    let logfile = logfile.map(|s| Path::from_str(s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n         matches.opt_present(\"test\");\n \n     let ratchet_metrics = matches.opt_str(\"ratchet-metrics\");\n-    let ratchet_metrics = ratchet_metrics.map(|s| Path(s));\n+    let ratchet_metrics = ratchet_metrics.map(|s| Path::from_str(s));\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n     let ratchet_noise_percent = ratchet_noise_percent.map(|s| from_str::<f64>(s).unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n-    let save_metrics = save_metrics.map(|s| Path(s));\n+    let save_metrics = save_metrics.map(|s| Path::from_str(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n     let test_shard = opt_shard(test_shard);\n@@ -547,7 +547,7 @@ impl ConsoleTestState {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.out.write_str(format!(\"\\nusing metrics ratchet: {}\\n\", pth.to_str()));\n+                self.out.write_str(format!(\"\\nusing metrics ratchet: {}\\n\", pth.display()));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n@@ -659,7 +659,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => (),\n         Some(ref pth) => {\n             st.metrics.save(pth);\n-            st.out.write_str(format!(\"\\nmetrics saved to: {}\", pth.to_str()));\n+            st.out.write_str(format!(\"\\nmetrics saved to: {}\", pth.display()));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n@@ -1440,7 +1440,7 @@ mod tests {\n     pub fn ratchet_test() {\n \n         let dpth = TempDir::new(\"test-ratchet\").expect(\"missing test for ratchet\");\n-        let pth = dpth.path().push(\"ratchet.json\");\n+        let pth = dpth.path().join_str(\"ratchet.json\");\n \n         let mut m1 = MetricMap::new();\n         m1.insert_metric(\"runtime\", 1000.0, 2.0);"}, {"sha": "ea943cdb01b97198223664247d7e6cc3fdf21324", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -184,11 +184,11 @@ impl Database {\n         let f = io::file_reader(&self.db_filename);\n         match f {\n             Err(e) => fail2!(\"Couldn't load workcache database {}: {}\",\n-                            self.db_filename.to_str(), e.to_str()),\n+                            self.db_filename.display(), e.to_str()),\n             Ok(r) =>\n                 match json::from_reader(r) {\n                     Err(e) => fail2!(\"Couldn't parse workcache database (from file {}): {}\",\n-                                    self.db_filename.to_str(), e.to_str()),\n+                                    self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n                         let mut decoder = json::Decoder(r);\n                         self.db_cache = Decodable::decode(&mut decoder);\n@@ -498,7 +498,7 @@ fn test() {\n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n     fn make_path(filename: ~str) -> Path {\n-        let pth = os::self_exe_path().expect(\"workcache::test failed\").pop().push(filename);\n+        let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename_str(filename);\n         if os::path_exists(&pth) {\n             os::remove_file(&pth);\n         }\n@@ -522,15 +522,20 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n-        prep.declare_input(\"file\", pth.to_str(), digest_file(&pth));\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        prep.declare_input(\"file\", pth.as_str().unwrap(), digest_file(&pth));\n         do prep.exec |_exe| {\n             let out = make_path(~\"foo.o\");\n-            run::process_status(\"gcc\", [pth.to_str(), ~\"-o\", out.to_str()]);\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            run::process_status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n+                                        ~\"-o\",\n+                                        out.as_str().unwrap().to_owned()]);\n \n             let _proof_of_concept = subcx.prep(\"subfn\");\n             // Could run sub-rules inside here.\n \n-            out.to_str()\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            out.as_str().unwrap().to_owned()\n         }\n     };\n "}, {"sha": "d5cd78f54f71674a5ef0a19376454f6476b08b71", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -70,7 +70,7 @@ pub fn WriteOutputFile(\n         Target: lib::llvm::TargetMachineRef,\n         PM: lib::llvm::PassManagerRef,\n         M: ModuleRef,\n-        Output: &str,\n+        Output: &Path,\n         FileType: lib::llvm::FileType) {\n     unsafe {\n         do Output.with_c_str |Output| {\n@@ -129,15 +129,13 @@ pub mod jit {\n             let cstore = sess.cstore;\n             let r = cstore::get_used_crate_files(cstore);\n             for cratepath in r.iter() {\n-                let path = cratepath.to_str();\n+                debug2!(\"linking: {}\", cratepath.display());\n \n-                debug2!(\"linking: {}\", path);\n-\n-                do path.with_c_str |buf_t| {\n+                do cratepath.with_c_str |buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n-                    debug2!(\"linked: {}\", path);\n+                    debug2!(\"linked: {}\", cratepath.display());\n                 }\n             }\n \n@@ -251,7 +249,7 @@ pub mod write {\n             llvm::LLVMInitializeMipsAsmParser();\n \n             if sess.opts.save_temps {\n-                do output.with_filetype(\"no-opt.bc\").with_c_str |buf| {\n+                do output.with_extension_str(\"no-opt.bc\").with_c_str |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }\n@@ -319,7 +317,7 @@ pub mod write {\n             llvm::LLVMDisposePassManager(mpm);\n \n             if sess.opts.save_temps {\n-                do output.with_filetype(\"bc\").with_c_str |buf| {\n+                do output.with_extension_str(\"bc\").with_c_str |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }\n@@ -350,12 +348,10 @@ pub mod write {\n                         }\n                     }\n                     output_type_assembly => {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output.to_str(),\n-                                        lib::llvm::AssemblyFile);\n+                        WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n                     }\n                     output_type_exe | output_type_object => {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output.to_str(),\n-                                        lib::llvm::ObjectFile);\n+                        WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n                     }\n                 }\n \n@@ -375,10 +371,11 @@ pub mod write {\n     pub fn run_assembler(sess: Session, assembly: &Path, object: &Path) {\n         let cc_prog = super::get_cc_prog(sess);\n \n+        // FIXME (#9639): This needs to handle non-utf8 paths\n         let cc_args = ~[\n             ~\"-c\",\n-            ~\"-o\", object.to_str(),\n-            assembly.to_str()];\n+            ~\"-o\", object.as_str().unwrap().to_owned(),\n+            assembly.as_str().unwrap().to_owned()];\n \n         let prog = run::process_output(cc_prog, cc_args);\n \n@@ -612,11 +609,12 @@ pub fn build_link_meta(sess: Session,\n             _ => {\n                 // to_managed could go away if there was a version of\n                 // filestem that returned an @str\n+                // FIXME (#9639): Non-utf8 filenames will give a misleading error\n                 let name = session::expect(sess,\n-                                           output.filestem(),\n+                                           output.filestem_str(),\n                                            || format!(\"output file name `{}` doesn't\\\n                                                     appear to have a stem\",\n-                                                   output.to_str())).to_managed();\n+                                                   output.display())).to_managed();\n                 if name.is_empty() {\n                     sess.fatal(\"missing crate link meta `name`, and the \\\n                                 inferred name is blank\");\n@@ -919,15 +917,16 @@ pub fn link_binary(sess: Session,\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n         debug2!(\"link_meta.name:  {}\", lm.name);\n         debug2!(\"long_libname: {}\", long_libname);\n-        debug2!(\"out_filename: {}\", out_filename.to_str());\n-        debug2!(\"dirname(out_filename): {}\", out_filename.dir_path().to_str());\n+        debug2!(\"out_filename: {}\", out_filename.display());\n+        let out_dirname = out_filename.dir_path();\n+        debug2!(\"dirname(out_filename): {}\", out_dirname.display());\n \n-        out_filename.dir_path().push(long_libname)\n+        out_filename.with_filename_str(long_libname)\n     } else {\n         out_filename.clone()\n     };\n \n-    debug2!(\"output: {}\", output.to_str());\n+    debug2!(\"output: {}\", output.display());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n     debug2!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n@@ -947,14 +946,15 @@ pub fn link_binary(sess: Session,\n \n     // Clean up on Darwin\n     if sess.targ_cfg.os == session::OsMacos {\n-        run::process_status(\"dsymutil\", [output.to_str()]);\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        run::process_status(\"dsymutil\", [output.as_str().unwrap().to_owned()]);\n     }\n \n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n         if ! os::remove_file(obj_filename) {\n             sess.warn(format!(\"failed to delete object file `{}`\",\n-                           obj_filename.to_str()));\n+                           obj_filename.display()));\n         }\n     }\n }\n@@ -977,20 +977,23 @@ pub fn link_args(sess: Session,\n \n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        out_filename.dir_path().push(long_libname)\n+        out_filename.with_filename_str(long_libname)\n     } else {\n         out_filename.clone()\n     };\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n-    let stage: ~str = ~\"-L\" + sess.filesearch.get_target_lib_path().to_str();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let lib_path = sess.filesearch.get_target_lib_path();\n+    let stage: ~str = ~\"-L\" + lib_path.as_str().unwrap();\n \n     let mut args = vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n \n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push_all([\n-        ~\"-o\", output.to_str(),\n-        obj_filename.to_str()]);\n+        ~\"-o\", output.as_str().unwrap().to_owned(),\n+        obj_filename.as_str().unwrap().to_owned()]);\n \n     let lib_cmd = match sess.targ_cfg.os {\n         session::OsMacos => ~\"-dynamiclib\",\n@@ -1001,14 +1004,15 @@ pub fn link_args(sess: Session,\n \n     let cstore = sess.cstore;\n     let r = cstore::get_used_crate_files(cstore);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     for cratepath in r.iter() {\n-        if cratepath.filetype() == Some(\".rlib\") {\n-            args.push(cratepath.to_str());\n+        if cratepath.extension_str() == Some(\"rlib\") {\n+            args.push(cratepath.as_str().unwrap().to_owned());\n             continue;\n         }\n-        let dir = cratepath.dirname();\n+        let dir = cratepath.dirname_str().unwrap();\n         if !dir.is_empty() { args.push(\"-L\" + dir); }\n-        let libarg = unlib(sess.targ_cfg, cratepath.filestem().unwrap().to_owned());\n+        let libarg = unlib(sess.targ_cfg, cratepath.filestem_str().unwrap().to_owned());\n         args.push(\"-l\" + libarg);\n     }\n \n@@ -1032,12 +1036,14 @@ pub fn link_args(sess: Session,\n     // forces to make sure that library can be found at runtime.\n \n     for path in sess.opts.addl_lib_search_paths.iter() {\n-        args.push(\"-L\" + path.to_str());\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n \n     let rustpath = filesearch::rust_path();\n     for path in rustpath.iter() {\n-        args.push(\"-L\" + path.to_str());\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n \n     // The names of the extern libraries\n@@ -1050,8 +1056,9 @@ pub fn link_args(sess: Session,\n         // On mac we need to tell the linker to let this library\n         // be rpathed\n         if sess.targ_cfg.os == session::OsMacos {\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n             args.push(\"-Wl,-install_name,@rpath/\"\n-                      + output.filename().unwrap());\n+                      + output.filename_str().unwrap());\n         }\n     }\n "}, {"sha": "b3fb6be686da76a24b0f965c38d87ee768275123", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 64, "deletions": 46, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -45,23 +45,26 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n \n fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n-    sess.filesearch.sysroot().push_rel(&r).push(os::dll_filename(\"rustrt\"))\n+    let mut p = sess.filesearch.sysroot().join_path(&r);\n+    p.push_str(os::dll_filename(\"rustrt\"));\n+    p\n }\n \n-pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    rpaths.iter().map(|rpath| format!(\"-Wl,-rpath,{}\",rpath.to_str())).collect()\n+pub fn rpaths_to_flags(rpaths: &[~str]) -> ~[~str] {\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    rpaths.iter().map(|rpath| format!(\"-Wl,-rpath,{}\",*rpath)).collect()\n }\n \n fn get_rpaths(os: session::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n-              target_triple: &str) -> ~[Path] {\n-    debug2!(\"sysroot: {}\", sysroot.to_str());\n-    debug2!(\"output: {}\", output.to_str());\n+              target_triple: &str) -> ~[~str] {\n+    debug2!(\"sysroot: {}\", sysroot.display());\n+    debug2!(\"output: {}\", output.display());\n     debug2!(\"libs:\");\n     for libpath in libs.iter() {\n-        debug2!(\"    {}\", libpath.to_str());\n+        debug2!(\"    {}\", libpath.display());\n     }\n     debug2!(\"target_triple: {}\", target_triple);\n \n@@ -77,10 +80,10 @@ fn get_rpaths(os: session::Os,\n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n-    fn log_rpaths(desc: &str, rpaths: &[Path]) {\n+    fn log_rpaths(desc: &str, rpaths: &[~str]) {\n         debug2!(\"{} rpaths:\", desc);\n         for rpath in rpaths.iter() {\n-            debug2!(\"    {}\", rpath.to_str());\n+            debug2!(\"    {}\", *rpath);\n         }\n     }\n \n@@ -99,14 +102,14 @@ fn get_rpaths(os: session::Os,\n \n fn get_rpaths_relative_to_output(os: session::Os,\n                                  output: &Path,\n-                                 libs: &[Path]) -> ~[Path] {\n+                                 libs: &[Path]) -> ~[~str] {\n     libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: session::Os,\n                                     output: &Path,\n                                     lib: &Path)\n-                                 -> Path {\n+                                 -> ~str {\n     use std::os;\n \n     assert!(not_win32(os));\n@@ -119,29 +122,43 @@ pub fn get_rpath_relative_to_output(os: session::Os,\n         session::OsWin32 => unreachable!()\n     };\n \n-    Path(prefix).push_rel(&os::make_absolute(output).get_relative_to(&os::make_absolute(lib)))\n+    let mut lib = os::make_absolute(lib);\n+    lib.pop();\n+    let mut output = os::make_absolute(output);\n+    output.pop();\n+    let relative = lib.path_relative_from(&output);\n+    let relative = relative.expect(\"could not create rpath relative to output\");\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    prefix+\"/\"+relative.as_str().expect(\"non-utf8 component in path\")\n }\n \n-fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n+fn get_absolute_rpaths(libs: &[Path]) -> ~[~str] {\n     libs.iter().map(|a| get_absolute_rpath(a)).collect()\n }\n \n-pub fn get_absolute_rpath(lib: &Path) -> Path {\n-    os::make_absolute(lib).dir_path()\n+pub fn get_absolute_rpath(lib: &Path) -> ~str {\n+    let mut p = os::make_absolute(lib);\n+    p.pop();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    p.as_str().expect(\"non-utf8 component in rpath\").to_owned()\n }\n \n-pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n+pub fn get_install_prefix_rpath(target_triple: &str) -> ~str {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n     let tlib = filesearch::relative_target_lib_path(target_triple);\n-    os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n+    let mut path = Path::from_str(install_prefix);\n+    path.push_path(&tlib);\n+    let path = os::make_absolute(&path);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    path.as_str().expect(\"non-utf8 component in rpath\").to_owned()\n }\n \n-pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n+pub fn minimize_rpaths(rpaths: &[~str]) -> ~[~str] {\n     let mut set = HashSet::new();\n     let mut minimized = ~[];\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath.to_str()) {\n+        if set.insert(rpath.as_slice()) {\n             minimized.push(rpath.clone());\n         }\n     }\n@@ -162,43 +179,43 @@ mod test {\n \n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags([Path(\"path1\"),\n-                                     Path(\"path2\")]);\n+        let flags = rpaths_to_flags([~\"path1\", ~\"path2\"]);\n         assert_eq!(flags, ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n     fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        let d = Path(env!(\"CFG_PREFIX\"))\n-            .push_rel(&Path(\"lib/rustc/triple/lib\"));\n+        let mut d = Path::from_str(env!(\"CFG_PREFIX\"));\n+        d.push_str(\"lib/rustc/triple/lib\");\n         debug2!(\"test_prefix_path: {} vs. {}\",\n                res.to_str(),\n-               d.to_str());\n-        assert!(res.to_str().ends_with(d.to_str()));\n+               d.display());\n+        assert!(ends_with(res.as_bytes(), d.as_vec()));\n+        fn ends_with(v: &[u8], needle: &[u8]) -> bool {\n+            v.len() >= needle.len() && v.slice_from(v.len()-needle.len()) == needle\n+        }\n     }\n \n     #[test]\n     fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        assert!(res.is_absolute);\n+        assert!(Path::from_str(res).is_absolute());\n     }\n \n     #[test]\n     fn test_minimize1() {\n-        let res = minimize_rpaths([Path(\"rpath1\"),\n-                                   Path(\"rpath2\"),\n-                                   Path(\"rpath1\")]);\n-        assert_eq!(res, ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n+        let res = minimize_rpaths([~\"rpath1\", ~\"rpath2\", ~\"rpath1\"]);\n+        assert_eq!(res.as_slice(), [~\"rpath1\", ~\"rpath2\"]);\n     }\n \n     #[test]\n     fn test_minimize2() {\n-        let res = minimize_rpaths([Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n-                                   Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n-                                   Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n-                                   Path(\"3\")]);\n-        assert_eq!(res, ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n+        let res = minimize_rpaths([~\"1a\", ~\"2\",  ~\"2\",\n+                                   ~\"1a\", ~\"4a\", ~\"1a\",\n+                                   ~\"2\",  ~\"3\",  ~\"4a\",\n+                                   ~\"3\"]);\n+        assert_eq!(res.as_slice(), [~\"1a\", ~\"2\", ~\"4a\", ~\"3\"]);\n     }\n \n     #[test]\n@@ -207,36 +224,37 @@ mod test {\n     fn test_rpath_relative() {\n       let o = session::OsLinux;\n       let res = get_rpath_relative_to_output(o,\n-            &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-      assert_eq!(res.to_str(), ~\"$ORIGIN/../lib\");\n+            &Path::from_str(\"bin/rustc\"), &Path::from_str(\"lib/libstd.so\"));\n+      assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n         let o = session::OsFreebsd;\n         let res = get_rpath_relative_to_output(o,\n-            &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-        assert_eq!(res.to_str(), ~\"$ORIGIN/../lib\");\n+            &Path::from_str(\"bin/rustc\"), &Path::from_str(\"lib/libstd.so\"));\n+        assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n         let o = session::OsMacos;\n         let res = get_rpath_relative_to_output(o,\n-                                               &Path(\"bin/rustc\"),\n-                                               &Path(\"lib/libstd.so\"));\n-        assert_eq!(res.to_str(), ~\"@executable_path/../lib\");\n+                                               &Path::from_str(\"bin/rustc\"),\n+                                               &Path::from_str(\"lib/libstd.so\"));\n+        assert_eq!(res.as_slice(), \"@executable_path/../lib\");\n     }\n \n     #[test]\n     fn test_get_absolute_rpath() {\n-        let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n+        let res = get_absolute_rpath(&Path::from_str(\"lib/libstd.so\"));\n+        let lib = os::make_absolute(&Path::from_str(\"lib\"));\n         debug2!(\"test_get_absolute_rpath: {} vs. {}\",\n-               res.to_str(),\n-               os::make_absolute(&Path(\"lib\")).to_str());\n+               res.to_str(), lib.display());\n \n-        assert_eq!(res, os::make_absolute(&Path(\"lib\")));\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        assert_eq!(res.as_slice(), lib.as_str().expect(\"non-utf8 component in path\"));\n     }\n }"}, {"sha": "fc5ff163d74989fd9fe868d0618bcfce28b0c62f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -58,7 +58,8 @@ pub fn anon_src() -> @str { @\"<anon>\" }\n \n pub fn source_name(input: &input) -> @str {\n     match *input {\n-      file_input(ref ifile) => ifile.to_str().to_managed(),\n+      // FIXME (#9639): This needs to handle non-utf8 paths\n+      file_input(ref ifile) => ifile.as_str().unwrap().to_managed(),\n       str_input(_) => anon_src()\n     }\n }\n@@ -352,7 +353,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n         (sess.opts.output_type == link::output_type_object ||\n          sess.opts.output_type == link::output_type_exe) {\n         let output_type = link::output_type_assembly;\n-        let asm_filename = outputs.obj_filename.with_filetype(\"s\");\n+        let asm_filename = outputs.obj_filename.with_extension_str(\"s\");\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n@@ -721,7 +722,7 @@ pub fn build_session_options(binary: @str,\n         } else if matches.opt_present(\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path(m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::from_str(m));\n     let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n     let target_cpu = matches.opt_str(\"target-cpu\").unwrap_or(~\"generic\");\n     let target_feature = matches.opt_str(\"target-feature\").unwrap_or(~\"\");\n@@ -754,7 +755,7 @@ pub fn build_session_options(binary: @str,\n \n     let statik = debugging_opts & session::statik != 0;\n \n-    let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| Path(*s));\n+    let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| Path::from_str(*s));\n     let linker = matches.opt_str(\"linker\");\n     let linker_args = matches.opt_strs(\"link-args\").flat_map( |a| {\n         a.split_iter(' ').map(|arg| arg.to_owned()).collect()\n@@ -985,7 +986,8 @@ pub fn build_output_filenames(input: &input,\n           };\n \n           let mut stem = match *input {\n-              file_input(ref ifile) => (*ifile).filestem().unwrap().to_managed(),\n+              // FIXME (#9639): This needs to handle non-utf8 paths\n+              file_input(ref ifile) => (*ifile).filestem_str().unwrap().to_managed(),\n               str_input(_) => @\"rust_out\"\n           };\n \n@@ -1003,20 +1005,24 @@ pub fn build_output_filenames(input: &input,\n           }\n \n           if *sess.building_library {\n-              out_path = dirpath.push(os::dll_filename(stem));\n-              obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n+              out_path = dirpath.join_str(os::dll_filename(stem));\n+              obj_path = {\n+                  let mut p = dirpath.join_str(stem);\n+                  p.set_extension_str(obj_suffix);\n+                  p\n+              };\n           } else {\n-              out_path = dirpath.push(stem);\n-              obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n+              out_path = dirpath.join_str(stem);\n+              obj_path = out_path.with_extension_str(obj_suffix);\n           }\n       }\n \n       Some(ref out_file) => {\n-        out_path = (*out_file).clone();\n+        out_path = out_file.clone();\n         obj_path = if stop_after_codegen {\n-            (*out_file).clone()\n+            out_file.clone()\n         } else {\n-            (*out_file).with_filetype(obj_suffix)\n+            out_file.with_extension_str(obj_suffix)\n         };\n \n         if *sess.building_library {"}, {"sha": "8ece290293b3982ce4474b7f03b3a800af5a4c88", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -143,14 +143,15 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n           let meta_items = match path_opt {\n               None => meta_items.clone(),\n               Some((p, _path_str_style)) => {\n-                  let p_path = Path(p);\n-                  match p_path.filestem() {\n+                  let p_path = Path::from_str(p);\n+                  match p_path.filestem_str() {\n+                      None|Some(\"\") =>\n+                          e.diag.span_bug(i.span, \"Bad package path in `extern mod` item\"),\n                       Some(s) =>\n                           vec::append(\n                               ~[attr::mk_name_value_item_str(@\"package_id\", p),\n                                attr::mk_name_value_item_str(@\"name\", s.to_managed())],\n-                              *meta_items),\n-                      None => e.diag.span_bug(i.span, \"Bad package path in `extern mod` item\")\n+                              *meta_items)\n                   }\n             }\n           };\n@@ -274,7 +275,7 @@ fn resolve_crate(e: @mut Env,\n         };\n         let (lident, ldata) = loader::load_library_crate(&load_ctxt);\n \n-        let cfilename = Path(lident);\n+        let cfilename = Path::from_str(lident);\n         let cdata = ldata;\n \n         let attrs = decoder::get_crate_attributes(cdata);"}, {"sha": "4e3daa7c185dad605bb96cd68f95c109b4896f78", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -24,10 +24,10 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n pub type pick<'self> = &'self fn(path: &Path) -> FileMatch;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n-    if path.file_path() == file {\n-        option::Some((*path).clone())\n+    if path.file_path() == Some(file) {\n+        Some(path.clone())\n     } else {\n-        option::None\n+        None\n     }\n }\n \n@@ -60,29 +60,29 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                     FileMatches => found = true,\n                     FileDoesntMatch => ()\n                 }\n-                visited_dirs.insert(path.to_str());\n+                visited_dirs.insert(path.as_vec().to_owned());\n             }\n \n             debug2!(\"filesearch: searching target lib path\");\n             let tlib_path = make_target_lib_path(self.sysroot,\n                                         self.target_triple);\n-            if !visited_dirs.contains(&tlib_path.to_str()) {\n+            if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n                 match f(&tlib_path) {\n                     FileMatches => found = true,\n                     FileDoesntMatch => ()\n                 }\n             }\n-            visited_dirs.insert(tlib_path.to_str());\n+            visited_dirs.insert(tlib_path.as_vec().to_owned());\n             // Try RUST_PATH\n             if !found {\n                 let rustpath = rust_path();\n                 for path in rustpath.iter() {\n                     let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n-                    debug2!(\"is {} in visited_dirs? {:?}\", tlib_path.to_str(),\n-                            visited_dirs.contains(&tlib_path.to_str()));\n+                    debug2!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n+                            visited_dirs.contains_equiv(&tlib_path.as_vec().to_owned()));\n \n-                    if !visited_dirs.contains(&tlib_path.to_str()) {\n-                        visited_dirs.insert(tlib_path.to_str());\n+                    if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n+                        visited_dirs.insert(tlib_path.as_vec().to_owned());\n                         // Don't keep searching the RUST_PATH if one match turns up --\n                         // if we did, we'd get a \"multiple matching crates\" error\n                         match f(&tlib_path) {\n@@ -99,12 +99,14 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             make_target_lib_path(self.sysroot, self.target_triple)\n         }\n         fn get_target_lib_file_path(&self, file: &Path) -> Path {\n-            self.get_target_lib_path().push_rel(file)\n+            let mut p = self.get_target_lib_path();\n+            p.push_path(file);\n+            p\n         }\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    debug2!(\"using sysroot = {}\", sysroot.to_str());\n+    debug2!(\"using sysroot = {}\", sysroot.display());\n     @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n@@ -114,19 +116,19 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n \n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n-        debug2!(\"searching {}\", lib_search_path.to_str());\n+        debug2!(\"searching {}\", lib_search_path.display());\n         let r = os::list_dir_path(lib_search_path);\n         let mut rslt = FileDoesntMatch;\n         for path in r.iter() {\n-            debug2!(\"testing {}\", path.to_str());\n+            debug2!(\"testing {}\", path.display());\n             let maybe_picked = pick(path);\n             match maybe_picked {\n                 FileMatches => {\n-                    debug2!(\"picked {}\", path.to_str());\n+                    debug2!(\"picked {}\", path.display());\n                     rslt = FileMatches;\n                 }\n                 FileDoesntMatch => {\n-                    debug2!(\"rejected {}\", path.to_str());\n+                    debug2!(\"rejected {}\", path.display());\n                 }\n             }\n         }\n@@ -135,24 +137,30 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n }\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {\n-    Path(libdir()).push_many([~\"rustc\",\n-                              target_triple.to_owned(),\n-                              libdir()])\n+    let dir = libdir();\n+    let mut p = Path::from_str(dir);\n+    assert!(p.is_relative());\n+    p.push_str(\"rustc\");\n+    p.push_str(target_triple);\n+    p.push_str(dir);\n+    p\n }\n \n fn make_target_lib_path(sysroot: &Path,\n                         target_triple: &str) -> Path {\n-    sysroot.push_rel(&relative_target_lib_path(target_triple))\n+    sysroot.join_path(&relative_target_lib_path(target_triple))\n }\n \n fn make_rustpkg_target_lib_path(dir: &Path,\n                         target_triple: &str) -> Path {\n-    dir.push_rel(&Path(libdir()).push(target_triple.to_owned()))\n+    let mut p = dir.join_str(libdir());\n+    p.push_str(target_triple);\n+    p\n }\n \n pub fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n-      option::Some(ref p) => (*p).pop(),\n+      option::Some(p) => { let mut p = p; p.pop(); p }\n       option::None => fail2!(\"can't determine value for sysroot\")\n     }\n }\n@@ -184,27 +192,28 @@ pub fn rust_path() -> ~[Path] {\n         Some(env_path) => {\n             let env_path_components: ~[&str] =\n                 env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n-            env_path_components.map(|&s| Path(s))\n+            env_path_components.map(|&s| Path::from_str(s))\n         }\n         None => ~[]\n     };\n     let cwd = os::getcwd();\n     // now add in default entries\n-    let cwd_dot_rust = cwd.push(\".rust\");\n+    let cwd_dot_rust = cwd.join_str(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n         env_rust_path.push(cwd_dot_rust);\n     }\n     if !env_rust_path.contains(&cwd) {\n         env_rust_path.push(cwd.clone());\n     }\n     do cwd.each_parent() |p| {\n-        if !env_rust_path.contains(&p.push(\".rust\")) {\n+        if !env_rust_path.contains(&p.join_str(\".rust\")) {\n             push_if_exists(&mut env_rust_path, p);\n         }\n-    }\n+        true\n+    };\n     let h = os::homedir();\n     for h in h.iter() {\n-        if !env_rust_path.contains(&h.push(\".rust\")) {\n+        if !env_rust_path.contains(&h.join_str(\".rust\")) {\n             push_if_exists(&mut env_rust_path, h);\n         }\n     }\n@@ -214,7 +223,7 @@ pub fn rust_path() -> ~[Path] {\n \n /// Adds p/.rust into vec, only if it exists\n fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n-    let maybe_dir = p.push(\".rust\");\n+    let maybe_dir = p.join_str(\".rust\");\n     if os::path_exists(&maybe_dir) {\n         vec.push(maybe_dir);\n     }"}, {"sha": "593a02c95082dcb9945a94112bee4e82f031009d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -93,25 +93,27 @@ fn find_library_crate_aux(\n     let prefix = format!(\"{}{}-\", prefix, crate_name);\n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| -> FileMatch {\n-      let path_str = path.filename();\n+      // FIXME (#9639): This needs to handle non-utf8 paths\n+      let path_str = path.filename_str();\n       match path_str {\n           None => FileDoesntMatch,\n           Some(path_str) =>\n               if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n-                  debug2!(\"{} is a candidate\", path.to_str());\n+                  debug2!(\"{} is a candidate\", path.display());\n                   match get_metadata_section(cx.os, path) {\n                       Some(cvec) =>\n                           if !crate_matches(cvec, cx.metas, cx.hash) {\n                               debug2!(\"skipping {}, metadata doesn't match\",\n-                                  path.to_str());\n+                                  path.display());\n                               FileDoesntMatch\n                           } else {\n-                              debug2!(\"found {} with matching metadata\", path.to_str());\n-                              matches.push((path.to_str(), cvec));\n+                              debug2!(\"found {} with matching metadata\", path.display());\n+                              // FIXME (#9639): This needs to handle non-utf8 paths\n+                              matches.push((path.as_str().unwrap().to_owned(), cvec));\n                               FileMatches\n                           },\n                       _ => {\n-                          debug2!(\"could not load metadata for {}\", path.to_str());\n+                          debug2!(\"could not load metadata for {}\", path.display());\n                           FileDoesntMatch\n                       }\n                   }\n@@ -273,7 +275,7 @@ pub fn list_file_metadata(intr: @ident_interner,\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n-        out.write_str(format!(\"could not find metadata in {}.\\n\", path.to_str()))\n+        out.write_str(format!(\"could not find metadata in {}.\\n\", path.display()))\n       }\n     }\n }"}, {"sha": "fb3f215e50624337e822184987c720a3382a6ce8", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -859,7 +859,8 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n \n     debug2!(\"compile_unit_metadata: {:?}\", crate_name);\n \n-    let work_dir = cx.sess.working_dir.to_str();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let work_dir = cx.sess.working_dir.as_str().unwrap();\n     let producer = format!(\"rustc version {}\", env!(\"CFG_VERSION\"));\n \n     do crate_name.with_c_str |crate_name| {\n@@ -969,7 +970,8 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n \n     debug2!(\"file_metadata: {}\", full_path);\n \n-    let work_dir = cx.sess.working_dir.to_str();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let work_dir = cx.sess.working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n             full_path.slice(work_dir.len() + 1u, full_path.len())"}, {"sha": "460ac45cdba0673a95b94774e1e775bb43866399", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -250,16 +250,16 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n             let src = str::from_utf8(io::stdin().read_whole_stream());\n             str_input(src.to_managed())\n         } else {\n-            file_input(Path(ifile))\n+            file_input(Path::from_str(ifile))\n         }\n       }\n       _ => early_error(demitter, \"multiple input filenames provided\")\n     };\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = matches.opt_str(\"out-dir\").map(|o| Path(o));\n-    let ofile = matches.opt_str(\"o\").map(|o| Path(o));\n+    let odir = matches.opt_str(\"out-dir\").map(|o| Path::from_str(o));\n+    let ofile = matches.opt_str(\"o\").map(|o| Path::from_str(o));\n     let cfg = build_configuration(sess);\n     let pretty = do matches.opt_default(\"pretty\", \"normal\").map |a| {\n         parse_pretty(sess, a)"}, {"sha": "1b7fe9f15cb2ed1ca1019204eeae6835ed94595d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -39,7 +39,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n \n     let sessopts = @driver::session::options {\n         binary: @\"rustdoc\",\n-        maybe_sysroot: Some(@os::self_exe_path().unwrap().pop()),\n+        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @mut libs,\n         .. (*rustc::driver::session::basic_options()).clone()\n     };"}, {"sha": "9347a1775d48b0e76e8516179c0e7df5cc3e0181", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -47,7 +47,6 @@ use std::rt::io::Reader;\n use std::str;\n use std::task;\n use std::unstable::finally::Finally;\n-use std::util;\n use std::vec;\n \n use extra::arc::RWArc;\n@@ -256,16 +255,16 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     crate = cache.fold_crate(crate);\n \n     // Add all the static files\n-    let dst = cx.dst.push(crate.name);\n+    let mut dst = cx.dst.join_str(crate.name);\n     mkdir(&dst);\n-    write(dst.push(\"jquery.js\"), include_str!(\"static/jquery-2.0.3.min.js\"));\n-    write(dst.push(\"main.js\"), include_str!(\"static/main.js\"));\n-    write(dst.push(\"main.css\"), include_str!(\"static/main.css\"));\n-    write(dst.push(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n+    write(dst.join_str(\"jquery.js\"), include_str!(\"static/jquery-2.0.3.min.js\"));\n+    write(dst.join_str(\"main.js\"), include_str!(\"static/main.js\"));\n+    write(dst.join_str(\"main.css\"), include_str!(\"static/main.css\"));\n+    write(dst.join_str(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n \n     // Publish the search index\n     {\n-        let dst = dst.push(\"search-index.js\");\n+        dst.push_str(\"search-index.js\");\n         let mut w = BufferedWriter::new(dst.open_writer(io::CreateOrTruncate));\n         let w = &mut w as &mut io::Writer;\n         write!(w, \"var searchIndex = [\");\n@@ -293,9 +292,9 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     // Render all source files (this may turn into a giant no-op)\n     {\n         info2!(\"emitting source files\");\n-        let dst = cx.dst.push(\"src\");\n+        let dst = cx.dst.join_str(\"src\");\n         mkdir(&dst);\n-        let dst = dst.push(crate.name);\n+        let dst = dst.join_str(crate.name);\n         mkdir(&dst);\n         let mut folder = SourceCollector {\n             dst: dst,\n@@ -325,7 +324,7 @@ fn write(dst: Path, contents: &str) {\n fn mkdir(path: &Path) {\n     do io::io_error::cond.trap(|err| {\n         error2!(\"Couldn't create directory `{}`: {}\",\n-                path.to_str(), err.desc);\n+                path.display(), err.desc);\n         fail2!()\n     }).inside {\n         if !path.is_dir() {\n@@ -335,18 +334,18 @@ fn mkdir(path: &Path) {\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n-/// things like \".\" and \"..\" to components which preserve the \"top down\"\n-/// hierarchy of a static HTML tree.\n-fn clean_srcpath(src: &str, f: &fn(&str)) {\n-    let p = Path(src);\n-    for c in p.components.iter() {\n-        if \".\" == *c {\n-            continue\n-        }\n-        if \"..\" == *c {\n-            f(\"up\");\n-        } else {\n-            f(c.as_slice())\n+/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n+/// static HTML tree.\n+// FIXME (#9639): The closure should deal with &[u8] instead of &str\n+fn clean_srcpath(src: &[u8], f: &fn(&str)) {\n+    let p = Path::from_vec(src);\n+    if p.as_vec() != bytes!(\".\") {\n+        for c in p.str_component_iter().map(|x|x.unwrap()) {\n+            if \"..\" == c {\n+                f(\"up\");\n+            } else {\n+                f(c.as_slice())\n+            }\n         }\n     }\n }\n@@ -355,7 +354,7 @@ fn clean_srcpath(src: &str, f: &fn(&str)) {\n /// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // See if there's documentation generated into the local directory\n-    let local_location = dst.push(e.name);\n+    let local_location = dst.join_str(e.name);\n     if local_location.is_dir() {\n         return Local;\n     }\n@@ -414,7 +413,7 @@ impl<'self> DocFolder for SourceCollector<'self> {\n impl<'self> SourceCollector<'self> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> bool {\n-        let p = Path(filename);\n+        let p = Path::from_str(filename);\n \n         // Read the contents of the file\n         let mut contents = ~[];\n@@ -445,17 +444,17 @@ impl<'self> SourceCollector<'self> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n-        do clean_srcpath(p.pop().to_str()) |component| {\n-            cur = cur.push(component);\n+        do clean_srcpath(p.dirname()) |component| {\n+            cur.push_str(component);\n             mkdir(&cur);\n             root_path.push_str(\"../\");\n         }\n \n-        let dst = cur.push(*p.components.last() + \".html\");\n-        let w = dst.open_writer(io::CreateOrTruncate);\n+        cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n+        let w = cur.open_writer(io::CreateOrTruncate);\n         let mut w = BufferedWriter::new(w);\n \n-        let title = format!(\"{} -- source\", *dst.components.last());\n+        let title = cur.with_filename_display_str(|s| format!(\"{} -- source\", s.unwrap()));\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n@@ -661,8 +660,8 @@ impl Context {\n         if s.len() == 0 {\n             fail2!(\"what {:?}\", self);\n         }\n-        let next = self.dst.push(s);\n-        let prev = util::replace(&mut self.dst, next);\n+        let prev = self.dst.clone();\n+        self.dst.push_str(s);\n         self.root_path.push_str(\"../\");\n         self.current.push(s);\n \n@@ -809,7 +808,7 @@ impl Context {\n                 let item = Cell::new(item);\n                 do self.recurse(name) |this| {\n                     let item = item.take();\n-                    let dst = this.dst.push(\"index.html\");\n+                    let dst = this.dst.join_str(\"index.html\");\n                     let writer = dst.open_writer(io::CreateOrTruncate);\n                     render(writer.unwrap(), this, &item, false);\n \n@@ -827,7 +826,7 @@ impl Context {\n             // Things which don't have names (like impls) don't get special\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n-                let dst = self.dst.push(item_path(&item));\n+                let dst = self.dst.join_str(item_path(&item));\n                 let writer = dst.open_writer(io::CreateOrTruncate);\n                 render(writer.unwrap(), self, &item, true);\n             }\n@@ -881,7 +880,7 @@ impl<'self> fmt::Default for Item<'self> {\n \n         if it.cx.include_sources {\n             let mut path = ~[];\n-            do clean_srcpath(it.item.source.filename) |component| {\n+            do clean_srcpath(it.item.source.filename.as_bytes()) |component| {\n                 path.push(component.to_owned());\n             }\n             let href = if it.item.source.loline == it.item.source.hiline {"}, {"sha": "12128402f74f0fdf5b095ed3b15ae1357980ba04", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -41,7 +41,7 @@ impl PluginManager {\n     /// platform. On windows, it turns into name.dll, on OS X, name.dylib, and\n     /// elsewhere, libname.so.\n     pub fn load_plugin(&mut self, name: ~str) {\n-        let x = self.prefix.push(libname(name));\n+        let x = self.prefix.join_str(libname(name));\n         let lib_result = dl::DynamicLibrary::open(Some(&x));\n         let lib = lib_result.unwrap();\n         let plugin = unsafe { lib.symbol(\"rustdoc_plugin_entrypoint\") }.unwrap();"}, {"sha": "470ae7f9dfe00e5f2b7722d47107d4450cb520c1", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -134,13 +134,13 @@ pub fn main_args(args: &[~str]) -> int {\n \n     info2!(\"going to format\");\n     let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path(s));\n+    let output = matches.opt_str(\"o\").map(|s| Path::from_str(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n-            html::render::run(crate, output.unwrap_or(Path(\"doc\")))\n+            html::render::run(crate, output.unwrap_or(Path::from_str(\"doc\")))\n         }\n         Some(~\"json\") => {\n-            json_output(crate, res, output.unwrap_or(Path(\"doc.json\")))\n+            json_output(crate, res, output.unwrap_or(Path::from_str(\"doc.json\")))\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -188,8 +188,8 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n-    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n-    let cr = Cell::new(Path(cratefile));\n+    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::from_str(*s)));\n+    let cr = Cell::new(Path::from_str(cratefile));\n     info2!(\"starting to run rustc\");\n     let crate = do std::task::try {\n         let cr = cr.take();\n@@ -230,7 +230,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n     // Load all plugins/passes into a PluginManager\n     let path = matches.opt_str(\"plugin-path\").unwrap_or(~\"/tmp/rustdoc_ng/plugins\");\n-    let mut pm = plugins::PluginManager::new(Path(path));\n+    let mut pm = plugins::PluginManager::new(Path::from_str(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n             Some(i) => PASSES[i].n1(),\n@@ -254,7 +254,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match ::std::io::file_reader(&Path(input)) {\n+    let input = match ::std::io::file_reader(&Path::from_str(input)) {\n         Ok(i) => i,\n         Err(s) => return Err(s),\n     };"}, {"sha": "b511d17ec7778c8e293700d37b18c28e0a76feb4", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -142,7 +142,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n         binary: binary,\n-        addl_lib_search_paths: @mut lib_search_paths.map(|p| Path(*p)),\n+        addl_lib_search_paths: @mut lib_search_paths.map(|p| Path::from_str(*p)),\n         jit: true,\n         .. (*session::basic_options()).clone()\n     };\n@@ -315,8 +315,20 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n // because it already exists and is newer than the source file, or\n // None if there were compile errors.\n fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n+    fn has_prefix(v: &[u8], pref: &[u8]) -> bool {\n+        v.len() >= pref.len() && v.slice_to(pref.len()) == pref\n+    }\n+    fn has_extension(v: &[u8], ext: Option<&[u8]>) -> bool {\n+        match ext {\n+            None => true,\n+            Some(ext) => {\n+                v.len() > ext.len() && v[v.len()-ext.len()-1] == '.' as u8 &&\n+                    v.slice_from(v.len()-ext.len()) == ext\n+            }\n+        }\n+    }\n     match do task::try {\n-        let src_path = Path(src_filename);\n+        let src_path = Path::from_str(src_filename);\n         let binary = binary.to_managed();\n         let options = @session::options {\n             binary: binary,\n@@ -334,17 +346,17 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         // If the library already exists and is newer than the source\n         // file, skip compilation and return None.\n         let mut should_compile = true;\n-        let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n+        let dir = os::list_dir_path(&outputs.out_filename.dir_path());\n         let maybe_lib_path = do dir.iter().find |file| {\n             // The actual file's name has a hash value and version\n             // number in it which is unknown at this time, so looking\n             // for a file that matches out_filename won't work,\n             // instead we guess which file is the library by matching\n             // the prefix and suffix of out_filename to files in the\n             // directory.\n-            let file_str = file.filename().unwrap();\n-            file_str.starts_with(outputs.out_filename.filestem().unwrap())\n-                && file_str.ends_with(outputs.out_filename.filetype().unwrap())\n+            let file_vec = file.filename().unwrap();\n+            has_prefix(file_vec, outputs.out_filename.filestem().unwrap()) &&\n+                has_extension(file_vec, outputs.out_filename.extension())\n         };\n         match maybe_lib_path {\n             Some(lib_path) => {\n@@ -429,11 +441,12 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 }\n             }\n             for crate in loaded_crates.iter() {\n-                let crate_path = Path(*crate);\n-                let crate_dir = crate_path.dirname();\n+                let crate_path = Path::from_str(*crate);\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                let crate_dir = crate_path.dirname_str().unwrap();\n                 repl.program.record_extern(format!(\"extern mod {};\", *crate));\n-                if !repl.lib_search_paths.iter().any(|x| x == &crate_dir) {\n-                    repl.lib_search_paths.push(crate_dir);\n+                if !repl.lib_search_paths.iter().any(|x| crate_dir == *x) {\n+                    repl.lib_search_paths.push(crate_dir.to_owned());\n                 }\n             }\n             if loaded_crates.is_empty() {"}, {"sha": "6e0908d2a4f65a4d291cde61bbddd542a429fe05", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -43,18 +43,18 @@ pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n }\n \n fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path(path);\n+    let path = Path::from_str(path);\n     os::path_exists(&path) && in_hash == digest_file_with_date(&path)\n }\n \n fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path(path);\n+    let path = Path::from_str(path);\n     os::path_exists(&path) && in_hash == digest_only_date(&path)\n }\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {\n-    let db_file = p.push(\"rustpkg_db.json\"); // ??? probably wrong\n-    debug2!(\"Workcache database file: {}\", db_file.to_str());\n+    let db_file = p.join_str(\"rustpkg_db.json\"); // ??? probably wrong\n+    debug2!(\"Workcache database file: {}\", db_file.display());\n     let db = RWArc::new(Database::new(db_file));\n     let lg = RWArc::new(Logger::new());\n     let cfg = Arc::new(TreeMap::new());\n@@ -73,7 +73,7 @@ pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n-        start_dir: root.push(\"src\").push(name),\n+        start_dir: root.join_many_str([\"src\", name.as_slice()]),\n         id: PkgId{ version: version, ..PkgId::new(name)},\n         // n.b. This assumes the package only has one crate\n         libs: ~[mk_crate(lib)],\n@@ -91,7 +91,7 @@ pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n-        start_dir: root.push(\"src\").push(name),\n+        start_dir: root.join_many_str([\"src\", name.as_slice()]),\n         id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[],\n         // n.b. This assumes the package only has one crate"}, {"sha": "41b04c389ae0520f1f91829cbf7dcc3da50ffdaf", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -123,7 +123,7 @@ impl Context {\n \n     /// Debugging\n     pub fn sysroot_str(&self) -> ~str {\n-        self.sysroot.to_str()\n+        self.sysroot.as_str().unwrap().to_owned()\n     }\n \n     // Hack so that rustpkg can run either out of a rustc target dir,\n@@ -132,7 +132,11 @@ impl Context {\n         if !in_target(&self.sysroot) {\n             self.sysroot.clone()\n         } else {\n-            self.sysroot.pop().pop().pop()\n+            let mut p = self.sysroot.clone();\n+            p.pop();\n+            p.pop();\n+            p.pop();\n+            p\n         }\n     }\n \n@@ -150,8 +154,10 @@ impl Context {\n /// rustpkg from a Rust target directory. This is part of a\n /// kludgy hack used to adjust the sysroot.\n pub fn in_target(sysroot: &Path) -> bool {\n-    debug2!(\"Checking whether {} is in target\", sysroot.to_str());\n-    os::path_is_dir(&sysroot.pop().pop().push(\"rustc\"))\n+    debug2!(\"Checking whether {} is in target\", sysroot.display());\n+    let mut p = sysroot.dir_path();\n+    p.set_filename_str(\"rustc\");\n+    os::path_is_dir(&p)\n }\n \n impl RustcFlags {"}, {"sha": "995f484a4e64feabfe39ecb76fb0a90ddb75ae0a", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -17,27 +17,33 @@ use std::os;\n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = os::list_dir(&p.push(\"bin\"));\n+        let binfiles = os::list_dir(&p.join_str(\"bin\"));\n         for exec in binfiles.iter() {\n-            let p = Path(*exec);\n-            let exec_path = p.filestem();\n-            do exec_path.iter().advance |s| {\n-                f(&PkgId::new(*s))\n-            };\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            match exec.filestem_str() {\n+                None => (),\n+                Some(exec_path) => {\n+                    if !f(&PkgId::new(exec_path)) {\n+                        return false;\n+                    }\n+                }\n+            }\n         }\n-        let libfiles = os::list_dir(&p.push(\"lib\"));\n+        let libfiles = os::list_dir(&p.join_str(\"lib\"));\n         for lib in libfiles.iter() {\n-            let lib = Path(*lib);\n-            debug2!(\"Full name: {}\", lib.to_str());\n-            match has_library(&lib) {\n+            debug2!(\"Full name: {}\", lib.display());\n+            match has_library(lib) {\n                 Some(basename) => {\n+                    let parent = p.join_str(\"lib\");\n                     debug2!(\"parent = {}, child = {}\",\n-                            p.push(\"lib\").to_str(), lib.to_str());\n-                    let rel_p = p.push(\"lib/\").get_relative_to(&lib);\n-                    debug2!(\"Rel: {}\", rel_p.to_str());\n-                    let rel_path = rel_p.push(basename).to_str();\n-                    debug2!(\"Rel name: {}\", rel_path);\n-                    f(&PkgId::new(rel_path));\n+                            parent.display(), lib.display());\n+                    let rel_p = lib.path_relative_from(&parent).unwrap();\n+                    debug2!(\"Rel: {}\", rel_p.display());\n+                    let rel_path = rel_p.join_str(basename);\n+                    do rel_path.with_display_str |s| {\n+                        debug2!(\"Rel name: {}\", s);\n+                        f(&PkgId::new(s));\n+                    }\n                 }\n                 None => ()\n             }\n@@ -48,10 +54,9 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n \n pub fn has_library(p: &Path) -> Option<~str> {\n     let files = os::list_dir(p);\n-    for q in files.iter() {\n-        let as_path = Path(*q);\n-        if as_path.filetype() == Some(os::consts::DLL_SUFFIX) {\n-            let stuff : &str = as_path.filestem().expect(\"has_library: weird path\");\n+    for path in files.iter() {\n+        if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n+            let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");\n             let mut stuff2 = stuff.split_str_iter(&\"-\");\n             let stuff3: ~[&str] = stuff2.collect();\n             // argh\n@@ -67,8 +72,10 @@ pub fn package_is_installed(p: &PkgId) -> bool {\n     do list_installed_packages() |installed| {\n         if installed == p {\n             is_installed = true;\n+            false\n+        } else {\n+            true\n         }\n-        false\n     };\n     is_installed\n }"}, {"sha": "bd22f1da913a9f09f33e06369388f71da937dfd8", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -59,14 +59,14 @@ impl PkgId {\n             }\n         };\n \n-        let path = Path(s);\n-        if path.is_absolute {\n+        let path = Path::from_str(s);\n+        if !path.is_relative() {\n             return cond.raise((path, ~\"absolute pkgid\"));\n         }\n-        if path.components.len() < 1 {\n+        if path.filename().is_none() {\n             return cond.raise((path, ~\"0-length pkgid\"));\n         }\n-        let short_name = path.filestem().expect(format!(\"Strange path! {}\", s));\n+        let short_name = path.filestem_str().expect(format!(\"Strange path! {}\", s));\n \n         let version = match given_version {\n             Some(v) => v,\n@@ -87,9 +87,11 @@ impl PkgId {\n     }\n \n     pub fn hash(&self) -> ~str {\n-        format!(\"{}-{}-{}\", self.path.to_str(),\n-                hash(self.path.to_str() + self.version.to_str()),\n-                self.version.to_str())\n+        // FIXME (#9639): hash should take a &[u8] so we can hash the real path\n+        do self.path.with_display_str |s| {\n+            let vers = self.version.to_str();\n+            format!(\"{}-{}-{}\", s, hash(s + vers), vers)\n+        }\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n@@ -98,7 +100,7 @@ impl PkgId {\n \n     /// True if the ID has multiple components\n     pub fn is_complex(&self) -> bool {\n-        self.short_name != self.path.to_str()\n+        self.short_name.as_bytes() != self.path.as_vec()\n     }\n \n     pub fn prefixes_iter(&self) -> Prefixes {\n@@ -115,7 +117,7 @@ impl PkgId {\n \n pub fn prefixes_iter(p: &Path) -> Prefixes {\n     Prefixes {\n-        components: p.components().to_owned(),\n+        components: p.str_component_iter().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n         remaining: ~[]\n     }\n }\n@@ -133,17 +135,18 @@ impl Iterator<(Path, Path)> for Prefixes {\n         }\n         else {\n             let last = self.components.pop();\n-            self.remaining.push(last);\n+            self.remaining.unshift(last);\n             // converting to str and then back is a little unfortunate\n-            Some((Path(self.components.to_str()), Path(self.remaining.to_str())))\n+            Some((Path::from_str(self.components.connect(\"/\")),\n+                  Path::from_str(self.remaining.connect(\"/\"))))\n         }\n     }\n }\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        format!(\"{}-{}\", self.path.to_str(), self.version.to_str())\n+        format!(\"{}-{}\", self.path.as_str().unwrap(), self.version.to_str())\n     }\n }\n "}, {"sha": "a924694cca5b21a250bd3839497c7fe6a97cad30", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -58,9 +58,9 @@ impl ToStr for PkgSrc {\n     fn to_str(&self) -> ~str {\n         format!(\"Package ID {} in start dir {} [workspaces = {} -> {}]\",\n                 self.id.to_str(),\n-                self.start_dir.to_str(),\n-                self.source_workspace.to_str(),\n-                self.destination_workspace.to_str())\n+                self.start_dir.display(),\n+                self.source_workspace.display(),\n+                self.destination_workspace.display())\n     }\n }\n condition! {\n@@ -79,8 +79,8 @@ impl PkgSrc {\n         debug2!(\"Checking package source for package ID {}, \\\n                 workspace = {} -> {}, use_rust_path_hack = {:?}\",\n                 id.to_str(),\n-                source_workspace.to_str(),\n-                destination_workspace.to_str(),\n+                source_workspace.display(),\n+                destination_workspace.display(),\n                 use_rust_path_hack);\n \n         let mut destination_workspace = destination_workspace.clone();\n@@ -94,22 +94,27 @@ impl PkgSrc {\n         } else {\n             // We search for sources under both src/ and build/ , because build/ is where\n             // automatically-checked-out sources go.\n-            let result = source_workspace.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n-                                                         id.short_name, id.version.to_str()));\n+            let mut result = source_workspace.join_str(\"src\");\n+            result.push_path(&id.path.dir_path());\n+            result.push_str(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            to_try.push(result);\n+            let mut result = source_workspace.join_str(\"src\");\n+            result.push_path(&id.path);\n             to_try.push(result);\n-            to_try.push(source_workspace.push(\"src\").push_rel(&id.path));\n \n-            let result = build_dir.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n-                                                         id.short_name, id.version.to_str()));\n+            let mut result = build_dir.join_str(\"src\");\n+            result.push_path(&id.path.dir_path());\n+            result.push_str(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n             to_try.push(result.clone());\n             output_names.push(result);\n-            let other_result = build_dir.push(\"src\").push_rel(&id.path);\n+            let mut other_result = build_dir.join_str(\"src\");\n+            other_result.push_path(&id.path);\n             to_try.push(other_result.clone());\n             output_names.push(other_result);\n \n         }\n \n-        debug2!(\"Checking dirs: {:?}\", to_try.map(|s| s.to_str()).connect(\":\"));\n+        debug2!(\"Checking dirs: {:?}\", to_try.map(|p| p.to_display_str()).connect(\":\"));\n \n         let path = to_try.iter().find(|&d| os::path_exists(d));\n \n@@ -123,14 +128,14 @@ impl PkgSrc {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n                 for (prefix, suffix) in id.prefixes_iter() {\n-                    let package_id = PkgId::new(prefix.to_str());\n-                    let path = build_dir.push_rel(&package_id.path);\n-                    debug2!(\"in loop: checking if {} is a directory\", path.to_str());\n+                    let package_id = PkgId::new(prefix.as_str().unwrap());\n+                    let path = build_dir.join_path(&package_id.path);\n+                    debug2!(\"in loop: checking if {} is a directory\", path.display());\n                     if os::path_is_dir(&path) {\n                         let ps = PkgSrc::new(source_workspace,\n                                              destination_workspace,\n                                              use_rust_path_hack,\n-                                             PkgId::new(prefix.to_str()));\n+                                             package_id);\n                         match ps {\n                             PkgSrc {\n                                 source_workspace: source,\n@@ -141,7 +146,7 @@ impl PkgSrc {\n                                     source_workspace: source.clone(),\n                                     build_in_destination: build_in_destination,\n                                     destination_workspace: destination,\n-                                    start_dir: start.push_rel(&suffix),\n+                                    start_dir: start.join_path(&suffix),\n                                     id: id,\n                                     libs: ~[],\n                                     mains: ~[],\n@@ -159,7 +164,7 @@ impl PkgSrc {\n                 // Ok, no prefixes work, so try fetching from git\n                 let mut ok_d = None;\n                 for w in output_names.iter() {\n-                    debug2!(\"Calling fetch_git on {}\", w.to_str());\n+                    debug2!(\"Calling fetch_git on {}\", w.display());\n                     let target_dir_opt = PkgSrc::fetch_git(w, &id);\n                     for p in target_dir_opt.iter() {\n                         ok_d = Some(p.clone());\n@@ -209,9 +214,9 @@ impl PkgSrc {\n             }\n         };\n         debug2!(\"3. build_in_destination = {:?}\", build_in_destination);\n-        debug2!(\"source: {} dest: {}\", source_workspace.to_str(), destination_workspace.to_str());\n+        debug2!(\"source: {} dest: {}\", source_workspace.display(), destination_workspace.display());\n \n-        debug2!(\"For package id {}, returning {}\", id.to_str(), dir.to_str());\n+        debug2!(\"For package id {}, returning {}\", id.to_str(), dir.display());\n \n         if !os::path_is_dir(&dir) {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n@@ -240,8 +245,8 @@ impl PkgSrc {\n         use conditions::git_checkout_failed::cond;\n \n         debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-                pkgid.to_str(), pkgid.path.to_str(),\n-                os::getcwd().to_str(),\n+                pkgid.to_str(), pkgid.path.display(),\n+                os::getcwd().display(),\n                 os::path_exists(&pkgid.path));\n \n         match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n@@ -250,14 +255,14 @@ impl PkgSrc {\n                 Some(local.clone())\n             }\n             DirToUse(clone_target) => {\n-                if pkgid.path.components().len() < 2 {\n+                if pkgid.path.component_iter().nth(1).is_none() {\n                     // If a non-URL, don't bother trying to fetch\n                     return None;\n                 }\n \n-                let url = format!(\"https://{}\", pkgid.path.to_str());\n+                let url = format!(\"https://{}\", pkgid.path.as_str().unwrap());\n                 debug2!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.to_str(), pkgid.version.to_str());\n+                        url, clone_target.display(), pkgid.version.to_str());\n \n                 let mut failed = false;\n \n@@ -273,7 +278,7 @@ impl PkgSrc {\n \n                 // Move clone_target to local.\n                 // First, create all ancestor directories.\n-                let moved = make_dir_rwx_recursive(&local.pop())\n+                let moved = make_dir_rwx_recursive(&local.dir_path())\n                     && os::rename_file(&clone_target, local);\n                 if moved { Some(local.clone()) }\n                     else { None }\n@@ -284,28 +289,31 @@ impl PkgSrc {\n     // If a file named \"pkg.rs\" in the start directory exists,\n     // return the path for it. Otherwise, None\n     pub fn package_script_option(&self) -> Option<Path> {\n-        let maybe_path = self.start_dir.push(\"pkg.rs\");\n-        debug2!(\"package_script_option: checking whether {} exists\", maybe_path.to_str());\n+        let maybe_path = self.start_dir.join_str(\"pkg.rs\");\n+        debug2!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n         if os::path_exists(&maybe_path) {\n             Some(maybe_path)\n-        }\n-        else {\n+        } else {\n             None\n         }\n     }\n \n     /// True if the given path's stem is self's pkg ID's stem\n     fn stem_matches(&self, p: &Path) -> bool {\n-        p.filestem().map_default(false, |p| { p == self.id.short_name.as_slice() })\n+        p.filestem().map_default(false, |p| { p == self.id.short_name.as_bytes() })\n     }\n \n     pub fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n-        assert!(p.components.len() > prefix);\n-        let mut sub = Path(\"\");\n-        for c in p.components.slice(prefix, p.components.len()).iter() {\n-            sub = sub.push(*c);\n+        let mut it = p.component_iter().peekable();\n+        if prefix > 0 {\n+            it.nth(prefix-1); // skip elements\n+        }\n+        assert!(it.peek().is_some());\n+        let mut sub = Path::from_str(\".\");\n+        for c in it {\n+            sub.push(c);\n         }\n-        debug2!(\"Will compile crate {}\", sub.to_str());\n+        debug2!(\"Will compile crate {}\", sub.display());\n         cs.push(Crate::new(&sub));\n     }\n \n@@ -318,10 +326,10 @@ impl PkgSrc {\n     pub fn find_crates_with_filter(&mut self, filter: &fn(&str) -> bool) {\n         use conditions::missing_pkg_files::cond;\n \n-        let prefix = self.start_dir.components.len();\n+        let prefix = self.start_dir.component_iter().len();\n         debug2!(\"Matching against {}\", self.id.short_name);\n         do os::walk_dir(&self.start_dir) |pth| {\n-            let maybe_known_crate_set = match pth.filename() {\n+            let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),\n                     \"main.rs\" => Some(&mut self.mains),\n@@ -349,7 +357,7 @@ impl PkgSrc {\n         }\n \n         debug2!(\"In {}, found {} libs, {} mains, {} tests, {} benchs\",\n-               self.start_dir.to_str(),\n+               self.start_dir.display(),\n                self.libs.len(),\n                self.mains.len(),\n                self.tests.len(),\n@@ -362,18 +370,17 @@ impl PkgSrc {\n                     cfgs: &[~str],\n                     what: OutputType) {\n         for crate in crates.iter() {\n-            let path = self.start_dir.push_rel(&crate.file).normalize();\n-            debug2!(\"build_crates: compiling {}\", path.to_str());\n-            let path_str = path.to_str();\n+            let path = self.start_dir.join_path(&crate.file);\n+            debug2!(\"build_crates: compiling {}\", path.display());\n             let cfgs = crate.cfgs + cfgs;\n \n             do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n-                debug2!(\"Building crate {}, declaring it as an input\", path.to_str());\n-                prep.declare_input(\"file\", path.to_str(),\n+                debug2!(\"Building crate {}, declaring it as an input\", path.display());\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                prep.declare_input(\"file\", path.as_str().unwrap(),\n                                    workcache_support::digest_file_with_date(&path));\n                 let subpath = path.clone();\n                 let subcfgs = cfgs.clone();\n-                let subpath_str = path_str.clone();\n                 let subcx = ctx.clone();\n                 let id = self.id.clone();\n                 let sub_dir = self.build_workspace().clone();\n@@ -387,9 +394,14 @@ impl PkgSrc {\n                                                sub_flags,\n                                                subcfgs,\n                                                false,\n-                                               what).to_str();\n-                    debug2!(\"Result of compiling {} was {}\", subpath_str, result);\n-                    result\n+                                               what);\n+                    // XXX: result is an Option<Path>. The following code did not take that\n+                    // into account. I'm not sure if the workcache really likes seeing the\n+                    // output as \"Some(\\\"path\\\")\". But I don't know what to do about it.\n+                    // FIXME (#9639): This needs to handle non-utf8 paths\n+                    let result = result.map(|p|p.as_str().unwrap());\n+                    debug2!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n+                    result.to_str()\n                 }\n             };\n         }\n@@ -403,10 +415,10 @@ impl PkgSrc {\n         debug2!(\"In declare inputs, self = {}\", self.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n-                let path = self.start_dir.push_rel(&c.file).normalize();\n-                debug2!(\"Declaring input: {}\", path.to_str());\n-                prep.declare_input(\"file\",\n-                                   path.to_str(),\n+                let path = self.start_dir.join_path(&c.file);\n+                debug2!(\"Declaring input: {}\", path.display());\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                prep.declare_input(\"file\", path.as_str().unwrap(),\n                                    workcache_support::digest_file_with_date(&path.clone()));\n             }\n         }\n@@ -422,7 +434,7 @@ impl PkgSrc {\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n         debug2!(\"Building libs in {}, destination = {}\",\n-               self.source_workspace.to_str(), self.build_workspace().to_str());\n+               self.source_workspace.display(), self.build_workspace().display());\n         self.build_crates(build_context, libs, cfgs, Lib);\n         debug2!(\"Building mains\");\n         self.build_crates(build_context, mains, cfgs, Main);\n@@ -447,7 +459,7 @@ impl PkgSrc {\n         let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n         for crate_set in crate_sets.iter() {\n             for c in crate_set.iter() {\n-                debug2!(\"Built crate: {}\", c.file.to_str())\n+                debug2!(\"Built crate: {}\", c.file.display())\n             }\n         }\n     }"}, {"sha": "34b387fc9a73d866af51b3e431da60dace67586b", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -53,7 +53,7 @@ pub fn make_dir_rwx_recursive(p: &Path) -> bool { os::mkdir_recursive(p, U_RWX)\n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    workspace_contains_package_id_(pkgid, workspace, |p| { p.push(\"src\") }).is_some()\n+    workspace_contains_package_id_(pkgid, workspace, |p| p.join_str(\"src\")).is_some()\n }\n \n pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n@@ -68,10 +68,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     let mut found = None;\n     do os::walk_dir(&src_dir) |p| {\n         if os::path_is_dir(p) {\n-            if *p == src_dir.push_rel(&pkgid.path) || {\n-                let pf = p.filename();\n-                do pf.iter().any |pf| {\n-                    let g = pf.to_str();\n+            if *p == src_dir.join_path(&pkgid.path) || {\n+                let pf = p.filename_str();\n+                do pf.iter().any |&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n@@ -89,30 +88,34 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     };\n \n     if found.is_some() {\n-        debug2!(\"Found {} in {}\", pkgid.to_str(), workspace.to_str());\n+        debug2!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n     } else {\n-        debug2!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.to_str());\n+        debug2!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.display());\n     }\n     found\n }\n \n /// Return the target-specific build subdirectory, pushed onto `base`;\n /// doesn't check that it exists or create it\n pub fn target_build_dir(workspace: &Path) -> Path {\n-    workspace.push(\"build\").push(host_triple())\n+    let mut dir = workspace.join_str(\"build\");\n+    dir.push_str(host_triple());\n+    dir\n }\n \n /// Return the target-specific lib subdirectory, pushed onto `base`;\n /// doesn't check that it exists or create it\n fn target_lib_dir(workspace: &Path) -> Path {\n-    workspace.push(\"lib\").push(host_triple())\n+    let mut dir = workspace.join_str(\"lib\");\n+    dir.push_str(host_triple());\n+    dir\n }\n \n /// Return the bin subdirectory, pushed onto `base`;\n /// doesn't check that it exists or create it\n /// note: this isn't target-specific\n fn target_bin_dir(workspace: &Path) -> Path {\n-    workspace.push(\"bin\")\n+    workspace.join_str(\"bin\")\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n@@ -121,12 +124,12 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n     let mut result = target_build_dir(workspace);\n     result = mk_output_path(Main, Build, pkgid, result);\n     debug2!(\"built_executable_in_workspace: checking whether {} exists\",\n-           result.to_str());\n+           result.display());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        debug2!(\"built_executable_in_workspace: {} does not exist\", result.to_str());\n+        debug2!(\"built_executable_in_workspace: {} does not exist\", result.display());\n         None\n     }\n }\n@@ -148,12 +151,12 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     // should use a target-specific subdirectory\n     result = mk_output_path(what, Build, pkgid, result);\n     debug2!(\"output_in_workspace: checking whether {} exists\",\n-           result.to_str());\n+           result.display());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        error2!(\"output_in_workspace: {} does not exist\", result.to_str());\n+        error2!(\"output_in_workspace: {} does not exist\", result.display());\n         None\n     }\n }\n@@ -167,7 +170,8 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Option<Path> {\n     // This could break once we're handling multiple versions better -- I should add a test for it\n-    match pkg_path.filename() {\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    match pkg_path.filename_str() {\n         None => None,\n         Some(short_name) => library_in_workspace(pkg_path,\n                                                  short_name,\n@@ -189,10 +193,10 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n     // contents\n \n     debug2!(\"short_name = {} where = {:?} workspace = {} \\\n-            prefix = {}\", short_name, where, workspace.to_str(), prefix);\n+            prefix = {}\", short_name, where, workspace.display(), prefix);\n \n     let dir_to_search = match where {\n-        Build => target_build_dir(workspace).push_rel(path),\n+        Build => target_build_dir(workspace).join_path(path),\n         Install => target_lib_dir(workspace)\n     };\n \n@@ -201,28 +205,24 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n \n // rustc doesn't use target-specific subdirectories\n pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n-    library_in(lib_name, &NoVersion, &sysroot.push(\"lib\"))\n+    library_in(lib_name, &NoVersion, &sysroot.join_str(\"lib\"))\n }\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n-    debug2!(\"Listing directory {}\", dir_to_search.to_str());\n+    debug2!(\"Listing directory {}\", dir_to_search.display());\n     let dir_contents = os::list_dir(dir_to_search);\n     debug2!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n-    let lib_filetype = os::consts::DLL_SUFFIX;\n+    let lib_filetype = os::consts::DLL_EXTENSION;\n \n     debug2!(\"lib_prefix = {} and lib_filetype = {}\", lib_prefix, lib_filetype);\n \n     // Find a filename that matches the pattern:\n     // (lib_prefix)-hash-(version)(lib_suffix)\n-    let paths = do dir_contents.iter().map |p| {\n-        Path((*p).clone())\n-    };\n-\n-    let mut libraries = do paths.filter |p| {\n-        let extension = p.filetype();\n-        debug2!(\"p = {}, p's extension is {:?}\", p.to_str(), extension);\n+    let mut libraries = do dir_contents.iter().filter |p| {\n+        let extension = p.extension_str();\n+        debug2!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n         match extension {\n             None => false,\n             Some(ref s) => lib_filetype == *s\n@@ -233,7 +233,7 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     for p_path in libraries {\n         // Find a filename that matches the pattern: (lib_prefix)-hash-(version)(lib_suffix)\n         // and remember what the hash was\n-        let mut f_name = match p_path.filestem() {\n+        let mut f_name = match p_path.filestem_str() {\n             Some(s) => s, None => continue\n         };\n         // Already checked the filetype above\n@@ -267,14 +267,14 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     if result_filename.is_none() {\n         debug2!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n-                  dir_to_search.to_str(), short_name);\n+                  dir_to_search.display(), short_name);\n     }\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     let abs_path = do result_filename.map |result_filename| {\n-        let absolute_path = dir_to_search.push_rel(&result_filename);\n-        debug2!(\"result_filename = {}\", absolute_path.to_str());\n+        let absolute_path = dir_to_search.join_path(&result_filename);\n+        debug2!(\"result_filename = {}\", absolute_path.display());\n         absolute_path\n     };\n \n@@ -297,7 +297,7 @@ pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     if !os::path_is_dir(workspace) {\n         cond.raise(((*workspace).clone(),\n                     format!(\"Workspace supplied to target_library_in_workspace \\\n-                             is not a directory! {}\", workspace.to_str())));\n+                             is not a directory! {}\", workspace.display())));\n     }\n     target_file_in_workspace(pkgid, workspace, Lib, Install)\n }\n@@ -329,14 +329,14 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match (where, what) {\n-                (Build, _)         => target_build_dir(workspace).push_rel(&pkgid.path),\n-                (Install, Lib)     => target_lib_dir(workspace),\n+                (Build, _)      => target_build_dir(workspace).join_path(&pkgid.path),\n+                (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n         cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n             create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n-            subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n+            subdir, pkgid.to_str(), workspace.display(), what, where)));\n     }\n     mk_output_path(what, where, pkgid, result)\n }\n@@ -347,8 +347,8 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n \n     let mut result = target_build_dir(workspace);\n-    result = result.push_rel(&pkgid.path);\n-    debug2!(\"Creating build dir {} for package id {}\", result.to_str(),\n+    result.push_path(&pkgid.path);\n+    debug2!(\"Creating build dir {} for package id {}\", result.display(),\n            pkgid.to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n@@ -370,16 +370,16 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // If we're installing, it just goes under <workspace>...\n         Install => workspace,\n         // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.push_rel(&pkg_id.path)\n+        Build => workspace.join_path(&pkg_id.path)\n     };\n     debug2!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n-           dir.to_str());\n+           dir.display());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n-        Lib => dir.push(os::dll_filename(short_name_with_version)),\n+        Lib => dir.join_str(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.push(format!(\"{}{}{}\", pkg_id.short_name,\n+        _ => dir.join_str(format!(\"{}{}{}\", pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n@@ -388,9 +388,9 @@ pub fn mk_output_path(what: OutputType, where: Target,\n                            os::EXE_SUFFIX))\n     };\n     if !output_path.is_absolute() {\n-        output_path = os::getcwd().push_rel(&output_path).normalize();\n+        output_path = os::getcwd().join_path(&output_path);\n     }\n-    debug2!(\"mk_output_path: returning {}\", output_path.to_str());\n+    debug2!(\"mk_output_path: returning {}\", output_path.display());\n     output_path\n }\n \n@@ -409,14 +409,14 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n     }\n     if !did_something {\n         warn(format!(\"Warning: there don't seem to be any files for {} installed in {}\",\n-             pkgid.to_str(), workspace.to_str()));\n+             pkgid.to_str(), workspace.display()));\n     }\n \n }\n \n fn dir_has_file(dir: &Path, file: &str) -> bool {\n     assert!(dir.is_absolute());\n-    os::path_exists(&dir.push(file))\n+    os::path_exists(&dir.join_str(file))\n }\n \n pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n@@ -425,15 +425,15 @@ pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n         // Require that the parent directory match the package ID\n         // Note that this only matches if the package ID being searched for\n         // has a name that's a single component\n-        if dir.is_parent_of(&p.path) || dir.is_parent_of(&versionize(&p.path, &p.version)) {\n-            debug2!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.to_str());\n+        if dir.ends_with_path(&p.path) || dir.ends_with_path(&versionize(&p.path, &p.version)) {\n+            debug2!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.display());\n             if dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n                 || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\") {\n-                debug2!(\"Did find id {} in dir {}\", p.to_str(), dir.to_str());\n+                debug2!(\"Did find id {} in dir {}\", p.to_str(), dir.display());\n                 return Some(dir.clone());\n             }\n         }\n-        debug2!(\"Didn't find id {} in dir {}\", p.to_str(), dir.to_str())\n+        debug2!(\"Didn't find id {} in dir {}\", p.to_str(), dir.display())\n     }\n     None\n }\n@@ -449,8 +449,12 @@ pub fn user_set_rust_path() -> bool {\n \n /// Append the version string onto the end of the path's filename\n pub fn versionize(p: &Path, v: &Version) -> Path {\n-    let q = p.file_path().to_str();\n-    p.with_filename(format!(\"{}-{}\", q, v.to_str()))\n+    let q = p.file_path().expect(\"path is a directory\");\n+    let mut q = q.as_vec().to_owned();\n+    q.push('-' as u8);\n+    let vs = v.to_str();\n+    q.push_all(vs.as_bytes());\n+    p.with_filename(q)\n }\n \n "}, {"sha": "47a65753cc9570b22011cc148887a2382ac54ed2", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 80, "deletions": 61, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -105,7 +105,7 @@ impl<'self> PkgScript<'self> {\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n-        debug2!(\"pkgscript parse: {}\", sysroot.to_str());\n+        debug2!(\"pkgscript parse: {}\", sysroot.display());\n         let options = @session::options {\n             binary: binary,\n             maybe_sysroot: Some(sysroot),\n@@ -141,31 +141,36 @@ impl<'self> PkgScript<'self> {\n                   sysroot: &Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n-        debug2!(\"Working directory = {}\", self.build_dir.to_str());\n+        debug2!(\"Working directory = {}\", self.build_dir.display());\n         // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate.take_unwrap());\n         debug2!(\"Building output filenames with script name {}\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n-        let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n+        let exe = self.build_dir.join_str(\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n                                        exec,\n                                        Nothing,\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug2!(\"Running program: {} {} {}\", exe.to_str(),\n-               sysroot.to_str(), \"install\");\n+        debug2!(\"Running program: {} {} {}\", exe.display(),\n+               sysroot.display(), \"install\");\n         // Discover the output\n-        exec.discover_output(\"binary\", exe.to_str(), digest_only_date(&exe));\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        exec.discover_output(\"binary\", exe.as_str().unwrap(), digest_only_date(&exe));\n         // FIXME #7401 should support commands besides `install`\n-        let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        let status = run::process_status(exe.as_str().unwrap(),\n+                                         [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n         if status != 0 {\n             return (~[], status);\n         }\n         else {\n             debug2!(\"Running program (configs): {} {} {}\",\n-                   exe.to_str(), sysroot.to_str(), \"configs\");\n-            let output = run::process_output(exe.to_str(), [sysroot.to_str(), ~\"configs\"]);\n+                   exe.display(), sysroot.display(), \"configs\");\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let output = run::process_output(exe.as_str().unwrap(),\n+                                             [sysroot.as_str().unwrap().to_owned(), ~\"configs\"]);\n             // Run the configs() function to get the configs\n             let cfgs = str::from_utf8_slice(output.output).word_iter()\n                 .map(|w| w.to_owned()).collect();\n@@ -208,7 +213,8 @@ impl CtxMethods for BuildContext {\n             match cwd_to_workspace() {\n                 None if self.context.use_rust_path_hack => {\n                     let cwd = os::getcwd();\n-                    let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n+                    // FIXME (#9639): This needs to handle non-utf8 paths\n+                    let pkgid = PkgId::new(cwd.filename_str().unwrap());\n                     let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, pkgid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n@@ -237,13 +243,12 @@ impl CtxMethods for BuildContext {\n             let mut dest_ws = default_workspace();\n             do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                 debug2!(\"found pkg {} in workspace {}, trying to build\",\n-                       pkgid.to_str(), workspace.to_str());\n+                       pkgid.to_str(), workspace.display());\n                 dest_ws = determine_destination(os::getcwd(),\n                                                 self.context.use_rust_path_hack,\n                                                 workspace);\n-                let mut pkg_src = PkgSrc::new(workspace.clone(), dest_ws.clone(),\n-                                              false, pkgid.clone());\n-                self.build(&mut pkg_src, what);\n+                let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n+                dest_ws = Some(self.build(&mut pkg_src, what));\n                 true\n             };\n             // n.b. If this builds multiple packages, it only returns the workspace for\n@@ -290,8 +295,9 @@ impl CtxMethods for BuildContext {\n                     match cwd_to_workspace() {\n                         None if self.context.use_rust_path_hack => {\n                             let cwd = os::getcwd();\n+                            // FIXME (#9639): This needs to handle non-utf8 paths\n                             let inferred_pkgid =\n-                                PkgId::new(cwd.components[cwd.components.len() - 1]);\n+                                PkgId::new(cwd.filename_str().unwrap());\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n                                                      true, inferred_pkgid), &Everything);\n                         }\n@@ -331,7 +337,9 @@ impl CtxMethods for BuildContext {\n             \"list\" => {\n                 io::println(\"Installed packages:\");\n                 do installed_packages::list_installed_packages |pkg_id| {\n-                    println(pkg_id.path.to_str());\n+                    do pkg_id.path.with_display_str |s| {\n+                        println(s);\n+                    }\n                     true\n                 };\n             }\n@@ -379,7 +387,7 @@ impl CtxMethods for BuildContext {\n                     do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(format!(\"Uninstalled package {} (was installed in {})\",\n-                                  pkgid.to_str(), workspace.to_str()));\n+                                  pkgid.to_str(), workspace.display()));\n                         true\n                     };\n                 }\n@@ -407,23 +415,25 @@ impl CtxMethods for BuildContext {\n         let pkgid = pkg_src.id.clone();\n \n         debug2!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n-                pkgid = {} pkgsrc start_dir = {}\", workspace.to_str(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n-               pkgid.to_str(), pkg_src.start_dir.to_str());\n+                pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n+               in_rust_path(&workspace), is_git_dir(&workspace.join_path(&pkgid.path)),\n+               pkgid.to_str(), pkg_src.start_dir.display());\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.push_rel(&pkgid.path)) {\n-            let out_dir = default_workspace().push(\"src\").push_rel(&pkgid.path);\n-            let git_result = source_control::safe_git_clone(&workspace.push_rel(&pkgid.path),\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.join_path(&pkgid.path)) {\n+            let mut out_dir = default_workspace().join_str(\"src\");\n+            out_dir.push_path(&pkgid.path);\n+            let git_result = source_control::safe_git_clone(&workspace.join_path(&pkgid.path),\n                                                             &pkgid.version,\n                                                             &out_dir);\n             match git_result {\n                 CheckedOutSources => make_read_only(&out_dir),\n-                _ => cond.raise((pkgid.path.to_str(), out_dir.clone()))\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                _ => cond.raise((pkgid.path.as_str().unwrap(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n-            debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.to_str(),\n+            debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n                    pkgid.to_str());\n             return self.build(&mut PkgSrc::new(default_ws.clone(),\n                                                default_ws,\n@@ -439,8 +449,10 @@ impl CtxMethods for BuildContext {\n         let cfgs = match pkg_src.package_script_option() {\n             Some(package_script_path) => {\n                 let sysroot = self.sysroot_to_use();\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                let pkg_script_path_str = package_script_path.as_str().unwrap();\n                 let (cfgs, hook_result) =\n-                    do self.workcache_context.with_prep(package_script_path.to_str()) |prep| {\n+                    do self.workcache_context.with_prep(pkg_script_path_str) |prep| {\n                     let sub_sysroot = sysroot.clone();\n                     let package_script_path_clone = package_script_path.clone();\n                     let sub_ws = workspace.clone();\n@@ -476,13 +488,13 @@ impl CtxMethods for BuildContext {\n                 // Find crates inside the workspace\n                 &Everything => pkg_src.find_crates(),\n                 // Find only tests\n-                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path(s)) }),\n+                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::from_str(s)) }),\n                 // Don't infer any crates -- just build the one that was requested\n                 &JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n-                    debug2!(\"JustOne: p = {}\", p.to_str());\n-                    assert!(os::path_exists(&pkg_src.start_dir.push_rel(p)));\n+                    debug2!(\"JustOne: p = {}\", p.display());\n+                    assert!(os::path_exists(&pkg_src.start_dir.join_path(p)));\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n                     } else if is_main(p) {\n@@ -492,7 +504,7 @@ impl CtxMethods for BuildContext {\n                     } else if is_bench(p) {\n                         PkgSrc::push_crate(&mut pkg_src.benchs, 0, p);\n                     } else {\n-                        warn(format!(\"Not building any crates for dependency {}\", p.to_str()));\n+                        warn(format!(\"Not building any crates for dependency {}\", p.display()));\n                         return;\n                     }\n                 }\n@@ -509,10 +521,10 @@ impl CtxMethods for BuildContext {\n \n         let dir = build_pkg_id_in_workspace(id, workspace);\n         note(format!(\"Cleaning package {} (removing directory {})\",\n-                        id.to_str(), dir.to_str()));\n+                        id.to_str(), dir.display()));\n         if os::path_exists(&dir) {\n             os::remove_dir_recursive(&dir);\n-            note(format!(\"Removed directory {}\", dir.to_str()));\n+            note(format!(\"Removed directory {}\", dir.display()));\n         }\n \n         note(format!(\"Cleaned package {}\", id.to_str()));\n@@ -541,21 +553,22 @@ impl CtxMethods for BuildContext {\n         debug2!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n-                let path = pkg_src.start_dir.push_rel(&c.file).normalize();\n-                debug2!(\"Recording input: {}\", path.to_str());\n-                inputs.push((~\"file\", path.to_str()));\n+                let path = pkg_src.start_dir.join_path(&c.file);\n+                debug2!(\"Recording input: {}\", path.display());\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                inputs.push((~\"file\", path.as_str().unwrap().to_owned()));\n             }\n         }\n \n         let result = self.install_no_build(pkg_src.build_workspace(),\n                                            &pkg_src.destination_workspace,\n-                                           &id).map(|s| Path(*s));\n+                                           &id).map(|s| Path::from_str(*s));\n         debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n-               id.to_str(), result.to_str());\n+               id.to_str(), result.map(|p| p.to_display_str()));\n         installed_files = installed_files + result;\n         note(format!(\"Installed package {} to {}\",\n                      id.to_str(),\n-                     pkg_src.destination_workspace.to_str()));\n+                     pkg_src.destination_workspace.display()));\n         (installed_files, inputs)\n     }\n \n@@ -578,18 +591,20 @@ impl CtxMethods for BuildContext {\n \n         debug2!(\"target_exec = {} target_lib = {:?} \\\n                maybe_executable = {:?} maybe_library = {:?}\",\n-               target_exec.to_str(), target_lib,\n+               target_exec.display(), target_lib,\n                maybe_executable, maybe_library);\n \n         do self.workcache_context.with_prep(id.install_tag()) |prep| {\n             for ee in maybe_executable.iter() {\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"binary\",\n-                                   ee.to_str(),\n+                                   ee.as_str().unwrap(),\n                                    workcache_support::digest_only_date(ee));\n             }\n             for ll in maybe_library.iter() {\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"binary\",\n-                                   ll.to_str(),\n+                                   ll.as_str().unwrap(),\n                                    workcache_support::digest_only_date(ll));\n             }\n             let subex = maybe_executable.clone();\n@@ -601,31 +616,32 @@ impl CtxMethods for BuildContext {\n                 let mut outputs = ~[];\n \n                 for exec in subex.iter() {\n-                    debug2!(\"Copying: {} -> {}\", exec.to_str(), sub_target_ex.to_str());\n+                    debug2!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n                     if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n                          os::copy_file(exec, &sub_target_ex)) {\n                         cond.raise(((*exec).clone(), sub_target_ex.clone()));\n                     }\n+                    // FIXME (#9639): This needs to handle non-utf8 paths\n                     exe_thing.discover_output(\"binary\",\n-                        sub_target_ex.to_str(),\n+                        sub_target_ex.as_str().unwrap(),\n                         workcache_support::digest_only_date(&sub_target_ex));\n-                    outputs.push(sub_target_ex.to_str());\n+                    outputs.push(sub_target_ex.as_str().unwrap().to_owned());\n                 }\n                 for lib in sublib.iter() {\n-                    let target_lib = sub_target_lib\n+                    let mut target_lib = sub_target_lib\n                         .clone().expect(format!(\"I built {} but apparently \\\n-                                             didn't install it!\", lib.to_str()));\n+                                             didn't install it!\", lib.display()));\n                     let target_lib = target_lib\n-                        .pop().push(lib.filename().expect(\"weird target lib\"));\n+                        .set_filename(lib.filename().expect(\"weird target lib\"));\n                     if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                          os::copy_file(lib, &target_lib)) {\n                         cond.raise(((*lib).clone(), target_lib.clone()));\n                     }\n-                    debug2!(\"3. discovering output {}\", target_lib.to_str());\n+                    debug2!(\"3. discovering output {}\", target_lib.display());\n                     exe_thing.discover_output(\"binary\",\n-                                              target_lib.to_str(),\n+                                              target_lib.as_str().unwrap(),\n                                               workcache_support::digest_only_date(&target_lib));\n-                    outputs.push(target_lib.to_str());\n+                    outputs.push(target_lib.as_str().unwrap().to_owned());\n                 }\n                 outputs\n             }\n@@ -639,23 +655,24 @@ impl CtxMethods for BuildContext {\n     fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n         match built_test_in_workspace(pkgid, workspace) {\n             Some(test_exec) => {\n-                debug2!(\"test: test_exec = {}\", test_exec.to_str());\n-                let status = run::process_status(test_exec.to_str(), [~\"--test\"]);\n+                debug2!(\"test: test_exec = {}\", test_exec.display());\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                let status = run::process_status(test_exec.as_str().unwrap(), [~\"--test\"]);\n                 os::set_exit_status(status);\n             }\n             None => {\n                 error(format!(\"Internal error: test executable for package ID {} in workspace {} \\\n                            wasn't built! Please report this as a bug.\",\n-                           pkgid.to_str(), workspace.to_str()));\n+                           pkgid.to_str(), workspace.display()));\n             }\n         }\n     }\n \n     fn init(&self) {\n-        os::mkdir_recursive(&Path(\"src\"),   U_RWX);\n-        os::mkdir_recursive(&Path(\"lib\"),   U_RWX);\n-        os::mkdir_recursive(&Path(\"bin\"),   U_RWX);\n-        os::mkdir_recursive(&Path(\"build\"), U_RWX);\n+        os::mkdir_recursive(&Path::from_str(\"src\"),   U_RWX);\n+        os::mkdir_recursive(&Path::from_str(\"lib\"),   U_RWX);\n+        os::mkdir_recursive(&Path::from_str(\"bin\"),   U_RWX);\n+        os::mkdir_recursive(&Path::from_str(\"build\"), U_RWX);\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n@@ -835,12 +852,13 @@ pub fn main_args(args: &[~str]) -> int {\n     let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n     remaining_args.shift();\n     let sroot = match supplied_sysroot {\n-        Some(getopts::Val(s)) => Path(s),\n+        Some(getopts::Val(s)) => Path::from_str(s),\n         _ => filesearch::get_or_default_sysroot()\n     };\n \n-    debug2!(\"Using sysroot: {}\", sroot.to_str());\n-    debug2!(\"Will store workcache in {}\", default_workspace().to_str());\n+    debug2!(\"Using sysroot: {}\", sroot.display());\n+    let ws = default_workspace();\n+    debug2!(\"Will store workcache in {}\", ws.display());\n \n     let rm_args = remaining_args.clone();\n     let sub_cmd = cmd.clone();\n@@ -866,7 +884,8 @@ pub fn main_args(args: &[~str]) -> int {\n \n fn declare_package_script_dependency(prep: &mut workcache::Prep, pkg_src: &PkgSrc) {\n     match pkg_src.package_script_option() {\n-        Some(ref p) => prep.declare_input(\"file\", p.to_str(),\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        Some(ref p) => prep.declare_input(\"file\", p.as_str().unwrap(),\n                                       workcache_support::digest_file_with_date(p)),\n         None => ()\n     }"}, {"sha": "080ba461f05fb176600c388df5b93c9cfafe7d30", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -18,7 +18,7 @@ use version::Version;\n pub fn find_installed_library_in_rust_path(pkg_path: &Path, _version: &Version) -> Option<Path> {\n     let rp = rust_path();\n     debug2!(\"find_installed_library_in_rust_path: looking for path {}\",\n-            pkg_path.to_str());\n+            pkg_path.display());\n     for p in rp.iter() {\n         match installed_library_in_workspace(pkg_path, p) {\n             Some(path) => return Some(path),"}, {"sha": "b910c07920508da1608465168021b006f3e7164f", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -24,14 +24,17 @@ use path_util::chmod_read_only;\n pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n     if os::path_exists(source) {\n         debug2!(\"{} exists locally! Cloning it into {}\",\n-                source.to_str(), target.to_str());\n+                source.display(), target.display());\n         // Ok to use target here; we know it will succeed\n         assert!(os::path_is_dir(source));\n         assert!(is_git_dir(source));\n \n         if !os::path_exists(target) {\n-            debug2!(\"Running: git clone {} {}\", source.to_str(), target.to_str());\n-            let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n+            debug2!(\"Running: git clone {} {}\", source.display(), target.display());\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let outp = run::process_output(\"git\", [~\"clone\",\n+                                                   source.as_str().unwrap().to_owned(),\n+                                                   target.as_str().unwrap().to_owned()]);\n             if outp.status != 0 {\n                 io::println(str::from_utf8_owned(outp.output.clone()));\n                 io::println(str::from_utf8_owned(outp.error));\n@@ -40,11 +43,13 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                 else {\n                 match v {\n                     &ExactRevision(ref s) => {\n+                        let git_dir = target.join_str(\".git\");\n                         debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n-                                *s, target.to_str(), target.push(\".git\").to_str());\n+                                *s, target.display(), git_dir.display());\n+                        // FIXME (#9639: This needs to handle non-utf8 paths\n                         let outp = run::process_output(\"git\",\n-                            [format!(\"--work-tree={}\", target.to_str()),\n-                             format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                            [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n+                             format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                              ~\"checkout\", format!(\"{}\", *s)]);\n                         if outp.status != 0 {\n                             io::println(str::from_utf8_owned(outp.output.clone()));\n@@ -59,11 +64,13 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             // Check that no version was specified. There's no reason to not handle the\n             // case where a version was requested, but I haven't implemented it.\n             assert!(*v == NoVersion);\n+            let git_dir = target.join_str(\".git\");\n             debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n-                    target.to_str(), target.push(\".git\").to_str(), source.to_str());\n-            let args = [format!(\"--work-tree={}\", target.to_str()),\n-                        format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n-                        ~\"pull\", ~\"--no-edit\", source.to_str()];\n+                    target.display(), git_dir.display(), source.display());\n+            // FIXME (#9639: This needs to handle non-utf8 paths\n+            let args = [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n+                        format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n+                        ~\"pull\", ~\"--no-edit\", source.as_str().unwrap().to_owned()];\n             let outp = run::process_output(\"git\", args);\n             assert!(outp.status == 0);\n         }\n@@ -73,7 +80,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n \n         let scratch_dir = TempDir::new(\"rustpkg\");\n         let clone_target = match scratch_dir {\n-            Some(d) => d.unwrap().push(\"rustpkg_temp\"),\n+            Some(d) => d.unwrap().join_str(\"rustpkg_temp\"),\n             None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n         };\n \n@@ -109,7 +116,7 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     else {\n         match v {\n             &ExactRevision(ref s) | &Tagged(ref s) => {\n-                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", format!(\"{}\", *s)],\n+                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n                                                          target);\n                     if outp.status != 0 {\n                         debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n@@ -129,5 +136,5 @@ fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput\n }\n \n pub fn is_git_dir(p: &Path) -> bool {\n-    os::path_is_dir(&p.push(\".git\"))\n+    os::path_is_dir(&p.join_str(\".git\"))\n }"}, {"sha": "9f371a865356bbc1ce0533162ceefce274400cce", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -50,13 +50,13 @@ pub fn is_bench(p: &Path) -> bool {\n \n fn file_is(p: &Path, stem: &str) -> bool {\n     match p.filestem() {\n-        Some(s) if s == stem => true,\n+        Some(s) if s == stem.as_bytes() => true,\n         _ => false\n     }\n }\n \n pub fn lib_name_of(p: &Path) -> Path {\n-    p.push(\"lib.rs\")\n+    p.join_str(\"lib.rs\")\n }\n \n pub static lib_crate_filename: &'static str = \"lib.rs\";"}, {"sha": "de7ad9dc06b58ea4de837970a060c69690cfb4f8", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 424, "deletions": 333, "changes": 757, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -41,7 +41,7 @@ use util::datestamp;\n \n fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     let context = workcache::Context::new(\n-        RWArc::new(Database::new(workspace.push(\"rustpkg_db.json\"))),\n+        RWArc::new(Database::new(workspace.join_str(\"rustpkg_db.json\"))),\n         RWArc::new(Logger::new()),\n         Arc::new(TreeMap::new()));\n     BuildContext {\n@@ -59,23 +59,23 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n     PkgId {\n-        path: Path(sn),\n+        path: Path::from_str(sn),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg() -> PkgId {\n     PkgId {\n-        path: Path(\"mockgithub.com/catamorphism/test-pkg\"),\n+        path: Path::from_str(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n     PkgId {\n-        path: Path(\"mockgithub.com/catamorphism/test-pkg\"),\n+        path: Path::from_str(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n     }\n@@ -101,35 +101,36 @@ fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> TempDi\n \n fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n     // include version number in directory name\n-    let package_dir = workspace.push_many([~\"src\", format!(\"{}-{}\",\n-                                                short_name.to_str(), version.to_str())]);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let package_dir = workspace.join_many_str([~\"src\", format!(\"{}-{}\",\n+                                                short_name.as_str().unwrap(), version.to_str())]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n     let workspace_dir = mk_empty_workspace(short_name, version, \"temp_workspace\");\n-    let package_dir = workspace_dir.path().push_many([~\"src\",\n-                                                      format!(\"{}-{}\",\n-                                                              short_name.to_str(),\n-                                                              version.to_str())]);\n+    let package_dir = workspace_dir.path().join_many_str([~\"src\",\n+                                                          format!(\"{}-{}\",\n+                                                                  short_name.to_str(),\n+                                                                  version.to_str())]);\n \n-    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n-    debug2!(\"mk_workspace: creating {}\", package_dir.to_str());\n+    debug2!(\"mk_workspace: creating {}\", package_dir.display());\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n-    writeFile(&package_dir.push(\"main.rs\"),\n+    writeFile(&package_dir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.push(\"lib.rs\"),\n+    writeFile(&package_dir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.push(\"test.rs\"),\n+    writeFile(&package_dir.join_str(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.push(\"bench.rs\"),\n+    writeFile(&package_dir.join_str(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     (workspace_dir, package_dir)\n }\n@@ -153,18 +154,18 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n /// Should create an empty git repo in p, relative to the tmp dir, and return the new\n /// absolute path\n fn init_git_repo(p: &Path) -> TempDir {\n-    assert!(!p.is_absolute());\n+    assert!(p.is_relative());\n     let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n-    let work_dir = tmp.path().push_rel(p);\n+    let work_dir = tmp.path().join_path(p);\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n-    debug2!(\"Running: git init in {}\", work_dir.to_str());\n-    let ws = work_dir.to_str();\n+    debug2!(\"Running: git init in {}\", work_dir.display());\n     run_git([~\"init\"], None, &work_dir_for_opts,\n-        format!(\"Couldn't initialize git repository in {}\", ws));\n+        format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n     // Add stuff to the dir so that git tag succeeds\n-    writeFile(&work_dir.push(\"README\"), \"\");\n-    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, format!(\"Couldn't add in {}\", ws));\n+    writeFile(&work_dir.join_str(\"README\"), \"\");\n+    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, format!(\"Couldn't add in {}\",\n+                                                                work_dir.display()));\n     git_commit(&work_dir_for_opts, ~\"whatever\");\n     tmp\n }\n@@ -176,19 +177,19 @@ fn add_all_and_commit(repo: &Path) {\n \n fn git_commit(repo: &Path, msg: ~str) {\n     run_git([~\"commit\", ~\"--author=tester <test@mozilla.com>\", ~\"-m\", msg],\n-            None, repo, format!(\"Couldn't commit in {}\", repo.to_str()));\n+            None, repo, format!(\"Couldn't commit in {}\", repo.display()));\n }\n \n fn git_add_all(repo: &Path) {\n-    run_git([~\"add\", ~\"-A\"], None, repo, format!(\"Couldn't add all files in {}\", repo.to_str()));\n+    run_git([~\"add\", ~\"-A\"], None, repo, format!(\"Couldn't add all files in {}\", repo.display()));\n }\n \n fn add_git_tag(repo: &Path, tag: ~str) {\n     assert!(repo.is_absolute());\n     git_add_all(repo);\n     git_commit(repo, ~\"whatever\");\n     run_git([~\"tag\", tag.clone()], None, repo,\n-            format!(\"Couldn't add git tag {} in {}\", tag, repo.to_str()));\n+            format!(\"Couldn't add git tag {} in {}\", tag, repo.display()));\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -215,24 +216,29 @@ fn is_read_only(p: &Path) -> bool {\n     }\n }\n \n+fn ends_with(v: &[u8], needle: &[u8]) -> bool {\n+    v.len() >= needle.len() && v.slice_from(v.len() - needle.len()) == needle\n+}\n+\n fn test_sysroot() -> Path {\n     // Totally gross hack but it's just for test cases.\n     // Infer the sysroot from the exe name and pray that it's right.\n     // (Did I mention it was a gross hack?)\n-    let self_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n-    self_path.pop()\n+    let mut self_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n+    self_path.pop();\n+    self_path\n }\n \n // Returns the path to rustpkg\n fn rustpkg_exec() -> Path {\n     // Ugh\n-    let first_try = test_sysroot().push_many(\n+    let first_try = test_sysroot().join_many_str(\n         [~\"lib\", ~\"rustc\", host_triple(), ~\"bin\", ~\"rustpkg\"]);\n     if is_executable(&first_try) {\n         first_try\n     }\n     else {\n-        let second_try = test_sysroot().push_many([~\"bin\", ~\"rustpkg\"]);\n+        let second_try = test_sysroot().join_many_str([\"bin\", \"rustpkg\"]);\n         if is_executable(&second_try) {\n             second_try\n         }\n@@ -275,12 +281,14 @@ enum ProcessResult {\n /// Returns the process's output.\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n     -> ProcessResult {\n-    let cmd = rustpkg_exec().to_str();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let exec_path = rustpkg_exec();\n+    let cmd = exec_path.as_str().unwrap().to_owned();\n     let env_str = match env {\n         Some(ref pairs) => pairs.map(|&(ref k, ref v)| { format!(\"{}={}\", *k, *v) }).connect(\",\"),\n         None        => ~\"\"\n     };\n-    debug2!(\"{} cd {}; {} {}\", env_str, cwd.to_str(), cmd, args.connect(\" \"));\n+    debug2!(\"{} cd {}; {} {}\", env_str, cwd.display(), cmd, args.connect(\" \"));\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n@@ -314,27 +322,27 @@ to make sure the command succeeded\n \n fn create_local_package(pkgid: &PkgId) -> TempDir {\n     let (workspace, parent_dir) = mk_temp_workspace(&pkgid.path, &pkgid.version);\n-    debug2!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.to_str());\n+    debug2!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.display());\n     workspace\n }\n \n fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n \n-    let package_dir = pkgdir.push_many([~\"src\", pkgid.to_str()]);\n+    let package_dir = pkgdir.join_many_str([~\"src\", pkgid.to_str()]);\n \n     // Create main, lib, test, and bench files\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n-    writeFile(&package_dir.push(\"main.rs\"),\n+    writeFile(&package_dir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.push(\"lib.rs\"),\n+    writeFile(&package_dir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.push(\"test.rs\"),\n+    writeFile(&package_dir.join_str(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.push(\"bench.rs\"),\n+    writeFile(&package_dir.join_str(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     package_dir\n }\n@@ -348,11 +356,11 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> TempDir\n     let package_dir = create_local_package(pkgid);\n     create_local_package_in(subord_pkgid, package_dir.path());\n     // Write a main.rs file into pkgid that references subord_pkgid\n-    writeFile(&package_dir.path().push_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n+    writeFile(&package_dir.path().join_many_str([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n                    subord_pkgid.short_name));\n     // Write a lib.rs file into subord_pkgid that has something in it\n-    writeFile(&package_dir.path().push_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n+    writeFile(&package_dir.path().join_many_str([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n@@ -371,7 +379,7 @@ fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Version) {\n }\n \n fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? version?\n-    debug2!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.to_str(), pkg_path.to_str());\n+    debug2!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.display(), pkg_path.display());\n     let lib = installed_library_in_workspace(pkg_path, repo);\n     debug2!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n@@ -385,13 +393,13 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n+    debug2!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     os::path_exists(&exec) && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"test_executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n+    debug2!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n         os::path_exists(&exec) && is_rwx(&exec)\n@@ -411,7 +419,7 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n \n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug2!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n-            repo.to_str(), short_name);\n+            repo.display(), short_name);\n     let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n@@ -444,7 +452,7 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n }\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n-    os::path_exists(&target_build_dir(repo).push_many([short_name.to_owned(),\n+    os::path_exists(&target_build_dir(repo).join_many_str([short_name.to_owned(),\n                                      format!(\"{}.{}\", short_name, extension)]))\n }\n \n@@ -453,7 +461,7 @@ fn assert_built_library_exists(repo: &Path, short_name: &str) {\n }\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n+    debug2!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n@@ -488,8 +496,8 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n // assumes short_name and path are one and the same -- I should fix\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n     debug2!(\"lib_output_file_name: given {} and short name {}\",\n-           workspace.to_str(), short_name);\n-    library_in_workspace(&Path(short_name),\n+           workspace.display(), short_name);\n+    library_in_workspace(&Path::from_str(short_name),\n                          short_name,\n                          Build,\n                          workspace,\n@@ -498,17 +506,19 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n }\n \n fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n-    target_build_dir(workspace).push(short_name).push(format!(\"{}{}\", short_name, os::EXE_SUFFIX))\n+    target_build_dir(workspace).join_str(short_name).join_str(format!(\"{}{}\", short_name,\n+                                                                      os::EXE_SUFFIX))\n }\n \n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.push_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many_str([~\"src\", pkgid.to_str()]);\n     let contents = os::list_dir_path(&pkg_src_dir);\n     for p in contents.iter() {\n-        if p.filetype() == Some(\".rs\") {\n+        if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n-            if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            if run::process_output(\"touch\", [p.as_str().unwrap().to_owned()]).status != 0 {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }\n@@ -518,10 +528,10 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n /// Add a comment at the end\n fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.push_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many_str([~\"src\", pkgid.to_str()]);\n     let mut maybe_p = None;\n-    let maybe_file = pkg_src_dir.push(filename);\n-    debug2!(\"Trying to frob {} -- {}\", pkg_src_dir.to_str(), filename);\n+    let maybe_file = pkg_src_dir.join_str(filename);\n+    debug2!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n     if os::path_exists(&maybe_file) {\n         maybe_p = Some(maybe_file);\n     }\n@@ -535,17 +545,17 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n             }\n         }\n         None => fail2!(\"frob_source_file failed to find a source file in {}\",\n-                           pkg_src_dir.to_str())\n+                           pkg_src_dir.display())\n     }\n }\n \n #[test]\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n-    let dir = temp.push(\"quux\");\n+    let dir = temp.join_str(\"quux\");\n     assert!(!os::path_exists(&dir) ||\n             os::remove_dir_recursive(&dir));\n-    debug2!(\"Trying to make {}\", dir.to_str());\n+    debug2!(\"Trying to make {}\", dir.display());\n     assert!(make_dir_rwx(&dir));\n     assert!(os::path_is_dir(&dir));\n     assert!(is_rwx(&dir));\n@@ -557,12 +567,12 @@ fn test_install_valid() {\n     use path_util::installed_library_in_workspace;\n \n     let sysroot = test_sysroot();\n-    debug2!(\"sysroot = {}\", sysroot.to_str());\n+    debug2!(\"sysroot = {}\", sysroot.display());\n     let temp_pkg_id = fake_pkg();\n     let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id.path, &NoVersion);\n     let temp_workspace = temp_workspace.path();\n     let ctxt = fake_ctxt(sysroot, temp_workspace);\n-    debug2!(\"temp_workspace = {}\", temp_workspace.to_str());\n+    debug2!(\"temp_workspace = {}\", temp_workspace.display());\n     // should have test, bench, lib, and main\n     let src = PkgSrc::new(temp_workspace.clone(),\n                           temp_workspace.clone(),\n@@ -571,7 +581,7 @@ fn test_install_valid() {\n     ctxt.install(src, &Everything);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug2!(\"exec = {}\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n \n@@ -583,7 +593,7 @@ fn test_install_valid() {\n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug2!(\"bench = {}\", bench.to_str());\n+    debug2!(\"bench = {}\", bench.display());\n     assert!(!os::path_exists(&bench));\n \n     // Make sure the db isn't dirty, so that it doesn't try to save()\n@@ -619,29 +629,30 @@ fn test_install_git() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    debug2!(\"repo = {}\", repo.to_str());\n-    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n-    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n+    debug2!(\"repo = {}\", repo.display());\n+    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    debug2!(\"repo_subdir = {}\", repo_subdir.display());\n \n-    writeFile(&repo_subdir.push(\"main.rs\"),\n+    writeFile(&repo_subdir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"lib.rs\"),\n+    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"test.rs\"),\n+    writeFile(&repo_subdir.join_str(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.push(\"bench.rs\"),\n+    writeFile(&repo_subdir.join_str(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n     debug2!(\"test_install_git: calling rustpkg install {} in {}\",\n-           temp_pkg_id.path.to_str(), repo.to_str());\n+           temp_pkg_id.path.display(), repo.display());\n     // should have test, bench, lib, and main\n-    command_line_test([~\"install\", temp_pkg_id.path.to_str()], repo);\n-    let ws = repo.push(\".rust\");\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n+    let ws = repo.join_str(\".rust\");\n     // Check that all files exist\n-    debug2!(\"Checking for files in {}\", ws.to_str());\n+    debug2!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug2!(\"exec = {}\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n@@ -657,9 +668,9 @@ fn test_install_git() {\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &ws);\n     assert!(!os::path_exists(&test));\n-    debug2!(\"test = {}\", test.to_str());\n+    debug2!(\"test = {}\", test.display());\n     let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n-    debug2!(\"bench = {}\", bench.to_str());\n+    debug2!(\"bench = {}\", bench.display());\n     assert!(!os::path_exists(&bench));\n }\n \n@@ -685,7 +696,7 @@ fn test_package_ids_must_be_relative_path_like() {\n             PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     do cond.trap(|(p, e)| {\n-        assert!(\"\" == p.to_str());\n+        assert!(p.filename().is_none())\n         assert!(\"0-length pkgid\" == e);\n         whatever.clone()\n     }).inside {\n@@ -694,11 +705,14 @@ fn test_package_ids_must_be_relative_path_like() {\n     }\n \n     do cond.trap(|(p, e)| {\n-        assert_eq!(p.to_str(), os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        let abs = os::make_absolute(&Path::from_str(\"foo/bar/quux\"));\n+        assert_eq!(p, abs);\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n     }).inside {\n-        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        let zp = os::make_absolute(&Path::from_str(\"foo/bar/quux\"));\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        let z = PkgId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n     }\n \n@@ -707,17 +721,17 @@ fn test_package_ids_must_be_relative_path_like() {\n #[test]\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path(local_path));\n+    let repo = init_git_repo(&Path::from_str(local_path));\n     let repo = repo.path();\n-    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n-    debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n-    writeFile(&repo_subdir.push(\"main.rs\"),\n+    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n+    debug2!(\"Writing files in: {}\", repo_subdir.display());\n+    writeFile(&repo_subdir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"lib.rs\"),\n+    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"test.rs\"),\n+    writeFile(&repo_subdir.join_str(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.push(\"bench.rs\"),\n+    writeFile(&repo_subdir.join_str(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n@@ -726,59 +740,64 @@ fn test_package_version() {\n     // This should look at the prefix, clone into a workspace, then build.\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n                       repo);\n-    let ws = repo.push(\".rust\");\n+    let ws = repo.join_str(\".rust\");\n     // we can still match on the filename to make sure it contains the 0.4 version\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n                                              &ws) {\n-        Some(p) => p.to_str().ends_with(format!(\"0.4{}\", os::consts::DLL_SUFFIX)),\n+        Some(p) => {\n+            let suffix = format!(\"0.4{}\", os::consts::DLL_SUFFIX);\n+            ends_with(p.as_vec(), suffix.as_bytes())\n+        }\n         None    => false\n     });\n     assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n-            == Some(target_build_dir(&ws).push_many([~\"mockgithub.com\",\n-                                                    ~\"catamorphism\",\n-                                                    ~\"test_pkg_version\",\n-                                                    ~\"test_pkg_version\"])));\n+            == Some(target_build_dir(&ws).join_many_str([\"mockgithub.com\",\n+                                                         \"catamorphism\",\n+                                                         \"test_pkg_version\",\n+                                                         \"test_pkg_version\"])));\n }\n \n #[test]\n fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path(local_path));\n+    let repo = init_git_repo(&Path::from_str(local_path));\n     let repo = repo.path();\n-    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n-    debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n-    writeFile(&repo_subdir.push(\"main.rs\"),\n+    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n+    debug2!(\"Writing files in: {}\", repo_subdir.display());\n+    writeFile(&repo_subdir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"lib.rs\"),\n+    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"test.rs\"),\n+    writeFile(&repo_subdir.join_str(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.push(\"bench.rs\"),\n+    writeFile(&repo_subdir.join_str(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.push(\"version-0.3-file.txt\"), \"hi\");\n+    writeFile(&repo_subdir.join_str(\"version-0.3-file.txt\"), \"hi\");\n     add_git_tag(&repo_subdir, ~\"0.3\");\n-    writeFile(&repo_subdir.push(\"version-0.4-file.txt\"), \"hello\");\n+    writeFile(&repo_subdir.join_str(\"version-0.4-file.txt\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n     command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n-    assert!(match installed_library_in_workspace(&Path(\"test_pkg_version\"), &repo.push(\".rust\")) {\n+    assert!(match installed_library_in_workspace(&Path::from_str(\"test_pkg_version\"),\n+                                                 &repo.join_str(\".rust\")) {\n         Some(p) => {\n-            debug2!(\"installed: {}\", p.to_str());\n-            p.to_str().ends_with(format!(\"0.3{}\", os::consts::DLL_SUFFIX))\n+            debug2!(\"installed: {}\", p.display());\n+            let suffix = format!(\"0.3{}\", os::consts::DLL_SUFFIX);\n+            ends_with(p.as_vec(), suffix.as_bytes())\n         }\n         None    => false\n     });\n     let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n-    assert!(target_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n-            == repo.push_many([~\".rust\", ~\"bin\", ~\"test_pkg_version\"]));\n+    assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join_str(\".rust\"))\n+            == repo.join_many_str([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n-    let dir = target_build_dir(&repo.push(\".rust\"))\n-        .push_rel(&Path(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n-    debug2!(\"dir = {}\", dir.to_str());\n+    let mut dir = target_build_dir(&repo.join_str(\".rust\"));\n+    dir.push_path(&Path::from_str(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n+    debug2!(\"dir = {}\", dir.display());\n     assert!(os::path_is_dir(&dir));\n-    assert!(os::path_exists(&dir.push(\"version-0.3-file.txt\")));\n-    assert!(!os::path_exists(&dir.push(\"version-0.4-file.txt\")));\n+    assert!(os::path_exists(&dir.join_str(\"version-0.3-file.txt\")));\n+    assert!(!os::path_exists(&dir.join_str(\"version-0.4-file.txt\")));\n }\n \n #[test]\n@@ -791,23 +810,23 @@ fn rustpkg_install_url_2() {\n \n #[test]\n fn rustpkg_library_target() {\n-    let foo_repo = init_git_repo(&Path(\"foo\"));\n+    let foo_repo = init_git_repo(&Path::from_str(\"foo\"));\n     let foo_repo = foo_repo.path();\n-    let package_dir = foo_repo.push(\"foo\");\n+    let package_dir = foo_repo.join_str(\"foo\");\n \n-    debug2!(\"Writing files in: {}\", package_dir.to_str());\n-    writeFile(&package_dir.push(\"main.rs\"),\n+    debug2!(\"Writing files in: {}\", package_dir.display());\n+    writeFile(&package_dir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.push(\"lib.rs\"),\n+    writeFile(&package_dir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.push(\"test.rs\"),\n+    writeFile(&package_dir.join_str(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.push(\"bench.rs\"),\n+    writeFile(&package_dir.join_str(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.push(\".rust\"), &Path(\"foo\"), ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.join_str(\".rust\"), &Path::from_str(\"foo\"), ExactRevision(~\"1.0\"));\n }\n \n #[test]\n@@ -822,56 +841,58 @@ fn rustpkg_local_pkg() {\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     let dir = dir.path();\n-    debug2!(\"dir = {}\", dir.to_str());\n-    let source = test_sysroot().pop().pop().pop().push_many(\n-        [~\"src\", ~\"librustpkg\", ~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n-    debug2!(\"package_script_with_default_build: {}\", source.to_str());\n+    debug2!(\"dir = {}\", dir.display());\n+    let mut source = test_sysroot().dir_path();\n+    source.pop(); source.pop();\n+    source.push_many_str(\n+        [\"src\", \"librustpkg\", \"testsuite\", \"pass\", \"src\", \"fancy-lib\", \"pkg.rs\"]);\n+    debug2!(\"package_script_with_default_build: {}\", source.display());\n     if !os::copy_file(&source,\n-                      &dir.push_many([~\"src\", ~\"fancy-lib-0.1\", ~\"pkg.rs\"])) {\n+                      &dir.join_many_str([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n         fail2!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &Path(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(dir).push_many([~\"fancy-lib\", ~\"generated.rs\"])));\n+    assert_lib_exists(dir, &Path::from_str(\"fancy-lib\"), NoVersion);\n+    assert!(os::path_exists(&target_build_dir(dir).join_many_str([\"fancy-lib\", \"generated.rs\"])));\n }\n \n #[test]\n fn rustpkg_build_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n-    let tmp = tmp.path().push(\".rust\");\n-    let package_dir = tmp.push_many([~\"src\", ~\"foo\"]);\n+    let tmp = tmp.path().join_str(\".rust\");\n+    let package_dir = tmp.join_many_str([\"src\", \"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n \n-    writeFile(&package_dir.push(\"main.rs\"),\n+    writeFile(&package_dir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug2!(\"build_no_arg: dir = {}\", package_dir.to_str());\n+    debug2!(\"build_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n }\n \n #[test]\n fn rustpkg_install_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n-    let tmp = tmp.path().push(\".rust\");\n-    let package_dir = tmp.push_many([~\"src\", ~\"foo\"]);\n+    let tmp = tmp.path().join_str(\".rust\");\n+    let package_dir = tmp.join_many_str([\"src\", \"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    writeFile(&package_dir.push(\"lib.rs\"),\n+    writeFile(&package_dir.join_str(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug2!(\"install_no_arg: dir = {}\", package_dir.to_str());\n+    debug2!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &Path(\"foo\"), NoVersion);\n+    assert_lib_exists(&tmp, &Path::from_str(\"foo\"), NoVersion);\n }\n \n #[test]\n fn rustpkg_clean_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n-    let tmp = tmp.path().push(\".rust\");\n-    let package_dir = tmp.push_many([~\"src\", ~\"foo\"]);\n+    let tmp = tmp.path().join_str(\".rust\");\n+    let package_dir = tmp.join_many_str([\"src\", \"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n \n-    writeFile(&package_dir.push(\"main.rs\"),\n+    writeFile(&package_dir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug2!(\"clean_no_arg: dir = {}\", package_dir.to_str());\n+    debug2!(\"clean_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n@@ -882,48 +903,49 @@ fn rustpkg_clean_no_arg() {\n #[test]\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &Path(\"foo\"), &NoVersion);\n-    debug2!(\"dir = {}\", dir.to_str());\n-    writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n+    let dir = mk_workspace(dir_for_path.path(), &Path::from_str(\"foo\"), &NoVersion);\n+    debug2!(\"dir = {}\", dir.display());\n+    writeFile(&dir.join_str(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n-    debug2!(\"cwd = {}\", cwd.to_str());\n+    debug2!(\"cwd = {}\", cwd.display());\n                                      // use command_line_test_with_env\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n                                &cwd,\n-                               Some(~[(~\"RUST_PATH\", dir_for_path.path().to_str())]));\n+                               Some(~[(~\"RUST_PATH\", dir_for_path.path().as_str().unwrap())]));\n     assert_executable_exists(dir_for_path.path(), \"foo\");\n }\n \n #[test]\n #[ignore] // FIXME(#9184) tests can't change the cwd (other tests are sad then)\n fn rust_path_contents() {\n     let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n-    let abc = &dir.path().push_many([~\"A\", ~\"B\", ~\"C\"]);\n-    assert!(os::mkdir_recursive(&abc.push(\".rust\"), U_RWX));\n-    assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), U_RWX));\n-    assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), U_RWX));\n+    let abc = &dir.path().join_many_str([\"A\", \"B\", \"C\"]);\n+    assert!(os::mkdir_recursive(&abc.join_str(\".rust\"), U_RWX));\n+    assert!(os::mkdir_recursive(&abc.with_filename(\".rust\"), U_RWX));\n+    assert!(os::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), U_RWX));\n     assert!(os::change_dir(abc));\n \n     let p = rust_path();\n-    let cwd = os::getcwd().push(\".rust\");\n-    let parent = cwd.pop().pop().push(\".rust\");\n-    let grandparent = cwd.pop().pop().pop().push(\".rust\");\n+    let cwd = os::getcwd().join_str(\".rust\");\n+    let parent = cwd.dir_path().with_filename_str(\".rust\");\n+    let grandparent = cwd.dir_path().dir_path().with_filename_str(\".rust\");\n     assert!(p.contains(&cwd));\n     assert!(p.contains(&parent));\n     assert!(p.contains(&grandparent));\n     for a_path in p.iter() {\n-        assert!(!a_path.components.is_empty());\n+        assert!(a_path.filename().is_some());\n     }\n }\n \n #[test]\n fn rust_path_parse() {\n     os::setenv(\"RUST_PATH\", \"/a/b/c:/d/e/f:/g/h/i\");\n     let paths = rust_path();\n-    assert!(paths.contains(&Path(\"/g/h/i\")));\n-    assert!(paths.contains(&Path(\"/d/e/f\")));\n-    assert!(paths.contains(&Path(\"/a/b/c\")));\n+    assert!(paths.contains(&Path::from_str(\"/g/h/i\")));\n+    assert!(paths.contains(&Path::from_str(\"/d/e/f\")));\n+    assert!(paths.contains(&Path::from_str(\"/a/b/c\")));\n     os::unsetenv(\"RUST_PATH\");\n }\n \n@@ -940,7 +962,8 @@ fn test_list() {\n \n // list doesn't output very much right now...\n     command_line_test([~\"install\", ~\"foo\"], dir);\n-    let env_arg = ~[(~\"RUST_PATH\", dir.to_str())];\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let env_arg = ~[(~\"RUST_PATH\", dir.as_str().unwrap().to_owned())];\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n     assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n \n@@ -966,7 +989,8 @@ fn install_remove() {\n     create_local_package_in(&foo, dir);\n     create_local_package_in(&bar, dir);\n     create_local_package_in(&quux, dir);\n-    let rust_path_to_use = ~[(~\"RUST_PATH\", dir.to_str())];\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path_to_use = ~[(~\"RUST_PATH\", dir.as_str().unwrap().to_owned())];\n     command_line_test([~\"install\", ~\"foo\"], dir);\n     command_line_test([~\"install\", ~\"bar\"], dir);\n     command_line_test([~\"install\", ~\"quux\"], dir);\n@@ -996,12 +1020,12 @@ fn install_check_duplicates() {\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail2!(\"package {} appears in `list` output more than once\", p.path.to_str());\n+            fail2!(\"package {} appears in `list` output more than once\", p.path.display());\n         }\n         else {\n             contents.push((*p).clone());\n         }\n-        false\n+        true\n     };\n     list_installed_packages(check_dups);\n }\n@@ -1059,7 +1083,7 @@ fn do_rebuild_dep_dates_change() {\n     touch_source_file(workspace, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     let new_bar_date = datestamp(&bar_lib_name);\n-    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), new_bar_date);\n+    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.display(), new_bar_date);\n     assert!(new_bar_date > bar_date);\n }\n \n@@ -1120,21 +1144,23 @@ fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n-    writeFile(&repo_subdir.push(\"foo\"), \"foo\");\n-    writeFile(&repo_subdir.push(\"lib.rs\"),\n+    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    writeFile(&repo_subdir.join_str(\"foo\"), \"foo\");\n+    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"testbranch\");\n-    writeFile(&repo_subdir.push(\"testbranch_only\"), \"hello\");\n+    writeFile(&repo_subdir.join_str(\"testbranch_only\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"another_tag\");\n-    writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n+    writeFile(&repo_subdir.join_str(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path.to_str())], repo);\n-    let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n-                                \"test-pkg\", \"testbranch_only\"]);\n-    let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n-                                \"master_only\"]);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\",\n+                                           temp_pkg_id.path.as_str().unwrap())], repo);\n+    let file1 = repo.join_many_str([\"mockgithub.com\", \"catamorphism\",\n+                                    \"test-pkg\", \"testbranch_only\"]);\n+    let file2 = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n+                                    \"master_only\"]);\n     assert!(os::path_exists(&file1));\n     assert!(!os::path_exists(&file2));\n }\n@@ -1143,12 +1169,13 @@ fn test_non_numeric_tag() {\n fn test_extern_mod() {\n     let dir = TempDir::new(\"test_extern_mod\").expect(\"test_extern_mod\");\n     let dir = dir.path();\n-    let main_file = dir.push(\"main.rs\");\n+    let main_file = dir.join_str(\"main.rs\");\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n     let lib_depend_dir = lib_depend_dir.path();\n-    let aux_dir = lib_depend_dir.push_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n+    let aux_dir = lib_depend_dir.join_many_str([\"src\", \"mockgithub.com\", \"catamorphism\",\n+                                                \"test_pkg\"]);\n     assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n-    let aux_pkg_file = aux_dir.push(\"lib.rs\");\n+    let aux_pkg_file = aux_dir.join_str(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n     assert!(os::path_exists(&aux_pkg_file));\n@@ -1159,15 +1186,19 @@ fn test_extern_mod() {\n \n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], lib_depend_dir);\n \n-    let exec_file = dir.push(\"out\");\n+    let exec_file = dir.join_str(\"out\");\n     // Be sure to extend the existing environment\n-    let env = Some([(~\"RUST_PATH\", lib_depend_dir.to_str())] + os::env());\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let env = Some([(~\"RUST_PATH\", lib_depend_dir.as_str().unwrap().to_owned())] + os::env());\n     let rustpkg_exec = rustpkg_exec();\n-    let rustc = rustpkg_exec.with_filename(\"rustc\");\n-\n-    let mut prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n-                                                      ~\"--sysroot\", test_sysroot().to_str(),\n-                                               ~\"-o\", exec_file.to_str()],\n+    let rustc = rustpkg_exec.with_filename_str(\"rustc\");\n+\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let mut prog = run::Process::new(rustc.as_str().unwrap(),\n+                                     [main_file.as_str().unwrap().to_owned(),\n+                                      ~\"--sysroot\", test_sys.as_str().unwrap().to_owned(),\n+                                      ~\"-o\", exec_file.as_str().unwrap().to_owned()],\n                                      run::ProcessOptions {\n         env: env,\n         dir: Some(dir),\n@@ -1188,12 +1219,12 @@ fn test_extern_mod() {\n fn test_extern_mod_simpler() {\n     let dir = TempDir::new(\"test_extern_mod_simpler\").expect(\"test_extern_mod_simpler\");\n     let dir = dir.path();\n-    let main_file = dir.push(\"main.rs\");\n+    let main_file = dir.join_str(\"main.rs\");\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n     let lib_depend_dir = lib_depend_dir.path();\n-    let aux_dir = lib_depend_dir.push_many([\"src\", \"rust-awesomeness\"]);\n+    let aux_dir = lib_depend_dir.join_many_str([\"src\", \"rust-awesomeness\"]);\n     assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n-    let aux_pkg_file = aux_dir.push(\"lib.rs\");\n+    let aux_pkg_file = aux_dir.join_str(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n     assert!(os::path_exists(&aux_pkg_file));\n@@ -1204,21 +1235,25 @@ fn test_extern_mod_simpler() {\n \n     command_line_test([~\"install\", ~\"rust-awesomeness\"], lib_depend_dir);\n \n-    let exec_file = dir.push(\"out\");\n+    let exec_file = dir.join_str(\"out\");\n     // Be sure to extend the existing environment\n-    let env = Some([(~\"RUST_PATH\", lib_depend_dir.to_str())] + os::env());\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let env = Some([(~\"RUST_PATH\", lib_depend_dir.as_str().unwrap().to_owned())] + os::env());\n     let rustpkg_exec = rustpkg_exec();\n-    let rustc = rustpkg_exec.with_filename(\"rustc\");\n+    let rustc = rustpkg_exec.with_filename_str(\"rustc\");\n+    let test_sys = test_sysroot();\n     debug2!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n-                     lib_depend_dir.to_str(),\n-                     rustc.to_str(),\n-                     main_file.to_str(),\n-                     test_sysroot().to_str(),\n-                     exec_file.to_str());\n-\n-    let mut prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n-                                                      ~\"--sysroot\", test_sysroot().to_str(),\n-                                               ~\"-o\", exec_file.to_str()],\n+                     lib_depend_dir.display(),\n+                     rustc.display(),\n+                     main_file.display(),\n+                     test_sys.display(),\n+                     exec_file.display());\n+\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let mut prog = run::Process::new(rustc.as_str().unwrap(),\n+                                     [main_file.as_str().unwrap().to_owned(),\n+                                      ~\"--sysroot\", test_sys.as_str().unwrap().to_owned(),\n+                                      ~\"-o\", exec_file.as_str().unwrap().to_owned()],\n                                      run::ProcessOptions {\n         env: env,\n         dir: Some(dir),\n@@ -1240,11 +1275,11 @@ fn test_import_rustpkg() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n+    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    debug2!(\"workspace = {}\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(workspace).push(\"foo\").push(format!(\"pkg{}\",\n+    debug2!(\"workspace = {}\", workspace.display());\n+    assert!(os::path_exists(&target_build_dir(workspace).join_str(\"foo\").join_str(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1253,11 +1288,11 @@ fn test_macro_pkg_script() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n+    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() { debug2!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    debug2!(\"workspace = {}\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(workspace).push(\"foo\").push(format!(\"pkg{}\",\n+    debug2!(\"workspace = {}\", workspace.display());\n+    assert!(os::path_exists(&target_build_dir(workspace).join_str(\"foo\").join_str(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1267,14 +1302,16 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path(\"foo\"), &NoVersion);\n-    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path(\"foo\"), &NoVersion);\n+    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::from_str(\"foo\"), &NoVersion);\n+    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::from_str(\"foo\"), &NoVersion);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n-    debug2!(\"Trying to install foo in {}\", a_loc.to_str());\n+    debug2!(\"Trying to install foo in {}\", a_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], a_loc);\n-    debug2!(\"Trying to install foo in {}\", b_loc.to_str());\n+    debug2!(\"Trying to install foo in {}\", b_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], b_loc);\n-    let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.to_str(), b_loc.to_str()))]);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n+                                            b_loc.as_str().unwrap()))]);\n     let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n     command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n }\n@@ -1291,19 +1328,19 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let p_id = PkgId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n    let workspace = workspace.path();\n-   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\",\n        format!(\"{}:{}\",\n-               dest_workspace.to_str(),\n-               workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n+               dest_workspace.as_str().unwrap(),\n+               foo_path.as_str().unwrap()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &Path(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::from_str(\"foo\"), NoVersion);\n    assert_executable_exists(dest_workspace, \"foo\");\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &Path(\"foo\"), NoVersion));\n+   assert!(!lib_exists(workspace, &Path::from_str(\"foo\"), NoVersion));\n    assert!(!executable_exists(workspace, \"foo\"));\n    assert!(!built_library_exists(workspace, \"foo\"));\n    assert!(!built_executable_exists(workspace, \"foo\"));\n@@ -1332,38 +1369,40 @@ fn test_rust_path_can_contain_package_dirs_without_flag() {\n fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n-   let cwd = cwd.path().push(\"foo\");\n+   let cwd = cwd.path().join_str(\"foo\");\n    assert!(os::mkdir_recursive(&cwd, U_RWX));\n-   writeFile(&cwd.push(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&cwd.join_str(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   // FIXME (#9639): This needs to handle non-utf8 paths\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n-   assert_lib_exists(dest_workspace, &Path(\"foo\"), NoVersion);\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n+   assert_lib_exists(dest_workspace, &Path::from_str(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &Path(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&cwd, &Path::from_str(\"foo\"), NoVersion));\n    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_multi_path() {\n    // Same as rust_path_hack_test, but with a more complex package ID\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n-   let subdir = cwd.path().push_many([~\"foo\", ~\"bar\", ~\"quux\"]);\n+   let subdir = cwd.path().join_many_str([\"foo\", \"bar\", \"quux\"]);\n    assert!(os::mkdir_recursive(&subdir, U_RWX));\n-   writeFile(&subdir.push(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&subdir.join_str(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n-   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   // FIXME (#9639): This needs to handle non-utf8 paths\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-   debug2!(\"Checking that {} exists in {}\", name, dest_workspace.to_str());\n-   assert_lib_exists(dest_workspace, &Path(\"quux\"), NoVersion);\n+   debug2!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n+   assert_lib_exists(dest_workspace, &Path::from_str(\"quux\"), NoVersion);\n    assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &Path(\"quux\"), NoVersion));\n+   assert!(!lib_exists(&subdir, &Path::from_str(\"quux\"), NoVersion));\n    assert!(!built_library_exists(&subdir, name));\n }\n \n@@ -1372,34 +1411,36 @@ fn rust_path_hack_install_no_arg() {\n    // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n    let cwd = cwd.path();\n-   let source_dir = cwd.push(\"foo\");\n+   let source_dir = cwd.join_str(\"foo\");\n    assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.push(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&source_dir.join_str(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   // FIXME (#9639): This needs to handle non-utf8 paths\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n-   assert_lib_exists(dest_workspace, &Path(\"foo\"), NoVersion);\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n+   assert_lib_exists(dest_workspace, &Path::from_str(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &Path(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&source_dir, &Path::from_str(\"foo\"), NoVersion));\n    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_no_arg() {\n    // Same as rust_path_hack_install_no_arg, but building instead of installing\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n-   let source_dir = cwd.path().push(\"foo\");\n+   let source_dir = cwd.path().join_str(\"foo\");\n    assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.push(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&source_dir.join_str(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   // FIXME (#9639): This needs to handle non-utf8 paths\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n@@ -1408,16 +1449,18 @@ fn rust_path_hack_build_no_arg() {\n fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &Path(\"foo\"), &NoVersion);\n-    debug2!(\"dir = {}\", dir.to_str());\n-    writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n+    let mut dir = mk_workspace(dir_for_path.path(), &Path::from_str(\"foo\"), &NoVersion);\n+    debug2!(\"dir = {}\", dir.display());\n+    writeFile(&dir.join_str(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n         \"dest_workspace\").expect(\"rust_path_install_target failed\");\n     let dir_to_install_to = dir_to_install_to.path();\n-    let dir = dir.pop().pop();\n+    dir.pop(); dir.pop();\n \n-    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dir_to_install_to.to_str(),\n-                                               dir.to_str()))]);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\",\n+                                                  dir_to_install_to.as_str().unwrap(),\n+                                                  dir.as_str().unwrap()))]);\n     let cwd = os::getcwd();\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n                                &cwd,\n@@ -1433,8 +1476,10 @@ fn sysroot_flag() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // no-op sysroot setting; I'm not sure how else to test this\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"--sysroot\",\n-                       test_sysroot().to_str(),\n+                       test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace);\n@@ -1446,7 +1491,9 @@ fn compile_flag_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"--no-link\",\n                        ~\"foo\"],\n@@ -1461,7 +1508,9 @@ fn compile_flag_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test_expect_fail([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"--no-link\",\n                        ~\"foo\"],\n@@ -1479,7 +1528,9 @@ fn notrans_flag_build() {\n                          ~\"--pretty\", ~\"-S\"];\n \n     for flag in flags_to_test.iter() {\n-        command_line_test([test_sysroot().to_str(),\n+        let test_sys = test_sysroot();\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        command_line_test([test_sys.as_str().unwrap().to_owned(),\n                            ~\"build\",\n                            flag.clone(),\n                            ~\"foo\"],\n@@ -1501,14 +1552,16 @@ fn notrans_flag_fail() {\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n                          ~\"--pretty\", ~\"-S\"];\n     for flag in flags_to_test.iter() {\n-        command_line_test_expect_fail([test_sysroot().to_str(),\n+        let test_sys = test_sysroot();\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n                            ~\"install\",\n                            flag.clone(),\n                            ~\"foo\"],\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &Path(\"foo\"), NoVersion));\n+        assert!(!lib_exists(workspace, &Path::from_str(\"foo\"), NoVersion));\n     }\n }\n \n@@ -1517,7 +1570,9 @@ fn dash_S() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sysroot().as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"-S\",\n                        ~\"foo\"],\n@@ -1532,7 +1587,9 @@ fn dash_S_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test_expect_fail([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"-S\",\n                        ~\"foo\"],\n@@ -1548,9 +1605,11 @@ fn test_cfg_build() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n-    writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n+    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"--cfg\",\n                        ~\"quux\",\n@@ -1564,9 +1623,11 @@ fn test_cfg_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n+    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n-    match command_line_test_partial([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    match command_line_test_partial([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace) {\n@@ -1581,7 +1642,9 @@ fn test_emit_llvm_S_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"-S\", ~\"--emit-llvm\",\n                        ~\"foo\"],\n@@ -1597,7 +1660,9 @@ fn test_emit_llvm_S_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test_expect_fail([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"-S\", ~\"--emit-llvm\",\n                        ~\"foo\"],\n@@ -1615,7 +1680,9 @@ fn test_emit_llvm_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"--emit-llvm\",\n                        ~\"foo\"],\n@@ -1632,7 +1699,9 @@ fn test_emit_llvm_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test_expect_fail([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"--emit-llvm\",\n                        ~\"foo\"],\n@@ -1659,7 +1728,9 @@ fn test_linker_build() {\n     let sess = build_session(options,\n                              @diagnostic::DefaultEmitter as\n                                 @diagnostic::Emitter);\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"--linker\",\n                        get_cc_prog(sess),\n@@ -1681,7 +1752,9 @@ fn test_build_install_flags_fail() {\n                      ~[~\"-Z\", ~\"--time-passes\"]];\n     let cwd = os::getcwd();\n     for flag in forbidden.iter() {\n-        command_line_test_expect_fail([test_sysroot().to_str(),\n+        let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+        command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n                            ~\"list\"] + *flag, &cwd, None, BAD_FLAG_CODE);\n     }\n }\n@@ -1691,7 +1764,9 @@ fn test_optimized_build() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"-O\",\n                        ~\"foo\"],\n@@ -1705,23 +1780,23 @@ fn pkgid_pointing_to_subdir() {\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n     let workspace = workspace.path();\n-    assert!(os::mkdir_recursive(&workspace.push_many([~\"src\", ~\"mockgithub.com\",\n-                                                     ~\"mozilla\", ~\"some_repo\"]), U_RWX));\n+    assert!(os::mkdir_recursive(&workspace.join_many_str([\"src\", \"mockgithub.com\",\n+                                                          \"mozilla\", \"some_repo\"]), U_RWX));\n \n-    let foo_dir = workspace.push_many([~\"src\", ~\"mockgithub.com\", ~\"mozilla\", ~\"some_repo\",\n-                                       ~\"extras\", ~\"foo\"]);\n-    let bar_dir = workspace.push_many([~\"src\", ~\"mockgithub.com\", ~\"mozilla\", ~\"some_repo\",\n-                                       ~\"extras\", ~\"bar\"]);\n+    let foo_dir = workspace.join_many_str([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n+                                           \"extras\", \"foo\"]);\n+    let bar_dir = workspace.join_many_str([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n+                                           \"extras\", \"bar\"]);\n     assert!(os::mkdir_recursive(&foo_dir, U_RWX));\n     assert!(os::mkdir_recursive(&bar_dir, U_RWX));\n-    writeFile(&foo_dir.push(\"lib.rs\"), \"pub fn f() {}\");\n-    writeFile(&bar_dir.push(\"lib.rs\"), \"pub fn g() {}\");\n+    writeFile(&foo_dir.join_str(\"lib.rs\"), \"pub fn f() {}\");\n+    writeFile(&bar_dir.join_str(\"lib.rs\"), \"pub fn g() {}\");\n \n-    debug2!(\"Creating a file in {}\", workspace.to_str());\n-    let testpkg_dir = workspace.push_many([~\"src\", ~\"testpkg-0.1\"]);\n+    debug2!(\"Creating a file in {}\", workspace.display());\n+    let testpkg_dir = workspace.join_many_str([\"src\", \"testpkg-0.1\"]);\n     assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n \n-    writeFile(&testpkg_dir.push(\"main.rs\"),\n+    writeFile(&testpkg_dir.join_str(\"main.rs\"),\n               \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n                extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar\\\";\\n\n                use foo::f; use bar::g; \\n\n@@ -1738,36 +1813,40 @@ fn test_recursive_deps() {\n     let c_id = PkgId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n-    writeFile(&b_workspace.push(\"src\").push(\"c-0.1\").push(\"lib.rs\"),\n+    writeFile(&b_workspace.join_many_str([\"src\", \"c-0.1\", \"lib.rs\"])),\n                \"pub fn g() {}\");\n     let a_workspace = create_local_package(&a_id);\n     let a_workspace = a_workspace.path();\n-    writeFile(&a_workspace.push(\"src\").push(\"a-0.1\").push(\"main.rs\"),\n+    writeFile(&a_workspace.join_many_str([\"src\", \"a-0.1\", \"main.rs\"]),\n                \"extern mod b; use b::f; fn main() { f(); }\");\n-    writeFile(&b_workspace.push(\"src\").push(\"b-0.1\").push(\"lib.rs\"),\n+    writeFile(&b_workspace.join_many_str([\"src\", \"b-0.1\", \"lib.rs\"]),\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n-    let environment = Some(~[(~\"RUST_PATH\", b_workspace.to_str())]);\n-    debug2!(\"RUST_PATH={}\", b_workspace.to_str());\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let environment = Some(~[(~\"RUST_PATH\", b_workspace.as_str().unwrap().to_owned())]);\n+    debug2!(\"RUST_PATH={}\", b_workspace.display());\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &Path(\"a\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path(\"b\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path(\"c\"), NoVersion);\n+    assert_lib_exists(a_workspace, &Path::from_str(\"a\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path::from_str(\"b\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path::from_str(\"c\"), NoVersion);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n     let p_id = PkgId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n-    let first_workspace = mk_empty_workspace(&Path(\"p\"), &NoVersion, \"dest\");\n+    let first_workspace = mk_empty_workspace(&Path::from_str(\"p\"), &NoVersion, \"dest\");\n     let first_workspace = first_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n-                            format!(\"{}:{}\", first_workspace.to_str(),\n-                                 second_workspace.to_str()))]);\n-    debug2!(\"RUST_PATH={}:{}\", first_workspace.to_str(), second_workspace.to_str());\n-    command_line_test_with_env([test_sysroot().to_str(),\n+                            format!(\"{}:{}\", first_workspace.as_str().unwrap(),\n+                                    second_workspace.as_str().unwrap()))]);\n+    debug2!(\"RUST_PATH={}:{}\", first_workspace.display(), second_workspace.display());\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test_with_env([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"foo\"],\n                       &os::getcwd(), rust_path);\n@@ -1782,28 +1861,32 @@ fn test_target_specific_build_dir() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace);\n     assert!(os::path_is_dir(&target_build_dir(workspace)));\n     assert!(built_executable_exists(workspace, \"foo\"));\n-    assert!(os::list_dir(&workspace.push(\"build\")).len() == 1);\n+    assert!(os::list_dir(&workspace.join_str(\"build\")).len() == 1);\n }\n \n #[test]\n fn test_target_specific_install_dir() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    let test_sys = test_sysroot();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"install\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&workspace.push(\"lib\").push(host_triple())));\n-    assert_lib_exists(workspace, &Path(\"foo\"), NoVersion);\n-    assert!(os::list_dir(&workspace.push(\"lib\")).len() == 1);\n-    assert!(os::path_is_dir(&workspace.push(\"bin\")));\n+    assert!(os::path_is_dir(&workspace.join_many_str([\"lib\", host_triple()])));\n+    assert_lib_exists(workspace, &Path::from_str(\"foo\"), NoVersion);\n+    assert!(os::list_dir(&workspace.join_str(\"lib\")).len() == 1);\n+    assert!(os::path_is_dir(&workspace.join_str(\"bin\")));\n     assert_executable_exists(workspace, \"foo\");\n }\n \n@@ -1813,10 +1896,10 @@ fn test_dependencies_terminate() {\n     let b_id = PkgId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n-    let b_dir = workspace.push_many([~\"src\", ~\"b-0.1\"]);\n-    let b_subdir = b_dir.push(\"test\");\n+    let b_dir = workspace.join_many_str([\"src\", \"b-0.1\"]);\n+    let b_subdir = b_dir.join_str(\"test\");\n     assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n-    writeFile(&b_subdir.push(\"test.rs\"),\n+    writeFile(&b_subdir.join_str(\"test.rs\"),\n               \"extern mod b; use b::f; #[test] fn g() { f() }\");\n     command_line_test([~\"install\", ~\"b\"], workspace);\n }\n@@ -1877,14 +1960,16 @@ fn correct_package_name_with_rust_path_hack() {\n     let bar_id = PkgId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+    let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n-    writeFile(&dest_workspace.push_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n+    writeFile(&dest_workspace.join_many_str([\"src\", \"bar-0.1\", \"main.rs\"]),\n               \"extern mod blat; fn main() { let _x = (); }\");\n \n-    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.to_str(),\n-                        foo_workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n+    let foo_path = foo_workspace.join_many_str([\"src\", \"foo-0.1\"]);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.as_str().unwrap(),\n+                                                  foo_path.as_str().unwrap()))]);\n     // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n     command_line_test_expect_fail([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n                                   // FIXME #3408: Should be NONEXISTENT_PACKAGE_CODE\n@@ -1904,7 +1989,7 @@ fn test_rustpkg_test_creates_exec() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n+    writeFile(&foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"test.rs\"]),\n               \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -1928,7 +2013,7 @@ fn test_rebuild_when_needed() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    let test_crate = foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -1948,7 +2033,7 @@ fn test_no_rebuilding() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    let test_crate = foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -1969,23 +2054,24 @@ fn test_installed_read_only() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    debug2!(\"repo = {}\", repo.to_str());\n-    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n-    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n+    debug2!(\"repo = {}\", repo.display());\n+    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    debug2!(\"repo_subdir = {}\", repo_subdir.display());\n \n-    writeFile(&repo_subdir.push(\"main.rs\"),\n+    writeFile(&repo_subdir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"lib.rs\"),\n+    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    command_line_test([~\"install\", temp_pkg_id.path.to_str()], repo);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n \n-    let ws = repo.push(\".rust\");\n+    let ws = repo.join_str(\".rust\");\n     // Check that all files exist\n-    debug2!(\"Checking for files in {}\", ws.to_str());\n+    debug2!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug2!(\"exec = {}\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let built_lib =\n@@ -1995,8 +2081,8 @@ fn test_installed_read_only() {\n     assert!(is_rwx(&built_lib));\n \n     // Make sure sources are (a) under \"build\" and (b) read-only\n-    let src1 = target_build_dir(&ws).push_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n-    let src2 = target_build_dir(&ws).push_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n+    let src1 = target_build_dir(&ws).join_many_str([\"src\", temp_pkg_id.to_str(), \"main.rs\"]);\n+    let src2 = target_build_dir(&ws).join_many_str([\"src\", temp_pkg_id.to_str(), \"lib.rs\"]);\n     assert!(os::path_exists(&src1));\n     assert!(os::path_exists(&src2));\n     assert!(is_read_only(&src1));\n@@ -2008,29 +2094,30 @@ fn test_installed_local_changes() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    debug2!(\"repo = {}\", repo.to_str());\n-    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n-    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n-    assert!(os::mkdir_recursive(&repo.push_many([\".rust\", \"src\"]), U_RWX));\n+    debug2!(\"repo = {}\", repo.display());\n+    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    debug2!(\"repo_subdir = {}\", repo_subdir.display());\n+    assert!(os::mkdir_recursive(&repo.join_many_str([\".rust\", \"src\"]), U_RWX));\n \n-    writeFile(&repo_subdir.push(\"main.rs\"),\n+    writeFile(&repo_subdir.join_str(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.push(\"lib.rs\"),\n+    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    command_line_test([~\"install\", temp_pkg_id.path.to_str()], repo);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n \n \n     // We installed the dependency.\n     // Now start a new workspace and clone it into it\n     let hacking_workspace = mk_emptier_workspace(\"hacking_workspace\");\n     let hacking_workspace = hacking_workspace.path();\n-    let target_dir = hacking_workspace.push_many([~\"src\",\n-                                                  ~\"mockgithub.com\",\n-                                                  ~\"catamorphism\",\n-                                                  ~\"test-pkg-0.1\"]);\n-    debug2!(\"---- git clone {} {}\", repo_subdir.to_str(), target_dir.to_str());\n+    let target_dir = hacking_workspace.join_many_str([\"src\",\n+                                                      \"mockgithub.com\",\n+                                                      \"catamorphism\",\n+                                                      \"test-pkg-0.1\"]);\n+    debug2!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n \n     let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n \n@@ -2040,28 +2127,32 @@ fn test_installed_local_changes() {\n     };\n \n     // Make a local change to it\n-    writeFile(&target_dir.push(\"lib.rs\"),\n+    writeFile(&target_dir.join_str(\"lib.rs\"),\n               \"pub fn g() { let _x = (); }\");\n \n     // Finally, make *another* package that uses it\n     let importer_pkg_id = fake_pkg();\n     let main_subdir = create_local_package_in(&importer_pkg_id, hacking_workspace);\n-    writeFile(&main_subdir.push(\"main.rs\"),\n+    writeFile(&main_subdir.join_str(\"main.rs\"),\n               \"extern mod test = \\\"mockgithub.com/catamorphism/test-pkg\\\"; \\\n               use test::g;\n               fn main() { g(); }\");\n     // And make sure we can build it\n \n-    command_line_test([~\"build\", importer_pkg_id.path.to_str()], hacking_workspace);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    command_line_test([~\"build\", importer_pkg_id.path.as_str().unwrap().to_owned()],\n+                      hacking_workspace);\n }\n \n #[test]\n fn test_7402() {\n     let dir = create_local_package(&PkgId::new(\"foo\"));\n     let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n     let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n-                            format!(\"{}:{}\", dest_workspace.to_str(), dir.path().to_str()))]);\n+                            format!(\"{}:{}\", dest_workspace.as_str().unwrap(),\n+                                    dir.path().as_str().unwrap()))]);\n     let cwd = os::getcwd();\n     command_line_test_with_env([~\"install\", ~\"foo\"], &cwd, rust_path);\n     assert_executable_exists(dest_workspace, \"foo\");\n@@ -2072,7 +2163,7 @@ fn test_compile_error() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let main_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]);\n+    let main_crate = foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"main.rs\"]);\n     // Write something bogus\n     writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n     let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);"}, {"sha": "14de18734ed60c83f3f0b9dc471820911ea04a30", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -170,21 +170,23 @@ pub fn compile_input(context: &BuildContext,\n                      cfgs: &[~str],\n                      opt: bool,\n                      what: OutputType) -> Option<Path> {\n-    assert!(in_file.components.len() > 1);\n-    let input = driver::file_input((*in_file).clone());\n-    debug2!(\"compile_input: {} / {:?}\", in_file.to_str(), what);\n+    assert!(in_file.component_iter().nth(1).is_some());\n+    let input = driver::file_input(in_file.clone());\n+    debug2!(\"compile_input: {} / {:?}\", in_file.display(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let out_dir = target_build_dir(workspace).push_rel(&pkg_id.path);\n+    let mut out_dir = target_build_dir(workspace);\n+    out_dir.push_path(&pkg_id.path);\n     // Make the output directory if it doesn't exist already\n     assert!(os::mkdir_recursive(&out_dir, U_RWX));\n \n     let binary = os::args()[0].to_managed();\n \n     debug2!(\"flags: {}\", flags.connect(\" \"));\n     debug2!(\"cfgs: {}\", cfgs.connect(\" \"));\n-    debug2!(\"compile_input's sysroot = {}\", context.sysroot().to_str());\n+    let csysroot = context.sysroot();\n+    debug2!(\"compile_input's sysroot = {}\", csysroot.display());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -209,10 +211,15 @@ pub fn compile_input(context: &BuildContext,\n         context.sysroot()\n     }\n     else {\n-        context.sysroot().pop().pop().pop()\n+        let mut p = context.sysroot().clone();\n+        p.pop();\n+        p.pop();\n+        p.pop();\n+        p\n     };\n-    debug2!(\"compile_input's sysroot = {}\", context.sysroot().to_str());\n-    debug2!(\"sysroot_to_use = {}\", sysroot_to_use.to_str());\n+    let csysroot = context.sysroot();\n+    debug2!(\"compile_input's sysroot = {}\", csysroot.display());\n+    debug2!(\"sysroot_to_use = {}\", sysroot_to_use.display());\n \n     let output_type = match context.compile_upto() {\n         Assemble => link::output_type_assembly,\n@@ -260,7 +267,7 @@ pub fn compile_input(context: &BuildContext,\n \n     find_and_install_dependencies(context, pkg_id, sess, exec, &crate,\n                                   |p| {\n-                                      debug2!(\"a dependency: {}\", p.to_str());\n+                                      debug2!(\"a dependency: {}\", p.display());\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n                                       if !addl_lib_search_paths.contains(&p) {\n@@ -278,18 +285,19 @@ pub fn compile_input(context: &BuildContext,\n             _     => pkg_id.short_name.to_managed()\n         };\n         debug2!(\"Injecting link name: {}\", name_to_use);\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n         let link_options =\n             ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n               attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n             ~[attr::mk_name_value_item_str(@\"package_id\",\n-                                           pkg_id.path.to_str().to_managed())];\n+                                           pkg_id.path.as_str().unwrap().to_managed())];\n \n         debug2!(\"link options: {:?}\", link_options);\n         crate.attrs = ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))];\n     }\n \n     debug2!(\"calling compile_crate_from_input, workspace = {},\n-           building_library = {:?}\", out_dir.to_str(), sess.building_library);\n+           building_library = {:?}\", out_dir.display(), sess.building_library);\n     let result = compile_crate_from_input(in_file,\n                                           exec,\n                                           context.compile_upto(),\n@@ -303,11 +311,12 @@ pub fn compile_input(context: &BuildContext,\n     else {\n         result\n     };\n-    debug2!(\"About to discover output {}\", discovered_output.to_str());\n     for p in discovered_output.iter() {\n+        debug2!(\"About to discover output {}\", p.display());\n         if os::path_exists(p) {\n-            debug2!(\"4. discovering output {}\", p.to_str());\n-            exec.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n+            debug2!(\"4. discovering output {}\", p.display());\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            exec.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n         }\n         // Nothing to do if it doesn't exist -- that could happen if we had the\n         // -S or -emit-llvm flags, etc.\n@@ -330,21 +339,21 @@ pub fn compile_crate_from_input(input: &Path,\n // given\n                                 crate: ast::Crate) -> Option<Path> {\n     debug2!(\"Calling build_output_filenames with {}, building library? {:?}\",\n-           out_dir.to_str(), sess.building_library);\n+           out_dir.display(), sess.building_library);\n \n     // bad copy\n-    debug2!(\"out_dir = {}\", out_dir.to_str());\n+    debug2!(\"out_dir = {}\", out_dir.display());\n     let outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n                                                  &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n     debug2!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n-           outputs.out_filename.to_str(),\n-           outputs.obj_filename.to_str(),\n+           outputs.out_filename.display(),\n+           outputs.obj_filename.display(),\n            sess.opts.output_type);\n     debug2!(\"additional libraries:\");\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n-        debug2!(\"an additional library: {}\", lib.to_str());\n+        debug2!(\"an additional library: {}\", lib.display());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n     if driver::stop_after_phase_3(sess) { return None; }\n@@ -359,9 +368,10 @@ pub fn compile_crate_from_input(input: &Path,\n     driver::phase_6_link_output(sess, &translation, outputs);\n \n     // Register dependency on the source file\n-    exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    exec.discover_input(\"file\", input.as_str().unwrap(), digest_file_with_date(input));\n \n-    debug2!(\"Built {}, date = {:?}\", outputs.out_filename.to_str(),\n+    debug2!(\"Built {}, date = {:?}\", outputs.out_filename.display(),\n            datestamp(&outputs.out_filename));\n \n     Some(outputs.out_filename)\n@@ -383,7 +393,7 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n                      what: OutputType) -> Option<Path> {\n-    debug2!(\"compile_crate: crate={}, workspace={}\", crate.to_str(), workspace.to_str());\n+    debug2!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n     debug2!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n         debug2!(\"+++ {}\", *fl);\n@@ -414,15 +424,16 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                 // Check standard Rust library path first\n                 match system_library(&self.context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n-                        debug2!(\"It exists: {}\", installed_path.to_str());\n+                        debug2!(\"It exists: {}\", installed_path.display());\n                         // Say that [path for c] has a discovered dependency on\n                         // installed_path\n                         // For binary files, we only hash the datestamp, not the contents.\n                         // I'm not sure what the right thing is.\n                         // Now we know that this crate has a discovered dependency on\n                         // installed_path\n+                        // FIXME (#9639): This needs to handle non-utf8 paths\n                         self.exec.discover_input(\"binary\",\n-                                                 installed_path.to_str(),\n+                                                 installed_path.as_str().unwrap(),\n                                                  digest_only_date(installed_path));\n                     }\n                     None => {\n@@ -456,7 +467,8 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                   self.context.context.use_rust_path_hack,\n                                                   pkg_id);\n                         let (outputs_disc, inputs_disc) =\n-                            self.context.install(pkg_src, &JustOne(Path(lib_crate_filename)));\n+                            self.context.install(pkg_src,\n+                                                 &JustOne(Path::from_str(lib_crate_filename)));\n                         debug2!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n@@ -465,24 +477,27 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // It must have installed *something*...\n                         assert!(!outputs_disc.is_empty());\n                         for dep in outputs_disc.iter() {\n-                            debug2!(\"Discovering a binary input: {}\", dep.to_str());\n+                            debug2!(\"Discovering a binary input: {}\", dep.display());\n+                            // FIXME (#9639): This needs to handle non-utf8 paths\n                             self.exec.discover_input(\"binary\",\n-                                                     dep.to_str(),\n+                                                     dep.as_str().unwrap(),\n                                                      digest_only_date(dep));\n                             // Also, add an additional search path\n-                            debug2!(\"Installed {} into {}\", dep.to_str(), dep.pop().to_str());\n-                            (self.save)(dep.pop());\n+                            debug2!(\"Installed {} into {}\", dep.display(),\n+                                    dep.dir_path().display());\n+                            (self.save)(dep.dir_path());\n                         }\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n-                                                         digest_file_with_date(&Path(*dep)));\n+                                                         digest_file_with_date(\n+                                                             &Path::from_str(*dep)));\n                             }\n                                 else if *what == ~\"binary\" {\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n-                                                         digest_only_date(&Path(*dep)));\n+                                                         digest_only_date(&Path::from_str(*dep)));\n                             }\n                                 else {\n                                 fail2!(\"Bad kind: {}\", *what);\n@@ -559,7 +574,7 @@ fn debug_flags() -> ~[~str] { ~[] }\n \n /// Returns the last-modified date as an Option\n pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug2!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.to_str(), os::path_exists(p));\n+    debug2!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(), os::path_exists(p));\n     let out = p.stat().map(|stat| stat.st_mtime);\n     debug2!(\"Date = {:?}\", out);\n     out.map(|t| { t as libc::time_t })"}, {"sha": "d0c76498c626496b6aca166685118de0d7ba70b4", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -98,15 +98,16 @@ pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n     let rustpath = rust_path();\n     for rp in rustpath.iter() {\n-        let local_path = rp.push_rel(local_path);\n-        let git_dir = local_path.push(\".git\");\n+        let local_path = rp.join_path(local_path);\n+        let git_dir = local_path.join_str(\".git\");\n         if !os::path_is_dir(&git_dir) {\n             continue;\n         }\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n         let outp = run::process_output(\"git\",\n-                                   [format!(\"--git-dir={}\", git_dir.to_str()), ~\"tag\", ~\"-l\"]);\n+                                   [\"--git-dir=\" + git_dir.as_str().unwrap(), ~\"tag\", ~\"-l\"]);\n \n-        debug2!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.to_str(), outp.status);\n+        debug2!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.display(), outp.status);\n \n         if outp.status != 0 {\n             continue;\n@@ -136,21 +137,23 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n         let tmp_dir = tmp_dir.expect(\"try_getting_version: couldn't create temp dir\");\n         let tmp_dir = tmp_dir.path();\n         debug2!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n-               remote_path.to_str(),\n-               tmp_dir.to_str());\n-        let outp  = run::process_output(\"git\", [~\"clone\",\n-                                                format!(\"https://{}\",\n-                                                        remote_path.to_str()),\n-                                                tmp_dir.to_str()]);\n+               remote_path.display(),\n+               tmp_dir.display());\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        let outp  = run::process_output(\"git\", [~\"clone\", format!(\"https://{}\",\n+                                                                  remote_path.as_str().unwrap()),\n+                                                tmp_dir.as_str().unwrap().to_owned()]);\n         if outp.status == 0 {\n             debug2!(\"Cloned it... ( {}, {} )\",\n                    str::from_utf8(outp.output),\n                    str::from_utf8(outp.error));\n             let mut output = None;\n+            let git_dir = tmp_dir.join_str(\".git\");\n             debug2!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n-                   tmp_dir.push(\".git\").to_str());\n+                   git_dir.display());\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n             let outp = run::process_output(\"git\",\n-                                           [format!(\"--git-dir={}\", tmp_dir.push(\".git\").to_str()),\n+                                           [\"--git-dir=\" + git_dir.as_str().unwrap(),\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_utf8(outp.output);\n             debug2!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n@@ -203,8 +206,8 @@ pub fn try_parsing_version(s: &str) -> Option<Version> {\n \n /// Just an approximation\n fn is_url_like(p: &Path) -> bool {\n-    let str = p.to_str();\n-    str.split_iter('/').len() > 2\n+    // check if there are more than 2 /-separated components\n+    p.as_vec().split_iter(|b| *b == '/' as u8).nth(2).is_some()\n }\n \n /// If s is of the form foo#bar, where bar is a valid version"}, {"sha": "34404ad625c78dd959705804fb271a1d15f9c55a", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -30,7 +30,12 @@ pub fn digest_file_with_date(path: &Path) -> ~str {\n             (*sha).input_str(st.st_mtime.to_str());\n             (*sha).result_str()\n         }\n-        Err(e) => cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e))).to_str()\n+        Err(e) => {\n+            let path = cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e)));\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            // XXX: I'm pretty sure this is the wrong return value\n+            path.as_str().unwrap().to_owned()\n+        }\n     }\n }\n \n@@ -51,13 +56,15 @@ pub fn digest_only_date(path: &Path) -> ~str {\n pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n     debug2!(\"Discovering {:?} outputs\", outputs.len());\n     for p in outputs.iter() {\n-        debug2!(\"Discovering output! {}\", p.to_str());\n+        debug2!(\"Discovering output! {}\", p.display());\n         // For now, assume that all discovered outputs are binaries\n-        e.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        e.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n     }\n }\n \n /// Returns the function name for building a crate\n pub fn crate_tag(p: &Path) -> ~str {\n-    p.to_str() // implicitly, it's \"build(p)\"...\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    p.as_str().unwrap().to_owned() // implicitly, it's \"build(p)\"...\n }"}, {"sha": "15f9760a6379ff32c2f87433ac3611d5f7f57bae", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -10,7 +10,7 @@\n \n // rustpkg utilities having to do with workspaces\n \n-use std::{os,util};\n+use std::os;\n use std::path::Path;\n use context::Context;\n use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack, default_workspace};\n@@ -26,8 +26,8 @@ pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path)\n         // tjc: make this a condition\n         fail2!(\"Package {} not found in any of \\\n                     the following workspaces: {}\",\n-                   pkgid.path.to_str(),\n-                   rust_path().to_str());\n+                   pkgid.path.display(),\n+                   rust_path().map(|p| p.to_display_str()).to_str());\n     }\n     for ws in workspaces.iter() {\n         if action(ws) {\n@@ -52,24 +52,21 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n }\n \n pub fn is_workspace(p: &Path) -> bool {\n-    os::path_is_dir(&p.push(\"src\"))\n+    os::path_is_dir(&p.join_str(\"src\"))\n }\n \n /// Construct a workspace and package-ID name based on the current directory.\n /// This gets used when rustpkg gets invoked without a package-ID argument.\n pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {\n     let cwd = os::getcwd();\n     for path in rust_path().move_iter() {\n-        let srcpath = path.push(\"src\");\n+        let srcpath = path.join_str(\"src\");\n         if srcpath.is_ancestor_of(&cwd) {\n-            // I'd love to use srcpath.get_relative_to(cwd) but it behaves wrong\n-            // I'd say broken, but it has tests enforcing the wrong behavior.\n-            // instead, just hack up the components vec\n-            let mut pkgid = cwd;\n-            pkgid.is_absolute = false;\n-            let comps = util::replace(&mut pkgid.components, ~[]);\n-            pkgid.components = comps.move_iter().skip(srcpath.components.len()).collect();\n-            return Some((path, PkgId::new(pkgid.components.connect(\"/\"))))\n+            let rel = cwd.path_relative_from(&srcpath);\n+            let rel_s = rel.and_then_ref(|p|p.as_str());\n+            if rel_s.is_some() {\n+                return Some((path, PkgId::new(rel_s.unwrap())));\n+            }\n         }\n     }\n     None"}, {"sha": "434d781805bf88c75cb6964b9e2efb79d0fe54c6", "filename": "src/libstd/io.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -60,12 +60,11 @@ use num;\n use ops::Drop;\n use option::{Some, None};\n use os;\n-use path::Path;\n+use path::{Path,GenericPath};\n use ptr;\n use result::{Result, Ok, Err};\n use str::{StrSlice, OwnedStr};\n use str;\n-use to_str::ToStr;\n use uint;\n use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n use vec;\n@@ -1069,7 +1068,9 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n     };\n \n     if f as uint == 0u {\n-        Err(~\"error opening \" + path.to_str())\n+        do path.with_display_str |p| {\n+            Err(~\"error opening \" + p)\n+        }\n     } else {\n         Ok(FILE_reader(f, true))\n     }\n@@ -1335,7 +1336,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     };\n     if fd < (0 as c_int) {\n-        Err(format!(\"error opening {}: {}\", path.to_str(), os::last_os_error()))\n+        Err(format!(\"error opening {}: {}\", path.display(), os::last_os_error()))\n     } else {\n         Ok(fd_writer(fd, true))\n     }\n@@ -1752,7 +1753,7 @@ pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n         if str::is_utf8(bytes) {\n             Ok(str::from_utf8(bytes))\n         } else {\n-            Err(file.to_str() + \" is not UTF-8\")\n+            Err(file.to_display_str() + \" is not UTF-8\")\n         }\n     }\n }\n@@ -1892,8 +1893,8 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        let tmpfile = &Path(\"tmp/lib-io-test-simple.tmp\");\n-        debug2!(\"{:?}\", tmpfile);\n+        let tmpfile = &Path::from_str(\"tmp/lib-io-test-simple.tmp\");\n+        debug2!(\"{}\", tmpfile.display());\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n         debug2!(\"{}\", frood.clone());\n@@ -1910,7 +1911,7 @@ mod tests {\n     #[test]\n     fn test_each_byte_each_char_file() {\n         // Issue #5056 -- shouldn't include trailing EOF.\n-        let path = Path(\"tmp/lib-io-test-each-byte-each-char-file.tmp\");\n+        let path = Path::from_str(\"tmp/lib-io-test-each-byte-each-char-file.tmp\");\n \n         {\n             // create empty, enough to reproduce a problem\n@@ -2010,7 +2011,7 @@ mod tests {\n \n     #[test]\n     fn file_reader_not_exist() {\n-        match io::file_reader(&Path(\"not a file\")) {\n+        match io::file_reader(&Path::from_str(\"not a file\")) {\n           Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n@@ -2021,7 +2022,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_read_buffer_too_small() {\n-        let path = &Path(\"tmp/lib-io-test-read-buffer-too-small.tmp\");\n+        let path = &Path::from_str(\"tmp/lib-io-test-read-buffer-too-small.tmp\");\n         // ensure the file exists\n         io::file_writer(path, [io::Create]).unwrap();\n \n@@ -2032,7 +2033,7 @@ mod tests {\n \n     #[test]\n     fn test_read_buffer_big_enough() {\n-        let path = &Path(\"tmp/lib-io-test-read-buffer-big-enough.tmp\");\n+        let path = &Path::from_str(\"tmp/lib-io-test-read-buffer-big-enough.tmp\");\n         // ensure the file exists\n         io::file_writer(path, [io::Create]).unwrap();\n \n@@ -2043,7 +2044,7 @@ mod tests {\n \n     #[test]\n     fn test_write_empty() {\n-        let file = io::file_writer(&Path(\"tmp/lib-io-test-write-empty.tmp\"),\n+        let file = io::file_writer(&Path::from_str(\"tmp/lib-io-test-write-empty.tmp\"),\n                                    [io::Create]).unwrap();\n         file.write([]);\n     }\n@@ -2075,7 +2076,7 @@ mod tests {\n \n     #[test]\n     fn test_read_write_le() {\n-        let path = Path(\"tmp/lib-io-test-read-write-le.tmp\");\n+        let path = Path::from_str(\"tmp/lib-io-test-read-write-le.tmp\");\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n \n         // write the ints to the file\n@@ -2097,7 +2098,7 @@ mod tests {\n \n     #[test]\n     fn test_read_write_be() {\n-        let path = Path(\"tmp/lib-io-test-read-write-be.tmp\");\n+        let path = Path::from_str(\"tmp/lib-io-test-read-write-be.tmp\");\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n \n         // write the ints to the file\n@@ -2119,7 +2120,7 @@ mod tests {\n \n     #[test]\n     fn test_read_be_int_n() {\n-        let path = Path(\"tmp/lib-io-test-read-be-int-n.tmp\");\n+        let path = Path::from_str(\"tmp/lib-io-test-read-be-int-n.tmp\");\n         let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n \n         // write the ints to the file\n@@ -2143,7 +2144,7 @@ mod tests {\n \n     #[test]\n     fn test_read_f32() {\n-        let path = Path(\"tmp/lib-io-test-read-f32.tmp\");\n+        let path = Path::from_str(\"tmp/lib-io-test-read-f32.tmp\");\n         //big-endian floating-point 8.1250\n         let buf = ~[0x41, 0x02, 0x00, 0x00];\n \n@@ -2161,7 +2162,7 @@ mod tests {\n \n     #[test]\n     fn test_read_write_f32() {\n-        let path = Path(\"tmp/lib-io-test-read-write-f32.tmp\");\n+        let path = Path::from_str(\"tmp/lib-io-test-read-write-f32.tmp\");\n         let f:f32 = 8.1250;\n \n         {"}, {"sha": "bfde1a86771ed4ba51071b25f4f0e6fc715c2ff3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -28,7 +28,7 @@\n \n #[allow(missing_doc)];\n \n-use c_str::ToCStr;\n+use c_str::{CString, ToCStr};\n use clone::Clone;\n use container::Container;\n use io;\n@@ -78,22 +78,7 @@ pub fn getcwd() -> Path {\n                 fail2!()\n             }\n \n-            Path(str::raw::from_c_str(buf as *c_char))\n-        }\n-    }\n-}\n-\n-// FIXME: move these to str perhaps? #2620\n-\n-pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool) -> Option<~str> {\n-    let mut buf = [0 as c_char, .. TMPBUF_SZ];\n-    do buf.as_mut_buf |b, sz| {\n-        if f(b, sz as size_t) {\n-            unsafe {\n-                Some(str::raw::from_c_str(b as *c_char))\n-            }\n-        } else {\n-            None\n+            GenericPath::from_c_str(CString::new(buf as *c_char, false))\n         }\n     }\n }\n@@ -451,70 +436,89 @@ pub fn dll_filename(base: &str) -> ~str {\n pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> Option<~str> {\n+    fn load_self() -> Option<~[u8]> {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n-            do fill_charp_buf() |buf, sz| {\n-                let mib = ~[CTL_KERN as c_int,\n-                           KERN_PROC as c_int,\n-                           KERN_PROC_PATHNAME as c_int, -1 as c_int];\n-                let mut sz = sz;\n+            let mib = ~[CTL_KERN as c_int,\n+                        KERN_PROC as c_int,\n+                        KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+            let mut sz: size_t = 0;\n+            let err = sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n+                             ptr::mut_null(), &mut sz, ptr::null(), 0u as size_t);\n+            if err != 0 { return None; }\n+            if sz == 0 { return None; }\n+            let mut v: ~[u8] = vec::with_capacity(sz as uint);\n+            let err = do v.as_mut_buf |buf,_| {\n                 sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n-                       buf as *mut c_void, &mut sz, ptr::null(),\n-                       0u as size_t) == (0 as c_int)\n-            }\n+                       buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n+            };\n+            if err != 0 { return None; }\n+            if sz == 0 { return None; }\n+            vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n+            Some(v)\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n-    fn load_self() -> Option<~str> {\n+    fn load_self() -> Option<~[u8]> {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::posix01::unistd::readlink;\n \n-            let mut path = [0 as c_char, .. TMPBUF_SZ];\n-\n-            do path.as_mut_buf |buf, len| {\n-                let len = do \"/proc/self/exe\".with_c_str |proc_self_buf| {\n-                    readlink(proc_self_buf, buf, len as size_t) as uint\n-                };\n+            let mut path: ~[u8] = vec::with_capacity(TMPBUF_SZ);\n \n-                if len == -1 {\n-                    None\n-                } else {\n-                    Some(str::raw::from_buf_len(buf as *u8, len))\n+            let len = do path.as_mut_buf |buf, _| {\n+                do \"/proc/self/exe\".with_c_str |proc_self_buf| {\n+                    readlink(proc_self_buf, buf as *mut c_char, TMPBUF_SZ as size_t) as uint\n                 }\n+            };\n+            if len == -1 {\n+                None\n+            } else {\n+                vec::raw::set_len(&mut path, len as uint);\n+                Some(path)\n             }\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> Option<~str> {\n+    fn load_self() -> Option<~[u8]> {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n-            do fill_charp_buf() |buf, sz| {\n-                let mut sz = sz as u32;\n-                libc::funcs::extra::_NSGetExecutablePath(\n-                    buf, &mut sz) == (0 as c_int)\n-            }\n+            use libc::funcs::extra::_NSGetExecutablePath;\n+            let mut sz: u32 = 0;\n+            _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n+            if sz == 0 { return None; }\n+            let mut v: ~[u8] = vec::with_capacity(sz as uint);\n+            let err = do v.as_mut_buf |buf,_| {\n+                _NSGetExecutablePath(buf as *mut i8, &mut sz)\n+            };\n+            if err != 0 { return None; }\n+            vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n+            Some(v)\n         }\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> Option<~str> {\n+    fn load_self() -> Option<~[u8]> {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             do fill_utf16_buf_and_decode() |buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }\n+            }.map_move(|s| s.into_bytes())\n         }\n     }\n \n-    load_self().map(|path| Path(path).dir_path())\n+    load_self().and_then(|path| Path::from_vec_opt(path).map(|p| p.dir_path()))\n+}\n+\n+\n+/**\n+ * Returns the path to the user's home directory, if known.\n }\n \n \n@@ -532,13 +536,10 @@ pub fn self_exe_path() -> Option<Path> {\n  * Otherwise, homedir returns option::none.\n  */\n pub fn homedir() -> Option<Path> {\n+    // FIXME (#7188): getenv needs a ~[u8] variant\n     return match getenv(\"HOME\") {\n-        Some(ref p) => if !p.is_empty() {\n-          Some(Path(*p))\n-        } else {\n-          secondary()\n-        },\n-        None => secondary()\n+        Some(ref p) if !p.is_empty() => Path::from_str_opt(*p),\n+        _ => secondary()\n     };\n \n     #[cfg(unix)]\n@@ -550,7 +551,7 @@ pub fn homedir() -> Option<Path> {\n     fn secondary() -> Option<Path> {\n         do getenv(\"USERPROFILE\").and_then |p| {\n             if !p.is_empty() {\n-                Some(Path(p))\n+                Path::from_str_opt(p)\n             } else {\n                 None\n             }\n@@ -579,7 +580,7 @@ pub fn tmpdir() -> Path {\n                 if x.is_empty() {\n                     None\n                 } else {\n-                    Some(Path(x))\n+                    Path::from_str_opt(x)\n                 },\n             _ => None\n         }\n@@ -588,9 +589,9 @@ pub fn tmpdir() -> Path {\n     #[cfg(unix)]\n     fn lookup() -> Path {\n         if cfg!(target_os = \"android\") {\n-            Path(\"/data/tmp\")\n+            Path::from_str(\"/data/tmp\")\n         } else {\n-            getenv_nonempty(\"TMPDIR\").unwrap_or(Path(\"/tmp\"))\n+            getenv_nonempty(\"TMPDIR\").unwrap_or(Path::from_str(\"/tmp\"))\n         }\n     }\n \n@@ -599,15 +600,15 @@ pub fn tmpdir() -> Path {\n         getenv_nonempty(\"TMP\").or(\n             getenv_nonempty(\"TEMP\").or(\n                 getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path(\"C:\\\\Windows\"))\n+                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::from_str(\"C:\\\\Windows\"))\n     }\n }\n \n /// Recursively walk a directory structure\n pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n     let r = list_dir(p);\n     r.iter().advance(|q| {\n-        let path = &p.push(*q);\n+        let path = &p.join_path(q);\n         f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n     })\n }\n@@ -643,10 +644,12 @@ pub fn path_exists(p: &Path) -> bool {\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n pub fn make_absolute(p: &Path) -> Path {\n-    if p.is_absolute {\n-        (*p).clone()\n+    if p.is_absolute() {\n+        p.clone()\n     } else {\n-        getcwd().push_many(p.components)\n+        let mut ret = getcwd();\n+        ret.push_path(p);\n+        ret\n     }\n }\n \n@@ -661,7 +664,7 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n         unsafe {\n             use os::win32::as_utf16_p;\n             // FIXME: turn mode into something useful? #2623\n-            do as_utf16_p(p.to_str()) |buf| {\n+            do as_utf16_p(p.as_str().unwrap()) |buf| {\n                 libc::CreateDirectoryW(buf, ptr::mut_null())\n                     != (0 as libc::BOOL)\n             }\n@@ -690,38 +693,32 @@ pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n     if path_is_dir(p) {\n         return true;\n     }\n-    else if p.components.is_empty() {\n-        return false;\n-    }\n-    else if p.components.len() == 1 {\n-        // No parent directories to create\n-        path_is_dir(p) || make_dir(p, mode)\n-    }\n-    else {\n-        mkdir_recursive(&p.pop(), mode) && make_dir(p, mode)\n+    let mut p_ = p.clone();\n+    if p_.pop().is_some() {\n+        if !mkdir_recursive(&p_, mode) {\n+            return false;\n+        }\n     }\n+    return make_dir(p, mode);\n }\n \n /// Lists the contents of a directory\n-pub fn list_dir(p: &Path) -> ~[~str] {\n-    if p.components.is_empty() && !p.is_absolute() {\n-        // Not sure what the right behavior is here, but this\n-        // prevents a bounds check failure later\n-        return ~[];\n-    }\n+///\n+/// Each resulting Path is a relative path with no directory component.\n+pub fn list_dir(p: &Path) -> ~[Path] {\n     unsafe {\n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n         #[cfg(target_os = \"macos\")]\n-        unsafe fn get_list(p: &Path) -> ~[~str] {\n+        unsafe fn get_list(p: &Path) -> ~[Path] {\n             #[fixed_stack_segment]; #[inline(never)];\n             use libc::{dirent_t};\n             use libc::{opendir, readdir, closedir};\n             extern {\n                 fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n             }\n-            let mut strings = ~[];\n+            let mut paths = ~[];\n             debug2!(\"os::list_dir -- BEFORE OPENDIR\");\n \n             let dir_ptr = do p.with_c_str |buf| {\n@@ -732,20 +729,20 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 debug2!(\"os::list_dir -- opendir() SUCCESS\");\n                 let mut entry_ptr = readdir(dir_ptr);\n                 while (entry_ptr as uint != 0) {\n-                    strings.push(str::raw::from_c_str(rust_list_dir_val(\n-                        entry_ptr)));\n+                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n+                    paths.push(GenericPath::from_c_str(cstr));\n                     entry_ptr = readdir(dir_ptr);\n                 }\n                 closedir(dir_ptr);\n             }\n             else {\n                 debug2!(\"os::list_dir -- opendir() FAILURE\");\n             }\n-            debug2!(\"os::list_dir -- AFTER -- \\\\#: {}\", strings.len());\n-            strings\n+            debug2!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n+            paths\n         }\n         #[cfg(windows)]\n-        unsafe fn get_list(p: &Path) -> ~[~str] {\n+        unsafe fn get_list(p: &Path) -> ~[Path] {\n             #[fixed_stack_segment]; #[inline(never)];\n             use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n             use libc::{wcslen, free};\n@@ -765,9 +762,9 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 fn rust_list_dir_wfd_size() -> libc::size_t;\n                 fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n             }\n-            fn star(p: &Path) -> Path { p.push(\"*\") }\n-            do as_utf16_p(star(p).to_str()) |path_ptr| {\n-                let mut strings = ~[];\n+            let star = p.join_str(\"*\");\n+            do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n+                let mut paths = ~[];\n                 let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n                 let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n                 if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n@@ -781,18 +778,18 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                             let fp_vec = vec::from_buf(\n                                 fp_buf, wcslen(fp_buf) as uint);\n                             let fp_str = str::from_utf16(fp_vec);\n-                            strings.push(fp_str);\n+                            paths.push(Path::from_str(fp_str));\n                         }\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n                     FindClose(find_handle);\n                     free(wfd_ptr)\n                 }\n-                strings\n+                paths\n             }\n         }\n-        do get_list(p).move_iter().filter |filename| {\n-            \".\" != *filename && \"..\" != *filename\n+        do get_list(p).move_iter().filter |path| {\n+            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n         }.collect()\n     }\n }\n@@ -803,7 +800,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n  * This version prepends each entry with the directory.\n  */\n pub fn list_dir_path(p: &Path) -> ~[Path] {\n-    list_dir(p).map(|f| p.push(*f))\n+    list_dir(p).map(|f| p.join_path(f))\n }\n \n /// Removes a directory at the specified path, after removing\n@@ -838,7 +835,7 @@ pub fn remove_dir(p: &Path) -> bool {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.to_str()) |buf| {\n+            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n                 libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n             };\n         }\n@@ -865,7 +862,7 @@ pub fn change_dir(p: &Path) -> bool {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.to_str()) |buf| {\n+            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n                 libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n             };\n         }\n@@ -891,8 +888,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n-            return do as_utf16_p(from.to_str()) |fromp| {\n-                do as_utf16_p(to.to_str()) |top| {\n+            return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n+                do as_utf16_p(to.as_str().unwrap()) |top| {\n                     libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n                         (0 as libc::BOOL)\n                 }\n@@ -968,7 +965,7 @@ pub fn remove_file(p: &Path) -> bool {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.to_str()) |buf| {\n+            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n                 libc::DeleteFileW(buf) != (0 as libc::BOOL)\n             };\n         }\n@@ -1657,35 +1654,45 @@ pub mod consts {\n         pub static SYSNAME: &'static str = \"macos\";\n         pub static DLL_PREFIX: &'static str = \"lib\";\n         pub static DLL_SUFFIX: &'static str = \".dylib\";\n+        pub static DLL_EXTENSION: &'static str = \"dylib\";\n         pub static EXE_SUFFIX: &'static str = \"\";\n+        pub static EXE_EXTENSION: &'static str = \"\";\n     }\n \n     pub mod freebsd {\n         pub static SYSNAME: &'static str = \"freebsd\";\n         pub static DLL_PREFIX: &'static str = \"lib\";\n         pub static DLL_SUFFIX: &'static str = \".so\";\n+        pub static DLL_EXTENSION: &'static str = \"so\";\n         pub static EXE_SUFFIX: &'static str = \"\";\n+        pub static EXE_EXTENSION: &'static str = \"\";\n     }\n \n     pub mod linux {\n         pub static SYSNAME: &'static str = \"linux\";\n         pub static DLL_PREFIX: &'static str = \"lib\";\n         pub static DLL_SUFFIX: &'static str = \".so\";\n+        pub static DLL_EXTENSION: &'static str = \"so\";\n         pub static EXE_SUFFIX: &'static str = \"\";\n+        pub static EXE_EXTENSION: &'static str = \"\";\n     }\n \n     pub mod android {\n         pub static SYSNAME: &'static str = \"android\";\n         pub static DLL_PREFIX: &'static str = \"lib\";\n         pub static DLL_SUFFIX: &'static str = \".so\";\n+        pub static DLL_EXTENSION: &'static str = \"so\";\n         pub static EXE_SUFFIX: &'static str = \"\";\n+        pub static EXE_EXTENSION: &'static str = \"\";\n     }\n \n     pub mod win32 {\n         pub static SYSNAME: &'static str = \"win32\";\n         pub static DLL_PREFIX: &'static str = \"\";\n         pub static DLL_SUFFIX: &'static str = \".dll\";\n+        pub static DLL_EXTENSION: &'static str = \"dll\";\n         pub static EXE_SUFFIX: &'static str = \".exe\";\n+        pub static EXE_EXTENSION: &'static str = \"exe\";\n     }\n \n \n@@ -1790,7 +1797,7 @@ mod tests {\n         debug2!(\"{:?}\", path.clone());\n \n         // Hard to test this function\n-        assert!(path.is_absolute);\n+        assert!(path.is_absolute());\n     }\n \n     #[test]\n@@ -1823,12 +1830,13 @@ mod tests {\n \n     #[test]\n     fn test() {\n-        assert!((!Path(\"test-path\").is_absolute));\n+        assert!((!Path::from_str(\"test-path\").is_absolute()));\n \n-        debug2!(\"Current working directory: {}\", getcwd().to_str());\n+        let cwd = getcwd();\n+        debug2!(\"Current working directory: {}\", cwd.display());\n \n-        debug2!(\"{:?}\", make_absolute(&Path(\"test-path\")));\n-        debug2!(\"{:?}\", make_absolute(&Path(\"/usr/bin\")));\n+        debug2!(\"{:?}\", make_absolute(&Path::from_str(\"test-path\")));\n+        debug2!(\"{:?}\", make_absolute(&Path::from_str(\"/usr/bin\")));\n     }\n \n     #[test]\n@@ -1837,7 +1845,7 @@ mod tests {\n         let oldhome = getenv(\"HOME\");\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n@@ -1858,35 +1866,37 @@ mod tests {\n         assert!(os::homedir().is_none());\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n \n         setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"/home/MountainView\");\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n \n         for s in oldhome.iter() { setenv(\"HOME\", *s) }\n         for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }\n     }\n \n     #[test]\n     fn tmpdir() {\n-        assert!(!os::tmpdir().to_str().is_empty());\n+        let p = os::tmpdir();\n+        let s = p.as_str();\n+        assert!(s.is_some() && s.unwrap() != \".\");\n     }\n \n     // Issue #712\n     #[test]\n     fn test_list_dir_no_invalid_memory_access() {\n-        os::list_dir(&Path(\".\"));\n+        os::list_dir(&Path::from_str(\".\"));\n     }\n \n     #[test]\n     fn list_dir() {\n-        let dirs = os::list_dir(&Path(\".\"));\n+        let dirs = os::list_dir(&Path::from_str(\".\"));\n         // Just assuming that we've got some contents in the current directory\n         assert!(dirs.len() > 0u);\n \n@@ -1895,44 +1905,38 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn list_dir_empty_path() {\n-        let dirs = os::list_dir(&Path(\"\"));\n-        assert!(dirs.is_empty());\n-    }\n-\n     #[test]\n     #[cfg(not(windows))]\n     fn list_dir_root() {\n-        let dirs = os::list_dir(&Path(\"/\"));\n+        let dirs = os::list_dir(&Path::from_str(\"/\"));\n         assert!(dirs.len() > 1);\n     }\n     #[test]\n     #[cfg(windows)]\n     fn list_dir_root() {\n-        let dirs = os::list_dir(&Path(\"C:\\\\\"));\n+        let dirs = os::list_dir(&Path::from_str(\"C:\\\\\"));\n         assert!(dirs.len() > 1);\n     }\n \n \n     #[test]\n     fn path_is_dir() {\n-        assert!((os::path_is_dir(&Path(\".\"))));\n-        assert!((!os::path_is_dir(&Path(\"test/stdtest/fs.rs\"))));\n+        assert!((os::path_is_dir(&Path::from_str(\".\"))));\n+        assert!((!os::path_is_dir(&Path::from_str(\"test/stdtest/fs.rs\"))));\n     }\n \n     #[test]\n     fn path_exists() {\n-        assert!((os::path_exists(&Path(\".\"))));\n-        assert!((!os::path_exists(&Path(\n+        assert!((os::path_exists(&Path::from_str(\".\"))));\n+        assert!((!os::path_exists(&Path::from_str(\n                      \"test/nonexistent-bogus-path\"))));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      assert!(!os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n-                            &Path(\"test/other-bogus-path\")));\n-      assert!(!os::path_exists(&Path(\"test/other-bogus-path\")));\n+      assert!(!os::copy_file(&Path::from_str(\"test/nonexistent-bogus-path\"),\n+                            &Path::from_str(\"test/other-bogus-path\")));\n+      assert!(!os::path_exists(&Path::from_str(\"test/other-bogus-path\")));\n     }\n \n     #[test]\n@@ -1942,9 +1946,8 @@ mod tests {\n         unsafe {\n             let tempdir = getcwd(); // would like to use $TMPDIR,\n                                     // doesn't seem to work on Linux\n-            assert!((tempdir.to_str().len() > 0u));\n-            let input = tempdir.push(\"in.txt\");\n-            let out = tempdir.push(\"out.txt\");\n+            let input = tempdir.join_str(\"in.txt\");\n+            let out = tempdir.join_str(\"out.txt\");\n \n             /* Write the temp input file */\n             let ostream = do input.with_c_str |fromp| {\n@@ -1965,10 +1968,12 @@ mod tests {\n             let in_mode = input.get_mode();\n             let rs = os::copy_file(&input, &out);\n             if (!os::path_exists(&input)) {\n-                fail2!(\"{} doesn't exist\", input.to_str());\n+                fail2!(\"{} doesn't exist\", input.display());\n             }\n             assert!((rs));\n-            let rslt = run::process_status(\"diff\", [input.to_str(), out.to_str()]);\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let rslt = run::process_status(\"diff\", [input.as_str().unwrap().to_owned(),\n+                                                    out.as_str().unwrap().to_owned()]);\n             assert_eq!(rslt, 0);\n             assert_eq!(out.get_mode(), in_mode);\n             assert!((remove_file(&input)));\n@@ -1978,16 +1983,10 @@ mod tests {\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        let path = Path(\"/\");\n+        let path = Path::from_str(\"/\");\n         assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }\n \n-    #[test]\n-    fn recursive_mkdir_empty() {\n-        let path = Path(\"\");\n-        assert!(!os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    }\n-\n     #[test]\n     fn memory_map_rw() {\n         use result::{Ok, Err};\n@@ -2032,7 +2031,8 @@ mod tests {\n            }\n         }\n \n-        let path = tmpdir().push(\"mmap_file.tmp\");\n+        let mut path = tmpdir();\n+        path.push_str(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n         remove_file(&path);\n "}, {"sha": "ea157c6eea65b8431bcf36b459cce74cb46d51d2", "filename": "src/libstd/path.rs", "status": "removed", "additions": 0, "deletions": 1507, "changes": 1507, "blob_url": "https://github.com/rust-lang/rust/blob/6741241f4046aea4014b1a23618593fb481c8606/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6741241f4046aea4014b1a23618593fb481c8606/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=6741241f4046aea4014b1a23618593fb481c8606", "patch": "@@ -1,1507 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Cross-platform file path handling\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use c_str::ToCStr;\n-use c_str;\n-use clone::Clone;\n-use cmp::Eq;\n-use container::Container;\n-use iter::{Iterator, range};\n-use libc;\n-use num;\n-use option::{None, Option, Some};\n-use str::{OwnedStr, Str, StrSlice, StrVector};\n-use to_str::ToStr;\n-use ascii::{AsciiCast, AsciiStr};\n-use vec::{Vector, OwnedVector, ImmutableVector, OwnedCopyableVector};\n-\n-#[cfg(windows)]\n-pub use Path = self::WindowsPath;\n-#[cfg(unix)]\n-pub use Path = self::PosixPath;\n-\n-#[deriving(Clone, Eq)]\n-pub struct WindowsPath {\n-    host: Option<~str>,\n-    device: Option<~str>,\n-    is_absolute: bool,\n-    components: ~[~str],\n-}\n-\n-pub fn WindowsPath(s: &str) -> WindowsPath {\n-    GenericPath::from_str(s)\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct PosixPath {\n-    is_absolute: bool,\n-    components: ~[~str],\n-}\n-\n-pub fn PosixPath(s: &str) -> PosixPath {\n-    GenericPath::from_str(s)\n-}\n-\n-pub trait GenericPath : Clone + Eq + ToStr {\n-    /// Converts a string to a path.\n-    fn from_str(&str) -> Self;\n-\n-    /// Returns the directory component of `self`, as a string.\n-    fn dirname(&self) -> ~str {\n-        let s = self.dir_path().to_str();\n-        match s.len() {\n-            0 => ~\".\",\n-            _ => s,\n-        }\n-    }\n-\n-    /// Returns the file component of `self`, as a string option.\n-    /// Returns None if `self` names a directory.\n-    fn filename<'a>(&'a self) -> Option<&'a str> {\n-        match self.components().len() {\n-            0 => None,\n-            n => Some(self.components()[n - 1].as_slice()),\n-        }\n-    }\n-\n-    /// Returns the stem of the file component of `self`, as a string option.\n-    /// The stem is the slice of a filename starting at 0 and ending just before\n-    /// the last '.' in the name.\n-    /// Returns None if `self` names a directory.\n-    fn filestem<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) => Some(f.slice_to(p)),\n-                    None => Some((*f)),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns the type of the file component of `self`, as a string option.\n-    /// The file type is the slice of a filename starting just after the last\n-    /// '.' in the name and ending at the last index in the filename.\n-    /// Returns None if `self` names a directory.\n-    fn filetype<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) if p < f.len() => Some(f.slice_from(p)),\n-                    _ => None,\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns a new path consisting of `self` with the parent directory component replaced\n-    /// with the given string.\n-    fn with_dirname(&self, (&str)) -> Self;\n-\n-    /// Returns a new path consisting of `self` with the file component replaced\n-    /// with the given string.\n-    fn with_filename(&self, (&str)) -> Self;\n-\n-    /// Returns a new path consisting of `self` with the file stem replaced\n-    /// with the given string.\n-    fn with_filestem(&self, s: &str) -> Self {\n-        match self.filetype() {\n-            None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(s.to_owned() + *t),\n-        }\n-    }\n-\n-    /// Returns a new path consisting of `self` with the file type replaced\n-    /// with the given string.\n-    fn with_filetype(&self, t: &str) -> Self {\n-        match (t.len(), self.filestem()) {\n-            (0, None)        => (*self).clone(),\n-            (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(format!(\".{}\", t)),\n-            (_, Some(ref s)) => self.with_filename(format!(\"{}.{}\", *s, t)),\n-        }\n-    }\n-\n-    /// Returns the directory component of `self`, as a new path.\n-    /// If `self` has no parent, returns `self`.\n-    fn dir_path(&self) -> Self {\n-        match self.components().len() {\n-            0 => (*self).clone(),\n-            _ => self.pop(),\n-        }\n-    }\n-\n-    /// Returns the file component of `self`, as a new path.\n-    /// If `self` names a directory, returns the empty path.\n-    fn file_path(&self) -> Self;\n-\n-    /// Returns a new path whose parent directory is `self` and whose\n-    /// file component is the given string.\n-    fn push(&self, (&str)) -> Self;\n-\n-    /// Returns a new path consisting of the given path, made relative to `self`.\n-    fn push_rel(&self, other: &Self) -> Self {\n-        assert!(!other.is_absolute());\n-        self.push_many(other.components())\n-    }\n-\n-    /// Returns a new path consisting of the path given by the given vector\n-    /// of strings, relative to `self`.\n-    fn push_many<S: Str>(&self, (&[S])) -> Self;\n-\n-    /// Identical to `dir_path` except in the case where `self` has only one\n-    /// component. In this case, `pop` returns the empty path.\n-    fn pop(&self) -> Self;\n-\n-    /// The same as `push_rel`, except that the directory argument must not\n-    /// contain directory separators in any of its components.\n-    fn unsafe_join(&self, (&Self)) -> Self;\n-\n-    /// On Unix, always returns `false`. On Windows, returns `true` iff `self`'s\n-    /// file stem is one of: `con` `aux` `com1` `com2` `com3` `com4`\n-    /// `lpt1` `lpt2` `lpt3` `prn` `nul`.\n-    fn is_restricted(&self) -> bool;\n-\n-    /// Returns a new path that names the same file as `self`, without containing\n-    /// any '.', '..', or empty components. On Windows, uppercases the drive letter\n-    /// as well.\n-    fn normalize(&self) -> Self;\n-\n-    /// Returns `true` if `self` is an absolute path.\n-    fn is_absolute(&self) -> bool;\n-\n-    /// True if `self` is an ancestor of `other`.\n-    // See `test_is_ancestor_of` for examples.\n-    fn is_ancestor_of(&self, other: &Self) -> bool {\n-        debug2!(\"{} / {} {} {}\", self.to_str(), other.to_str(), self.is_absolute(),\n-               self.components().len());\n-        self == other ||\n-            (!other.components().is_empty() &&\n-             !(self.components().is_empty() && !self.is_absolute()) &&\n-             self.is_ancestor_of(&other.pop()))\n-    }\n-\n-    /// Finds the relative path from one file to another.\n-    fn get_relative_to(&self, abs2: (&Self)) -> Self {\n-        assert!(self.is_absolute());\n-        assert!(abs2.is_absolute());\n-        let abs1 = self.normalize();\n-        let abs2 = abs2.normalize();\n-\n-        let split1: &[~str] = abs1.components();\n-        let split2: &[~str] = abs2.components();\n-        let len1 = split1.len();\n-        let len2 = split2.len();\n-        assert!(len1 > 0);\n-        assert!(len2 > 0);\n-\n-        let max_common_path = num::min(len1, len2) - 1;\n-        let mut start_idx = 0;\n-        while start_idx < max_common_path\n-            && split1[start_idx] == split2[start_idx] {\n-            start_idx += 1;\n-        }\n-\n-        let mut path: ~[~str] = ~[];\n-        for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n-\n-        path.push_all(split2.slice(start_idx, len2 - 1));\n-\n-        let mut result: Self = GenericPath::from_str(\".\");\n-        if !path.is_empty() {\n-            // Without this type hint, the typechecker doesn't seem to like it\n-            let p: Self = GenericPath::from_str(\"\");\n-            result = p.push_many(path);\n-        };\n-        result\n-    }\n-\n-\n-    /// Returns `true` iff `child` is a suffix of `parent`. See the test\n-    /// case for examples.\n-    fn is_parent_of(&self, child: &Self) -> bool {\n-        if !self.is_absolute() || child.is_absolute()\n-            || self.components().len() < child.components().len()\n-            || self.components().is_empty() {\n-            return false;\n-        }\n-        let child_components = child.components().len();\n-        let parent_components = self.components().len();\n-        let to_drop = self.components().len() - child_components;\n-        self.components().slice(to_drop, parent_components) == child.components()\n-    }\n-\n-    fn components<'a>(&'a self) -> &'a [~str];\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-mod stat {\n-    #[cfg(target_arch = \"x86\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                __pad1: 0,\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                __pad2: 0,\n-                st_size: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                __unused4: 0,\n-                __unused5: 0,\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"arm\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                __pad0: [0, ..4],\n-                __st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                __pad3: [0, ..4],\n-                st_size: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_ino: 0\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"mips\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_pad1: [0, ..3],\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_pad2: [0, ..2],\n-                st_size: 0,\n-                st_pad3: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_pad5: [0, ..14],\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_ino: 0,\n-                st_nlink: 0,\n-                st_mode: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                __pad0: 0,\n-                st_rdev: 0,\n-                st_size: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                __unused: [0, 0, 0],\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-mod stat {\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_size: 0,\n-                st_blocks: 0,\n-                st_blksize: 0,\n-                st_flags: 0,\n-                st_gen: 0,\n-                st_lspare: 0,\n-                st_birthtime: 0,\n-                st_birthtime_nsec: 0,\n-                __unused: [0, 0],\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-mod stat {\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_ino: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_birthtime: 0,\n-                st_birthtime_nsec: 0,\n-                st_size: 0,\n-                st_blocks: 0,\n-                st_blksize: 0,\n-                st_flags: 0,\n-                st_gen: 0,\n-                st_lspare: 0,\n-                st_qspare: [0, 0],\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-mod stat {\n-    pub mod arch {\n-        use libc;\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_size: 0,\n-                st_atime: 0,\n-                st_mtime: 0,\n-                st_ctime: 0,\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-impl WindowsPath {\n-    pub fn stat(&self) -> Option<libc::stat> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do self.with_c_str |buf| {\n-            let mut st = stat::arch::default_stat();\n-            match unsafe { libc::stat(buf, &mut st) } {\n-                0 => Some(st),\n-                _ => None,\n-            }\n-        }\n-    }\n-\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true,\n-        }\n-    }\n-\n-    pub fn get_size(&self) -> Option<i64> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_size as i64),\n-        }\n-    }\n-\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_mode as uint),\n-        }\n-    }\n-}\n-\n-#[cfg(not(target_os = \"win32\"))]\n-impl PosixPath {\n-    pub fn stat(&self) -> Option<libc::stat> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do self.with_c_str |buf| {\n-            let mut st = stat::arch::default_stat();\n-            match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n-                0 => Some(st),\n-                _ => None,\n-            }\n-        }\n-    }\n-\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true,\n-        }\n-    }\n-\n-    pub fn get_size(&self) -> Option<i64> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_size as i64),\n-        }\n-    }\n-\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_mode as uint),\n-        }\n-    }\n-\n-    /// Executes a function `f` on `self` as well as on all of its ancestors.\n-    pub fn each_parent(&self, f: &fn(&Path)) {\n-        if !self.components.is_empty() {\n-            f(self);\n-            self.pop().each_parent(f);\n-        }\n-    }\n-\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-impl PosixPath {\n-    pub fn get_atime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_atime as i64,\n-                      st.st_atime_nsec as int))\n-            }\n-        }\n-    }\n-\n-    pub fn get_mtime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_mtime as i64,\n-                      st.st_mtime_nsec as int))\n-            }\n-        }\n-    }\n-\n-    pub fn get_ctime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_ctime as i64,\n-                      st.st_ctime_nsec as int))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-impl PosixPath {\n-    pub fn lstat(&self) -> Option<libc::stat> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do self.with_c_str |buf| {\n-            let mut st = stat::arch::default_stat();\n-            match unsafe { libc::lstat(buf, &mut st) } {\n-                0 => Some(st),\n-                _ => None,\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"macos\")]\n-impl PosixPath {\n-    pub fn get_birthtime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_birthtime as i64,\n-                      st.st_birthtime_nsec as int))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-impl WindowsPath {\n-    pub fn get_atime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_atime as i64, 0))\n-            }\n-        }\n-    }\n-\n-    pub fn get_mtime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_mtime as i64, 0))\n-            }\n-        }\n-    }\n-\n-    pub fn get_ctime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_ctime as i64, 0))\n-            }\n-        }\n-    }\n-\n-    /// Executes a function `f` on `self` as well as on all of its ancestors.\n-    pub fn each_parent(&self, f: &fn(&Path)) {\n-        if !self.components.is_empty() {\n-            f(self);\n-            self.pop().each_parent(f);\n-        }\n-    }\n-}\n-\n-impl ToStr for PosixPath {\n-    fn to_str(&self) -> ~str {\n-        let mut s = ~\"\";\n-        if self.is_absolute {\n-            s.push_str(\"/\");\n-        }\n-        s + self.components.connect(\"/\")\n-    }\n-}\n-\n-impl ToCStr for PosixPath {\n-    fn to_c_str(&self) -> c_str::CString {\n-        self.to_str().to_c_str()\n-    }\n-\n-    unsafe fn to_c_str_unchecked(&self) -> c_str::CString {\n-        self.to_str().to_c_str_unchecked()\n-    }\n-}\n-\n-impl GenericPath for PosixPath {\n-    fn from_str(s: &str) -> PosixPath {\n-        let components = s.split_iter('/')\n-            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n-            .collect();\n-        let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n-        PosixPath {\n-            is_absolute: is_absolute,\n-            components: components,\n-        }\n-    }\n-\n-    fn with_dirname(&self, d: &str) -> PosixPath {\n-        let dpath = PosixPath(d);\n-        match self.filename() {\n-            Some(ref f) => dpath.push(*f),\n-            None => dpath,\n-        }\n-    }\n-\n-    fn with_filename(&self, f: &str) -> PosixPath {\n-        assert!(!f.iter().all(posix::is_sep));\n-        self.dir_path().push(f)\n-    }\n-\n-    fn file_path(&self) -> PosixPath {\n-        let cs = match self.filename() {\n-          None => ~[],\n-          Some(ref f) => ~[(*f).to_owned()]\n-        };\n-        PosixPath {\n-            is_absolute: false,\n-            components: cs,\n-        }\n-    }\n-\n-    fn push(&self, s: &str) -> PosixPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(posix::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        PosixPath {\n-            components: v,\n-            ..(*self).clone()\n-        }\n-    }\n-\n-    fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n-        let mut v = self.components.clone();\n-        for e in cs.iter() {\n-            for s in e.as_slice().split_iter(posix::is_sep) {\n-                if !s.is_empty() {\n-                    v.push(s.to_owned())\n-                }\n-            }\n-        }\n-        PosixPath {\n-            is_absolute: self.is_absolute,\n-            components: v,\n-        }\n-    }\n-\n-    fn pop(&self) -> PosixPath {\n-        let mut cs = self.components.clone();\n-        if cs.len() != 0 {\n-            cs.pop();\n-        }\n-        PosixPath {\n-            is_absolute: self.is_absolute,\n-            components: cs,\n-        } //..self }\n-    }\n-\n-    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n-        if other.is_absolute {\n-            PosixPath {\n-                is_absolute: true,\n-                components: other.components.clone(),\n-            }\n-        } else {\n-            self.push_rel(other)\n-        }\n-    }\n-\n-    fn is_restricted(&self) -> bool {\n-        false\n-    }\n-\n-    fn normalize(&self) -> PosixPath {\n-        PosixPath {\n-            is_absolute: self.is_absolute,\n-            components: normalize(self.components),\n-        } // ..self }\n-    }\n-\n-    fn is_absolute(&self) -> bool {\n-        self.is_absolute\n-    }\n-\n-    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n-\n-}\n-\n-\n-impl ToStr for WindowsPath {\n-    fn to_str(&self) -> ~str {\n-        let mut s = ~\"\";\n-        match self.host {\n-          Some(ref h) => {\n-            s.push_str(\"\\\\\\\\\");\n-            s.push_str(*h);\n-          }\n-          None => { }\n-        }\n-        match self.device {\n-          Some(ref d) => {\n-            s.push_str(*d);\n-            s.push_str(\":\");\n-          }\n-          None => { }\n-        }\n-        if self.is_absolute {\n-            s.push_str(\"\\\\\");\n-        }\n-        s + self.components.connect(\"\\\\\")\n-    }\n-}\n-\n-impl c_str::ToCStr for WindowsPath {\n-    fn to_c_str(&self) -> c_str::CString {\n-        self.to_str().to_c_str()\n-    }\n-\n-    unsafe fn to_c_str_unchecked(&self) -> c_str::CString {\n-        self.to_str().to_c_str_unchecked()\n-    }\n-}\n-\n-impl GenericPath for WindowsPath {\n-    fn from_str(s: &str) -> WindowsPath {\n-        let host;\n-        let device;\n-        let rest;\n-\n-        match (\n-            windows::extract_drive_prefix(s),\n-            windows::extract_unc_prefix(s),\n-        ) {\n-            (Some((ref d, ref r)), _) => {\n-                host = None;\n-                device = Some((*d).clone());\n-                rest = (*r).clone();\n-            }\n-            (None, Some((ref h, ref r))) => {\n-                host = Some((*h).clone());\n-                device = None;\n-                rest = (*r).clone();\n-            }\n-            (None, None) => {\n-                host = None;\n-                device = None;\n-                rest = s.to_owned();\n-            }\n-        }\n-\n-        let components = rest.split_iter(windows::is_sep)\n-            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n-            .collect();\n-\n-        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0] as char));\n-        WindowsPath {\n-            host: host,\n-            device: device,\n-            is_absolute: is_absolute,\n-            components: components,\n-        }\n-    }\n-\n-    fn with_dirname(&self, d: &str) -> WindowsPath {\n-        let dpath = WindowsPath(d);\n-        match self.filename() {\n-            Some(ref f) => dpath.push(*f),\n-            None => dpath,\n-        }\n-    }\n-\n-    fn with_filename(&self, f: &str) -> WindowsPath {\n-        assert!(! f.iter().all(windows::is_sep));\n-        self.dir_path().push(f)\n-    }\n-\n-    fn file_path(&self) -> WindowsPath {\n-        WindowsPath {\n-            host: None,\n-            device: None,\n-            is_absolute: false,\n-            components: match self.filename() {\n-                None => ~[],\n-                Some(ref f) => ~[(*f).to_owned()],\n-            }\n-        }\n-    }\n-\n-    fn push(&self, s: &str) -> WindowsPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(windows::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        WindowsPath { components: v, ..(*self).clone() }\n-    }\n-\n-    fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n-        let mut v = self.components.clone();\n-        for e in cs.iter() {\n-            for s in e.as_slice().split_iter(windows::is_sep) {\n-                if !s.is_empty() {\n-                    v.push(s.to_owned())\n-                }\n-            }\n-        }\n-        // tedious, but as-is, we can't use ..self\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute,\n-            components: v\n-        }\n-    }\n-\n-    fn pop(&self) -> WindowsPath {\n-        let mut cs = self.components.clone();\n-        if cs.len() != 0 {\n-            cs.pop();\n-        }\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute,\n-            components: cs,\n-        }\n-    }\n-\n-    fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n-        /* rhs not absolute is simple push */\n-        if !other.is_absolute {\n-            return self.push_many(other.components);\n-        }\n-\n-        /* if rhs has a host set, then the whole thing wins */\n-        match other.host {\n-            Some(ref host) => {\n-                return WindowsPath {\n-                    host: Some((*host).clone()),\n-                    device: other.device.clone(),\n-                    is_absolute: true,\n-                    components: other.components.clone(),\n-                };\n-            }\n-            _ => {}\n-        }\n-\n-        /* if rhs has a device set, then a part wins */\n-        match other.device {\n-            Some(ref device) => {\n-                return WindowsPath {\n-                    host: None,\n-                    device: Some((*device).clone()),\n-                    is_absolute: true,\n-                    components: other.components.clone(),\n-                };\n-            }\n-            _ => {}\n-        }\n-\n-        /* fallback: host and device of lhs win, but the\n-           whole path of the right */\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute || other.is_absolute,\n-            components: other.components.clone(),\n-        }\n-    }\n-\n-    fn is_restricted(&self) -> bool {\n-        match self.filestem() {\n-            Some(stem) => {\n-                // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-                // to_ascii_move and to_str_move to not do a unnecessary copy.\n-                match stem.to_ascii().to_lower().to_str_ascii() {\n-                    ~\"con\" | ~\"aux\" | ~\"com1\" | ~\"com2\" | ~\"com3\" | ~\"com4\" |\n-                    ~\"lpt1\" | ~\"lpt2\" | ~\"lpt3\" | ~\"prn\" | ~\"nul\" => true,\n-                    _ => false\n-                }\n-            },\n-            None => false\n-        }\n-    }\n-\n-    fn normalize(&self) -> WindowsPath {\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: match self.device {\n-                None => None,\n-\n-                // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-                // to_ascii_move and to_str_move to not do a unnecessary copy.\n-                Some(ref device) => Some(device.to_ascii().to_upper().to_str_ascii())\n-            },\n-            is_absolute: self.is_absolute,\n-            components: normalize(self.components)\n-        }\n-    }\n-\n-    fn is_absolute(&self) -> bool {\n-        self.is_absolute\n-    }\n-\n-    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n-\n-}\n-\n-pub fn normalize(components: &[~str]) -> ~[~str] {\n-    let mut cs = ~[];\n-    for c in components.iter() {\n-        if *c == ~\".\" && components.len() > 1 { continue; }\n-        if *c == ~\"\" { continue; }\n-        if *c == ~\"..\" && cs.len() != 0 {\n-            cs.pop();\n-            continue;\n-        }\n-        cs.push((*c).clone());\n-    }\n-    cs\n-}\n-\n-// Various posix helpers.\n-pub mod posix {\n-\n-    #[inline]\n-    pub fn is_sep(u: char) -> bool {\n-        u == '/'\n-    }\n-\n-}\n-\n-// Various windows helpers.\n-pub mod windows {\n-    use libc;\n-    use option::{None, Option, Some};\n-\n-    #[inline]\n-    pub fn is_sep(u: char) -> bool {\n-        u == '/' || u == '\\\\'\n-    }\n-\n-    pub fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n-        if (s.len() > 1 &&\n-            (s[0] == '\\\\' as u8 || s[0] == '/' as u8) &&\n-            s[0] == s[1]) {\n-            let mut i = 2;\n-            while i < s.len() {\n-                if is_sep(s[i] as char) {\n-                    let pre = s.slice(2, i).to_owned();\n-                    let rest = s.slice(i, s.len()).to_owned();\n-                    return Some((pre, rest));\n-                }\n-                i += 1;\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            if (s.len() > 1 &&\n-                libc::isalpha(s[0] as libc::c_int) != 0 &&\n-                s[1] == ':' as u8) {\n-                let rest = if s.len() == 2 {\n-                    ~\"\"\n-                } else {\n-                    s.slice(2, s.len()).to_owned()\n-                };\n-                return Some((s.slice(0,1).to_owned(), rest));\n-            }\n-            None\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use option::{None, Some};\n-    use path::{PosixPath, WindowsPath, windows};\n-\n-    #[test]\n-    fn test_double_slash_collapsing() {\n-        let path = PosixPath(\"tmp/\");\n-        let path = path.push(\"/hmm\");\n-        let path = path.normalize();\n-        assert_eq!(~\"tmp/hmm\", path.to_str());\n-\n-        let path = WindowsPath(\"tmp/\");\n-        let path = path.push(\"/hmm\");\n-        let path = path.normalize();\n-        assert_eq!(~\"tmp\\\\hmm\", path.to_str());\n-    }\n-\n-    #[test]\n-    fn test_filetype_foo_bar() {\n-        let wp = PosixPath(\"foo.bar\");\n-        assert_eq!(wp.filetype(), Some(\".bar\"));\n-\n-        let wp = WindowsPath(\"foo.bar\");\n-        assert_eq!(wp.filetype(), Some(\".bar\"));\n-    }\n-\n-    #[test]\n-    fn test_filetype_foo() {\n-        let wp = PosixPath(\"foo\");\n-        assert_eq!(wp.filetype(), None);\n-\n-        let wp = WindowsPath(\"foo\");\n-        assert_eq!(wp.filetype(), None);\n-    }\n-\n-    #[test]\n-    fn test_posix_paths() {\n-        fn t(wp: &PosixPath, s: &str) {\n-            let ss = wp.to_str();\n-            let sss = s.to_owned();\n-            if (ss != sss) {\n-                debug2!(\"got {}\", ss);\n-                debug2!(\"expected {}\", sss);\n-                assert_eq!(ss, sss);\n-            }\n-        }\n-\n-        t(&(PosixPath(\"hi\")), \"hi\");\n-        t(&(PosixPath(\"/lib\")), \"/lib\");\n-        t(&(PosixPath(\"hi/there\")), \"hi/there\");\n-        t(&(PosixPath(\"hi/there.txt\")), \"hi/there.txt\");\n-\n-        t(&(PosixPath(\"hi/there.txt\")), \"hi/there.txt\");\n-        t(&(PosixPath(\"hi/there.txt\")\n-           .with_filetype(\"\")), \"hi/there\");\n-\n-        t(&(PosixPath(\"/a/b/c/there.txt\")\n-            .with_dirname(\"hi\")), \"hi/there.txt\");\n-\n-        t(&(PosixPath(\"hi/there.txt\")\n-            .with_dirname(\".\")), \"./there.txt\");\n-\n-        t(&(PosixPath(\"a/b/c\")\n-            .push(\"..\")), \"a/b/c/..\");\n-\n-        t(&(PosixPath(\"there.txt\")\n-            .with_filetype(\"o\")), \"there.o\");\n-\n-        t(&(PosixPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")), \"hi/there.o\");\n-\n-        t(&(PosixPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"/usr/lib\")),\n-          \"/usr/lib/there.o\");\n-\n-        t(&(PosixPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"/usr/lib/\")),\n-          \"/usr/lib/there.o\");\n-\n-        t(&(PosixPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"/usr//lib//\")),\n-            \"/usr/lib/there.o\");\n-\n-        t(&(PosixPath(\"/usr/bin/rust\")\n-            .push_many([~\"lib\", ~\"thingy.so\"])\n-            .with_filestem(\"librustc\")),\n-          \"/usr/bin/rust/lib/librustc.so\");\n-\n-    }\n-\n-    #[test]\n-    fn test_posix_push_with_backslash() {\n-        let a = PosixPath(\"/aaa/bbb\");\n-        let b = a.push(\"x\\\\y\"); // \\ is not a file separator for posix paths\n-        assert_eq!(a.components.len(), 2);\n-        assert_eq!(b.components.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_normalize() {\n-        fn t(wp: &PosixPath, s: &str) {\n-            let ss = wp.to_str();\n-            let sss = s.to_owned();\n-            if (ss != sss) {\n-                debug2!(\"got {}\", ss);\n-                debug2!(\"expected {}\", sss);\n-                assert_eq!(ss, sss);\n-            }\n-        }\n-\n-        t(&(PosixPath(\"hi/there.txt\")\n-            .with_dirname(\".\").normalize()), \"there.txt\");\n-\n-        t(&(PosixPath(\"a/b/../c/././/../foo.txt/\").normalize()),\n-          \"a/foo.txt\");\n-\n-        t(&(PosixPath(\"a/b/c\")\n-            .push(\"..\").normalize()), \"a/b\");\n-    }\n-\n-    #[test]\n-    fn test_extract_unc_prefixes() {\n-        assert!(windows::extract_unc_prefix(\"\\\\\\\\\").is_none());\n-        assert!(windows::extract_unc_prefix(\"//\").is_none());\n-        assert!(windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none());\n-        assert!(windows::extract_unc_prefix(\"//hi\").is_none());\n-        assert!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n-            Some((~\"hi\", ~\"\\\\\")));\n-        assert!(windows::extract_unc_prefix(\"//hi\\\\\") ==\n-            Some((~\"hi\", ~\"\\\\\")));\n-        assert!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n-            Some((~\"hi\", ~\"\\\\there\")));\n-        assert!(windows::extract_unc_prefix(\"//hi/there\") ==\n-            Some((~\"hi\", ~\"/there\")));\n-        assert!(windows::extract_unc_prefix(\n-            \"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n-        assert!(windows::extract_unc_prefix(\n-            \"//hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n-    }\n-\n-    #[test]\n-    fn test_extract_drive_prefixes() {\n-        assert!(windows::extract_drive_prefix(\"c\").is_none());\n-        assert!(windows::extract_drive_prefix(\"c:\") ==\n-                     Some((~\"c\", ~\"\")));\n-        assert!(windows::extract_drive_prefix(\"d:\") ==\n-                     Some((~\"d\", ~\"\")));\n-        assert!(windows::extract_drive_prefix(\"z:\") ==\n-                     Some((~\"z\", ~\"\")));\n-        assert!(windows::extract_drive_prefix(\"c:\\\\hi\") ==\n-                     Some((~\"c\", ~\"\\\\hi\")));\n-        assert!(windows::extract_drive_prefix(\"d:hi\") ==\n-                     Some((~\"d\", ~\"hi\")));\n-        assert!(windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n-                     Some((~\"c\", ~\"hi\\\\there.txt\")));\n-        assert!(windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n-                     Some((~\"c\", ~\"\\\\hi\\\\there.txt\")));\n-    }\n-\n-    #[test]\n-    fn test_windows_paths() {\n-        fn t(wp: &WindowsPath, s: &str) {\n-            let ss = wp.to_str();\n-            let sss = s.to_owned();\n-            if (ss != sss) {\n-                debug2!(\"got {}\", ss);\n-                debug2!(\"expected {}\", sss);\n-                assert_eq!(ss, sss);\n-            }\n-        }\n-\n-        t(&(WindowsPath(\"hi\")), \"hi\");\n-        t(&(WindowsPath(\"hi/there\")), \"hi\\\\there\");\n-        t(&(WindowsPath(\"hi/there.txt\")), \"hi\\\\there.txt\");\n-\n-        t(&(WindowsPath(\"there.txt\")\n-            .with_filetype(\"o\")), \"there.o\");\n-\n-        t(&(WindowsPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")), \"hi\\\\there.o\");\n-\n-        t(&(WindowsPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"c:\\\\program files A\")),\n-          \"c:\\\\program files A\\\\there.o\");\n-\n-        t(&(WindowsPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"c:\\\\program files B\\\\\")),\n-          \"c:\\\\program files B\\\\there.o\");\n-\n-        t(&(WindowsPath(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"c:\\\\program files C\\\\/\")),\n-            \"c:\\\\program files C\\\\there.o\");\n-\n-        t(&(WindowsPath(\"c:\\\\program files (x86)\\\\rust\")\n-            .push_many([~\"lib\", ~\"thingy.dll\"])\n-            .with_filename(\"librustc.dll\")),\n-          \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n-\n-        t(&(WindowsPath(\"\\\\\\\\computer\\\\share\")\n-            .unsafe_join(&WindowsPath(\"\\\\a\"))),\n-          \"\\\\\\\\computer\\\\a\");\n-\n-        t(&(WindowsPath(\"//computer/share\")\n-            .unsafe_join(&WindowsPath(\"\\\\a\"))),\n-          \"\\\\\\\\computer\\\\a\");\n-\n-        t(&(WindowsPath(\"//computer/share\")\n-            .unsafe_join(&WindowsPath(\"\\\\\\\\computer\\\\share\"))),\n-          \"\\\\\\\\computer\\\\share\");\n-\n-        t(&(WindowsPath(\"C:/whatever\")\n-            .unsafe_join(&WindowsPath(\"//computer/share/a/b\"))),\n-          \"\\\\\\\\computer\\\\share\\\\a\\\\b\");\n-\n-        t(&(WindowsPath(\"C:\")\n-            .unsafe_join(&WindowsPath(\"D:/foo\"))),\n-          \"D:\\\\foo\");\n-\n-        t(&(WindowsPath(\"C:\")\n-            .unsafe_join(&WindowsPath(\"B\"))),\n-          \"C:B\");\n-\n-        t(&(WindowsPath(\"C:\")\n-            .unsafe_join(&WindowsPath(\"/foo\"))),\n-          \"C:\\\\foo\");\n-\n-        t(&(WindowsPath(\"C:\\\\\")\n-            .unsafe_join(&WindowsPath(\"\\\\bar\"))),\n-          \"C:\\\\bar\");\n-\n-        t(&(WindowsPath(\"\")\n-            .unsafe_join(&WindowsPath(\"\"))),\n-          \"\");\n-\n-        t(&(WindowsPath(\"\")\n-            .unsafe_join(&WindowsPath(\"a\"))),\n-          \"a\");\n-\n-        t(&(WindowsPath(\"\")\n-            .unsafe_join(&WindowsPath(\"C:\\\\a\"))),\n-          \"C:\\\\a\");\n-\n-        t(&(WindowsPath(\"c:\\\\foo\")\n-            .normalize()),\n-          \"C:\\\\foo\");\n-    }\n-\n-    #[test]\n-    fn test_windows_path_restrictions() {\n-        assert_eq!(WindowsPath(\"hi\").is_restricted(), false);\n-        assert_eq!(WindowsPath(\"C:\\\\NUL\").is_restricted(), true);\n-        assert_eq!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted(), true);\n-        assert_eq!(WindowsPath(\"c:\\\\prn.exe\").is_restricted(), true);\n-    }\n-\n-    #[test]\n-    fn test_is_ancestor_of() {\n-        assert!(&PosixPath(\"/a/b\").is_ancestor_of(&PosixPath(\"/a/b/c/d\")));\n-        assert!(!&PosixPath(\"/a/b/c/d\").is_ancestor_of(&PosixPath(\"/a/b\")));\n-        assert!(!&PosixPath(\"/a/b\").is_ancestor_of(&PosixPath(\"/c/d\")));\n-        assert!(&PosixPath(\"/a/b\").is_ancestor_of(&PosixPath(\"/a/b/c/d\")));\n-        assert!(&PosixPath(\"/\").is_ancestor_of(&PosixPath(\"/a/b/c\")));\n-        assert!(!&PosixPath(\"/\").is_ancestor_of(&PosixPath(\"\")));\n-        assert!(!&PosixPath(\"/a/b/c\").is_ancestor_of(&PosixPath(\"\")));\n-        assert!(!&PosixPath(\"\").is_ancestor_of(&PosixPath(\"/a/b/c\")));\n-\n-        assert!(&WindowsPath(\"C:\\\\a\\\\b\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\")));\n-        assert!(!&WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\")));\n-        assert!(!&WindowsPath(\"C:\\\\a\\\\b\").is_ancestor_of(&WindowsPath(\"C:\\\\c\\\\d\")));\n-        assert!(&WindowsPath(\"C:\\\\a\\\\b\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\")));\n-        assert!(&WindowsPath(\"C:\\\\\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\")));\n-        assert!(!&WindowsPath(\"C:\\\\\").is_ancestor_of(&WindowsPath(\"\")));\n-        assert!(!&WindowsPath(\"C:\\\\a\\\\b\\\\c\").is_ancestor_of(&WindowsPath(\"\")));\n-        assert!(!&WindowsPath(\"\").is_ancestor_of(&WindowsPath(\"C:\\\\a\\\\b\\\\c\")));\n-\n-    }\n-\n-    #[test]\n-    fn test_relative_to1() {\n-        let p1 = PosixPath(\"/usr/bin/rustc\");\n-        let p2 = PosixPath(\"/usr/lib/mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"../lib\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\rustc\");\n-        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n-\n-    }\n-\n-    #[test]\n-    fn test_relative_to2() {\n-        let p1 = PosixPath(\"/usr/bin/rustc\");\n-        let p2 = PosixPath(\"/usr/bin/../lib/mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"../lib\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\rustc\");\n-        let p2 = WindowsPath(\"C:\\\\usr\\\\bin\\\\..\\\\lib\\\\mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to3() {\n-        let p1 = PosixPath(\"/usr/bin/whatever/rustc\");\n-        let p2 = PosixPath(\"/usr/lib/whatever/mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"../../lib/whatever\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\whatever\\\\rustc\");\n-        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"..\\\\..\\\\lib\\\\whatever\"));\n-\n-    }\n-\n-    #[test]\n-    fn test_relative_to4() {\n-        let p1 = PosixPath(\"/usr/bin/whatever/../rustc\");\n-        let p2 = PosixPath(\"/usr/lib/whatever/mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"../lib/whatever\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\whatever\\\\..\\\\rustc\");\n-        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"..\\\\lib\\\\whatever\"));\n-\n-    }\n-\n-    #[test]\n-    fn test_relative_to5() {\n-        let p1 = PosixPath(\"/usr/bin/whatever/../rustc\");\n-        let p2 = PosixPath(\"/usr/lib/whatever/../mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"../lib\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\usr\\\\bin/whatever\\\\..\\\\rustc\");\n-        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\..\\\\mylib\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to6() {\n-        let p1 = PosixPath(\"/1\");\n-        let p2 = PosixPath(\"/2/3\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"2\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\1\");\n-        let p2 = WindowsPath(\"C:\\\\2\\\\3\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"2\"));\n-\n-    }\n-\n-    #[test]\n-    fn test_relative_to7() {\n-        let p1 = PosixPath(\"/1/2\");\n-        let p2 = PosixPath(\"/3\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, PosixPath(\"..\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\1\\\\2\");\n-        let p2 = WindowsPath(\"C:\\\\3\");\n-        let res = p1.get_relative_to(&p2);\n-        assert_eq!(res, WindowsPath(\"..\"));\n-\n-    }\n-\n-    #[test]\n-    fn test_relative_to8() {\n-        let p1 = PosixPath(\"/home/brian/Dev/rust/build/\").push_rel(\n-            &PosixPath(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n-        let p2 = PosixPath(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n-            &PosixPath(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n-        let res = p1.get_relative_to(&p2);\n-        debug2!(\"test_relative_to8: {} vs. {}\",\n-               res.to_str(),\n-               PosixPath(\".\").to_str());\n-        assert_eq!(res, PosixPath(\".\"));\n-\n-        let p1 = WindowsPath(\"C:\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\\").push_rel(\n-            &WindowsPath(\"stage2\\\\lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\librustc.so\"));\n-        let p2 = WindowsPath(\"\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\stage2\\\\bin\\\\..\").push_rel(\n-            &WindowsPath(\"lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\libstd.so\"));\n-        let res = p1.get_relative_to(&p2);\n-        debug2!(\"test_relative_to8: {} vs. {}\",\n-               res.to_str(),\n-               WindowsPath(\".\").to_str());\n-        assert_eq!(res, WindowsPath(\".\"));\n-\n-    }\n-\n-\n-    #[test]\n-    fn test_is_parent_of() {\n-        fn is_parent_of_pp(p: &PosixPath, q: &PosixPath) -> bool {\n-            p.is_parent_of(q)\n-        }\n-\n-        assert!(is_parent_of_pp(&PosixPath(\"/a/b/c/d/e\"), &PosixPath(\"c/d/e\")));\n-        assert!(!is_parent_of_pp(&PosixPath(\"a/b/c/d/e\"), &PosixPath(\"c/d/e\")));\n-        assert!(!is_parent_of_pp(&PosixPath(\"/a/b/c/d/e\"), &PosixPath(\"/c/d/e\")));\n-        assert!(!is_parent_of_pp(&PosixPath(\"\"), &PosixPath(\"\")));\n-        assert!(!is_parent_of_pp(&PosixPath(\"\"), &PosixPath(\"a/b/c\")));\n-        assert!(is_parent_of_pp(&PosixPath(\"/a/b/c\"), &PosixPath(\"\")));\n-        assert!(is_parent_of_pp(&PosixPath(\"/a/b/c\"), &PosixPath(\"a/b/c\")));\n-        assert!(!is_parent_of_pp(&PosixPath(\"/a/b/c\"), &PosixPath(\"d/e/f\")));\n-\n-        fn is_parent_of_wp(p: &WindowsPath, q: &WindowsPath) -> bool {\n-            p.is_parent_of(q)\n-        }\n-\n-        let abcde = WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\\\\e\");\n-        let rel_abcde = WindowsPath(\"a\\\\b\\\\c\\\\d\\\\e\");\n-        let cde   = WindowsPath(\"c\\\\d\\\\e\");\n-        let slashcde = WindowsPath(\"C:\\\\c\\\\d\\\\e\");\n-        let empty = WindowsPath(\"\");\n-        let abc = WindowsPath(\"C:\\\\a\\\\b\\\\c\");\n-        let rel_abc = WindowsPath(\"a\\\\b\\\\c\");\n-        let def = WindowsPath(\"d\\\\e\\\\f\");\n-\n-        assert!(is_parent_of_wp(&abcde, &cde));\n-        assert!(!is_parent_of_wp(&rel_abcde, &cde));\n-        assert!(!is_parent_of_wp(&abcde, &slashcde));\n-        assert!(!is_parent_of_wp(&empty, &empty));\n-        assert!(!is_parent_of_wp(&empty, &rel_abc));\n-        assert!(is_parent_of_wp(&abc, &empty));\n-        assert!(is_parent_of_wp(&abc, &rel_abc));\n-        assert!(!is_parent_of_wp(&abc, &def));\n-    }\n-\n-}"}, {"sha": "db6bfada8c08f3fc9926eafcee7d593bf687249f", "filename": "src/libstd/path/mod.rs", "status": "renamed", "additions": 275, "deletions": 110, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -19,7 +19,7 @@ use option::{Option, None, Some};\n use str;\n use str::{OwnedStr, Str, StrSlice};\n use vec;\n-use vec::{CopyableVector, OwnedCopyableVector, OwnedVector};\n+use vec::{CopyableVector, OwnedCopyableVector, OwnedVector, Vector};\n use vec::{ImmutableEqVector, ImmutableVector};\n \n /// Typedef for POSIX file paths.\n@@ -37,20 +37,31 @@ pub use Path = self::posix::Path;\n #[cfg(windows)]\n pub use Path = self::windows::Path;\n \n-/// Typedef for the POSIX path component iterator.\n-/// See `posix::ComponentIter` for more info.\n-pub use PosixComponentIter = self::posix::ComponentIter;\n-\n-/// Typedef for the Windows path component iterator.\n-/// See `windows::ComponentIter` for more info.\n-pub use WindowsComponentIter = self::windows::ComponentIter;\n-\n /// Typedef for the platform-native component iterator\n #[cfg(unix)]\n pub use ComponentIter = self::posix::ComponentIter;\n+/// Typedef for the platform-native reverse component iterator\n+#[cfg(unix)]\n+pub use RevComponentIter = self::posix::RevComponentIter;\n /// Typedef for the platform-native component iterator\n #[cfg(windows)]\n pub use ComponentIter = self::windows::ComponentIter;\n+/// Typedef for the platform-native reverse component iterator\n+#[cfg(windows)]\n+pub use RevComponentIter = self::windows::RevComponentIter;\n+\n+/// Typedef for the platform-native str component iterator\n+#[cfg(unix)]\n+pub use StrComponentIter = self::posix::StrComponentIter;\n+/// Typedef for the platform-native reverse str component iterator\n+#[cfg(unix)]\n+pub use RevStrComponentIter = self::posix::RevStrComponentIter;\n+/// Typedef for the platform-native str component iterator\n+#[cfg(windows)]\n+pub use StrComponentIter = self::windows::StrComponentIter;\n+/// Typedef for the platform-native reverse str component iterator\n+#[cfg(windows)]\n+pub use RevStrComponentIter = self::windows::RevStrComponentIter;\n \n pub mod posix;\n pub mod windows;\n@@ -128,7 +139,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     #[inline]\n     fn from_c_str(path: CString) -> Self {\n         // CStrings can't contain NULs\n-        unsafe { GenericPathUnsafe::from_vec_unchecked(path.as_bytes()) }\n+        let v = path.as_bytes();\n+        // v is NUL-terminated. Strip it off\n+        let v = v.slice_to(v.len()-1);\n+        unsafe { GenericPathUnsafe::from_vec_unchecked(v) }\n     }\n \n     /// Returns the path as a string, if possible.\n@@ -146,7 +160,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the unicode\n     /// replacement char. This involves allocation.\n     #[inline]\n-    fn as_display_str<T>(&self, f: &fn(&str) -> T) -> T {\n+    fn with_display_str<T>(&self, f: &fn(&str) -> T) -> T {\n         match self.as_str() {\n             Some(s) => f(s),\n             None => {\n@@ -161,29 +175,37 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the unicode\n     /// replacement char. This involves allocation.\n     ///\n-    /// This is similar to `as_display_str()` except it will always allocate a new ~str.\n+    /// This is similar to `with_display_str()` except it will always allocate a new ~str.\n     fn to_display_str(&self) -> ~str {\n-        // FIXME (#9516): Don't decode utf-8 manually here once we have a good way to do it in str\n-        // This is a truly horrifically bad implementation, done as a functionality stopgap until\n-        // we have a proper utf-8 decoder. I don't really want to write one here.\n-        static REPLACEMENT_CHAR: char = '\\uFFFD';\n-\n-        let mut v = self.as_vec();\n-        let mut s = str::with_capacity(v.len());\n-        while !v.is_empty() {\n-            let w = str::utf8_char_width(v[0]);\n-            if w == 0u {\n-                s.push_char(REPLACEMENT_CHAR);\n-                v = v.slice_from(1);\n-            } else if v.len() < w || !str::is_utf8(v.slice_to(w)) {\n-                s.push_char(REPLACEMENT_CHAR);\n-                v = v.slice_from(1);\n-            } else {\n-                s.push_str(unsafe { ::cast::transmute(v.slice_to(w)) });\n-                v = v.slice_from(w);\n+        from_utf8_with_replacement(self.as_vec())\n+    }\n+\n+    /// Provides the filename as a string\n+    ///\n+    /// If the filename is not UTF-8, invalid sequences will be replaced with the unicode\n+    /// replacement char. This involves allocation.\n+    #[inline]\n+    fn with_filename_display_str<T>(&self, f: &fn(Option<&str>) -> T) -> T {\n+        match self.filename_str() {\n+            s@Some(_) => f(s),\n+            None => {\n+                let o = self.to_filename_display_str();\n+                f(o.map(|s|s.as_slice()))\n             }\n         }\n-        s\n+    }\n+\n+    /// Returns the filename as a string\n+    ///\n+    /// If the filename is not UTF-8, invalid sequences will be replaced with the unicode\n+    /// replacement char. This involves allocation.\n+    ///\n+    /// This is similar to `to_filename_display_str` except it will always allocate a new ~str.\n+    fn to_filename_display_str(&self) -> Option<~str> {\n+        match self.filename() {\n+            None => None,\n+            Some(v) => Some(from_utf8_with_replacement(v))\n+        }\n     }\n \n     /// Returns an object that implements `fmt::Default` for printing paths\n@@ -211,51 +233,59 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         str::from_utf8_slice_opt(self.dirname())\n     }\n     /// Returns the file component of `self`, as a byte vector.\n-    /// If `self` represents the root of the file hierarchy, returns the empty vector.\n-    /// If `self` is \".\", returns the empty vector.\n-    fn filename<'a>(&'a self) -> &'a [u8];\n+    /// If `self` represents the root of the file hierarchy, returns None.\n+    /// If `self` is \".\" or \"..\", returns None.\n+    fn filename<'a>(&'a self) -> Option<&'a [u8]>;\n     /// Returns the file component of `self`, as a string, if possible.\n     /// See `filename` for details.\n     #[inline]\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_slice_opt(self.filename())\n+        self.filename().and_then(str::from_utf8_slice_opt)\n     }\n     /// Returns the stem of the filename of `self`, as a byte vector.\n     /// The stem is the portion of the filename just before the last '.'.\n     /// If there is no '.', the entire filename is returned.\n-    fn filestem<'a>(&'a self) -> &'a [u8] {\n-        let name = self.filename();\n-        let dot = '.' as u8;\n-        match name.rposition_elem(&dot) {\n-            None | Some(0) => name,\n-            Some(1) if name == bytes!(\"..\") => name,\n-            Some(pos) => name.slice_to(pos)\n+    fn filestem<'a>(&'a self) -> Option<&'a [u8]> {\n+        match self.filename() {\n+            None => None,\n+            Some(name) => Some({\n+                let dot = '.' as u8;\n+                match name.rposition_elem(&dot) {\n+                    None | Some(0) => name,\n+                    Some(1) if name == bytes!(\"..\") => name,\n+                    Some(pos) => name.slice_to(pos)\n+                }\n+            })\n         }\n     }\n     /// Returns the stem of the filename of `self`, as a string, if possible.\n     /// See `filestem` for details.\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_slice_opt(self.filestem())\n+        self.filestem().and_then(str::from_utf8_slice_opt)\n     }\n     /// Returns the extension of the filename of `self`, as an optional byte vector.\n     /// The extension is the portion of the filename just after the last '.'.\n     /// If there is no extension, None is returned.\n     /// If the filename ends in '.', the empty vector is returned.\n     fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n-        let name = self.filename();\n-        let dot = '.' as u8;\n-        match name.rposition_elem(&dot) {\n-            None | Some(0) => None,\n-            Some(1) if name == bytes!(\"..\") => None,\n-            Some(pos) => Some(name.slice_from(pos+1))\n+        match self.filename() {\n+            None => None,\n+            Some(name) => {\n+                let dot = '.' as u8;\n+                match name.rposition_elem(&dot) {\n+                    None | Some(0) => None,\n+                    Some(1) if name == bytes!(\"..\") => None,\n+                    Some(pos) => Some(name.slice_from(pos+1))\n+                }\n+            }\n         }\n     }\n     /// Returns the extension of the filename of `self`, as a string, if possible.\n     /// See `extension` for details.\n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().and_then(|v| str::from_utf8_slice_opt(v))\n+        self.extension().and_then(str::from_utf8_slice_opt)\n     }\n \n     /// Replaces the directory portion of the path with the given byte vector.\n@@ -322,27 +352,30 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn set_filestem(&mut self, filestem: &[u8]) {\n         // borrowck is being a pain here\n         let val = {\n-            let name = self.filename();\n-            if !name.is_empty() {\n-                let dot = '.' as u8;\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => None,\n-                    Some(idx) => {\n-                        let mut v;\n-                        if contains_nul(filestem) {\n-                            let filestem = self::null_byte::cond.raise(filestem.to_owned());\n-                            assert!(!contains_nul(filestem));\n-                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n-                            v.push_all(filestem);\n-                        } else {\n-                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n-                            v.push_all(filestem);\n+            match self.filename() {\n+                None => None,\n+                Some(name) => {\n+                    let dot = '.' as u8;\n+                    match name.rposition_elem(&dot) {\n+                        None | Some(0) => None,\n+                        Some(idx) => {\n+                            let mut v;\n+                            if contains_nul(filestem) {\n+                                let filestem = self::null_byte::cond.raise(filestem.to_owned());\n+                                assert!(!contains_nul(filestem));\n+                                v = filestem;\n+                                let n = v.len();\n+                                v.reserve(n + name.len() - idx);\n+                            } else {\n+                                v = vec::with_capacity(filestem.len() + name.len() - idx);\n+                                v.push_all(filestem);\n+                            }\n+                            v.push_all(name.slice_from(idx));\n+                            Some(v)\n                         }\n-                        v.push_all(name.slice_from(idx));\n-                        Some(v)\n                     }\n                 }\n-            } else { None }\n+            }\n         };\n         match val {\n             None => self.set_filename(filestem),\n@@ -366,52 +399,56 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn set_extension(&mut self, extension: &[u8]) {\n         // borrowck causes problems here too\n         let val = {\n-            let name = self.filename();\n-            if !name.is_empty() {\n-                let dot = '.' as u8;\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => {\n-                        if extension.is_empty() {\n-                            None\n-                        } else {\n-                            let mut v;\n-                            if contains_nul(extension) {\n-                                let extension = self::null_byte::cond.raise(extension.to_owned());\n-                                assert!(!contains_nul(extension));\n-                                v = vec::with_capacity(name.len() + extension.len() + 1);\n-                                v.push_all(name);\n-                                v.push(dot);\n-                                v.push_all(extension);\n+            match self.filename() {\n+                None => None,\n+                Some(name) => {\n+                    let dot = '.' as u8;\n+                    match name.rposition_elem(&dot) {\n+                        None | Some(0) => {\n+                            if extension.is_empty() {\n+                                None\n                             } else {\n-                                v = vec::with_capacity(name.len() + extension.len() + 1);\n-                                v.push_all(name);\n-                                v.push(dot);\n-                                v.push_all(extension);\n+                                let mut v;\n+                                if contains_nul(extension) {\n+                                    let ext = extension.to_owned();\n+                                    let extension = self::null_byte::cond.raise(ext);\n+                                    assert!(!contains_nul(extension));\n+                                    v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                    v.push_all(name);\n+                                    v.push(dot);\n+                                    v.push_all(extension);\n+                                } else {\n+                                    v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                    v.push_all(name);\n+                                    v.push(dot);\n+                                    v.push_all(extension);\n+                                }\n+                                Some(v)\n                             }\n-                            Some(v)\n                         }\n-                    }\n-                    Some(idx) => {\n-                        if extension.is_empty() {\n-                            Some(name.slice_to(idx).to_owned())\n-                        } else {\n-                            let mut v;\n-                            if contains_nul(extension) {\n-                                let extension = self::null_byte::cond.raise(extension.to_owned());\n-                                assert!(!contains_nul(extension));\n-                                v = vec::with_capacity(idx + extension.len() + 1);\n-                                v.push_all(name.slice_to(idx+1));\n-                                v.push_all(extension);\n+                        Some(idx) => {\n+                            if extension.is_empty() {\n+                                Some(name.slice_to(idx).to_owned())\n                             } else {\n-                                v = vec::with_capacity(idx + extension.len() + 1);\n-                                v.push_all(name.slice_to(idx+1));\n-                                v.push_all(extension);\n+                                let mut v;\n+                                if contains_nul(extension) {\n+                                    let ext = extension.to_owned();\n+                                    let extension = self::null_byte::cond.raise(ext);\n+                                    assert!(!contains_nul(extension));\n+                                    v = vec::with_capacity(idx + extension.len() + 1);\n+                                    v.push_all(name.slice_to(idx+1));\n+                                    v.push_all(extension);\n+                                } else {\n+                                    v = vec::with_capacity(idx + extension.len() + 1);\n+                                    v.push_all(name.slice_to(idx+1));\n+                                    v.push_all(extension);\n+                                }\n+                                Some(v)\n                             }\n-                            Some(v)\n                         }\n                     }\n                 }\n-            } else { None }\n+            }\n         };\n         match val {\n             None => (),\n@@ -424,6 +461,52 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn set_extension_str(&mut self, extension: &str) {\n         self.set_extension(extension.as_bytes())\n     }\n+    /// Adds the given extension (as a byte vector) to the file.\n+    /// This does not remove any existing extension.\n+    /// `foo.bar`.add_extension(`baz`) becomes `foo.bar.baz`.\n+    /// If `self` has no filename, this is a no-op.\n+    /// If the given byte vector is [], this is a no-op.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    fn add_extension(&mut self, extension: &[u8]) {\n+        if extension.is_empty() { return; }\n+        // appease borrowck\n+        let val = {\n+            match self.filename() {\n+                None => None,\n+                Some(name) => {\n+                    let mut v;\n+                    if contains_nul(extension) {\n+                        let ext = extension.to_owned();\n+                        let extension = self::null_byte::cond.raise(ext);\n+                        assert!(!contains_nul(extension));\n+                        v = vec::with_capacity(name.len() + 1 + extension.len());\n+                        v.push_all(name);\n+                        v.push('.' as u8);\n+                        v.push_all(extension);\n+                    } else {\n+                        v = vec::with_capacity(name.len() + 1 + extension.len());\n+                        v.push_all(name);\n+                        v.push('.' as u8);\n+                        v.push_all(extension);\n+                    }\n+                    Some(v)\n+                }\n+            }\n+        };\n+        match val {\n+            None => (),\n+            Some(v) => unsafe { self.set_filename_unchecked(v) }\n+        }\n+    }\n+    /// Adds the given extension (as a string) to the file.\n+    /// See `add_extension` for details.\n+    #[inline]\n+    fn add_extension_str(&mut self, extension: &str) {\n+        self.add_extension(extension.as_bytes())\n+    }\n \n     /// Returns a new Path constructed by replacing the dirname with the given byte vector.\n     /// See `set_dirname` for details.\n@@ -516,12 +599,14 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If `self` represents the root of the filesystem hierarchy, returns None.\n     fn file_path(&self) -> Option<Self> {\n         // self.filename() returns a NUL-free vector\n-        match self.filename() {\n-            [] => None,\n-            v => Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n-        }\n+        self.filename().map_move(|v| unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n     }\n \n+    /// Returns a Path that represents the filesystem root that `self` is rooted in.\n+    ///\n+    /// If `self` is not absolute, or vol-relative in the case of Windows, this returns None.\n+    fn root_path(&self) -> Option<Self>;\n+\n     /// Pushes a path (as a byte vector) onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n     ///\n@@ -554,6 +639,21 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn push_path(&mut self, path: &Self) {\n         self.push(path.as_vec())\n     }\n+    /// Pushes multiple paths (as byte vectors) onto `self`.\n+    /// See `push` for details.\n+    #[inline]\n+    fn push_many<V: Vector<u8>>(&mut self, paths: &[V]) {\n+        for p in paths.iter() {\n+            self.push(p.as_slice());\n+        }\n+    }\n+    /// Pushes multiple paths (as strings) onto `self`.\n+    #[inline]\n+    fn push_many_str<S: Str>(&mut self, paths: &[S]) {\n+        for p in paths.iter() {\n+            self.push_str(p.as_slice());\n+        }\n+    }\n     /// Pops the last path component off of `self` and returns it.\n     /// If `self` represents the root of the file hierarchy, None is returned.\n     fn pop(&mut self) -> Option<~[u8]>;\n@@ -593,12 +693,36 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.push_path(path);\n         p\n     }\n+    /// Returns a new Path constructed by joining `self` with the given paths (as byte vectors).\n+    /// See `join` for details.\n+    #[inline]\n+    fn join_many<V: Vector<u8>>(&self, paths: &[V]) -> Self {\n+        let mut p = self.clone();\n+        p.push_many(paths);\n+        p\n+    }\n+    /// Returns a new Path constructed by joining `self` with the given paths (as strings).\n+    /// See `join` for details.\n+    #[inline]\n+    fn join_many_str<S: Str>(&self, paths: &[S]) -> Self {\n+        let mut p = self.clone();\n+        p.push_many_str(paths);\n+        p\n+    }\n \n     /// Returns whether `self` represents an absolute path.\n     /// An absolute path is defined as one that, when joined to another path, will\n     /// yield back the same absolute path.\n     fn is_absolute(&self) -> bool;\n \n+    /// Returns whether `self` represents a relative path.\n+    /// Typically this is the inverse of `is_absolute`.\n+    /// But for Windows paths, it also means the path is not volume-relative or\n+    /// relative to the current working directory.\n+    fn is_relative(&self) -> bool {\n+        !self.is_absolute()\n+    }\n+\n     /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n     /// If both paths are relative, they are compared as though they are relative\n     /// to the same parent path.\n@@ -707,6 +831,30 @@ fn contains_nul(v: &[u8]) -> bool {\n     v.iter().any(|&x| x == 0)\n }\n \n+#[inline(always)]\n+fn from_utf8_with_replacement(mut v: &[u8]) -> ~str {\n+    // FIXME (#9516): Don't decode utf-8 manually here once we have a good way to do it in str\n+    // This is a truly horrifically bad implementation, done as a functionality stopgap until\n+    // we have a proper utf-8 decoder. I don't really want to write one here.\n+    static REPLACEMENT_CHAR: char = '\\uFFFD';\n+\n+    let mut s = str::with_capacity(v.len());\n+    while !v.is_empty() {\n+        let w = str::utf8_char_width(v[0]);\n+        if w == 0u {\n+            s.push_char(REPLACEMENT_CHAR);\n+            v = v.slice_from(1);\n+        } else if v.len() < w || !str::is_utf8(v.slice_to(w)) {\n+            s.push_char(REPLACEMENT_CHAR);\n+            v = v.slice_from(1);\n+        } else {\n+            s.push_str(unsafe { ::cast::transmute(v.slice_to(w)) });\n+            v = v.slice_from(w);\n+        }\n+    }\n+    s\n+}\n+\n // FIXME (#9537): libc::stat should derive Default\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n@@ -927,3 +1075,20 @@ mod stat {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{GenericPath, PosixPath, WindowsPath};\n+    use c_str::ToCStr;\n+\n+    #[test]\n+    fn test_from_c_str() {\n+        let input = \"/foo/bar/baz\";\n+        let path: PosixPath = GenericPath::from_c_str(input.to_c_str());\n+        assert_eq!(path.as_vec(), input.as_bytes());\n+\n+        let input = \"\\\\foo\\\\bar\\\\baz\";\n+        let path: WindowsPath = GenericPath::from_c_str(input.to_c_str());\n+        assert_eq!(path.as_str().unwrap(), input);\n+    }\n+}", "previous_filename": "src/libstd/path2/mod.rs"}, {"sha": "481387378fa6f4cfe5eb16abb627d4f32f29cef2", "filename": "src/libstd/path/posix.rs", "status": "renamed", "additions": 345, "deletions": 67, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -15,22 +15,30 @@ use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::Eq;\n use from_str::FromStr;\n-use iter::{AdditiveIterator, Extendable, Iterator};\n+use iter::{AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n use to_bytes::IterBytes;\n use util;\n use vec;\n-use vec::CopyableVector;\n-use vec::{Vector, VectorVector};\n+use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector};\n use super::{GenericPath, GenericPathUnsafe};\n \n #[cfg(not(target_os = \"win32\"))]\n use libc;\n \n-/// Iterator that yields successive components of a Path\n-pub type ComponentIter<'self> = vec::SplitIterator<'self, u8>;\n+/// Iterator that yields successive components of a Path as &[u8]\n+pub type ComponentIter<'self> = SplitIterator<'self, u8>;\n+/// Iterator that yields components of a Path in reverse as &[u8]\n+pub type RevComponentIter<'self> = RSplitIterator<'self, u8>;\n+\n+/// Iterator that yields successive components of a Path as Option<&str>\n+pub type StrComponentIter<'self> = Map<'self, &'self [u8], Option<&'self str>,\n+                                       ComponentIter<'self>>;\n+/// Iterator that yields components of a Path in reverse as Option<&str>\n+pub type RevStrComponentIter<'self> = Map<'self, &'self [u8], Option<&'self str>,\n+                                          RevComponentIter<'self>>;\n \n /// Represents a POSIX file path\n #[deriving(Clone, DeepClone)]\n@@ -187,12 +195,13 @@ impl GenericPath for Path {\n         }\n     }\n \n-    fn filename<'a>(&'a self) -> &'a [u8] {\n+    fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => &[],\n-            None => self.repr.as_slice(),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => &[],\n-            Some(idx) => self.repr.slice_from(idx+1)\n+            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => None,\n+            None => Some(self.repr.as_slice()),\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => None,\n+            Some(0) if self.repr.slice_from(1).is_empty() => None,\n+            Some(idx) => Some(self.repr.slice_from(idx+1))\n         }\n     }\n \n@@ -219,6 +228,14 @@ impl GenericPath for Path {\n         }\n     }\n \n+    fn root_path(&self) -> Option<Path> {\n+        if self.is_absolute() {\n+            Some(Path::from_str(\"/\"))\n+        } else {\n+            None\n+        }\n+    }\n+\n     #[inline]\n     fn is_absolute(&self) -> bool {\n         self.repr[0] == sep\n@@ -384,6 +401,48 @@ impl Path {\n         }\n         ret\n     }\n+\n+    /// Returns an iterator that yields each component of the path in reverse.\n+    /// See component_iter() for details.\n+    pub fn rev_component_iter<'a>(&'a self) -> RevComponentIter<'a> {\n+        let v = if self.repr[0] == sep {\n+            self.repr.slice_from(1)\n+        } else { self.repr.as_slice() };\n+        let mut ret = v.rsplit_iter(is_sep);\n+        if v.is_empty() {\n+            // consume the empty \"\" component\n+            ret.next();\n+        }\n+        ret\n+    }\n+\n+    /// Returns an iterator that yields each component of the path as Option<&str>.\n+    /// See component_iter() for details.\n+    pub fn str_component_iter<'a>(&'a self) -> StrComponentIter<'a> {\n+        self.component_iter().map(str::from_utf8_slice_opt)\n+    }\n+\n+    /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n+    /// See component_iter() for details.\n+    pub fn rev_str_component_iter<'a>(&'a self) -> RevStrComponentIter<'a> {\n+        self.rev_component_iter().map(str::from_utf8_slice_opt)\n+    }\n+\n+    /// Returns whether the relative path `child` is a suffix of `self`.\n+    pub fn ends_with_path(&self, child: &Path) -> bool {\n+        if !child.is_relative() { return false; }\n+        let mut selfit = self.rev_component_iter();\n+        let mut childit = child.rev_component_iter();\n+        loop {\n+            match (selfit.next(), childit.next()) {\n+                (Some(a), Some(b)) => if a != b { return false; },\n+                (Some(_), None) => break,\n+                (None, Some(_)) => return false,\n+                (None, None) => break\n+            }\n+        }\n+        true\n+    }\n }\n \n // None result means the byte vector didn't need normalizing\n@@ -422,8 +481,8 @@ fn contains_nul(v: &[u8]) -> bool {\n     v.iter().any(|&x| x == 0)\n }\n \n-static dot_static: &'static [u8] = &'static ['.' as u8];\n-static dot_dot_static: &'static [u8] = &'static ['.' as u8, '.' as u8];\n+static dot_static: &'static [u8] = bytes!(\".\");\n+static dot_dot_static: &'static [u8] = bytes!(\"..\");\n \n // Stat support\n #[cfg(not(target_os = \"win32\"))]\n@@ -524,7 +583,7 @@ impl Path {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n     use iter::Iterator;\n     use str;\n     use vec::Vector;\n@@ -604,7 +663,7 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use path2::null_byte::cond;\n+        use path::null_byte::cond;\n \n         let mut handled = false;\n         let mut p = do cond.trap(|v| {\n@@ -653,7 +712,7 @@ mod tests {\n \n     #[test]\n     fn test_null_byte_fail() {\n-        use path2::null_byte::cond;\n+        use path::null_byte::cond;\n         use task;\n \n         macro_rules! t(\n@@ -709,25 +768,47 @@ mod tests {\n         assert_eq!(Path::from_str(\"foo\").to_display_str(), ~\"foo\");\n         assert_eq!(Path::from_vec(b!(\"foo\", 0x80)).to_display_str(), ~\"foo\\uFFFD\");\n         assert_eq!(Path::from_vec(b!(\"foo\", 0xff, \"bar\")).to_display_str(), ~\"foo\\uFFFDbar\");\n+        assert_eq!(Path::from_vec(b!(\"foo\", 0xff, \"/bar\")).to_filename_display_str(), Some(~\"bar\"));\n+        assert_eq!(Path::from_vec(b!(\"foo/\", 0xff, \"bar\")).to_filename_display_str(),\n+                   Some(~\"\\uFFFDbar\"));\n+        assert_eq!(Path::from_vec(b!(\"/\")).to_filename_display_str(), None);\n \n         let mut called = false;\n-        do Path::from_str(\"foo\").as_display_str |s| {\n+        do Path::from_str(\"foo\").with_display_str |s| {\n             assert_eq!(s, \"foo\");\n             called = true;\n         };\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"foo\", 0x80)).as_display_str |s| {\n+        do Path::from_vec(b!(\"foo\", 0x80)).with_display_str |s| {\n             assert_eq!(s, \"foo\\uFFFD\");\n             called = true;\n         };\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"foo\", 0xff, \"bar\")).as_display_str |s| {\n+        do Path::from_vec(b!(\"foo\", 0xff, \"bar\")).with_display_str |s| {\n             assert_eq!(s, \"foo\\uFFFDbar\");\n             called = true;\n         };\n         assert!(called);\n+        called = false;\n+        do Path::from_vec(b!(\"foo\", 0xff, \"/bar\")).with_filename_display_str |s| {\n+            assert_eq!(s, Some(\"bar\"));\n+            called = true;\n+        }\n+        assert!(called);\n+        called = false;\n+        do Path::from_vec(b!(\"foo/\", 0xff, \"bar\")).with_filename_display_str |s| {\n+            assert_eq!(s, Some(\"\\uFFFDbar\"));\n+            called = true;\n+        }\n+        assert!(called);\n+        called = false;\n+        do Path::from_vec(b!(\"/\")).with_filename_display_str |s| {\n+            assert!(s.is_none());\n+            called = true;\n+        }\n+        assert!(called);\n     }\n \n     #[test]\n@@ -774,20 +855,20 @@ mod tests {\n                     let path = Path::from_vec($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n-            )\n+            );\n         )\n \n-        t!(v: b!(\"a/b/c\"), filename, b!(\"c\"));\n-        t!(v: b!(\"a/b/c\", 0xff), filename, b!(\"c\", 0xff));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), filename, b!(\"c\"));\n-        t!(s: \"a/b/c\", filename, \"c\");\n-        t!(s: \"/a/b/c\", filename, \"c\");\n-        t!(s: \"a\", filename, \"a\");\n-        t!(s: \"/a\", filename, \"a\");\n-        t!(s: \".\", filename, \"\");\n-        t!(s: \"/\", filename, \"\");\n-        t!(s: \"..\", filename, \"\");\n-        t!(s: \"../..\", filename, \"\");\n+        t!(v: b!(\"a/b/c\"), filename, Some(b!(\"c\")));\n+        t!(v: b!(\"a/b/c\", 0xff), filename, Some(b!(\"c\", 0xff)));\n+        t!(v: b!(\"a/b\", 0xff, \"/c\"), filename, Some(b!(\"c\")));\n+        t!(s: \"a/b/c\", filename, Some(\"c\"), opt);\n+        t!(s: \"/a/b/c\", filename, Some(\"c\"), opt);\n+        t!(s: \"a\", filename, Some(\"a\"), opt);\n+        t!(s: \"/a\", filename, Some(\"a\"), opt);\n+        t!(s: \".\", filename, None, opt);\n+        t!(s: \"/\", filename, None, opt);\n+        t!(s: \"..\", filename, None, opt);\n+        t!(s: \"../..\", filename, None, opt);\n \n         t!(v: b!(\"a/b/c\"), dirname, b!(\"a/b\"));\n         t!(v: b!(\"a/b/c\", 0xff), dirname, b!(\"a/b\"));\n@@ -801,21 +882,21 @@ mod tests {\n         t!(s: \"..\", dirname, \"..\");\n         t!(s: \"../..\", dirname, \"../..\");\n \n-        t!(v: b!(\"hi/there.txt\"), filestem, b!(\"there\"));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), filestem, b!(\"there\", 0x80));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), filestem, b!(\"there\"));\n-        t!(s: \"hi/there.txt\", filestem, \"there\");\n-        t!(s: \"hi/there\", filestem, \"there\");\n-        t!(s: \"there.txt\", filestem, \"there\");\n-        t!(s: \"there\", filestem, \"there\");\n-        t!(s: \".\", filestem, \"\");\n-        t!(s: \"/\", filestem, \"\");\n-        t!(s: \"foo/.bar\", filestem, \".bar\");\n-        t!(s: \".bar\", filestem, \".bar\");\n-        t!(s: \"..bar\", filestem, \".\");\n-        t!(s: \"hi/there..txt\", filestem, \"there.\");\n-        t!(s: \"..\", filestem, \"\");\n-        t!(s: \"../..\", filestem, \"\");\n+        t!(v: b!(\"hi/there.txt\"), filestem, Some(b!(\"there\")));\n+        t!(v: b!(\"hi/there\", 0x80, \".txt\"), filestem, Some(b!(\"there\", 0x80)));\n+        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), filestem, Some(b!(\"there\")));\n+        t!(s: \"hi/there.txt\", filestem, Some(\"there\"), opt);\n+        t!(s: \"hi/there\", filestem, Some(\"there\"), opt);\n+        t!(s: \"there.txt\", filestem, Some(\"there\"), opt);\n+        t!(s: \"there\", filestem, Some(\"there\"), opt);\n+        t!(s: \".\", filestem, None, opt);\n+        t!(s: \"/\", filestem, None, opt);\n+        t!(s: \"foo/.bar\", filestem, Some(\".bar\"), opt);\n+        t!(s: \".bar\", filestem, Some(\".bar\"), opt);\n+        t!(s: \"..bar\", filestem, Some(\".\"), opt);\n+        t!(s: \"hi/there..txt\", filestem, Some(\"there.\"), opt);\n+        t!(s: \"..\", filestem, None, opt);\n+        t!(s: \"../..\", filestem, None, opt);\n \n         t!(v: b!(\"hi/there.txt\"), extension, Some(b!(\"txt\")));\n         t!(v: b!(\"hi/there\", 0x80, \".txt\"), extension, Some(b!(\"txt\")));\n@@ -878,6 +959,39 @@ mod tests {\n         t!(s: \"a/b\", \"../c\", \"a/c\");\n     }\n \n+    #[test]\n+    fn test_push_many() {\n+        use to_man = at_vec::to_managed_move;\n+\n+        macro_rules! t(\n+            (s: $path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = Path::from_str($path);\n+                    p.push_many_str($push);\n+                    assert_eq!(p.as_str(), Some($exp));\n+                }\n+            );\n+            (v: $path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = Path::from_vec($path);\n+                    p.push_many($push);\n+                    assert_eq!(p.as_vec(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n+        t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n+        t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [@\"d\", @\"e\"], \"a/b/c/d/e\");\n+        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n+        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n+        t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n+        t!(v: b!(\"a/b/c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n+              b!(\"a/b/c/d/e\"));\n+    }\n+\n     #[test]\n     fn test_pop() {\n         macro_rules! t(\n@@ -926,6 +1040,12 @@ mod tests {\n         assert_eq!(Path::from_vec(b!(\"foo\", 0x80, \"/bar\")).pop_str(), Some(~\"bar\"));\n     }\n \n+    #[test]\n+    fn test_root_path() {\n+        assert_eq!(Path::from_vec(b!(\"a/b/c\")).root_path(), None);\n+        assert_eq!(Path::from_vec(b!(\"/a/b/c\")).root_path(), Some(Path::from_str(\"/\")));\n+    }\n+\n     #[test]\n     fn test_join() {\n         t!(v: Path::from_vec(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n@@ -960,6 +1080,38 @@ mod tests {\n         t!(s: \"/\", \"a/b\", \"/a/b\");\n     }\n \n+    #[test]\n+    fn test_join_many() {\n+        use to_man = at_vec::to_managed_move;\n+\n+        macro_rules! t(\n+            (s: $path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let res = path.join_many_str($join);\n+                    assert_eq!(res.as_str(), Some($exp));\n+                }\n+            );\n+            (v: $path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_vec($path);\n+                    let res = path.join_many($join);\n+                    assert_eq!(res.as_vec(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n+        t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n+        t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [@\"d\", @\"e\"], \"a/b/c/d/e\");\n+        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n+        t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n+        t!(v: b!(\"a/b/c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n+              b!(\"a/b/c/d/e\"));\n+    }\n+\n     #[test]\n     fn test_with_helpers() {\n         t!(v: Path::from_vec(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n@@ -1121,16 +1273,58 @@ mod tests {\n         t!(s: \".\", set_extension_str, with_extension_str, \"txt\");\n     }\n \n+    #[test]\n+    fn test_add_extension() {\n+        macro_rules! t(\n+            (s: $path:expr, $ext:expr, $exp:expr) => (\n+                {\n+                    let mut path = Path::from_str($path);\n+                    path.add_extension_str($ext);\n+                    assert_eq!(path.as_str(), Some($exp));\n+                }\n+            );\n+            (v: $path:expr, $ext:expr, $exp:expr) => (\n+                {\n+                    let mut path = Path::from_vec($path);\n+                    path.add_extension($ext);\n+                    assert_eq!(path.as_vec(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"hi/there.txt\", \"foo\", \"hi/there.txt.foo\");\n+        t!(s: \"hi/there.\", \"foo\", \"hi/there..foo\");\n+        t!(s: \"hi/there\", \".foo\", \"hi/there..foo\");\n+        t!(s: \"hi/there.txt\", \"\", \"hi/there.txt\");\n+        t!(v: b!(\"hi/there.txt\"), b!(\"foo\"), b!(\"hi/there.txt.foo\"));\n+        t!(v: b!(\"hi/there\"), b!(\"bar\"), b!(\"hi/there.bar\"));\n+        t!(v: b!(\"/\"), b!(\"foo\"), b!(\"/\"));\n+        t!(v: b!(\".\"), b!(\"foo\"), b!(\".\"));\n+        t!(v: b!(\"hi/there.\", 0x80, \"foo\"), b!(0xff), b!(\"hi/there.\", 0x80, \"foo.\", 0xff));\n+    }\n+\n     #[test]\n     fn test_getters() {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    assert_eq!(path.filename_str(), $filename);\n-                    assert_eq!(path.dirname_str(), $dirname);\n-                    assert_eq!(path.filestem_str(), $filestem);\n-                    assert_eq!(path.extension_str(), $ext);\n+                    let filename = $filename;\n+                    assert!(path.filename_str() == filename,\n+                            \"`%s`.filename_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), filename, path.filename_str());\n+                    let dirname = $dirname;\n+                    assert!(path.dirname_str() == dirname,\n+                            \"`%s`.dirname_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), dirname, path.dirname_str());\n+                    let filestem = $filestem;\n+                    assert!(path.filestem_str() == filestem,\n+                            \"`%s`.filestem_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), filestem, path.filestem_str());\n+                    let ext = $ext;\n+                    assert!(path.extension_str() == ext,\n+                            \"`%s`.extension_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), ext, path.extension_str());\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n@@ -1144,15 +1338,15 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::from_vec(b!(\"a/b/c\")), b!(\"c\"), b!(\"a/b\"), b!(\"c\"), None);\n-        t!(v: Path::from_vec(b!(\"a/b/\", 0xff)), b!(0xff), b!(\"a/b\"), b!(0xff), None);\n-        t!(v: Path::from_vec(b!(\"hi/there.\", 0xff)), b!(\"there.\", 0xff), b!(\"hi\"),\n-              b!(\"there\"), Some(b!(0xff)));\n+        t!(v: Path::from_vec(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n+        t!(v: Path::from_vec(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n+        t!(v: Path::from_vec(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n+              Some(b!(\"there\")), Some(b!(0xff)));\n         t!(s: Path::from_str(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n-        t!(s: Path::from_str(\"/\"), Some(\"\"), Some(\"/\"), Some(\"\"), None);\n-        t!(s: Path::from_str(\"..\"), Some(\"\"), Some(\"..\"), Some(\"\"), None);\n-        t!(s: Path::from_str(\"../..\"), Some(\"\"), Some(\"../..\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::from_str(\"/\"), None, Some(\"/\"), None, None);\n+        t!(s: Path::from_str(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::from_str(\"../..\"), None, Some(\"../..\"), None, None);\n         t!(s: Path::from_str(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n         t!(s: Path::from_str(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n@@ -1207,14 +1401,23 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        assert_eq!(Path::from_str(\"a/b/c\").is_absolute(), false);\n-        assert_eq!(Path::from_str(\"/a/b/c\").is_absolute(), true);\n-        assert_eq!(Path::from_str(\"a\").is_absolute(), false);\n-        assert_eq!(Path::from_str(\"/a\").is_absolute(), true);\n-        assert_eq!(Path::from_str(\".\").is_absolute(), false);\n-        assert_eq!(Path::from_str(\"/\").is_absolute(), true);\n-        assert_eq!(Path::from_str(\"..\").is_absolute(), false);\n-        assert_eq!(Path::from_str(\"../..\").is_absolute(), false);\n+        macro_rules! t(\n+            (s: $path:expr, $abs:expr, $rel:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    assert_eq!(path.is_absolute(), $abs);\n+                    assert_eq!(path.is_relative(), $rel);\n+                }\n+            )\n+        )\n+        t!(s: \"a/b/c\", false, true);\n+        t!(s: \"/a/b/c\", true, false);\n+        t!(s: \"a\", false, true);\n+        t!(s: \"/a\", true, false);\n+        t!(s: \".\", false, true);\n+        t!(s: \"/\", true, false);\n+        t!(s: \"..\", false, true);\n+        t!(s: \"../..\", false, true);\n     }\n \n     #[test]\n@@ -1251,6 +1454,45 @@ mod tests {\n         t!(s: \"../..\", \"a/b\", true);\n     }\n \n+    #[test]\n+    fn test_ends_with_path() {\n+        macro_rules! t(\n+            (s: $path:expr, $child:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let child = Path::from_str($child);\n+                    assert_eq!(path.ends_with_path(&child), $exp);\n+                }\n+            );\n+            (v: $path:expr, $child:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_vec($path);\n+                    let child = Path::from_vec($child);\n+                    assert_eq!(path.ends_with_path(&child), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", \"c\", true);\n+        t!(s: \"a/b/c\", \"d\", false);\n+        t!(s: \"foo/bar/quux\", \"bar\", false);\n+        t!(s: \"foo/bar/quux\", \"barquux\", false);\n+        t!(s: \"a/b/c\", \"b/c\", true);\n+        t!(s: \"a/b/c\", \"a/b/c\", true);\n+        t!(s: \"a/b/c\", \"foo/a/b/c\", false);\n+        t!(s: \"/a/b/c\", \"a/b/c\", true);\n+        t!(s: \"/a/b/c\", \"/a/b/c\", false); // child must be relative\n+        t!(s: \"/a/b/c\", \"foo/a/b/c\", false);\n+        t!(s: \"a/b/c\", \"\", false);\n+        t!(s: \"\", \"\", true);\n+        t!(s: \"/a/b/c\", \"d/e/f\", false);\n+        t!(s: \"a/b/c\", \"a/b\", false);\n+        t!(s: \"a/b/c\", \"b\", false);\n+        t!(v: b!(\"a/b/c\"), b!(\"b/c\"), true);\n+        t!(v: b!(\"a/b/\", 0xff), b!(0xff), true);\n+        t!(v: b!(\"a/b/\", 0xff), b!(\"b/\", 0xff), true);\n+    }\n+\n     #[test]\n     fn test_path_relative_from() {\n         macro_rules! t(\n@@ -1305,15 +1547,25 @@ mod tests {\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).to_owned_vec();\n-                    assert_eq!(comps, exps);\n+                    assert!(comps == exps, \"component_iter: Expected %?, found %?\",\n+                            comps, exps);\n+                    let comps = path.rev_component_iter().to_owned_vec();\n+                    let exps = exps.move_rev_iter().to_owned_vec();\n+                    assert!(comps == exps, \"rev_component_iter: Expected %?, found %?\",\n+                            comps, exps);\n                 }\n             );\n             (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n                 {\n                     let path = Path::from_vec(b!($($arg),+));\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert!(comps.as_slice() == exp, \"component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                    let comps = path.rev_component_iter().to_owned_vec();\n+                    let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n+                    assert!(comps.as_slice() == exp, \"rev_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n                 }\n             )\n         )\n@@ -1334,6 +1586,32 @@ mod tests {\n         t!(s: \"../../foo\", [\"..\", \"..\", \"foo\"]);\n     }\n \n+    #[test]\n+    fn test_str_component_iter() {\n+        macro_rules! t(\n+            (v: [$($arg:expr),+], $exp:expr) => (\n+                {\n+                    let path = Path::from_vec(b!($($arg),+));\n+                    let comps = path.str_component_iter().to_owned_vec();\n+                    let exp: &[Option<&str>] = $exp;\n+                    assert!(comps.as_slice() == exp, \"str_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                    let comps = path.rev_str_component_iter().to_owned_vec();\n+                    let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n+                    assert!(comps.as_slice() == exp,\n+                            \"rev_str_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: [\"a/b/c\"], [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n+        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [None, Some(\"a\"), None]);\n+        t!(v: [\"../../foo\", 0xcd, \"bar\"], [Some(\"..\"), Some(\"..\"), None]);\n+        // str_component_iter is a wrapper around component_iter, so no need to do\n+        // the full set of tests\n+    }\n+\n     #[test]\n     fn test_each_parent() {\n         assert!(Path::from_str(\"/foo/bar\").each_parent(|_| true));", "previous_filename": "src/libstd/path2/posix.rs"}, {"sha": "50cbe698d0452766e9f7c5f604ee5adb6b6934f6", "filename": "src/libstd/path/windows.rs", "status": "renamed", "additions": 362, "deletions": 89, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -15,10 +15,10 @@ use c_str::{CString, ToCStr};\n use cast;\n use cmp::Eq;\n use from_str::FromStr;\n-use iter::{AdditiveIterator, Extendable, Iterator};\n+use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Invert, Iterator, Map};\n use option::{Option, Some, None};\n use str;\n-use str::{OwnedStr, Str, StrVector};\n+use str::{CharSplitIterator, OwnedStr, Str, StrVector};\n use to_bytes::IterBytes;\n use util;\n use vec::Vector;\n@@ -27,8 +27,25 @@ use super::{GenericPath, GenericPathUnsafe};\n #[cfg(target_os = \"win32\")]\n use libc;\n \n-/// Iterator that yields successive components of a Path\n-pub type ComponentIter<'self> = str::CharSplitIterator<'self, char>;\n+/// Iterator that yields successive components of a Path as &str\n+///\n+/// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n+/// every component in WindowsPath is guaranteed to be Some.\n+pub type StrComponentIter<'self> = Map<'self, &'self str, Option<&'self str>,\n+                                       CharSplitIterator<'self, char>>;\n+/// Iterator that yields components of a Path in reverse as &str\n+///\n+/// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n+/// every component in WindowsPath is guaranteed to be Some.\n+pub type RevStrComponentIter<'self> = Invert<Map<'self, &'self str, Option<&'self str>,\n+                                                 CharSplitIterator<'self, char>>>;\n+\n+/// Iterator that yields successive components of a Path as &[u8]\n+pub type ComponentIter<'self> = Map<'self, Option<&'self str>, &'self [u8],\n+                                    StrComponentIter<'self>>;\n+/// Iterator that yields components of a Path in reverse as &[u8]\n+pub type RevComponentIter<'self> = Map<'self, Option<&'self str>, &'self [u8],\n+                                       RevStrComponentIter<'self>>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:\n@@ -361,7 +378,7 @@ impl GenericPath for Path {\n     }\n \n     #[inline]\n-    fn as_display_str<T>(&self, f: &fn(&str) -> T) -> T {\n+    fn with_display_str<T>(&self, f: &fn(&str) -> T) -> T {\n         f(self.repr.as_slice())\n     }\n \n@@ -400,44 +417,42 @@ impl GenericPath for Path {\n     }\n \n     #[inline]\n-    fn filename<'a>(&'a self) -> &'a [u8] {\n-        self.filename_str().unwrap().as_bytes()\n+    fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n+        self.filename_str().map_move(|x| x.as_bytes())\n     }\n \n     /// See `GenericPath::filename_str` for info.\n-    /// Always returns a `Some` value.\n+    /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr || \"..\" == self.repr => \"\",\n-            None => self.repr.as_slice(),\n-            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => \"\",\n-            Some((_,idxa,end)) => self.repr.slice(idxa, end)\n-        })\n+        match self.sepidx_or_prefix_len() {\n+            None if \".\" == self.repr || \"..\" == self.repr => None,\n+            None => Some(self.repr.as_slice()),\n+            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => None,\n+            Some((_,idxa,end)) if idxa == end => None,\n+            Some((_,idxa,end)) => Some(self.repr.slice(idxa, end))\n+        }\n     }\n \n     /// See `GenericPath::filestem_str` for info.\n-    /// Always returns a `Some` value.\n+    /// Always returns a `Some` value if `filestem` returns a `Some` value.\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n         // filestem() returns a byte vector that's guaranteed valid UTF-8\n-        Some(unsafe { cast::transmute(self.filestem()) })\n+        self.filestem().map_move(cast::transmute)\n     }\n \n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n         // extension() returns a byte vector that's guaranteed valid UTF-8\n-        self.extension().map_move(|v| unsafe { cast::transmute(v) })\n+        self.extension().map_move(cast::transmute)\n     }\n \n     fn dir_path(&self) -> Path {\n         unsafe { GenericPathUnsafe::from_str_unchecked(self.dirname_str().unwrap()) }\n     }\n \n     fn file_path(&self) -> Option<Path> {\n-        match self.filename_str() {\n-            None | Some(\"\") => None,\n-            Some(s) => Some(unsafe { GenericPathUnsafe::from_str_unchecked(s) })\n-        }\n+        self.filename_str().map_move(|s| unsafe { GenericPathUnsafe::from_str_unchecked(s) })\n     }\n \n     #[inline]\n@@ -477,6 +492,21 @@ impl GenericPath for Path {\n         }\n     }\n \n+    fn root_path(&self) -> Option<Path> {\n+        if self.is_absolute() {\n+            Some(Path::from_str(match self.prefix {\n+                Some(VerbatimDiskPrefix)|Some(DiskPrefix) => {\n+                    self.repr.slice_to(self.prefix_len()+1)\n+                }\n+                _ => self.repr.slice_to(self.prefix_len())\n+            }))\n+        } else if self.is_vol_relative() {\n+            Some(Path::from_str(self.repr.slice_to(1)))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// See `GenericPath::is_absolute` for info.\n     ///\n     /// A Windows Path is considered absolute only if it has a non-volume prefix,\n@@ -498,15 +528,20 @@ impl GenericPath for Path {\n         }\n     }\n \n+    #[inline]\n+    fn is_relative(&self) -> bool {\n+        self.prefix.is_none() && !self.is_vol_relative()\n+    }\n+\n     fn is_ancestor_of(&self, other: &Path) -> bool {\n         if !self.equiv_prefix(other) {\n             false\n         } else if self.is_absolute() != other.is_absolute() ||\n                   self.is_vol_relative() != other.is_vol_relative() {\n             false\n         } else {\n-            let mut ita = self.component_iter();\n-            let mut itb = other.component_iter();\n+            let mut ita = self.str_component_iter().map(|x|x.unwrap());\n+            let mut itb = other.str_component_iter().map(|x|x.unwrap());\n             if \".\" == self.repr {\n                 return itb.next() != Some(\"..\");\n             }\n@@ -553,8 +588,8 @@ impl GenericPath for Path {\n                 None\n             }\n         } else {\n-            let mut ita = self.component_iter();\n-            let mut itb = base.component_iter();\n+            let mut ita = self.str_component_iter().map(|x|x.unwrap());\n+            let mut itb = base.str_component_iter().map(|x|x.unwrap());\n             let mut comps = ~[];\n \n             let a_verb = self.is_verbatim();\n@@ -669,13 +704,14 @@ impl Path {\n         path\n     }\n \n-    /// Returns an iterator that yields each component of the path in turn.\n+    /// Returns an iterator that yields each component of the path in turn as a Option<&str>.\n+    /// Every component is guaranteed to be Some.\n     /// Does not yield the path prefix (including server/share components in UNC paths).\n     /// Does not distinguish between volume-relative and relative paths, e.g.\n     /// \\a\\b\\c and a\\b\\c.\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n-    pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n+    pub fn str_component_iter<'a>(&'a self) -> StrComponentIter<'a> {\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n@@ -686,10 +722,52 @@ impl Path {\n             None if self.repr[0] == sep as u8 => self.repr.slice_from(1),\n             None => self.repr.as_slice()\n         };\n-        let ret = s.split_terminator_iter(sep);\n+        let ret = s.split_terminator_iter(sep).map(Some);\n         ret\n     }\n \n+    /// Returns an iterator that yields each component of the path in reverse as an Option<&str>\n+    /// See str_component_iter() for details.\n+    pub fn rev_str_component_iter<'a>(&'a self) -> RevStrComponentIter<'a> {\n+        self.str_component_iter().invert()\n+    }\n+\n+    /// Returns an iterator that yields each component of the path in turn as a &[u8].\n+    /// See str_component_iter() for details.\n+    pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n+        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n+            #[inline];\n+            x.unwrap().as_bytes()\n+        }\n+        self.str_component_iter().map(convert)\n+    }\n+\n+    /// Returns an iterator that yields each component of the path in reverse as a &[u8].\n+    /// See str_component_iter() for details.\n+    pub fn rev_component_iter<'a>(&'a self) -> RevComponentIter<'a> {\n+        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n+            #[inline];\n+            x.unwrap().as_bytes()\n+        }\n+        self.rev_str_component_iter().map(convert)\n+    }\n+\n+    /// Returns whether the relative path `child` is a suffix of `self`.\n+    pub fn ends_with_path(&self, child: &Path) -> bool {\n+        if !child.is_relative() { return false; }\n+        let mut selfit = self.str_component_iter().invert();\n+        let mut childit = child.str_component_iter().invert();\n+        loop {\n+            match (selfit.next(), childit.next()) {\n+                (Some(a), Some(b)) => if a != b { return false; },\n+                (Some(_), None) => break,\n+                (None, Some(_)) => return false,\n+                (None, None) => break\n+            }\n+        }\n+        true\n+    }\n+\n     /// Returns whether the path is considered \"volume-relative\", which means a path\n     /// that looks like \"\\foo\". Paths of this form are relative to the current volume,\n     /// but absolute within that volume.\n@@ -1096,8 +1174,8 @@ impl Path {\n     /// Returns whether the represented file exists\n     pub fn exists(&self) -> bool {\n         match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.st_size as i64)\n+            None => false,\n+            Some(_) => true\n         }\n     }\n \n@@ -1339,7 +1417,7 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use path2::null_byte::cond;\n+        use path::null_byte::cond;\n \n         let mut handled = false;\n         let mut p = do cond.trap(|v| {\n@@ -1388,7 +1466,7 @@ mod tests {\n \n     #[test]\n     fn test_null_byte_fail() {\n-        use path2::null_byte::cond;\n+        use path::null_byte::cond;\n         use task;\n \n         macro_rules! t(\n@@ -1448,13 +1526,20 @@ mod tests {\n     #[test]\n     fn test_display_str() {\n         assert_eq!(Path::from_str(\"foo\").to_display_str(), ~\"foo\");\n+        assert_eq!(Path::from_vec(b!(\"\\\\\")).to_filename_display_str(), None);\n \n         let mut called = false;\n-        do Path::from_str(\"foo\").as_display_str |s| {\n+        do Path::from_str(\"foo\").with_display_str |s| {\n             assert_eq!(s, \"foo\");\n             called = true;\n         };\n         assert!(called);\n+        called = false;\n+        do Path::from_vec(b!(\"\\\\\")).with_filename_display_str |s| {\n+            assert!(s.is_none());\n+            called = true;\n+        }\n+        assert!(called);\n     }\n \n     #[test]\n@@ -1500,37 +1585,37 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), filename, b!(\"c\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), filename, Some(b!(\"c\")));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"\\\\a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"a\", filename_str, \"a\");\n         t!(s: \"\\\\a\", filename_str, \"a\");\n-        t!(s: \".\", filename_str, \"\");\n-        t!(s: \"\\\\\", filename_str, \"\");\n-        t!(s: \"..\", filename_str, \"\");\n-        t!(s: \"..\\\\..\", filename_str, \"\");\n+        t!(s: \".\", filename_str, None, opt);\n+        t!(s: \"\\\\\", filename_str, None, opt);\n+        t!(s: \"..\", filename_str, None, opt);\n+        t!(s: \"..\\\\..\", filename_str, None, opt);\n         t!(s: \"c:\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"C:\\\\\", filename_str, \"\");\n-        t!(s: \"C:\", filename_str, \"\");\n+        t!(s: \"C:\\\\\", filename_str, None, opt);\n+        t!(s: \"C:\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\server\\\\share\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\server\\\\share\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\server\\\\share\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\server\", filename_str, \"server\");\n         t!(s: \"\\\\\\\\?\\\\bar\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\?\\\\bar\", filename_str, \"\");\n-        t!(s: \"\\\\\\\\?\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\bar\", filename_str, None, opt);\n+        t!(s: \"\\\\\\\\?\\\\\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", filename_str, \"\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", filename_str, None, opt);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\?\\\\C:\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", filename_str, \"\");\n-        t!(s: \"\\\\\\\\?\\\\C:\", filename_str, \"\");\n-        t!(s: \"\\\\\\\\?\\\\foo/bar\", filename_str, \"\");\n-        t!(s: \"\\\\\\\\?\\\\C:/foo\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", filename_str, None, opt);\n+        t!(s: \"\\\\\\\\?\\\\C:\", filename_str, None, opt);\n+        t!(s: \"\\\\\\\\?\\\\foo/bar\", filename_str, None, opt);\n+        t!(s: \"\\\\\\\\?\\\\C:/foo\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", filename_str, \"bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", filename_str, \"\");\n-        t!(s: \"\\\\\\\\.\\\\foo/bar\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", filename_str, None, opt);\n+        t!(s: \"\\\\\\\\.\\\\foo/bar\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\.\\\\foo\\\\bar/baz\", filename_str, \"bar/baz\");\n-        t!(s: \"\\\\\\\\.\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\.\\\\\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", filename_str, \"b\");\n \n         t!(v: b!(\"a\\\\b\\\\c\"), dirname, b!(\"a\\\\b\"));\n@@ -1564,19 +1649,19 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\", dirname_str, \"\\\\\\\\.\\\\foo\");\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", dirname_str, \"\\\\\\\\?\\\\a\");\n \n-        t!(v: b!(\"hi\\\\there.txt\"), filestem, b!(\"there\"));\n+        t!(v: b!(\"hi\\\\there.txt\"), filestem, Some(b!(\"there\")));\n         t!(s: \"hi\\\\there.txt\", filestem_str, \"there\");\n         t!(s: \"hi\\\\there\", filestem_str, \"there\");\n         t!(s: \"there.txt\", filestem_str, \"there\");\n         t!(s: \"there\", filestem_str, \"there\");\n-        t!(s: \".\", filestem_str, \"\");\n-        t!(s: \"\\\\\", filestem_str, \"\");\n+        t!(s: \".\", filestem_str, None, opt);\n+        t!(s: \"\\\\\", filestem_str, None, opt);\n         t!(s: \"foo\\\\.bar\", filestem_str, \".bar\");\n         t!(s: \".bar\", filestem_str, \".bar\");\n         t!(s: \"..bar\", filestem_str, \".\");\n         t!(s: \"hi\\\\there..txt\", filestem_str, \"there.\");\n-        t!(s: \"..\", filestem_str, \"\");\n-        t!(s: \"..\\\\..\", filestem_str, \"\");\n+        t!(s: \"..\", filestem_str, None, opt);\n+        t!(s: \"..\\\\..\", filestem_str, None, opt);\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n         t!(v: b!(\"hi\\\\there.txt\"), extension, Some(b!(\"txt\")));\n@@ -1681,6 +1766,39 @@ mod tests {\n         t!(s: \"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n     }\n \n+    #[test]\n+    fn test_push_many() {\n+        use to_man = at_vec::to_managed_move;\n+\n+        macro_rules! t(\n+            (s: $path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = Path::from_str($path);\n+                    p.push_many_str($push);\n+                    assert_eq!(p.as_str(), Some($exp));\n+                }\n+            );\n+            (v: $path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = Path::from_vec($path);\n+                    p.push_many($push);\n+                    assert_eq!(p.as_vec(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n+        t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [@\"d\", @\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n+              b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+    }\n+\n     #[test]\n     fn test_pop() {\n         macro_rules! t(\n@@ -1753,6 +1871,20 @@ mod tests {\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\", Some(\"b\"));\n     }\n \n+    #[test]\n+    fn test_root_path() {\n+        assert_eq!(Path::from_str(\"a\\\\b\\\\c\").root_path(), None);\n+        assert_eq!(Path::from_str(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::from_str(\"\\\\\")));\n+        assert_eq!(Path::from_str(\"C:a\").root_path(), None);\n+        assert_eq!(Path::from_str(\"C:\\\\a\").root_path(), Some(Path::from_str(\"C:\\\\\")));\n+        assert_eq!(Path::from_str(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::from_str(\"\\\\\\\\a\\\\b\")));\n+        assert_eq!(Path::from_str(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::from_str(\"\\\\\\\\?\\\\a\")));\n+        assert_eq!(Path::from_str(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::from_str(\"\\\\\\\\?\\\\C:\\\\\")));\n+        assert_eq!(Path::from_str(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n+                   Some(Path::from_str(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n+        assert_eq!(Path::from_str(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::from_str(\"\\\\\\\\.\\\\a\")));\n+    }\n+\n     #[test]\n     fn test_join() {\n         t!(s: Path::from_str(\"a\\\\b\\\\c\").join_str(\"..\"), \"a\\\\b\");\n@@ -1790,6 +1922,38 @@ mod tests {\n         // the full set of prefix tests\n     }\n \n+    #[test]\n+    fn test_join_many() {\n+        use to_man = at_vec::to_managed_move;\n+\n+        macro_rules! t(\n+            (s: $path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let res = path.join_many_str($join);\n+                    assert_eq!(res.as_str(), Some($exp));\n+                }\n+            );\n+            (v: $path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_vec($path);\n+                    let res = path.join_many($join);\n+                    assert_eq!(res.as_vec(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n+        t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [@\"d\", @\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n+              b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+    }\n+\n     #[test]\n     fn test_with_helpers() {\n         macro_rules! t(\n@@ -2002,16 +2166,55 @@ mod tests {\n         // will suffice. No need for the full set of prefix tests.\n     }\n \n+    #[test]\n+    fn test_add_extension() {\n+        macro_rules! t(\n+            (s: $path:expr, $ext:expr, $exp:expr) => (\n+                {\n+                    let mut path = Path::from_str($path);\n+                    path.add_extension_str($ext);\n+                    assert_eq!(path.as_str(), Some($exp));\n+                }\n+            );\n+            (v: $path:expr, $ext:expr, $exp:expr) => (\n+                {\n+                    let mut path = Path::from_vec($path);\n+                    path.add_extension($ext);\n+                    assert_eq!(path.as_vec(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: b!(\"hi\\\\there.txt\"), b!(\"foo\"), b!(\"hi\\\\there.txt.foo\"));\n+        t!(v: b!(\"hi\\\\there\"), b!(\"bar\"), b!(\"hi\\\\there.bar\"));\n+        t!(v: b!(\"\\\\\"), b!(\"foo\"), b!(\"\\\\\"));\n+        t!(v: b!(\".\"), b!(\"foo\"), b!(\".\"));\n+        t!(s: \"hi\\\\there.\", \"foo\", \"hi\\\\there..foo\");\n+        t!(s: \"hi\\\\there.txt\", \"\", \"hi\\\\there.txt\");\n+    }\n+\n     #[test]\n     fn test_getters() {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    assert_eq!(path.filename_str(), $filename);\n-                    assert_eq!(path.dirname_str(), $dirname);\n-                    assert_eq!(path.filestem_str(), $filestem);\n-                    assert_eq!(path.extension_str(), $ext);\n+                    let filename = $filename;\n+                    assert!(path.filename_str() == filename,\n+                            \"`%s`.filename_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), filename, path.filename_str());\n+                    let dirname = $dirname;\n+                    assert!(path.dirname_str() == dirname,\n+                            \"`%s`.dirname_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), dirname, path.dirname_str());\n+                    let filestem = $filestem;\n+                    assert!(path.filestem_str() == filestem,\n+                            \"`%s`.filestem_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), filestem, path.filestem_str());\n+                    let ext = $ext;\n+                    assert!(path.extension_str() == ext,\n+                            \"`%s`.extension_str(): Expected `%?`, found `%?`\",\n+                            path.as_str().unwrap(), ext, path.extension_str());\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n@@ -2025,12 +2228,12 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")), b!(\"c\"), b!(\"a\\\\b\"), b!(\"c\"), None);\n+        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n         t!(s: Path::from_str(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n-        t!(s: Path::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n-        t!(s: Path::from_str(\"\\\\\"), Some(\"\"), Some(\"\\\\\"), Some(\"\"), None);\n-        t!(s: Path::from_str(\"..\"), Some(\"\"), Some(\"..\"), Some(\"\"), None);\n-        t!(s: Path::from_str(\"..\\\\..\"), Some(\"\"), Some(\"..\\\\..\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::from_str(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n+        t!(s: Path::from_str(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::from_str(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n         t!(s: Path::from_str(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n         t!(s: Path::from_str(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n@@ -2076,10 +2279,10 @@ mod tests {\n     #[test]\n     fn test_is_absolute() {\n         macro_rules! t(\n-            ($path:expr, $abs:expr, $vol:expr, $cwd:expr) => (\n+            ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n                 {\n                     let path = Path::from_str($path);\n-                    let (abs, vol, cwd) = ($abs, $vol, $cwd);\n+                    let (abs, vol, cwd, rel) = ($abs, $vol, $cwd, $rel);\n                     let b = path.is_absolute();\n                     assert!(b == abs, \"Path '%s'.is_absolute(): expected %?, found %?\",\n                             path.as_str().unwrap(), abs, b);\n@@ -2089,25 +2292,28 @@ mod tests {\n                     let b = path.is_cwd_relative();\n                     assert!(b == cwd, \"Path '%s'.is_cwd_relative(): expected %?, found %?\",\n                             path.as_str().unwrap(), cwd, b);\n+                    let b = path.is_relative();\n+                    assert!(b == rel, \"Path '%s'.is_relativf(): expected %?, found %?\",\n+                            path.as_str().unwrap(), rel, b);\n                 }\n             )\n         )\n-        t!(\"a\\\\b\\\\c\", false, false, false);\n-        t!(\"\\\\a\\\\b\\\\c\", false, true, false);\n-        t!(\"a\", false, false, false);\n-        t!(\"\\\\a\", false, true, false);\n-        t!(\".\", false, false, false);\n-        t!(\"\\\\\", false, true, false);\n-        t!(\"..\", false, false, false);\n-        t!(\"..\\\\..\", false, false, false);\n-        t!(\"C:a\\\\b.txt\", false, false, true);\n-        t!(\"C:\\\\a\\\\b.txt\", true, false, false);\n-        t!(\"\\\\\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false);\n-        t!(\"\\\\\\\\?\\\\a\\\\b\\\\c.txt\", true, false, false);\n-        t!(\"\\\\\\\\?\\\\C:\\\\a\\\\b.txt\", true, false, false);\n-        t!(\"\\\\\\\\?\\\\C:a\\\\b.txt\", true, false, false); // NB: not equivalent to C:a\\b.txt\n-        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false);\n-        t!(\"\\\\\\\\.\\\\a\\\\b\", true, false, false);\n+        t!(\"a\\\\b\\\\c\", false, false, false, true);\n+        t!(\"\\\\a\\\\b\\\\c\", false, true, false, false);\n+        t!(\"a\", false, false, false, true);\n+        t!(\"\\\\a\", false, true, false, false);\n+        t!(\".\", false, false, false, true);\n+        t!(\"\\\\\", false, true, false, false);\n+        t!(\"..\", false, false, false, true);\n+        t!(\"..\\\\..\", false, false, false, true);\n+        t!(\"C:a\\\\b.txt\", false, false, true, false);\n+        t!(\"C:\\\\a\\\\b.txt\", true, false, false, false);\n+        t!(\"\\\\\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false, false);\n+        t!(\"\\\\\\\\?\\\\a\\\\b\\\\c.txt\", true, false, false, false);\n+        t!(\"\\\\\\\\?\\\\C:\\\\a\\\\b.txt\", true, false, false, false);\n+        t!(\"\\\\\\\\?\\\\C:a\\\\b.txt\", true, false, false, false); // NB: not equivalent to C:a\\b.txt\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false, false);\n+        t!(\"\\\\\\\\.\\\\a\\\\b\", true, false, false, false);\n     }\n \n     #[test]\n@@ -2213,6 +2419,38 @@ mod tests {\n         t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", true);\n     }\n \n+    #[test]\n+    fn test_ends_with_path() {\n+        macro_rules! t(\n+            (s: $path:expr, $child:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let child = Path::from_str($child);\n+                    assert_eq!(path.ends_with_path(&child), $exp);\n+                }\n+            );\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"c\", true);\n+        t!(s: \"a\\\\b\\\\c\", \"d\", false);\n+        t!(s: \"foo\\\\bar\\\\quux\", \"bar\", false);\n+        t!(s: \"foo\\\\bar\\\\quux\", \"barquux\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"b\\\\c\", true);\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n+        t!(s: \"a\\\\b\\\\c\", \"foo\\\\a\\\\b\\\\c\", false);\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", false); // child must be relative\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"foo\\\\a\\\\b\\\\c\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"\", false);\n+        t!(s: \"\", \"\", true);\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"d\\\\e\\\\f\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"b\", false);\n+        t!(s: \"C:\\\\a\\\\b\", \"b\", true);\n+        t!(s: \"C:\\\\a\\\\b\", \"C:b\", false);\n+        t!(s: \"C:\\\\a\\\\b\", \"C:a\\\\b\", false);\n+    }\n+\n     #[test]\n     fn test_path_relative_from() {\n         macro_rules! t(\n@@ -2348,22 +2586,34 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_component_iter() {\n+    fn test_str_component_iter() {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::from_str($path);\n-                    let comps = path.component_iter().to_owned_vec();\n+                    let comps = path.str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert!(comps.as_slice() == exp, \"str_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                    let comps = path.rev_str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n+                    let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n+                    assert!(comps.as_slice() == exp,\n+                            \"rev_str_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n                 }\n             );\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n                     let path = Path::from_vec(b!($($arg),+));\n-                    let comps = path.component_iter().to_owned_vec();\n+                    let comps = path.str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert!(comps.as_slice() == exp, \"str_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                    let comps = path.rev_str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n+                    let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n+                    assert!(comps.as_slice() == exp,\n+                            \"rev_str_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n                 }\n             )\n         )\n@@ -2408,6 +2658,29 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\", []);\n     }\n \n+    #[test]\n+    fn test_component_iter() {\n+        macro_rules! t(\n+            (s: $path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let comps = path.component_iter().to_owned_vec();\n+                    let exp: &[&[u8]] = $exp;\n+                    assert!(comps.as_slice() == exp, \"component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                    let comps = path.rev_component_iter().to_owned_vec();\n+                    let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n+                    assert!(comps.as_slice() == exp, \"rev_component_iter: Expected %?, found %?\",\n+                            comps.as_slice(), exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", [b!(\"a\"), b!(\"b\"), b!(\"c\")]);\n+        t!(s: \".\", [b!(\".\")]);\n+        // since this is really a wrapper around str_component_iter, those tests suffice\n+    }\n+\n     #[test]\n     fn test_each_parent() {\n         assert!(Path::from_str(\"/foo/bar\").each_parent(|_| true));", "previous_filename": "src/libstd/path2/windows.rs"}, {"sha": "24327e57f829516004d8907e90182c7e24862ece", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -60,10 +60,7 @@ pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n-pub use path::GenericPath;\n-pub use path::Path;\n-pub use path::PosixPath;\n-pub use path::WindowsPath;\n+pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};"}, {"sha": "9fbb897c2a7da39fc6c859169066515bdd0c9603", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -627,12 +627,13 @@ pub trait DirectoryInfo : FileSystemInfo {\n     fn mkdir(&self) {\n         match ignore_io_error(|| self.stat()) {\n             Some(_) => {\n+                let path = self.get_path();\n                 io_error::cond.raise(IoError {\n                     kind: PathAlreadyExists,\n                     desc: \"Path already exists\",\n                     detail:\n                         Some(format!(\"{} already exists; can't mkdir it\",\n-                                     self.get_path().to_str()))\n+                                     path.display()))\n                 })\n             },\n             None => mkdir(self.get_path())\n@@ -655,24 +656,27 @@ pub trait DirectoryInfo : FileSystemInfo {\n                 match s.is_dir {\n                     true => rmdir(self.get_path()),\n                     false => {\n+                        let path = self.get_path();\n                         let ioerr = IoError {\n                             kind: MismatchedFileTypeForOperation,\n                             desc: \"Cannot do rmdir() on a non-directory\",\n                             detail: Some(format!(\n                                 \"{} is a non-directory; can't rmdir it\",\n-                                self.get_path().to_str()))\n+                                path.display()))\n                         };\n                         io_error::cond.raise(ioerr);\n                     }\n                 }\n             },\n-            None =>\n+            None => {\n+                let path = self.get_path();\n                 io_error::cond.raise(IoError {\n                     kind: PathDoesntExist,\n                     desc: \"Path doesn't exist\",\n                     detail: Some(format!(\"{} doesn't exist; can't rmdir it\",\n-                                         self.get_path().to_str()))\n+                                         path.display()))\n                 })\n+            }\n         }\n     }\n \n@@ -699,7 +703,7 @@ mod test {\n     fn file_test_io_smoke_test() {\n         do run_in_mt_newsched_task {\n             let message = \"it's alright. have a good time\";\n-            let filename = &Path(\"./tmp/file_rt_io_file_test.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test.txt\");\n             {\n                 let mut write_stream = open(filename, Create, ReadWrite).unwrap();\n                 write_stream.write(message.as_bytes());\n@@ -721,7 +725,7 @@ mod test {\n     #[test]\n     fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path(\"./tmp/file_that_does_not_exist.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_that_does_not_exist.txt\");\n             let mut called = false;\n             do io_error::cond.trap(|_| {\n                 called = true;\n@@ -736,7 +740,7 @@ mod test {\n     #[test]\n     fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path(\"./tmp/file_another_file_that_does_not_exist.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_another_file_that_does_not_exist.txt\");\n             let mut called = false;\n             do io_error::cond.trap(|_| {\n                 called = true;\n@@ -753,7 +757,7 @@ mod test {\n             use str;\n             let message = \"ten-four\";\n             let mut read_mem = [0, .. 8];\n-            let filename = &Path(\"./tmp/file_rt_io_file_test_positional.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_positional.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(message.as_bytes());\n@@ -784,7 +788,7 @@ mod test {\n             let set_cursor = 4 as u64;\n             let mut tell_pos_pre_read;\n             let mut tell_pos_post_read;\n-            let filename = &Path(\"./tmp/file_rt_io_file_test_seeking.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_seeking.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(message.as_bytes());\n@@ -813,7 +817,7 @@ mod test {\n             let final_msg =     \"foo-the-bar!!\";\n             let seek_idx = 3;\n             let mut read_mem = [0, .. 13];\n-            let filename = &Path(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(initial_msg.as_bytes());\n@@ -839,7 +843,7 @@ mod test {\n             let chunk_two = \"asdf\";\n             let chunk_three = \"zxcv\";\n             let mut read_mem = [0, .. 4];\n-            let filename = &Path(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(initial_msg.as_bytes());\n@@ -869,7 +873,7 @@ mod test {\n     #[test]\n     fn file_test_stat_is_correct_on_is_file() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path(\"./tmp/file_stat_correct_on_is_file.txt\");\n+            let filename = &Path::from_str(\"./tmp/file_stat_correct_on_is_file.txt\");\n             {\n                 let mut fs = open(filename, Create, ReadWrite).unwrap();\n                 let msg = \"hw\";\n@@ -887,7 +891,7 @@ mod test {\n     #[test]\n     fn file_test_stat_is_correct_on_is_dir() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path(\"./tmp/file_stat_correct_on_is_dir\");\n+            let filename = &Path::from_str(\"./tmp/file_stat_correct_on_is_dir\");\n             mkdir(filename);\n             let stat_res = match stat(filename) {\n                 Some(s) => s,\n@@ -901,7 +905,7 @@ mod test {\n     #[test]\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         do run_in_mt_newsched_task {\n-            let dir = &Path(\"./tmp/fileinfo_false_on_dir\");\n+            let dir = &Path::from_str(\"./tmp/fileinfo_false_on_dir\");\n             mkdir(dir);\n             assert!(dir.is_file() == false);\n             rmdir(dir);\n@@ -911,7 +915,7 @@ mod test {\n     #[test]\n     fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         do run_in_mt_newsched_task {\n-            let file = &Path(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+            let file = &Path::from_str(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n             {\n                 let msg = \"foo\".as_bytes();\n                 let mut w = file.open_writer(Create);\n@@ -926,7 +930,7 @@ mod test {\n     #[test]\n     fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         do run_in_mt_newsched_task {\n-            let dir = &Path(\"./tmp/before_and_after_dir\");\n+            let dir = &Path::from_str(\"./tmp/before_and_after_dir\");\n             assert!(!dir.exists());\n             dir.mkdir();\n             assert!(dir.exists());\n@@ -940,11 +944,11 @@ mod test {\n     fn file_test_directoryinfo_readdir() {\n         use str;\n         do run_in_mt_newsched_task {\n-            let dir = &Path(\"./tmp/di_readdir\");\n+            let dir = &Path::from_str(\"./tmp/di_readdir\");\n             dir.mkdir();\n             let prefix = \"foo\";\n             for n in range(0,3) {\n-                let f = dir.push(format!(\"{}.txt\", n));\n+                let f = dir.join_str(format!(\"{}.txt\", n));\n                 let mut w = f.open_writer(Create);\n                 let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n                 let msg = msg_str.as_bytes();\n@@ -955,13 +959,13 @@ mod test {\n                     let mut mem = [0u8, .. 4];\n                     for f in files.iter() {\n                         {\n-                            let n = f.filestem();\n+                            let n = f.filestem_str();\n                             let mut r = f.open_reader(Open);\n                             r.read(mem);\n                             let read_str = str::from_utf8(mem);\n                             let expected = match n {\n-                                Some(n) => prefix+n,\n-                                None => fail2!(\"really shouldn't happen..\")\n+                                None|Some(\"\") => fail2!(\"really shouldn't happen..\"),\n+                                Some(n) => prefix+n\n                             };\n                             assert!(expected == read_str);\n                         }"}, {"sha": "a872423c255aef97283bacb06c863e745326971b", "filename": "src/libstd/rt/io/support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsupport.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -22,7 +22,7 @@ impl<'self> PathLike for &'self str {\n \n impl PathLike for Path {\n     fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        let s = self.to_str();\n+        let s = self.as_str().unwrap();\n         f(s)\n     }\n }\n@@ -35,7 +35,7 @@ mod test {\n     #[test]\n     fn path_like_smoke_test() {\n         let expected = if cfg!(unix) { \"/home\" } else { \"C:\\\\\" };\n-        let path = Path(expected);\n+        let path = Path::from_str(expected);\n         path.path_as_str(|p| assert!(p == expected));\n         path.path_as_str(|p| assert!(p == expected));\n     }"}, {"sha": "1178bfdaa80fc75e2824dff2bc8d92d1b604199c", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -16,6 +16,7 @@ use container::Container;\n use iter::{Iterator, range};\n use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n+use path::GenericPath;\n use rt::sched::Scheduler;\n use unstable::{run_in_bare_thread};\n use rt::thread::Thread;\n@@ -346,7 +347,6 @@ it is running in and assigns a port range based on it.\n fn base_port() -> uint {\n     use os;\n     use str::StrSlice;\n-    use to_str::ToStr;\n     use vec::ImmutableVector;\n \n     let base = 9600u;\n@@ -363,12 +363,14 @@ fn base_port() -> uint {\n         (\"dist\", base + range * 8)\n     ];\n \n-    let path = os::getcwd().to_str();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let path = os::getcwd();\n+    let path_s = path.as_str().unwrap();\n \n     let mut final_base = base;\n \n     for &(dir, base) in bases.iter() {\n-        if path.contains(dir) {\n+        if path_s.contains(dir) {\n             final_base = base;\n             break;\n         }"}, {"sha": "7756448adf8291f5495780a15be92952f48eb946", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -391,7 +391,7 @@ mod test {\n             let read_mem = vec::from_elem(read_buf_len, 0u8);\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n-            let p = Path(path_str);\n+            let p = Path::from_str(path_str);\n             let open_req = FsRequest::new();\n             do open_req.open(&loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n@@ -405,7 +405,7 @@ mod test {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let open_req = FsRequest::new();\n-                        do open_req.open(&loop_, &Path(path_str), read_flags as int,0)\n+                        do open_req.open(&loop_, &Path::from_str(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n@@ -431,7 +431,7 @@ mod test {\n                                         assert!(uverr.is_none());\n                                         let loop_ = &req.get_loop();\n                                         let unlink_req = FsRequest::new();\n-                                        do unlink_req.unlink(loop_, &Path(path_str))\n+                                        do unlink_req.unlink(loop_, &Path::from_str(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n@@ -465,7 +465,7 @@ mod test {\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path(path_str),\n+            let result = open_req.open_sync(&loop_, &Path::from_str(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let fd = result.unwrap();\n@@ -479,7 +479,7 @@ mod test {\n             assert!(result.is_ok());\n             // re-open\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path(path_str),\n+            let result = open_req.open_sync(&loop_, &Path::from_str(path_str),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n@@ -503,7 +503,7 @@ mod test {\n                 assert!(result.is_ok());\n                 // unlink\n                 let unlink_req = FsRequest::new();\n-                let result = unlink_req.unlink_sync(&loop_, &Path(path_str));\n+                let result = unlink_req.unlink_sync(&loop_, &Path::from_str(path_str));\n                 assert!(result.is_ok());\n             } else { fail2!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();"}, {"sha": "a139c4e95eff428273dbd1bed2183d9b49124f8a", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -34,7 +34,7 @@ use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr, accum_sockaddrs};\n use rt::uv::addrinfo::GetAddrInfoRequest;\n use unstable::sync::Exclusive;\n-use path::Path;\n+use path::{GenericPath, Path};\n use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n           S_IRUSR, S_IWUSR, S_IRWXU};\n@@ -631,7 +631,7 @@ impl IoFactory for UvIoFactory {\n                         None => {\n                             let stat = req.get_stat();\n                             Ok(FileStat {\n-                                path: Path(path_str),\n+                                path: Path::from_str(path_str),\n                                 is_file: stat.is_file(),\n                                 is_dir: stat.is_dir(),\n                                 size: stat.st_size,\n@@ -720,7 +720,9 @@ impl IoFactory for UvIoFactory {\n                             let rel_paths = req.get_paths();\n                             let mut paths = ~[];\n                             for r in rel_paths.iter() {\n-                                paths.push(Path(path_str+\"/\"+*r));\n+                                let mut p = Path::from_str(path_str);\n+                                p.push_str(*r);\n+                                paths.push(p);\n                             }\n                             Ok(paths)\n                         },\n@@ -2177,20 +2179,20 @@ fn file_test_uvio_full_simple_impl() {\n         {\n             let create_fm = Create;\n             let create_fa = ReadWrite;\n-            let mut fd = (*io).fs_open(&Path(path), create_fm, create_fa).unwrap();\n+            let mut fd = (*io).fs_open(&Path::from_str(path), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf);\n         }\n         {\n             let ro_fm = Open;\n             let ro_fa = Read;\n-            let mut fd = (*io).fs_open(&Path(path), ro_fm, ro_fa).unwrap();\n+            let mut fd = (*io).fs_open(&Path::from_str(path), ro_fm, ro_fa).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }\n-        (*io).fs_unlink(&Path(path));\n+        (*io).fs_unlink(&Path::from_str(path));\n     }\n }\n "}, {"sha": "3f7ce3eae586466614a80e038b9c7ed775956a70", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -578,8 +578,8 @@ mod tests {\n         let mut prog = run_pwd(None);\n \n         let output = str::from_utf8(prog.finish_with_output().output);\n-        let parent_dir = os::getcwd().normalize();\n-        let child_dir = Path(output.trim()).normalize();\n+        let parent_dir = os::getcwd();\n+        let child_dir = Path::from_str(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -592,11 +592,11 @@ mod tests {\n     fn test_change_working_directory() {\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().dir_path().normalize();\n+        let parent_dir = os::getcwd().dir_path();\n         let mut prog = run_pwd(Some(&parent_dir));\n \n         let output = str::from_utf8(prog.finish_with_output().output);\n-        let child_dir = Path(output.trim()).normalize();\n+        let child_dir = Path::from_str(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();"}, {"sha": "73cb6a5645de3317e7f817ef398b194b853f4e29", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -177,7 +177,6 @@ pub mod libc;\n pub mod c_str;\n pub mod os;\n pub mod path;\n-pub mod path2;\n pub mod rand;\n pub mod run;\n pub mod sys;"}, {"sha": "a91d68366f33afa866d5013187dce02f3ee023a7", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -225,7 +225,7 @@ pub mod dl {\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n         #[fixed_stack_segment]; #[inline(never)];\n-        do os::win32::as_utf16_p(filename.to_str()) |raw_name| {\n+        do os::win32::as_utf16_p(filename.as_str().unwrap()) |raw_name| {\n             LoadLibraryW(raw_name)\n         }\n     }"}, {"sha": "ef09315a88777b554cd51f30b758c139800f2978", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -81,15 +81,15 @@ pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n         cx.parse_sess(), cx.cfg(),\n-        &res_rel_file(cx, sp, &Path(file)), sp);\n+        &res_rel_file(cx, sp, &Path::from_str(file)), sp);\n     base::MRExpr(p.parse_expr())\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n-    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n+    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path::from_str(file)));\n     match res {\n       result::Ok(res) => {\n           base::MRExpr(cx.expr_str(sp, res.to_managed()))\n@@ -103,7 +103,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n-    match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n+    match io::read_whole_file(&res_rel_file(cx, sp, &Path::from_str(file))) {\n       result::Ok(src) => {\n         let u8_exprs: ~[@ast::Expr] = src.iter().map(|char| cx.expr_u8(sp, *char)).collect();\n         base::MRExpr(cx.expr_vec(sp, u8_exprs))\n@@ -144,10 +144,12 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n // isn't already)\n fn res_rel_file(cx: @ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n-    if !arg.is_absolute {\n-        let cu = Path(cx.codemap().span_to_filename(sp));\n-        cu.dir_path().push_many(arg.components)\n+    if !arg.is_absolute() {\n+        let mut cu = Path::from_str(cx.codemap().span_to_filename(sp));\n+        cu.pop();\n+        cu.push_path(arg);\n+        cu\n     } else {\n-        (*arg).clone()\n+        arg.clone()\n     }\n }"}, {"sha": "05998d80213951280f61082053878fc61c529ece", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -261,7 +261,8 @@ pub fn new_parser_from_tts(sess: @mut ParseSess,\n pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n     -> @FileMap {\n     match io::read_whole_file_str(path) {\n-        Ok(src) => string_to_filemap(sess, src.to_managed(), path.to_str().to_managed()),\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        Ok(src) => string_to_filemap(sess, src.to_managed(), path.as_str().unwrap().to_managed()),\n         Err(e) => {\n             match spanopt {\n                 Some(span) => sess.span_diagnostic.span_fatal(span, e),"}, {"sha": "ad565fd2ec4acb2aa192f44339ea896d327a05cc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -3992,27 +3992,20 @@ impl Parser {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::item_, ~[ast::Attribute]) {\n-        let prefix = Path(self.sess.cm.span_to_filename(*self.span));\n-        let prefix = prefix.dir_path();\n+        let mut prefix = Path::from_str(self.sess.cm.span_to_filename(*self.span));\n+        prefix.pop();\n         let mod_path_stack = &*self.mod_path_stack;\n-        let mod_path = Path(\".\").push_many(*mod_path_stack);\n-        let dir_path = prefix.push_many(mod_path.components);\n+        let mod_path = Path::from_str(\".\").join_many_str(*mod_path_stack);\n+        let dir_path = prefix.join_path(&mod_path);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {\n-            Some(d) => {\n-                let path = Path(d);\n-                if !path.is_absolute {\n-                    dir_path.push(d)\n-                } else {\n-                    path\n-                }\n-            }\n+            Some(d) => dir_path.join_str(d),\n             None => {\n                 let mod_name = token::interner_get(id.name).to_owned();\n                 let default_path_str = mod_name + \".rs\";\n                 let secondary_path_str = mod_name + \"/mod.rs\";\n-                let default_path = dir_path.push(default_path_str);\n-                let secondary_path = dir_path.push(secondary_path_str);\n+                let default_path = dir_path.join_str(default_path_str);\n+                let secondary_path = dir_path.join_str(secondary_path_str);\n                 let default_exists = default_path.exists();\n                 let secondary_exists = secondary_path.exists();\n                 match (default_exists, secondary_exists) {\n@@ -4039,28 +4032,30 @@ impl Parser {\n                               path: Path,\n                               outer_attrs: ~[ast::Attribute],\n                               id_sp: Span) -> (ast::item_, ~[ast::Attribute]) {\n-        let full_path = path.normalize();\n-\n-        let maybe_i = do self.sess.included_mod_stack.iter().position |p| { *p == full_path };\n+        let maybe_i = do self.sess.included_mod_stack.iter().position |p| { *p == path };\n         match maybe_i {\n             Some(i) => {\n                 let stack = &self.sess.included_mod_stack;\n                 let mut err = ~\"circular modules: \";\n                 for p in stack.slice(i, stack.len()).iter() {\n-                    err.push_str(p.to_str());\n+                    do p.with_display_str |s| {\n+                        err.push_str(s);\n+                    }\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(full_path.to_str());\n+                do path.with_display_str |s| {\n+                    err.push_str(s);\n+                }\n                 self.span_fatal(id_sp, err);\n             }\n             None => ()\n         }\n-        self.sess.included_mod_stack.push(full_path.clone());\n+        self.sess.included_mod_stack.push(path.clone());\n \n         let p0 =\n             new_sub_parser_from_file(self.sess,\n                                      self.cfg.clone(),\n-                                     &full_path,\n+                                     &path,\n                                      id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n         let mod_attrs = vec::append(outer_attrs, inner);"}, {"sha": "8a5cb016a738cb22e7000c748d115252fc61637b", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -73,8 +73,8 @@ fn read_line() {\n     use std::rt::io::file::FileInfo;\n     use std::rt::io::buffered::BufferedReader;\n \n-    let path = Path(env!(\"CFG_SRC_DIR\"))\n-        .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n+    let path = Path::from_str(env!(\"CFG_SRC_DIR\"))\n+        .join_str(\"src/test/bench/shootout-k-nucleotide.data\");\n \n     for _ in range(0, 3) {\n         let mut reader = BufferedReader::new(path.open_reader(Open).unwrap());"}, {"sha": "addb43c49952c042af6a27ea9ab4dcf3b1a22382", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -122,7 +122,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        io::file_writer(&Path(\"./shootout-fasta.data\"),\n+        io::file_writer(&Path::from_str(\"./shootout-fasta.data\"),\n                         [io::Truncate, io::Create]).unwrap()\n     } else {\n         io::stdout()"}, {"sha": "58ec5d440718cdad6b0637f19172ff4fbc3c80f9", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -164,8 +164,8 @@ fn main() {\n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         // FIXME: Using this compile-time env variable is a crummy way to\n         // get to this massive data set, but include_bin! chokes on it (#2598)\n-        let path = Path(env!(\"CFG_SRC_DIR\"))\n-            .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n+        let path = Path::from_str(env!(\"CFG_SRC_DIR\"))\n+            .join_str(\"src/test/bench/shootout-k-nucleotide.data\");\n         ~path.open_reader(Open).unwrap() as ~Reader\n     } else {\n         ~stdio::stdin() as ~Reader"}, {"sha": "170645f4404b5a4a8e4cb1a5e277893db68f36bc", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -20,14 +20,14 @@ use std::{io, os, unstable};\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            os::make_dir(&Path(path), 0xFFFF);\n+            os::make_dir(&Path::from_str(path), 0xFFFF);\n         } else {\n-            io::mk_file_writer(&Path(path), [io::Create]);\n+            io::mk_file_writer(&Path::from_str(path), [io::Create]);\n         }\n     }\n \n     fn abs_path(path: &str) -> Path {\n-        os::getcwd().push_many(Path(path).components)\n+        os::getcwd().join_path(&Path::from_str(path))\n     }\n \n     fn glob_vec(pattern: &str) -> ~[Path] {"}, {"sha": "01d895d1bcf05e41e3e4ea8c2b53437911e82fa3", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -23,7 +23,7 @@ fn tester()\n {\n     let loader: rsrc_loader = |_path| {result::Ok(~\"more blah\")};\n \n-    let path = path::Path(\"blah\");\n+    let path = path::Path::from_str(\"blah\");\n     assert!(loader(&path).is_ok());\n }\n "}, {"sha": "608624670fc373ad05991e45ef3c5dd4d57be2c7", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -25,12 +25,12 @@ fn rename_directory() {\n \n         let tmpdir = TempDir::new(\"rename_directory\").expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n-        let old_path = tmpdir.push_many([\"foo\", \"bar\", \"baz\"]);\n+        let old_path = tmpdir.join_many_str([\"foo\", \"bar\", \"baz\"]);\n         assert!(os::mkdir_recursive(&old_path, U_RWX));\n-        let test_file = &old_path.push(\"temp.txt\");\n+        let test_file = &old_path.join_str(\"temp.txt\");\n \n         /* Write the temp input file */\n-        let ostream = do test_file.to_str().with_c_str |fromp| {\n+        let ostream = do test_file.with_c_str |fromp| {\n             do \"w+b\".with_c_str |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n@@ -46,11 +46,11 @@ fn rename_directory() {\n         }\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n-        let new_path = tmpdir.push_many([\"quux\", \"blat\"]);\n+        let new_path = tmpdir.join_many_str([\"quux\", \"blat\"]);\n         assert!(os::mkdir_recursive(&new_path, U_RWX));\n-        assert!(os::rename_file(&old_path, &new_path.push(\"newdir\")));\n-        assert!(os::path_is_dir(&new_path.push(\"newdir\")));\n-        assert!(os::path_exists(&new_path.push_many([\"newdir\", \"temp.txt\"])));\n+        assert!(os::rename_file(&old_path, &new_path.join_str(\"newdir\")));\n+        assert!(os::path_is_dir(&new_path.join_str(\"newdir\")));\n+        assert!(os::path_exists(&new_path.join_many_str([\"newdir\", \"temp.txt\"])));\n     }\n }\n "}, {"sha": "5cd62368aa2221f467c222c55edacd03017d798d", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -18,8 +18,8 @@ use std::io;\n use std::os;\n \n pub fn main() {\n-    let dir = tempfile::TempDir::new_in(&Path(\".\"), \"\").unwrap();\n-    let path = dir.path().push(\"file\");\n+    let dir = tempfile::TempDir::new_in(&Path::from_str(\".\"), \"\").unwrap();\n+    let path = dir.path().join_str(\"file\");\n \n     {\n         match io::file_writer(&path, [io::Create, io::Truncate]) {"}, {"sha": "80e63396350b299e6c478471350ddd44f82a2006", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=73d3d00ec437f87ac665b4e4da3bedec8ce4f9ef", "patch": "@@ -28,12 +28,15 @@ use std::cell::Cell;\n \n fn test_tempdir() {\n     let path = {\n-        let p = TempDir::new_in(&Path(\".\"), \"foobar\").unwrap();\n+        let p = TempDir::new_in(&Path::from_str(\".\"), \"foobar\").unwrap();\n         let p = p.path();\n-        assert!(p.to_str().ends_with(\"foobar\"));\n+        assert!(ends_with(p.as_vec(), bytes!(\"foobar\")));\n         p.clone()\n     };\n     assert!(!os::path_exists(&path));\n+    fn ends_with(v: &[u8], needle: &[u8]) -> bool {\n+        v.len() >= needle.len() && v.slice_from(v.len()-needle.len()) == needle\n+    }\n }\n \n fn test_rm_tempdir() {\n@@ -81,36 +84,37 @@ fn test_rm_tempdir() {\n // Ideally these would be in std::os but then core would need\n // to depend on std\n fn recursive_mkdir_rel() {\n-    let path = Path(\"frob\");\n-    debug2!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.to_str(),\n-           os::getcwd().to_str(),\n-           os::path_exists(&path));\n+    let path = Path::from_str(\"frob\");\n+    let cwd = os::getcwd();\n+    debug2!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n+           cwd.display(), os::path_exists(&path));\n     assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     assert!(os::path_is_dir(&path));\n     assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     assert!(os::path_is_dir(&path));\n }\n \n fn recursive_mkdir_dot() {\n-    let dot = Path(\".\");\n+    let dot = Path::from_str(\".\");\n     assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    let dotdot = Path(\"..\");\n+    let dotdot = Path::from_str(\"..\");\n     assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n }\n \n fn recursive_mkdir_rel_2() {\n-    let path = Path(\"./frob/baz\");\n-    debug2!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.to_str(),\n-           os::getcwd().to_str(), os::path_exists(&path));\n+    let path = Path::from_str(\"./frob/baz\");\n+    let cwd = os::getcwd();\n+    debug2!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n+           cwd.display(), os::path_exists(&path));\n     assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n         assert!(os::path_is_dir(&path));\n-    assert!(os::path_is_dir(&path.pop()));\n-    let path2 = Path(\"quux/blat\");\n-    debug2!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.to_str(),\n-           os::getcwd().to_str());\n+    assert!(os::path_is_dir(&path.dir_path()));\n+    let path2 = Path::from_str(\"quux/blat\");\n+    debug2!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n+           cwd.display());\n     assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n         assert!(os::path_is_dir(&path2));\n-    assert!(os::path_is_dir(&path2.pop()));\n+    assert!(os::path_is_dir(&path2.dir_path()));\n }\n \n // Ideally this would be in core, but needs TempFile\n@@ -120,17 +124,17 @@ pub fn test_rmdir_recursive_ok() {\n     let tmpdir = TempDir::new(\"test\").expect(\"test_rmdir_recursive_ok: \\\n                                               couldn't create temp dir\");\n     let tmpdir = tmpdir.path();\n-    let root = tmpdir.push(\"foo\");\n+    let root = tmpdir.join_str(\"foo\");\n \n-    debug2!(\"making {}\", root.to_str());\n+    debug2!(\"making {}\", root.display());\n     assert!(os::make_dir(&root, rwx));\n-    assert!(os::make_dir(&root.push(\"foo\"), rwx));\n-    assert!(os::make_dir(&root.push(\"foo\").push(\"bar\"), rwx));\n-    assert!(os::make_dir(&root.push(\"foo\").push(\"bar\").push(\"blat\"), rwx));\n+    assert!(os::make_dir(&root.join_str(\"foo\"), rwx));\n+    assert!(os::make_dir(&root.join_str(\"foo\").join_str(\"bar\"), rwx));\n+    assert!(os::make_dir(&root.join_str(\"foo\").join_str(\"bar\").join_str(\"blat\"), rwx));\n     assert!(os::remove_dir_recursive(&root));\n     assert!(!os::path_exists(&root));\n-    assert!(!os::path_exists(&root.push(\"bar\")));\n-    assert!(!os::path_exists(&root.push(\"bar\").push(\"blat\")));\n+    assert!(!os::path_exists(&root.join_str(\"bar\")));\n+    assert!(!os::path_exists(&root.join_str(\"bar\").join_str(\"blat\")));\n }\n \n fn in_tmpdir(f: &fn()) {"}]}