{"sha": "fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNjJmZjQ2NWNiNTcyZTU4YjIzYmYxZGRiMGNlNTFlMTFjMjFlNDk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-28T01:21:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-28T01:21:32Z"}, "message": "De-mode std::{treemap,sort}. Part of #3583.", "tree": {"sha": "8fe90dadaa120ddf3e43f81bc79f24b8a8a57b7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fe90dadaa120ddf3e43f81bc79f24b8a8a57b7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "html_url": "https://github.com/rust-lang/rust/commit/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86041c421dc5782bf48cdac4a4bc49dc1e50b360", "url": "https://api.github.com/repos/rust-lang/rust/commits/86041c421dc5782bf48cdac4a4bc49dc1e50b360", "html_url": "https://github.com/rust-lang/rust/commit/86041c421dc5782bf48cdac4a4bc49dc1e50b360"}], "stats": {"total": 36, "additions": 11, "deletions": 25}, "files": [{"sha": "20a18b883203a504ea4c43ecddebb6137d80c7f9", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "patch": "@@ -5,12 +5,6 @@\n use vec::{len, push};\n use core::cmp::{Eq, Ord};\n \n-export le;\n-export merge_sort;\n-export quick_sort;\n-export quick_sort3;\n-export Sort;\n-\n type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n \n /**\n@@ -19,7 +13,7 @@ type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n+pub fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n     type Slice = (uint, uint);\n \n     return merge_sort_(le, v, (0u, len(v)));\n@@ -93,7 +87,7 @@ fn qsort<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-fn quick_sort<T: Copy>(compare_func: Le<T>, arr: &[mut T]) {\n+pub fn quick_sort<T: Copy>(compare_func: Le<T>, arr: &[mut T]) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n@@ -155,12 +149,12 @@ fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-fn quick_sort3<T: Copy Ord Eq>(arr: &[mut T]) {\n+pub fn quick_sort3<T: Copy Ord Eq>(arr: &[mut T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n \n-trait Sort {\n+pub trait Sort {\n     fn qsort(self);\n }\n \n@@ -274,7 +268,7 @@ mod tests {\n \n     fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n-        pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n         let v3 = merge_sort::<int>(f, v1);\n         let mut i = 0u;\n@@ -304,7 +298,7 @@ mod tests {\n \n     #[test]\n     fn test_merge_sort_mutable() {\n-        pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let v1 = ~[mut 3, 2, 1];\n         let v2 = merge_sort(le, v1);\n         assert v2 == ~[1, 2, 3];"}, {"sha": "96d7b8c20fcba9f2c2cb4d303da9e047f00a57c8", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "patch": "@@ -98,11 +98,8 @@ mod map;\n mod rope;\n #[legacy_exports]\n mod smallintmap;\n-#[legacy_exports]\n mod sort;\n-#[legacy_exports]\n mod treemap;\n-#[legacy_exports]\n \n // And ... other stuff\n "}, {"sha": "3419f1cb90c2be4ccb19041295faf929cb519550", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe62ff465cb572e58b23bf1ddb0ce51e11c21e49/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=fe62ff465cb572e58b23bf1ddb0ce51e11c21e49", "patch": "@@ -12,12 +12,7 @@ use core::cmp::{Eq, Ord};\n use core::option::{Some, None};\n use Option = core::Option;\n \n-export TreeMap;\n-export insert;\n-export find;\n-export traverse;\n-\n-type TreeMap<K, V> = @mut TreeEdge<K, V>;\n+pub type TreeMap<K, V> = @mut TreeEdge<K, V>;\n \n type TreeEdge<K, V> = Option<@TreeNode<K, V>>;\n \n@@ -29,10 +24,10 @@ enum TreeNode<K, V> = {\n };\n \n /// Create a treemap\n-fn TreeMap<K, V>() -> TreeMap<K, V> { @mut None }\n+pub fn TreeMap<K, V>() -> TreeMap<K, V> { @mut None }\n \n /// Insert a value into the map\n-fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n+pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n     match copy *m {\n       None => {\n         *m = Some(@TreeNode({key: k,\n@@ -54,7 +49,7 @@ fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n }\n \n /// Find a value based on the key\n-fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, +k: K)\n+pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, +k: K)\n                               -> Option<V> {\n     match copy *m {\n       None => None,\n@@ -73,7 +68,7 @@ fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, +k: K)\n }\n \n /// Visit all pairs in the map in order.\n-fn traverse<K, V: Copy>(m: &const TreeEdge<K, V>, f: fn((&K), (&V))) {\n+pub fn traverse<K, V: Copy>(m: &const TreeEdge<K, V>, f: fn((&K), (&V))) {\n     match copy *m {\n       None => (),\n       Some(node) => {"}]}