{"sha": "80a2a94d5a646859239cb8acab3ecc3c508e741e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYTJhOTRkNWE2NDY4NTkyMzljYjhhY2FiM2VjYzNjNTA4ZTc0MWU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-04-20T22:32:23Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-04-22T11:25:14Z"}, "message": "Re-enable hoedown by default", "tree": {"sha": "e234d8dc09de0b8e2022bc54df1a70a9772f8a53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e234d8dc09de0b8e2022bc54df1a70a9772f8a53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a2a94d5a646859239cb8acab3ecc3c508e741e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a2a94d5a646859239cb8acab3ecc3c508e741e", "html_url": "https://github.com/rust-lang/rust/commit/80a2a94d5a646859239cb8acab3ecc3c508e741e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a2a94d5a646859239cb8acab3ecc3c508e741e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff13b7c91813eb178c98a7abc661acaf5c41dc31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff13b7c91813eb178c98a7abc661acaf5c41dc31", "html_url": "https://github.com/rust-lang/rust/commit/ff13b7c91813eb178c98a7abc661acaf5c41dc31"}], "stats": {"total": 532, "additions": 382, "deletions": 150}, "files": [{"sha": "614d59c512da22dbb0224bda4dcce817dd1bded3", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 294, "deletions": 41, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=80a2a94d5a646859239cb8acab3ecc3c508e741e", "patch": "@@ -32,6 +32,7 @@ use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n+use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n@@ -40,21 +41,28 @@ use syntax::codemap::Span;\n use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n+use html::escape::Escape;\n use test;\n \n use pulldown_cmark::{html, Event, Tag, Parser};\n use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n \n+#[derive(PartialEq, Debug, Clone, Copy)]\n+pub enum RenderType {\n+    Hoedown,\n+    Pulldown,\n+}\n+\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n // The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str);\n+pub struct Markdown<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str);\n+pub struct MarkdownWithToc<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str);\n+pub struct MarkdownHtml<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str);\n \n@@ -73,6 +81,14 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n+/// Returns a new string with all consecutive whitespace collapsed into\n+/// single spaces.\n+///\n+/// Any leading or trailing whitespace will be trimmed.\n+fn collapse_whitespace(s: &str) -> String {\n+    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n+}\n+\n /// Convert chars from a title for an id.\n ///\n /// \"Hello, world!\" -> \"hello-world\"\n@@ -368,6 +384,7 @@ const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n+const HOEDOWN_HTML_ESCAPE: libc::c_uint = 1 << 1;\n \n const HOEDOWN_EXTENSIONS: libc::c_uint =\n     HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n@@ -462,6 +479,13 @@ struct hoedown_buffer {\n     unit: libc::size_t,\n }\n \n+struct MyOpaque {\n+    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                           *const hoedown_buffer, *const hoedown_renderer_data,\n+                           libc::size_t),\n+    toc_builder: Option<TocBuilder>,\n+}\n+\n extern {\n     fn hoedown_html_renderer_new(render_flags: libc::c_uint,\n                                  nesting_level: libc::c_int)\n@@ -478,6 +502,7 @@ extern {\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n+    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n }\n \n@@ -487,6 +512,208 @@ impl hoedown_buffer {\n     }\n }\n \n+pub fn render(w: &mut fmt::Formatter,\n+              s: &str,\n+              print_toc: bool,\n+              html_flags: libc::c_uint) -> fmt::Result {\n+    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n+                    line: libc::size_t) {\n+        unsafe {\n+            if orig_text.is_null() { return }\n+\n+            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n+            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n+            let text = (*orig_text).as_bytes();\n+            let origtext = str::from_utf8(text).unwrap();\n+            let origtext = origtext.trim_left();\n+            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n+            let rendered = if lang.is_null() || origtext.is_empty() {\n+                false\n+            } else {\n+                let rlang = (*lang).as_bytes();\n+                let rlang = str::from_utf8(rlang).unwrap();\n+                if !LangString::parse(rlang).rust {\n+                    (my_opaque.dfltblk)(ob, orig_text, lang,\n+                                        opaque as *const hoedown_renderer_data,\n+                                        line);\n+                    true\n+                } else {\n+                    false\n+                }\n+            };\n+\n+            let lines = origtext.lines().filter(|l| {\n+                stripped_filtered_line(*l).is_none()\n+            });\n+            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+            if rendered { return }\n+            PLAYGROUND.with(|play| {\n+                // insert newline to clearly separate it from the\n+                // previous block so we can shorten the html output\n+                let mut s = String::from(\"\\n\");\n+                let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n+                    if url.is_empty() {\n+                        return None;\n+                    }\n+                    let test = origtext.lines().map(|l| {\n+                        stripped_filtered_line(l).unwrap_or(l)\n+                    }).collect::<Vec<&str>>().join(\"\\n\");\n+                    let krate = krate.as_ref().map(|s| &**s);\n+                    let test = test::maketest(&test, krate, false,\n+                                              &Default::default());\n+                    let channel = if test.contains(\"#![feature(\") {\n+                        \"&amp;version=nightly\"\n+                    } else {\n+                        \"\"\n+                    };\n+                    // These characters don't need to be escaped in a URI.\n+                    // FIXME: use a library function for percent encoding.\n+                    fn dont_escape(c: u8) -> bool {\n+                        (b'a' <= c && c <= b'z') ||\n+                        (b'A' <= c && c <= b'Z') ||\n+                        (b'0' <= c && c <= b'9') ||\n+                        c == b'-' || c == b'_' || c == b'.' ||\n+                        c == b'~' || c == b'!' || c == b'\\'' ||\n+                        c == b'(' || c == b')' || c == b'*'\n+                    }\n+                    let mut test_escaped = String::new();\n+                    for b in test.bytes() {\n+                        if dont_escape(b) {\n+                            test_escaped.push(char::from(b));\n+                        } else {\n+                            write!(test_escaped, \"%{:02X}\", b).unwrap();\n+                        }\n+                    }\n+                    Some(format!(\n+                        r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n+                        url, test_escaped, channel\n+                    ))\n+                });\n+                s.push_str(&highlight::render_with_highlighting(\n+                               &text,\n+                               Some(\"rust-example-rendered\"),\n+                               None,\n+                               playground_button.as_ref().map(String::as_str)));\n+                let output = CString::new(s).unwrap();\n+                hoedown_buffer_puts(ob, output.as_ptr());\n+            })\n+        }\n+    }\n+\n+    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+                     level: libc::c_int, data: *const hoedown_renderer_data,\n+                     _: libc::size_t) {\n+        // hoedown does this, we may as well too\n+        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n+\n+        // Extract the text provided\n+        let s = if text.is_null() {\n+            \"\".to_owned()\n+        } else {\n+            let s = unsafe { (*text).as_bytes() };\n+            str::from_utf8(&s).unwrap().to_owned()\n+        };\n+\n+        // Discard '<em>', '<code>' tags and some escaped characters,\n+        // transform the contents of the header into a hyphenated string\n+        // without non-alphanumeric characters other than '-' and '_'.\n+        //\n+        // This is a terrible hack working around how hoedown gives us rendered\n+        // html for text rather than the raw text.\n+        let mut id = s.clone();\n+        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n+                            \"<strong>\", \"</strong>\",\n+                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n+        for sub in repl_sub {\n+            id = id.replace(sub, \"\");\n+        }\n+        let id = id.chars().filter_map(|c| {\n+            if c.is_alphanumeric() || c == '-' || c == '_' {\n+                if c.is_ascii() {\n+                    Some(c.to_ascii_lowercase())\n+                } else {\n+                    Some(c)\n+                }\n+            } else if c.is_whitespace() && c.is_ascii() {\n+                Some('-')\n+            } else {\n+                None\n+            }\n+        }).collect::<String>();\n+\n+        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+\n+        let id = derive_id(id);\n+\n+        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+        });\n+\n+        // Render the HTML\n+        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n+                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+                           s, lvl = level, id = id, sec = sec);\n+\n+        let text = CString::new(text).unwrap();\n+        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n+    }\n+\n+    extern fn codespan(\n+        ob: *mut hoedown_buffer,\n+        text: *const hoedown_buffer,\n+        _: *const hoedown_renderer_data,\n+        _: libc::size_t\n+    ) -> libc::c_int {\n+        let content = if text.is_null() {\n+            \"\".to_owned()\n+        } else {\n+            let bytes = unsafe { (*text).as_bytes() };\n+            let s = str::from_utf8(bytes).unwrap();\n+            collapse_whitespace(s)\n+        };\n+\n+        let content = format!(\"<code>{}</code>\", Escape(&content));\n+        let element = CString::new(content).unwrap();\n+        unsafe { hoedown_buffer_puts(ob, element.as_ptr()); }\n+        // Return anything except 0, which would mean \"also print the code span verbatim\".\n+        1\n+    }\n+\n+    unsafe {\n+        let ob = hoedown_buffer_new(DEF_OUNIT);\n+        let renderer = hoedown_html_renderer_new(html_flags, 0);\n+        let mut opaque = MyOpaque {\n+            dfltblk: (*renderer).blockcode.unwrap(),\n+            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n+        };\n+        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                = &mut opaque as *mut _ as *mut libc::c_void;\n+        (*renderer).blockcode = Some(block);\n+        (*renderer).header = Some(header);\n+        (*renderer).codespan = Some(codespan);\n+\n+        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n+        hoedown_document_render(document, ob, s.as_ptr(),\n+                                s.len() as libc::size_t);\n+        hoedown_document_free(document);\n+\n+        hoedown_html_renderer_free(renderer);\n+\n+        let mut ret = opaque.toc_builder.map_or(Ok(()), |builder| {\n+            write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n+        });\n+\n+        if ret.is_ok() {\n+            let buf = (*ob).as_bytes();\n+            ret = w.write_str(str::from_utf8(buf).unwrap());\n+        }\n+        hoedown_buffer_free(ob);\n+        ret\n+    }\n+}\n+\n pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n     extern fn block(_ob: *mut hoedown_buffer,\n                     text: *const hoedown_buffer,\n@@ -511,7 +738,22 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n                 stripped_filtered_line(l).unwrap_or(l)\n             });\n             let filename = tests.get_filename();\n-            tests.add_old_test(lines.collect::<Vec<&str>>().join(\"\\n\"), filename);\n+\n+            if tests.render_type == RenderType::Hoedown {\n+                let text = (*text).as_bytes();\n+                let text = str::from_utf8(text).unwrap();\n+                let lines = text.lines().map(|l| {\n+                    stripped_filtered_line(l).unwrap_or(l)\n+                });\n+                let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+                tests.add_test(text.to_owned(),\n+                               block_info.should_panic, block_info.no_run,\n+                               block_info.ignore, block_info.test_harness,\n+                               block_info.compile_fail, block_info.error_codes,\n+                               line, filename);\n+            } else {\n+                tests.add_old_test(lines.collect::<Vec<&str>>().join(\"\\n\"), filename);\n+            }\n         }\n     }\n \n@@ -533,7 +775,6 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n     }\n \n     tests.set_position(position);\n-\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);\n@@ -702,72 +943,84 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md) = *self;\n+        let Markdown(md, render_type) = *self;\n+\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n+        if render_type == RenderType::Hoedown {\n+            render(fmt, md, false, 0)\n+        } else {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n \n-        let mut opts = Options::empty();\n-        opts.insert(OPTION_ENABLE_TABLES);\n-        opts.insert(OPTION_ENABLE_FOOTNOTES);\n-\n-        let p = Parser::new_ext(md, opts);\n+            let p = Parser::new_ext(md, opts);\n \n-        let mut s = String::with_capacity(md.len() * 3 / 2);\n+            let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+            html::push_html(&mut s,\n+                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n \n-        fmt.write_str(&s)\n+            fmt.write_str(&s)\n+        }\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownWithToc(md) = *self;\n+        let MarkdownWithToc(md, render_type) = *self;\n \n-        let mut opts = Options::empty();\n-        opts.insert(OPTION_ENABLE_TABLES);\n-        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+        if render_type == RenderType::Hoedown {\n+            render(fmt, md, true, 0)\n+        } else {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n \n-        let p = Parser::new_ext(md, opts);\n+            let p = Parser::new_ext(md, opts);\n \n-        let mut s = String::with_capacity(md.len() * 3 / 2);\n+            let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        let mut toc = TocBuilder::new();\n+            let mut toc = TocBuilder::new();\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+            html::push_html(&mut s,\n+                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n \n-        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n+            write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n \n-        fmt.write_str(&s)\n+            fmt.write_str(&s)\n+        }\n     }\n }\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownHtml(md) = *self;\n+        let MarkdownHtml(md, render_type) = *self;\n+\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n+        if render_type == RenderType::Hoedown {\n+            render(fmt, md, false, HOEDOWN_HTML_ESCAPE)\n+        } else {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n \n-        let mut opts = Options::empty();\n-        opts.insert(OPTION_ENABLE_TABLES);\n-        opts.insert(OPTION_ENABLE_FOOTNOTES);\n-\n-        let p = Parser::new_ext(md, opts);\n+            let p = Parser::new_ext(md, opts);\n \n-        // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n-            _ => event\n-        });\n+            // Treat inline HTML as plain text.\n+            let p = p.map(|event| match event {\n+                Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+                _ => event\n+            });\n \n-        let mut s = String::with_capacity(md.len() * 3 / 2);\n+            let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+            html::push_html(&mut s,\n+                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n \n-        fmt.write_str(&s)\n+            fmt.write_str(&s)\n+        }\n     }\n }\n "}, {"sha": "57d71e6c4e004e37b7542d6eb1eecf117c72f598", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=80a2a94d5a646859239cb8acab3ecc3c508e741e", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, RenderType};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -98,6 +98,7 @@ pub struct Context {\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n     pub shared: Arc<SharedContext>,\n+    pub render_type: RenderType,\n }\n \n pub struct SharedContext {\n@@ -433,7 +434,8 @@ pub fn run(mut krate: clean::Crate,\n            dst: PathBuf,\n            passes: FxHashSet<String>,\n            css_file_extension: Option<PathBuf>,\n-           renderinfo: RenderInfo) -> Result<(), Error> {\n+           renderinfo: RenderInfo,\n+           render_type: RenderType) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n@@ -495,6 +497,7 @@ pub fn run(mut krate: clean::Crate,\n         dst: dst,\n         render_redirect_pages: false,\n         shared: Arc::new(scx),\n+        render_type: render_type,\n     };\n \n     // Crawl the crate to build various caches used for the output\n@@ -1638,11 +1641,12 @@ fn plain_summary_line(s: Option<&str>) -> String {\n \n fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n     document_stability(w, cx, item)?;\n-    document_full(w, item)?;\n+    document_full(w, item, cx.render_type)?;\n     Ok(())\n }\n \n-fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink) -> fmt::Result {\n+fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n+                  render_type: RenderType) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n             format!(\"{} [Read more]({})\",\n@@ -1651,7 +1655,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&markdown))?;\n+               Markdown(&markdown, render_type))?;\n     }\n     Ok(())\n }\n@@ -1681,10 +1685,11 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n     }\n }\n \n-fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n+fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n+                 render_type: RenderType) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s), render_type))?;\n     }\n     Ok(())\n }\n@@ -1872,7 +1877,13 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = MarkdownSummaryLine(doc_value),\n+                       docs = if cx.render_type == RenderType::Hoedown {\n+                           format!(\"{}\",\n+                                   shorter(Some(&Markdown(doc_value,\n+                                                          RenderType::Hoedown).to_string())))\n+                       } else {\n+                           format!(\"{}\", MarkdownSummaryLine(doc_value))\n+                       },\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -1915,7 +1926,9 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             } else {\n                 String::new()\n             };\n-            let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&deprecated_reason));\n+            let text = format!(\"Deprecated{}{}\",\n+                               since,\n+                               MarkdownHtml(&deprecated_reason, cx.render_type));\n             stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n         };\n \n@@ -1944,7 +1957,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                     let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n                                         This is a nightly-only experimental API. {}\\\n                                         </summary>{}\",\n-                                       unstable_extra, MarkdownHtml(&stab.unstable_reason));\n+                                       unstable_extra,\n+                                       MarkdownHtml(&stab.unstable_reason, cx.render_type));\n                     stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\",\n                                    text));\n                 }\n@@ -1964,7 +1978,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             String::new()\n         };\n \n-        let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&note));\n+        let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&note, cx.render_type));\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n \n@@ -2900,7 +2914,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, cx.render_type))?;\n         }\n     }\n \n@@ -2999,19 +3013,19 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         // because impls can't have a stability.\n                         document_stability(w, cx, it)?;\n                         if get_doc_value(item).is_some() {\n-                            document_full(w, item)?;\n+                            document_full(w, item, cx.render_type)?;\n                         } else {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, it, link)?;\n+                            document_short(w, it, link, cx.render_type)?;\n                         }\n                     }\n                 } else {\n                     document(w, cx, item)?;\n                 }\n             } else {\n                 document_stability(w, cx, item)?;\n-                document_short(w, item, link)?;\n+                document_short(w, item, link, cx.render_type)?;\n             }\n         }\n         Ok(())"}, {"sha": "2a6134fde5c3d8f8e9aaba8b30ee207590052184", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=80a2a94d5a646859239cb8acab3ecc3c508e741e", "patch": "@@ -93,6 +93,8 @@ pub mod test;\n \n use clean::AttributesExt;\n \n+use html::markdown::RenderType;\n+\n struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n@@ -169,6 +171,7 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                         \"URL to send code snippets to, may be reset by --markdown-playground-url \\\n                          or `#![doc(html_playground_url=...)]`\",\n                         \"URL\")),\n+        unstable(optflag(\"\", \"enable-commonmark\", \"to enable commonmark doc rendering/testing\")),\n     ]\n }\n \n@@ -250,6 +253,12 @@ pub fn main_args(args: &[String]) -> isize {\n     let css_file_extension = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n     let cfgs = matches.opt_strs(\"cfg\");\n \n+    let render_type = if matches.opt_present(\"enable-commonmark\") {\n+        RenderType::Pulldown\n+    } else {\n+        RenderType::Hoedown\n+    };\n+\n     if let Some(ref p) = css_file_extension {\n         if !p.is_file() {\n             writeln!(\n@@ -273,15 +282,17 @@ pub fn main_args(args: &[String]) -> isize {\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot)\n+            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type)\n         }\n         (true, false) => {\n-            return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot)\n+            return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot,\n+                             render_type)\n         }\n         (false, true) => return markdown::render(input,\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n-                                                 !matches.opt_present(\"markdown-no-toc\")),\n+                                                 !matches.opt_present(\"markdown-no-toc\"),\n+                                                 render_type),\n         (false, false) => {}\n     }\n \n@@ -295,7 +306,8 @@ pub fn main_args(args: &[String]) -> isize {\n                                   output.unwrap_or(PathBuf::from(\"doc\")),\n                                   passes.into_iter().collect(),\n                                   css_file_extension,\n-                                  renderinfo)\n+                                  renderinfo,\n+                                  render_type)\n                     .expect(\"failed to generate documentation\");\n                 0\n             }"}, {"sha": "b9ed0eeaef736715d814e34a0d04e51c10399855", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=80a2a94d5a646859239cb8acab3ecc3c508e741e", "patch": "@@ -26,6 +26,7 @@ use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n use html::markdown::{Markdown, MarkdownWithToc, find_testable_code, old_find_testable_code};\n+use html::markdown::RenderType;\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -50,7 +51,8 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool) -> isize {\n+              external_html: &ExternalHtml, include_toc: bool,\n+              render_type: RenderType) -> isize {\n     let input_p = Path::new(input);\n     output.push(input_p.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -94,9 +96,9 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     reset_ids(false);\n \n     let rendered = if include_toc {\n-        format!(\"{}\", MarkdownWithToc(text))\n+        format!(\"{}\", MarkdownWithToc(text, render_type))\n     } else {\n-        format!(\"{}\", Markdown(text))\n+        format!(\"{}\", Markdown(text, render_type))\n     };\n \n     let err = write!(\n@@ -147,7 +149,8 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n-            mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>) -> isize {\n+            mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n+            render_type: RenderType) -> isize {\n     let input_str = match load_string(input) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n@@ -158,7 +161,8 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n                                        true, opts, maybe_sysroot, None,\n-                                       Some(input.to_owned()));\n+                                       Some(input.to_owned()),\n+                                       render_type);\n     old_find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());"}, {"sha": "a30ec25de60d755b96f08e4fdbe84e5a12c581df", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2a94d5a646859239cb8acab3ecc3c508e741e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=80a2a94d5a646859239cb8acab3ecc3c508e741e", "patch": "@@ -43,7 +43,7 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use clean::Attributes;\n-use html::markdown;\n+use html::markdown::{self, RenderType};\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -57,7 +57,8 @@ pub fn run(input: &str,\n            externs: Externs,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>,\n-           maybe_sysroot: Option<PathBuf>)\n+           maybe_sysroot: Option<PathBuf>,\n+           render_type: RenderType)\n            -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n@@ -106,7 +107,8 @@ pub fn run(input: &str,\n                                        opts,\n                                        maybe_sysroot,\n                                        Some(codemap),\n-                                       None);\n+                                       None,\n+                                       render_type);\n \n     {\n         let dep_graph = DepGraph::new(false);\n@@ -396,12 +398,15 @@ pub struct Collector {\n     position: Span,\n     codemap: Option<Rc<CodeMap>>,\n     filename: Option<String>,\n+    // to be removed when hoedown will be removed as well\n+    pub render_type: RenderType,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n-               codemap: Option<Rc<CodeMap>>, filename: Option<String>) -> Collector {\n+               codemap: Option<Rc<CodeMap>>, filename: Option<String>,\n+               render_type: RenderType) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             old_tests: HashMap::new(),\n@@ -418,6 +423,7 @@ impl Collector {\n             position: DUMMY_SP,\n             codemap: codemap,\n             filename: filename,\n+            render_type: render_type,\n         }\n     }\n \n@@ -458,20 +464,22 @@ impl Collector {\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n                     line: usize, filename: String) {\n         let name = self.generate_name(line, &filename);\n-        let name_beg = self.generate_name_beginning(&filename);\n-        let mut found = false;\n-        // to be removed when hoedown is removed\n-        let test = test.trim().to_owned();\n-        if let Some(entry) = self.old_tests.get_mut(&name_beg) {\n-            found = entry.remove_item(&test).is_some();\n-        }\n-        if !found {\n-            let _ = writeln!(&mut io::stderr(),\n-                             \"WARNING: {} Code block is not currently run as a test, but will in \\\n-                              future versions of rustdoc. Please ensure this code block is a \\\n-                              runnable test, or use the `ignore` directive.\",\n-                             name);\n-            return\n+        if self.render_type == RenderType::Pulldown {\n+            let name_beg = self.generate_name_beginning(&filename);\n+            let mut found = false;\n+            // to be removed when hoedown is removed\n+            let test = test.trim().to_owned();\n+            if let Some(entry) = self.old_tests.get_mut(&name_beg) {\n+                found = entry.remove_item(&test).is_some();\n+            }\n+            if !found {\n+                let _ = writeln!(&mut io::stderr(),\n+                                 \"WARNING: {} Code block is not currently run as a test, but will in \\\n+                                  future versions of rustdoc. Please ensure this code block is a \\\n+                                  runnable test, or use the `ignore` directive.\",\n+                                 name);\n+                return\n+            }\n         }\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n@@ -587,10 +595,15 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {\n             self.collector.cnt = 0;\n-            markdown::old_find_testable_code(doc, self.collector,\n+            if self.collector.render_type == RenderType::Pulldown {\n+                markdown::old_find_testable_code(doc, self.collector,\n+                                                 attrs.span.unwrap_or(DUMMY_SP));\n+                markdown::find_testable_code(doc, self.collector,\n                                              attrs.span.unwrap_or(DUMMY_SP));\n-            markdown::find_testable_code(doc, self.collector,\n-                                         attrs.span.unwrap_or(DUMMY_SP));\n+            } else {\n+                markdown::old_find_testable_code(doc, self.collector,\n+                                                 attrs.span.unwrap_or(DUMMY_SP));\n+            }\n         }\n \n         nested(self);"}, {"sha": "f048b64d104abc82ab7e60521c05884c86506ee6", "filename": "src/test/rustdoc/check-hard-break.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name = \"foo\"]\n-\n-// ignore-tidy-end-whitespace\n-\n-// @has foo/fn.f.html\n-// @has - '<p>hard break:<br />'\n-// @has - 'after hard break</p>'\n-/// hard break:  \n-/// after hard break\n-pub fn f() {}"}, {"sha": "46542677857fc797cc0461d335502f13d25a45ad", "filename": "src/test/rustdoc/check-rule-image-footnote.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name = \"foo\"]\n-\n-// ignore-tidy-linelength\n-\n-// @has foo/fn.f.html\n-// @has - '<p>markdown test</p>'\n-// @has - '<p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p>'\n-// @has - '<hr />'\n-// @has - '<p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p>'\n-// @has - '<p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p>'\n-// @has - '<p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\" /></p>'\n-// @has - '<div class=\"footnotes\"><hr><ol><li id=\"ref1\">'\n-// @has - '<p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\">'\n-// @has - '<p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n-/// markdown test\n-///\n-/// this is a [link].\n-///\n-/// [link]: https://example.com \"this is a title\"\n-///\n-/// -----------\n-///\n-/// a footnote[^footnote].\n-///\n-/// another footnote[^footnotebis].\n-///\n-/// [^footnote]: Thing\n-///\n-///\n-/// [^footnotebis]: Another Thing\n-///\n-///\n-/// ![Rust](https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png)\n-pub fn f() {}"}]}