{"sha": "f6827839c0b3e81f07c522fc28b5a2406025acaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ODI3ODM5YzBiM2U4MWYwN2M1MjJmYzI4YjVhMjQwNjAyNWFjYWY=", "commit": {"author": {"name": "Arlie Davis", "email": "ardavis@microsoft.com", "date": "2020-11-12T19:24:10Z"}, "committer": {"name": "Arlie Davis", "email": "ardavis@microsoft.com", "date": "2020-11-25T00:12:23Z"}, "message": "Move lev_distance to rustc_ast, make non-generic\n\nrustc_ast currently has a few dependencies on rustc_lexer. Ideally, an AST\nwould not have any dependency its lexer, for minimizing unnecessarily\ndesign-time dependencies. Breaking this dependency would also have practical\nbenefits, since modifying rustc_lexer would not trigger a rebuild of rustc_ast.\n\nThis commit does not remove the rustc_ast --> rustc_lexer dependency,\nbut it does remove one of the sources of this dependency, which is the\ncode that handles fuzzy matching between symbol names for making suggestions\nin diagnostics. Since that code depends only on Symbol, it is easy to move\nit to rustc_span. It might even be best to move it to a separate crate,\nsince other tools such as Cargo use the same algorithm, and have simply\ncontain a duplicate of the code.\n\nThis changes the signature of find_best_match_for_name so that it is no\nlonger generic over its input. I checked the optimized binaries, and this\nfunction was duplicated at nearly every call site, because most call sites\nused short-lived iterator chains, generic over Map and such. But there's\nno good reason for a function like this to be generic, since all it does\nis immediately convert the generic input (the Iterator impl) to a concrete\nVec<Symbol>. This has all of the costs of generics (duplicated method bodies)\nwith no benefit.\n\nChanging find_best_match_for_name to be non-generic removed about 10KB of\ncode from the optimized binary. I know it's a drop in the bucket, but we have\nto start reducing binary size, and beginning to tame over-use of generics\nis part of that.", "tree": {"sha": "5739df0d3421a466fc0e1f236b963a5f7b2c40a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5739df0d3421a466fc0e1f236b963a5f7b2c40a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6827839c0b3e81f07c522fc28b5a2406025acaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6827839c0b3e81f07c522fc28b5a2406025acaf", "html_url": "https://github.com/rust-lang/rust/commit/f6827839c0b3e81f07c522fc28b5a2406025acaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6827839c0b3e81f07c522fc28b5a2406025acaf/comments", "author": null, "committer": null, "parents": [{"sha": "53ce1dd719442eb8a5d5d99242b1b5593cb723e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ce1dd719442eb8a5d5d99242b1b5593cb723e6", "html_url": "https://github.com/rust-lang/rust/commit/53ce1dd719442eb8a5d5d99242b1b5593cb723e6"}], "stats": {"total": 4, "additions": 2, "deletions": 2}, "files": [{"sha": "15505fd79f4a1f6ac0c338de623b478c6b0c1268", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6827839c0b3e81f07c522fc28b5a2406025acaf/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6827839c0b3e81f07c522fc28b5a2406025acaf/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=f6827839c0b3e81f07c522fc28b5a2406025acaf", "patch": "@@ -5,7 +5,7 @@ use crate::utils::{\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -427,7 +427,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n                             .map(|l| Symbol::intern(&l.name_lower()))\n                             .collect::<Vec<_>>();\n                         let sugg = find_best_match_for_name(\n-                            symbols.iter(),\n+                            &symbols,\n                             Symbol::intern(&format!(\"clippy::{}\", name_lower)),\n                             None,\n                         );"}]}