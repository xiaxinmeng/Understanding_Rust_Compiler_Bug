{"sha": "610dbcbf8e49947c17e48561a87a21d8b9ed4d23", "node_id": "C_kwDOAAsO6NoAKDYxMGRiY2JmOGU0OTk0N2MxN2U0ODU2MWE4N2EyMWQ4YjllZDRkMjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T20:19:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T20:19:42Z"}, "message": "Auto merge of #2784 - bryangarza:future-sizes-tests, r=RalfJung\n\nAdd tests for moving data across await point\n\nThis patch adds a few tests to assert the current behavior when passing data across an await point. This will help to test out an upcoming fix for the issue of arguments in async functions growing in size because of the generator upvar that is generated when we desugar the async function.\n\nSee https://github.com/rust-lang/rust/issues/62958\n\nAlso relates to https://github.com/rust-lang/rust/pull/107500\n\nFYI `@oli-obk` `@pnkfelix`", "tree": {"sha": "0dbd046cbaec35fe28e47a92ed87294be833a648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dbd046cbaec35fe28e47a92ed87294be833a648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/610dbcbf8e49947c17e48561a87a21d8b9ed4d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/610dbcbf8e49947c17e48561a87a21d8b9ed4d23", "html_url": "https://github.com/rust-lang/rust/commit/610dbcbf8e49947c17e48561a87a21d8b9ed4d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/610dbcbf8e49947c17e48561a87a21d8b9ed4d23/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c7f09b77da1f8b78b8a035682ee971439b84fa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c7f09b77da1f8b78b8a035682ee971439b84fa6", "html_url": "https://github.com/rust-lang/rust/commit/6c7f09b77da1f8b78b8a035682ee971439b84fa6"}, {"sha": "3fcbd1ccf92daa18d460731b89606edeb56fb8d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fcbd1ccf92daa18d460731b89606edeb56fb8d0", "html_url": "https://github.com/rust-lang/rust/commit/3fcbd1ccf92daa18d460731b89606edeb56fb8d0"}], "stats": {"total": 81, "additions": 81, "deletions": 0}, "files": [{"sha": "489fae66ffb2b4c53c6ba92bafc3350399f5a6a0", "filename": "src/tools/miri/tests/pass/move-data-across-await-point.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/610dbcbf8e49947c17e48561a87a21d8b9ed4d23/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmove-data-across-await-point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610dbcbf8e49947c17e48561a87a21d8b9ed4d23/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmove-data-across-await-point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmove-data-across-await-point.rs?ref=610dbcbf8e49947c17e48561a87a21d8b9ed4d23", "patch": "@@ -0,0 +1,81 @@\n+use std::future::Future;\n+use std::ptr;\n+\n+// This test:\n+// - Compares addresses of non-Copy data before and after moving it\n+// - Writes to the pointer after it has moved across the await point\n+//\n+// This is only meant to assert current behavior, not guarantee that this is\n+// how it should work in the future. In fact, upcoming changes to rustc\n+// *should* break these tests.\n+// See: https://github.com/rust-lang/rust/issues/62958\n+async fn data_moved_async() {\n+    async fn helper(mut data: Vec<u8>, raw_pointer: *mut Vec<u8>) {\n+        let raw_pointer2 = ptr::addr_of_mut!(data);\n+        // `raw_pointer` points to the original location where the Vec was stored in the caller.\n+        // `data` is where that Vec (to be precise, its ptr+capacity+len on-stack data)\n+        // got moved to. Those will usually not be the same since the Vec got moved twice\n+        // (into the function call, and then into the generator upvar).\n+        assert_ne!(raw_pointer, raw_pointer2);\n+        unsafe {\n+            // This writes into the `x` in `data_moved_async`, re-initializing it.\n+            std::ptr::write(raw_pointer, vec![3]);\n+        }\n+    }\n+    // Vec<T> is not Copy\n+    let mut x: Vec<u8> = vec![2];\n+    let raw_pointer = ptr::addr_of_mut!(x);\n+    helper(x, raw_pointer).await;\n+    unsafe {\n+        assert_eq!(*raw_pointer, vec![3]);\n+        // Drop to prevent leak.\n+        std::ptr::drop_in_place(raw_pointer);\n+    }\n+}\n+\n+// Same thing as above, but non-async.\n+fn data_moved() {\n+    fn helper(mut data: Vec<u8>, raw_pointer: *mut Vec<u8>) {\n+        let raw_pointer2 = ptr::addr_of_mut!(data);\n+        assert_ne!(raw_pointer, raw_pointer2);\n+        unsafe {\n+            std::ptr::write(raw_pointer, vec![3]);\n+        }\n+    }\n+\n+    let mut x: Vec<u8> = vec![2];\n+    let raw_pointer = ptr::addr_of_mut!(x);\n+    helper(x, raw_pointer);\n+    unsafe {\n+        assert_eq!(*raw_pointer, vec![3]);\n+        std::ptr::drop_in_place(raw_pointer);\n+    }\n+}\n+\n+fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n+    use std::sync::Arc;\n+    use std::task::{Context, Poll, Wake, Waker};\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    let waker = Waker::from(Arc::new(MyWaker));\n+    let mut context = Context::from_waker(&waker);\n+\n+    let mut pinned = Box::pin(fut);\n+    loop {\n+        match pinned.as_mut().poll(&mut context) {\n+            Poll::Pending => continue,\n+            Poll::Ready(v) => return v,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    run_fut(data_moved_async());\n+    data_moved();\n+}"}]}