{"sha": "6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "node_id": "C_kwDOAAsO6NoAKDZmODJhMDBhYTFhM2RjMjZlMmJhOTE5ZTUzOWJiYzI1MDRlYmYyMmE", "commit": {"author": {"name": "TheOddGarlic", "email": "umutinanerdogan@pm.me", "date": "2022-08-28T18:48:09Z"}, "committer": {"name": "mejrs", "email": "", "date": "2022-12-17T18:08:24Z"}, "message": "Migrate leading/trailing irrefutable let pattern diagnostics", "tree": {"sha": "06747bfbc46a45b22a191f7360335b55f844a629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06747bfbc46a45b22a191f7360335b55f844a629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "html_url": "https://github.com/rust-lang/rust/commit/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/comments", "author": {"login": "AsyaTheAbove", "id": 40492846, "node_id": "MDQ6VXNlcjQwNDkyODQ2", "avatar_url": "https://avatars.githubusercontent.com/u/40492846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AsyaTheAbove", "html_url": "https://github.com/AsyaTheAbove", "followers_url": "https://api.github.com/users/AsyaTheAbove/followers", "following_url": "https://api.github.com/users/AsyaTheAbove/following{/other_user}", "gists_url": "https://api.github.com/users/AsyaTheAbove/gists{/gist_id}", "starred_url": "https://api.github.com/users/AsyaTheAbove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AsyaTheAbove/subscriptions", "organizations_url": "https://api.github.com/users/AsyaTheAbove/orgs", "repos_url": "https://api.github.com/users/AsyaTheAbove/repos", "events_url": "https://api.github.com/users/AsyaTheAbove/events{/privacy}", "received_events_url": "https://api.github.com/users/AsyaTheAbove/received_events", "type": "User", "site_admin": false}, "committer": {}, "parents": [{"sha": "4b70784176052a7fe6e7fc205bab67c829de0bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b70784176052a7fe6e7fc205bab67c829de0bc1", "html_url": "https://github.com/rust-lang/rust/commit/4b70784176052a7fe6e7fc205bab67c829de0bc1"}], "stats": {"total": 77, "additions": 52, "deletions": 25}, "files": [{"sha": "280b82b4ea400fec98c39388716629e4eee0c554", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "patch": "@@ -207,3 +207,29 @@ mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n     .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n \n mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n+\n+mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } outside of the construct\n+\n+mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } into the body"}, {"sha": "3331e785b95f256a991f88609fa170d34ddbe5a7", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "patch": "@@ -497,3 +497,19 @@ pub struct LowerRangeBoundMustBeLessThanUpper {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build::leading_irrefutable_let_patterns)]\n+#[note]\n+#[help]\n+pub struct LeadingIrrefutableLetPatterns {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build::trailing_irrefutable_let_patterns)]\n+#[note]\n+#[help]\n+pub struct TrailingIrrefutableLetPatterns {\n+    pub count: usize,\n+}"}, {"sha": "8e1a3f10f4acb5e0528e2bd3f0cf4c5e82f9bfa8", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=6f82a00aa1a3dc26e2ba919e539bbc2504ebf22a", "patch": "@@ -339,29 +339,6 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             );\n             return true;\n         }\n-        let lint_affix = |affix: &[Option<(Span, bool)>], kind, suggestion| {\n-            let span_start = affix[0].unwrap().0;\n-            let span_end = affix.last().unwrap().unwrap().0;\n-            let span = span_start.to(span_end);\n-            let cnt = affix.len();\n-            let s = pluralize!(cnt);\n-            cx.tcx.struct_span_lint_hir(\n-                IRREFUTABLE_LET_PATTERNS,\n-                top,\n-                span,\n-                format!(\"{kind} irrefutable pattern{s} in let chain\"),\n-                |lint| {\n-                    lint.note(format!(\n-                        \"{these} pattern{s} will always match\",\n-                        these = pluralize!(\"this\", cnt),\n-                    ))\n-                    .help(format!(\n-                        \"consider moving {} {suggestion}\",\n-                        if cnt > 1 { \"them\" } else { \"it\" }\n-                    ))\n-                },\n-            );\n-        };\n         if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n             // The chain has a non-zero prefix of irrefutable `let` statements.\n \n@@ -375,13 +352,21 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             if !matches!(let_source, LetSource::WhileLet | LetSource::IfLetGuard) {\n                 // Emit the lint\n                 let prefix = &chain_refutabilities[..until];\n-                lint_affix(prefix, \"leading\", \"outside of the construct\");\n+                let span_start = prefix[0].unwrap().0;\n+                let span_end = prefix.last().unwrap().unwrap().0;\n+                let span = span_start.to(span_end);\n+                let count = prefix.len();\n+                cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, LeadingIrrefutableLetPatterns { count });\n             }\n         }\n         if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n             // The chain has a non-empty suffix of irrefutable `let` statements\n             let suffix = &chain_refutabilities[from + 1..];\n-            lint_affix(suffix, \"trailing\", \"into the body\");\n+            let span_start = suffix[0].unwrap().0;\n+            let span_end = suffix.last().unwrap().unwrap().0;\n+            let span = span_start.to(span_end);\n+            let count = suffix.len();\n+            cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, TrailingIrrefutableLetPatterns { count });\n         }\n         true\n     }"}]}