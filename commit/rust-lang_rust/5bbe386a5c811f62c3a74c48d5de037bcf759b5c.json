{"sha": "5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYmUzODZhNWM4MTFmNjJjM2E3NGM0OGQ1ZGUwMzdiY2Y3NTliNWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-11T13:34:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-11T13:34:03Z"}, "message": "Rollup merge of #24242 - nikomatsakis:escaping-closure-error-message, r=brson\n\n Example showing sample inputs, old message, new message:\n\nhttps://gist.github.com/nikomatsakis/11126784ac678b7eb6ba\n\nAlso adds infrastructure for reporting suggestions \\\"in situ\\\" and does some (minor) cleanups to `CodeMap`.\n\nr? @brson", "tree": {"sha": "5be407fef10c6d2ff7a7d9c1d79a6fb4aa9abbac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5be407fef10c6d2ff7a7d9c1d79a6fb4aa9abbac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "html_url": "https://github.com/rust-lang/rust/commit/5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3c9331c25986bf5b732e32fbe2008e7c66e7f56", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c9331c25986bf5b732e32fbe2008e7c66e7f56", "html_url": "https://github.com/rust-lang/rust/commit/b3c9331c25986bf5b732e32fbe2008e7c66e7f56"}, {"sha": "e313b3334b82676bbdcf90cd48f08b87fc0d03da", "url": "https://api.github.com/repos/rust-lang/rust/commits/e313b3334b82676bbdcf90cd48f08b87fc0d03da", "html_url": "https://github.com/rust-lang/rust/commit/e313b3334b82676bbdcf90cd48f08b87fc0d03da"}], "stats": {"total": 454, "additions": 370, "deletions": 84}, "files": [{"sha": "88faf1cb68ae4db505359543eff52f5c592f25d1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -143,6 +143,13 @@ impl Session {\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_end_note(sp, msg)\n     }\n+\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.diagnostic().span_suggestion(sp, msg, suggestion)\n+    }\n     pub fn span_help(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_help(sp, msg)\n     }"}, {"sha": "db947a27472ada5eb768cdf9ac7f1e6cb7e2448d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -522,6 +522,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {\n+        // Catch and handle some particular cases.\n+        match (&err.code, &err.cause) {\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic), &euv::ClosureCapture(span)) |\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)), &euv::ClosureCapture(span)) => {\n+                return self.report_out_of_scope_escaping_closure_capture(&err, span);\n+            }\n+            _ => { }\n+        }\n+\n+        // General fallback.\n         self.span_err(\n             err.span,\n             &self.bckerr_to_string(&err));\n@@ -796,16 +806,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n-                let descr = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n-                    }\n-                    None => self.cmt_to_string(&*err.cmt),\n-                };\n-\n+                let descr = self.cmt_to_path_or_string(&err.cmt);\n                 format!(\"lifetime of {} is too short to guarantee \\\n-                                its contents can be safely reborrowed\",\n-                               descr)\n+                         its contents can be safely reborrowed\",\n+                        descr)\n             }\n         }\n     }\n@@ -888,6 +892,39 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn report_out_of_scope_escaping_closure_capture(&self,\n+                                                    err: &BckError<'tcx>,\n+                                                    capture_span: Span)\n+    {\n+        let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n+\n+        span_err!(\n+            self.tcx.sess, err.span, E0373,\n+            \"closure may outlive the current function, \\\n+             but it borrows {}, \\\n+             which is owned by the current function\",\n+            cmt_path_or_string);\n+\n+        self.tcx.sess.span_note(\n+            capture_span,\n+            &format!(\"{} is borrowed here\",\n+                     cmt_path_or_string));\n+\n+        let suggestion =\n+            match self.tcx.sess.codemap().span_to_snippet(err.span) {\n+                Ok(string) => format!(\"move {}\", string),\n+                Err(_) => format!(\"move |<args>| <body>\")\n+            };\n+\n+        self.tcx.sess.span_suggestion(\n+            err.span,\n+            &format!(\"to force the closure to take ownership of {} \\\n+                      (and any other referenced variables), \\\n+                      use the `move` keyword, as shown:\",\n+                     cmt_path_or_string),\n+            suggestion);\n+    }\n+\n     pub fn note_and_explain_bckerr(&self, err: BckError<'tcx>) {\n         let code = err.code;\n         match code {\n@@ -1035,6 +1072,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         cmt.descriptive_string(self.tcx)\n     }\n+\n+    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt<'tcx>) -> String {\n+        match opt_loan_path(cmt) {\n+            Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n+            None => self.cmt_to_string(cmt),\n+        }\n+    }\n }\n \n fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {"}, {"sha": "981b28593f9a4d20bba49937fda8b822b6e2bbc2", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_diagnostics! {\n+    E0373 // closure may outlive current fn, but it borrows {}, which is owned by current fn\n+}\n+\n+__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "647ea3555ba913984c8ed71be606c13e41851c86", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -40,6 +40,10 @@ pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n pub use borrowck::FnPartsWithCFG;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod borrowck;\n \n pub mod graphviz;"}, {"sha": "7635c8eadc26efab0fb7fce588aa10d33c04daba", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 92, "deletions": 13, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -49,7 +49,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[derive(Copy, Clone, PartialEq, Hash, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -305,9 +305,21 @@ impl ExpnId {\n \n pub type FileName = String;\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineInfo {\n+    /// Index of line, starting from 0.\n+    pub line_index: usize,\n+\n+    /// Column in line where span begins, starting from 0.\n+    pub start_col: CharPos,\n+\n+    /// Column in line where span ends, starting from 0, exclusive.\n+    pub end_col: CharPos,\n+}\n+\n pub struct FileLines {\n     pub file: Rc<FileMap>,\n-    pub lines: Vec<usize>\n+    pub lines: Vec<LineInfo>\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n@@ -479,9 +491,9 @@ impl FileMap {\n         lines.push(pos);\n     }\n \n-    /// get a line from the list of pre-computed line-beginnings\n-    ///\n-    pub fn get_line(&self, line_number: usize) -> Option<String> {\n+    /// get a line from the list of pre-computed line-beginnings.\n+    /// line-number here is 0-based.\n+    pub fn get_line(&self, line_number: usize) -> Option<&str> {\n         match self.src {\n             Some(ref src) => {\n                 let lines = self.lines.borrow();\n@@ -492,7 +504,7 @@ impl FileMap {\n                     match slice.find('\\n') {\n                         Some(e) => &slice[..e],\n                         None => slice\n-                    }.to_string()\n+                    }\n                 })\n             }\n             None => None\n@@ -661,10 +673,29 @@ impl CodeMap {\n     pub fn span_to_lines(&self, sp: Span) -> FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n-        let mut lines = Vec::new();\n-        for i in lo.line - 1..hi.line {\n-            lines.push(i);\n-        };\n+        let mut lines = Vec::with_capacity(hi.line - lo.line + 1);\n+\n+        // The span starts partway through the first line,\n+        // but after that it starts from offset 0.\n+        let mut start_col = lo.col;\n+\n+        // For every line but the last, it extends from `start_col`\n+        // and to the end of the line. Be careful because the line\n+        // numbers in Loc are 1-based, so we subtract 1 to get 0-based\n+        // lines.\n+        for line_index in lo.line-1 .. hi.line-1 {\n+            let line_len = lo.file.get_line(line_index).map(|s| s.len()).unwrap_or(0);\n+            lines.push(LineInfo { line_index: line_index,\n+                                  start_col: start_col,\n+                                  end_col: CharPos::from_usize(line_len) });\n+            start_col = CharPos::from_usize(0);\n+        }\n+\n+        // For the last line, it extends from `start_col` to `hi.col`:\n+        lines.push(LineInfo { line_index: hi.line - 1,\n+                              start_col: start_col,\n+                              end_col: hi.col });\n+\n         FileLines {file: lo.file, lines: lines}\n     }\n \n@@ -919,17 +950,18 @@ pub struct MalformedCodemapPositions {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n-        assert_eq!(fm.get_line(0), Some(\"first line.\".to_string()));\n+        assert_eq!(fm.get_line(0), Some(\"first line.\"));\n         // TESTING BROKEN BEHAVIOR:\n         fm.next_line(BytePos(10));\n-        assert_eq!(fm.get_line(1), Some(\".\".to_string()));\n+        assert_eq!(fm.get_line(1), Some(\".\"));\n     }\n \n     #[test]\n@@ -1057,7 +1089,54 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1);\n+        assert_eq!(file_lines.lines[0].line_index, 1);\n+    }\n+\n+    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n+    /// coverting that range. The idea is that the string has the same\n+    /// length as the input, and we uncover the byte positions.  Note\n+    /// that this can span lines and so on.\n+    fn span_from_selection(input: &str, selection: &str) -> Span {\n+        assert_eq!(input.len(), selection.len());\n+        let left_index = selection.find('^').unwrap() as u32;\n+        let right_index = selection.rfind('~').unwrap() as u32;\n+        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n+    }\n+\n+    fn new_filemap_and_lines(cm: &CodeMap, filename: &str, input: &str) -> Rc<FileMap> {\n+        let fm = cm.new_filemap(filename.to_string(), input.to_string());\n+        let mut byte_pos: u32 = 0;\n+        for line in input.lines() {\n+            // register the start of this line\n+            fm.next_line(BytePos(byte_pos));\n+\n+            // update byte_pos to include this line and the \\n at the end\n+            byte_pos += line.len() as u32 + 1;\n+        }\n+        fm\n+    }\n+\n+    /// Test span_to_snippet and span_to_lines for a span coverting 3\n+    /// lines in the middle of a file.\n+    #[test]\n+    fn span_to_snippet_and_lines_spanning_multiple_lines() {\n+        let cm = CodeMap::new();\n+        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        new_filemap_and_lines(&cm, \"blork.rs\", inputtext);\n+        let span = span_from_selection(inputtext, selection);\n+\n+        // check that we are extracting the text we thought we were extracting\n+        assert_eq!(&cm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+        // check that span_to_lines gives us the complete result with the lines/cols we expected\n+        let lines = cm.span_to_lines(span);\n+        let expected = vec![\n+            LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n+            LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },\n+            LineInfo { line_index: 3, start_col: CharPos(0), end_col: CharPos(5) }\n+            ];\n+        assert_eq!(lines.lines, expected);\n     }\n \n     #[test]"}, {"sha": "ed7bdcd898e9357ebcfa60cd65d187623ba3aa0d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 143, "deletions": 58, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -18,6 +18,7 @@ use codemap;\n use diagnostics;\n \n use std::cell::{RefCell, Cell};\n+use std::cmp;\n use std::fmt;\n use std::io::prelude::*;\n use std::io;\n@@ -28,28 +29,39 @@ use libc;\n /// maximum number of lines we will print for each error; arbitrary.\n const MAX_LINES: usize = 6;\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n pub enum RenderSpan {\n     /// A FullSpan renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary of\n     /// the source code covered by the span.\n     FullSpan(Span),\n \n+    /// Similar to a FullSpan, but the cited position is the end of\n+    /// the span, instead of the start. Used, at least, for telling\n+    /// compiletest/runtest to look at the last line of the span\n+    /// (since `end_highlight_lines` displays an arrow to the end\n+    /// of the span).\n+    EndSpan(Span),\n+\n+    /// A suggestion renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary\n+    /// of hypothetical source code, where the `String` is spliced\n+    /// into the lines in place of the code covered by the span.\n+    Suggestion(Span, String),\n+\n     /// A FileLine renders with just a line for the message prefixed\n     /// by file:linenum.\n     FileLine(Span),\n }\n \n impl RenderSpan {\n-    fn span(self) -> Span {\n-        match self {\n-            FullSpan(s) | FileLine(s) => s\n-        }\n-    }\n-    fn is_full_span(&self) -> bool {\n-        match self {\n-            &FullSpan(..) => true,\n-            &FileLine(..) => false,\n+    fn span(&self) -> Span {\n+        match *self {\n+            FullSpan(s) |\n+            Suggestion(s, _) |\n+            EndSpan(s) |\n+            FileLine(s) =>\n+                s\n         }\n     }\n }\n@@ -115,11 +127,17 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FullSpan(sp), msg, Note);\n+        self.handler.custom_emit(&self.cm, EndSpan(sp), msg, Note);\n     }\n     pub fn span_help(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Help);\n     }\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.handler.custom_emit(&self.cm, Suggestion(sp, suggestion), msg, Help);\n+    }\n     pub fn fileline_note(&self, sp: Span, msg: &str) {\n         self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n     }\n@@ -407,8 +425,8 @@ impl Emitter for EmitterWriter {\n         let error = match cmsp {\n             Some((cm, COMMAND_LINE_SP)) => emit(self, cm,\n                                                 FileLine(COMMAND_LINE_SP),\n-                                                msg, code, lvl, false),\n-            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl, false),\n+                                                msg, code, lvl),\n+            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl),\n             None => print_diagnostic(self, \"\", lvl, msg, code),\n         };\n \n@@ -420,43 +438,49 @@ impl Emitter for EmitterWriter {\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n-        match emit(self, cm, sp, msg, None, lvl, true) {\n+        match emit(self, cm, sp, msg, None, lvl) {\n             Ok(()) => {}\n             Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::Result<()> {\n+        msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n     let sp = rsp.span();\n \n     // We cannot check equality directly with COMMAND_LINE_SP\n     // since PartialEq is manually implemented to ignore the ExpnId\n     let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n         \"<command line option>\".to_string()\n+    } else if let EndSpan(_) = rsp {\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+        cm.span_to_string(span_end)\n     } else {\n         cm.span_to_string(sp)\n     };\n-    if custom {\n-        // we want to tell compiletest/runtest to look at the last line of the\n-        // span (since `custom_highlight_lines` displays an arrow to the end of\n-        // the span)\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-        let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, &ses[..], lvl, msg, code));\n-        if rsp.is_full_span() {\n-            try!(custom_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-        }\n-    } else {\n-        try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n-        if rsp.is_full_span() {\n+\n+    try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n+\n+    match rsp {\n+        FullSpan(_) => {\n             try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n+        EndSpan(_) => {\n+            try!(end_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n+        }\n+        Suggestion(_, ref suggestion) => {\n+            try!(highlight_suggestion(dst, cm, sp, suggestion));\n+        }\n+        FileLine(..) => {\n+            // no source text in this case!\n+        }\n     }\n+\n     if sp != COMMAND_LINE_SP {\n         try!(print_macro_backtrace(dst, cm, sp));\n     }\n+\n     match code {\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n@@ -472,29 +496,90 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n     Ok(())\n }\n \n+fn highlight_suggestion(err: &mut EmitterWriter,\n+                        cm: &codemap::CodeMap,\n+                        sp: Span,\n+                        suggestion: &str)\n+                        -> io::Result<()>\n+{\n+    let lines = cm.span_to_lines(sp);\n+    assert!(!lines.lines.is_empty());\n+\n+    // To build up the result, we want to take the snippet from the first\n+    // line that precedes the span, prepend that with the suggestion, and\n+    // then append the snippet from the last line that trails the span.\n+    let fm = &lines.file;\n+\n+    let first_line = &lines.lines[0];\n+    let prefix = fm.get_line(first_line.line_index)\n+                   .map(|l| &l[..first_line.start_col.0])\n+                   .unwrap_or(\"\");\n+\n+    let last_line = lines.lines.last().unwrap();\n+    let suffix = fm.get_line(last_line.line_index)\n+                   .map(|l| &l[last_line.end_col.0..])\n+                   .unwrap_or(\"\");\n+\n+    let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n+\n+    // print the suggestion without any line numbers, but leave\n+    // space for them. This helps with lining up with previous\n+    // snippets from the actual error being reported.\n+    let fm = &*lines.file;\n+    let mut lines = complete.lines();\n+    for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n+        let elided_line_num = format!(\"{}\", line_index+1);\n+        try!(write!(&mut err.dst, \"{0}:{1:2$} {3}\\n\",\n+                    fm.name, \"\", elided_line_num.len(), line));\n+    }\n+\n+    // if we elided some lines, add an ellipsis\n+    if lines.next().is_some() {\n+        let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n+        try!(write!(&mut err.dst, \"{0:1$} {0:2$} ...\\n\",\n+                    \"\", fm.name.len(), elided_line_num.len()));\n+    }\n+\n+    Ok(())\n+}\n+\n fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines) -> io::Result<()> {\n+                   lines: codemap::FileLines)\n+                   -> io::Result<()>\n+{\n     let fm = &*lines.file;\n \n-    let mut elided = false;\n-    let mut display_lines = &lines.lines[..];\n-    if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0..MAX_LINES];\n-        elided = true;\n-    }\n+    let line_strings: Option<Vec<&str>> =\n+        lines.lines.iter()\n+                   .map(|info| fm.get_line(info.line_index))\n+                   .collect();\n+\n+    let line_strings = match line_strings {\n+        None => { return Ok(()); }\n+        Some(line_strings) => line_strings\n+    };\n+\n+    // Display only the first MAX_LINES lines.\n+    let all_lines = lines.lines.len();\n+    let display_lines = cmp::min(all_lines, MAX_LINES);\n+    let display_line_infos = &lines.lines[..display_lines];\n+    let display_line_strings = &line_strings[..display_lines];\n+\n     // Print the offending lines\n-    for &line_number in display_lines {\n-        if let Some(line) = fm.get_line(line_number) {\n-            try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name,\n-                        line_number + 1, line));\n-        }\n+    for (line_info, line) in display_line_infos.iter().zip(display_line_strings.iter()) {\n+        try!(write!(&mut err.dst, \"{}:{} {}\\n\",\n+                    fm.name,\n+                    line_info.line_index + 1,\n+                    line));\n     }\n-    if elided {\n-        let last_line = display_lines[display_lines.len() - 1];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1);\n+\n+    // If we elided something, put an ellipsis.\n+    if display_lines < all_lines {\n+        let last_line_index = display_line_infos.last().unwrap().line_index;\n+        let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n@@ -503,7 +588,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     if lines.lines.len() == 1 {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0;\n-        let mut num = (lines.lines[0] + 1) / 10;\n+        let mut num = (lines.lines[0].line_index + 1) / 10;\n \n         // how many digits must be indent past?\n         while num > 0 { num /= 10; digits += 1; }\n@@ -515,7 +600,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         for _ in 0..skip {\n             s.push(' ');\n         }\n-        if let Some(orig) = fm.get_line(lines.lines[0]) {\n+        if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n             let mut col = skip;\n             let mut lastc = ' ';\n             let mut iter = orig.chars().enumerate();\n@@ -575,12 +660,12 @@ fn highlight_lines(err: &mut EmitterWriter,\n }\n \n /// Here are the differences between this and the normal `highlight_lines`:\n-/// `custom_highlight_lines` will always put arrow on the last byte of the\n+/// `end_highlight_lines` will always put arrow on the last byte of the\n /// span (instead of the first byte). Also, when the span is too long (more\n-/// than 6 lines), `custom_highlight_lines` will print the first line, then\n+/// than 6 lines), `end_highlight_lines` will print the first line, then\n /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n /// six lines.\n-fn custom_highlight_lines(w: &mut EmitterWriter,\n+fn end_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n@@ -590,32 +675,32 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n \n     let lines = &lines.lines[..];\n     if lines.len() > MAX_LINES {\n-        if let Some(line) = fm.get_line(lines[0]) {\n+        if let Some(line) = fm.get_line(lines[0].line_index) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        lines[0] + 1, line));\n+                        lines[0].line_index + 1, line));\n         }\n         try!(write!(&mut w.dst, \"...\\n\"));\n-        let last_line_number = lines[lines.len() - 1];\n-        if let Some(last_line) = fm.get_line(last_line_number) {\n+        let last_line_index = lines[lines.len() - 1].line_index;\n+        if let Some(last_line) = fm.get_line(last_line_index) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        last_line_number + 1, last_line));\n+                        last_line_index + 1, last_line));\n         }\n     } else {\n-        for &line_number in lines {\n-            if let Some(line) = fm.get_line(line_number) {\n+        for line_info in lines {\n+            if let Some(line) = fm.get_line(line_info.line_index) {\n                 try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                            line_number + 1, line));\n+                            line_info.line_index + 1, line));\n             }\n         }\n     }\n-    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n+    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n     let hi = cm.lookup_char_pos(sp.hi);\n     let skip = last_line_start.width(false);\n     let mut s = String::new();\n     for _ in 0..skip {\n         s.push(' ');\n     }\n-    if let Some(orig) = fm.get_line(lines[0]) {\n+    if let Some(orig) = fm.get_line(lines[0].line_index) {\n         let iter = orig.chars().enumerate();\n         for (pos, ch) in iter {\n             // Span seems to use half-opened interval, so subtract 1"}, {"sha": "87e40df7663baacabd7c522321104fc0e7c82a61", "filename": "src/test/compile-fail/borrowck-escaping-closure-error-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-1.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::thread::spawn;\n+\n+// Test that we give a custom error (E0373) for the case where a\n+// closure is escaping current frame, and offer a suggested code edit.\n+// I refrained from including the precise message here, but the\n+// original text as of the time of this writing is:\n+//\n+//    closure may outlive the current function, but it borrows `books`,\n+//    which is owned by the current function\n+\n+fn main() {\n+    let mut books = vec![1,2,3];\n+    spawn(|| books.push(4));\n+    //~^ ERROR E0373\n+}"}, {"sha": "67700be890b1faa8a9c9090fdb0ea8382ddfd854", "filename": "src/test/compile-fail/borrowck-escaping-closure-error-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-escaping-closure-error-2.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give a custom error (E0373) for the case where a\n+// closure is escaping current frame, and offer a suggested code edit.\n+// I refrained from including the precise message here, but the\n+// original text as of the time of this writing is:\n+//\n+//    closure may outlive the current function, but it borrows `books`,\n+//    which is owned by the current function\n+\n+fn foo<'a>(x: &'a i32) -> Box<FnMut()+'a> {\n+    let mut books = vec![1,2,3];\n+    Box::new(|| books.push(4))\n+    //~^ ERROR E0373\n+}\n+\n+fn main() { }"}, {"sha": "b4abef0bd280b914aa20d155a0ac18f07740f432", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -18,10 +18,10 @@ trait Collection { fn len(&self) -> usize; }\n \n struct List<'a, T: ListItem<'a>> {\n //~^ ERROR the parameter type `T` may not live long enough\n-//~^^ NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at\n+//~| HELP consider adding an explicit lifetime bound\n+//~| NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at\n     slice: &'a [T]\n }\n-//~^ HELP consider adding an explicit lifetime bound\n impl<'a, T: ListItem<'a>> Collection for List<'a, T> {\n     fn len(&self) -> usize {\n         0"}, {"sha": "0089bff3e8fd89c56d0870bd3edc8648e285068b", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -15,7 +15,7 @@ fn id<T>(t: T) -> T { t }\n fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     id(Box::new(|| *v))\n-        //~^ ERROR `v` does not live long enough\n+        //~^ ERROR E0373\n         //~| ERROR cannot move out of borrowed content\n }\n "}, {"sha": "948dc8cd219689301a9b30ba2702422a39294451", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bbe386a5c811f62c3a74c48d5de037bcf759b5c/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=5bbe386a5c811f62c3a74c48d5de037bcf759b5c", "patch": "@@ -13,7 +13,7 @@ fn ignore<F>(_f: F) where F: for<'z> FnOnce(&'z isize) -> &'z isize {}\n fn nested() {\n     let y = 3;\n     ignore(\n-        |z| { //~ ERROR `y` does not live long enough\n+        |z| { //~ ERROR E0373\n             if false { &y } else { z }\n         });\n }"}]}