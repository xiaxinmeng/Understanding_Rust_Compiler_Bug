{"sha": "078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3OGMwZTI2YzNmZjRkOTY1MmJjYjQ4NDViNWY0NjY1YzJlMDk4OWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-23T09:23:36Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-23T09:23:36Z"}, "message": "Merge #1313\n\n1313: Update `gen_lsp_server` examples r=matklad a=dmoonfire\n\n- updated the documentation with an example that has no errors with current compiler\r\n- added two example code to test compilation and show in use\r\n  - one example is the bare bones version in documentation\r\n  - the other example is the same but with logging statements to show flow\n\nCo-authored-by: Dylan Moonfire <dylan.moonfire@ryan.com>", "tree": {"sha": "24719bb7205e95c1b2130238c6927dbfaa8db3e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24719bb7205e95c1b2130238c6927dbfaa8db3e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "html_url": "https://github.com/rust-lang/rust/commit/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a25e103e4542637047fe388a926aebddca07b3b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25e103e4542637047fe388a926aebddca07b3b7", "html_url": "https://github.com/rust-lang/rust/commit/a25e103e4542637047fe388a926aebddca07b3b7"}, {"sha": "cbd131acbe497795028844a592a438b70a30ba32", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd131acbe497795028844a592a438b70a30ba32", "html_url": "https://github.com/rust-lang/rust/commit/cbd131acbe497795028844a592a438b70a30ba32"}], "stats": {"total": 179, "additions": 170, "deletions": 9}, "files": [{"sha": "fa2fefea55a83537e79fbc09efbe99c9d8e8fb01", "filename": "crates/gen_lsp_server/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2FCargo.toml?ref=078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "patch": "@@ -14,3 +14,6 @@ failure = \"0.1.4\"\n serde_json = \"1.0.34\"\n serde = { version = \"1.0.83\", features = [\"derive\"] }\n crossbeam-channel = \"0.3.5\"\n+\n+[dev-dependencies]\n+flexi_logger = \"0.11.0\""}, {"sha": "60c581075f72cc17e4491166194a3e4899712655", "filename": "crates/gen_lsp_server/examples/01_gen_lsp_server.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2Fexamples%2F01_gen_lsp_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2Fexamples%2F01_gen_lsp_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fexamples%2F01_gen_lsp_server.rs?ref=078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "patch": "@@ -0,0 +1,45 @@\n+use crossbeam_channel::{Sender, Receiver};\r\n+use lsp_types::{\r\n+    ServerCapabilities, InitializeParams,\r\n+    request::{GotoDefinition, GotoDefinitionResponse},\r\n+};\r\n+use gen_lsp_server::{run_server, stdio_transport, handle_shutdown, RawMessage, RawResponse};\r\n+\r\n+fn main() -> Result<(), failure::Error> {\r\n+    let (receiver, sender, io_threads) = stdio_transport();\r\n+    run_server(ServerCapabilities::default(), receiver, sender, main_loop)?;\r\n+    io_threads.join()?;\r\n+    Ok(())\r\n+}\r\n+\r\n+fn main_loop(\r\n+    _params: InitializeParams,\r\n+    receiver: &Receiver<RawMessage>,\r\n+    sender: &Sender<RawMessage>,\r\n+) -> Result<(), failure::Error> {\r\n+    for msg in receiver {\r\n+        match msg {\r\n+            RawMessage::Request(req) => {\r\n+                let req = match handle_shutdown(req, sender) {\r\n+                    None => return Ok(()),\r\n+                    Some(req) => req,\r\n+                };\r\n+                match req.cast::<GotoDefinition>() {\r\n+                    Ok((id, _params)) => {\r\n+                        let resp = RawResponse::ok::<GotoDefinition>(\r\n+                            id,\r\n+                            &Some(GotoDefinitionResponse::Array(Vec::new())),\r\n+                        );\r\n+                        sender.send(RawMessage::Response(resp))?;\r\n+                        continue;\r\n+                    }\r\n+                    Err(req) => req,\r\n+                };\r\n+                // ...\r\n+            }\r\n+            RawMessage::Response(_resp) => (),\r\n+            RawMessage::Notification(_not) => (),\r\n+        }\r\n+    }\r\n+    Ok(())\r\n+}\r"}, {"sha": "27e4f1cbc667dd698fc5f362ca677aa75dbcae99", "filename": "crates/gen_lsp_server/examples/02_gen_lsp_server_with_logging.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2Fexamples%2F02_gen_lsp_server_with_logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2Fexamples%2F02_gen_lsp_server_with_logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fexamples%2F02_gen_lsp_server_with_logging.rs?ref=078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "patch": "@@ -0,0 +1,118 @@\n+//! A minimal example LSP server that can only respond to the `gotoDefinition` request. To use\r\n+//! this example, execute it and then send an `initialize` request.\r\n+//!\r\n+//! ```no_run\r\n+//! Content-Length: 85\r\n+//!\r\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1, \"params\": {\"capabilities\": {}}}\r\n+//! ```\r\n+//!\r\n+//! This will respond with a server respose. Then send it a `initialized` notification which will\r\n+//! have no response.\r\n+//!\r\n+//! ```no_run\r\n+//! Content-Length: 59\r\n+//!\r\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"initialized\", \"params\": {}}\r\n+//! ```\r\n+//!\r\n+//! Once these two are sent, then we enter the main loop of the server. The only request this\r\n+//! example can handle is `gotoDefinition`:\r\n+//!\r\n+//! ```no_run\r\n+//! Content-Length: 159\r\n+//!\r\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"textDocument/definition\", \"id\": 2, \"params\": {\"textDocument\": {\"uri\": \"file://temp\"}, \"position\": {\"line\": 1, \"character\": 1}}}\r\n+//! ```\r\n+//!\r\n+//! To finish up without errors, send a shutdown request:\r\n+//!\r\n+//! ```no_run\r\n+//! Content-Length: 67\r\n+//!\r\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"shutdown\", \"id\": 3, \"params\": null}\r\n+//! ```\r\n+//!\r\n+//! The server will exit the main loop and finally we send a `shutdown` notification to stop\r\n+//! the server.\r\n+//!\r\n+//! ```\r\n+//! Content-Length: 54\r\n+//!\r\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"exit\", \"params\": null}\r\n+//! ```\r\n+\r\n+use crossbeam_channel::{Sender, Receiver};\r\n+use lsp_types::{\r\n+    ServerCapabilities, InitializeParams,\r\n+    request::{GotoDefinition, GotoDefinitionResponse},\r\n+};\r\n+use log::info;\r\n+use gen_lsp_server::{\r\n+    run_server, stdio_transport, handle_shutdown, RawMessage, RawResponse, RawRequest,\r\n+};\r\n+\r\n+fn main() -> Result<(), failure::Error> {\r\n+    // Set up logging. Because `stdio_transport` gets a lock on stdout and stdin, we must have\r\n+    // our logging only write out to stderr.\r\n+    flexi_logger::Logger::with_str(\"info\").start().unwrap();\r\n+    info!(\"starting generic LSP server\");\r\n+\r\n+    // Create the transport. Includes the stdio (stdin and stdout) versions but this could\r\n+    // also be implemented to use sockets or HTTP.\r\n+    let (receiver, sender, io_threads) = stdio_transport();\r\n+\r\n+    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).\r\n+    run_server(ServerCapabilities::default(), receiver, sender, main_loop)?;\r\n+    io_threads.join()?;\r\n+\r\n+    // Shut down gracefully.\r\n+    info!(\"shutting down server\");\r\n+    Ok(())\r\n+}\r\n+\r\n+fn main_loop(\r\n+    _params: InitializeParams,\r\n+    receiver: &Receiver<RawMessage>,\r\n+    sender: &Sender<RawMessage>,\r\n+) -> Result<(), failure::Error> {\r\n+    info!(\"starting example main loop\");\r\n+    for msg in receiver {\r\n+        info!(\"got msg: {:?}\", msg);\r\n+        match msg {\r\n+            RawMessage::Request(req) => {\r\n+                let req = match log_handle_shutdown(req, sender) {\r\n+                    None => return Ok(()),\r\n+                    Some(req) => req,\r\n+                };\r\n+                info!(\"got request: {:?}\", req);\r\n+                match req.cast::<GotoDefinition>() {\r\n+                    Ok((id, params)) => {\r\n+                        info!(\"got gotoDefinition request #{}: {:?}\", id, params);\r\n+                        let resp = RawResponse::ok::<GotoDefinition>(\r\n+                            id,\r\n+                            &Some(GotoDefinitionResponse::Array(Vec::new())),\r\n+                        );\r\n+                        info!(\"sending gotoDefinition response: {:?}\", resp);\r\n+                        sender.send(RawMessage::Response(resp))?;\r\n+                        continue;\r\n+                    }\r\n+                    Err(req) => req,\r\n+                };\r\n+                // ...\r\n+            }\r\n+            RawMessage::Response(resp) => {\r\n+                info!(\"got response: {:?}\", resp);\r\n+            }\r\n+            RawMessage::Notification(not) => {\r\n+                info!(\"got notification: {:?}\", not);\r\n+            }\r\n+        }\r\n+    }\r\n+    Ok(())\r\n+}\r\n+\r\n+pub fn log_handle_shutdown(req: RawRequest, sender: &Sender<RawMessage>) -> Option<RawRequest> {\r\n+    info!(\"handle_shutdown: {:?}\", req);\r\n+    handle_shutdown(req, sender)\r\n+}\r"}, {"sha": "1cd5a3a7c72ba6b05f40c96b307b5e0db428414a", "filename": "crates/gen_lsp_server/src/lib.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078c0e26c3ff4d9652bcb4845b5f4665c2e0989d/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs?ref=078c0e26c3ff4d9652bcb4845b5f4665c2e0989d", "patch": "@@ -2,21 +2,16 @@\n //! This crate handles protocol handshaking and parsing messages, while you\n //! control the message dispatch loop yourself.\n //!\n-//! Run with `RUST_LOG=sync_lsp_server=debug` to see all the messages.\n+//! Run with `RUST_LOG=gen_lsp_server=debug` to see all the messages.\n //!\n //! ```no_run\n-//! extern crate gen_lsp_server;\n-//! extern crate lsp_types;\n-//! extern crate failure;\n-//! extern crate crossbeam_channel;\n-//!\n //! use crossbeam_channel::{Sender, Receiver};\n //! use lsp_types::{ServerCapabilities, InitializeParams, request::{GotoDefinition, GotoDefinitionResponse}};\n //! use gen_lsp_server::{run_server, stdio_transport, handle_shutdown, RawMessage, RawResponse};\n //!\n //! fn main() -> Result<(), failure::Error> {\n //!     let (receiver, sender, io_threads) = stdio_transport();\n-//!     gen_lsp_server::run_server(\n+//!     run_server(\n //!         ServerCapabilities::default(),\n //!         receiver,\n //!         sender,\n@@ -38,13 +33,13 @@\n //!                     None => return Ok(()),\n //!                     Some(req) => req,\n //!                 };\n-//!                 let req = match req.cast::<GotoDefinition>() {\n+//!                 match req.cast::<GotoDefinition>() {\n //!                     Ok((id, _params)) => {\n //!                         let resp = RawResponse::ok::<GotoDefinition>(\n //!                             id,\n //!                             &Some(GotoDefinitionResponse::Array(Vec::new())),\n //!                         );\n-//!                         sender.send(RawMessage::Response(resp));\n+//!                         sender.send(RawMessage::Response(resp))?;\n //!                         continue;\n //!                     },\n //!                     Err(req) => req,"}]}