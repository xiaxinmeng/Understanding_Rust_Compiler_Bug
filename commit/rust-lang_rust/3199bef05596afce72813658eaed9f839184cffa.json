{"sha": "3199bef05596afce72813658eaed9f839184cffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOTliZWYwNTU5NmFmY2U3MjgxMzY1OGVhZWQ5ZjgzOTE4NGNmZmE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-11T00:05:35Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-15T19:11:42Z"}, "message": "Fixed issue #56199.", "tree": {"sha": "35e10aa1e11e02047e4497286532a1f7f7b4f5e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35e10aa1e11e02047e4497286532a1f7f7b4f5e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3199bef05596afce72813658eaed9f839184cffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3199bef05596afce72813658eaed9f839184cffa", "html_url": "https://github.com/rust-lang/rust/commit/3199bef05596afce72813658eaed9f839184cffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3199bef05596afce72813658eaed9f839184cffa/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a1b2267e45ed0a5bdbfcbe522024729c8bd1387", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1b2267e45ed0a5bdbfcbe522024729c8bd1387", "html_url": "https://github.com/rust-lang/rust/commit/0a1b2267e45ed0a5bdbfcbe522024729c8bd1387"}], "stats": {"total": 206, "additions": 151, "deletions": 55}, "files": [{"sha": "dbefa396cdaf3feb9d7f9a40940d0fb8e3dc4f04", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3199bef05596afce72813658eaed9f839184cffa/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3199bef05596afce72813658eaed9f839184cffa/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3199bef05596afce72813658eaed9f839184cffa", "patch": "@@ -1754,17 +1754,19 @@ bitflags! {\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n         const IS_ENUM             = 1 << 0;\n-        const IS_PHANTOM_DATA     = 1 << 1;\n-        const IS_FUNDAMENTAL      = 1 << 2;\n-        const IS_UNION            = 1 << 3;\n-        const IS_BOX              = 1 << 4;\n+        const IS_UNION            = 1 << 1;\n+        const IS_STRUCT           = 1 << 2;\n+        const IS_TUPLE_STRUCT     = 1 << 3;\n+        const IS_PHANTOM_DATA     = 1 << 4;\n+        const IS_FUNDAMENTAL      = 1 << 5;\n+        const IS_BOX              = 1 << 6;\n         /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 5;\n+        const IS_ARC              = 1 << 7;\n         /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 6;\n+        const IS_RC               = 1 << 8;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE   = 1 << 7;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 9;\n     }\n }\n \n@@ -2079,31 +2081,43 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n            repr: ReprOptions) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n+\n+        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n+        }\n+        flags |= match kind {\n+            AdtKind::Enum => AdtFlags::IS_ENUM,\n+            AdtKind::Union => AdtFlags::IS_UNION,\n+            AdtKind::Struct => AdtFlags::IS_STRUCT,\n+        };\n+\n+        if let AdtKind::Struct = kind {\n+            let variant_def = &variants[VariantIdx::new(0)];\n+            let def_key = tcx.def_key(variant_def.did);\n+            match def_key.disambiguated_data.data {\n+                DefPathData::StructCtor => flags |= AdtFlags::IS_TUPLE_STRUCT,\n+                _ => (),\n+            }\n+        }\n+\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n-            flags = flags | AdtFlags::IS_FUNDAMENTAL;\n+            flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n-            flags = flags | AdtFlags::IS_PHANTOM_DATA;\n+            flags |= AdtFlags::IS_PHANTOM_DATA;\n         }\n         if Some(did) == tcx.lang_items().owned_box() {\n-            flags = flags | AdtFlags::IS_BOX;\n+            flags |= AdtFlags::IS_BOX;\n         }\n         if Some(did) == tcx.lang_items().arc() {\n-            flags = flags | AdtFlags::IS_ARC;\n+            flags |= AdtFlags::IS_ARC;\n         }\n         if Some(did) == tcx.lang_items().rc() {\n-            flags = flags | AdtFlags::IS_RC;\n-        }\n-        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n-            debug!(\"found non-exhaustive variant list for {:?}\", did);\n-            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n-        }\n-        match kind {\n-            AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n-            AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n-            AdtKind::Struct => {}\n+            flags |= AdtFlags::IS_RC;\n         }\n+\n         AdtDef {\n             did,\n             variants,\n@@ -2114,25 +2128,31 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn is_struct(&self) -> bool {\n-        !self.is_union() && !self.is_enum()\n+        self.flags.contains(AdtFlags::IS_STRUCT)\n+    }\n+\n+    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n+    #[inline]\n+    pub fn is_tuple_struct(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_TUPLE_STRUCT)\n     }\n \n     #[inline]\n     pub fn is_union(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_UNION)\n+        self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_ENUM)\n+        self.flags.contains(AdtFlags::IS_ENUM)\n     }\n \n     #[inline]\n     pub fn is_variant_list_non_exhaustive(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n+        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n     }\n \n-    /// Returns the kind of the ADT - Struct or Enum.\n+    /// Returns the kind of the ADT.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {\n         if self.is_enum() {\n@@ -2161,33 +2181,33 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    /// Returns whether this type is #[fundamental] for the purposes\n+    /// Returns whether this type is `#[fundamental]` for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n+        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n     /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n+        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n     /// Returns `true` if this is `Arc<T>`.\n     pub fn is_arc(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_ARC)\n+        self.flags.contains(AdtFlags::IS_ARC)\n     }\n \n     /// Returns `true` if this is `Rc<T>`.\n     pub fn is_rc(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_RC)\n+        self.flags.contains(AdtFlags::IS_RC)\n     }\n \n     /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_BOX)\n+        self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n     /// Returns whether this type has a destructor."}, {"sha": "75ae868883484e0bd308d9b07d02386331faef7d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3199bef05596afce72813658eaed9f839184cffa/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3199bef05596afce72813658eaed9f839184cffa/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=3199bef05596afce72813658eaed9f839184cffa", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         Def::Local(id) | Def::Upvar(id, ..) => {\n                             Some(self.tcx.hir().span(id))\n                         }\n-                        _ => self.tcx.hir().span_if_local(def.def_id())\n+                        _ => def.opt_def_id().and_then(|did| self.tcx.hir().span_if_local(did)),\n                     };\n                     if let Some(span) = def_span {\n                         let label = match (unit_variant, inner_callee_path) {"}, {"sha": "d558558c764a7bb2189f30073d7b61f2e7a98917", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3199bef05596afce72813658eaed9f839184cffa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3199bef05596afce72813658eaed9f839184cffa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3199bef05596afce72813658eaed9f839184cffa", "patch": "@@ -95,7 +95,7 @@ mod op;\n \n use astconv::AstConv;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-use rustc::hir::{self, GenericArg, Node, ItemKind, PatKind};\n+use rustc::hir::{self, GenericArg, ItemKind, Node, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -113,7 +113,8 @@ use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n                        UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate, RegionKind};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate,\n+                RegionKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n@@ -3217,8 +3218,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             return_expr_ty);\n     }\n \n-    // A generic function for checking the then and else in an if\n-    // or if-else.\n+    // A generic function for checking the 'then' and 'else' clauses in an 'if'\n+    // or 'if-else' expression.\n     fn check_then_else(&self,\n                        cond_expr: &'gcx hir::Expr,\n                        then_expr: &'gcx hir::Expr,\n@@ -3544,7 +3545,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // We don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n                 // a bug to have constructed one.\n-                if adt_kind != ty::AdtKind::Enum {\n+                if adt_kind != AdtKind::Enum {\n                     tcx.check_stability(v_field.did, Some(expr_id), field.span);\n                 }\n \n@@ -5156,26 +5157,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }).unwrap_or(false);\n \n         let mut new_def = def;\n-        let (def_id, ty) = if let Def::SelfCtor(impl_def_id) = def {\n-            let ty = self.impl_self_ty(span, impl_def_id).ty;\n-\n-            match ty.ty_adt_def() {\n-                Some(adt_def) if adt_def.is_struct() => {\n-                    let variant = adt_def.non_enum_variant();\n-                    new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                    (variant.did, self.tcx.type_of(variant.did))\n-                }\n-                _ => {\n-                    (impl_def_id, self.tcx.types.err)\n+        let (def_id, ty) = match def {\n+            Def::SelfCtor(impl_def_id) => {\n+                let ty = self.impl_self_ty(span, impl_def_id).ty;\n+                let adt_def = ty.ty_adt_def();\n+\n+                match adt_def {\n+                    Some(adt_def) if adt_def.is_tuple_struct() => {\n+                        let variant = adt_def.non_enum_variant();\n+                        new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n+                        (variant.did, self.tcx.type_of(variant.did))\n+                    }\n+                    _ => {\n+                        let mut err = self.tcx.sess.struct_span_err(span,\n+                            \"the `Self` constructor can only be used with tuple or unit structs\");\n+                        if let Some(adt_def) = adt_def {\n+                            match adt_def.adt_kind() {\n+                                AdtKind::Enum => {\n+                                    err.note(\"did you mean to use one of the enum's variants?\");\n+                                },\n+                                AdtKind::Union => {},\n+                                AdtKind::Struct => {\n+                                    err.span_label(\n+                                        span,\n+                                        format!(\"did you mean `Self {{ /* fields */ }}`?\"),\n+                                    );\n+                                }\n+                            }\n+                        }\n+                        err.emit();\n+\n+                        (impl_def_id, self.tcx.types.err)\n+                    }\n                 }\n             }\n-        } else {\n-            let def_id = def.def_id();\n+            _ => {\n+                let def_id = def.def_id();\n \n-            // The things we are substituting into the type should not contain\n-            // escaping late-bound regions, and nor should the base type scheme.\n-            let ty = self.tcx.type_of(def_id);\n-            (def_id, ty)\n+                // The things we are substituting into the type should not contain\n+                // escaping late-bound regions, and nor should the base type scheme.\n+                let ty = self.tcx.type_of(def_id);\n+                (def_id, ty)\n+            }\n         };\n \n         let substs = AstConv::create_substs_for_generic_args("}, {"sha": "bbd51823cf1af29013975083495b7a5f1b516db4", "filename": "src/test/ui/issues/issue-56199.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3199bef05596afce72813658eaed9f839184cffa/src%2Ftest%2Fui%2Fissues%2Fissue-56199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3199bef05596afce72813658eaed9f839184cffa/src%2Ftest%2Fui%2Fissues%2Fissue-56199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56199.rs?ref=3199bef05596afce72813658eaed9f839184cffa", "patch": "@@ -0,0 +1,23 @@\n+\n+enum Foo {}\n+struct Bar {}\n+\n+impl Foo {\n+    fn foo() {\n+        let _ = Self;\n+        //~^ ERROR the `Self` constructor can only be used with tuple structs\n+        let _ = Self();\n+        //~^ ERROR the `Self` constructor can only be used with tuple structs\n+    }\n+}\n+\n+impl Bar {\n+    fn bar() {\n+        let _ = Self;\n+        //~^ ERROR the `Self` constructor can only be used with tuple structs\n+        let _ = Self();\n+        //~^ ERROR the `Self` constructor can only be used with tuple structs\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "feb88e926b2d841cf0f5f27dd847f3b5c2c129c8", "filename": "src/test/ui/issues/issue-56199.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3199bef05596afce72813658eaed9f839184cffa/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3199bef05596afce72813658eaed9f839184cffa/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr?ref=3199bef05596afce72813658eaed9f839184cffa", "patch": "@@ -0,0 +1,30 @@\n+error: the `Self` constructor can only be used with tuple structs\n+  --> $DIR/issue-56199.rs:7:17\n+   |\n+LL |         let _ = Self;\n+   |                 ^^^^\n+   |\n+   = note: did you mean to use one of the enum's variants?\n+\n+error: the `Self` constructor can only be used with tuple structs\n+  --> $DIR/issue-56199.rs:9:17\n+   |\n+LL |         let _ = Self();\n+   |                 ^^^^\n+   |\n+   = note: did you mean to use one of the enum's variants?\n+\n+error: the `Self` constructor can only be used with tuple structs\n+  --> $DIR/issue-56199.rs:16:17\n+   |\n+LL |         let _ = Self;\n+   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+\n+error: the `Self` constructor can only be used with tuple structs\n+  --> $DIR/issue-56199.rs:18:17\n+   |\n+LL |         let _ = Self();\n+   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+\n+error: aborting due to 4 previous errors\n+"}]}