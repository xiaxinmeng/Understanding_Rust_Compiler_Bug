{"sha": "d4ad050ce5778a09566f6f9ec172565815d54604", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YWQwNTBjZTU3NzhhMDk1NjZmNmY5ZWMxNzI1NjU4MTVkNTQ2MDQ=", "commit": {"author": {"name": "jedel1043", "email": "jedel0124@gmail.com", "date": "2021-05-16T14:51:00Z"}, "committer": {"name": "jedel1043", "email": "jedel0124@gmail.com", "date": "2021-05-16T14:51:00Z"}, "message": "Check and deny anonymous fields on `ast_validation`", "tree": {"sha": "0f83ed9e8c5e4c553c0c2510a9ceeffb4bfdadf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f83ed9e8c5e4c553c0c2510a9ceeffb4bfdadf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ad050ce5778a09566f6f9ec172565815d54604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ad050ce5778a09566f6f9ec172565815d54604", "html_url": "https://github.com/rust-lang/rust/commit/d4ad050ce5778a09566f6f9ec172565815d54604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ad050ce5778a09566f6f9ec172565815d54604/comments", "author": {"login": "jedel1043", "id": 38230983, "node_id": "MDQ6VXNlcjM4MjMwOTgz", "avatar_url": "https://avatars.githubusercontent.com/u/38230983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedel1043", "html_url": "https://github.com/jedel1043", "followers_url": "https://api.github.com/users/jedel1043/followers", "following_url": "https://api.github.com/users/jedel1043/following{/other_user}", "gists_url": "https://api.github.com/users/jedel1043/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedel1043/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedel1043/subscriptions", "organizations_url": "https://api.github.com/users/jedel1043/orgs", "repos_url": "https://api.github.com/users/jedel1043/repos", "events_url": "https://api.github.com/users/jedel1043/events{/privacy}", "received_events_url": "https://api.github.com/users/jedel1043/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedel1043", "id": 38230983, "node_id": "MDQ6VXNlcjM4MjMwOTgz", "avatar_url": "https://avatars.githubusercontent.com/u/38230983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedel1043", "html_url": "https://github.com/jedel1043", "followers_url": "https://api.github.com/users/jedel1043/followers", "following_url": "https://api.github.com/users/jedel1043/following{/other_user}", "gists_url": "https://api.github.com/users/jedel1043/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedel1043/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedel1043/subscriptions", "organizations_url": "https://api.github.com/users/jedel1043/orgs", "repos_url": "https://api.github.com/users/jedel1043/repos", "events_url": "https://api.github.com/users/jedel1043/events{/privacy}", "received_events_url": "https://api.github.com/users/jedel1043/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "059b68dd677808e14e560802d235ad40beeba71e", "url": "https://api.github.com/repos/rust-lang/rust/commits/059b68dd677808e14e560802d235ad40beeba71e", "html_url": "https://github.com/rust-lang/rust/commit/059b68dd677808e14e560802d235ad40beeba71e"}], "stats": {"total": 254, "additions": 184, "deletions": 70}, "files": [{"sha": "ba2da7694978d9791f5326da3eee0b179e38da11", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 184, "deletions": 70, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/d4ad050ce5778a09566f6f9ec172565815d54604/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ad050ce5778a09566f6f9ec172565815d54604/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=d4ad050ce5778a09566f6f9ec172565815d54604", "patch": "@@ -175,10 +175,30 @@ impl<'a> AstValidator<'a> {\n                     }\n                 }\n             }\n+            TyKind::AnonymousStruct(ref fields, ..) | TyKind::AnonymousUnion(ref fields, ..) => {\n+                self.with_banned_assoc_ty_bound(|this| {\n+                    walk_list!(this, visit_struct_field_def, fields)\n+                });\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }\n \n+    fn visit_struct_field_def(&mut self, field: &'a FieldDef) {\n+        if let Some(ident) = field.ident {\n+            if ident.name == kw::Underscore {\n+                self.check_anonymous_field(field);\n+                self.visit_vis(&field.vis);\n+                self.visit_ident(ident);\n+                self.visit_ty_common(&field.ty);\n+                self.walk_ty(&field.ty);\n+                walk_list!(self, visit_attribute, &field.attrs);\n+                return;\n+            }\n+        }\n+        self.visit_field_def(field);\n+    }\n+\n     fn err_handler(&self) -> &rustc_errors::Handler {\n         &self.session.diagnostic()\n     }\n@@ -213,6 +233,66 @@ impl<'a> AstValidator<'a> {\n         err.emit();\n     }\n \n+    fn check_anonymous_field(&self, field: &FieldDef) {\n+        let FieldDef { ty, .. } = field;\n+        match &ty.kind {\n+            TyKind::AnonymousStruct(..) | TyKind::AnonymousUnion(..) => {\n+                // We already checked for `kw::Underscore` before calling this function,\n+                // so skip the check\n+            }\n+            TyKind::Path(..) => {\n+                // If the anonymous field contains a Path as type, we can't determine\n+                // if the path is a valid struct or union, so skip the check\n+            }\n+            _ => {\n+                let msg = \"unnamed fields can only have struct or union types\";\n+                let label = \"not a struct or union\";\n+                self.err_handler()\n+                    .struct_span_err(field.span, msg)\n+                    .span_label(ty.span, label)\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    fn deny_anonymous_struct(&self, ty: &Ty) {\n+        match &ty.kind {\n+            TyKind::AnonymousStruct(..) => {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        ty.span,\n+                        \"anonymous structs are not allowed outside of unnamed struct or union fields\",\n+                    )\n+                    .span_label(ty.span, \"anonymous struct declared here\")\n+                    .emit();\n+            }\n+            TyKind::AnonymousUnion(..) => {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        ty.span,\n+                        \"anonymous unions are not allowed outside of unnamed struct or union fields\",\n+                    )\n+                    .span_label(ty.span, \"anonymous union declared here\")\n+                    .emit();\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn deny_anonymous_field(&self, field: &FieldDef) {\n+        if let Some(ident) = field.ident {\n+            if ident.name == kw::Underscore {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        field.span,\n+                        \"anonymous fields are not allowed outside of structs or unions\",\n+                    )\n+                    .span_label(ident.span, \"anonymous field declared here\")\n+                    .emit()\n+            }\n+        }\n+    }\n+\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n@@ -732,6 +812,71 @@ impl<'a> AstValidator<'a> {\n             )\n             .emit();\n     }\n+\n+    fn visit_ty_common(&mut self, ty: &'a Ty) {\n+        match ty.kind {\n+            TyKind::BareFn(ref bfty) => {\n+                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n+                Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n+                    struct_span_err!(\n+                        self.session,\n+                        span,\n+                        E0561,\n+                        \"patterns aren't allowed in function pointer types\"\n+                    )\n+                    .emit();\n+                });\n+                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n+            }\n+            TyKind::TraitObject(ref bounds, ..) => {\n+                let mut any_lifetime_bounds = false;\n+                for bound in bounds {\n+                    if let GenericBound::Outlives(ref lifetime) = *bound {\n+                        if any_lifetime_bounds {\n+                            struct_span_err!(\n+                                self.session,\n+                                lifetime.ident.span,\n+                                E0226,\n+                                \"only a single explicit lifetime bound is permitted\"\n+                            )\n+                            .emit();\n+                            break;\n+                        }\n+                        any_lifetime_bounds = true;\n+                    }\n+                }\n+                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n+            }\n+            TyKind::ImplTrait(_, ref bounds) => {\n+                if self.is_impl_trait_banned {\n+                    struct_span_err!(\n+                        self.session,\n+                        ty.span,\n+                        E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit();\n+                }\n+\n+                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n+                    struct_span_err!(\n+                        self.session,\n+                        ty.span,\n+                        E0666,\n+                        \"nested `impl Trait` is not allowed\"\n+                    )\n+                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n+                    .span_label(ty.span, \"nested `impl Trait` here\")\n+                    .emit();\n+                }\n+\n+                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n+                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n /// Checks that generic parameters are in the correct order,\n@@ -850,72 +995,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.kind {\n-            TyKind::BareFn(ref bfty) => {\n-                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n-                Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n-                });\n-                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n-            }\n-            TyKind::TraitObject(ref bounds, ..) => {\n-                let mut any_lifetime_bounds = false;\n-                for bound in bounds {\n-                    if let GenericBound::Outlives(ref lifetime) = *bound {\n-                        if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n-                            break;\n-                        }\n-                        any_lifetime_bounds = true;\n-                    }\n-                }\n-                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n-            }\n-            TyKind::ImplTrait(_, ref bounds) => {\n-                if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n-                }\n-\n-                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n-                }\n-\n-                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n-                }\n-\n-                self.walk_ty(ty);\n-                return;\n-            }\n-            _ => {}\n-        }\n-\n+        self.visit_ty_common(ty);\n+        self.deny_anonymous_struct(ty);\n         self.walk_ty(ty)\n     }\n \n@@ -929,6 +1010,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_lifetime(self, lifetime);\n     }\n \n+    fn visit_field_def(&mut self, s: &'a FieldDef) {\n+        self.deny_anonymous_field(s);\n+        visit::walk_field_def(self, s)\n+    }\n+\n     fn visit_item(&mut self, item: &'a Item) {\n         if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n             self.has_proc_macro_decls = true;\n@@ -1084,14 +1170,42 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Union(ref vdata, _) => {\n-                if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {\n-                    self.err_handler()\n-                        .span_err(item.span, \"tuple and unit unions are not permitted\");\n+            ItemKind::Struct(ref vdata, ref generics) => match vdata {\n+                // Duplicating the `Visitor` logic allows catching all cases\n+                // of `Anonymous(Struct, Union)` outside of a field struct or union.\n+                //\n+                // Inside `visit_ty` the validator catches every `Anonymous(Struct, Union)` it\n+                // encounters, and only on `ItemKind::Struct` and `ItemKind::Union`\n+                // it uses `visit_ty_common`, which doesn't contain that specific check.\n+                VariantData::Struct(ref fields, ..) => {\n+                    self.visit_vis(&item.vis);\n+                    self.visit_ident(item.ident);\n+                    self.visit_generics(generics);\n+                    self.with_banned_assoc_ty_bound(|this| {\n+                        walk_list!(this, visit_struct_field_def, fields);\n+                    });\n+                    walk_list!(self, visit_attribute, &item.attrs);\n+                    return;\n                 }\n+                _ => {}\n+            },\n+            ItemKind::Union(ref vdata, ref generics) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n+                match vdata {\n+                    VariantData::Struct(ref fields, ..) => {\n+                        self.visit_vis(&item.vis);\n+                        self.visit_ident(item.ident);\n+                        self.visit_generics(generics);\n+                        self.with_banned_assoc_ty_bound(|this| {\n+                            walk_list!(this, visit_struct_field_def, fields);\n+                        });\n+                        walk_list!(self, visit_attribute, &item.attrs);\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);"}]}