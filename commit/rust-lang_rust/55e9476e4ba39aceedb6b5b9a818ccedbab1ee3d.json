{"sha": "55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZTk0NzZlNGJhMzlhY2VlZGI2YjViOWE4MThjY2VkYmFiMWVlM2Q=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-28T17:36:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-28T19:43:37Z"}, "message": "internal: more production-ready proc-macro RPC deserialization\n\n* avoid arbitrary nested JSON tree (danger of stack overflow)\n* use more compact representation.", "tree": {"sha": "6ac270be180a060c1a8e76b3cdbab5db5903adc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ac270be180a060c1a8e76b3cdbab5db5903adc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "html_url": "https://github.com/rust-lang/rust/commit/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ea3c4d53bc41984b96013a6085d92d6b19e9952", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea3c4d53bc41984b96013a6085d92d6b19e9952", "html_url": "https://github.com/rust-lang/rust/commit/9ea3c4d53bc41984b96013a6085d92d6b19e9952"}], "stats": {"total": 579, "additions": 365, "deletions": 214}, "files": [{"sha": "41dfcc541a8c378ee88ba010d43b1e602fb93e86", "filename": "crates/proc_macro_api/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "patch": "@@ -21,7 +21,9 @@ use tt::{SmolStr, Subtree};\n \n use crate::process::ProcMacroProcessSrv;\n \n-pub use rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n+pub use rpc::{\n+    ExpansionResult, ExpansionTask, flat::FlatTree, ListMacrosResult, ListMacrosTask, ProcMacroKind,\n+};\n pub use version::{read_dylib_info, RustCInfo};\n \n #[derive(Debug, Clone)]\n@@ -58,9 +60,9 @@ impl ProcMacroProcessExpander {\n         env: Vec<(String, String)>,\n     ) -> Result<Subtree, tt::ExpansionError> {\n         let task = ExpansionTask {\n-            macro_body: subtree.clone(),\n+            macro_body: FlatTree::new(subtree),\n             macro_name: self.name.to_string(),\n-            attributes: attr.cloned(),\n+            attributes: attr.map(FlatTree::new),\n             lib: self.dylib_path.to_path_buf(),\n             env,\n         };\n@@ -70,7 +72,7 @@ impl ProcMacroProcessExpander {\n             .lock()\n             .unwrap_or_else(|e| e.into_inner())\n             .send_task(msg::Request::ExpansionMacro(task))?;\n-        Ok(result.expansion)\n+        Ok(result.expansion.to_subtree())\n     }\n }\n "}, {"sha": "fd10d87f08c86546989580107a4b09ad3afcc6f0", "filename": "crates/proc_macro_api/src/msg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs?ref=55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "patch": "@@ -12,13 +12,13 @@ use crate::{\n     ExpansionResult, ExpansionTask,\n };\n \n-#[derive(Debug, Serialize, Deserialize, Clone)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub enum Request {\n     ListMacro(ListMacrosTask),\n     ExpansionMacro(ExpansionTask),\n }\n \n-#[derive(Debug, Serialize, Deserialize, Clone)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub enum Response {\n     Error(ResponseError),\n     ListMacro(ListMacrosResult),"}, {"sha": "10aa24d00c2c2a971f69acc22f809715bafcba25", "filename": "crates/proc_macro_api/src/rpc.rs", "status": "modified", "additions": 21, "deletions": 204, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs?ref=55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "patch": "@@ -5,13 +5,12 @@\n //! Although adding `Serialize` and `Deserialize` traits to `tt` directly seems\n //! to be much easier, we deliberately duplicate `tt` structs with `#[serde(with = \"XXDef\")]`\n //! for separation of code responsibility.\n+pub(crate) mod flat;\n \n use paths::AbsPathBuf;\n use serde::{Deserialize, Serialize};\n-use tt::{\n-    Delimiter, DelimiterKind, Ident, Leaf, Literal, Punct, SmolStr, Spacing, Subtree, TokenId,\n-    TokenTree,\n-};\n+\n+use crate::rpc::flat::FlatTree;\n \n #[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n pub struct ListMacrosTask {\n@@ -30,14 +29,13 @@ pub struct ListMacrosResult {\n     pub macros: Vec<(String, ProcMacroKind)>,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub struct ExpansionTask {\n     /// Argument of macro call.\n     ///\n     /// In custom derive this will be a struct or enum; in attribute-like macro - underlying\n     /// item; in function-like macro - the macro body.\n-    #[serde(with = \"SubtreeDef\")]\n-    pub macro_body: Subtree,\n+    pub macro_body: FlatTree,\n \n     /// Name of macro to expand.\n     ///\n@@ -46,208 +44,23 @@ pub struct ExpansionTask {\n     pub macro_name: String,\n \n     /// Possible attributes for the attribute-like macros.\n-    #[serde(with = \"opt_subtree_def\")]\n-    pub attributes: Option<Subtree>,\n+    pub attributes: Option<FlatTree>,\n \n     pub lib: AbsPathBuf,\n \n     /// Environment variables to set during macro expansion.\n     pub env: Vec<(String, String)>,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug, Default, Serialize, Deserialize)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub struct ExpansionResult {\n-    #[serde(with = \"SubtreeDef\")]\n-    pub expansion: Subtree,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"DelimiterKind\")]\n-enum DelimiterKindDef {\n-    Parenthesis,\n-    Brace,\n-    Bracket,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"TokenId\")]\n-struct TokenIdDef(u32);\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Delimiter\")]\n-struct DelimiterDef {\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-    #[serde(with = \"DelimiterKindDef\")]\n-    kind: DelimiterKind,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Subtree\")]\n-struct SubtreeDef {\n-    #[serde(default, with = \"opt_delimiter_def\")]\n-    delimiter: Option<Delimiter>,\n-    #[serde(with = \"vec_token_tree\")]\n-    token_trees: Vec<TokenTree>,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"TokenTree\")]\n-enum TokenTreeDef {\n-    #[serde(with = \"LeafDef\")]\n-    Leaf(Leaf),\n-    #[serde(with = \"SubtreeDef\")]\n-    Subtree(Subtree),\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Leaf\")]\n-enum LeafDef {\n-    #[serde(with = \"LiteralDef\")]\n-    Literal(Literal),\n-    #[serde(with = \"PunctDef\")]\n-    Punct(Punct),\n-    #[serde(with = \"IdentDef\")]\n-    Ident(Ident),\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Literal\")]\n-struct LiteralDef {\n-    text: SmolStr,\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Punct\")]\n-struct PunctDef {\n-    char: char,\n-    #[serde(with = \"SpacingDef\")]\n-    spacing: Spacing,\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Spacing\")]\n-enum SpacingDef {\n-    Alone,\n-    Joint,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Ident\")]\n-struct IdentDef {\n-    text: SmolStr,\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-}\n-\n-mod token_id_def {\n-    pub(super) fn skip_if(value: &tt::TokenId) -> bool {\n-        *value == tt::TokenId::unspecified()\n-    }\n-}\n-\n-mod opt_delimiter_def {\n-    use super::{Delimiter, DelimiterDef};\n-    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n-\n-    pub(super) fn serialize<S>(value: &Option<Delimiter>, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        #[derive(Serialize)]\n-        struct Helper<'a>(#[serde(with = \"DelimiterDef\")] &'a Delimiter);\n-        value.as_ref().map(Helper).serialize(serializer)\n-    }\n-\n-    pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Option<Delimiter>, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        #[derive(Deserialize)]\n-        struct Helper(#[serde(with = \"DelimiterDef\")] Delimiter);\n-        let helper = Option::deserialize(deserializer)?;\n-        Ok(helper.map(|Helper(external)| external))\n-    }\n-}\n-\n-mod opt_subtree_def {\n-    use super::{Subtree, SubtreeDef};\n-    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n-\n-    pub(super) fn serialize<S>(value: &Option<Subtree>, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        #[derive(Serialize)]\n-        struct Helper<'a>(#[serde(with = \"SubtreeDef\")] &'a Subtree);\n-        value.as_ref().map(Helper).serialize(serializer)\n-    }\n-\n-    pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Option<Subtree>, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        #[derive(Deserialize)]\n-        struct Helper(#[serde(with = \"SubtreeDef\")] Subtree);\n-        let helper = Option::deserialize(deserializer)?;\n-        Ok(helper.map(|Helper(external)| external))\n-    }\n-}\n-\n-mod vec_token_tree {\n-    use super::{TokenTree, TokenTreeDef};\n-    use serde::{ser::SerializeSeq, Deserialize, Deserializer, Serialize, Serializer};\n-\n-    pub(super) fn serialize<S>(value: &[TokenTree], serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        #[derive(Serialize)]\n-        struct Helper<'a>(#[serde(with = \"TokenTreeDef\")] &'a TokenTree);\n-\n-        let items: Vec<_> = value.iter().map(Helper).collect();\n-        let mut seq = serializer.serialize_seq(Some(items.len()))?;\n-        for element in items {\n-            seq.serialize_element(&element)?;\n-        }\n-        seq.end()\n-    }\n-\n-    pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Vec<TokenTree>, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        #[derive(Deserialize)]\n-        struct Helper(#[serde(with = \"TokenTreeDef\")] TokenTree);\n-\n-        let helper = Vec::deserialize(deserializer)?;\n-        Ok(helper.into_iter().map(|Helper(external)| external).collect())\n-    }\n+    pub expansion: FlatTree,\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use tt::*;\n \n     fn fixture_token_tree() -> Subtree {\n         let mut subtree = Subtree::default();\n@@ -257,6 +70,15 @@ mod tests {\n         subtree\n             .token_trees\n             .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), id: TokenId(1) }.into()));\n+        subtree.token_trees.push(TokenTree::Leaf(Leaf::Literal(Literal {\n+            text: \"Foo\".into(),\n+            id: TokenId::unspecified(),\n+        })));\n+        subtree.token_trees.push(TokenTree::Leaf(Leaf::Punct(Punct {\n+            char: '@',\n+            id: TokenId::unspecified(),\n+            spacing: Spacing::Joint,\n+        })));\n         subtree.token_trees.push(TokenTree::Subtree(Subtree {\n             delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Brace }),\n             token_trees: vec![],\n@@ -268,22 +90,17 @@ mod tests {\n     fn test_proc_macro_rpc_works() {\n         let tt = fixture_token_tree();\n         let task = ExpansionTask {\n-            macro_body: tt.clone(),\n+            macro_body: FlatTree::new(&tt),\n             macro_name: Default::default(),\n             attributes: None,\n             lib: AbsPathBuf::assert(std::env::current_dir().unwrap()),\n             env: Default::default(),\n         };\n \n         let json = serde_json::to_string(&task).unwrap();\n+        println!(\"{}\", json);\n         let back: ExpansionTask = serde_json::from_str(&json).unwrap();\n \n-        assert_eq!(task.macro_body, back.macro_body);\n-\n-        let result = ExpansionResult { expansion: tt };\n-        let json = serde_json::to_string(&result).unwrap();\n-        let back: ExpansionResult = serde_json::from_str(&json).unwrap();\n-\n-        assert_eq!(result, back);\n+        assert_eq!(tt, back.macro_body.to_subtree());\n     }\n }"}, {"sha": "d427fa87d23a8a1f088efaceb3039dcd52900f0f", "filename": "crates/proc_macro_api/src/rpc/flat.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Frpc%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_api%2Fsrc%2Frpc%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc%2Fflat.rs?ref=55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "patch": "@@ -0,0 +1,328 @@\n+//! Serialization-friendly representation of `tt::Subtree`.\n+//!\n+//! It is possible to serialize `Subtree` as is, as a tree, but using\n+//! arbitrary-nested trees in JSON is problematic, as they can cause the JSON\n+//! parser to overflow the stack.\n+//!\n+//! Additionally, such implementation would be pretty verbose, and we do care\n+//! about performance here a bit.\n+//!\n+//! So what this module does is dumping a `tt::Subtree` into a bunch of flat\n+//! array of numbers. See the test in the parent module to get an example\n+//! output.\n+//!\n+//! ```json\n+//!  {\n+//!    // Array of subtrees, each subtree is represented by 4 numbers:\n+//!    // id of delimiter, delimiter kind, index of first child in `token_tree`,\n+//!    // index of last child in `token_tree`\n+//!    \"subtree\":[4294967295,0,0,5,2,2,5,5],\n+//!    // 2 ints per literal: [token id, index into `text`]\n+//!    \"literal\":[4294967295,1],\n+//!    // 3 ints per punct: [token id, char, spacing]\n+//!    \"punct\":[4294967295,64,1],\n+//!    // 2 ints per ident: [token id, index into `text`]\n+//!    \"ident\":   [0,0,1,1],\n+//!    // children of all subtrees, concatenated. Each child is represented as `index << 2 | tag`\n+//!    // where tag denotes one of subtree, literal, punct or ident.\n+//!    \"token_tree\":[3,7,1,4],\n+//!    // Strings shared by idents and literals\n+//!    \"text\": [\"struct\",\"Foo\"]\n+//!  }\n+//! ```\n+//!\n+//! We probably should replace most of the code here with bincode someday, but,\n+//! as we don't have bincode in Cargo.toml yet, lets stick with serde_json for\n+//! the time being.\n+\n+use std::{\n+    collections::{HashMap, VecDeque},\n+    convert::TryInto,\n+};\n+\n+use serde::{Deserialize, Serialize};\n+use tt::TokenId;\n+\n+#[derive(Serialize, Deserialize, Debug)]\n+pub struct FlatTree {\n+    subtree: Vec<u32>,\n+    literal: Vec<u32>,\n+    punct: Vec<u32>,\n+    ident: Vec<u32>,\n+    token_tree: Vec<u32>,\n+    text: Vec<String>,\n+}\n+\n+struct SubtreeRepr {\n+    id: tt::TokenId,\n+    kind: Option<tt::DelimiterKind>,\n+    tt: [u32; 2],\n+}\n+\n+struct LiteralRepr {\n+    id: tt::TokenId,\n+    text: u32,\n+}\n+\n+struct PunctRepr {\n+    id: tt::TokenId,\n+    char: char,\n+    spacing: tt::Spacing,\n+}\n+\n+struct IdentRepr {\n+    id: tt::TokenId,\n+    text: u32,\n+}\n+\n+impl FlatTree {\n+    pub fn new(subtree: &tt::Subtree) -> FlatTree {\n+        let mut w = Writer {\n+            string_table: HashMap::new(),\n+            work: VecDeque::new(),\n+\n+            subtree: Vec::new(),\n+            literal: Vec::new(),\n+            punct: Vec::new(),\n+            ident: Vec::new(),\n+            token_tree: Vec::new(),\n+            text: Vec::new(),\n+        };\n+        w.write(subtree);\n+\n+        return FlatTree {\n+            subtree: write_vec(w.subtree, SubtreeRepr::write),\n+            literal: write_vec(w.literal, LiteralRepr::write),\n+            punct: write_vec(w.punct, PunctRepr::write),\n+            ident: write_vec(w.ident, IdentRepr::write),\n+            token_tree: w.token_tree,\n+            text: w.text,\n+        };\n+\n+        fn write_vec<T, F: Fn(T) -> [u32; N], const N: usize>(xs: Vec<T>, f: F) -> Vec<u32> {\n+            xs.into_iter().flat_map(f).collect()\n+        }\n+    }\n+\n+    pub fn to_subtree(self) -> tt::Subtree {\n+        return Reader {\n+            subtree: read_vec(self.subtree, SubtreeRepr::read),\n+            literal: read_vec(self.literal, LiteralRepr::read),\n+            punct: read_vec(self.punct, PunctRepr::read),\n+            ident: read_vec(self.ident, IdentRepr::read),\n+            token_tree: self.token_tree,\n+            text: self.text,\n+        }\n+        .read();\n+\n+        fn read_vec<T, F: Fn([u32; N]) -> T, const N: usize>(xs: Vec<u32>, f: F) -> Vec<T> {\n+            let mut chunks = xs.chunks_exact(N);\n+            let res = chunks.by_ref().map(|chunk| f(chunk.try_into().unwrap())).collect();\n+            assert!(chunks.remainder().is_empty());\n+            res\n+        }\n+    }\n+}\n+\n+impl SubtreeRepr {\n+    fn write(self) -> [u32; 4] {\n+        let kind = match self.kind {\n+            None => 0,\n+            Some(tt::DelimiterKind::Parenthesis) => 1,\n+            Some(tt::DelimiterKind::Brace) => 2,\n+            Some(tt::DelimiterKind::Bracket) => 3,\n+        };\n+        [self.id.0, kind, self.tt[0], self.tt[1]]\n+    }\n+    fn read([id, kind, lo, len]: [u32; 4]) -> SubtreeRepr {\n+        let kind = match kind {\n+            0 => None,\n+            1 => Some(tt::DelimiterKind::Parenthesis),\n+            2 => Some(tt::DelimiterKind::Brace),\n+            3 => Some(tt::DelimiterKind::Bracket),\n+            other => panic!(\"bad kind {}\", other),\n+        };\n+        SubtreeRepr { id: TokenId(id), kind, tt: [lo, len] }\n+    }\n+}\n+\n+impl LiteralRepr {\n+    fn write(self) -> [u32; 2] {\n+        [self.id.0, self.text]\n+    }\n+    fn read([id, text]: [u32; 2]) -> LiteralRepr {\n+        LiteralRepr { id: TokenId(id), text }\n+    }\n+}\n+\n+impl PunctRepr {\n+    fn write(self) -> [u32; 3] {\n+        let spacing = match self.spacing {\n+            tt::Spacing::Alone => 0,\n+            tt::Spacing::Joint => 1,\n+        };\n+        [self.id.0, self.char as u32, spacing]\n+    }\n+    fn read([id, char, spacing]: [u32; 3]) -> PunctRepr {\n+        let spacing = match spacing {\n+            0 => tt::Spacing::Alone,\n+            1 => tt::Spacing::Joint,\n+            other => panic!(\"bad spacing {}\", other),\n+        };\n+        PunctRepr { id: TokenId(id), char: char.try_into().unwrap(), spacing }\n+    }\n+}\n+\n+impl IdentRepr {\n+    fn write(self) -> [u32; 2] {\n+        [self.id.0, self.text]\n+    }\n+    fn read(data: [u32; 2]) -> IdentRepr {\n+        IdentRepr { id: TokenId(data[0]), text: data[1] }\n+    }\n+}\n+\n+struct Writer<'a> {\n+    work: VecDeque<(usize, &'a tt::Subtree)>,\n+    string_table: HashMap<&'a str, u32>,\n+\n+    subtree: Vec<SubtreeRepr>,\n+    literal: Vec<LiteralRepr>,\n+    punct: Vec<PunctRepr>,\n+    ident: Vec<IdentRepr>,\n+    token_tree: Vec<u32>,\n+    text: Vec<String>,\n+}\n+\n+impl<'a> Writer<'a> {\n+    fn write(&mut self, root: &'a tt::Subtree) {\n+        self.enqueue(root);\n+        while let Some((idx, subtree)) = self.work.pop_front() {\n+            self.subtree(idx, subtree);\n+        }\n+    }\n+\n+    fn subtree(&mut self, idx: usize, subtree: &'a tt::Subtree) {\n+        let mut first_tt = self.token_tree.len();\n+        let n_tt = subtree.token_trees.len();\n+        self.token_tree.resize(first_tt + n_tt, !0);\n+\n+        self.subtree[idx].tt = [first_tt as u32, (first_tt + n_tt) as u32];\n+\n+        for child in &subtree.token_trees {\n+            let idx_tag = match child {\n+                tt::TokenTree::Subtree(it) => {\n+                    let idx = self.enqueue(it);\n+                    idx << 2 | 0b00\n+                }\n+                tt::TokenTree::Leaf(leaf) => match leaf {\n+                    tt::Leaf::Literal(lit) => {\n+                        let idx = self.literal.len() as u32;\n+                        let text = self.intern(&lit.text);\n+                        self.literal.push(LiteralRepr { id: lit.id, text });\n+                        idx << 2 | 0b01\n+                    }\n+                    tt::Leaf::Punct(punct) => {\n+                        let idx = self.punct.len() as u32;\n+                        self.punct.push(PunctRepr {\n+                            char: punct.char,\n+                            spacing: punct.spacing,\n+                            id: punct.id,\n+                        });\n+                        idx << 2 | 0b10\n+                    }\n+                    tt::Leaf::Ident(ident) => {\n+                        let idx = self.ident.len() as u32;\n+                        let text = self.intern(&ident.text);\n+                        self.ident.push(IdentRepr { id: ident.id, text });\n+                        idx << 2 | 0b11\n+                    }\n+                },\n+            };\n+            self.token_tree[first_tt] = idx_tag;\n+            first_tt += 1;\n+        }\n+    }\n+\n+    fn enqueue(&mut self, subtree: &'a tt::Subtree) -> u32 {\n+        let idx = self.subtree.len();\n+        let delimiter_id = subtree.delimiter.map(|it| it.id).unwrap_or(TokenId::unspecified());\n+        let delimiter_kind = subtree.delimiter.map(|it| it.kind);\n+        self.subtree.push(SubtreeRepr { id: delimiter_id, kind: delimiter_kind, tt: [!0, !0] });\n+        self.work.push_back((idx, subtree));\n+        idx as u32\n+    }\n+\n+    pub(crate) fn intern(&mut self, text: &'a str) -> u32 {\n+        let table = &mut self.text;\n+        *self.string_table.entry(text).or_insert_with(|| {\n+            let idx = table.len();\n+            table.push(text.to_string());\n+            idx as u32\n+        })\n+    }\n+}\n+\n+struct Reader {\n+    subtree: Vec<SubtreeRepr>,\n+    literal: Vec<LiteralRepr>,\n+    punct: Vec<PunctRepr>,\n+    ident: Vec<IdentRepr>,\n+    token_tree: Vec<u32>,\n+    text: Vec<String>,\n+}\n+\n+impl Reader {\n+    pub(crate) fn read(self) -> tt::Subtree {\n+        let mut res: Vec<Option<tt::Subtree>> = vec![None; self.subtree.len()];\n+        for i in (0..self.subtree.len()).rev() {\n+            let repr = &self.subtree[i];\n+            let token_trees = &self.token_tree[repr.tt[0] as usize..repr.tt[1] as usize];\n+            let s = tt::Subtree {\n+                delimiter: repr.kind.map(|kind| tt::Delimiter { id: repr.id, kind }),\n+                token_trees: token_trees\n+                    .iter()\n+                    .copied()\n+                    .map(|idx_tag| {\n+                        let tag = idx_tag & 0b11;\n+                        let idx = (idx_tag >> 2) as usize;\n+                        match tag {\n+                            // XXX: we iterate subtrees in reverse to guarantee\n+                            // that this unwrap doesn't fire.\n+                            0b00 => res[idx].take().unwrap().into(),\n+                            0b01 => {\n+                                let repr = &self.literal[idx];\n+                                tt::Leaf::Literal(tt::Literal {\n+                                    text: self.text[repr.text as usize].as_str().into(),\n+                                    id: repr.id,\n+                                })\n+                                .into()\n+                            }\n+                            0b10 => {\n+                                let repr = &self.punct[idx];\n+                                tt::Leaf::Punct(tt::Punct {\n+                                    char: repr.char,\n+                                    spacing: repr.spacing,\n+                                    id: repr.id,\n+                                })\n+                                .into()\n+                            }\n+                            0b11 => {\n+                                let repr = &self.ident[idx];\n+                                tt::Leaf::Ident(tt::Ident {\n+                                    text: self.text[repr.text as usize].as_str().into(),\n+                                    id: repr.id,\n+                                })\n+                                .into()\n+                            }\n+                            other => panic!(\"bad tag: {}\", other),\n+                        }\n+                    })\n+                    .collect(),\n+            };\n+            res[i] = Some(s.into())\n+        }\n+\n+        res[0].take().unwrap()\n+    }\n+}"}, {"sha": "fe3665110db7366e2a115dfdd5e0c890da5b7d16", "filename": "crates/proc_macro_srv/src/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs?ref=55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "patch": "@@ -12,7 +12,7 @@ pub fn run() -> io::Result<()> {\n         let res = match req {\n             msg::Request::ListMacro(task) => srv.list_macros(&task).map(msg::Response::ListMacro),\n             msg::Request::ExpansionMacro(task) => {\n-                srv.expand(&task).map(msg::Response::ExpansionMacro)\n+                srv.expand(task).map(msg::Response::ExpansionMacro)\n             }\n         };\n "}, {"sha": "c60dd2efc53f1944043799524245513788fbe1a4", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=55e9476e4ba39aceedb6b5b9a818ccedbab1ee3d", "patch": "@@ -15,7 +15,7 @@ mod dylib;\n \n mod abis;\n \n-use proc_macro_api::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n+use proc_macro_api::{ExpansionResult, ExpansionTask, FlatTree, ListMacrosResult, ListMacrosTask};\n use std::{\n     collections::{hash_map::Entry, HashMap},\n     env, fs,\n@@ -29,7 +29,7 @@ pub(crate) struct ProcMacroSrv {\n }\n \n impl ProcMacroSrv {\n-    pub fn expand(&mut self, task: &ExpansionTask) -> Result<ExpansionResult, String> {\n+    pub fn expand(&mut self, task: ExpansionTask) -> Result<ExpansionResult, String> {\n         let expander = self.expander(task.lib.as_ref())?;\n \n         let mut prev_env = HashMap::new();\n@@ -38,7 +38,11 @@ impl ProcMacroSrv {\n             env::set_var(k, v);\n         }\n \n-        let result = expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref());\n+        let macro_body = task.macro_body.to_subtree();\n+        let attributes = task.attributes.map(|it| it.to_subtree());\n+        let result = expander\n+            .expand(&task.macro_name, &macro_body, attributes.as_ref())\n+            .map(|it| FlatTree::new(&it));\n \n         for (k, _) in &task.env {\n             match &prev_env[k.as_str()] {"}]}