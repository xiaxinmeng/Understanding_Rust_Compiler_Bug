{"sha": "fe69a5cf0cba9943311b350af0bc800f52c6adbd", "node_id": "C_kwDOAAsO6NoAKGZlNjlhNWNmMGNiYTk5NDMzMTFiMzUwYWYwYmM4MDBmNTJjNmFkYmQ", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-22T14:27:20Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-22T14:27:20Z"}, "message": "dont canonicalize in try_unify_abstract_consts and erase regions instead", "tree": {"sha": "1c144f294436ceaef297b9cc6a1e54b4fef1cb67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c144f294436ceaef297b9cc6a1e54b4fef1cb67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe69a5cf0cba9943311b350af0bc800f52c6adbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe69a5cf0cba9943311b350af0bc800f52c6adbd", "html_url": "https://github.com/rust-lang/rust/commit/fe69a5cf0cba9943311b350af0bc800f52c6adbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe69a5cf0cba9943311b350af0bc800f52c6adbd/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ff1edbe5e38cede450d926d2761191f07bb0af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff1edbe5e38cede450d926d2761191f07bb0af1", "html_url": "https://github.com/rust-lang/rust/commit/8ff1edbe5e38cede450d926d2761191f07bb0af1"}], "stats": {"total": 51, "additions": 22, "deletions": 29}, "files": [{"sha": "a779e38a16989c0e12cfdc69f5094d23666e8145", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe69a5cf0cba9943311b350af0bc800f52c6adbd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69a5cf0cba9943311b350af0bc800f52c6adbd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=fe69a5cf0cba9943311b350af0bc800f52c6adbd", "patch": "@@ -70,7 +70,6 @@ mod sub;\n pub mod type_variable;\n mod undo_log;\n \n-use crate::infer::canonical::OriginalQueryValues;\n pub use rustc_middle::infer::unify_key;\n \n #[must_use]\n@@ -695,14 +694,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> bool {\n         // Reject any attempt to unify two unevaluated constants that contain inference\n         // variables, since inference variables in queries lead to ICEs.\n-        if a.substs.has_infer_types_or_consts() || b.substs.has_infer_types_or_consts() {\n-            debug!(\"a or b contain infer vars in its substs -> cannot unify\");\n+        if a.substs.has_infer_types_or_consts()\n+            || b.substs.has_infer_types_or_consts()\n+            || param_env.has_infer_types_or_consts()\n+        {\n+            debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n             return false;\n         }\n \n-        let canonical = self.canonicalize_query((a, b), &mut OriginalQueryValues::default());\n+        let erased_args = self.tcx.erase_regions((a, b));\n+        let erased_param_env = self.tcx.erase_regions(param_env);\n+        debug!(\"after erase_regions args: {:?}, param_env: {:?}\", erased_args, param_env);\n \n-        self.tcx.try_unify_abstract_consts(param_env.and(canonical.value))\n+        self.tcx.try_unify_abstract_consts(erased_param_env.and(erased_args))\n     }\n \n     pub fn is_in_snapshot(&self) -> bool {\n@@ -1619,9 +1623,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // variables\n         if substs.has_infer_types_or_consts() {\n             debug!(\"substs have infer types or consts: {:?}\", substs);\n-            if substs.has_infer_types_or_consts() {\n-                return Err(ErrorHandled::TooGeneric);\n-            }\n+            return Err(ErrorHandled::TooGeneric);\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);"}, {"sha": "93810cb00cfdd6e9a90e8aa7f72fc3b78d88e477", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe69a5cf0cba9943311b350af0bc800f52c6adbd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69a5cf0cba9943311b350af0bc800f52c6adbd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=fe69a5cf0cba9943311b350af0bc800f52c6adbd", "patch": "@@ -195,11 +195,13 @@ fn satisfied_from_param_env<'tcx>(\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::ConstEvaluatable(uv) => {\n                 if let Some(b_ct) = AbstractConst::new(tcx, uv)? {\n+                    let const_unify_ctxt = ConstUnifyCtxt::new(tcx, param_env);\n+\n                     // Try to unify with each subtree in the AbstractConst to allow for\n                     // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n                     // predicate for `(N + 1) * 2`\n                     let result = walk_abstract_const(tcx, b_ct, |b_ct| {\n-                        match try_unify(tcx, ct, b_ct, param_env) {\n+                        match const_unify_ctxt.try_unify(ct, b_ct) {\n                             true => ControlFlow::BREAK,\n                             false => ControlFlow::CONTINUE,\n                         }\n@@ -569,18 +571,6 @@ pub(super) fn thir_abstract_const<'tcx>(\n     }\n }\n \n-/// Tries to unify two abstract constants using structural equality.\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(super) fn try_unify<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    a: AbstractConst<'tcx>,\n-    b: AbstractConst<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    let const_unify_ctxt = ConstUnifyCtxt::new(tcx, param_env);\n-    const_unify_ctxt.try_unify_inner(a, b)\n-}\n-\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n@@ -589,7 +579,8 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     (|| {\n         if let Some(a) = AbstractConst::new(tcx, a)? {\n             if let Some(b) = AbstractConst::new(tcx, b)? {\n-                return Ok(try_unify(tcx, a, b, param_env));\n+                let const_unify_ctxt = ConstUnifyCtxt::new(tcx, param_env);\n+                return Ok(const_unify_ctxt.try_unify(a, b));\n             }\n         }\n \n@@ -666,7 +657,7 @@ impl<'tcx> ConstUnifyCtxt<'tcx> {\n \n     /// Tries to unify two abstract constants using structural equality.\n     #[instrument(skip(self), level = \"debug\")]\n-    fn try_unify_inner(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+    fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n         let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n             a\n         } else {\n@@ -723,23 +714,23 @@ impl<'tcx> ConstUnifyCtxt<'tcx> {\n                 }\n             }\n             (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-                self.try_unify_inner(a.subtree(al), b.subtree(bl))\n-                    && self.try_unify_inner(a.subtree(ar), b.subtree(br))\n+                self.try_unify(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify(a.subtree(ar), b.subtree(br))\n             }\n             (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-                self.try_unify_inner(a.subtree(av), b.subtree(bv))\n+                self.try_unify(a.subtree(av), b.subtree(bv))\n             }\n             (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n                 if a_args.len() == b_args.len() =>\n             {\n-                self.try_unify_inner(a.subtree(a_f), b.subtree(b_f))\n+                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n                     && iter::zip(a_args, b_args)\n-                        .all(|(&an, &bn)| self.try_unify_inner(a.subtree(an), b.subtree(bn)))\n+                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n             }\n             (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n                 if (a_ty == b_ty) && (a_kind == b_kind) =>\n             {\n-                self.try_unify_inner(a.subtree(a_operand), b.subtree(b_operand))\n+                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n             }\n             // use this over `_ => false` to make adding variants to `Node` less error prone\n             (Node::Cast(..), _)"}]}