{"sha": "ef3e33bd16b1392f8f238c1224cd58d5fb95b555", "node_id": "C_kwDOAAsO6NoAKGVmM2UzM2JkMTZiMTM5MmY4ZjIzOGMxMjI0Y2Q1OGQ1ZmI5NWI1NTU", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-03-08T02:51:53Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-03-08T02:51:53Z"}, "message": "unix: Avoid name conversions in `remove_dir_all_recursive`\n\nEach recursive call was creating an `OsString` for a `&Path`, only for\nit to be turned into a `CString` right away. Instead we can directly\npass `.name_cstr()`, saving two allocations each time.", "tree": {"sha": "2236c9fe27fd00973a0b82f7bd2184c98c043834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2236c9fe27fd00973a0b82f7bd2184c98c043834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3e33bd16b1392f8f238c1224cd58d5fb95b555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3e33bd16b1392f8f238c1224cd58d5fb95b555", "html_url": "https://github.com/rust-lang/rust/commit/ef3e33bd16b1392f8f238c1224cd58d5fb95b555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3e33bd16b1392f8f238c1224cd58d5fb95b555/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03918badd33d255de806b4a9a8aa75b031ed0738", "url": "https://api.github.com/repos/rust-lang/rust/commits/03918badd33d255de806b4a9a8aa75b031ed0738", "html_url": "https://github.com/rust-lang/rust/commit/03918badd33d255de806b4a9a8aa75b031ed0738"}], "stats": {"total": 19, "additions": 9, "deletions": 10}, "files": [{"sha": "4a48be5cda69598725feecf7dbb769717cdc62a3", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef3e33bd16b1392f8f238c1224cd58d5fb95b555/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3e33bd16b1392f8f238c1224cd58d5fb95b555/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=ef3e33bd16b1392f8f238c1224cd58d5fb95b555", "patch": "@@ -1604,17 +1604,15 @@ mod remove_dir_impl {\n         }\n     }\n \n-    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n-        let pcstr = cstr(p)?;\n-\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, path: &CStr) -> io::Result<()> {\n         // try opening as directory\n-        let fd = match openat_nofollow_dironly(parent_fd, &pcstr) {\n+        let fd = match openat_nofollow_dironly(parent_fd, &path) {\n             Err(err) if err.raw_os_error() == Some(libc::ENOTDIR) => {\n                 // not a directory - don't traverse further\n                 return match parent_fd {\n                     // unlink...\n                     Some(parent_fd) => {\n-                        cvt(unsafe { unlinkat(parent_fd, pcstr.as_ptr(), 0) }).map(drop)\n+                        cvt(unsafe { unlinkat(parent_fd, path.as_ptr(), 0) }).map(drop)\n                     }\n                     // ...unless this was supposed to be the deletion root directory\n                     None => Err(err),\n@@ -1627,26 +1625,27 @@ mod remove_dir_impl {\n         let (dir, fd) = fdreaddir(fd)?;\n         for child in dir {\n             let child = child?;\n+            let child_name = child.name_cstr();\n             match is_dir(&child) {\n                 Some(true) => {\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    remove_dir_all_recursive(Some(fd), child_name)?;\n                 }\n                 Some(false) => {\n-                    cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n+                    cvt(unsafe { unlinkat(fd, child_name.as_ptr(), 0) })?;\n                 }\n                 None => {\n                     // POSIX specifies that calling unlink()/unlinkat(..., 0) on a directory can succeed\n                     // if the process has the appropriate privileges. This however can causing orphaned\n                     // directories requiring an fsck e.g. on Solaris and Illumos. So we try recursing\n                     // into it first instead of trying to unlink() it.\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    remove_dir_all_recursive(Some(fd), child_name)?;\n                 }\n             }\n         }\n \n         // unlink the directory after removing its contents\n         cvt(unsafe {\n-            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), pcstr.as_ptr(), libc::AT_REMOVEDIR)\n+            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), path.as_ptr(), libc::AT_REMOVEDIR)\n         })?;\n         Ok(())\n     }\n@@ -1659,7 +1658,7 @@ mod remove_dir_impl {\n         if attr.file_type().is_symlink() {\n             crate::fs::remove_file(p)\n         } else {\n-            remove_dir_all_recursive(None, p)\n+            remove_dir_all_recursive(None, &cstr(p)?)\n         }\n     }\n "}]}