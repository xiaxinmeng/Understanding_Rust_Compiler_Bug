{"sha": "ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMDRhYThlMzg1ZjM0M2Y2NmM1YmVkNmEzNGQxZWJmNmM5NzFlNGQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-02-24T07:17:02Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-04-20T01:41:18Z"}, "message": "Allow inheritance between structs.\n\nNo subtyping, no interaction with traits. Partially addresses #9912.", "tree": {"sha": "9c0845b6a369ab071138f6c542e7aef46ff5a2a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c0845b6a369ab071138f6c542e7aef46ff5a2a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "html_url": "https://github.com/rust-lang/rust/commit/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3757f01c9bed7b2fe0d726ac45c754312e2917ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/3757f01c9bed7b2fe0d726ac45c754312e2917ea", "html_url": "https://github.com/rust-lang/rust/commit/3757f01c9bed7b2fe0d726ac45c754312e2917ea"}], "stats": {"total": 1011, "additions": 803, "deletions": 208}, "files": [{"sha": "7b402cd4b16d43f73870a43f04fa5df34175aeeb", "filename": "src/doc/rust.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -1214,6 +1214,22 @@ struct Cookie;\n let c = [Cookie, Cookie, Cookie, Cookie];\n ~~~~\n \n+By using the `struct_inherit` feature gate, structures may use single inheritance. A Structure may only\n+inherit from a single other structure, called the _super-struct_. The inheriting structure (sub-struct)\n+acts as if all fields in the super-struct were present in the sub-struct. Fields declared in a sub-struct\n+must not have the same name as any field in any (transitive) super-struct. All fields (both declared\n+and inherited) must be specified in any initializers. Inheritance between structures does not give\n+subtyping or coercion. The super-struct and sub-struct must be defined in the same crate. The super-struct\n+must be declared using the `virtual` keyword.\n+For example:\n+\n+~~~~ {.ignore}\n+virtual struct Sup { x: int }\n+struct Sub : Sup { y: int }\n+let s = Sub {x: 10, y: 11};\n+let sx = s.x;\n+~~~~\n+\n ### Enumerations\n \n An _enumeration_ is a simultaneous definition of a nominal [enumerated type](#enumerated-types) as well as a set of *constructors*,"}, {"sha": "e630d7e15e03936054c25e02215739a01fe14f40", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -151,6 +151,8 @@ fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n     @ast::StructDef {\n         fields: fields.collect(),\n         ctor_id: def.ctor_id,\n+        super_struct: def.super_struct.clone(),\n+        is_virtual: def.is_virtual,\n     }\n }\n "}, {"sha": "0f76075656e0203f3e08694bcb58622a29428c9b", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -55,6 +55,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"default_type_params\", Active),\n     (\"quote\", Active),\n     (\"linkage\", Active),\n+    (\"struct_inherit\", Active),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n@@ -190,11 +191,22 @@ impl<'a> Visitor<()> for Context<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(..) => {\n+            ast::ItemStruct(struct_definition, _) => {\n                 if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }\n+                match struct_definition.super_struct {\n+                    Some(ref path) => self.gate_feature(\"struct_inherit\", path.span,\n+                                                        \"struct inheritance is experimental \\\n+                                                         and possibly buggy\"),\n+                    None => {}\n+                }\n+                if struct_definition.is_virtual {\n+                    self.gate_feature(\"struct_inherit\", i.span,\n+                                      \"struct inheritance (`virtual` keyword) is \\\n+                                       experimental and possibly buggy\");\n+                }\n             }\n \n             _ => {}"}, {"sha": "4a0b3ea0cf6a03c11b2042e42984c60776cbf1d0", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -92,6 +92,7 @@ pub static tag_path_len: uint = 0x25;\n pub static tag_path_elem_mod: uint = 0x26;\n pub static tag_path_elem_name: uint = 0x27;\n pub static tag_item_field: uint = 0x28;\n+pub static tag_item_field_origin: uint = 0x29;\n \n pub static tag_item_variances: uint = 0x2a;\n /*\n@@ -102,43 +103,43 @@ pub static tag_item_variances: uint = 0x2a;\n   both, tag_item_trait_method and tag_item_impl_method have to be two\n   different tags.\n  */\n-pub static tag_item_impl_method: uint = 0x2c;\n-pub static tag_item_trait_method_explicit_self: uint = 0x2d;\n+pub static tag_item_impl_method: uint = 0x30;\n+pub static tag_item_trait_method_explicit_self: uint = 0x31;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-pub static tag_items_data_item_reexport: uint = 0x2f;\n-pub static tag_items_data_item_reexport_def_id: uint = 0x30;\n-pub static tag_items_data_item_reexport_name: uint = 0x31;\n+pub static tag_items_data_item_reexport: uint = 0x38;\n+pub static tag_items_data_item_reexport_def_id: uint = 0x39;\n+pub static tag_items_data_item_reexport_name: uint = 0x3a;\n \n // used to encode crate_ctxt side tables\n #[deriving(Eq)]\n #[repr(uint)]\n-pub enum astencode_tag { // Reserves 0x32 -- 0x45\n-    tag_ast = 0x32,\n-\n-    tag_tree = 0x33,\n-\n-    tag_id_range = 0x34,\n-\n-    tag_table = 0x35,\n-    tag_table_id = 0x36,\n-    tag_table_val = 0x37,\n-    tag_table_def = 0x38,\n-    tag_table_node_type = 0x39,\n-    tag_table_node_type_subst = 0x3a,\n-    tag_table_freevars = 0x3b,\n-    tag_table_tcache = 0x3c,\n-    tag_table_param_defs = 0x3d,\n-    tag_table_mutbl = 0x3e,\n-    tag_table_last_use = 0x3f,\n-    tag_table_spill = 0x40,\n-    tag_table_method_map = 0x41,\n-    tag_table_vtable_map = 0x42,\n-    tag_table_adjustments = 0x43,\n-    tag_table_moves_map = 0x44,\n-    tag_table_capture_map = 0x45\n+pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n+    tag_ast = 0x40,\n+\n+    tag_tree = 0x41,\n+\n+    tag_id_range = 0x42,\n+\n+    tag_table = 0x43,\n+    tag_table_id = 0x44,\n+    tag_table_val = 0x45,\n+    tag_table_def = 0x46,\n+    tag_table_node_type = 0x47,\n+    tag_table_node_type_subst = 0x48,\n+    tag_table_freevars = 0x49,\n+    tag_table_tcache = 0x4a,\n+    tag_table_param_defs = 0x4b,\n+    tag_table_mutbl = 0x4c,\n+    tag_table_last_use = 0x4d,\n+    tag_table_spill = 0x4e,\n+    tag_table_method_map = 0x4f,\n+    tag_table_vtable_map = 0x50,\n+    tag_table_adjustments = 0x51,\n+    tag_table_moves_map = 0x52,\n+    tag_table_capture_map = 0x53\n }\n static first_astencode_tag: uint = tag_ast as uint;\n static last_astencode_tag: uint = tag_table_capture_map as uint;\n@@ -151,9 +152,9 @@ impl astencode_tag {\n     }\n }\n \n-pub static tag_item_trait_method_sort: uint = 0x46;\n+pub static tag_item_trait_method_sort: uint = 0x60;\n \n-pub static tag_item_impl_type_basename: uint = 0x47;\n+pub static tag_item_impl_type_basename: uint = 0x61;\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -162,42 +163,42 @@ pub static tag_item_impl_type_basename: uint = 0x47;\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-pub static tag_lang_items: uint = 0x48;\n-pub static tag_lang_items_item: uint = 0x49;\n-pub static tag_lang_items_item_id: uint = 0x4a;\n-pub static tag_lang_items_item_node_id: uint = 0x4b;\n+pub static tag_lang_items: uint = 0x70;\n+pub static tag_lang_items_item: uint = 0x71;\n+pub static tag_lang_items_item_id: uint = 0x72;\n+pub static tag_lang_items_item_node_id: uint = 0x73;\n \n-pub static tag_item_unnamed_field: uint = 0x4c;\n-pub static tag_items_data_item_visibility: uint = 0x4e;\n+pub static tag_item_unnamed_field: uint = 0x74;\n+pub static tag_items_data_item_visibility: uint = 0x76;\n \n-pub static tag_item_method_tps: uint = 0x51;\n-pub static tag_item_method_fty: uint = 0x52;\n+pub static tag_item_method_tps: uint = 0x79;\n+pub static tag_item_method_fty: uint = 0x7a;\n \n-pub static tag_mod_child: uint = 0x53;\n-pub static tag_misc_info: uint = 0x54;\n-pub static tag_misc_info_crate_items: uint = 0x55;\n+pub static tag_mod_child: uint = 0x7b;\n+pub static tag_misc_info: uint = 0x7c;\n+pub static tag_misc_info_crate_items: uint = 0x7d;\n \n-pub static tag_item_method_provided_source: uint = 0x56;\n-pub static tag_item_impl_vtables: uint = 0x57;\n+pub static tag_item_method_provided_source: uint = 0x7e;\n+pub static tag_item_impl_vtables: uint = 0x7f;\n \n-pub static tag_impls: uint = 0x58;\n-pub static tag_impls_impl: uint = 0x59;\n+pub static tag_impls: uint = 0x80;\n+pub static tag_impls_impl: uint = 0x81;\n \n-pub static tag_items_data_item_inherent_impl: uint = 0x5a;\n-pub static tag_items_data_item_extension_impl: uint = 0x5b;\n+pub static tag_items_data_item_inherent_impl: uint = 0x82;\n+pub static tag_items_data_item_extension_impl: uint = 0x83;\n \n-pub static tag_region_param_def: uint = 0x5c;\n-pub static tag_region_param_def_ident: uint = 0x5d;\n-pub static tag_region_param_def_def_id: uint = 0x5e;\n+pub static tag_region_param_def: uint = 0x84;\n+pub static tag_region_param_def_ident: uint = 0x85;\n+pub static tag_region_param_def_def_id: uint = 0x86;\n \n-pub static tag_native_libraries: uint = 0x5f;\n-pub static tag_native_libraries_lib: uint = 0x60;\n-pub static tag_native_libraries_name: uint = 0x61;\n-pub static tag_native_libraries_kind: uint = 0x62;\n+pub static tag_native_libraries: uint = 0x87;\n+pub static tag_native_libraries_lib: uint = 0x88;\n+pub static tag_native_libraries_name: uint = 0x89;\n+pub static tag_native_libraries_kind: uint = 0x8a;\n \n-pub static tag_macro_registrar_fn: uint = 0x63;\n-pub static tag_exported_macros: uint = 0x64;\n-pub static tag_macro_def: uint = 0x65;\n+pub static tag_macro_registrar_fn: uint = 0x8b;\n+pub static tag_exported_macros: uint = 0x8c;\n+pub static tag_macro_def: uint = 0x8d;\n \n #[deriving(Clone, Show)]\n pub struct LinkMeta {"}, {"sha": "b1cede8e410c494c6bab9bba47938cb6ca85a7e6", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -975,21 +975,27 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n             // FIXME #6993: name should be of type Name, not Ident\n             let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n+            let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n+            let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n             result.push(ty::field_ty {\n                 name: name.name,\n-                id: did, vis:\n-                struct_field_family_to_visibility(f),\n+                id: did,\n+                vis: struct_field_family_to_visibility(f),\n+                origin: origin_id,\n             });\n         }\n         true\n     });\n     reader::tagged_docs(item, tag_item_unnamed_field, |an_item| {\n         let did = item_def_id(an_item, cdata);\n+        let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n+        let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n             vis: struct_field_family_to_visibility(f),\n+            origin: origin_id,\n         });\n         true\n     });"}, {"sha": "f4c3f5640682ffa8b6900557053cd8bac3facf6d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -290,23 +290,22 @@ fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(ebml_w: &mut Encoder,\n-                        def: @StructDef) {\n-    for f in def.fields.iter() {\n-        match f.node.kind {\n-            NamedField(ident, vis) => {\n-               ebml_w.start_tag(tag_item_field);\n-               encode_struct_field_family(ebml_w, vis);\n-               encode_name(ebml_w, ident.name);\n-               encode_def_id(ebml_w, local_def(f.node.id));\n-               ebml_w.end_tag();\n-            }\n-            UnnamedField(vis) => {\n-                ebml_w.start_tag(tag_item_unnamed_field);\n-                encode_struct_field_family(ebml_w, vis);\n-                encode_def_id(ebml_w, local_def(f.node.id));\n-                ebml_w.end_tag();\n-            }\n+                        fields: &Vec<ty::field_ty>,\n+                        origin: DefId) {\n+    for f in fields.iter() {\n+        if f.name == special_idents::unnamed_field.name {\n+            ebml_w.start_tag(tag_item_unnamed_field);\n+        } else {\n+            ebml_w.start_tag(tag_item_field);\n+            encode_name(ebml_w, f.name);\n         }\n+        encode_struct_field_family(ebml_w, f.vis);\n+        encode_def_id(ebml_w, f.id);\n+        ebml_w.start_tag(tag_item_field_origin);\n+        let s = def_to_str(origin);\n+        ebml_w.writer.write(s.as_bytes());\n+        ebml_w.end_tag();\n+        ebml_w.end_tag();\n     }\n }\n \n@@ -344,12 +343,13 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n             ast::TupleVariantKind(_) => {},\n-            ast::StructVariantKind(def) => {\n+            ast::StructVariantKind(_) => {\n+                let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  ebml_w,\n-                                                 def.fields.as_slice(),\n+                                                 &fields,\n                                                  index);\n-                encode_struct_fields(ebml_w, def);\n+                encode_struct_fields(ebml_w, &fields, def_id);\n                 let bkts = create_index(idx);\n                 encode_index(ebml_w, bkts, write_i64);\n             }\n@@ -666,7 +666,7 @@ fn encode_provided_source(ebml_w: &mut Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut Encoder,\n-                          fields: &[StructField],\n+                          fields: &Vec<ty::field_ty>,\n                           global_index: @RefCell<Vec<entry<i64>> >)\n                           -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n@@ -676,22 +676,19 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n     for field in fields.iter() {\n-        let (nm, vis) = match field.node.kind {\n-            NamedField(nm, vis) => (nm, vis),\n-            UnnamedField(vis) => (special_idents::unnamed_field, vis)\n-        };\n+        let nm = field.name;\n+        let id = field.id.node;\n \n-        let id = field.node.id;\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n         global_index.borrow_mut().push(entry {\n             val: id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n-               token::get_ident(nm), id);\n-        encode_struct_field_family(ebml_w, vis);\n-        encode_name(ebml_w, nm.name);\n+               token::get_name(nm), id);\n+        encode_struct_field_family(ebml_w, field.vis);\n+        encode_name(ebml_w, nm);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n         encode_def_id(ebml_w, local_def(id));\n         ebml_w.end_tag();\n@@ -983,12 +980,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  generics);\n       }\n       ItemStruct(struct_def, _) => {\n+        let fields = ty::lookup_struct_fields(tcx, def_id);\n+\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_struct(ecx, ebml_w,\n-                                         struct_def.fields.as_slice(), index);\n+        let idx = encode_info_for_struct(ecx,\n+                                         ebml_w,\n+                                         &fields,\n+                                         index);\n \n         /* Index the class*/\n         add_to_index(item, ebml_w, index);\n@@ -1008,7 +1009,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(ebml_w, struct_def);\n+        encode_struct_fields(ebml_w, &fields, def_id);\n \n         (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n "}, {"sha": "59d4c2e03d499b75b70952085cb0c77d17eecd25", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -488,7 +488,7 @@ impl<'a> PrivacyVisitor<'a> {\n         // members, so that's why we test the parent, and not the did itself.\n         let mut cur = self.curitem;\n         loop {\n-            debug!(\"privacy - questioning {}\", self.nodestr(cur));\n+            debug!(\"privacy - questioning {}, {:?}\", self.nodestr(cur), cur);\n             match cur {\n                 // If the relevant parent is in our history, then we're allowed\n                 // to look inside any of our ancestor's immediate private items,\n@@ -554,11 +554,14 @@ impl<'a> PrivacyVisitor<'a> {\n     }\n \n     // Checks that a field is in scope.\n-    fn check_field(&mut self, span: Span, id: ast::DefId,\n+    fn check_field(&mut self,\n+                   span: Span,\n+                   id: ast::DefId,\n                    name: FieldName) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         let field = match name {\n             NamedField(ident) => {\n+                debug!(\"privacy - check named field {} in struct {}\", ident.name, id);\n                 fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n             UnnamedField(idx) => fields.get(idx)"}, {"sha": "9112434b12c83666d5ab3081f6d6672ca51bc1e1", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -3708,6 +3708,7 @@ impl<'a> Resolver<'a> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n+                                    struct_def.super_struct,\n                                     struct_def.fields.as_slice());\n             }\n \n@@ -3922,30 +3923,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_struct(&mut self,\n-                          id: NodeId,\n-                          generics: &Generics,\n-                          fields: &[StructField]) {\n-        let mut ident_map: HashMap<ast::Ident, &StructField> = HashMap::new();\n-        for field in fields.iter() {\n-            match field.node.kind {\n-                NamedField(ident, _) => {\n-                    match ident_map.find(&ident) {\n-                        Some(&prev_field) => {\n-                            let ident_str = token::get_ident(ident);\n-                            self.resolve_error(field.span,\n-                                format!(\"field `{}` is already declared\", ident_str));\n-                            self.session.span_note(prev_field.span,\n-                                \"previously declared here\");\n-                        },\n-                        None => {\n-                            ident_map.insert(ident, field);\n-                        }\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-\n+                      id: NodeId,\n+                      generics: &Generics,\n+                      super_struct: Option<P<Ty>>,\n+                      fields: &[StructField]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                        id,\n@@ -3955,6 +3936,39 @@ impl<'a> Resolver<'a> {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n \n+            // Resolve the super struct.\n+            match super_struct {\n+                Some(t) => match t.node {\n+                    TyPath(ref path, None, path_id) => {\n+                        match this.resolve_path(id, path, TypeNS, true) {\n+                            Some((DefTy(def_id), lp)) if this.structs.contains(&def_id) => {\n+                                let def = DefStruct(def_id);\n+                                debug!(\"(resolving struct) resolved `{}` to type {:?}\",\n+                                       token::get_ident(path.segments\n+                                                            .last().unwrap()\n+                                                            .identifier),\n+                                       def);\n+                                debug!(\"(resolving struct) writing resolution for `{}` (id {})\",\n+                                       this.path_idents_to_str(path),\n+                                       path_id);\n+                                this.record_def(path_id, (def, lp));\n+                            }\n+                            Some((DefStruct(_), _)) => {\n+                                this.session.span_err(t.span,\n+                                                      \"super-struct is defined \\\n+                                                       in a different crate\")\n+                            },\n+                            Some(_) => this.session.span_err(t.span,\n+                                                             \"super-struct is not a struct type\"),\n+                            None => this.session.span_err(t.span,\n+                                                          \"super-struct could not be resolved\"),\n+                        }\n+                    },\n+                    _ => this.session.span_bug(t.span, \"path not mapped to a TyPath\")\n+                },\n+                None => {}\n+            }\n+\n             // Resolve fields.\n             for field in fields.iter() {\n                 this.resolve_type(field.node.ty);"}, {"sha": "e32ab1fc8e39a10c4199e65884f82b8c4dc4bdde", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -52,7 +52,6 @@ use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n use syntax::owned_slice::OwnedSlice;\n use syntax::abi;\n-use syntax;\n use collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n@@ -150,10 +149,12 @@ pub enum TraitStore {\n     RegionTraitStore(Region, ast::Mutability),\n }\n \n+#[deriving(Clone)]\n pub struct field_ty {\n     pub name: Name,\n     pub id: DefId,\n     pub vis: ast::Visibility,\n+    pub origin: ast::DefId,  // The DefId of the struct in which the field is declared.\n }\n \n // Contains information needed to resolve types and (in the future) look up\n@@ -303,6 +304,8 @@ pub struct ctxt {\n     // A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n     pub supertraits: RefCell<DefIdMap<@Vec<@TraitRef> >>,\n+    pub superstructs: RefCell<DefIdMap<Option<ast::DefId>>>,\n+    pub struct_fields: RefCell<DefIdMap<@Vec<field_ty>>>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n@@ -1115,6 +1118,8 @@ pub fn mk_ctxt(s: Session,\n         lang_items: lang_items,\n         provided_method_sources: RefCell::new(DefIdMap::new()),\n         supertraits: RefCell::new(DefIdMap::new()),\n+        superstructs: RefCell::new(DefIdMap::new()),\n+        struct_fields: RefCell::new(DefIdMap::new()),\n         destructor_for_type: RefCell::new(DefIdMap::new()),\n         destructors: RefCell::new(DefIdSet::new()),\n         trait_impls: RefCell::new(DefIdMap::new()),\n@@ -3987,60 +3992,70 @@ pub fn lookup_field_type(tcx: &ctxt,\n     subst(tcx, substs, t)\n }\n \n-// Look up the list of field names and IDs for a given struct\n+// Lookup all ancestor structs of a struct indicated by did. That is the reflexive,\n+// transitive closure of doing a single lookup in cx.superstructs.\n+fn lookup_super_structs(cx: &ctxt,\n+                            did: ast::DefId) -> Vec<DefId> {\n+    let mut this_result: Vec<DefId> = vec!(did);\n+    match cx.superstructs.borrow().find(&did) {\n+        Some(&Some(def_id)) => {\n+            let ss: Vec<DefId> = lookup_super_structs(cx, def_id);\n+            this_result.extend(ss.move_iter());\n+            this_result\n+        },\n+        Some(&None) => this_result,\n+        None => {\n+            cx.sess.bug(\n+                format!(\"ID not mapped to super-struct: {}\",\n+                    cx.map.node_to_str(did.node)));\n+        }\n+    }\n+}\n+\n+// Look up the list of field names and IDs for a given struct.\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n     if did.krate == ast::LOCAL_CRATE {\n-        match cx.map.find(did.node) {\n-            Some(ast_map::NodeItem(i)) => {\n-                match i.node {\n-                    ast::ItemStruct(struct_def, _) => {\n-                        struct_field_tys(struct_def.fields.as_slice())\n-                    }\n-                    _ => cx.sess.bug(\"struct ID bound to non-struct\")\n-                }\n-            }\n-            Some(ast_map::NodeVariant(ref variant)) => {\n-                match (*variant).node.kind {\n-                    ast::StructVariantKind(struct_def) => {\n-                        struct_field_tys(struct_def.fields.as_slice())\n-                    }\n-                    _ => {\n-                        cx.sess.bug(\"struct ID bound to enum variant that \\\n-                                    isn't struct-like\")\n-                    }\n+        // We store the fields which are syntactically in each struct in cx. So\n+        // we have to walk the inheritance chain of the struct to get all the\n+        // structs (explicit and inherited) for a struct. If this is expensive\n+        // we could cache the whole list of fields here.\n+        let structs = lookup_super_structs(cx, did);\n+        let struct_fields = cx.struct_fields.borrow();\n+        let results: Vec<&@Vec<field_ty>> = structs.iter().map(|s| {\n+            match struct_fields.find(s) {\n+                Some(fields) => fields,\n+                _ => {\n+                    cx.sess.bug(\n+                        format!(\"ID not mapped to struct fields: {}\",\n+                            cx.map.node_to_str(did.node)));\n                 }\n             }\n-            _ => {\n-                cx.sess.bug(\n-                    format!(\"struct ID not bound to an item: {}\",\n-                        cx.map.node_to_str(did.node)));\n+        }).collect();\n+\n+        let len = results.iter().map(|x| x.len()).fold(0, |a, b| a + b);\n+        let mut result: Vec<field_ty> = Vec::with_capacity(len);\n+        for rs in results.iter() {\n+            for r in rs.iter() {\n+                result.push(*r);\n             }\n         }\n+        assert!(result.len() == len);\n+        result\n     } else {\n         csearch::get_struct_fields(&cx.sess.cstore, did)\n     }\n }\n \n-fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n-    fields.iter().map(|field| {\n-        match field.node.kind {\n-            NamedField(ident, visibility) => {\n-                field_ty {\n-                    name: ident.name,\n-                    id: ast_util::local_def(field.node.id),\n-                    vis: visibility,\n-                }\n-            }\n-            UnnamedField(visibility) => {\n-                field_ty {\n-                    name: syntax::parse::token::special_idents::unnamed_field.name,\n-                    id: ast_util::local_def(field.node.id),\n-                    vis: visibility,\n-                }\n-            }\n-        }\n-    }).collect()\n+pub fn lookup_struct_field(cx: &ctxt,\n+                           parent: ast::DefId,\n+                           field_id: ast::DefId)\n+                        -> field_ty {\n+    let r = lookup_struct_fields(cx, parent);\n+    match r.iter().find(|f| f.id.node == field_id.node) {\n+        Some(t) => *t,\n+        None => cx.sess.bug(\"struct ID not found in parent's fields\")\n+    }\n }\n \n // Returns a list of fields corresponding to the struct's items. trans uses"}, {"sha": "f640b5dc9be0f30318d2b79d1882bb226d4409b4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -122,6 +122,7 @@ use std::vec::Vec;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_util::local_def;\n use syntax::ast_util;\n use syntax::attr;\n@@ -509,6 +510,57 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     fcx\n }\n \n+fn span_for_field(tcx: &ty::ctxt, field: &ty::field_ty, struct_id: ast::DefId) -> Span {\n+    assert!(field.id.krate == ast::LOCAL_CRATE);\n+    let item = match tcx.map.find(struct_id.node) {\n+        Some(ast_map::NodeItem(item)) => item,\n+        None => fail!(\"node not in ast map: {}\", struct_id.node),\n+        _ => fail!(\"expected item, found {}\", tcx.map.node_to_str(struct_id.node))\n+    };\n+\n+    match item.node {\n+        ast::ItemStruct(struct_def, _) => {\n+            match struct_def.fields.iter().find(|f| match f.node.kind {\n+                ast::NamedField(ident, _) => ident.name == field.name,\n+                _ => false,\n+            }) {\n+                Some(f) => f.span,\n+                None => tcx.sess.bug(format!(\"Could not find field {}\",\n+                                             token::get_name(field.name))),\n+            }\n+        },\n+        _ => tcx.sess.bug(\"Field found outside of a struct?\"),\n+    }\n+}\n+\n+// Check struct fields are uniquely named wrt parents.\n+fn check_for_field_shadowing(tcx: &ty::ctxt,\n+                             id: ast::DefId) {\n+    let struct_fields = tcx.struct_fields.borrow();\n+    let fields = struct_fields.get(&id);\n+\n+    let superstructs = tcx.superstructs.borrow();\n+    let super_struct = superstructs.get(&id);\n+    match *super_struct {\n+        Some(parent_id) => {\n+            let super_fields = ty::lookup_struct_fields(tcx, parent_id);\n+            for f in fields.iter() {\n+                match super_fields.iter().find(|sf| f.name == sf.name) {\n+                    Some(prev_field) => {\n+                        tcx.sess.span_err(span_for_field(tcx, f, id),\n+                            format!(\"field `{}` hides field declared in super-struct\",\n+                                    token::get_name(f.name)));\n+                        tcx.sess.span_note(span_for_field(tcx, prev_field, parent_id),\n+                            \"previously declared here\");\n+                    },\n+                    None => {}\n+                }\n+            }\n+        },\n+        None => {}\n+    }\n+}\n+\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n@@ -518,6 +570,9 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     // Check that the struct is instantiable\n     check_instantiable(tcx, span, id);\n \n+    // Check there are no overlapping fields in super-structs\n+    check_for_field_shadowing(tcx, local_def(id));\n+\n     if ty::lookup_simd(tcx, local_def(id)) {\n         check_simd(tcx, span, id);\n     }\n@@ -2385,14 +2440,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n         check_struct_or_variant_fields(fcx,\n-                                           struct_type,\n-                                           span,\n-                                           class_id,\n-                                           id,\n-                                           substitutions,\n-                                           class_fields.as_slice(),\n-                                           fields,\n-                                           base_expr.is_none());\n+                                       struct_type,\n+                                       span,\n+                                       class_id,\n+                                       id,\n+                                       substitutions,\n+                                       class_fields.as_slice(),\n+                                       fields,\n+                                       base_expr.is_none());\n         if ty::type_is_error(fcx.node_ty(id)) {\n             struct_type = ty::mk_err();\n         }"}, {"sha": "490a52df2ba7a0ca42425b645791e69801140ed9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 97, "deletions": 11, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -46,7 +46,7 @@ use util::ppaux;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n-use collections::HashSet;\n+use collections::{HashMap, HashSet};\n \n use syntax::abi;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -440,15 +440,35 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n-                     v: &ast::StructField) {\n+                     v: &ast::StructField,\n+                     origin: ast::DefId) -> ty::field_ty {\n     let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n-                          ty::ty_param_bounds_and_ty {\n-                              generics: struct_generics.clone(),\n-                              ty: tt\n-                          });\n+                                       ty::ty_param_bounds_and_ty {\n+                                           generics: struct_generics.clone(),\n+                                           ty: tt\n+                                       });\n+\n+    match v.node.kind {\n+        ast::NamedField(ident, visibility) => {\n+            ty::field_ty {\n+                name: ident.name,\n+                id: local_def(v.node.id),\n+                vis: visibility,\n+                origin: origin,\n+            }\n+        }\n+        ast::UnnamedField(visibility) => {\n+            ty::field_ty {\n+                name: special_idents::unnamed_field.name,\n+                id: local_def(v.node.id),\n+                vis: visibility,\n+                origin: origin,\n+            }\n+        }\n+    }\n }\n \n fn convert_methods(ccx: &CrateCtxt,\n@@ -637,12 +657,21 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         ast::ItemStruct(struct_def, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n \n-            // Write the class type\n+            // Write the class type.\n             let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n \n+            // Write the super-struct type, if it exists.\n+            match struct_def.super_struct {\n+                Some(ty) => {\n+                    let supserty = ccx.to_ty(&ExplicitRscope, ty);\n+                    write_ty_to_tcx(tcx, it.id, supserty);\n+                },\n+                _ => {},\n+            }\n+\n             convert_struct(ccx, struct_def, tpt, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n@@ -671,10 +700,67 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                       id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n-    // Write the type of each of the members\n-    for f in struct_def.fields.iter() {\n-       convert_field(ccx, &tpt.generics, f);\n-    }\n+    // Write the type of each of the members and check for duplicate fields.\n+    let mut seen_fields: HashMap<ast::Name, Span> = HashMap::new();\n+    let field_tys = struct_def.fields.iter().map(|f| {\n+        let result = convert_field(ccx, &tpt.generics, f, local_def(id));\n+\n+        if result.name != special_idents::unnamed_field.name {\n+            let dup = match seen_fields.find(&result.name) {\n+                Some(prev_span) => {\n+                    tcx.sess.span_err(f.span,\n+                        format!(\"field `{}` is already declared\", token::get_name(result.name)));\n+                    tcx.sess.span_note(*prev_span,\n+                        \"previously declared here\");\n+                    true\n+                },\n+                None => false,\n+            };\n+            // FIXME(#6393) this whole dup thing is just to satisfy\n+            // the borrow checker :-(\n+            if !dup {\n+                seen_fields.insert(result.name, f.span);\n+            }\n+        }\n+\n+        result\n+    }).collect();\n+\n+    tcx.struct_fields.borrow_mut().insert(local_def(id), @field_tys);\n+\n+    let super_struct = match struct_def.super_struct {\n+        Some(t) => match t.node {\n+            ast::TyPath(_, _, path_id) => {\n+                let def_map = tcx.def_map.borrow();\n+                match def_map.find(&path_id) {\n+                    Some(&ast::DefStruct(def_id)) => {\n+                        // FIXME(#12511) Check for cycles in the inheritance hierarchy.\n+                        // Check super-struct is virtual.\n+                        match tcx.map.find(def_id.node) {\n+                            Some(ast_map::NodeItem(i)) => match i.node {\n+                                ast::ItemStruct(struct_def, _) => {\n+                                    if !struct_def.is_virtual {\n+                                        tcx.sess.span_err(t.span,\n+                                            \"struct inheritance is only \\\n+                                             allowed from virtual structs\");\n+                                    }\n+                                },\n+                                _ => {},\n+                            },\n+                            _ => {},\n+                        }\n+\n+                        Some(def_id)\n+                    },\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        },\n+        None => None,\n+    };\n+    tcx.superstructs.borrow_mut().insert(local_def(id), super_struct);\n+\n     let substs = mk_item_substs(ccx, &tpt.generics, None);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n "}, {"sha": "2b6f94e6bf5188008b4ab65f54f22157c3cd9145", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -1080,7 +1080,9 @@ pub struct StructDef {\n     pub fields: Vec<StructField>, /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n-    pub ctor_id: Option<NodeId>\n+    pub ctor_id: Option<NodeId>,\n+    pub super_struct: Option<P<Ty>>, // Super struct, if specified.\n+    pub is_virtual: bool,            // True iff the struct may be inherited from.\n }\n \n /*"}, {"sha": "73ad2664be4c078312b400f54e1f46d585bc691d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -235,7 +235,12 @@ pub trait Folder {\n                 kind = StructVariantKind(@ast::StructDef {\n                     fields: struct_def.fields.iter()\n                         .map(|f| self.fold_struct_field(f)).collect(),\n-                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(c))\n+                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(c)),\n+                    super_struct: match struct_def.super_struct {\n+                        Some(t) => Some(self.fold_ty(t)),\n+                        None => None\n+                    },\n+                    is_virtual: struct_def.is_virtual,\n                 })\n             }\n         }\n@@ -480,6 +485,11 @@ fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef\n     @ast::StructDef {\n         fields: struct_def.fields.iter().map(|f| fold_struct_field(f, fld)).collect(),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n+        super_struct: match struct_def.super_struct {\n+            Some(t) => Some(fld.fold_ty(t)),\n+            None => None\n+        },\n+        is_virtual: struct_def.is_virtual,\n     }\n }\n "}, {"sha": "3d09147d8f3026a1efae9ae7851ec6b825f370a5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -3884,11 +3884,26 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse struct Foo { ... }\n-    fn parse_item_struct(&mut self) -> ItemInfo {\n+    fn parse_item_struct(&mut self, is_virtual: bool) -> ItemInfo {\n         let class_name = self.parse_ident();\n         let generics = self.parse_generics();\n \n-        let mut fields: Vec<StructField> ;\n+        let super_struct = if self.eat(&token::COLON) {\n+            let ty = self.parse_ty(false);\n+            match ty.node {\n+                TyPath(_, None, _) => {\n+                    Some(ty)\n+                }\n+                _ => {\n+                    self.span_err(ty.span, \"not a struct\");\n+                    None\n+                }\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let mut fields: Vec<StructField>;\n         let is_tuple_like;\n \n         if self.eat(&token::LBRACE) {\n@@ -3938,7 +3953,9 @@ impl<'a> Parser<'a> {\n         (class_name,\n          ItemStruct(@ast::StructDef {\n              fields: fields,\n-             ctor_id: if is_tuple_like { Some(new_id) } else { None }\n+             ctor_id: if is_tuple_like { Some(new_id) } else { None },\n+             super_struct: super_struct,\n+             is_virtual: is_virtual,\n          }, generics),\n          None)\n     }\n@@ -4329,7 +4346,9 @@ impl<'a> Parser<'a> {\n \n         return @ast::StructDef {\n             fields: fields,\n-            ctor_id: None\n+            ctor_id: None,\n+            super_struct: None,\n+            is_virtual: false,\n         };\n     }\n \n@@ -4514,6 +4533,12 @@ impl<'a> Parser<'a> {\n                             format!(\"expected `\\\\{` or `fn` but found `{}`\", token_str));\n         }\n \n+        let is_virtual = self.eat_keyword(keywords::Virtual);\n+        if is_virtual && !self.is_keyword(keywords::Struct) {\n+            self.span_err(self.span,\n+                          \"`virtual` keyword may only be used with `struct`\");\n+        }\n+\n         // the rest are all guaranteed to be items:\n         if self.is_keyword(keywords::Static) {\n             // STATIC ITEM\n@@ -4614,7 +4639,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_struct();\n+            let (ident, item_, extra_attrs) = self.parse_item_struct(is_virtual);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,"}, {"sha": "611ce7cc52798081beecffa6305322a9c2e4574c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -474,22 +474,23 @@ declare_special_idents_and_keywords! {\n         (35,                         Type,       \"type\");\n         (36,                         Unsafe,     \"unsafe\");\n         (37,                         Use,        \"use\");\n-        (38,                         While,      \"while\");\n-        (39,                         Continue,   \"continue\");\n-        (40,                         Proc,       \"proc\");\n-        (41,                         Box,        \"box\");\n+        (38,                         Virtual,    \"virtual\");\n+        (39,                         While,      \"while\");\n+        (40,                         Continue,   \"continue\");\n+        (41,                         Proc,       \"proc\");\n+        (42,                         Box,        \"box\");\n \n         'reserved:\n-        (42,                         Alignof,    \"alignof\");\n-        (43,                         Be,         \"be\");\n-        (44,                         Offsetof,   \"offsetof\");\n-        (45,                         Priv,       \"priv\");\n-        (46,                         Pure,       \"pure\");\n-        (47,                         Sizeof,     \"sizeof\");\n-        (48,                         Typeof,     \"typeof\");\n-        (49,                         Unsized,    \"unsized\");\n-        (50,                         Yield,      \"yield\");\n-        (51,                         Do,         \"do\");\n+        (43,                         Alignof,    \"alignof\");\n+        (44,                         Be,         \"be\");\n+        (45,                         Offsetof,   \"offsetof\");\n+        (46,                         Priv,       \"priv\");\n+        (47,                         Pure,       \"pure\");\n+        (48,                         Sizeof,     \"sizeof\");\n+        (49,                         Typeof,     \"typeof\");\n+        (50,                         Unsized,    \"unsized\");\n+        (51,                         Yield,      \"yield\");\n+        (52,                         Do,         \"do\");\n     }\n }\n "}, {"sha": "f4e337e2048f3b34f9b4f5f249019359b9ed274e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -640,6 +640,9 @@ impl<'a> State<'a> {\n                 ));\n             }\n             ast::ItemStruct(struct_def, ref generics) => {\n+                if struct_def.is_virtual {\n+                    try!(self.word_space(\"virtual\"));\n+                }\n                 try!(self.head(visibility_qualified(item.vis, \"struct\")));\n                 try!(self.print_struct(struct_def, generics, item.ident, item.span));\n             }\n@@ -754,6 +757,13 @@ impl<'a> State<'a> {\n                         span: codemap::Span) -> IoResult<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n+        match struct_def.super_struct {\n+            Some(t) => {\n+                try!(self.word_space(\":\"));\n+                try!(self.print_type(t));\n+            },\n+            None => {},\n+        }\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());"}, {"sha": "1f75c2e062ff06deae64da3aa7a6de495e1d7c82", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -571,6 +571,10 @@ pub fn walk_struct_def<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                 _: &Generics,\n                                                 _: NodeId,\n                                                 env: E) {\n+    match struct_definition.super_struct {\n+        Some(t) => visitor.visit_ty(t, env.clone()),\n+        None => {},\n+    }\n     for field in struct_definition.fields.iter() {\n         visitor.visit_struct_field(field, env.clone())\n     }"}, {"sha": "fd049a25a0cff8bea6700dcd39ac543d2d7e873b", "filename": "src/test/auxiliary/inherit_struct_lib.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fauxiliary%2Finherit_struct_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fauxiliary%2Finherit_struct_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherit_struct_lib.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance on structs from another crate.\n+#![feature(struct_inherit)]\n+\n+pub virtual struct S1 {\n+    pub f1: int,\n+}\n+\n+pub struct S2 : S1 {\n+    pub f2: int,\n+}\n+\n+pub fn test_s2(s2: S2) {\n+    assert!(s2.f1 == 115);\n+    assert!(s2.f2 == 113);\n+}\n+\n+pub static glob_s: S2 = S2 { f1: 32, f2: -45 };"}, {"sha": "00ea4b7783b9c55bb7f599fc1540ebfaaee04080", "filename": "src/test/compile-fail/inherit-struct1.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct1.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct q : r {\n-    //~^ ERROR expected `{`, `(`, or `;` after struct name\n-    foo: int\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+struct S6 : ~S2; //~ ERROR not a struct\n+\n+pub fn main() {\n }", "previous_filename": "src/test/compile-fail/removed-syntax-class-traits.rs"}, {"sha": "99fd2d2f69d8115731b17c6c2fc92bdc4c75ae18", "filename": "src/test/compile-fail/inherit-struct2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct2.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+struct S2 : S0 { //~ ERROR super-struct could not be resolved\n+    f2: int,\n+}\n+\n+trait T {}\n+\n+struct S3 : T { //~ ERROR super-struct is not a struct type\n+    f3: int,\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "88329033df7ee40b417de8e75c463c9e428ebf52", "filename": "src/test/compile-fail/inherit-struct3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct3.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+virtual struct S1 {\n+    f1: int,\n+}\n+\n+struct S6 : S1 {\n+    f2: int,\n+}\n+\n+pub fn main() {\n+    let s = S6{f2: 3}; //~ ERROR missing field: `f1`\n+    let s = S6{f1: 3}; //~ ERROR missing field: `f2`\n+}"}, {"sha": "e01ec2904a684acb4b71674ea49f8134724b50ee", "filename": "src/test/compile-fail/inherit-struct4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct4.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+// With lifetime parameters.\n+struct S5<'a> : S4 { //~ ERROR wrong number of lifetime parameters: expected 1 but found 0\n+    f4: int,\n+}\n+\n+virtual struct S4<'a> {\n+    f3: &'a int,\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "c40d27c3b6b3b4016dafd20b67857f6f7d737df4", "filename": "src/test/compile-fail/inherit-struct5.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct5.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance on structs from another crate.\n+#![feature(struct_inherit)]\n+\n+// aux-build:inherit_struct_lib.rs\n+extern crate inherit_struct_lib;\n+\n+struct S3 : inherit_struct_lib::S1; //~ ERROR super-struct is defined in a different crate\n+\n+pub fn main() {\n+}"}, {"sha": "e8c86dcb31692e48f50062b0a4882ffca6217037", "filename": "src/test/compile-fail/inherit-struct6.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct6.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test privacy and struct inheritance.\n+#![feature(struct_inherit)]\n+\n+mod Foo {\n+    pub virtual struct S1 {\n+        pub f1: int,\n+        f2: int,\n+    }\n+}\n+\n+struct S2 : Foo::S1 {\n+    pub f3: int,\n+}\n+\n+impl S2 {\n+    fn new() -> S2 {\n+        S2{f1: 3, f2: 4, f3: 5} //~ ERROR field `f2` of struct `S2` is private\n+    }\n+\n+    fn bar(&self) {\n+        self.f3;\n+        self.f1;\n+        self.f2; //~ ERROR field `f2` of struct `S2` is private\n+    }\n+}\n+\n+pub fn main() {\n+    let s = S2{f1: 3, f2: 4, f3: 5}; //~ ERROR field `f2` of struct `S2` is private\n+    s.f3;\n+    s.f1;\n+    s.f2; //~ ERROR field `f2` of struct `S2` is private\n+}"}, {"sha": "fb0c9175d1582176034f571f92472067ddb92e54", "filename": "src/test/compile-fail/inherit-struct7.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct7.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+virtual trait Foo {} //~ ERROR `virtual` keyword may only be used with `struct`\n+virtual enum Bar {} //~ ERROR `virtual` keyword may only be used with `struct`\n+virtual fn baz() {} //~ ERROR `virtual` keyword may only be used with `struct`\n+\n+pub fn main() {\n+}"}, {"sha": "d1108349db157d2b4c9bbd80341ccd8ce3635e54", "filename": "src/test/compile-fail/inherit-struct8.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct8.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+virtual struct S1 {\n+    f1: int,\n+}\n+\n+virtual struct S6 : S1 {\n+    f2: int,\n+}\n+\n+struct S7 : S1 {\n+    f1: int, //~ ERROR field `f1` hides field declared in super-struct\n+}\n+\n+struct S8 : S6 {\n+    f1: int, //~ ERROR field `f1` hides field declared in super-struct\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "70e341d589cc7c372750d5fff5cc134ab1c49cf2", "filename": "src/test/compile-fail/inherit-struct9.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fcompile-fail%2Finherit-struct9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct9.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+struct s9;\n+struct s10 : s9; //~ ERROR struct inheritance is only allowed from virtual structs\n+\n+pub fn main() {\n+}"}, {"sha": "2ac3b48f6827b9600a89866e47599e5b8c3ad319", "filename": "src/test/debug-info/simple-struct.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -72,15 +72,20 @@\n // debugger:print 'simple-struct::PADDING_AT_END'\n // check:$18 = {x = -27, y = 28}\n \n-#![allow(unused_variable)]\n-#![allow(dead_code)]\n+// debugger:print inheriting\n+// check:$19 = {a = 10019, b = -10020, x = -10016, y = -10017.5, z = 10018}\n+\n+\n+#![feature(struct_inherit)];\n+#![allow(unused_variable)];\n+#![allow(dead_code)];\n \n struct NoPadding16 {\n     x: u16,\n     y: i16\n }\n \n-struct NoPadding32 {\n+virtual struct NoPadding32 {\n     x: i32,\n     y: f32,\n     z: u32\n@@ -143,6 +148,11 @@ static mut PADDING_AT_END: PaddingAtEnd = PaddingAtEnd {\n     y: 14\n };\n \n+struct Inheriting : NoPadding32 {\n+    a: u16,\n+    b: i16\n+}\n+\n fn main() {\n     let no_padding16 = NoPadding16 { x: 10000, y: -10001 };\n     let no_padding32 = NoPadding32 { x: -10002, y: -10003.5, z: 10004 };\n@@ -152,6 +162,8 @@ fn main() {\n     let internal_padding = InternalPadding { x: 10012, y: -10013 };\n     let padding_at_end = PaddingAtEnd { x: -10014, y: 10015 };\n \n+    let inheriting = Inheriting { a: 10019, b: -10020, x: -10016, y: -10017.5, z: 10018 };\n+\n     unsafe {\n         NO_PADDING_16.x = 100;\n         NO_PADDING_16.y = -101;"}, {"sha": "4602f13fef01137770e9626f5897430442171699", "filename": "src/test/run-pass/inherit-struct1.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Frun-pass%2Finherit-struct1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Frun-pass%2Finherit-struct1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finherit-struct1.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance.\n+#![feature(struct_inherit)]\n+\n+virtual struct S1 {\n+    f1: int,\n+}\n+\n+virtual struct S2 : S1 {\n+    f2: int,\n+}\n+\n+struct S3 : S2 {\n+    f3: int,\n+}\n+\n+// With lifetime parameters.\n+struct S5<'a> : S4<'a> {\n+    f4: int,\n+}\n+\n+virtual struct S4<'a> {\n+    f3: &'a int,\n+}\n+\n+// With type parameters.\n+struct S7<T> : S6<T> {\n+    f4: int,\n+}\n+\n+virtual struct S6<T> {\n+    f3: T,\n+}\n+\n+pub fn main() {\n+    let s = S2{f1: 115, f2: 113};\n+    assert!(s.f1 == 115);\n+    assert!(s.f2 == 113);\n+\n+    let s = S3{f1: 15, f2: 13, f3: 17};\n+    assert!(s.f1 == 15);\n+    assert!(s.f2 == 13);\n+    assert!(s.f3 == 17);\n+\n+    let s = S5{f3: &5, f4: 3};\n+    assert!(*s.f3 == 5);\n+    assert!(s.f4 == 3);\n+\n+    let s = S7{f3: 5u, f4: 3};\n+    assert!(s.f3 == 5u);\n+    assert!(s.f4 == 3);\n+}"}, {"sha": "bbcba0af68060847073d25a611ff519fd0b26016", "filename": "src/test/run-pass/inherit-struct2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Frun-pass%2Finherit-struct2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d/src%2Ftest%2Frun-pass%2Finherit-struct2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finherit-struct2.rs?ref=ff04aa8e385f343f66c5bed6a34d1ebf6c971e4d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test struct inheritance on structs from another crate.\n+\n+// aux-build:inherit_struct_lib.rs\n+extern crate inherit_struct_lib;\n+\n+pub fn main() {\n+    let s = inherit_struct_lib::S2{f1: 115, f2: 113};\n+    assert!(s.f1 == 115);\n+    assert!(s.f2 == 113);\n+\n+    assert!(inherit_struct_lib::glob_s.f1 == 32);\n+    assert!(inherit_struct_lib::glob_s.f2 == -45);\n+\n+    inherit_struct_lib::test_s2(s);\n+}"}]}