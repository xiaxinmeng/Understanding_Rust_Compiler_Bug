{"sha": "6a73d544f4117b942b300afb8bda98216fc92356", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNzNkNTQ0ZjQxMTdiOTQyYjMwMGFmYjhiZGE5ODIxNmZjOTIzNTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-30T11:30:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-30T11:30:51Z"}, "message": "Merge #5137\n\n5137: Make gotodef tests more data-driven r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "18b444a0d447465a7de75ec5a0153c90b8566a7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18b444a0d447465a7de75ec5a0153c90b8566a7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a73d544f4117b942b300afb8bda98216fc92356", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+yJrCRBK7hj4Ov3rIwAAdHIIAHsj8b9HK924vE8nOnOQ1MT0\naOhpj7jGcxCADHzjHG95DbUzAEeI3Hym/VDxijA0qVXhkACx2jcl+ex3AC71ep98\n5rfTGJvrS/NMYrbHhaPG4hbOxeJwZLBRhMQqnlYb2jybC+pyzg7uWRVaz93Pnon9\nCAga68O9ap2/p8vy8r73D+TNIpBFaErrfWl6/XGd1YLRDUpnVeX6iSCjDo2+9Xl7\nlO87JlijWrmf5vZgyn0xJPWj5Ha4+YPDBStiAnEtksIqvvVoYbsrTzW1GfrpqZVK\nYpKOKd16iIYBM4jtbyvWJQlBsK6QhWOGehy03Y7Xd05hWLSg6Rre+02+gUVgZRY=\n=GKSe\n-----END PGP SIGNATURE-----\n", "payload": "tree 18b444a0d447465a7de75ec5a0153c90b8566a7f\nparent 5a0fb3caff745d20face2d7ab02fa4da63faef9c\nparent af7e300041b1af68e671446fe22d2b9e5d30f83d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593516651 +0000\ncommitter GitHub <noreply@github.com> 1593516651 +0000\n\nMerge #5137\n\n5137: Make gotodef tests more data-driven r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a73d544f4117b942b300afb8bda98216fc92356", "html_url": "https://github.com/rust-lang/rust/commit/6a73d544f4117b942b300afb8bda98216fc92356", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a73d544f4117b942b300afb8bda98216fc92356/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a0fb3caff745d20face2d7ab02fa4da63faef9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0fb3caff745d20face2d7ab02fa4da63faef9c", "html_url": "https://github.com/rust-lang/rust/commit/5a0fb3caff745d20face2d7ab02fa4da63faef9c"}, {"sha": "af7e300041b1af68e671446fe22d2b9e5d30f83d", "url": "https://api.github.com/repos/rust-lang/rust/commits/af7e300041b1af68e671446fe22d2b9e5d30f83d", "html_url": "https://github.com/rust-lang/rust/commit/af7e300041b1af68e671446fe22d2b9e5d30f83d"}], "stats": {"total": 1376, "additions": 639, "deletions": 737}, "files": [{"sha": "1ddacc1f6c235eef643867226c0b17ed197ee921", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -80,7 +80,7 @@ pub struct FilePosition {\n     pub offset: TextSize,\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n pub struct FileRange {\n     pub file_id: FileId,\n     pub range: TextRange,"}, {"sha": "fddf0604d10b73a740e2fd512400e18c20bb2836", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -8,8 +8,10 @@ use std::{\n use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n use hir_expand::{db::AstDatabase, diagnostics::DiagnosticSink};\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast};\n-use rustc_hash::FxHashSet;\n+use ra_syntax::TextRange;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::format_to;\n+use test_utils::extract_annotations;\n \n use crate::{\n     db::HirDatabase, diagnostics::Diagnostic, expr::ExprValidator,\n@@ -155,17 +157,27 @@ impl TestDB {\n         (buf, count)\n     }\n \n-    pub fn all_files(&self) -> Vec<FileId> {\n-        let mut res = Vec::new();\n+    pub fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n+        let mut files = Vec::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n             for (module_id, _) in crate_def_map.modules.iter() {\n                 let file_id = crate_def_map[module_id].origin.file_id();\n-                res.extend(file_id)\n+                files.extend(file_id)\n             }\n         }\n-        res\n+        files\n+            .into_iter()\n+            .filter_map(|file_id| {\n+                let text = self.file_text(file_id);\n+                let annotations = extract_annotations(&text);\n+                if annotations.is_empty() {\n+                    return None;\n+                }\n+                Some((file_id, annotations))\n+            })\n+            .collect()\n     }\n }\n "}, {"sha": "9084c3bed2cd00a77b3a6557bb9425b1fec66843", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -28,7 +28,6 @@ use ra_syntax::{\n     SyntaxNode,\n };\n use stdx::format_to;\n-use test_utils::extract_annotations;\n \n use crate::{\n     db::HirDatabase, display::HirDisplay, infer::TypeMismatch, test_db::TestDB, InferenceResult, Ty,\n@@ -49,9 +48,7 @@ fn check_types_source_code(ra_fixture: &str) {\n fn check_types_impl(ra_fixture: &str, display_source: bool) {\n     let db = TestDB::with_files(ra_fixture);\n     let mut checked_one = false;\n-    for file_id in db.all_files() {\n-        let text = db.parse(file_id).syntax_node().to_string();\n-        let annotations = extract_annotations(&text);\n+    for (file_id, annotations) in db.extract_annotations() {\n         for (range, expected) in annotations {\n             let ty = type_at_range(&db, FileRange { file_id, range });\n             let actual = if display_source {"}, {"sha": "8bf2428ed46e536d2c0472f22471cea61e92791a", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{FileRange, FileSymbol};\n+use crate::FileSymbol;\n \n use super::short_label::ShortLabel;\n \n@@ -47,6 +47,19 @@ impl NavigationTarget {\n     pub fn range(&self) -> TextRange {\n         self.focus_range.unwrap_or(self.full_range)\n     }\n+    /// A \"most interesting\" range withing the `full_range`.\n+    ///\n+    /// Typically, `full_range` is the whole syntax node,\n+    /// including doc comments, and `focus_range` is the range of the identifier.\n+    pub fn focus_range(&self) -> Option<TextRange> {\n+        self.focus_range\n+    }\n+    pub fn full_range(&self) -> TextRange {\n+        self.full_range\n+    }\n+    pub fn file_id(&self) -> FileId {\n+        self.file_id\n+    }\n \n     pub fn name(&self) -> &SmolStr {\n         &self.name\n@@ -60,18 +73,6 @@ impl NavigationTarget {\n         self.kind\n     }\n \n-    pub fn file_id(&self) -> FileId {\n-        self.file_id\n-    }\n-\n-    pub fn file_range(&self) -> FileRange {\n-        FileRange { file_id: self.file_id, range: self.full_range }\n-    }\n-\n-    pub fn full_range(&self) -> TextRange {\n-        self.full_range\n-    }\n-\n     pub fn docs(&self) -> Option<&str> {\n         self.docs.as_deref()\n     }\n@@ -80,14 +81,6 @@ impl NavigationTarget {\n         self.description.as_deref()\n     }\n \n-    /// A \"most interesting\" range withing the `full_range`.\n-    ///\n-    /// Typically, `full_range` is the whole syntax node,\n-    /// including doc comments, and `focus_range` is the range of the identifier.\n-    pub fn focus_range(&self) -> Option<TextRange> {\n-        self.focus_range\n-    }\n-\n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n@@ -278,16 +271,22 @@ impl ToNav for hir::Module {\n impl ToNav for hir::ImplDef {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n-        let frange = if let Some(item) = self.is_builtin_derive(db) {\n+        let derive_attr = self.is_builtin_derive(db);\n+        let frange = if let Some(item) = &derive_attr {\n             original_range(db, item.syntax())\n         } else {\n             original_range(db, src.as_ref().map(|it| it.syntax()))\n         };\n+        let focus_range = if derive_attr.is_some() {\n+            None\n+        } else {\n+            src.value.target_type().map(|ty| original_range(db, src.with_value(ty.syntax())).range)\n+        };\n \n         NavigationTarget::from_syntax(\n             frange.file_id,\n             \"impl\".into(),\n-            None,\n+            focus_range,\n             frange.range,\n             src.value.syntax().kind(),\n         )"}, {"sha": "4c78fa214222249748e9763509f4a9f7d7d4b107", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 452, "deletions": 611, "changes": 1063, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -103,753 +103,628 @@ pub(crate) fn reference_definition(\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n-    use test_utils::assert_eq_text;\n-\n-    use crate::mock_analysis::analysis_and_position;\n-\n-    fn check_goto(ra_fixture: &str, expected: &str, expected_range: &str) {\n-        let (analysis, pos) = analysis_and_position(ra_fixture);\n-\n-        let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n-        if navs.len() == 0 {\n-            panic!(\"unresolved reference\")\n-        }\n-        assert_eq!(navs.len(), 1);\n-\n-        let nav = navs.pop().unwrap();\n-        let file_text = analysis.file_text(nav.file_id()).unwrap();\n-\n-        let mut actual = file_text[nav.full_range()].to_string();\n-        if let Some(focus) = nav.focus_range() {\n-            actual += \"|\";\n-            actual += &file_text[focus];\n-        }\n-\n-        if !expected_range.contains(\"...\") {\n-            test_utils::assert_eq_text!(&actual, expected_range);\n-        } else {\n-            let mut parts = expected_range.split(\"...\");\n-            let prefix = parts.next().unwrap();\n-            let suffix = parts.next().unwrap();\n-            assert!(\n-                actual.starts_with(prefix) && actual.ends_with(suffix),\n-                \"\\nExpected: {}\\n Actual: {}\\n\",\n-                expected_range,\n-                actual\n-            );\n+    use ra_db::FileRange;\n+    use ra_syntax::{TextRange, TextSize};\n+\n+    use crate::mock_analysis::MockAnalysis;\n+\n+    fn check(ra_fixture: &str) {\n+        let (mock, position) = MockAnalysis::with_files_and_position(ra_fixture);\n+        let (mut expected, data) = mock.annotation();\n+        let analysis = mock.analysis();\n+        match data.as_str() {\n+            \"\" => (),\n+            \"file\" => {\n+                expected.range =\n+                    TextRange::up_to(TextSize::of(&*analysis.file_text(expected.file_id).unwrap()))\n+            }\n+            data => panic!(\"bad data: {}\", data),\n         }\n \n-        nav.assert_match(expected);\n-    }\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let (analysis, pos) = analysis_and_position(ra_fixture);\n-\n-        let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n+        let mut navs = analysis.goto_definition(position).unwrap().unwrap().info;\n         if navs.len() == 0 {\n             panic!(\"unresolved reference\")\n         }\n         assert_eq!(navs.len(), 1);\n \n         let nav = navs.pop().unwrap();\n-        let file_text = analysis.file_text(nav.file_id()).unwrap();\n-\n-        let mut actual = nav.debug_render();\n-        actual += \"\\n\";\n-        actual += &file_text[nav.full_range()].to_string();\n-        if let Some(focus) = nav.focus_range() {\n-            actual += \"|\";\n-            actual += &file_text[focus];\n-            actual += \"\\n\";\n-        }\n-        expect.assert_eq(&actual);\n+        assert_eq!(expected, FileRange { file_id: nav.file_id(), range: nav.range() });\n     }\n \n     #[test]\n     fn goto_def_in_items() {\n         check(\n             r#\"\n struct Foo;\n+     //^^^\n enum E { X(Foo<|>) }\n \"#,\n-            expect![[r#\"\n-                Foo STRUCT_DEF FileId(1) 0..11 7..10\n-                struct Foo;|Foo\n-            \"#]],\n         );\n     }\n \n     #[test]\n     fn goto_def_at_start_of_item() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            enum E { X(<|>Foo) }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..11 7..10\",\n-            \"struct Foo;|Foo\",\n+        check(\n+            r#\"\n+struct Foo;\n+     //^^^\n+enum E { X(<|>Foo) }\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_definition_resolves_correct_name() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            use a::Foo;\n-            mod a;\n-            mod b;\n-            enum E { X(Foo<|>) }\n-\n-            //- /a.rs\n-            struct Foo;\n+        check(\n+            r#\"\n+//- /lib.rs\n+use a::Foo;\n+mod a;\n+mod b;\n+enum E { X(Foo<|>) }\n \n-            //- /b.rs\n-            struct Foo;\n-            \",\n-            \"Foo STRUCT_DEF FileId(2) 0..11 7..10\",\n-            \"struct Foo;|Foo\",\n+//- /a.rs\n+struct Foo;\n+     //^^^\n+//- /b.rs\n+struct Foo;\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_module_declaration() {\n-        check_goto(\n+        check(\n             r#\"\n //- /lib.rs\n mod <|>foo;\n \n //- /foo.rs\n // empty\n+//^ file\n \"#,\n-            \"foo SOURCE_FILE FileId(2) 0..9\",\n-            \"// empty\\n\",\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n //- /lib.rs\n mod <|>foo;\n \n //- /foo/mod.rs\n // empty\n+//^ file\n \"#,\n-            \"foo SOURCE_FILE FileId(2) 0..9\",\n-            \"// empty\\n\",\n         );\n     }\n \n     #[test]\n     fn goto_def_for_macros() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            macro_rules! foo { () => { () } }\n-\n-            fn bar() {\n-                <|>foo!();\n-            }\n-            \",\n-            \"foo MACRO_CALL FileId(1) 0..33 13..16\",\n-            \"macro_rules! foo { () => { () } }|foo\",\n+        check(\n+            r#\"\n+macro_rules! foo { () => { () } }\n+           //^^^\n+fn bar() {\n+    <|>foo!();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_macros_from_other_crates() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            use foo::foo;\n-            fn bar() {\n-                <|>foo!();\n-            }\n-\n-            //- /foo/lib.rs\n-            #[macro_export]\n-            macro_rules! foo { () => { () } }\n-            \",\n-            \"foo MACRO_CALL FileId(2) 0..49 29..32\",\n-            \"#[macro_export]\\nmacro_rules! foo { () => { () } }|foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn goto_def_for_use_alias() {\n-        check_goto(\n+        check(\n             r#\"\n //- /lib.rs\n-use foo as bar<|>;\n+use foo::foo;\n+fn bar() {\n+    <|>foo!();\n+}\n \n //- /foo/lib.rs\n #[macro_export]\n macro_rules! foo { () => { () } }\n+           //^^^\n \"#,\n-            \"SOURCE_FILE FileId(2) 0..50\",\n-            \"#[macro_export]\\nmacro_rules! foo { () => { () } }\\n\",\n-        );\n-    }\n-\n-    #[test]\n-    fn goto_def_for_use_alias_foo_macro() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            use foo::foo as bar<|>;\n-\n-            //- /foo/lib.rs\n-            #[macro_export]\n-            macro_rules! foo { () => { () } }\n-            \",\n-            \"foo MACRO_CALL FileId(2) 0..49 29..32\",\n-            \"#[macro_export]\\nmacro_rules! foo { () => { () } }|foo\",\n         );\n     }\n \n     #[test]\n     fn goto_def_for_macros_in_use_tree() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            use foo::foo<|>;\n+        check(\n+            r#\"\n+//- /lib.rs\n+use foo::foo<|>;\n \n-            //- /foo/lib.rs\n-            #[macro_export]\n-            macro_rules! foo { () => { () } }\n-            \",\n-            \"foo MACRO_CALL FileId(2) 0..49 29..32\",\n-            \"#[macro_export]\\nmacro_rules! foo { () => { () } }|foo\",\n+//- /foo/lib.rs\n+#[macro_export]\n+macro_rules! foo { () => { () } }\n+           //^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_macro_defined_fn_with_arg() {\n-        check_goto(\n+        check(\n             r#\"\n //- /lib.rs\n macro_rules! define_fn {\n     ($name:ident) => (fn $name() {})\n }\n \n define_fn!(foo);\n+         //^^^\n \n fn bar() {\n    <|>foo();\n }\n \"#,\n-            \"foo FN_DEF FileId(1) 65..81 76..79\",\n-            \"define_fn!(foo);|foo\",\n         );\n     }\n \n     #[test]\n     fn goto_def_for_macro_defined_fn_no_arg() {\n-        check_goto(\n+        check(\n             r#\"\n //- /lib.rs\n macro_rules! define_fn {\n     () => (fn foo() {})\n }\n \n-define_fn!();\n+  define_fn!();\n+//^^^^^^^^^^^^^\n \n fn bar() {\n    <|>foo();\n }\n \"#,\n-            \"foo FN_DEF FileId(1) 52..65 52..65\",\n-            \"define_fn!();|define_fn!();\",\n         );\n     }\n \n     #[test]\n     fn goto_definition_works_for_macro_inside_pattern() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            macro_rules! foo {() => {0}}\n-\n-            fn bar() {\n-                match (0,1) {\n-                    (<|>foo!(), _) => {}\n-                }\n-            }\n-            \",\n-            \"foo MACRO_CALL FileId(1) 0..28 13..16\",\n-            \"macro_rules! foo {() => {0}}|foo\",\n+        check(\n+            r#\"\n+//- /lib.rs\n+macro_rules! foo {() => {0}}\n+           //^^^\n+\n+fn bar() {\n+    match (0,1) {\n+        (<|>foo!(), _) => {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_definition_works_for_macro_inside_match_arm_lhs() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            macro_rules! foo {() => {0}}\n-\n-            fn bar() {\n-                match 0 {\n-                    <|>foo!() => {}\n-                }\n-            }\n-            \",\n-            \"foo MACRO_CALL FileId(1) 0..28 13..16\",\n-            \"macro_rules! foo {() => {0}}|foo\",\n+        check(\n+            r#\"\n+//- /lib.rs\n+macro_rules! foo {() => {0}}\n+           //^^^\n+fn bar() {\n+    match 0 {\n+        <|>foo!() => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_def_for_use_alias() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+use foo as bar<|>;\n+\n+//- /foo/lib.rs\n+// empty\n+//^ file\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_def_for_use_alias_foo_macro() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+use foo::foo as bar<|>;\n+\n+//- /foo/lib.rs\n+#[macro_export]\n+macro_rules! foo { () => { () } }\n+           //^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_methods() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            impl Foo {\n-                fn frobnicate(&self) { }\n-            }\n+        check(\n+            r#\"\n+//- /lib.rs\n+struct Foo;\n+impl Foo {\n+    fn frobnicate(&self) { }\n+     //^^^^^^^^^^\n+}\n \n-            fn bar(foo: &Foo) {\n-                foo.frobnicate<|>();\n-            }\n-            \",\n-            \"frobnicate FN_DEF FileId(1) 27..51 30..40\",\n-            \"fn frobnicate(&self) { }|frobnicate\",\n+fn bar(foo: &Foo) {\n+    foo.frobnicate<|>();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_fields() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo {\n-                spam: u32,\n-            }\n+        check(\n+            r#\"\n+struct Foo {\n+    spam: u32,\n+} //^^^^\n \n-            fn bar(foo: &Foo) {\n-                foo.spam<|>;\n-            }\n-            \",\n-            \"spam RECORD_FIELD_DEF FileId(1) 17..26 17..21\",\n-            \"spam: u32|spam\",\n+fn bar(foo: &Foo) {\n+    foo.spam<|>;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_record_fields() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo {\n-                spam: u32,\n-            }\n+        check(\n+            r#\"\n+//- /lib.rs\n+struct Foo {\n+    spam: u32,\n+} //^^^^\n \n-            fn bar() -> Foo {\n-                Foo {\n-                    spam<|>: 0,\n-                }\n-            }\n-            \",\n-            \"spam RECORD_FIELD_DEF FileId(1) 17..26 17..21\",\n-            \"spam: u32|spam\",\n+fn bar() -> Foo {\n+    Foo {\n+        spam<|>: 0,\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_record_pat_fields() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            struct Foo {\n-                spam: u32,\n-            }\n+        check(\n+            r#\"\n+//- /lib.rs\n+struct Foo {\n+    spam: u32,\n+} //^^^^\n \n-            fn bar(foo: Foo) -> Foo {\n-                let Foo { spam<|>: _, } = foo\n-            }\n-            \",\n-            \"spam RECORD_FIELD_DEF FileId(1) 17..26 17..21\",\n-            \"spam: u32|spam\",\n+fn bar(foo: Foo) -> Foo {\n+    let Foo { spam<|>: _, } = foo\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_record_fields_macros() {\n-        check_goto(\n+        check(\n             r\"\n-            //- /lib.rs\n-            macro_rules! m { () => { 92 };}\n-            struct Foo { spam: u32 }\n+macro_rules! m { () => { 92 };}\n+struct Foo { spam: u32 }\n+           //^^^^\n \n-            fn bar() -> Foo {\n-                Foo { spam<|>: m!() }\n-            }\n-            \",\n-            \"spam RECORD_FIELD_DEF FileId(1) 45..54 45..49\",\n-            \"spam: u32|spam\",\n+fn bar() -> Foo {\n+    Foo { spam<|>: m!() }\n+}\n+\",\n         );\n     }\n \n     #[test]\n     fn goto_for_tuple_fields() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo(u32);\n-\n-            fn bar() {\n-                let foo = Foo(0);\n-                foo.<|>0;\n-            }\n-            \",\n-            \"TUPLE_FIELD_DEF FileId(1) 11..14\",\n-            \"u32\",\n+        check(\n+            r#\"\n+struct Foo(u32);\n+         //^^^\n+\n+fn bar() {\n+    let foo = Foo(0);\n+    foo.<|>0;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_ufcs_inherent_methods() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            impl Foo {\n-                fn frobnicate() { }\n-            }\n+        check(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn frobnicate() { }\n+}    //^^^^^^^^^^\n \n-            fn bar(foo: &Foo) {\n-                Foo::frobnicate<|>();\n-            }\n-            \",\n-            \"frobnicate FN_DEF FileId(1) 27..46 30..40\",\n-            \"fn frobnicate() { }|frobnicate\",\n+fn bar(foo: &Foo) {\n+    Foo::frobnicate<|>();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_ufcs_trait_methods_through_traits() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            trait Foo {\n-                fn frobnicate();\n-            }\n+        check(\n+            r#\"\n+trait Foo {\n+    fn frobnicate();\n+}    //^^^^^^^^^^\n \n-            fn bar() {\n-                Foo::frobnicate<|>();\n-            }\n-            \",\n-            \"frobnicate FN_DEF FileId(1) 16..32 19..29\",\n-            \"fn frobnicate();|frobnicate\",\n+fn bar() {\n+    Foo::frobnicate<|>();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_ufcs_trait_methods_through_self() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            trait Trait {\n-                fn frobnicate();\n-            }\n-            impl Trait for Foo {}\n+        check(\n+            r#\"\n+struct Foo;\n+trait Trait {\n+    fn frobnicate();\n+}    //^^^^^^^^^^\n+impl Trait for Foo {}\n \n-            fn bar() {\n-                Foo::frobnicate<|>();\n-            }\n-            \",\n-            \"frobnicate FN_DEF FileId(1) 30..46 33..43\",\n-            \"fn frobnicate();|frobnicate\",\n+fn bar() {\n+    Foo::frobnicate<|>();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_definition_on_self() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            impl Foo {\n-                pub fn new() -> Self {\n-                    Self<|> {}\n-                }\n-            }\n-            \",\n-            \"impl IMPL_DEF FileId(1) 12..73\",\n-            \"impl Foo {...}\",\n-        );\n-\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            impl Foo {\n-                pub fn new() -> Self<|> {\n-                    Self {}\n-                }\n-            }\n-            \",\n-            \"impl IMPL_DEF FileId(1) 12..73\",\n-            \"impl Foo {...}\",\n-        );\n-\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo { A }\n-            impl Foo {\n-                pub fn new() -> Self<|> {\n-                    Foo::A\n-                }\n-            }\n-            \",\n-            \"impl IMPL_DEF FileId(1) 15..75\",\n-            \"impl Foo {...}\",\n-        );\n-\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo { A }\n-            impl Foo {\n-                pub fn thing(a: &Self<|>) {\n-                }\n-            }\n-            \",\n-            \"impl IMPL_DEF FileId(1) 15..62\",\n-            \"impl Foo {...}\",\n+        check(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+   //^^^\n+    pub fn new() -> Self {\n+        Self<|> {}\n+    }\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+   //^^^\n+    pub fn new() -> Self<|> {\n+        Self {}\n+    }\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+enum Foo { A }\n+impl Foo {\n+   //^^^\n+    pub fn new() -> Self<|> {\n+        Foo::A\n+    }\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+enum Foo { A }\n+impl Foo {\n+   //^^^\n+    pub fn thing(a: &Self<|>) {\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_definition_on_self_in_trait_impl() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            trait Make {\n-                fn new() -> Self;\n-            }\n-            impl Make for Foo {\n-                fn new() -> Self {\n-                    Self<|> {}\n-                }\n-            }\n-            \",\n-            \"impl IMPL_DEF FileId(1) 49..115\",\n-            \"impl Make for Foo {...}\",\n+        check(\n+            r#\"\n+struct Foo;\n+trait Make {\n+    fn new() -> Self;\n+}\n+impl Make for Foo {\n+            //^^^\n+    fn new() -> Self {\n+        Self<|> {}\n+    }\n+}\n+\"#,\n         );\n \n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            trait Make {\n-                fn new() -> Self;\n-            }\n-            impl Make for Foo {\n-                fn new() -> Self<|> {\n-                    Self {}\n-                }\n-            }\n-            \",\n-            \"impl IMPL_DEF FileId(1) 49..115\",\n-            \"impl Make for Foo {...}\",\n+        check(\n+            r#\"\n+struct Foo;\n+trait Make {\n+    fn new() -> Self;\n+}\n+impl Make for Foo {\n+            //^^^\n+    fn new() -> Self<|> {\n+        Self {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_when_used_on_definition_name_itself() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo<|> { value: u32 }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..25 7..10\",\n-            \"struct Foo { value: u32 }|Foo\",\n+        check(\n+            r#\"\n+struct Foo<|> { value: u32 }\n+     //^^^\n+            \"#,\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            struct Foo {\n-                field<|>: string,\n-            }\n-            \"#,\n-            \"field RECORD_FIELD_DEF FileId(1) 17..30 17..22\",\n-            \"field: string|field\",\n+struct Foo {\n+    field<|>: string,\n+} //^^^^^\n+\"#,\n         );\n \n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            fn foo_test<|>() { }\n-            \",\n-            \"foo_test FN_DEF FileId(1) 0..17 3..11\",\n-            \"fn foo_test() { }|foo_test\",\n+        check(\n+            r#\"\n+fn foo_test<|>() { }\n+ //^^^^^^^^\n+\"#,\n         );\n \n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo<|> {\n-                Variant,\n-            }\n-            \",\n-            \"Foo ENUM_DEF FileId(1) 0..25 5..8\",\n-            \"enum Foo {...}|Foo\",\n-        );\n-\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo {\n-                Variant1,\n-                Variant2<|>,\n-                Variant3,\n-            }\n-            \",\n-            \"Variant2 ENUM_VARIANT FileId(1) 29..37 29..37\",\n-            \"Variant2|Variant2\",\n+        check(\n+            r#\"\n+enum Foo<|> { Variant }\n+   //^^^\n+\"#,\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            static INNER<|>: &str = \"\";\n-            \"#,\n-            \"INNER STATIC_DEF FileId(1) 0..24 7..12\",\n-            \"static INNER: &str = \\\"\\\";|INNER\",\n+enum Foo {\n+    Variant1,\n+    Variant2<|>,\n+  //^^^^^^^^\n+    Variant3,\n+}\n+\"#,\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            const INNER<|>: &str = \"\";\n-            \"#,\n-            \"INNER CONST_DEF FileId(1) 0..23 6..11\",\n-            \"const INNER: &str = \\\"\\\";|INNER\",\n+static INNER<|>: &str = \"\";\n+     //^^^^^\n+\"#,\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            type Thing<|> = Option<()>;\n-            \"#,\n-            \"Thing TYPE_ALIAS_DEF FileId(1) 0..24 5..10\",\n-            \"type Thing = Option<()>;|Thing\",\n+const INNER<|>: &str = \"\";\n+    //^^^^^\n+\"#,\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            trait Foo<|> { }\n-            \"#,\n-            \"Foo TRAIT_DEF FileId(1) 0..13 6..9\",\n-            \"trait Foo { }|Foo\",\n+type Thing<|> = Option<()>;\n+   //^^^^^\n+\"#,\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            mod bar<|> { }\n-            \"#,\n-            \"bar MODULE FileId(1) 0..11 4..7\",\n-            \"mod bar { }|bar\",\n+trait Foo<|> { }\n+    //^^^\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+mod bar<|> { }\n+  //^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_from_macro() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            macro_rules! id {\n-                ($($tt:tt)*) => { $($tt)* }\n-            }\n-            fn foo() {}\n-            id! {\n-                fn bar() {\n-                    fo<|>o();\n-                }\n-            }\n-            mod confuse_index { fn foo(); }\n-            \",\n-            \"foo FN_DEF FileId(1) 52..63 55..58\",\n-            \"fn foo() {}|foo\",\n+        check(\n+            r#\"\n+macro_rules! id {\n+    ($($tt:tt)*) => { $($tt)* }\n+}\n+fn foo() {}\n+ //^^^\n+id! {\n+    fn bar() {\n+        fo<|>o();\n+    }\n+}\n+mod confuse_index { fn foo(); }\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_through_format() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            #[macro_export]\n-            macro_rules! format {\n-                ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n-            }\n-            #[rustc_builtin_macro]\n-            #[macro_export]\n-            macro_rules! format_args {\n-                ($fmt:expr) => ({ /* compiler built-in */ });\n-                ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n-            }\n-            pub mod __export {\n-                pub use crate::format_args;\n-                fn foo() {} // for index confusion\n-            }\n-            fn foo() -> i8 {}\n-            fn test() {\n-                format!(\\\"{}\\\", fo<|>o())\n-            }\n-            \",\n-            \"foo FN_DEF FileId(1) 398..415 401..404\",\n-            \"fn foo() -> i8 {}|foo\",\n+        check(\n+            r#\"\n+#[macro_export]\n+macro_rules! format {\n+    ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n+}\n+#[rustc_builtin_macro]\n+#[macro_export]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+pub mod __export {\n+    pub use crate::format_args;\n+    fn foo() {} // for index confusion\n+}\n+fn foo() -> i8 {}\n+ //^^^\n+fn test() {\n+    format!(\"{}\", fo<|>o())\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_for_type_param() {\n-        check_goto(\n+        check(\n             r#\"\n-            //- /lib.rs\n-            struct Foo<T: Clone> {\n-                t: <|>T,\n-            }\n-            \"#,\n-            \"T TYPE_PARAM FileId(1) 11..19 11..12\",\n-            \"T: Clone|T\",\n+struct Foo<T: Clone> { t: <|>T }\n+         //^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_within_macro() {\n-        check_goto(\n+        check(\n             r#\"\n-//- /lib.rs\n macro_rules! id {\n     ($($tt:tt)*) => ($($tt)*)\n }\n \n fn foo() {\n     let x = 1;\n+      //^\n     id!({\n         let y = <|>x;\n         let z = y;\n     });\n }\n \"#,\n-            \"x BIND_PAT FileId(1) 70..71\",\n-            \"x\",\n         );\n \n-        check_goto(\n+        check(\n             r#\"\n-//- /lib.rs\n macro_rules! id {\n     ($($tt:tt)*) => ($($tt)*)\n }\n@@ -858,159 +733,125 @@ fn foo() {\n     let x = 1;\n     id!({\n         let y = x;\n+          //^\n         let z = <|>y;\n     });\n }\n \"#,\n-            \"y BIND_PAT FileId(1) 99..100\",\n-            \"y\",\n         );\n     }\n \n     #[test]\n     fn goto_def_in_local_fn() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            fn main() {\n-                fn foo() {\n-                    let x = 92;\n-                    <|>x;\n-                }\n-            }\n-            \",\n-            \"x BIND_PAT FileId(1) 39..40\",\n-            \"x\",\n+        check(\n+            r#\"\n+fn main() {\n+    fn foo() {\n+        let x = 92;\n+          //^\n+        <|>x;\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_in_local_macro() {\n-        check_goto(\n-            r\"\n-            //- /lib.rs\n-            fn bar() {\n-                macro_rules! foo { () => { () } }\n-                <|>foo!();\n-            }\n-            \",\n-            \"foo MACRO_CALL FileId(1) 15..48 28..31\",\n-            \"macro_rules! foo { () => { () } }|foo\",\n+        check(\n+            r#\"\n+fn bar() {\n+    macro_rules! foo { () => { () } }\n+               //^^^\n+    <|>foo!();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_field_init_shorthand() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo { x: i32 }\n-            fn main() {\n-                let x = 92;\n-                Foo { x<|> };\n-            }\n-            \",\n-            \"x BIND_PAT FileId(1) 42..43\",\n-            \"x\",\n+        check(\n+            r#\"\n+struct Foo { x: i32 }\n+fn main() {\n+    let x = 92;\n+      //^\n+    Foo { x<|> };\n+}\n+\"#,\n         )\n     }\n \n     #[test]\n     fn goto_def_for_enum_variant_field() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo {\n-                Bar { x: i32 }\n-            }\n-            fn baz(foo: Foo) {\n-                match foo {\n-                    Foo::Bar { x<|> } => x\n-                };\n-            }\n-            \",\n-            \"x RECORD_FIELD_DEF FileId(1) 21..27 21..22\",\n-            \"x: i32|x\",\n+        check(\n+            r#\"\n+enum Foo {\n+    Bar { x: i32 }\n+}       //^\n+fn baz(foo: Foo) {\n+    match foo {\n+        Foo::Bar { x<|> } => x\n+    };\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_enum_variant_self_pattern_const() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo {\n-                Bar,\n-            }\n-            impl Foo {\n-                fn baz(self) {\n-                    match self {\n-                        Self::Bar<|> => {}\n-                    }\n-                }\n-            }\n-            \",\n-            \"Bar ENUM_VARIANT FileId(1) 15..18 15..18\",\n-            \"Bar|Bar\",\n+        check(\n+            r#\"\n+enum Foo { Bar }\n+         //^^^\n+impl Foo {\n+    fn baz(self) {\n+        match self { Self::Bar<|> => {} }\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_enum_variant_self_pattern_record() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo {\n-                Bar { val: i32 },\n-            }\n-            impl Foo {\n-                fn baz(self) -> i32 {\n-                    match self {\n-                        Self::Bar<|> { val } => {}\n-                    }\n-                }\n-            }\n-            \",\n-            \"Bar ENUM_VARIANT FileId(1) 15..31 15..18\",\n-            \"Bar { val: i32 }|Bar\",\n+        check(\n+            r#\"\n+enum Foo { Bar { val: i32 } }\n+         //^^^\n+impl Foo {\n+    fn baz(self) -> i32 {\n+        match self { Self::Bar<|> { val } => {} }\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_enum_variant_self_expr_const() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo {\n-                Bar,\n-            }\n-            impl Foo {\n-                fn baz(self) {\n-                    Self::Bar<|>;\n-                }\n-            }\n-            \",\n-            \"Bar ENUM_VARIANT FileId(1) 15..18 15..18\",\n-            \"Bar|Bar\",\n+        check(\n+            r#\"\n+enum Foo { Bar }\n+         //^^^\n+impl Foo {\n+    fn baz(self) { Self::Bar<|>; }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_def_for_enum_variant_self_expr_record() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            enum Foo {\n-                Bar { val: i32 },\n-            }\n-            impl Foo {\n-                fn baz(self) {\n-                    Self::Bar<|> {val: 4};\n-                }\n-            }\n-            \",\n-            \"Bar ENUM_VARIANT FileId(1) 15..31 15..18\",\n-            \"Bar { val: i32 }|Bar\",\n+        check(\n+            r#\"\n+enum Foo { Bar { val: i32 } }\n+         //^^^\n+impl Foo {\n+    fn baz(self) { Self::Bar<|> {val: 4}; }\n+}\n+\"#,\n         );\n     }\n }"}, {"sha": "99a7022a4836648ab0b3683cadd83e7168b42f25", "filename": "crates/ra_ide/src/goto_implementation.rs", "status": "modified", "additions": 105, "deletions": 88, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -74,135 +74,152 @@ fn impls_for_trait(\n \n #[cfg(test)]\n mod tests {\n-    use crate::mock_analysis::analysis_and_position;\n+    use ra_db::FileRange;\n \n-    fn check_goto(fixture: &str, expected: &[&str]) {\n-        let (analysis, pos) = analysis_and_position(fixture);\n+    use crate::mock_analysis::MockAnalysis;\n \n-        let mut navs = analysis.goto_implementation(pos).unwrap().unwrap().info;\n-        assert_eq!(navs.len(), expected.len());\n-        navs.sort_by_key(|nav| (nav.file_id(), nav.full_range().start()));\n-        navs.into_iter().enumerate().for_each(|(i, nav)| nav.assert_match(expected[i]));\n+    fn check(ra_fixture: &str) {\n+        let (mock, position) = MockAnalysis::with_files_and_position(ra_fixture);\n+        let annotations = mock.annotations();\n+        let analysis = mock.analysis();\n+\n+        let navs = analysis.goto_implementation(position).unwrap().unwrap().info;\n+\n+        let key = |frange: &FileRange| (frange.file_id, frange.range.start());\n+\n+        let mut expected = annotations\n+            .into_iter()\n+            .map(|(range, data)| {\n+                assert!(data.is_empty());\n+                range\n+            })\n+            .collect::<Vec<_>>();\n+        expected.sort_by_key(key);\n+\n+        let mut actual = navs\n+            .into_iter()\n+            .map(|nav| FileRange { file_id: nav.file_id(), range: nav.range() })\n+            .collect::<Vec<_>>();\n+        actual.sort_by_key(key);\n+\n+        assert_eq!(expected, actual);\n     }\n \n     #[test]\n     fn goto_implementation_works() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo<|>;\n-            impl Foo {}\n-            \",\n-            &[\"impl IMPL_DEF FileId(1) 12..23\"],\n+        check(\n+            r#\"\n+struct Foo<|>;\n+impl Foo {}\n+   //^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_works_multiple_blocks() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo<|>;\n-            impl Foo {}\n-            impl Foo {}\n-            \",\n-            &[\"impl IMPL_DEF FileId(1) 12..23\", \"impl IMPL_DEF FileId(1) 24..35\"],\n+        check(\n+            r#\"\n+struct Foo<|>;\n+impl Foo {}\n+   //^^^\n+impl Foo {}\n+   //^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_works_multiple_mods() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo<|>;\n-            mod a {\n-                impl super::Foo {}\n-            }\n-            mod b {\n-                impl super::Foo {}\n-            }\n-            \",\n-            &[\"impl IMPL_DEF FileId(1) 24..42\", \"impl IMPL_DEF FileId(1) 57..75\"],\n+        check(\n+            r#\"\n+struct Foo<|>;\n+mod a {\n+    impl super::Foo {}\n+       //^^^^^^^^^^\n+}\n+mod b {\n+    impl super::Foo {}\n+       //^^^^^^^^^^\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_works_multiple_files() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo<|>;\n-            mod a;\n-            mod b;\n-            //- /a.rs\n-            impl crate::Foo {}\n-            //- /b.rs\n-            impl crate::Foo {}\n-            \",\n-            &[\"impl IMPL_DEF FileId(2) 0..18\", \"impl IMPL_DEF FileId(3) 0..18\"],\n+        check(\n+            r#\"\n+//- /lib.rs\n+struct Foo<|>;\n+mod a;\n+mod b;\n+//- /a.rs\n+impl crate::Foo {}\n+   //^^^^^^^^^^\n+//- /b.rs\n+impl crate::Foo {}\n+   //^^^^^^^^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_for_trait() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            trait T<|> {}\n-            struct Foo;\n-            impl T for Foo {}\n-            \",\n-            &[\"impl IMPL_DEF FileId(1) 23..40\"],\n+        check(\n+            r#\"\n+trait T<|> {}\n+struct Foo;\n+impl T for Foo {}\n+         //^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_for_trait_multiple_files() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            trait T<|> {};\n-            struct Foo;\n-            mod a;\n-            mod b;\n-            //- /a.rs\n-            impl crate::T for crate::Foo {}\n-            //- /b.rs\n-            impl crate::T for crate::Foo {}\n-            \",\n-            &[\"impl IMPL_DEF FileId(2) 0..31\", \"impl IMPL_DEF FileId(3) 0..31\"],\n+        check(\n+            r#\"\n+//- /lib.rs\n+trait T<|> {};\n+struct Foo;\n+mod a;\n+mod b;\n+//- /a.rs\n+impl crate::T for crate::Foo {}\n+                //^^^^^^^^^^\n+//- /b.rs\n+impl crate::T for crate::Foo {}\n+                //^^^^^^^^^^\n+            \"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_all_impls() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            trait T {}\n-            struct Foo<|>;\n-            impl Foo {}\n-            impl T for Foo {}\n-            impl T for &Foo {}\n-            \",\n-            &[\n-                \"impl IMPL_DEF FileId(1) 23..34\",\n-                \"impl IMPL_DEF FileId(1) 35..52\",\n-                \"impl IMPL_DEF FileId(1) 53..71\",\n-            ],\n+        check(\n+            r#\"\n+//- /lib.rs\n+trait T {}\n+struct Foo<|>;\n+impl Foo {}\n+   //^^^\n+impl T for Foo {}\n+         //^^^\n+impl T for &Foo {}\n+         //^^^^\n+\"#,\n         );\n     }\n \n     #[test]\n     fn goto_implementation_to_builtin_derive() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            #[derive(Copy)]\n-            struct Foo<|>;\n-            \",\n-            &[\"impl IMPL_DEF FileId(1) 0..15\"],\n+        check(\n+            r#\"\n+  #[derive(Copy)]\n+//^^^^^^^^^^^^^^^\n+struct Foo<|>;\n+\"#,\n         );\n     }\n }"}, {"sha": "db6d50694a9761a1753116b25e6268c0337deafc", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -3,7 +3,9 @@ use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use ra_db::{CrateName, Env, FileSet, SourceRoot, VfsPath};\n-use test_utils::{extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER};\n+use test_utils::{\n+    extract_annotations, extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER,\n+};\n \n use crate::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition, FileId, FilePosition, FileRange,\n@@ -77,6 +79,24 @@ impl MockAnalysis {\n             .expect(\"no file in this mock\");\n         FileId(idx as u32 + 1)\n     }\n+    pub fn annotations(&self) -> Vec<(FileRange, String)> {\n+        self.files\n+            .iter()\n+            .enumerate()\n+            .flat_map(|(idx, fixture)| {\n+                let file_id = FileId(idx as u32 + 1);\n+                let annotations = extract_annotations(&fixture.text);\n+                annotations\n+                    .into_iter()\n+                    .map(move |(range, data)| (FileRange { file_id, range }, data))\n+            })\n+            .collect()\n+    }\n+    pub fn annotation(&self) -> (FileRange, String) {\n+        let mut all = self.annotations();\n+        assert_eq!(all.len(), 1);\n+        all.pop().unwrap()\n+    }\n     pub fn analysis_host(self) -> AnalysisHost {\n         let mut host = AnalysisHost::default();\n         let mut change = AnalysisChange::new();"}, {"sha": "25bcd80af8c16c78092a9a2dc28a073984c33737", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -330,11 +330,12 @@ pub(crate) fn handle_workspace_symbol(\n     fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n         for nav in snap.analysis.symbol_search(query)? {\n+            let container_name = nav.container_name().map(|v| v.to_string());\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n                 kind: to_proto::symbol_kind(nav.kind()),\n-                location: to_proto::location(snap, nav.file_range())?,\n-                container_name: nav.container_name().map(|v| v.to_string()),\n+                location: to_proto::location_from_nav(snap, nav)?,\n+                container_name,\n                 deprecated: None,\n             };\n             res.push(info);\n@@ -1213,8 +1214,8 @@ fn show_impl_command_link(\n             let position = to_proto::position(&line_index, position.offset);\n             let locations: Vec<_> = nav_data\n                 .info\n-                .iter()\n-                .filter_map(|it| to_proto::location(snap, it.file_range()).ok())\n+                .into_iter()\n+                .filter_map(|nav| to_proto::location_from_nav(snap, nav).ok())\n                 .collect();\n             let title = implementation_title(locations.len());\n             let command = show_references_command(title, &uri, position, locations);"}, {"sha": "a0a58f689d5deda4686b677550692ed1094214e3", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -446,6 +446,18 @@ pub(crate) fn location(\n     Ok(loc)\n }\n \n+/// Perefer using `location_link`, if the client has the cap.\n+pub(crate) fn location_from_nav(\n+    snap: &GlobalStateSnapshot,\n+    nav: NavigationTarget,\n+) -> Result<lsp_types::Location> {\n+    let url = url(snap, nav.file_id());\n+    let line_index = snap.analysis.file_line_index(nav.file_id())?;\n+    let range = range(&line_index, nav.full_range());\n+    let loc = lsp_types::Location::new(url, range);\n+    Ok(loc)\n+}\n+\n pub(crate) fn location_link(\n     snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,"}, {"sha": "f1139d2f42060e086a5b46311a6478d395691619", "filename": "docs/dev/README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a73d544f4117b942b300afb8bda98216fc92356/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a73d544f4117b942b300afb8bda98216fc92356/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=6a73d544f4117b942b300afb8bda98216fc92356", "patch": "@@ -177,6 +177,9 @@ There are many benefits to this:\n * less stuff printed during printf-debugging\n * less time to run test\n \n+It also makes sense to format snippets more compactly (for example, by placing enum defitions like `enum E { Foo, Bar }` on a single line),\n+as long as they are still readable.\n+\n ## Order of Imports\n \n We separate import groups with blank lines"}]}