{"sha": "e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "node_id": "C_kwDOAAsO6NoAKGU5YWZmOWM0MmNiOTQ5NzRkYzgwZTNjNWFlM2QyNzI3ZWFhZTk2ODI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-10T01:10:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-10T01:10:59Z"}, "message": "Auto merge of #91970 - nrc:provide-any, r=scottmcm\n\nAdd the Provider api to core::any\n\nThis is an implementation of [RFC 3192](https://github.com/rust-lang/rfcs/pull/3192) ~~(which is yet to be merged, thus why this is a draft PR)~~. It adds an API for type-driven requests and provision of data from trait objects. A primary use case is for the `Error` trait, though that is not implemented in this PR. The only major difference to the RFC is that the functionality is added to the `any` module, rather than being in a sibling `provide_any` module (as discussed in the RFC thread).\n\n~~Still todo: improve documentation on items, including adding examples.~~\n\ncc `@yaahc`", "tree": {"sha": "95e880fce932f656a18ff2d2a4fdbb229f6e79c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95e880fce932f656a18ff2d2a4fdbb229f6e79c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "html_url": "https://github.com/rust-lang/rust/commit/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "420c970cb1edccbf60ff2aeb51ca01e2300b09ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/420c970cb1edccbf60ff2aeb51ca01e2300b09ef", "html_url": "https://github.com/rust-lang/rust/commit/420c970cb1edccbf60ff2aeb51ca01e2300b09ef"}, {"sha": "66290109bbd0f2da2f6b2dc9787b29371e788c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/66290109bbd0f2da2f6b2dc9787b29371e788c76", "html_url": "https://github.com/rust-lang/rust/commit/66290109bbd0f2da2f6b2dc9787b29371e788c76"}], "stats": {"total": 439, "additions": 436, "deletions": 3}, "files": [{"sha": "5eda860264c6c6fd3be104aea99c2c24e8c40f88", "filename": "library/core/src/any.rs", "status": "modified", "additions": 373, "deletions": 3, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "patch": "@@ -1,5 +1,9 @@\n-//! This module implements the `Any` trait, which enables dynamic typing\n-//! of any `'static` type through runtime reflection.\n+//! This module contains the `Any` trait, which enables dynamic typing\n+//! of any `'static` type through runtime reflection. It also contains the\n+//! `Provider` trait and accompanying API, which enable trait objects to provide\n+//! data based on typed requests, an alternate form of runtime reflection.\n+//!\n+//! # `Any` and `TypeId`\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used\n //! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n@@ -37,7 +41,7 @@\n //! assert_eq!(boxed_id, TypeId::of::<Box<dyn Any>>());\n //! ```\n //!\n-//! # Examples\n+//! ## Examples\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n //! We know the value we're working on implements Debug, but we don't know its\n@@ -81,6 +85,73 @@\n //!     do_work(&my_i8);\n //! }\n //! ```\n+//!\n+//! # `Provider` and `Demand`\n+//!\n+//! `Provider` and the associated APIs support generic, type-driven access to data, and a mechanism\n+//! for implementers to provide such data. The key parts of the interface are the `Provider`\n+//! trait for objects which can provide data, and the [`request_value`] and [`request_ref`]\n+//! functions for requesting data from an object which implements `Provider`. Generally, end users\n+//! should not call `request_*` directly, they are helper functions for intermediate implementers\n+//! to use to implement a user-facing interface. This is purely for the sake of ergonomics, there is\n+//! safety concern here; intermediate implementers can typically support methods rather than\n+//! free functions and use more specific names.\n+//!\n+//! Typically, a data provider is a trait object of a trait which extends `Provider`. A user will\n+//! request data from a trait object by specifying the type of the data.\n+//!\n+//! ## Data flow\n+//!\n+//! * A user requests an object of a specific type, which is delegated to `request_value` or\n+//!   `request_ref`\n+//! * `request_*` creates a `Demand` object and passes it to `Provider::provide`\n+//! * The data provider's implementation of `Provider::provide` tries providing values of\n+//!   different types using `Demand::provide_*`. If the type matches the type requested by\n+//!   the user, the value will be stored in the `Demand` object.\n+//! * `request_*` unpacks the `Demand` object and returns any stored value to the user.\n+//!\n+//! ## Examples\n+//!\n+//! ```\n+//! # #![feature(provide_any)]\n+//! use std::any::{Provider, Demand, request_ref};\n+//!\n+//! // Definition of MyTrait, a data provider.\n+//! trait MyTrait: Provider {\n+//!     // ...\n+//! }\n+//!\n+//! // Methods on `MyTrait` trait objects.\n+//! impl dyn MyTrait + '_ {\n+//!     /// Get a reference to a field of the implementing struct.\n+//!     pub fn get_context_by_ref<T: ?Sized + 'static>(&self) -> Option<&T> {\n+//!         request_ref::<T, _>(self)\n+//!     }\n+//! }\n+//!\n+//! // Downstream implementation of `MyTrait` and `Provider`.\n+//! # struct SomeConcreteType { some_string: String }\n+//! impl MyTrait for SomeConcreteType {\n+//!     // ...\n+//! }\n+//!\n+//! impl Provider for SomeConcreteType {\n+//!     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+//!         // Provide a string reference. We could provide multiple values with\n+//!         // different types here.\n+//!         demand.provide_ref::<String>(&self.some_string);\n+//!     }\n+//! }\n+//!\n+//! // Downstream usage of `MyTrait`.\n+//! fn use_my_trait(obj: &dyn MyTrait) {\n+//!     // Request a &String from obj.\n+//!     let _ = obj.get_context_by_ref::<String>().unwrap();\n+//! }\n+//! ```\n+//!\n+//! In this example, if the concrete type of `obj` in `use_my_trait` is `SomeConcreteType`, then\n+//! the `get_context_ref` call will return a reference to `obj.some_string` with type `&String`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -700,3 +771,302 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Provider trait\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// Trait implemented by a type which can dynamically provide values based on type.\n+#[unstable(feature = \"provide_any\", issue = \"96024\")]\n+pub trait Provider {\n+    /// Data providers should implement this method to provide *all* values they are able to\n+    /// provide by using `demand`.\n+    ///\n+    /// Note that the `provide_*` methods on `Demand` have short-circuit semantics: if an earlier\n+    /// method has successfully provided a value, then later methods will not get an opportunity to\n+    /// provide.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Provides a reference to a field with type `String` as a `&str`, and a value of\n+    /// type `i32`.\n+    ///\n+    /// ```rust\n+    /// # #![feature(provide_any)]\n+    /// use std::any::{Provider, Demand};\n+    /// # struct SomeConcreteType { field: String, num_field: i32 }\n+    ///\n+    /// impl Provider for SomeConcreteType {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_ref::<str>(&self.field)\n+    ///             .provide_value::<i32, _>(|| self.num_field);\n+    ///     }\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>);\n+}\n+\n+/// Request a value from the `Provider`.\n+///\n+/// # Examples\n+///\n+/// Get a string value from a provider.\n+///\n+/// ```rust\n+/// # #![feature(provide_any)]\n+/// use std::any::{Provider, request_value};\n+///\n+/// fn get_string<P: Provider>(provider: &P) -> String {\n+///     request_value::<String, _>(provider).unwrap()\n+/// }\n+/// ```\n+#[unstable(feature = \"provide_any\", issue = \"96024\")]\n+pub fn request_value<'a, T, P>(provider: &'a P) -> Option<T>\n+where\n+    T: 'static,\n+    P: Provider + ?Sized,\n+{\n+    request_by_type_tag::<'a, tags::Value<T>, P>(provider)\n+}\n+\n+/// Request a reference from the `Provider`.\n+///\n+/// # Examples\n+///\n+/// Get a string reference from a provider.\n+///\n+/// ```rust\n+/// # #![feature(provide_any)]\n+/// use std::any::{Provider, request_ref};\n+///\n+/// fn get_str<P: Provider>(provider: &P) -> &str {\n+///     request_ref::<str, _>(provider).unwrap()\n+/// }\n+/// ```\n+#[unstable(feature = \"provide_any\", issue = \"96024\")]\n+pub fn request_ref<'a, T, P>(provider: &'a P) -> Option<&'a T>\n+where\n+    T: 'static + ?Sized,\n+    P: Provider + ?Sized,\n+{\n+    request_by_type_tag::<'a, tags::Ref<tags::MaybeSizedValue<T>>, P>(provider)\n+}\n+\n+/// Request a specific value by tag from the `Provider`.\n+fn request_by_type_tag<'a, I, P>(provider: &'a P) -> Option<I::Reified>\n+where\n+    I: tags::Type<'a>,\n+    P: Provider + ?Sized,\n+{\n+    let mut tagged = TaggedOption::<'a, I>(None);\n+    provider.provide(tagged.as_demand());\n+    tagged.0\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Demand and its methods\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// A helper object for providing data by type.\n+///\n+/// A data provider provides values by calling this type's provide methods.\n+#[unstable(feature = \"provide_any\", issue = \"96024\")]\n+#[repr(transparent)]\n+pub struct Demand<'a>(dyn Erased<'a> + 'a);\n+\n+impl<'a> Demand<'a> {\n+    /// Create a new `&mut Demand` from a `&mut dyn Erased` trait object.\n+    fn new<'b>(erased: &'b mut (dyn Erased<'a> + 'a)) -> &'b mut Demand<'a> {\n+        // SAFETY: transmuting `&mut (dyn Erased<'a> + 'a)` to `&mut Demand<'a>` is safe since\n+        // `Demand` is repr(transparent).\n+        unsafe { &mut *(erased as *mut dyn Erased<'a> as *mut Demand<'a>) }\n+    }\n+\n+    /// Provide a value or other type with only static lifetimes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Provides a `String` by cloning.\n+    ///\n+    /// ```rust\n+    /// # #![feature(provide_any)]\n+    /// use std::any::{Provider, Demand};\n+    /// # struct SomeConcreteType { field: String }\n+    ///\n+    /// impl Provider for SomeConcreteType {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_value::<String, _>(|| self.field.clone());\n+    ///     }\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn provide_value<T, F>(&mut self, fulfil: F) -> &mut Self\n+    where\n+        T: 'static,\n+        F: FnOnce() -> T,\n+    {\n+        self.provide_with::<tags::Value<T>, F>(fulfil)\n+    }\n+\n+    /// Provide a reference, note that the referee type must be bounded by `'static`,\n+    /// but may be unsized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Provides a reference to a field as a `&str`.\n+    ///\n+    /// ```rust\n+    /// # #![feature(provide_any)]\n+    /// use std::any::{Provider, Demand};\n+    /// # struct SomeConcreteType { field: String }\n+    ///\n+    /// impl Provider for SomeConcreteType {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_ref::<str>(&self.field);\n+    ///     }\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn provide_ref<T: ?Sized + 'static>(&mut self, value: &'a T) -> &mut Self {\n+        self.provide::<tags::Ref<tags::MaybeSizedValue<T>>>(value)\n+    }\n+\n+    /// Provide a value with the given `Type` tag.\n+    fn provide<I>(&mut self, value: I::Reified) -> &mut Self\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        if let Some(res @ TaggedOption(None)) = self.0.downcast_mut::<I>() {\n+            res.0 = Some(value);\n+        }\n+        self\n+    }\n+\n+    /// Provide a value with the given `Type` tag, using a closure to prevent unnecessary work.\n+    fn provide_with<I, F>(&mut self, fulfil: F) -> &mut Self\n+    where\n+        I: tags::Type<'a>,\n+        F: FnOnce() -> I::Reified,\n+    {\n+        if let Some(res @ TaggedOption(None)) = self.0.downcast_mut::<I>() {\n+            res.0 = Some(fulfil());\n+        }\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"provide_any\", issue = \"96024\")]\n+impl<'a> fmt::Debug for Demand<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Demand\").finish_non_exhaustive()\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Type tags\n+///////////////////////////////////////////////////////////////////////////////\n+\n+mod tags {\n+    //! Type tags are used to identify a type using a separate value. This module includes type tags\n+    //! for some very common types.\n+    //!\n+    //! Currently type tags are not exposed to the user. But in the future, if you want to use the\n+    //! Provider API with more complex types (typically those including lifetime parameters), you\n+    //! will need to write your own tags.\n+\n+    use crate::marker::PhantomData;\n+\n+    /// This trait is implemented by specific tag types in order to allow\n+    /// describing a type which can be requested for a given lifetime `'a`.\n+    ///\n+    /// A few example implementations for type-driven tags can be found in this\n+    /// module, although crates may also implement their own tags for more\n+    /// complex types with internal lifetimes.\n+    pub trait Type<'a>: Sized + 'static {\n+        /// The type of values which may be tagged by this tag for the given\n+        /// lifetime.\n+        type Reified: 'a;\n+    }\n+\n+    /// Similar to the [`Type`] trait, but represents a type which may be unsized (i.e., has a\n+    /// `?Sized` bound). E.g., `str`.\n+    pub trait MaybeSizedType<'a>: Sized + 'static {\n+        type Reified: 'a + ?Sized;\n+    }\n+\n+    impl<'a, T: Type<'a>> MaybeSizedType<'a> for T {\n+        type Reified = T::Reified;\n+    }\n+\n+    /// Type-based tag for types bounded by `'static`, i.e., with no borrowed elements.\n+    #[derive(Debug)]\n+    pub struct Value<T: 'static>(PhantomData<T>);\n+\n+    impl<'a, T: 'static> Type<'a> for Value<T> {\n+        type Reified = T;\n+    }\n+\n+    /// Type-based tag similar to [`Value`] but which may be unsized (i.e., has a `'Sized` bound).\n+    #[derive(Debug)]\n+    pub struct MaybeSizedValue<T: ?Sized + 'static>(PhantomData<T>);\n+\n+    impl<'a, T: ?Sized + 'static> MaybeSizedType<'a> for MaybeSizedValue<T> {\n+        type Reified = T;\n+    }\n+\n+    /// Type-based tag for reference types (`&'a T`, where T is represented by\n+    /// `<I as MaybeSizedType<'a>>::Reified`.\n+    #[derive(Debug)]\n+    pub struct Ref<I>(PhantomData<I>);\n+\n+    impl<'a, I: MaybeSizedType<'a>> Type<'a> for Ref<I> {\n+        type Reified = &'a I::Reified;\n+    }\n+}\n+\n+/// An `Option` with a type tag `I`.\n+///\n+/// Since this struct implements `Erased`, the type can be erased to make a dynamically typed\n+/// option. The type can be checked dynamically using `Erased::tag_id` and since this is statically\n+/// checked for the concrete type, there is some degree of type safety.\n+#[repr(transparent)]\n+struct TaggedOption<'a, I: tags::Type<'a>>(Option<I::Reified>);\n+\n+impl<'a, I: tags::Type<'a>> TaggedOption<'a, I> {\n+    fn as_demand(&mut self) -> &mut Demand<'a> {\n+        Demand::new(self as &mut (dyn Erased<'a> + 'a))\n+    }\n+}\n+\n+/// Represents a type-erased but identifiable object.\n+///\n+/// This trait is exclusively implemented by the `TaggedOption` type.\n+unsafe trait Erased<'a>: 'a {\n+    /// The `TypeId` of the erased type.\n+    fn tag_id(&self) -> TypeId;\n+}\n+\n+unsafe impl<'a, I: tags::Type<'a>> Erased<'a> for TaggedOption<'a, I> {\n+    fn tag_id(&self) -> TypeId {\n+        TypeId::of::<I>()\n+    }\n+}\n+\n+#[unstable(feature = \"provide_any\", issue = \"96024\")]\n+impl<'a> dyn Erased<'a> + 'a {\n+    /// Returns some reference to the dynamic value if it is tagged with `I`,\n+    /// or `None` otherwise.\n+    #[inline]\n+    fn downcast_mut<I>(&mut self) -> Option<&mut TaggedOption<'a, I>>\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        if self.tag_id() == TypeId::of::<I>() {\n+            // SAFETY: Just checked whether we're pointing to an I.\n+            Some(unsafe { &mut *(self as *mut Self).cast::<TaggedOption<'a, I>>() })\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "cdc6fadbab7074ddcd521b92523a0a650d1fa87b", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "patch": "@@ -130,3 +130,65 @@ fn distinct_type_names() {\n \n     assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n }\n+\n+// Test the `Provider` API.\n+\n+struct SomeConcreteType {\n+    some_string: String,\n+}\n+\n+impl Provider for SomeConcreteType {\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        demand\n+            .provide_ref::<String>(&self.some_string)\n+            .provide_ref::<str>(&self.some_string)\n+            .provide_value::<String, _>(|| \"bye\".to_owned());\n+    }\n+}\n+\n+// Test the provide and request mechanisms with a by-reference trait object.\n+#[test]\n+fn test_provider() {\n+    let obj: &dyn Provider = &SomeConcreteType { some_string: \"hello\".to_owned() };\n+\n+    assert_eq!(&**request_ref::<String, _>(obj).unwrap(), \"hello\");\n+    assert_eq!(&*request_value::<String, _>(obj).unwrap(), \"bye\");\n+    assert_eq!(request_value::<u8, _>(obj), None);\n+}\n+\n+// Test the provide and request mechanisms with a boxed trait object.\n+#[test]\n+fn test_provider_boxed() {\n+    let obj: Box<dyn Provider> = Box::new(SomeConcreteType { some_string: \"hello\".to_owned() });\n+\n+    assert_eq!(&**request_ref::<String, _>(&*obj).unwrap(), \"hello\");\n+    assert_eq!(&*request_value::<String, _>(&*obj).unwrap(), \"bye\");\n+    assert_eq!(request_value::<u8, _>(&*obj), None);\n+}\n+\n+// Test the provide and request mechanisms with a concrete object.\n+#[test]\n+fn test_provider_concrete() {\n+    let obj = SomeConcreteType { some_string: \"hello\".to_owned() };\n+\n+    assert_eq!(&**request_ref::<String, _>(&obj).unwrap(), \"hello\");\n+    assert_eq!(&*request_value::<String, _>(&obj).unwrap(), \"bye\");\n+    assert_eq!(request_value::<u8, _>(&obj), None);\n+}\n+\n+trait OtherTrait: Provider {}\n+\n+impl OtherTrait for SomeConcreteType {}\n+\n+impl dyn OtherTrait {\n+    fn get_ref<T: 'static + ?Sized>(&self) -> Option<&T> {\n+        request_ref::<T, _>(self)\n+    }\n+}\n+\n+// Test the provide and request mechanisms via an intermediate trait.\n+#[test]\n+fn test_provider_intermediate() {\n+    let obj: &dyn OtherTrait = &SomeConcreteType { some_string: \"hello\".to_owned() };\n+    assert_eq!(obj.get_ref::<str>().unwrap(), \"hello\");\n+}"}, {"sha": "63c9602abe75cf653cb67f08acbf068b918c5f20", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9aff9c42cb94974dc80e3c5ae3d2727eaae9682/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=e9aff9c42cb94974dc80e3c5ae3d2727eaae9682", "patch": "@@ -96,6 +96,7 @@\n #![feature(const_slice_from_ref)]\n #![feature(waker_getters)]\n #![feature(slice_flatten)]\n+#![feature(provide_any)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}]}