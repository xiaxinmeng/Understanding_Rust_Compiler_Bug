{"sha": "5a4fa4554f26b1d34c4b336f4609edc65704643e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNGZhNDU1NGYyNmIxZDM0YzRiMzM2ZjQ2MDllZGM2NTcwNDY0M2U=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-06T22:48:30Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-06T23:41:41Z"}, "message": "linker: Some minor code cleanup", "tree": {"sha": "dc9da5a93bdfb8188b2644854ae8fdb94acedcdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc9da5a93bdfb8188b2644854ae8fdb94acedcdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a4fa4554f26b1d34c4b336f4609edc65704643e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4fa4554f26b1d34c4b336f4609edc65704643e", "html_url": "https://github.com/rust-lang/rust/commit/5a4fa4554f26b1d34c4b336f4609edc65704643e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a4fa4554f26b1d34c4b336f4609edc65704643e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "379c255eb926e4bb577121c84437ab3934aa4475", "url": "https://api.github.com/repos/rust-lang/rust/commits/379c255eb926e4bb577121c84437ab3934aa4475", "html_url": "https://github.com/rust-lang/rust/commit/379c255eb926e4bb577121c84437ab3934aa4475"}], "stats": {"total": 96, "additions": 38, "deletions": 58}, "files": [{"sha": "20e64f0c488515c5baec199c38afd8d0e0117a84", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 38, "deletions": 58, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5a4fa4554f26b1d34c4b336f4609edc65704643e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4fa4554f26b1d34c4b336f4609edc65704643e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=5a4fa4554f26b1d34c4b336f4609edc65704643e", "patch": "@@ -154,7 +154,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n+fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n     let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n \n     // If our linker looks like a batch script on Windows then to execute this\n@@ -285,11 +285,7 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata<'a>(\n-    sess: &'a Session,\n-    metadata: &EncodedMetadata,\n-    tmpdir: &TempDir,\n-) -> PathBuf {\n+pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &TempDir) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, &metadata.raw_data);\n \n@@ -744,7 +740,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n-pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     fn infer_from(\n         sess: &Session,\n         linker: Option<PathBuf>,\n@@ -832,7 +828,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n /// Returns a boolean indicating whether we should preserve the object files on\n /// the filesystem for their debug information. This is often useful with\n /// split-dwarf like schemes.\n-pub fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // If the objects don't have debuginfo there's nothing to preserve.\n     if sess.opts.debuginfo == config::DebugInfo::None {\n         return false;\n@@ -886,7 +882,7 @@ enum RlibFlavor {\n     StaticlibBase,\n }\n \n-pub fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n+fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     let lib_args: Vec<_> = all_native_libs\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n@@ -1012,7 +1008,7 @@ fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     PathBuf::from(name)\n }\n \n-pub fn exec_linker(\n+fn exec_linker(\n     sess: &Session,\n     cmd: &Command,\n     out_filename: &Path,\n@@ -1161,7 +1157,7 @@ pub fn exec_linker(\n }\n \n /// Add begin object files defined by the target spec.\n-fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &'a Session, crate_type: config::CrateType) {\n+fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n     let pre_link_objects = if crate_type == config::CrateType::Executable {\n         &sess.target.target.options.pre_link_objects_exe\n     } else {\n@@ -1179,7 +1175,7 @@ fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &'a Session, crate_type: con\n }\n \n /// Add end object files defined by the target spec.\n-fn add_post_link_objects(cmd: &mut dyn Linker, sess: &'a Session, crate_type: config::CrateType) {\n+fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.add_object(&get_object_file_path(sess, obj));\n     }\n@@ -1194,7 +1190,7 @@ fn add_post_link_objects(cmd: &mut dyn Linker, sess: &'a Session, crate_type: co\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_pre_link_args(\n     cmd: &mut dyn Linker,\n-    sess: &'a Session,\n+    sess: &Session,\n     flavor: LinkerFlavor,\n     crate_type: config::CrateType,\n ) {\n@@ -1213,7 +1209,7 @@ fn add_pre_link_args(\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_user_defined_link_args(\n     cmd: &mut dyn Linker,\n-    sess: &'a Session,\n+    sess: &Session,\n     codegen_results: &CodegenResults,\n ) {\n     cmd.args(&sess.opts.cg.link_args);\n@@ -1224,7 +1220,7 @@ fn add_user_defined_link_args(\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_late_link_args(\n     cmd: &mut dyn Linker,\n-    sess: &'a Session,\n+    sess: &Session,\n     flavor: LinkerFlavor,\n     crate_type: config::CrateType,\n     codegen_results: &CodegenResults,\n@@ -1249,7 +1245,7 @@ fn add_late_link_args(\n \n /// Add arbitrary \"post-link\" args defined by the target spec.\n /// FIXME: Determine where exactly these args need to be inserted.\n-fn add_post_link_args(cmd: &mut dyn Linker, sess: &'a Session, flavor: LinkerFlavor) {\n+fn add_post_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n@@ -1264,8 +1260,7 @@ fn add_local_crate_regular_objects(cmd: &mut dyn Linker, codegen_results: &Codeg\n \n /// Add object files for allocator code linked once for the whole crate tree.\n fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n-    let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n+    if let Some(obj) = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref()) {\n         cmd.add_object(obj);\n     }\n }\n@@ -1280,8 +1275,8 @@ fn add_local_crate_metadata_objects(\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n-        let obj = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref());\n-        if let Some(obj) = obj {\n+        if let Some(obj) = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref())\n+        {\n             cmd.add_object(obj);\n         }\n     }\n@@ -1337,25 +1332,24 @@ fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'\n }\n \n /// Add sysroot and other globally set directories to the directory search list.\n-fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &'a Session) {\n-    // The default library location, we need this to find the runtime.\n-    // The location of crates will be determined as needed.\n-    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n-\n-    // prefer system mingw-w64 libs, see get_crt_libs_path comment for more details\n+fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n+    // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n     if cfg!(windows) && sess.target.target.llvm_target.contains(\"windows-gnu\") {\n         if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n             cmd.include_path(&compiler_libs_path);\n         }\n     }\n \n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n }\n \n /// Add options requesting executables to be position-independent or not position-independent.\n fn add_position_independent_executable_args(\n     cmd: &mut dyn Linker,\n-    sess: &'a Session,\n+    sess: &Session,\n     flavor: LinkerFlavor,\n     crate_type: config::CrateType,\n     codegen_results: &CodegenResults,\n@@ -1364,55 +1358,41 @@ fn add_position_independent_executable_args(\n         return;\n     }\n \n-    let mut position_independent_executable = false;\n     if sess.target.target.options.position_independent_executables {\n         let attr_link_args = &*codegen_results.crate_info.link_args;\n         let mut user_defined_link_args = sess.opts.cg.link_args.iter().chain(attr_link_args);\n         if is_pic(sess)\n             && !sess.crt_static(Some(crate_type))\n             && !user_defined_link_args.any(|x| x == \"-static\")\n         {\n-            position_independent_executable = true;\n+            cmd.position_independent_executable();\n+            return;\n         }\n     }\n \n-    if position_independent_executable {\n-        cmd.position_independent_executable();\n-    } else {\n-        // recent versions of gcc can be configured to generate position\n-        // independent executables by default. We have to pass -no-pie to\n-        // explicitly turn that off. Not applicable to ld.\n-        if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n-            cmd.no_position_independent_executable();\n-        }\n+    // Recent versions of gcc can be configured to generate position\n+    // independent executables by default. We have to pass -no-pie to\n+    // explicitly turn that off. Not applicable to ld.\n+    if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n+        cmd.no_position_independent_executable();\n     }\n }\n \n /// Add options making relocation sections in the produced ELF files read-only\n /// and suppressing lazy binding.\n-fn add_relro_args(cmd: &mut dyn Linker, sess: &'a Session) {\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => sess.target.target.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        }\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        }\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        }\n+fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) {\n+    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.target.options.relro_level) {\n+        RelroLevel::Full => cmd.full_relro(),\n+        RelroLevel::Partial => cmd.partial_relro(),\n+        RelroLevel::Off => cmd.no_relro(),\n         RelroLevel::None => {}\n     }\n }\n \n /// Add library search paths used at runtime by dynamic linkers.\n fn add_rpath_args(\n     cmd: &mut dyn Linker,\n-    sess: &'a Session,\n+    sess: &Session,\n     codegen_results: &CodegenResults,\n     out_filename: &Path,\n ) {\n@@ -1623,7 +1603,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-pub fn add_local_native_libraries(\n+fn add_local_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n@@ -1953,7 +1933,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(\n+fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n@@ -2010,14 +1990,14 @@ pub fn add_upstream_native_libraries(\n     }\n }\n \n-pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,\n     }\n }\n \n-pub fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n     match sess.lto() {\n         config::Lto::Fat => true,\n         config::Lto::Thin => {"}]}