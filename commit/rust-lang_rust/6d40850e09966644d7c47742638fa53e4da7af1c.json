{"sha": "6d40850e09966644d7c47742638fa53e4da7af1c", "node_id": "C_kwDOAAsO6NoAKDZkNDA4NTBlMDk5NjY2NDRkN2M0Nzc0MjYzOGZhNTNlNGRhN2FmMWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-09T22:29:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-09T22:29:56Z"}, "message": "Rollup merge of #93503 - michaelwoerister:fix-vtable-holder-debuginfo-regression, r=wesleywiser\n\ndebuginfo: Fix DW_AT_containing_type vtable debuginfo regression\n\nThis PR brings back the `DW_AT_containing_type` attribute for vtables after it has accidentally been removed in #89597.\n\nIt also implements a more accurate description of vtables. Instead of describing them as an array of void pointers, the compiler will now emit a struct type description with a field for each entry of the vtable.\n\nr? ``@wesleywiser``\n\nThis PR should fix issue https://github.com/rust-lang/rust/issues/93164.\n~~The PR is blocked on https://github.com/rust-lang/rust/pull/93154 because both of them modify the `codegen/debug-vtable.rs` test case.~~", "tree": {"sha": "9c07dc3ae5d2f7ec93c949cc11e8026e77386014", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c07dc3ae5d2f7ec93c949cc11e8026e77386014"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d40850e09966644d7c47742638fa53e4da7af1c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBEBlCRBK7hj4Ov3rIwAA0nYIAHd03TaZ488oCN7Tkn/C1WF+\nskTMrPyPZNVc69LPeVBRaAcwh9h6JIT2cN42s0HPH9AFVoDKxTQIGglBl7VMxBri\nwKFOxZkVZCuO4q6Kp+efbYnF7oj1jSLn2CBZHv+LnelqQHvTtQCL2rKdFMfc3lif\nRTYjGKp3rimUT4KzRE8CZEsTxkDUxUhS6x+ZNS1RKHAiJ82byhq36T2sNxHHwaGq\n8DFouCQKjCz+YZoyYt+AfS5a2Ewj68JuzBWiHH4T64prThq1DtTy70RbAVLKYsra\nQwt8RadP3nAd2uzf5Sm7jv12UH0KkdAx1WRS2ebFcbUxlf0U0zzccizxtF6LYZg=\n=8QUD\n-----END PGP SIGNATURE-----\n", "payload": "tree 9c07dc3ae5d2f7ec93c949cc11e8026e77386014\nparent 3f4aaf4f2e9fd49736e660475f446619e8734e09\nparent ed21805aee9ad1abed5dc5157ac568e95fd84afb\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644445796 +0100\ncommitter GitHub <noreply@github.com> 1644445796 +0100\n\nRollup merge of #93503 - michaelwoerister:fix-vtable-holder-debuginfo-regression, r=wesleywiser\n\ndebuginfo: Fix DW_AT_containing_type vtable debuginfo regression\n\nThis PR brings back the `DW_AT_containing_type` attribute for vtables after it has accidentally been removed in #89597.\n\nIt also implements a more accurate description of vtables. Instead of describing them as an array of void pointers, the compiler will now emit a struct type description with a field for each entry of the vtable.\n\nr? ``@wesleywiser``\n\nThis PR should fix issue https://github.com/rust-lang/rust/issues/93164.\n~~The PR is blocked on https://github.com/rust-lang/rust/pull/93154 because both of them modify the `codegen/debug-vtable.rs` test case.~~\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d40850e09966644d7c47742638fa53e4da7af1c", "html_url": "https://github.com/rust-lang/rust/commit/6d40850e09966644d7c47742638fa53e4da7af1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d40850e09966644d7c47742638fa53e4da7af1c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4aaf4f2e9fd49736e660475f446619e8734e09", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4aaf4f2e9fd49736e660475f446619e8734e09", "html_url": "https://github.com/rust-lang/rust/commit/3f4aaf4f2e9fd49736e660475f446619e8734e09"}, {"sha": "ed21805aee9ad1abed5dc5157ac568e95fd84afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed21805aee9ad1abed5dc5157ac568e95fd84afb", "html_url": "https://github.com/rust-lang/rust/commit/ed21805aee9ad1abed5dc5157ac568e95fd84afb"}], "stats": {"total": 277, "additions": 214, "deletions": 63}, "files": [{"sha": "da997dd98792fea8451cc8549c860f1244b901ac", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 146, "deletions": 35, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/6d40850e09966644d7c47742638fa53e4da7af1c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40850e09966644d7c47742638fa53e4da7af1c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=6d40850e09966644d7c47742638fa53e4da7af1c", "patch": "@@ -21,6 +21,7 @@ use crate::value::Value;\n \n use cstr::cstr;\n use rustc_codegen_ssa::debuginfo::type_names::cpp_like_debuginfo;\n+use rustc_codegen_ssa::debuginfo::type_names::VTableNameKind;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -276,6 +277,12 @@ impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n     ) -> String {\n         format!(\"{}_variant_part\", self.get_unique_type_id_as_string(enum_type_id))\n     }\n+\n+    /// Gets the `UniqueTypeId` for the type of a vtable.\n+    fn get_unique_type_id_of_vtable_type(&mut self, vtable_type_name: &str) -> UniqueTypeId {\n+        let interner_key = self.unique_id_interner.intern(vtable_type_name);\n+        interner_key\n+    }\n }\n \n /// A description of some recursive type. It can either be already finished (as\n@@ -351,14 +358,15 @@ impl<'ll, 'tcx> RecursiveTypeDescription<'ll, 'tcx> {\n \n                 // ... then create the member descriptions ...\n                 let member_descriptions = member_description_factory.create_member_descriptions(cx);\n+                let type_params = compute_type_parameters(cx, unfinished_type);\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(\n                     cx,\n-                    unfinished_type,\n                     member_holding_stub,\n                     member_descriptions,\n                     None,\n+                    type_params,\n                 );\n                 MetadataCreationResult::new(metadata_stub, true)\n             }\n@@ -983,7 +991,17 @@ fn foreign_type_metadata<'ll, 'tcx>(\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n     let name = compute_debuginfo_type_name(cx.tcx, t, false);\n-    create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA, DIFlags::FlagZero)\n+    let (size, align) = cx.size_and_align_of(t);\n+    create_struct_stub(\n+        cx,\n+        size,\n+        align,\n+        &name,\n+        unique_type_id,\n+        NO_SCOPE_METADATA,\n+        DIFlags::FlagZero,\n+        None,\n+    )\n }\n \n fn param_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n@@ -1299,14 +1317,17 @@ fn prepare_struct_metadata<'ll, 'tcx>(\n     };\n \n     let containing_scope = get_namespace_for_item(cx, struct_def_id);\n+    let (size, align) = cx.size_and_align_of(struct_type);\n \n     let struct_metadata_stub = create_struct_stub(\n         cx,\n-        struct_type,\n+        size,\n+        align,\n         &struct_name,\n         unique_type_id,\n         Some(containing_scope),\n         DIFlags::FlagZero,\n+        None,\n     );\n \n     create_and_register_recursive_type_forward_declaration(\n@@ -1398,15 +1419,18 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n     unique_type_id: UniqueTypeId,\n     containing_scope: Option<&'ll DIScope>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n+    let (size, align) = cx.size_and_align_of(tuple_type);\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n \n     let struct_stub = create_struct_stub(\n         cx,\n-        tuple_type,\n+        size,\n+        align,\n         &tuple_name[..],\n         unique_type_id,\n         containing_scope,\n         DIFlags::FlagZero,\n+        None,\n     );\n \n     create_and_register_recursive_type_forward_declaration(\n@@ -1581,13 +1605,14 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     describe_enum_variant(cx, self.layout, variant_info, self_metadata);\n \n                 let member_descriptions = member_description_factory.create_member_descriptions(cx);\n+                let type_params = compute_type_parameters(cx, self.enum_type);\n \n                 set_members_of_composite_type(\n                     cx,\n-                    self.enum_type,\n                     variant_type_metadata,\n                     member_descriptions,\n                     Some(&self.common_members),\n+                    type_params,\n                 );\n                 vec![MemberDescription {\n                     name: variant_info.variant_name(),\n@@ -1648,13 +1673,14 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                         let member_descriptions =\n                             member_desc_factory.create_member_descriptions(cx);\n+                        let type_params = compute_type_parameters(cx, self.enum_type);\n \n                         set_members_of_composite_type(\n                             cx,\n-                            self.enum_type,\n                             variant_type_metadata,\n                             member_descriptions,\n                             Some(&self.common_members),\n+                            type_params,\n                         );\n \n                         MemberDescription {\n@@ -1777,13 +1803,14 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     );\n \n                     let member_descriptions = member_desc_factory.create_member_descriptions(cx);\n+                    let type_params = compute_type_parameters(cx, self.enum_type);\n \n                     set_members_of_composite_type(\n                         cx,\n-                        self.enum_type,\n                         variant_type_metadata,\n                         member_descriptions,\n                         Some(&self.common_members),\n+                        type_params,\n                     );\n \n                     let (size, align) =\n@@ -1823,13 +1850,14 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                             let member_descriptions =\n                                 member_desc_factory.create_member_descriptions(cx);\n+                            let type_params = compute_type_parameters(cx, self.enum_type);\n \n                             set_members_of_composite_type(\n                                 cx,\n-                                self.enum_type,\n                                 variant_type_metadata,\n                                 member_descriptions,\n                                 Some(&self.common_members),\n+                                type_params,\n                             );\n \n                             let niche_value = calculate_niche_value(i);\n@@ -1965,13 +1993,18 @@ fn describe_enum_variant<'ll, 'tcx>(\n             .type_map\n             .borrow_mut()\n             .get_unique_type_id_of_enum_variant(cx, layout.ty, variant_name);\n+\n+        let (size, align) = cx.size_and_align_of(layout.ty);\n+\n         create_struct_stub(\n             cx,\n-            layout.ty,\n+            size,\n+            align,\n             variant_name,\n             unique_type_id,\n             Some(containing_scope),\n             DIFlags::FlagZero,\n+            None,\n         )\n     });\n \n@@ -2308,33 +2341,38 @@ fn composite_type_metadata<'ll, 'tcx>(\n     member_descriptions: Vec<MemberDescription<'ll>>,\n     containing_scope: Option<&'ll DIScope>,\n ) -> &'ll DICompositeType {\n+    let (size, align) = cx.size_and_align_of(composite_type);\n+\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(\n         cx,\n-        composite_type,\n+        size,\n+        align,\n         composite_type_name,\n         composite_type_unique_id,\n         containing_scope,\n         DIFlags::FlagZero,\n+        None,\n     );\n+\n     // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(\n         cx,\n-        composite_type,\n         composite_type_metadata,\n         member_descriptions,\n         None,\n+        compute_type_parameters(cx, composite_type),\n     );\n \n     composite_type_metadata\n }\n \n fn set_members_of_composite_type<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    composite_type: Ty<'tcx>,\n     composite_type_metadata: &'ll DICompositeType,\n     member_descriptions: Vec<MemberDescription<'ll>>,\n     common_members: Option<&Vec<Option<&'ll DIType>>>,\n+    type_params: &'ll DIArray,\n ) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n@@ -2361,13 +2399,12 @@ fn set_members_of_composite_type<'ll, 'tcx>(\n         member_metadata.extend(other_members.iter());\n     }\n \n-    let type_params = compute_type_parameters(cx, composite_type);\n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), &member_metadata);\n+        let field_array = create_DIArray(DIB(cx), &member_metadata);\n         llvm::LLVMRustDICompositeTypeReplaceArrays(\n             DIB(cx),\n             composite_type_metadata,\n-            Some(type_array),\n+            Some(field_array),\n             Some(type_params),\n         );\n     }\n@@ -2420,14 +2457,14 @@ fn compute_type_parameters<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -\n /// with `set_members_of_composite_type()`.\n fn create_struct_stub<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    struct_type: Ty<'tcx>,\n-    struct_type_name: &str,\n+    size: Size,\n+    align: Align,\n+    type_name: &str,\n     unique_type_id: UniqueTypeId,\n     containing_scope: Option<&'ll DIScope>,\n     flags: DIFlags,\n+    vtable_holder: Option<&'ll DIType>,\n ) -> &'ll DICompositeType {\n-    let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n-\n     let type_map = debug_context(cx).type_map.borrow();\n     let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n \n@@ -2440,17 +2477,17 @@ fn create_struct_stub<'ll, 'tcx>(\n         llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n             containing_scope,\n-            struct_type_name.as_ptr().cast(),\n-            struct_type_name.len(),\n+            type_name.as_ptr().cast(),\n+            type_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            struct_size.bits(),\n-            struct_align.bits() as u32,\n+            size.bits(),\n+            align.bits() as u32,\n             flags,\n             None,\n             empty_array,\n             0,\n-            None,\n+            vtable_holder,\n             unique_type_id.as_ptr().cast(),\n             unique_type_id.len(),\n         )\n@@ -2556,6 +2593,14 @@ pub fn create_global_var_metadata<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId, g\n }\n \n /// Generates LLVM debuginfo for a vtable.\n+///\n+/// The vtable type looks like a struct with a field for each function pointer and super-trait\n+/// pointer it contains (plus the `size` and `align` fields).\n+///\n+/// Except for `size`, `align`, and `drop_in_place`, the field names don't try to mirror\n+/// the name of the method they implement. This can be implemented in the future once there\n+/// is a proper disambiguation scheme for dealing with methods from different traits that have\n+/// the same name.\n fn vtable_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -2572,16 +2617,81 @@ fn vtable_type_metadata<'ll, 'tcx>(\n         COMMON_VTABLE_ENTRIES\n     };\n \n-    // FIXME: We describe the vtable as an array of *const () pointers. The length of the array is\n-    //        correct - but we could create a more accurate description, e.g. by describing it\n-    //        as a struct where each field has a name that corresponds to the name of the method\n-    //        it points to.\n-    //        However, this is not entirely straightforward because there might be multiple\n-    //        methods with the same name if the vtable is for multiple traits. So for now we keep\n-    //        things simple instead of adding some ad-hoc disambiguation scheme.\n-    let vtable_type = tcx.mk_array(tcx.mk_imm_ptr(tcx.types.unit), vtable_entries.len() as u64);\n+    // All function pointers are described as opaque pointers. This could be improved in the future\n+    // by describing them as actual function pointers.\n+    let void_pointer_ty = tcx.mk_imm_ptr(tcx.types.unit);\n+    let void_pointer_type_debuginfo = type_metadata(cx, void_pointer_ty);\n+    let usize_debuginfo = type_metadata(cx, tcx.types.usize);\n+    let (pointer_size, pointer_align) = cx.size_and_align_of(void_pointer_ty);\n+    // If `usize` is not pointer-sized and -aligned then the size and alignment computations\n+    // for the vtable as a whole would be wrong. Let's make sure this holds even on weird\n+    // platforms.\n+    assert_eq!(cx.size_and_align_of(tcx.types.usize), (pointer_size, pointer_align));\n+\n+    let vtable_type_name =\n+        compute_debuginfo_vtable_name(cx.tcx, ty, poly_trait_ref, VTableNameKind::Type);\n+    let unique_type_id = debug_context(cx)\n+        .type_map\n+        .borrow_mut()\n+        .get_unique_type_id_of_vtable_type(&vtable_type_name);\n+    let size = pointer_size * vtable_entries.len() as u64;\n+\n+    // This gets mapped to a DW_AT_containing_type attribute which allows GDB to correlate\n+    // the vtable to the type it is for.\n+    let vtable_holder = type_metadata(cx, ty);\n+\n+    let vtable_type_metadata = create_struct_stub(\n+        cx,\n+        size,\n+        pointer_align,\n+        &vtable_type_name,\n+        unique_type_id,\n+        NO_SCOPE_METADATA,\n+        DIFlags::FlagArtificial,\n+        Some(vtable_holder),\n+    );\n+\n+    // Create a field for each entry in the vtable.\n+    let fields: Vec<_> = vtable_entries\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(index, vtable_entry)| {\n+            let (field_name, field_type) = match vtable_entry {\n+                ty::VtblEntry::MetadataDropInPlace => {\n+                    (\"drop_in_place\".to_string(), void_pointer_type_debuginfo)\n+                }\n+                ty::VtblEntry::Method(_) => {\n+                    // Note: This code does not try to give a proper name to each method\n+                    //       because there might be multiple methods with the same name\n+                    //       (coming from different traits).\n+                    (format!(\"__method{}\", index), void_pointer_type_debuginfo)\n+                }\n+                ty::VtblEntry::TraitVPtr(_) => {\n+                    // Note: In the future we could try to set the type of this pointer\n+                    //       to the type that we generate for the corresponding vtable.\n+                    (format!(\"__super_trait_ptr{}\", index), void_pointer_type_debuginfo)\n+                }\n+                ty::VtblEntry::MetadataAlign => (\"align\".to_string(), usize_debuginfo),\n+                ty::VtblEntry::MetadataSize => (\"size\".to_string(), usize_debuginfo),\n+                ty::VtblEntry::Vacant => return None,\n+            };\n+\n+            Some(MemberDescription {\n+                name: field_name,\n+                type_metadata: field_type,\n+                offset: pointer_size * index as u64,\n+                size: pointer_size,\n+                align: pointer_align,\n+                flags: DIFlags::FlagZero,\n+                discriminant: None,\n+                source_info: None,\n+            })\n+        })\n+        .collect();\n \n-    type_metadata(cx, vtable_type)\n+    let type_params = create_DIArray(DIB(cx), &[]);\n+    set_members_of_composite_type(cx, vtable_type_metadata, fields, None, type_params);\n+    vtable_type_metadata\n }\n \n /// Creates debug information for the given vtable, which is for the\n@@ -2603,11 +2713,12 @@ pub fn create_vtable_metadata<'ll, 'tcx>(\n         return;\n     }\n \n-    let vtable_name = compute_debuginfo_vtable_name(cx.tcx, ty, poly_trait_ref);\n+    let vtable_name =\n+        compute_debuginfo_vtable_name(cx.tcx, ty, poly_trait_ref, VTableNameKind::GlobalVariable);\n     let vtable_type = vtable_type_metadata(cx, ty, poly_trait_ref);\n+    let linkage_name = \"\";\n \n     unsafe {\n-        let linkage_name = \"\";\n         llvm::LLVMRustDIBuilderCreateStaticVariable(\n             DIB(cx),\n             NO_SCOPE_METADATA,"}, {"sha": "3cb19c0eec624b4e8460efff15d413e51fac6f18", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6d40850e09966644d7c47742638fa53e4da7af1c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40850e09966644d7c47742638fa53e4da7af1c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=6d40850e09966644d7c47742638fa53e4da7af1c", "patch": "@@ -469,7 +469,14 @@ fn push_debuginfo_type_name<'tcx>(\n     }\n }\n \n-/// Computes a name for the global variable storing a vtable.\n+pub enum VTableNameKind {\n+    // Is the name for the const/static holding the vtable?\n+    GlobalVariable,\n+    // Is the name for the type of the vtable?\n+    Type,\n+}\n+\n+/// Computes a name for the global variable storing a vtable (or the type of that global variable).\n ///\n /// The name is of the form:\n ///\n@@ -478,10 +485,15 @@ fn push_debuginfo_type_name<'tcx>(\n /// or, when generating C++-like names:\n ///\n /// `impl$<path::to::SomeType, path::to::SomeTrait>::vtable$`\n+///\n+/// If `kind` is `VTableNameKind::Type` then the last component is `{vtable_ty}` instead of just\n+/// `{vtable}`, so that the type and the corresponding global variable get assigned different\n+/// names.\n pub fn compute_debuginfo_vtable_name<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     t: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    kind: VTableNameKind,\n ) -> String {\n     let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n@@ -514,7 +526,12 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n \n     push_close_angle_bracket(cpp_like_debuginfo, &mut vtable_name);\n \n-    let suffix = if cpp_like_debuginfo { \"::vtable$\" } else { \"::{vtable}\" };\n+    let suffix = match (cpp_like_debuginfo, kind) {\n+        (true, VTableNameKind::GlobalVariable) => \"::vtable$\",\n+        (false, VTableNameKind::GlobalVariable) => \"::{vtable}\",\n+        (true, VTableNameKind::Type) => \"::vtable_type$\",\n+        (false, VTableNameKind::Type) => \"::{vtable_type}\",\n+    };\n \n     vtable_name.reserve_exact(suffix.len());\n     vtable_name.push_str(suffix);"}, {"sha": "b9cb4f93d07d8159e8a4016380a6a140a8793620", "filename": "src/test/codegen/debug-vtable.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6d40850e09966644d7c47742638fa53e4da7af1c/src%2Ftest%2Fcodegen%2Fdebug-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40850e09966644d7c47742638fa53e4da7af1c/src%2Ftest%2Fcodegen%2Fdebug-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdebug-vtable.rs?ref=6d40850e09966644d7c47742638fa53e4da7af1c", "patch": "@@ -9,19 +9,41 @@\n // compile-flags: -Cdebuginfo=2 -Copt-level=0 -Csymbol-mangling-version=v0\n // ignore-tidy-linelength\n \n+// NONMSVC: ![[USIZE:[0-9]+]] = !DIBasicType(name: \"usize\"\n+// MSVC: ![[USIZE:[0-9]+]] = !DIDerivedType(tag: DW_TAG_typedef, name: \"usize\"\n+// NONMSVC: ![[PTR:[0-9]+]] = !DIDerivedType(tag: DW_TAG_pointer_type, name: \"*const ()\"\n+// MSVC: ![[PTR:[0-9]+]] = !DIDerivedType(tag: DW_TAG_pointer_type, name: \"ptr_const$<tuple$<> >\"\n+\n // NONMSVC: !DIGlobalVariable(name: \"<debug_vtable::Foo as debug_vtable::SomeTrait>::{vtable}\"\n // MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::Foo, debug_vtable::SomeTrait>::vtable$\"\n-// NONMSVC: !DIDerivedType(tag: DW_TAG_pointer_type, name: \"*const ()\",\n-// MSVC: !DIDerivedType(tag: DW_TAG_pointer_type, name: \"ptr_const$<tuple$<> >\",\n-// CHECK: !DISubrange(count: 5\n+\n+// NONMSVC: ![[VTABLE_TY0:[0-9]+]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"<debug_vtable::Foo as debug_vtable::SomeTrait>::{vtable_type}\", {{.*}} size: {{320|160}}, align: {{64|32}}, flags: DIFlagArtificial, {{.*}} vtableHolder: ![[FOO_TYPE:[0-9]+]],\n+// MSVC: ![[VTABLE_TY0:[0-9]+]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"impl$<debug_vtable::Foo, debug_vtable::SomeTrait>::vtable_type$\", {{.*}} size: {{320|160}}, align: {{64|32}}, flags: DIFlagArtificial, {{.*}} vtableHolder: ![[FOO_TYPE:[0-9]+]],\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"drop_in_place\", scope: ![[VTABLE_TY0]], {{.*}} baseType: ![[PTR]], size: {{64|32}}, align: {{64|32}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"size\", scope: ![[VTABLE_TY0]], {{.*}} baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{64|32}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"align\", scope: ![[VTABLE_TY0]], {{.*}} baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{128|64}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"__method3\", scope: ![[VTABLE_TY0]], {{.*}} baseType: ![[PTR]], size: {{64|32}}, align: {{64|32}}, offset: {{192|96}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"__method4\", scope: ![[VTABLE_TY0]], {{.*}} baseType: ![[PTR]], size: {{64|32}}, align: {{64|32}}, offset: {{256|128}})\n+// CHECK: ![[FOO_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Foo\",\n \n // NONMSVC: !DIGlobalVariable(name: \"<debug_vtable::Foo as debug_vtable::SomeTraitWithGenerics<u64, i8>>::{vtable}\"\n // MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::Foo, debug_vtable::SomeTraitWithGenerics<u64,i8> >::vtable$\"\n-// CHECK: !DISubrange(count: 4\n+\n+// NONMSVC: ![[VTABLE_TY1:[0-9]+]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"<debug_vtable::Foo as debug_vtable::SomeTraitWithGenerics<u64, i8>>::{vtable_type}\", {{.*}}, size: {{256|128}}, align: {{64|32}}, flags: DIFlagArtificial, {{.*}}, vtableHolder: ![[FOO_TYPE]],\n+// MSVC: ![[VTABLE_TY1:[0-9]+]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"impl$<debug_vtable::Foo, debug_vtable::SomeTraitWithGenerics<u64,i8> >::vtable_type$\", {{.*}}, size: {{256|128}}, align: {{64|32}}, flags: DIFlagArtificial, {{.*}}, vtableHolder: ![[FOO_TYPE]],\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"drop_in_place\", scope: ![[VTABLE_TY1]], {{.*}} baseType: ![[PTR]], size: {{64|32}}, align: {{64|32}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"size\", scope: ![[VTABLE_TY1]], {{.*}} baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{64|32}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"align\", scope: ![[VTABLE_TY1]], {{.*}} baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{128|64}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"__method3\", scope: ![[VTABLE_TY1]], {{.*}} baseType: ![[PTR]], size: {{64|32}}, align: {{64|32}}, offset: {{192|96}})\n \n // NONMSVC: !DIGlobalVariable(name: \"<debug_vtable::Foo as _>::{vtable}\"\n // MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::Foo, _>::vtable$\"\n-// CHECK: !DISubrange(count: 3\n+\n+// NONMSVC: ![[VTABLE_TY2:[0-9]+]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"<debug_vtable::Foo as _>::{vtable_type}\", {{.*}}, size: {{192|96}}, align: {{64|32}}, flags: DIFlagArtificial, {{.*}}, vtableHolder: ![[FOO_TYPE]],\n+// MSVC: ![[VTABLE_TY2:[0-9]+]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"impl$<debug_vtable::Foo, _>::vtable_type$\", {{.*}}, size: {{192|96}}, align: {{64|32}}, flags: DIFlagArtificial, {{.*}}, vtableHolder: ![[FOO_TYPE]],\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"drop_in_place\", scope: ![[VTABLE_TY2]], {{.*}}, baseType: ![[PTR]], size: {{64|32}}, align: {{64|32}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"size\", scope: ![[VTABLE_TY2]], {{.*}}, baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{64|32}})\n+// CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"align\", scope: ![[VTABLE_TY2]], {{.*}}, baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{128|64}})\n \n // NONMSVC: !DIGlobalVariable(name: \"<debug_vtable::bar::{closure_env#0} as core::ops::function::FnOnce<(core::option::Option<&dyn core::ops::function::Fn<(), Output=()>>)>>::{vtable}\"\n // MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::bar::closure_env$0, core::ops::function::FnOnce<tuple$<enum$<core::option::Option<ref$<dyn$<core::ops::function::Fn<tuple$<>,assoc$<Output,tuple$<> > > > > >, {{.*}}, {{.*}}, Some> > > >::vtable$\"\n@@ -34,6 +56,9 @@\n \n #![crate_type = \"lib\"]\n \n+// Force emission for debuginfo for usize and *const() early..\n+pub static mut XYZ: Option<(usize, *const ())> = None;\n+\n pub struct Foo;\n \n pub trait SomeTrait {"}, {"sha": "ad59f740b567f7ad58974ba473ebd19d7f678f22", "filename": "src/test/codegen/debuginfo-generic-closure-env-names.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d40850e09966644d7c47742638fa53e4da7af1c/src%2Ftest%2Fcodegen%2Fdebuginfo-generic-closure-env-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40850e09966644d7c47742638fa53e4da7af1c/src%2Ftest%2Fcodegen%2Fdebuginfo-generic-closure-env-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdebuginfo-generic-closure-env-names.rs?ref=6d40850e09966644d7c47742638fa53e4da7af1c", "patch": "@@ -17,35 +17,34 @@\n \n // compile-flags: -Cdebuginfo=2 --edition 2021 -Copt-level=0 -Csymbol-mangling-version=v0\n \n-\n-// CHECK: [[non_generic_closure_NAMESPACE:!.*]] = !DINamespace(name: \"non_generic_closure\"\n-// CHECK: [[function_containing_closure_NAMESPACE:!.*]] = !DINamespace(name: \"function_containing_closure\"\n-// CHECK: [[generic_async_function_NAMESPACE:!.*]] = !DINamespace(name: \"generic_async_function\"\n-// CHECK: [[generic_async_block_NAMESPACE:!.*]] = !DINamespace(name: \"generic_async_block\"\n-\n // non_generic_closure()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}\", scope: [[non_generic_closure_NAMESPACE]]\n-// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0\", scope: [[non_generic_closure_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}\", scope: ![[non_generic_closure_NAMESPACE:[0-9]+]],\n+// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0\", scope: ![[non_generic_closure_NAMESPACE:[0-9]+]],\n+// CHECK: ![[non_generic_closure_NAMESPACE]] = !DINamespace(name: \"non_generic_closure\"\n+\n+// CHECK: ![[function_containing_closure_NAMESPACE:[0-9]+]] = !DINamespace(name: \"function_containing_closure\"\n+// CHECK: ![[generic_async_function_NAMESPACE:[0-9]+]] = !DINamespace(name: \"generic_async_function\"\n+// CHECK: ![[generic_async_block_NAMESPACE:[0-9]+]] = !DINamespace(name: \"generic_async_block\"\n \n // function_containing_closure<u32>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<u32>\", scope: [[function_containing_closure_NAMESPACE]]\n-// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<u32>\", scope: [[function_containing_closure_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<u32>\", scope: ![[function_containing_closure_NAMESPACE]]\n+// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<u32>\", scope: ![[function_containing_closure_NAMESPACE]]\n \n // generic_async_function<Foo>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: [[generic_async_function_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[generic_async_function_NAMESPACE]]\n \n // generic_async_function<u32>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<u32>\", scope: [[generic_async_function_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<u32>\", scope: ![[generic_async_function_NAMESPACE]]\n \n // generic_async_block<Foo>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: [[generic_async_block_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[generic_async_block_NAMESPACE]]\n \n // generic_async_block<u32>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<u32>\", scope: [[generic_async_block_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<u32>\", scope: ![[generic_async_block_NAMESPACE]]\n \n // function_containing_closure<Foo>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: [[function_containing_closure_NAMESPACE]]\n-// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<debuginfo_generic_closure_env_names::Foo>\", scope: [[function_containing_closure_NAMESPACE]]\n+// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[function_containing_closure_NAMESPACE]]\n+// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<debuginfo_generic_closure_env_names::Foo>\", scope: ![[function_containing_closure_NAMESPACE]]\n \n \n #![crate_type = \"lib\"]\n@@ -54,15 +53,14 @@ use std::future::Future;\n pub struct Foo;\n \n pub fn non_generic_closure(x: Foo) -> Box<dyn FnOnce() -> Foo> {\n-    // This static only exists to trigger generating the namespace debuginfo for\n-    // `function_containing_closure` at a predictable, early point, which makes\n-    // writing the FileCheck tests above simpler.\n-    static _X: u8 = 0;\n     return Box::new(move || x);\n }\n \n fn function_containing_closure<T: 'static>(x: T) -> impl FnOnce() -> T {\n-    static _X: u8 = 0; // Same as above\n+    // This static only exists to trigger generating the namespace debuginfo for\n+    // `function_containing_closure` at a predictable, early point, which makes\n+    // writing the FileCheck tests above simpler.\n+    static _X: u8 = 0;\n \n     return move || x;\n }"}]}