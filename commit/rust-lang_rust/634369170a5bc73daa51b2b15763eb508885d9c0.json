{"sha": "634369170a5bc73daa51b2b15763eb508885d9c0", "node_id": "C_kwDOAAsO6NoAKDYzNDM2OTE3MGE1YmM3M2RhYTUxYjJiMTU3NjNlYjUwODg4NWQ5YzA", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-03-25T02:29:33Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:18:54Z"}, "message": "Add documentation for the semantics of MIR rvalues", "tree": {"sha": "6622779a5bfacc16e066e1f5e35c23c10fd82467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6622779a5bfacc16e066e1f5e35c23c10fd82467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/634369170a5bc73daa51b2b15763eb508885d9c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/634369170a5bc73daa51b2b15763eb508885d9c0", "html_url": "https://github.com/rust-lang/rust/commit/634369170a5bc73daa51b2b15763eb508885d9c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/634369170a5bc73daa51b2b15763eb508885d9c0/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f4a7a074299a1450f02365de2d80a8c13f03510", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4a7a074299a1450f02365de2d80a8c13f03510", "html_url": "https://github.com/rust-lang/rust/commit/2f4a7a074299a1450f02365de2d80a8c13f03510"}], "stats": {"total": 124, "additions": 101, "deletions": 23}, "files": [{"sha": "fd2b5f5335f69689407c5041f275536ae33d6b8f", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/634369170a5bc73daa51b2b15763eb508885d9c0/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634369170a5bc73daa51b2b15763eb508885d9c0/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=634369170a5bc73daa51b2b15763eb508885d9c0", "patch": "@@ -59,6 +59,7 @@\n #![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n+#![feature(intra_doc_pointers)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "8c4d289a4c34b8c6299afe0499f7ebdd6bdf7000", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 100, "deletions": 23, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/634369170a5bc73daa51b2b15763eb508885d9c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634369170a5bc73daa51b2b15763eb508885d9c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=634369170a5bc73daa51b2b15763eb508885d9c0", "patch": "@@ -2388,57 +2388,134 @@ impl<'tcx> Operand<'tcx> {\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n /// The various kinds of rvalues that can appear in MIR.\n ///\n-/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n-/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n-/// causing an ICE if they are violated.\n+/// Not all of these are allowed at every [`MirPhase`] - when this is the case, it's stated below.\n+///\n+/// Computing any rvalue begins by evaluating the places and operands in the rvalue in the order in\n+/// which they appear. These are then used to produce a \"value\" - the same kind of value that an\n+/// [`Operand`] is.\n pub enum Rvalue<'tcx> {\n-    /// x (either a move or copy, depending on type of x)\n+    /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n \n-    /// [x; 32]\n+    /// Creates an array where each element is the value of the operand. This currently does not\n+    /// drop the value even if the number of repetitions is zero, see [#74836].\n+    ///\n+    /// Corresponds to source code like `[x; 32]`.\n+    ///\n+    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n     Repeat(Operand<'tcx>, ty::Const<'tcx>),\n \n-    /// &x or &mut x\n+    /// Creates a reference of the indicated kind to the place.\n+    ///\n+    /// There is not much to document here, because besides the obvious parts the semantics of this\n+    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n+    /// exactly what the behavior of this operation should be.\n+    ///\n+    /// `Shallow` borrows are disallowed after drop lowering.\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n-    /// Accessing a thread local static. This is inherently a runtime operation, even if llvm\n-    /// treats it as an access to a static. This `Rvalue` yields a reference to the thread local\n-    /// static.\n+    /// Returns a pointer/reference to the given thread local.\n+    ///\n+    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n+    /// `*const T`, and if neither of those apply a `&T`.\n+    ///\n+    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n+    /// like a function call. Also, DSEing these causes `fn main() {}` to SIGILL for some reason\n+    /// that I never got a chance to look into.\n+    ///\n+    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n+    /// nature of this operation?\n     ThreadLocalRef(DefId),\n \n-    /// Create a raw pointer to the given place\n-    /// Can be generated by raw address of expressions (`&raw const x`),\n-    /// or when casting a reference to a raw pointer.\n+    /// Creates a pointer with the indicated mutability to the place.\n+    ///\n+    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n+    /// `&raw v` or `addr_of!(v)`.\n+    ///\n+    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n+    /// model.\n     AddressOf(Mutability, Place<'tcx>),\n \n-    /// length of a `[X]` or `[X;n]` value\n+    /// Yields the length of the place, as a `usize`.\n+    ///\n+    /// If the type of the place is an array, this is the array length. This also works for slices\n+    /// (`[T]`, not `&[T]`) through some mechanism that depends on how exactly places work (see\n+    /// there for more details).\n     Len(Place<'tcx>),\n \n+    /// Performs essentially all of the casts that can be performed via `as`.\n+    ///\n+    /// This allows for casts from/to a variety of types.\n+    ///\n+    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n+    /// `ArrayToPointer` and `MutToConstPointer` are special.\n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n+    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n+    ///   paramter may be a `usize` as well.\n+    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n+    ///   raw pointers, or function pointers and return a `bool`.\n+    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n+    ///   same type and return a value of the same type as their LHS. For all other operations, the\n+    ///   types of the operands must match.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools and return a\n+    ///   value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats of any\n+    ///   matching type and return a value of that type.\n     BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n+\n+    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n+    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n+    /// unequal to the actual result and sets the `bool` if this is the case. `BinOp::Offset` is not\n+    /// allowed here.\n+    ///\n+    /// **FIXME**: What about division/modulo? Are they allowed here at all? Are zero divisors still\n+    /// UB? Also, which other combinations of types are disallowed?\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n+    /// Yields the size or alignment of the type as a `usize`.\n     NullaryOp(NullOp, Ty<'tcx>),\n+\n+    /// Exactly like `BinaryOp`, but less operands.\n+    ///\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float; binary\n+    /// not requires a signed integer, unsigned integer, or bool. Both operation kinds return a\n+    /// value with the same type as their operand.\n     UnaryOp(UnOp, Operand<'tcx>),\n \n-    /// Read the discriminant of an ADT.\n+    /// Computes the discriminant of the place, returning it as an integer of type\n+    /// [`discriminant_ty`].\n+    ///\n+    /// The validity requirements for the underlying value are undecided for this rvalue, see\n+    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n+    /// variant index; use [`discriminant_for_variant`] to convert.\n+    ///\n+    /// For types defined in the source code as enums, this is well behaved. This is also well\n+    /// formed for other types, but yields no particular value - there is no reason it couldn't be\n+    /// defined to yield eg zero though.\n     ///\n-    /// Undefined (i.e., no effort is made to make it defined, but there\u2019s no reason why it cannot\n-    /// be defined to return, say, a 0) if ADT is not an enum.\n+    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n+    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n+    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n     Discriminant(Place<'tcx>),\n \n-    /// Creates an aggregate value, like a tuple or struct. This is\n-    /// only needed because we want to distinguish `dest = Foo { x:\n-    /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n-    /// that `Foo` has a destructor. These rvalues can be optimized\n-    /// away after type-checking and before lowering.\n+    /// Creates an aggregate value, like a tuple or struct.\n+    ///\n+    /// This is needed because dataflow analysis needs to distinguish\n+    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n+    /// has a destructor.\n+    ///\n+    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n+    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n \n     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n     ///\n-    /// This is different a normal transmute because dataflow analysis will treat the box\n-    /// as initialized but its content as uninitialized.\n+    /// This is different a normal transmute because dataflow analysis will treat the box as\n+    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n+    /// affects alias analysis.\n+    ///\n+    /// Disallowed after drop elaboration.\n     ShallowInitBox(Operand<'tcx>, Ty<'tcx>),\n }\n "}]}