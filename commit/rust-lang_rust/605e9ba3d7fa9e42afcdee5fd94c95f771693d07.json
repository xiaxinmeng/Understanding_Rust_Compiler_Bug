{"sha": "605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNWU5YmEzZDdmYTllNDJhZmNkZWU1ZmQ5NGM5NWY3NzE2OTNkMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-12T06:09:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-12T06:09:07Z"}, "message": "Auto merge of #6179 - flip1995:rewrite_use_self, r=phansch\n\nRework use_self impl based on ty::Ty comparison #3410 | Take 2\n\nThis builds on top of #5531\n\nI already reviewed and approved the commits by `@montrivo.` So only the review of my commits should be necessary.\n\nI would also appreciate your review `@montrivo,` since you are familiar with the challenges here.\n\nFixes #3410 and Fixes #4143 (same problem)\nFixes #2843\nFixes #3859\nFixes #4734 and fixes #6221\nFixes #4305\nFixes #5078 (even at expression level now \ud83c\udf89)\nFixes #3881 and Fixes #4887 (same problem)\nFixes #3909\n\nNot yet: #4140 (test added)\n\nAll the credit for the fixes goes to `@montrivo.` I only refactored and copy and pasted his code.\n\nchangelog: rewrite [`use_self`] lint and fix multiple (8) FPs. One to go.", "tree": {"sha": "c6723dbec3614b9b7784fa0e2399b3d496a4b7a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6723dbec3614b9b7784fa0e2399b3d496a4b7a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "html_url": "https://github.com/rust-lang/rust/commit/605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa2c1d63a296442d503f16901bd15e1d2222086e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa2c1d63a296442d503f16901bd15e1d2222086e", "html_url": "https://github.com/rust-lang/rust/commit/fa2c1d63a296442d503f16901bd15e1d2222086e"}, {"sha": "52f98d832dc5ca982b9edad7807b2a9a9ddd13e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/52f98d832dc5ca982b9edad7807b2a9a9ddd13e0", "html_url": "https://github.com/rust-lang/rust/commit/52f98d832dc5ca982b9edad7807b2a9a9ddd13e0"}], "stats": {"total": 1151, "additions": 880, "deletions": 271}, "files": [{"sha": "a0dd53af661b61e35ac3bbd9e3440c210d7a7969", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 369, "deletions": 194, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -1,24 +1,24 @@\n+use crate::utils::{in_macro, meets_msrv, snippet_opt, span_lint_and_sugg};\n use if_chain::if_chain;\n+\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::def::DefKind;\n use rustc_hir::{\n-    def, FnDecl, FnRetTy, FnSig, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Path, PathSegment, QPath,\n-    TyKind,\n+    def,\n+    def_id::LocalDefId,\n+    intravisit::{walk_ty, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n+    QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_middle::ty::{DefIdTree, Ty};\n+use rustc_middle::ty::{AssocKind, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::kw;\n+use rustc_span::{BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{differing_macro_contexts, meets_msrv, span_lint_and_sugg};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for unnecessary repetition of structure name when a\n     /// replacement with `Self` is applicable.\n@@ -28,10 +28,11 @@ declare_clippy_lint! {\n     /// feels inconsistent.\n     ///\n     /// **Known problems:**\n-    /// - False positive when using associated types ([#2843](https://github.com/rust-lang/rust-clippy/issues/2843))\n-    /// - False positives in some situations when using generics ([#3410](https://github.com/rust-lang/rust-clippy/issues/3410))\n+    /// - Unaddressed false negative in fn bodies of trait implementations\n+    /// - False positive with assotiated types in traits (#4140)\n     ///\n     /// **Example:**\n+    ///\n     /// ```rust\n     /// struct Foo {}\n     /// impl Foo {\n@@ -54,235 +55,409 @@ declare_clippy_lint! {\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n-impl_lint_pass!(UseSelf => [USE_SELF]);\n-\n-const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n-\n-fn span_use_self_lint(cx: &LateContext<'_>, path: &Path<'_>, last_segment: Option<&PathSegment<'_>>) {\n-    let last_segment = last_segment.unwrap_or_else(|| path.segments.last().expect(SEGMENTS_MSG));\n+#[derive(Default)]\n+pub struct UseSelf {\n+    msrv: Option<RustcVersion>,\n+    stack: Vec<StackItem>,\n+}\n \n-    // Path segments only include actual path, no methods or fields.\n-    let last_path_span = last_segment.ident.span;\n+const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n \n-    if differing_macro_contexts(path.span, last_path_span) {\n-        return;\n+impl UseSelf {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Self::default()\n+        }\n     }\n-\n-    // Only take path up to the end of last_path_span.\n-    let span = path.span.with_hi(last_path_span.hi());\n-\n-    span_lint_and_sugg(\n-        cx,\n-        USE_SELF,\n-        span,\n-        \"unnecessary structure name repetition\",\n-        \"use the applicable keyword\",\n-        \"Self\".to_owned(),\n-        Applicability::MachineApplicable,\n-    );\n }\n \n-// FIXME: always use this (more correct) visitor, not just in method signatures.\n-struct SemanticUseSelfVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    self_ty: Ty<'tcx>,\n+#[derive(Debug)]\n+enum StackItem {\n+    Check {\n+        hir_id: HirId,\n+        impl_trait_ref_def_id: Option<LocalDefId>,\n+        types_to_skip: Vec<HirId>,\n+        types_to_lint: Vec<HirId>,\n+    },\n+    NoCheck,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for SemanticUseSelfVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n+impl_lint_pass!(UseSelf => [USE_SELF]);\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = &hir_ty.kind {\n-            match path.res {\n-                def::Res::SelfTy(..) => {},\n-                _ => {\n-                    if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n-                        span_use_self_lint(self.cx, path, None);\n-                    }\n-                },\n-            }\n-        }\n+const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n-        walk_ty(self, hir_ty)\n+impl<'tcx> LateLintPass<'tcx> for UseSelf {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // We push the self types of `impl`s on a stack here. Only the top type on the stack is\n+        // relevant for linting, since this is the self type of the `impl` we're currently in. To\n+        // avoid linting on nested items, we push `StackItem::NoCheck` on the stack to signal, that\n+        // we're in an `impl` or nested item, that we don't want to lint\n+        //\n+        // NB: If you push something on the stack in this method, remember to also pop it in the\n+        // `check_item_post` method.\n+        match &item.kind {\n+            ItemKind::Impl(Impl {\n+                self_ty: hir_self_ty,\n+                of_trait,\n+                ..\n+            }) => {\n+                let should_check = if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind {\n+                    let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n+                    parameters.as_ref().map_or(true, |params| {\n+                        !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n+                    })\n+                } else {\n+                    false\n+                };\n+                let impl_trait_ref_def_id = of_trait.as_ref().map(|_| cx.tcx.hir().local_def_id(item.hir_id));\n+                if should_check {\n+                    self.stack.push(StackItem::Check {\n+                        hir_id: hir_self_ty.hir_id,\n+                        impl_trait_ref_def_id,\n+                        types_to_lint: Vec::new(),\n+                        types_to_skip: Vec::new(),\n+                    });\n+                } else {\n+                    self.stack.push(StackItem::NoCheck);\n+                }\n+            },\n+            ItemKind::Static(..)\n+            | ItemKind::Const(..)\n+            | ItemKind::Fn(..)\n+            | ItemKind::Enum(..)\n+            | ItemKind::Struct(..)\n+            | ItemKind::Union(..)\n+            | ItemKind::Trait(..) => {\n+                self.stack.push(StackItem::NoCheck);\n+            },\n+            _ => (),\n+        }\n     }\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+    fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n+        use ItemKind::{Const, Enum, Fn, Impl, Static, Struct, Trait, Union};\n+        match item.kind {\n+            Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..) => {\n+                self.stack.pop();\n+            },\n+            _ => (),\n+        }\n     }\n-}\n \n-fn check_trait_method_impl_decl<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    impl_item: &ImplItem<'_>,\n-    impl_decl: &'tcx FnDecl<'_>,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-) {\n-    let trait_method = cx\n-        .tcx\n-        .associated_items(impl_trait_ref.def_id)\n-        .find_by_name_and_kind(cx.tcx, impl_item.ident, ty::AssocKind::Fn, impl_trait_ref.def_id)\n-        .expect(\"impl method matches a trait method\");\n-\n-    let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n-    let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n-\n-    let output_hir_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n-        Some(&**ty)\n-    } else {\n-        None\n-    };\n-\n-    // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n-    // `trait_ty` (of type `ty::Ty`) is the semantic type for the signature in the trait.\n-    // We use `impl_hir_ty` to see if the type was written as `Self`,\n-    // `hir_ty_to_ty(...)` to check semantic types of paths, and\n-    // `trait_ty` to determine which parts of the signature in the trait, mention\n-    // the type being implemented verbatim (as opposed to `Self`).\n-    for (impl_hir_ty, trait_ty) in impl_decl\n-        .inputs\n-        .iter()\n-        .chain(output_hir_ty)\n-        .zip(trait_method_sig.inputs_and_output)\n-    {\n-        // Check if the input/output type in the trait method specifies the implemented\n-        // type verbatim, and only suggest `Self` if that isn't the case.\n-        // This avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`,\n-        // in an `impl Trait for u8`, when the trait always uses `Vec<u8>`.\n-        // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n-        let self_ty = impl_trait_ref.self_ty();\n-        if !trait_ty.walk().any(|inner| inner == self_ty.into()) {\n-            let mut visitor = SemanticUseSelfVisitor { cx, self_ty };\n-\n-            visitor.visit_ty(&impl_hir_ty);\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n+        // We want to skip types in trait `impl`s that aren't declared as `Self` in the trait\n+        // declaration. The collection of those types is all this method implementation does.\n+        if_chain! {\n+            if let ImplItemKind::Fn(FnSig { decl, .. }, ..) = impl_item.kind;\n+            if let Some(&mut StackItem::Check {\n+                impl_trait_ref_def_id: Some(def_id),\n+                ref mut types_to_skip,\n+                ..\n+            }) = self.stack.last_mut();\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(def_id);\n+            then {\n+                // `self_ty` is the semantic self type of `impl <trait> for <type>`. This cannot be\n+                // `Self`.\n+                let self_ty = impl_trait_ref.self_ty();\n+\n+                // `trait_method_sig` is the signature of the function, how it is declared in the\n+                // trait, not in the impl of the trait.\n+                let trait_method = cx\n+                    .tcx\n+                    .associated_items(impl_trait_ref.def_id)\n+                    .find_by_name_and_kind(cx.tcx, impl_item.ident, AssocKind::Fn, impl_trait_ref.def_id)\n+                    .expect(\"impl method matches a trait method\");\n+                let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n+                let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n+\n+                // `impl_inputs_outputs` is an iterator over the types (`hir::Ty`) declared in the\n+                // implementation of the trait.\n+                let output_hir_ty = if let FnRetTy::Return(ty) = &decl.output {\n+                    Some(&**ty)\n+                } else {\n+                    None\n+                };\n+                let impl_inputs_outputs = decl.inputs.iter().chain(output_hir_ty);\n+\n+                // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n+                //\n+                // `trait_sem_ty` (of type `ty::Ty`) is the semantic type for the signature in the\n+                // trait declaration. This is used to check if `Self` was used in the trait\n+                // declaration.\n+                //\n+                // If `any`where in the `trait_sem_ty` the `self_ty` was used verbatim (as opposed\n+                // to `Self`), we want to skip linting that type and all subtypes of it. This\n+                // avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`, in an `impl Trait\n+                // for u8`, when the trait always uses `Vec<u8>`.\n+                //\n+                // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n+                for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n+                    if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n+                        let mut visitor = SkipTyCollector::default();\n+                        visitor.visit_ty(&impl_hir_ty);\n+                        types_to_skip.extend(visitor.types_to_skip);\n+                    }\n+                }\n+            }\n         }\n     }\n-}\n \n-const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) {\n+        // `hir_ty_to_ty` cannot be called in `Body`s or it will panic (sometimes). But in bodies\n+        // we can use `cx.typeck_results.node_type(..)` to get the `ty::Ty` from a `hir::Ty`.\n+        // However the `node_type()` method can *only* be called in bodies.\n+        //\n+        // This method implementation determines which types should get linted in a `Body` and\n+        // which shouldn't, with a visitor. We could directly lint in the visitor, but then we\n+        // could only allow this lint on item scope. And we would have to check if those types are\n+        // already dealt with in `check_ty` anyway.\n+        if let Some(StackItem::Check {\n+            hir_id,\n+            types_to_lint,\n+            types_to_skip,\n+            ..\n+        }) = self.stack.last_mut()\n+        {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            let mut visitor = LintTyCollector {\n+                cx,\n+                self_ty,\n+                types_to_lint: vec![],\n+                types_to_skip: vec![],\n+            };\n+            visitor.visit_expr(&body.value);\n+            types_to_lint.extend(visitor.types_to_lint);\n+            types_to_skip.extend(visitor.types_to_skip);\n+        }\n+    }\n \n-pub struct UseSelf {\n-    msrv: Option<RustcVersion>,\n-}\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n+        if in_macro(hir_ty.span) | in_impl(cx, hir_ty) | !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n+            return;\n+        }\n \n-impl UseSelf {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n+        let lint_dependend_on_expr_kind = if let Some(StackItem::Check {\n+            hir_id,\n+            types_to_lint,\n+            types_to_skip,\n+            ..\n+        }) = self.stack.last()\n+        {\n+            if types_to_skip.contains(&hir_ty.hir_id) {\n+                false\n+            } else if types_to_lint.contains(&hir_ty.hir_id) {\n+                true\n+            } else {\n+                let self_ty = ty_from_hir_id(cx, *hir_id);\n+                should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n+            }\n+        } else {\n+            false\n+        };\n+\n+        if lint_dependend_on_expr_kind {\n+            // FIXME: this span manipulation should not be necessary\n+            // @flip1995 found an ast lowering issue in\n+            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+            match cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_ty.hir_id)) {\n+                Some(Node::Expr(Expr {\n+                    kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n+                    ..\n+                })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n+                _ => span_lint(cx, hir_ty.span),\n+            }\n+        }\n     }\n-}\n \n-impl<'tcx> LateLintPass<'tcx> for UseSelf {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n-            return;\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n+            let def_id = expr.hir_id.owner;\n+            if cx.tcx.has_typeck_results(def_id) {\n+                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n+            } else {\n+                false\n+            }\n         }\n \n-        if in_external_macro(cx.sess(), item.span) {\n+        if in_macro(expr.span) | !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n             return;\n         }\n-        if_chain! {\n-            if let ItemKind::Impl(impl_) = &item.kind;\n-            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = impl_.self_ty.kind;\n-            then {\n-                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                let should_check = parameters.as_ref().map_or(\n-                    true,\n-                    |params| !params.parenthesized\n-                        &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n-                );\n \n-                if should_check {\n-                    let visitor = &mut UseSelfVisitor {\n-                        item_path,\n-                        cx,\n-                    };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-                    let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n-\n-                    if let Some(impl_trait_ref) = impl_trait_ref {\n-                        for impl_item_ref in impl_.items {\n-                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n-                            if let ImplItemKind::Fn(FnSig{ decl: impl_decl, .. }, impl_body_id)\n-                                    = &impl_item.kind {\n-                                check_trait_method_impl_decl(cx, impl_item, impl_decl, impl_trait_ref);\n-\n-                                let body = cx.tcx.hir().body(*impl_body_id);\n-                                visitor.visit_body(body);\n-                            } else {\n-                                visitor.visit_impl_item(impl_item);\n-                            }\n+        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            match &expr.kind {\n+                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n+                    if expr_ty_matches(cx, expr, self_ty) {\n+                        match path.res {\n+                            def::Res::SelfTy(..) => (),\n+                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n+                            _ => {\n+                                span_lint(cx, path.span);\n+                            },\n                         }\n-                    } else {\n-                        for impl_item_ref in impl_.items {\n-                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n-                            visitor.visit_impl_item(impl_item);\n+                    }\n+                },\n+                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+                ExprKind::Call(fun, _) => {\n+                    if let Expr {\n+                        kind: ExprKind::Path(ref qpath),\n+                        ..\n+                    } = fun\n+                    {\n+                        if expr_ty_matches(cx, expr, self_ty) {\n+                            let res = cx.qpath_res(qpath, fun.hir_id);\n+\n+                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n+                                match ctor_of {\n+                                    def::CtorOf::Variant => {\n+                                        span_lint_on_qpath_resolved(cx, qpath, true);\n+                                    },\n+                                    def::CtorOf::Struct => {\n+                                        span_lint_on_qpath_resolved(cx, qpath, false);\n+                                    },\n+                                }\n+                            }\n                         }\n                     }\n-                }\n+                },\n+                // unit enum variants (`Enum::A`)\n+                ExprKind::Path(qpath) => {\n+                    if expr_ty_matches(cx, expr, self_ty) {\n+                        span_lint_on_qpath_resolved(cx, &qpath, true);\n+                    }\n+                },\n+                _ => (),\n             }\n         }\n     }\n+\n     extract_msrv_attr!(LateContext);\n }\n \n-struct UseSelfVisitor<'a, 'tcx> {\n-    item_path: &'a Path<'a>,\n+#[derive(Default)]\n+struct SkipTyCollector {\n+    types_to_skip: Vec<HirId>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for SkipTyCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, hir_ty: &hir::Ty<'_>) {\n+        self.types_to_skip.push(hir_ty.hir_id);\n+\n+        walk_ty(self, hir_ty)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct LintTyCollector<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    types_to_lint: Vec<HirId>,\n+    types_to_skip: Vec<HirId>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for LintTyCollector<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n-    fn visit_path(&mut self, path: &'tcx Path<'_>, _id: HirId) {\n-        if !path.segments.iter().any(|p| p.ident.span.is_dummy()) {\n-            if path.segments.len() >= 2 {\n-                let last_but_one = &path.segments[path.segments.len() - 2];\n-                if last_but_one.ident.name != kw::SelfUpper {\n-                    let enum_def_id = match path.res {\n-                        Res::Def(DefKind::Variant, variant_def_id) => self.cx.tcx.parent(variant_def_id),\n-                        Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), ctor_def_id) => {\n-                            let variant_def_id = self.cx.tcx.parent(ctor_def_id);\n-                            variant_def_id.and_then(|def_id| self.cx.tcx.parent(def_id))\n-                        },\n-                        _ => None,\n-                    };\n-\n-                    if self.item_path.res.opt_def_id() == enum_def_id {\n-                        span_use_self_lint(self.cx, path, Some(last_but_one));\n-                    }\n-                }\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n+        if_chain! {\n+            if let Some(ty) = self.cx.typeck_results().node_type_opt(hir_ty.hir_id);\n+            if should_lint_ty(hir_ty, ty, self.self_ty);\n+            then {\n+                self.types_to_lint.push(hir_ty.hir_id);\n+            } else {\n+                self.types_to_skip.push(hir_ty.hir_id);\n             }\n+        }\n \n-            if path.segments.last().expect(SEGMENTS_MSG).ident.name != kw::SelfUpper {\n-                if self.item_path.res == path.res {\n-                    span_use_self_lint(self.cx, path, None);\n-                } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, _), ctor_def_id) = path.res {\n-                    if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_def_id) {\n-                        span_use_self_lint(self.cx, path, None);\n-                    }\n-                }\n-            }\n+        walk_ty(self, hir_ty)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn span_lint(cx: &LateContext<'_>, span: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        USE_SELF,\n+        span,\n+        \"unnecessary structure name repetition\",\n+        \"use the applicable keyword\",\n+        \"Self\".to_owned(),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+#[allow(clippy::cast_possible_truncation)]\n+fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n+    let sp = span.with_hi(segment.ident.span.lo());\n+    // remove the trailing ::\n+    let span_without_last_segment = match snippet_opt(cx, sp) {\n+        Some(snippet) => match snippet.rfind(\"::\") {\n+            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n+            None => sp,\n+        },\n+        None => sp,\n+    };\n+    span_lint(cx, span_without_last_segment);\n+}\n+\n+fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if path.segments.len() > 1 {\n+        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n+    }\n+}\n+\n+fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if until_last_segment {\n+            span_lint_on_path_until_last_segment(cx, path);\n+        } else {\n+            span_lint(cx, path.span);\n         }\n+    }\n+}\n \n-        walk_path(self, path);\n+fn ty_from_hir_id<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Ty<'tcx> {\n+    if let Some(Node::Ty(hir_ty)) = cx.tcx.hir().find(hir_id) {\n+        hir_ty_to_ty(cx.tcx, hir_ty)\n+    } else {\n+        unreachable!(\"This function should only be called with `HirId`s that are for sure `Node::Ty`\")\n     }\n+}\n \n-    fn visit_item(&mut self, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Use(..)\n-            | ItemKind::Static(..)\n-            | ItemKind::Enum(..)\n-            | ItemKind::Struct(..)\n-            | ItemKind::Union(..)\n-            | ItemKind::Impl { .. }\n-            | ItemKind::Fn(..) => {\n-                // Don't check statements that shadow `Self` or where `Self` can't be used\n-            },\n-            _ => walk_item(self, item),\n+fn in_impl(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    let parent = map.get_parent_node(hir_ty.hir_id);\n+    if_chain! {\n+        if let Some(Node::Item(item)) = map.find(parent);\n+        if let ItemKind::Impl { .. } = item.kind;\n+        then {\n+            true\n+        } else {\n+            false\n         }\n     }\n+}\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::All(self.cx.tcx.hir())\n+fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n+    if_chain! {\n+        if TyS::same_type(ty, self_ty);\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        then {\n+            !matches!(path.res, def::Res::SelfTy(..))\n+        } else {\n+            false\n+        }\n     }\n }"}, {"sha": "aebeaf346799d3767a483533b9ff1e2f67c17783", "filename": "tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -41,3 +41,15 @@ pub fn derive_foo(_input: TokenStream) -> TokenStream {\n         }\n     }\n }\n+\n+#[proc_macro_derive(StructAUseSelf)]\n+pub fn derive_use_self(_input: TokenStream) -> proc_macro::TokenStream {\n+    quote! {\n+        struct A;\n+        impl A {\n+            fn new() -> A {\n+                A\n+            }\n+        }\n+    }\n+}"}, {"sha": "95e7bc754310f8393cf59cf6939ddc2f8e7bf170", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 215, "deletions": 9, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -1,9 +1,13 @@\n // run-rustfix\n // edition:2018\n+// aux-build:proc_macro_derive.rs\n \n #![warn(clippy::use_self)]\n #![allow(dead_code)]\n-#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms)]\n+#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms, clippy::from_over_into)]\n+\n+#[macro_use]\n+extern crate proc_macro_derive;\n \n fn main() {}\n \n@@ -71,13 +75,12 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n-        #[allow(clippy::wrong_self_convention)]\n-        fn into_bytes(&self) -> Vec<u8>;\n+        fn to_bytes(&self) -> Vec<u8>;\n     }\n \n     // This should not be linted\n     impl IntoBytes for u8 {\n-        fn into_bytes(&self) -> Vec<u8> {\n+        fn to_bytes(&self) -> Vec<u8> {\n             vec![*self]\n         }\n     }\n@@ -110,17 +113,20 @@ mod tuple_structs {\n mod macros {\n     macro_rules! use_self_expand {\n         () => {\n-            fn new() -> Self {\n-                Self {}\n+            fn new() -> Foo {\n+                Foo {}\n             }\n         };\n     }\n \n     struct Foo {}\n \n     impl Foo {\n-        use_self_expand!(); // Should lint in local macros\n+        use_self_expand!(); // Should not lint in local macros\n     }\n+\n+    #[derive(StructAUseSelf)] // Should not lint in derives\n+    struct A;\n }\n \n mod nesting {\n@@ -177,11 +183,22 @@ mod issue3410 {\n     struct B;\n \n     trait Trait<T> {\n-        fn a(v: T);\n+        fn a(v: T) -> Self;\n     }\n \n     impl Trait<Vec<A>> for Vec<B> {\n-        fn a(_: Vec<A>) {}\n+        fn a(_: Vec<A>) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<T> Trait<Vec<A>> for Vec<T>\n+    where\n+        T: Trait<B>,\n+    {\n+        fn a(v: Vec<A>) -> Self {\n+            <Vec<B>>::a(v).into_iter().map(Trait::a).collect()\n+        }\n     }\n }\n \n@@ -252,3 +269,192 @@ mod paths_created_by_lowering {\n         }\n     }\n }\n+\n+// reused from #1997\n+mod generics {\n+    struct Foo<T> {\n+        value: T,\n+    }\n+\n+    impl<T> Foo<T> {\n+        // `Self` is applicable here\n+        fn foo(value: T) -> Self {\n+            Self { value }\n+        }\n+\n+        // `Cannot` use `Self` as a return type as the generic types are different\n+        fn bar(value: i32) -> Foo<i32> {\n+            Foo { value }\n+        }\n+    }\n+}\n+\n+mod issue4140 {\n+    pub struct Error<From, To> {\n+        _from: From,\n+        _too: To,\n+    }\n+\n+    pub trait From<T> {\n+        type From;\n+        type To;\n+\n+        fn from(value: T) -> Self;\n+    }\n+\n+    pub trait TryFrom<T>\n+    where\n+        Self: Sized,\n+    {\n+        type From;\n+        type To;\n+\n+        fn try_from(value: T) -> Result<Self, Error<Self::From, Self::To>>;\n+    }\n+\n+    impl<F, T> TryFrom<F> for T\n+    where\n+        T: From<F>,\n+    {\n+        type From = Self;\n+        type To = Self;\n+\n+        fn try_from(value: F) -> Result<Self, Error<Self::From, Self::To>> {\n+            Ok(From::from(value))\n+        }\n+    }\n+\n+    impl From<bool> for i64 {\n+        type From = bool;\n+        type To = Self;\n+\n+        fn from(value: bool) -> Self {\n+            if value {\n+                100\n+            } else {\n+                0\n+            }\n+        }\n+    }\n+}\n+\n+mod issue2843 {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    impl Foo for usize {\n+        type Bar = u8;\n+    }\n+\n+    impl<T: Foo> Foo for Option<T> {\n+        type Bar = Option<T::Bar>;\n+    }\n+}\n+\n+mod issue3859 {\n+    pub struct Foo;\n+    pub struct Bar([usize; 3]);\n+\n+    impl Foo {\n+        pub const BAR: usize = 3;\n+\n+        pub fn foo() {\n+            const _X: usize = Foo::BAR;\n+            // const _Y: usize = Self::BAR;\n+        }\n+    }\n+}\n+\n+mod issue4305 {\n+    trait Foo: 'static {}\n+\n+    struct Bar;\n+\n+    impl Foo for Bar {}\n+\n+    impl<T: Foo> From<T> for Box<dyn Foo> {\n+        fn from(t: T) -> Self {\n+            Box::new(t)\n+        }\n+    }\n+}\n+\n+mod lint_at_item_level {\n+    struct Foo {}\n+\n+    #[allow(clippy::use_self)]\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    #[allow(clippy::use_self)]\n+    impl Default for Foo {\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod lint_at_impl_item_level {\n+    struct Foo {}\n+\n+    impl Foo {\n+        #[allow(clippy::use_self)]\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    impl Default for Foo {\n+        #[allow(clippy::use_self)]\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod issue4734 {\n+    #[repr(C, packed)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    impl From<X> for u32 {\n+        fn from(c: X) -> Self {\n+            unsafe { core::mem::transmute(c) }\n+        }\n+    }\n+}\n+\n+mod nested_paths {\n+    use std::convert::Into;\n+    mod submod {\n+        pub struct B {}\n+        pub struct C {}\n+\n+        impl Into<C> for B {\n+            fn into(self) -> C {\n+                C {}\n+            }\n+        }\n+    }\n+\n+    struct A<T> {\n+        t: T,\n+    }\n+\n+    impl<T> A<T> {\n+        fn new<V: Into<T>>(v: V) -> Self {\n+            Self { t: Into::into(v) }\n+        }\n+    }\n+\n+    impl A<submod::C> {\n+        fn test() -> Self {\n+            Self::new::<submod::B>(submod::B {})\n+        }\n+    }\n+}"}, {"sha": "75424f341597d1e50aa08ef0362dfeb9b8d1256c", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 214, "deletions": 8, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -1,9 +1,13 @@\n // run-rustfix\n // edition:2018\n+// aux-build:proc_macro_derive.rs\n \n #![warn(clippy::use_self)]\n #![allow(dead_code)]\n-#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms)]\n+#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms, clippy::from_over_into)]\n+\n+#[macro_use]\n+extern crate proc_macro_derive;\n \n fn main() {}\n \n@@ -71,13 +75,12 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n-        #[allow(clippy::wrong_self_convention)]\n-        fn into_bytes(&self) -> Vec<u8>;\n+        fn to_bytes(&self) -> Vec<u8>;\n     }\n \n     // This should not be linted\n     impl IntoBytes for u8 {\n-        fn into_bytes(&self) -> Vec<u8> {\n+        fn to_bytes(&self) -> Vec<u8> {\n             vec![*self]\n         }\n     }\n@@ -87,7 +90,7 @@ mod existential {\n     struct Foo;\n \n     impl Foo {\n-        fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n+        fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n             foos.iter()\n         }\n \n@@ -119,8 +122,11 @@ mod macros {\n     struct Foo {}\n \n     impl Foo {\n-        use_self_expand!(); // Should lint in local macros\n+        use_self_expand!(); // Should not lint in local macros\n     }\n+\n+    #[derive(StructAUseSelf)] // Should not lint in derives\n+    struct A;\n }\n \n mod nesting {\n@@ -177,11 +183,22 @@ mod issue3410 {\n     struct B;\n \n     trait Trait<T> {\n-        fn a(v: T);\n+        fn a(v: T) -> Self;\n     }\n \n     impl Trait<Vec<A>> for Vec<B> {\n-        fn a(_: Vec<A>) {}\n+        fn a(_: Vec<A>) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<T> Trait<Vec<A>> for Vec<T>\n+    where\n+        T: Trait<B>,\n+    {\n+        fn a(v: Vec<A>) -> Self {\n+            <Vec<B>>::a(v).into_iter().map(Trait::a).collect()\n+        }\n     }\n }\n \n@@ -252,3 +269,192 @@ mod paths_created_by_lowering {\n         }\n     }\n }\n+\n+// reused from #1997\n+mod generics {\n+    struct Foo<T> {\n+        value: T,\n+    }\n+\n+    impl<T> Foo<T> {\n+        // `Self` is applicable here\n+        fn foo(value: T) -> Foo<T> {\n+            Foo { value }\n+        }\n+\n+        // `Cannot` use `Self` as a return type as the generic types are different\n+        fn bar(value: i32) -> Foo<i32> {\n+            Foo { value }\n+        }\n+    }\n+}\n+\n+mod issue4140 {\n+    pub struct Error<From, To> {\n+        _from: From,\n+        _too: To,\n+    }\n+\n+    pub trait From<T> {\n+        type From;\n+        type To;\n+\n+        fn from(value: T) -> Self;\n+    }\n+\n+    pub trait TryFrom<T>\n+    where\n+        Self: Sized,\n+    {\n+        type From;\n+        type To;\n+\n+        fn try_from(value: T) -> Result<Self, Error<Self::From, Self::To>>;\n+    }\n+\n+    impl<F, T> TryFrom<F> for T\n+    where\n+        T: From<F>,\n+    {\n+        type From = T::From;\n+        type To = T::To;\n+\n+        fn try_from(value: F) -> Result<Self, Error<Self::From, Self::To>> {\n+            Ok(From::from(value))\n+        }\n+    }\n+\n+    impl From<bool> for i64 {\n+        type From = bool;\n+        type To = Self;\n+\n+        fn from(value: bool) -> Self {\n+            if value {\n+                100\n+            } else {\n+                0\n+            }\n+        }\n+    }\n+}\n+\n+mod issue2843 {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    impl Foo for usize {\n+        type Bar = u8;\n+    }\n+\n+    impl<T: Foo> Foo for Option<T> {\n+        type Bar = Option<T::Bar>;\n+    }\n+}\n+\n+mod issue3859 {\n+    pub struct Foo;\n+    pub struct Bar([usize; 3]);\n+\n+    impl Foo {\n+        pub const BAR: usize = 3;\n+\n+        pub fn foo() {\n+            const _X: usize = Foo::BAR;\n+            // const _Y: usize = Self::BAR;\n+        }\n+    }\n+}\n+\n+mod issue4305 {\n+    trait Foo: 'static {}\n+\n+    struct Bar;\n+\n+    impl Foo for Bar {}\n+\n+    impl<T: Foo> From<T> for Box<dyn Foo> {\n+        fn from(t: T) -> Self {\n+            Box::new(t)\n+        }\n+    }\n+}\n+\n+mod lint_at_item_level {\n+    struct Foo {}\n+\n+    #[allow(clippy::use_self)]\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    #[allow(clippy::use_self)]\n+    impl Default for Foo {\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod lint_at_impl_item_level {\n+    struct Foo {}\n+\n+    impl Foo {\n+        #[allow(clippy::use_self)]\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    impl Default for Foo {\n+        #[allow(clippy::use_self)]\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod issue4734 {\n+    #[repr(C, packed)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    impl From<X> for u32 {\n+        fn from(c: X) -> Self {\n+            unsafe { core::mem::transmute(c) }\n+        }\n+    }\n+}\n+\n+mod nested_paths {\n+    use std::convert::Into;\n+    mod submod {\n+        pub struct B {}\n+        pub struct C {}\n+\n+        impl Into<C> for B {\n+            fn into(self) -> C {\n+                C {}\n+            }\n+        }\n+    }\n+\n+    struct A<T> {\n+        t: T,\n+    }\n+\n+    impl<T> A<T> {\n+        fn new<V: Into<T>>(v: V) -> Self {\n+            Self { t: Into::into(v) }\n+        }\n+    }\n+\n+    impl A<submod::C> {\n+        fn test() -> Self {\n+            A::new::<submod::B>(submod::B {})\n+        }\n+    }\n+}"}, {"sha": "37dfef7cfe0e516996b23ddc5d43c5393a4004d6", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 66, "deletions": 52, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -1,164 +1,178 @@\n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:14:21\n+  --> $DIR/use_self.rs:18:21\n    |\n LL |         fn new() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n    |\n    = note: `-D clippy::use-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:15:13\n+  --> $DIR/use_self.rs:19:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:17:22\n+  --> $DIR/use_self.rs:21:22\n    |\n LL |         fn test() -> Foo {\n    |                      ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:18:13\n+  --> $DIR/use_self.rs:22:13\n    |\n LL |             Foo::new()\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:23:25\n+  --> $DIR/use_self.rs:27:25\n    |\n LL |         fn default() -> Foo {\n    |                         ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:24:13\n+  --> $DIR/use_self.rs:28:13\n    |\n LL |             Foo::new()\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:90:56\n+  --> $DIR/use_self.rs:93:24\n    |\n-LL |         fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n-   |                                                        ^^^ help: use the applicable keyword: `Self`\n+LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n+   |                        ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:105:13\n+  --> $DIR/use_self.rs:93:55\n+   |\n+LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n+   |                                                       ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:108:13\n    |\n LL |             TS(0)\n    |             ^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:113:25\n-   |\n-LL |             fn new() -> Foo {\n-   |                         ^^^ help: use the applicable keyword: `Self`\n-...\n-LL |         use_self_expand!(); // Should lint in local macros\n-   |         ------------------- in this macro invocation\n+  --> $DIR/use_self.rs:143:29\n    |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |                 fn bar() -> Bar {\n+   |                             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:114:17\n-   |\n-LL |                 Foo {}\n-   |                 ^^^ help: use the applicable keyword: `Self`\n-...\n-LL |         use_self_expand!(); // Should lint in local macros\n-   |         ------------------- in this macro invocation\n+  --> $DIR/use_self.rs:144:21\n    |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |                     Bar { foo: Foo {} }\n+   |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:149:21\n+  --> $DIR/use_self.rs:155:21\n    |\n LL |         fn baz() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:150:13\n+  --> $DIR/use_self.rs:156:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:137:29\n-   |\n-LL |                 fn bar() -> Bar {\n-   |                             ^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:138:21\n-   |\n-LL |                     Bar { foo: Foo {} }\n-   |                     ^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:167:21\n+  --> $DIR/use_self.rs:173:21\n    |\n LL |             let _ = Enum::B(42);\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:168:21\n+  --> $DIR/use_self.rs:174:21\n    |\n LL |             let _ = Enum::C { field: true };\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:169:21\n+  --> $DIR/use_self.rs:175:21\n    |\n LL |             let _ = Enum::A;\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:200:13\n+  --> $DIR/use_self.rs:217:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:201:13\n+  --> $DIR/use_self.rs:218:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:203:13\n+  --> $DIR/use_self.rs:220:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:222:13\n+  --> $DIR/use_self.rs:239:13\n    |\n LL |             TestStruct::from_something()\n    |             ^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:236:25\n+  --> $DIR/use_self.rs:253:25\n    |\n LL |         async fn g() -> S {\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:237:13\n+  --> $DIR/use_self.rs:254:13\n    |\n LL |             S {}\n    |             ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:241:16\n+  --> $DIR/use_self.rs:258:16\n    |\n LL |             &p[S::A..S::B]\n    |                ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:241:22\n+  --> $DIR/use_self.rs:258:22\n    |\n LL |             &p[S::A..S::B]\n    |                      ^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 25 previous errors\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:281:29\n+   |\n+LL |         fn foo(value: T) -> Foo<T> {\n+   |                             ^^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:282:13\n+   |\n+LL |             Foo { value }\n+   |             ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:319:21\n+   |\n+LL |         type From = T::From;\n+   |                     ^^^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:320:19\n+   |\n+LL |         type To = T::To;\n+   |                   ^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:457:13\n+   |\n+LL |             A::new::<submod::B>(submod::B {})\n+   |             ^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 29 previous errors\n "}, {"sha": "9bcd692fb3511d805c24f6b49902eb31300936de", "filename": "tests/ui/use_self_trait.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self_trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self_trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self_trait.fixed?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -47,7 +47,8 @@ impl Mul for Bad {\n \n impl Clone for Bad {\n     fn clone(&self) -> Self {\n-        Self\n+        // FIXME: applicable here\n+        Bad\n     }\n }\n "}, {"sha": "de305d40f330b1a4707995a0f286a844b6da0449", "filename": "tests/ui/use_self_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self_trait.rs?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -47,6 +47,7 @@ impl Mul for Bad {\n \n impl Clone for Bad {\n     fn clone(&self) -> Self {\n+        // FIXME: applicable here\n         Bad\n     }\n }"}, {"sha": "55af3ff2a93d9af515ccfea3db0cf2afd2a0be11", "filename": "tests/ui/use_self_trait.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605e9ba3d7fa9e42afcdee5fd94c95f771693d07/tests%2Fui%2Fuse_self_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self_trait.stderr?ref=605e9ba3d7fa9e42afcdee5fd94c95f771693d07", "patch": "@@ -84,11 +84,5 @@ error: unnecessary structure name repetition\n LL |     fn mul(self, rhs: Bad) -> Bad {\n    |                               ^^^ help: use the applicable keyword: `Self`\n \n-error: unnecessary structure name repetition\n-  --> $DIR/use_self_trait.rs:50:9\n-   |\n-LL |         Bad\n-   |         ^^^ help: use the applicable keyword: `Self`\n-\n-error: aborting due to 15 previous errors\n+error: aborting due to 14 previous errors\n "}]}