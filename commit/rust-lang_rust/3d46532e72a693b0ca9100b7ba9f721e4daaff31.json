{"sha": "3d46532e72a693b0ca9100b7ba9f721e4daaff31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNDY1MzJlNzJhNjkzYjBjYTkxMDBiN2JhOWY3MjFlNGRhYWZmMzE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-22T01:36:27Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-22T02:47:00Z"}, "message": "refactor and document the chain reformatting code", "tree": {"sha": "9ab62f417cdd50e773b6a75428d28143f9910a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ab62f417cdd50e773b6a75428d28143f9910a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d46532e72a693b0ca9100b7ba9f721e4daaff31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d46532e72a693b0ca9100b7ba9f721e4daaff31", "html_url": "https://github.com/rust-lang/rust/commit/3d46532e72a693b0ca9100b7ba9f721e4daaff31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d46532e72a693b0ca9100b7ba9f721e4daaff31/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c3228530f5b3fb62554b9db6755e2651908e589", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c3228530f5b3fb62554b9db6755e2651908e589", "html_url": "https://github.com/rust-lang/rust/commit/4c3228530f5b3fb62554b9db6755e2651908e589"}], "stats": {"total": 282, "additions": 202, "deletions": 80}, "files": [{"sha": "5c097c83cb1d1e8fd7fbf3e75718ba7de8ff38d8", "filename": "src/chains.rs", "status": "modified", "additions": 200, "deletions": 78, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3d46532e72a693b0ca9100b7ba9f721e4daaff31/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d46532e72a693b0ca9100b7ba9f721e4daaff31/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=3d46532e72a693b0ca9100b7ba9f721e4daaff31", "patch": "@@ -8,16 +8,88 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Formatting of chained expressions, i.e. expressions which are chained by\n-// dots: struct and enum field access and method calls.\n-//\n-// Instead of walking these subexpressions one-by-one, as is our usual strategy\n-// for expression formatting, we collect maximal sequences of these expressions\n-// and handle them simultaneously.\n-//\n-// Whenever possible, the entire chain is put on a single line. If that fails,\n-// we put each subexpression on a separate, much like the (default) function\n-// argument function argument strategy.\n+/// Formatting of chained expressions, i.e. expressions which are chained by\n+/// dots: struct and enum field access and method calls.\n+///\n+/// Instead of walking these subexpressions one-by-one, as is our usual strategy\n+/// for expression formatting, we collect maximal sequences of these expressions\n+/// and handle them simultaneously.\n+///\n+/// Whenever possible, the entire chain is put on a single line. If that fails,\n+/// we put each subexpression on a separate, much like the (default) function\n+/// argument function argument strategy.\n+///\n+/// Depends on config options: `chain_base_indent` is the indent to use for\n+/// blocks in the parent/root/base of the chain.\n+/// E.g., `let foo = { aaaa; bbb; ccc }.bar.baz();`, we would layout for the\n+/// following values of `chain_base_indent`:\n+/// Visual:\n+/// ```\n+/// let foo = {\n+///               aaaa;\n+///               bbb;\n+///               ccc\n+///           }\n+///           .bar\n+///           .baz();\n+/// ```\n+/// Inherit:\n+/// ```\n+/// let foo = {\n+///     aaaa;\n+///     bbb;\n+///     ccc\n+/// }\n+/// .bar\n+/// .baz();\n+/// ```\n+/// Tabbed:\n+/// ```\n+/// let foo = {\n+///         aaaa;\n+///         bbb;\n+///         ccc\n+///     }\n+///     .bar\n+///     .baz();\n+/// ```\n+///\n+/// `chain_indent` dictates how the rest of the chain is aligned. This only seems\n+/// to have an effect if the first non-root part of the chain is put on a\n+/// newline, otherwise we align the dots:\n+/// ```\n+/// foo.bar\n+///    .baz()\n+/// ```\n+/// If the first item in the chain is a block expression, we align the dots with\n+/// the braces.\n+///\n+/// Otherwise:\n+/// Visual:\n+/// ```\n+/// let a = foo(aaa, bbb)\n+///             .bar\n+///             .baz()\n+/// ```\n+/// Visual seems to be a tab indented from the indent of the whole expression.\n+/// Inherit:\n+/// ```\n+/// let a = foo(aaa, bbb)\n+/// .bar\n+/// .baz()\n+/// ```\n+/// Tabbed:\n+/// ```\n+/// let a = foo(aaa, bbb)\n+///     .bar\n+///     .baz()\n+/// ```\n+/// `chains_overflow_last` applies only to chains where the last item is a\n+/// method call. Usually, any line break in a chain sub-expression causes the\n+/// whole chain to be split with newlines at each `.`. With `chains_overflow_last`\n+/// true, then we allow the last method call to spill over multiple lines without\n+/// forcing the rest of the chain to be split.\n+\n \n use Indent;\n use rewrite::{Rewrite, RewriteContext};\n@@ -28,49 +100,43 @@ use config::BlockIndentStyle;\n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n \n-pub fn rewrite_chain(mut expr: &ast::Expr,\n+\n+pub fn rewrite_chain(expr: &ast::Expr,\n                      context: &RewriteContext,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n     let total_span = expr.span;\n-    let mut subexpr_list = vec![expr];\n+    let (parent, subexpr_list) = make_subexpr_list(expr);\n \n-    while let Some(subexpr) = pop_expr_chain(expr) {\n-        subexpr_list.push(subexpr);\n-        expr = subexpr;\n-    }\n-\n-    let parent_block_indent = match context.config.chain_base_indent {\n-        BlockIndentStyle::Visual => offset,\n-        BlockIndentStyle::Inherit => context.block_indent,\n-        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n-    };\n+    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n+    let parent_block_indent = chain_base_indent(context, offset);\n     let parent_context = &RewriteContext { block_indent: parent_block_indent, ..*context };\n-    let parent = subexpr_list.pop().unwrap();\n-    let parent_rewrite = try_opt!(expr.rewrite(parent_context, width, offset));\n+    let parent_rewrite = try_opt!(parent.rewrite(parent_context, width, offset));\n+\n+    // Decide how to layout the rest of the chain. `extend` is true if we can\n+    // put the first non-parent item on the same line as the parent.\n     let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n                               parent_rewrite.len() <= context.config.tab_spaces {\n+        // Try and put the whole chain on one line.\n         (offset + Indent::new(0, parent_rewrite.len()), true)\n     } else if is_block_expr(parent, &parent_rewrite) {\n+        // The parent is a block, so align the rest of the chain with the closing\n+        // brace.\n         (parent_block_indent, false)\n     } else {\n-        match context.config.chain_indent {\n-            BlockIndentStyle::Inherit => (context.block_indent, false),\n-            BlockIndentStyle::Tabbed => (context.block_indent.block_indent(context.config), false),\n-            BlockIndentStyle::Visual => (offset + Indent::new(context.config.tab_spaces, 0), false),\n-        }\n+        (chain_indent(context, offset), false)\n     };\n \n     let max_width = try_opt!((width + offset.width()).checked_sub(indent.width()));\n     let mut rewrites = try_opt!(subexpr_list.iter()\n                                             .rev()\n                                             .map(|e| {\n-                                                rewrite_chain_expr(e,\n-                                                                   total_span,\n-                                                                   context,\n-                                                                   max_width,\n-                                                                   indent)\n+                                                rewrite_chain_subexpr(e,\n+                                                                      total_span,\n+                                                                      context,\n+                                                                      max_width,\n+                                                                      indent)\n                                             })\n                                             .collect::<Option<Vec<_>>>());\n \n@@ -80,6 +146,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n                            .fold(0, |a, b| a + first_line_width(b)) +\n                        parent_rewrite.len();\n     let total_width = almost_total + first_line_width(rewrites.last().unwrap());\n+\n     let veto_single_line = if context.config.take_source_hints && subexpr_list.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n         // line, we won't consider putting them on a single line either.\n@@ -92,49 +159,40 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n         false\n     };\n \n-    let fits_single_line = !veto_single_line &&\n-                           match subexpr_list[0].node {\n-        ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions)\n-            if context.config.chains_overflow_last => {\n-            let len = rewrites.len();\n-            let (init, last) = rewrites.split_at_mut(len - 1);\n-            let last = &mut last[0];\n-\n-            if init.iter().all(|s| !s.contains('\\n')) && total_width <= width {\n-                let last_rewrite = width.checked_sub(almost_total)\n-                                        .and_then(|inner_width| {\n-                                            rewrite_method_call(method_name.node,\n-                                                                types,\n-                                                                expressions,\n-                                                                total_span,\n-                                                                context,\n-                                                                inner_width,\n-                                                                offset + almost_total)\n-                                        });\n-                match last_rewrite {\n-                    Some(mut string) => {\n-                        ::std::mem::swap(&mut string, last);\n-                        true\n-                    }\n-                    None => false,\n+    let mut fits_single_line = !veto_single_line && total_width <= width;\n+    if fits_single_line {\n+        let len = rewrites.len();\n+        let (init, last) = rewrites.split_at_mut(len - 1);\n+        fits_single_line = init.iter().all(|s| !s.contains('\\n'));\n+\n+        if fits_single_line {\n+            fits_single_line = match expr.node {\n+                ref e @ ast::ExprKind::MethodCall(..) if context.config.chains_overflow_last => {\n+                    rewrite_method_call_with_overflow(e,\n+                                                      &mut last[0],\n+                                                      almost_total,\n+                                                      width,\n+                                                      total_span,\n+                                                      context,\n+                                                      offset)\n                 }\n-            } else {\n-                false\n+                _ => !last[0].contains('\\n'),\n             }\n         }\n-        _ => total_width <= width && rewrites.iter().all(|s| !s.contains('\\n')),\n-    };\n+    }\n \n     let connector = if fits_single_line && !parent_rewrite.contains('\\n') {\n+        // Yay, we can put everything on one line.\n         String::new()\n     } else {\n+        // Use new lines.\n         format!(\"\\n{}\", indent.to_string(context.config))\n     };\n \n     let first_connector = if extend {\n         \"\"\n     } else {\n-        &connector[..]\n+        &connector\n     };\n \n     wrap_str(format!(\"{}{}{}\",\n@@ -146,8 +204,40 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n              offset)\n }\n \n+fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n+                                     last: &mut String,\n+                                     almost_total: usize,\n+                                     width: usize,\n+                                     total_span: Span,\n+                                     context: &RewriteContext,\n+                                     offset: Indent)\n+                                     -> bool {\n+    if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n+        let budget = match width.checked_sub(almost_total) {\n+            Some(b) => b,\n+            None => return false,\n+        };\n+        let mut last_rewrite = rewrite_method_call(method_name.node,\n+                                                   types,\n+                                                   expressions,\n+                                                   total_span,\n+                                                   context,\n+                                                   budget,\n+                                                   offset + almost_total);\n+\n+        if let Some(ref mut s) = last_rewrite {\n+            ::std::mem::swap(s, last);\n+            true\n+        } else {\n+            false\n+        }\n+    } else {\n+        unreachable!();\n+    }\n+}\n+\n // States whether an expression's last line exclusively consists of closing\n-// parens, braces and brackets in its idiomatic formatting.\n+// parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n         ast::ExprKind::Struct(..) |\n@@ -167,21 +257,53 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n     }\n }\n \n-fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n-    match expr.node {\n-        ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n-        ast::ExprKind::TupField(ref subexpr, _) |\n-        ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n-        _ => None,\n+// Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n+// E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n+fn make_subexpr_list(mut expr: &ast::Expr) -> (&ast::Expr, Vec<&ast::Expr>) {\n+    fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n+        match expr.node {\n+            ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n+            ast::ExprKind::TupField(ref subexpr, _) |\n+            ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n+            _ => None,\n+        }\n+    }\n+\n+    let mut subexpr_list = vec![expr];\n+\n+    while let Some(subexpr) = pop_expr_chain(expr) {\n+        subexpr_list.push(subexpr);\n+        expr = subexpr;\n+    }\n+\n+    let parent = subexpr_list.pop().unwrap();\n+    (parent, subexpr_list)\n+}\n+\n+fn chain_base_indent(context: &RewriteContext, offset: Indent) -> Indent {\n+    match context.config.chain_base_indent {\n+        BlockIndentStyle::Visual => offset,\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+    }\n+}\n+\n+fn chain_indent(context: &RewriteContext, offset: Indent) -> Indent {\n+    match context.config.chain_indent {\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+        BlockIndentStyle::Visual => offset + Indent::new(context.config.tab_spaces, 0),\n     }\n }\n \n-fn rewrite_chain_expr(expr: &ast::Expr,\n-                      span: Span,\n-                      context: &RewriteContext,\n-                      width: usize,\n-                      offset: Indent)\n-                      -> Option<String> {\n+// Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n+// `.c`.\n+fn rewrite_chain_subexpr(expr: &ast::Expr,\n+                         span: Span,\n+                         context: &RewriteContext,\n+                         width: usize,\n+                         offset: Indent)\n+                         -> Option<String> {\n     match expr.node {\n         ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) => {\n             let inner = &RewriteContext { block_indent: offset, ..*context };\n@@ -213,7 +335,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n     }\n }\n \n-// Determines we can continue formatting a given expression on the same line.\n+// Determines if we can continue formatting a given expression on the same line.\n fn is_continuable(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Path(..) => true,"}, {"sha": "71edfe955bd693fae9597b5c1b051582ee496671", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d46532e72a693b0ca9100b7ba9f721e4daaff31/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d46532e72a693b0ca9100b7ba9f721e4daaff31/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=3d46532e72a693b0ca9100b7ba9f721e4daaff31", "patch": "@@ -377,11 +377,11 @@ create_config! {\n         \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n     chain_base_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on chain base\";\n     chain_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indentation of chain\";\n+    chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n     single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";\n     format_strings: bool, true, \"Format string literals where necessary\";\n     force_format_strings: bool, false, \"Always format string literals\";\n-    chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     take_source_hints: bool, true, \"Retain some formatting characteristics from the source code\";\n     hard_tabs: bool, false, \"Use tab characters for indentation, spaces for alignment\";\n     wrap_comments: bool, false, \"Break comments to fit on the line\";\n@@ -390,7 +390,7 @@ create_config! {\n     match_block_trailing_comma: bool, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n     match_wildcard_trailing_comma: bool, true, \"Put a trailing comma after a wildcard arm\";\n-    closure_block_indent_threshold: isize, 4, \"How many lines a closure must have before it is \\\n+    closure_block_indent_threshold: isize, -1, \"How many lines a closure must have before it is \\\n                                                 block indented. -1 means never use block indent.\";\n     write_mode: WriteMode, WriteMode::Replace,\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";"}]}