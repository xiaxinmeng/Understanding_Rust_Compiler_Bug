{"sha": "19faaf1a9eff62606e777207205c6fea49aa1751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZmFhZjFhOWVmZjYyNjA2ZTc3NzIwNzIwNWM2ZmVhNDlhYTE3NTE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-09T11:58:45Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-27T17:06:50Z"}, "message": "Remove cat_discr\n\nit seems to be some kind of GC-related mess", "tree": {"sha": "520b43673f11c93002ab719880f4930648357cdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/520b43673f11c93002ab719880f4930648357cdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19faaf1a9eff62606e777207205c6fea49aa1751", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19faaf1a9eff62606e777207205c6fea49aa1751", "html_url": "https://github.com/rust-lang/rust/commit/19faaf1a9eff62606e777207205c6fea49aa1751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19faaf1a9eff62606e777207205c6fea49aa1751/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c121cbab35c9ff9ba133c578976a4ec35c011bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c121cbab35c9ff9ba133c578976a4ec35c011bcf", "html_url": "https://github.com/rust-lang/rust/commit/c121cbab35c9ff9ba133c578976a4ec35c011bcf"}], "stats": {"total": 168, "additions": 35, "deletions": 133}, "files": [{"sha": "f5e849f41967da8d5b28a4b37834a44901a9d8fd", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -831,7 +831,6 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         return;\n                     }\n \n-                    mc::cat_discr(b, _) |\n                     mc::cat_deref(b, _, mc::OwnedPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;"}, {"sha": "a1c02b85e8f51cd085764f98fbac2e09597a192f", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -159,8 +159,7 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n             }\n         }\n \n-        mc::cat_deref(ref b, _, mc::OwnedPtr) |\n-        mc::cat_discr(ref b, _) => {\n+        mc::cat_deref(ref b, _, mc::OwnedPtr) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }\n     }"}, {"sha": "41fe77d5197fd5b6325b2ab102eb364c78c59abb", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -84,62 +84,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_interior(ref base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n-\n-            mc::cat_discr(ref base, new_discr_scope) => {\n-                // Subtle: in a match, we must ensure that each binding\n-                // variable remains valid for the duration of the arm in\n-                // which it appears, presuming that this arm is taken.\n-                // But it is inconvenient in trans to root something just\n-                // for one arm.  Therefore, we insert a cat_discr(),\n-                // basically a special kind of category that says \"if this\n-                // value must be dynamically rooted, root it for the scope\n-                // `match_id`\".\n-                //\n-                // As an example, consider this scenario:\n-                //\n-                //    let mut x = @Some(3);\n-                //    match *x { Some(y) {...} None {...} }\n-                //\n-                // Technically, the value `x` need only be rooted\n-                // in the `some` arm.  However, we evaluate `x` in trans\n-                // before we know what arm will be taken, so we just\n-                // always root it for the duration of the match.\n-                //\n-                // As a second example, consider *this* scenario:\n-                //\n-                //    let x = @@Some(3);\n-                //    match x { @@Some(y) {...} @@None {...} }\n-                //\n-                // Here again, `x` need only be rooted in the `some` arm.\n-                // In this case, the value which needs to be rooted is\n-                // found only when checking which pattern matches: but\n-                // this check is done before entering the arm.  Therefore,\n-                // even in this case we just choose to keep the value\n-                // rooted for the entire match.  This means the value will be\n-                // rooted even if the none arm is taken.  Oh well.\n-                //\n-                // At first, I tried to optimize the second case to only\n-                // root in one arm, but the result was suboptimal: first,\n-                // it interfered with the construction of phi nodes in the\n-                // arm, as we were adding code to root values before the\n-                // phi nodes were added.  This could have been addressed\n-                // with a second basic block.  However, the naive approach\n-                // also yielded suboptimal results for patterns like:\n-                //\n-                //    let x = @@...;\n-                //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n-                //\n-                // The reason is that we would root the value once for\n-                // each pattern and not once per arm.  This is also easily\n-                // fixed, but it's yet more code for what is really quite\n-                // the corner case.\n-                //\n-                // Nonetheless, if you decide to optimize this case in the\n-                // future, you need only adjust where the cat_discr()\n-                // node appears to draw the line between what will be rooted\n-                // in the *arm* vs the *match*.\n-                self.check(base, Some(new_discr_scope))\n-            }\n         }\n     }\n \n@@ -182,8 +126,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n             mc::cat_downcast(ref cmt) |\n             mc::cat_deref(ref cmt, _, mc::OwnedPtr) |\n-            mc::cat_interior(ref cmt, _) |\n-            mc::cat_discr(ref cmt, _) => {\n+            mc::cat_interior(ref cmt, _) => {\n                 self.scope(cmt)\n             }\n         }"}, {"sha": "1a12828922cbf58088e16d8b910773fc629ec044", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -213,9 +213,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         /*!\n          * Guarantees that `addr_of(cmt)` will be valid for the duration of\n          * `static_scope_r`, or reports an error.  This may entail taking\n-         * out loans, which will be added to the `req_loan_map`.  This can\n-         * also entail \"rooting\" GC'd pointers, which means ensuring\n-         * dynamically that they are not freed.\n+         * out loans, which will be added to the `req_loan_map`.\n          */\n \n         debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\"}, {"sha": "6a6fc1760f2bb3b25fa22069c95be5cf558f4788", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 28, "deletions": 49, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -96,46 +96,27 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 self.extend(result, cmt.mutbl, LpInterior(i))\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::OwnedPtr) => {\n-                // R-Deref-Send-Pointer\n-                //\n-                // When we borrow the interior of an owned pointer, we\n-                // cannot permit the base to be mutated, because that\n-                // would cause the unique pointer to be freed.\n-                //\n-                // Eventually we should make these non-special and\n-                // just rely on Deref<T> implementation.\n-                let result = self.restrict(cmt_base);\n-                self.extend(result, cmt.mutbl, LpDeref(pk))\n-            }\n \n             mc::cat_static_item(..) => {\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::BorrowedPtr(ty::ImmBorrow, lt)) |\n-            mc::cat_deref(cmt_base, _, mc::Implicit(ty::ImmBorrow, lt)) => {\n-                // R-Deref-Imm-Borrowed\n-                if !self.bccx.is_subregion_of(self.loan_region, lt) {\n-                    self.bccx.report(\n-                        BckError {\n-                            span: self.span,\n-                            cause: self.cause,\n-                            cmt: cmt_base,\n-                            code: err_borrowed_pointer_too_short(\n-                                self.loan_region, lt)});\n-                    return Safe;\n-                }\n-                Safe\n-            }\n-\n             mc::cat_deref(cmt_base, _, pk) => {\n                 match pk {\n-                    mc::BorrowedPtr(ty::MutBorrow, lt) |\n-                    mc::BorrowedPtr(ty::UniqueImmBorrow, lt) |\n-                    mc::Implicit(ty::MutBorrow, lt) |\n-                    mc::Implicit(ty::UniqueImmBorrow, lt) => {\n-                        // R-Deref-Mut-Borrowed\n+                    mc::OwnedPtr => {\n+                        // R-Deref-Send-Pointer\n+                        //\n+                        // When we borrow the interior of an owned pointer, we\n+                        // cannot permit the base to be mutated, because that\n+                        // would cause the unique pointer to be freed.\n+                        //\n+                        // Eventually we should make these non-special and\n+                        // just rely on Deref<T> implementation.\n+                        let result = self.restrict(cmt_base);\n+                        self.extend(result, cmt.mutbl, LpDeref(pk))\n+                    }\n+                    mc::Implicit(bk, lt) | mc::BorrowedPtr(bk, lt) => {\n+                        // R-Deref-[Mut-]Borrowed\n                         if !self.bccx.is_subregion_of(self.loan_region, lt) {\n                             self.bccx.report(\n                                 BckError {\n@@ -147,25 +128,23 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                             return Safe;\n                         }\n \n-                        let result = self.restrict(cmt_base);\n-                        self.extend(result, cmt.mutbl, LpDeref(pk))\n-                    }\n-                    mc::UnsafePtr(..) => {\n-                        // We are very trusting when working with unsafe\n-                        // pointers.\n-                        Safe\n-                    }\n-                    _ => {\n-                        self.bccx.tcx.sess.span_bug(self.span,\n-                                                    \"unhandled memcat in \\\n-                                                     cat_deref\")\n+                        match bk {\n+                            ty::ImmBorrow => Safe,\n+                            ty::MutBorrow | ty::UniqueImmBorrow => {\n+                                // R-Deref-Mut-Borrowed\n+                                //\n+                                // The referent can be aliased after the\n+                                // references lifetime ends (by a newly-unfrozen\n+                                // borrow).\n+                                let result = self.restrict(cmt_base);\n+                                self.extend(result, cmt.mutbl, LpDeref(pk))\n+                            }\n+                        }\n                     }\n+                    // Borrowck is not relevant for unsafe pointers\n+                    mc::UnsafePtr(..) => Safe\n                 }\n             }\n-\n-            mc::cat_discr(cmt_base, _) => {\n-                self.restrict(cmt_base)\n-            }\n         }\n     }\n "}, {"sha": "8a4625861b3a631a82aad7d58608525ffc50271a", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -379,8 +379,7 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n             })\n         }\n \n-        mc::cat_downcast(ref cmt_base) |\n-        mc::cat_discr(ref cmt_base, _) => {\n+        mc::cat_downcast(ref cmt_base) => {\n             opt_loan_path(cmt_base)\n         }\n     }"}, {"sha": "dd862d53c475b6c7fab88b89d09b58047532477d", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -269,7 +269,6 @@ impl euv::Delegate for GlobalChecker {\n                     break\n                 }\n                 mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_discr(ref cmt, _) |\n                 mc::cat_downcast(ref cmt) |\n                 mc::cat_interior(ref cmt, _) => cur = cmt,\n \n@@ -307,7 +306,6 @@ impl euv::Delegate for GlobalChecker {\n                 }\n \n                 mc::cat_downcast(..) |\n-                mc::cat_discr(..) |\n                 mc::cat_upvar(..) => unreachable!(),\n \n                 mc::cat_local(..) => {\n@@ -331,4 +329,3 @@ impl euv::Delegate for GlobalChecker {\n                    _cmt: mc::cmt,\n                    _mode: euv::ConsumeMode) {}\n }\n-"}, {"sha": "57efb90ac8b1927dcdcd6bf65cba4feb76a95467", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -87,7 +87,6 @@ pub enum categorization {\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n     cat_downcast(cmt),                 // selects a particular enum variant (*1)\n-    cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -1339,9 +1338,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           cat_upvar(ref var) => {\n               upvar_to_string(var, true)\n           }\n-          cat_discr(ref cmt, _) => {\n-            self.cmt_to_string(&**cmt)\n-          }\n           cat_downcast(ref cmt) => {\n             self.cmt_to_string(&**cmt)\n           }\n@@ -1379,7 +1375,6 @@ impl cmt_ {\n                 Rc::new((*self).clone())\n             }\n             cat_downcast(ref b) |\n-            cat_discr(ref b, _) |\n             cat_interior(ref b, _) |\n             cat_deref(ref b, _, OwnedPtr) => {\n                 b.guarantor()\n@@ -1404,8 +1399,7 @@ impl cmt_ {\n             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n             cat_downcast(ref b) |\n             cat_deref(ref b, _, OwnedPtr) |\n-            cat_interior(ref b, _) |\n-            cat_discr(ref b, _) => {\n+            cat_interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n@@ -1490,9 +1484,6 @@ impl Repr for categorization {\n             cat_downcast(ref cmt) => {\n                 format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n-            cat_discr(ref cmt, _) => {\n-                cmt.cat.repr(tcx)\n-            }\n         }\n     }\n }"}, {"sha": "08f83ad7e38ecdd1095fdfe7e9acf00d70a74068", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19faaf1a9eff62606e777207205c6fea49aa1751/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=19faaf1a9eff62606e777207205c6fea49aa1751", "patch": "@@ -1494,7 +1494,6 @@ fn link_region(rcx: &Rcx,\n                 }\n             }\n \n-            mc::cat_discr(cmt_base, _) |\n             mc::cat_downcast(cmt_base) |\n             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n             mc::cat_interior(cmt_base, _) => {\n@@ -1736,8 +1735,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n-            mc::cat_downcast(base) |\n-            mc::cat_discr(base, _) => {\n+            mc::cat_downcast(base) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n                 cmt = base;\n@@ -1788,8 +1786,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n-            mc::cat_downcast(base) |\n-            mc::cat_discr(base, _) => {\n+            mc::cat_downcast(base) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n                 cmt = base;"}]}