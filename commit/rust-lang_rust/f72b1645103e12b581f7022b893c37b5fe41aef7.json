{"sha": "f72b1645103e12b581f7022b893c37b5fe41aef7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MmIxNjQ1MTAzZTEyYjU4MWY3MDIyYjg5M2MzN2I1ZmU0MWFlZjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-23T00:27:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-27T00:01:16Z"}, "message": "std: Rename io to old_io\n\nIn preparation for the I/O rejuvination of the standard library, this commit\nrenames the current `io` module to `old_io` in order to make room for the new\nI/O modules. It is expected that the I/O RFCs will land incrementally over time\ninstead of all at once, and this provides a fresh clean path for new modules to\nenter into as well as guaranteeing that all old infrastructure will remain in\nplace for some time.\n\nAs each `old_io` module is replaced it will be deprecated in-place for new\nstructures in `std::{io, fs, net}` (as appropriate).\n\nThis commit does *not* leave a reexport of `old_io as io` as the deprecation\nlint does not currently warn on this form of use. This is quite a large breaking\nchange for all imports in existing code, but all functionality is retained\nprecisely as-is and path statements simply need to be renamed from `io` to\n`old_io`.\n\n[breaking-change]", "tree": {"sha": "91f98ee9b6a33110445bcf73d172e16c99042863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91f98ee9b6a33110445bcf73d172e16c99042863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f72b1645103e12b581f7022b893c37b5fe41aef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f72b1645103e12b581f7022b893c37b5fe41aef7", "html_url": "https://github.com/rust-lang/rust/commit/f72b1645103e12b581f7022b893c37b5fe41aef7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f72b1645103e12b581f7022b893c37b5fe41aef7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec3a833d5082a77e74a30c2d3d353ba7f5df644", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec3a833d5082a77e74a30c2d3d353ba7f5df644", "html_url": "https://github.com/rust-lang/rust/commit/8ec3a833d5082a77e74a30c2d3d353ba7f5df644"}], "stats": {"total": 602, "additions": 311, "deletions": 291}, "files": [{"sha": "119e7c501969dc4b806c2f560f9d740a4e154def", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -79,7 +79,8 @@\n //! memory types, including [`atomic`](sync/atomic/index.html).\n //!\n //! Common types of I/O, including files, TCP, UDP, pipes, Unix domain sockets,\n-//! timers, and process spawning, are defined in the [`io`](io/index.html) module.\n+//! timers, and process spawning, are defined in the\n+//! [`old_io`](old_io/index.html) module.\n //!\n //! Rust's I/O and concurrency depends on a small runtime interface\n //! that lives, along with its support code, in mod [`rt`](rt/index.html).\n@@ -239,7 +240,7 @@ pub mod thread_local;\n pub mod dynamic_lib;\n pub mod ffi;\n pub mod fmt;\n-pub mod io;\n+pub mod old_io;\n pub mod os;\n pub mod path;\n pub mod rand;\n@@ -284,7 +285,7 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    pub use io; // used for println!()\n+    pub use old_io; // used for println!()\n     pub use option; // used for bitflags!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]"}, {"sha": "c04af865af886559c85b86617a7d151677ec780f", "filename": "src/libstd/old_io/buffered.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -14,7 +14,7 @@\n \n use cmp;\n use fmt;\n-use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n+use old_io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::{IteratorExt, ExactSizeIterator, repeat};\n use ops::Drop;\n use option::Option;\n@@ -34,7 +34,7 @@ use vec::Vec;\n /// # Example\n ///\n /// ```rust\n-/// use std::io::{BufferedReader, File};\n+/// use std::old_io::{BufferedReader, File};\n ///\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut reader = BufferedReader::new(file);\n@@ -137,7 +137,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io::{BufferedWriter, File};\n+/// use std::old_io::{BufferedWriter, File};\n ///\n /// let file = File::create(&Path::new(\"message.txt\")).unwrap();\n /// let mut writer = BufferedWriter::new(file);\n@@ -324,7 +324,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::{BufferedStream, File};\n+/// use std::old_io::{BufferedStream, File};\n ///\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut stream = BufferedStream::new(file);\n@@ -437,13 +437,13 @@ mod test {\n     pub struct NullStream;\n \n     impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            Err(io::standard_error(io::EndOfFile))\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n     impl Writer for NullStream {\n-        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n+        fn write(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n     }\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -452,9 +452,9 @@ mod test {\n     }\n \n     impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.lengths.is_empty() {\n-                Err(io::standard_error(io::EndOfFile))\n+                Err(old_io::standard_error(old_io::EndOfFile))\n             } else {\n                 Ok(self.lengths.remove(0))\n             }\n@@ -555,13 +555,13 @@ mod test {\n     fn test_buffered_stream() {\n         struct S;\n \n-        impl io::Writer for S {\n-            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n+        impl old_io::Writer for S {\n+            fn write(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n         }\n \n-        impl io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-                Err(io::standard_error(io::EndOfFile))\n+        impl old_io::Reader for S {\n+            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+                Err(old_io::standard_error(old_io::EndOfFile))\n             }\n         }\n \n@@ -664,7 +664,7 @@ mod test {\n \n         impl Writer for FailFlushWriter {\n             fn write(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n-            fn flush(&mut self) -> IoResult<()> { Err(io::standard_error(EndOfFile)) }\n+            fn flush(&mut self) -> IoResult<()> { Err(old_io::standard_error(EndOfFile)) }\n         }\n \n         let writer = FailFlushWriter;", "previous_filename": "src/libstd/io/buffered.rs"}, {"sha": "3c684e4cc6a983a85c095ddaaaa36dbf60839679", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -11,7 +11,7 @@\n use clone::Clone;\n use cmp;\n use sync::mpsc::{Sender, Receiver};\n-use io;\n+use old_io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n use slice::{bytes, SliceExt};\n@@ -24,7 +24,7 @@ use vec::Vec;\n ///\n /// ```\n /// use std::sync::mpsc::channel;\n-/// use std::io::ChanReader;\n+/// use std::old_io::ChanReader;\n ///\n /// let (tx, rx) = channel();\n /// # drop(tx);\n@@ -70,7 +70,7 @@ impl Buffer for ChanReader {\n             }\n         }\n         if self.closed {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(&self.buf[self.pos..])\n         }\n@@ -102,7 +102,7 @@ impl Reader for ChanReader {\n             }\n         }\n         if self.closed && num_read == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(num_read)\n         }\n@@ -116,7 +116,7 @@ impl Reader for ChanReader {\n /// ```\n /// # #![allow(unused_must_use)]\n /// use std::sync::mpsc::channel;\n-/// use std::io::ChanWriter;\n+/// use std::old_io::ChanWriter;\n ///\n /// let (tx, rx) = channel();\n /// # drop(rx);\n@@ -144,8 +144,8 @@ impl Clone for ChanWriter {\n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.tx.send(buf.to_vec()).map_err(|_| {\n-            io::IoError {\n-                kind: io::BrokenPipe,\n+            old_io::IoError {\n+                kind: old_io::BrokenPipe,\n                 desc: \"Pipe closed\",\n                 detail: None\n             }\n@@ -193,14 +193,14 @@ mod test {\n \n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n         assert_eq!(a, buf);\n \n         // Ensure it continues to panic in the same way.\n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n         assert_eq!(a, buf);\n     }\n@@ -223,7 +223,7 @@ mod test {\n         assert_eq!(Ok(\"how are you?\".to_string()), reader.read_line());\n         match reader.read_line() {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n     }\n \n@@ -242,7 +242,7 @@ mod test {\n \n         match writer.write_u8(1) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::BrokenPipe),\n+            Err(e) => assert_eq!(e.kind, old_io::BrokenPipe),\n         }\n     }\n }", "previous_filename": "src/libstd/io/comm_adapters.rs"}, {"sha": "259242d0cd85fb8d39e5549889cbfbff62b076eb", "filename": "src/libstd/old_io/extensions.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -15,8 +15,8 @@\n // FIXME: Not sure how this should be structured\n // FIXME: Iteration should probably be considered separately\n \n-use io::{IoError, IoResult, Reader};\n-use io;\n+use old_io::{IoError, IoResult, Reader};\n+use old_io;\n use iter::Iterator;\n use num::Int;\n use ops::FnOnce;\n@@ -59,7 +59,7 @@ impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n     fn next(&mut self) -> Option<IoResult<u8>> {\n         match self.reader.read_byte() {\n             Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: io::EndOfFile, .. }) => None,\n+            Err(IoError { kind: old_io::EndOfFile, .. }) => None,\n             Err(e) => Some(Err(e))\n         }\n     }\n@@ -179,14 +179,14 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n mod test {\n     use prelude::v1::*;\n     use io;\n-    use io::{MemReader, BytesReader};\n+    use old_io::{MemReader, BytesReader};\n \n     struct InitialZeroByteReader {\n         count: int,\n     }\n \n     impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 Ok(0)\n@@ -200,16 +200,16 @@ mod test {\n     struct EofReader;\n \n     impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            Err(io::standard_error(io::EndOfFile))\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n     struct ErroringReader;\n \n     impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            Err(io::standard_error(io::InvalidInput))\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            Err(old_io::standard_error(old_io::InvalidInput))\n         }\n     }\n \n@@ -218,7 +218,7 @@ mod test {\n     }\n \n     impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -237,13 +237,13 @@ mod test {\n     }\n \n     impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n                 Ok(1)\n             } else {\n-                Err(io::standard_error(io::InvalidInput))\n+                Err(old_io::standard_error(old_io::InvalidInput))\n             }\n         }\n     }\n@@ -253,7 +253,7 @@ mod test {\n     }\n \n     impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -265,7 +265,7 @@ mod test {\n                 buf[1] = 13;\n                 Ok(2)\n             } else {\n-                Err(io::standard_error(io::EndOfFile))\n+                Err(old_io::standard_error(old_io::EndOfFile))\n             }\n         }\n     }", "previous_filename": "src/libstd/io/extensions.rs"}, {"sha": "ee6dbafe688537d08d6f5443195e175e75df405e", "filename": "src/libstd/old_io/fs.rs", "status": "renamed", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -18,21 +18,21 @@\n //! At the top-level of the module are a set of freestanding functions, associated\n //! with various filesystem operations. They all operate on `Path` objects.\n //!\n-//! All operations in this module, including those as part of `File` et al\n-//! block the task during execution. In the event of failure, all functions/methods\n+//! All operations in this module, including those as part of `File` et al block\n+//! the task during execution. In the event of failure, all functions/methods\n //! will return an `IoResult` type with an `Err` value.\n //!\n //! Also included in this module is an implementation block on the `Path` object\n-//! defined in `std::path::Path`. The impl adds useful methods about inspecting the\n-//! metadata of a file. This includes getting the `stat` information, reading off\n-//! particular bits of it, etc.\n+//! defined in `std::path::Path`. The impl adds useful methods about inspecting\n+//! the metadata of a file. This includes getting the `stat` information,\n+//! reading off particular bits of it, etc.\n //!\n //! # Example\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n-//! use std::io::fs::PathExtensions;\n-//! use std::io::{File, fs};\n+//! use std::old_io::fs::PathExtensions;\n+//! use std::old_io::{File, fs};\n //!\n //! let path = Path::new(\"foo.txt\");\n //!\n@@ -51,13 +51,13 @@\n //! ```\n \n use clone::Clone;\n-use io::standard_error;\n-use io::{FilePermission, Write, Open, FileAccess, FileMode, FileType};\n-use io::{IoResult, IoError, InvalidInput};\n-use io::{FileStat, SeekStyle, Seek, Writer, Reader};\n-use io::{Read, Truncate, ReadWrite, Append};\n-use io::UpdateIoError;\n-use io;\n+use old_io::standard_error;\n+use old_io::{FilePermission, Write, Open, FileAccess, FileMode, FileType};\n+use old_io::{IoResult, IoError, InvalidInput};\n+use old_io::{FileStat, SeekStyle, Seek, Writer, Reader};\n+use old_io::{Read, Truncate, ReadWrite, Append};\n+use old_io::UpdateIoError;\n+use old_io;\n use iter::{Iterator, Extend};\n use option::Option;\n use option::Option::{Some, None};\n@@ -101,7 +101,7 @@ impl File {\n     /// # Example\n     ///\n     /// ```rust,should_fail\n-    /// use std::io::{File, Open, ReadWrite};\n+    /// use std::old_io::{File, Open, ReadWrite};\n     ///\n     /// let p = Path::new(\"/some/file/path.txt\");\n     ///\n@@ -170,7 +170,7 @@ impl File {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::File;\n+    /// use std::old_io::File;\n     ///\n     /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n     /// ```\n@@ -188,12 +188,12 @@ impl File {\n     ///\n     /// ```rust\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::File;\n+    /// use std::old_io::File;\n     ///\n     /// let mut f = File::create(&Path::new(\"foo.txt\"));\n     /// f.write(b\"This is a sample file\");\n     /// # drop(f);\n-    /// # ::std::io::fs::unlink(&Path::new(\"foo.txt\"));\n+    /// # ::std::old_io::fs::unlink(&Path::new(\"foo.txt\"));\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n@@ -265,7 +265,7 @@ impl File {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/file/path.txt\");\n /// fs::unlink(&p);\n@@ -293,7 +293,7 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/file/path.txt\");\n /// match fs::stat(&p) {\n@@ -333,7 +333,7 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n /// ```\n@@ -359,7 +359,7 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n /// ```\n@@ -386,7 +386,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n \n     if !from.is_file() {\n         return update_err(Err(IoError {\n-            kind: io::MismatchedFileTypeForOperation,\n+            kind: old_io::MismatchedFileTypeForOperation,\n             desc: \"the source path is not an existing file\",\n             detail: None\n         }), from, to)\n@@ -408,20 +408,20 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// ```rust\n /// # #![allow(unused_must_use)]\n /// use std::io;\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n-/// fs::chmod(&Path::new(\"file.txt\"), io::USER_FILE);\n-/// fs::chmod(&Path::new(\"file.txt\"), io::USER_READ | io::USER_WRITE);\n-/// fs::chmod(&Path::new(\"dir\"),      io::USER_DIR);\n-/// fs::chmod(&Path::new(\"file.exe\"), io::USER_EXEC);\n+/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_FILE);\n+/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_READ | old_io::USER_WRITE);\n+/// fs::chmod(&Path::new(\"dir\"),      old_io::USER_DIR);\n+/// fs::chmod(&Path::new(\"file.exe\"), old_io::USER_EXEC);\n /// ```\n ///\n /// # Error\n ///\n /// This function will return an error if the provided `path` doesn't exist, if\n /// the process lacks permissions to change the attributes of the file, or if\n /// some other I/O error is encountered.\n-pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n+pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n     fs_imp::chmod(path, mode.bits() as uint)\n            .update_err(\"couldn't chmod path\", |e|\n                format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n@@ -470,10 +470,10 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// ```rust\n /// # #![allow(unused_must_use)]\n /// use std::io;\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/dir\");\n-/// fs::mkdir(&p, io::USER_RWX);\n+/// fs::mkdir(&p, old_io::USER_RWX);\n /// ```\n ///\n /// # Error\n@@ -492,7 +492,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/dir\");\n /// fs::rmdir(&p);\n@@ -513,12 +513,12 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io::fs::PathExtensions;\n-/// use std::io::fs;\n+/// use std::old_io::fs::PathExtensions;\n+/// use std::old_io::fs;\n /// use std::io;\n ///\n /// // one possible implementation of fs::walk_dir only visiting files\n-/// fn visit_dirs<F>(dir: &Path, cb: &mut F) -> io::IoResult<()> where\n+/// fn visit_dirs<F>(dir: &Path, cb: &mut F) -> old_io::IoResult<()> where\n ///     F: FnMut(&Path),\n /// {\n ///     if dir.is_dir() {\n@@ -532,7 +532,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n ///         }\n ///         Ok(())\n ///     } else {\n-///         Err(io::standard_error(io::InvalidInput))\n+///         Err(old_io::standard_error(old_io::InvalidInput))\n ///     }\n /// }\n /// ```\n@@ -664,7 +664,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n                 // (eg: deleted by someone else since readdir)\n                 match update_err(unlink(&child), path) {\n                     Ok(()) => (),\n-                    Err(ref e) if e.kind == io::FileNotFound => (),\n+                    Err(ref e) if e.kind == old_io::FileNotFound => (),\n                     Err(e) => return Err(e)\n                 }\n             }\n@@ -675,7 +675,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n             let result = update_err(rmdir(&rm_stack.pop().unwrap()), path);\n             match result {\n                 Ok(()) => (),\n-                Err(ref e) if e.kind == io::FileNotFound => (),\n+                Err(ref e) if e.kind == old_io::FileNotFound => (),\n                 Err(e) => return Err(e)\n             }\n         }\n@@ -709,7 +709,7 @@ impl Reader for File {\n             Ok(read) => {\n                 self.last_nread = read as int;\n                 match read {\n-                    0 => update_err(Err(standard_error(io::EndOfFile)), self),\n+                    0 => update_err(Err(standard_error(old_io::EndOfFile)), self),\n                     _ => Ok(read as uint)\n                 }\n             },\n@@ -824,10 +824,10 @@ fn access_string(access: FileAccess) -> &'static str {\n #[allow(unused_mut)]\n mod test {\n     use prelude::v1::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n+    use old_io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n     use io;\n     use str;\n-    use io::fs::*;\n+    use old_io::fs::*;\n \n     macro_rules! check { ($e:expr) => (\n         match $e {\n@@ -863,15 +863,15 @@ mod test {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n             let TempDir(ref p) = *self;\n-            check!(io::fs::rmdir_recursive(p));\n+            check!(old_io::fs::rmdir_recursive(p));\n         }\n     }\n \n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        check!(io::fs::mkdir(&ret, io::USER_RWX));\n+        check!(old_io::fs::mkdir(&ret, old_io::USER_RWX));\n         TempDir(ret)\n     }\n \n@@ -1055,7 +1055,7 @@ mod test {\n     fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        check!(mkdir(filename, io::USER_RWX));\n+        check!(mkdir(filename, old_io::USER_RWX));\n         let stat_res_fn = check!(stat(filename));\n         assert!(stat_res_fn.kind == FileType::Directory);\n         let stat_res_meth = check!(filename.stat());\n@@ -1067,7 +1067,7 @@ mod test {\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n         assert!(dir.is_file() == false);\n         check!(rmdir(dir));\n     }\n@@ -1087,7 +1087,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n         check!(rmdir(dir));\n@@ -1099,7 +1099,7 @@ mod test {\n         use str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n         let prefix = \"foo\";\n         for n in range(0i,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n@@ -1130,14 +1130,14 @@ mod test {\n     fn file_test_walk_dir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"walk_dir\");\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n \n         let dir1 = &dir.join(\"01/02/03\");\n-        check!(mkdir_recursive(dir1, io::USER_RWX));\n+        check!(mkdir_recursive(dir1, old_io::USER_RWX));\n         check!(File::create(&dir1.join(\"04\")));\n \n         let dir2 = &dir.join(\"11/12/13\");\n-        check!(mkdir_recursive(dir2, io::USER_RWX));\n+        check!(mkdir_recursive(dir2, old_io::USER_RWX));\n         check!(File::create(&dir2.join(\"14\")));\n \n         let mut files = check!(walk_dir(dir));\n@@ -1155,12 +1155,12 @@ mod test {\n \n     #[test]\n     fn mkdir_path_already_exists_error() {\n-        use io::{IoError, PathAlreadyExists};\n+        use old_io::{IoError, PathAlreadyExists};\n \n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"mkdir_error_twice\");\n-        check!(mkdir(dir, io::USER_RWX));\n-        match mkdir(dir, io::USER_RWX) {\n+        check!(mkdir(dir, old_io::USER_RWX));\n+        match mkdir(dir, old_io::USER_RWX) {\n             Err(IoError{kind:PathAlreadyExists,..}) => (),\n             _ => assert!(false)\n         };\n@@ -1170,7 +1170,7 @@ mod test {\n     fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");\n-        check!(mkdir_recursive(&dir, io::USER_RWX));\n+        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n         assert!(dir.is_dir())\n     }\n \n@@ -1180,10 +1180,10 @@ mod test {\n         let dir = tmpdir.join(\"d1\");\n         let file = dir.join(\"f1\");\n \n-        check!(mkdir_recursive(&dir, io::USER_RWX));\n+        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n         check!(File::create(&file));\n \n-        let result = mkdir_recursive(&file, io::USER_RWX);\n+        let result = mkdir_recursive(&file, old_io::USER_RWX);\n \n         error!(result, \"couldn't recursively mkdir\");\n         error!(result, \"couldn't create directory\");\n@@ -1193,7 +1193,7 @@ mod test {\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        check!(mkdir_recursive(&Path::new(\"/\"), io::USER_RWX));\n+        check!(mkdir_recursive(&Path::new(\"/\"), old_io::USER_RWX));\n     }\n \n     // FIXME(#12795) depends on lstat to work on windows\n@@ -1206,8 +1206,8 @@ mod test {\n         let dtt = dt.join(\"t\");\n         let d2 = tmpdir.join(\"d2\");\n         let canary = d2.join(\"do_not_delete\");\n-        check!(mkdir_recursive(&dtt, io::USER_RWX));\n-        check!(mkdir_recursive(&d2, io::USER_RWX));\n+        check!(mkdir_recursive(&dtt, old_io::USER_RWX));\n+        check!(mkdir_recursive(&d2, old_io::USER_RWX));\n         check!(File::create(&canary).write(b\"foo\"));\n         check!(symlink(&d2, &dt.join(\"d2\")));\n         check!(rmdir_recursive(&d1));\n@@ -1225,7 +1225,7 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        check!(mkdir(&dirpath, io::USER_RWX));\n+        check!(mkdir(&dirpath, old_io::USER_RWX));\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n@@ -1243,7 +1243,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        check!(mkdir(&unicode, io::USER_RWX));\n+        check!(mkdir(&unicode, old_io::USER_RWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     }\n@@ -1324,12 +1324,12 @@ mod test {\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(File::create(&input));\n-        check!(chmod(&input, io::USER_READ));\n+        check!(chmod(&input, old_io::USER_READ));\n         check!(copy(&input, &out));\n-        assert!(!check!(out.stat()).perm.intersects(io::USER_WRITE));\n+        assert!(!check!(out.stat()).perm.intersects(old_io::USER_WRITE));\n \n-        check!(chmod(&input, io::USER_FILE));\n-        check!(chmod(&out, io::USER_FILE));\n+        check!(chmod(&input, old_io::USER_FILE));\n+        check!(chmod(&out, old_io::USER_FILE));\n     }\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1405,24 +1405,24 @@ mod test {\n         let file = tmpdir.join(\"in.txt\");\n \n         check!(File::create(&file));\n-        assert!(check!(stat(&file)).perm.contains(io::USER_WRITE));\n-        check!(chmod(&file, io::USER_READ));\n-        assert!(!check!(stat(&file)).perm.contains(io::USER_WRITE));\n+        assert!(check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n+        check!(chmod(&file, old_io::USER_READ));\n+        assert!(!check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n \n-        match chmod(&tmpdir.join(\"foo\"), io::USER_RWX) {\n+        match chmod(&tmpdir.join(\"foo\"), old_io::USER_RWX) {\n             Ok(..) => panic!(\"wanted a panic\"),\n             Err(..) => {}\n         }\n \n-        check!(chmod(&file, io::USER_FILE));\n+        check!(chmod(&file, old_io::USER_FILE));\n     }\n \n     #[test]\n     fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n         check!(file.fsync());\n         check!(file.datasync());\n         check!(file.write(b\"foo\"));\n@@ -1436,7 +1436,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n         check!(file.write(b\"foo\"));\n         check!(file.fsync());\n \n@@ -1467,57 +1467,57 @@ mod test {\n     fn open_flavors() {\n         let tmpdir = tmpdir();\n \n-        match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n+        match File::open_mode(&tmpdir.join(\"a\"), old_io::Open, old_io::Read) {\n             Ok(..) => panic!(), Err(..) => {}\n         }\n \n         // Perform each one twice to make sure that it succeeds the second time\n         // (where the file exists)\n-        check!(File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n         assert!(tmpdir.join(\"b\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n \n-        check!(File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n         assert!(tmpdir.join(\"c\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n \n-        check!(File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n         assert!(tmpdir.join(\"d\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n \n-        check!(File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n         assert!(tmpdir.join(\"e\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n \n-        check!(File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n         assert!(tmpdir.join(\"f\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n \n-        check!(File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n         assert!(tmpdir.join(\"g\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n \n         check!(File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()));\n-        check!(File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read));\n+        check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open, old_io::Read));\n         {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Open,\n-                                               io::Read));\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open,\n+                                               old_io::Read));\n             match f.write(\"wut\".as_bytes()) {\n                 Ok(..) => panic!(), Err(..) => {}\n             }\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n                 \"write/stat failed\");\n         {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Append,\n-                                               io::Write));\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Append,\n+                                               old_io::Write));\n             check!(f.write(\"bar\".as_bytes()));\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 6,\n                 \"append didn't append\");\n         {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n-                                               io::Write));\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Truncate,\n+                                               old_io::Write));\n             check!(f.write(\"bar\".as_bytes()));\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n@@ -1529,8 +1529,9 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n         check!(File::create(&path));\n-        // These numbers have to be bigger than the time in the day to account for timezones\n-        // Windows in particular will fail in certain timezones with small enough values\n+        // These numbers have to be bigger than the time in the day to account\n+        // for timezones Windows in particular will fail in certain timezones\n+        // with small enough values\n         check!(change_file_times(&path, 100000, 200000));\n         assert_eq!(check!(path.stat()).accessed, 100000);\n         assert_eq!(check!(path.stat()).modified, 200000);\n@@ -1565,7 +1566,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"file\");\n         check!(File::create(&path));\n-        check!(chmod(&path, io::USER_READ));\n+        check!(chmod(&path, old_io::USER_READ));\n         check!(unlink(&path));\n     }\n }", "previous_filename": "src/libstd/io/fs.rs"}, {"sha": "3fc2a330fdec49cff12a3d71c15ce20fadb66420", "filename": "src/libstd/old_io/mem.rs", "status": "renamed", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -15,8 +15,8 @@\n use cmp::min;\n use option::Option::None;\n use result::Result::{Err, Ok};\n-use io;\n-use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n+use old_io;\n+use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice::{self, AsSlice, SliceExt};\n use vec::Vec;\n \n@@ -25,14 +25,14 @@ const BUF_CAPACITY: uint = 128;\n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n     let pos = match seek {\n-        io::SeekSet => 0,\n-        io::SeekEnd => end,\n-        io::SeekCur => cur,\n+        old_io::SeekSet => 0,\n+        old_io::SeekEnd => end,\n+        old_io::SeekCur => cur,\n     } as i64;\n \n     if offset + pos < 0 {\n         Err(IoError {\n-            kind: io::InvalidInput,\n+            kind: old_io::InvalidInput,\n             desc: \"invalid seek to a negative offset\",\n             detail: None\n         })\n@@ -55,7 +55,7 @@ impl Writer for Vec<u8> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::MemWriter;\n+/// use std::old_io::MemWriter;\n ///\n /// let mut w = MemWriter::new();\n /// w.write(&[0, 1, 2]);\n@@ -111,7 +111,7 @@ impl Writer for MemWriter {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::MemReader;\n+/// use std::old_io::MemReader;\n ///\n /// let mut r = MemReader::new(vec!(0, 1, 2));\n ///\n@@ -155,7 +155,7 @@ impl MemReader {\n impl Reader for MemReader {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n+        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -189,7 +189,7 @@ impl Buffer for MemReader {\n         if self.pos < self.buf.len() {\n             Ok(&self.buf[self.pos..])\n         } else {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n@@ -200,7 +200,7 @@ impl Buffer for MemReader {\n impl<'a> Reader for &'a [u8] {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.is_empty() { return Err(io::standard_error(io::EndOfFile)); }\n+        if self.is_empty() { return Err(old_io::standard_error(old_io::EndOfFile)); }\n \n         let write_len = min(buf.len(), self.len());\n         {\n@@ -219,7 +219,7 @@ impl<'a> Buffer for &'a [u8] {\n     #[inline]\n     fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.is_empty() {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(*self)\n         }\n@@ -241,7 +241,7 @@ impl<'a> Buffer for &'a [u8] {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::BufWriter;\n+/// use std::old_io::BufWriter;\n ///\n /// let mut buf = [0; 4];\n /// {\n@@ -274,7 +274,7 @@ impl<'a> Writer for BufWriter<'a> {\n         let dst_len = dst.len();\n \n         if dst_len == 0 {\n-            return Err(io::standard_error(io::EndOfFile));\n+            return Err(old_io::standard_error(old_io::EndOfFile));\n         }\n \n         let src_len = src.len();\n@@ -290,7 +290,7 @@ impl<'a> Writer for BufWriter<'a> {\n \n             self.pos += dst_len;\n \n-            Err(io::standard_error(io::ShortWrite(dst_len)))\n+            Err(old_io::standard_error(old_io::ShortWrite(dst_len)))\n         }\n     }\n }\n@@ -313,7 +313,7 @@ impl<'a> Seek for BufWriter<'a> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::BufReader;\n+/// use std::old_io::BufReader;\n ///\n /// let buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(&buf);\n@@ -345,7 +345,7 @@ impl<'a> BufReader<'a> {\n impl<'a> Reader for BufReader<'a> {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n+        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -379,7 +379,7 @@ impl<'a> Buffer for BufReader<'a> {\n         if self.pos < self.buf.len() {\n             Ok(&self.buf[self.pos..])\n         } else {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n@@ -390,7 +390,7 @@ impl<'a> Buffer for BufReader<'a> {\n #[cfg(test)]\n mod test {\n     extern crate \"test\" as test_crate;\n-    use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n+    use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n     use prelude::v1::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt};\n     use prelude::v1::IteratorExt;\n     use io;\n@@ -432,8 +432,8 @@ mod test {\n             writer.write(&[]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n \n-            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, io::ShortWrite(1));\n-            assert_eq!(writer.write(&[10]).err().unwrap().kind, io::EndOfFile);\n+            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, old_io::ShortWrite(1));\n+            assert_eq!(writer.write(&[10]).err().unwrap().kind, old_io::EndOfFile);\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n         assert_eq!(buf, b);\n@@ -476,7 +476,7 @@ mod test {\n \n         match writer.write(&[0, 0]) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::ShortWrite(1)),\n+            Err(e) => assert_eq!(e.kind, old_io::ShortWrite(1)),\n         }\n     }\n ", "previous_filename": "src/libstd/io/mem.rs"}, {"sha": "7a8ed204ca530242df42ef84ef558de9950922d5", "filename": "src/libstd/old_io/mod.rs", "status": "renamed", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -18,6 +18,24 @@\n \n //! I/O, including files, networking, timers, and processes\n //!\n+//! > **Warning**: This module is currently called `old_io` for a reason! The\n+//! > module is currently being redesigned in a number of RFCs. For more details\n+//! > follow the RFC repository in connection with [RFC 517][base] or follow\n+//! > some of these sub-RFCs\n+//! >\n+//! > * [String handling][osstr]\n+//! > * [Core I/O support][core]\n+//! > * [Deadlines][deadlines]\n+//! > * [std::env][env]\n+//! > * [std::process][process]\n+//!\n+//! [base]: https://github.com/rust-lang/rfcs/blob/master/text/0517-io-os-reform.md\n+//! [osstr]: https://github.com/rust-lang/rfcs/pull/575\n+//! [core]: https://github.com/rust-lang/rfcs/pull/576\n+//! [deadlines]: https://github.com/rust-lang/rfcs/pull/577\n+//! [env]: https://github.com/rust-lang/rfcs/pull/578\n+//! [process]: https://github.com/rust-lang/rfcs/pull/579\n+//!\n //! `std::io` provides Rust's basic I/O types,\n //! for reading and writing to files, TCP, UDP,\n //! and other types of sockets and pipes,\n@@ -30,7 +48,7 @@\n //! * Read lines from stdin\n //!\n //!     ```rust\n-//!     use std::io;\n+//!     use std::old_io as io;\n //!\n //!     for line in io::stdin().lock().lines() {\n //!         print!(\"{}\", line.unwrap());\n@@ -40,7 +58,7 @@\n //! * Read a complete file\n //!\n //!     ```rust\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!\n //!     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n //!     ```\n@@ -49,19 +67,19 @@\n //!\n //!     ```rust\n //!     # #![allow(unused_must_use)]\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!\n //!     let mut file = File::create(&Path::new(\"message.txt\"));\n //!     file.write(b\"hello, file!\\n\");\n //!     # drop(file);\n-//!     # ::std::io::fs::unlink(&Path::new(\"message.txt\"));\n+//!     # ::std::old_io::fs::unlink(&Path::new(\"message.txt\"));\n //!     ```\n //!\n //! * Iterate over the lines of a file\n //!\n //!     ```rust,no_run\n-//!     use std::io::BufferedReader;\n-//!     use std::io::File;\n+//!     use std::old_io::BufferedReader;\n+//!     use std::old_io::File;\n //!\n //!     let path = Path::new(\"message.txt\");\n //!     let mut file = BufferedReader::new(File::open(&path));\n@@ -73,8 +91,8 @@\n //! * Pull the lines of a file into a vector of strings\n //!\n //!     ```rust,no_run\n-//!     use std::io::BufferedReader;\n-//!     use std::io::File;\n+//!     use std::old_io::BufferedReader;\n+//!     use std::old_io::File;\n //!\n //!     let path = Path::new(\"message.txt\");\n //!     let mut file = BufferedReader::new(File::open(&path));\n@@ -85,7 +103,7 @@\n //!\n //!     ```rust\n //!     # #![allow(unused_must_use)]\n-//!     use std::io::TcpStream;\n+//!     use std::old_io::TcpStream;\n //!\n //!     # // connection doesn't fail if a server is running on 8080\n //!     # // locally, we still want to be type checking this code, so lets\n@@ -103,8 +121,8 @@\n //!     # fn main() { }\n //!     # fn foo() {\n //!     # #![allow(dead_code)]\n-//!     use std::io::{TcpListener, TcpStream};\n-//!     use std::io::{Acceptor, Listener};\n+//!     use std::old_io::{TcpListener, TcpStream};\n+//!     use std::old_io::{Acceptor, Listener};\n //!     use std::thread::Thread;\n //!\n //!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n@@ -166,14 +184,14 @@\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n-//! use std::io::File;\n+//! use std::old_io::File;\n //!\n //! match File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\") {\n //!     Ok(()) => (), // succeeded\n //!     Err(e) => println!(\"failed to write to my diary: {}\", e),\n //! }\n //!\n-//! # ::std::io::fs::unlink(&Path::new(\"diary.txt\"));\n+//! # ::std::old_io::fs::unlink(&Path::new(\"diary.txt\"));\n //! ```\n //!\n //! So what actually happens if `create` encounters an error?\n@@ -199,7 +217,7 @@\n //! If you wanted to read several `u32`s from a file and return their product:\n //!\n //! ```rust\n-//! use std::io::{File, IoResult};\n+//! use std::old_io::{File, IoResult};\n //!\n //! fn file_product(p: &Path) -> IoResult<u32> {\n //!     let mut f = File::open(p);\n@@ -925,9 +943,9 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// # Examples\n ///\n /// ```\n-/// use std::io;\n-/// use std::io::ByRefReader;\n-/// use std::io::util::LimitReader;\n+/// use std::old_io as io;\n+/// use std::old_io::ByRefReader;\n+/// use std::old_io::util::LimitReader;\n ///\n /// fn process_input<R: Reader>(r: R) {}\n ///\n@@ -1254,8 +1272,8 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// # Example\n ///\n /// ```\n-/// use std::io::util::TeeReader;\n-/// use std::io::{stdin, ByRefWriter};\n+/// use std::old_io::util::TeeReader;\n+/// use std::old_io::{stdin, ByRefWriter};\n ///\n /// fn process_input<R: Reader>(r: R) {}\n ///\n@@ -1379,7 +1397,7 @@ pub trait Buffer: Reader {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::BufReader;\n+    /// use std::old_io::BufReader;\n     ///\n     /// let mut reader = BufReader::new(b\"hello\\nworld\");\n     /// assert_eq!(\"hello\\n\", &*reader.read_line().unwrap());\n@@ -1601,7 +1619,7 @@ impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n /// # Example\n ///\n /// ```\n-/// use std::io;\n+/// use std::old_io as io;\n ///\n /// let eof = io::standard_error(io::EndOfFile);\n /// let einval = io::standard_error(io::InvalidInput);\n@@ -1691,7 +1709,7 @@ pub enum FileType {\n /// ```no_run\n /// # #![allow(unstable)]\n ///\n-/// use std::io::fs::PathExtensions;\n+/// use std::old_io::fs::PathExtensions;\n ///\n /// let info = match Path::new(\"foo.txt\").stat() {\n ///     Ok(stat) => stat,", "previous_filename": "src/libstd/io/mod.rs"}, {"sha": "9800cc6829ea09ead390633364bd598485159ecb", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -20,8 +20,8 @@ pub use self::Flag::*;\n pub use self::Protocol::*;\n \n use iter::IteratorExt;\n-use io::{IoResult};\n-use io::net::ip::{SocketAddr, IpAddr};\n+use old_io::{IoResult};\n+use old_io::net::ip::{SocketAddr, IpAddr};\n use option::Option;\n use option::Option::{Some, None};\n use string::String;\n@@ -114,7 +114,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n mod test {\n     use prelude::v1::*;\n     use super::*;\n-    use io::net::ip::*;\n+    use old_io::net::ip::*;\n \n     #[test]\n     fn dns_smoke_test() {", "previous_filename": "src/libstd/io/net/addrinfo.rs"}, {"sha": "26eb068b15183e21f553befd3dd385b05c909f3f", "filename": "src/libstd/old_io/net/ip.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -19,8 +19,8 @@ pub use self::IpAddr::*;\n \n use boxed::Box;\n use fmt;\n-use io::{self, IoResult, IoError};\n-use io::net;\n+use old_io::{self, IoResult, IoError};\n+use old_io::net;\n use iter::{Iterator, IteratorExt};\n use ops::{FnOnce, FnMut};\n use option::Option;\n@@ -406,9 +406,9 @@ impl FromStr for SocketAddr {\n /// ```rust,no_run\n /// # #![allow(unused_must_use)]\n ///\n-/// use std::io::{TcpStream, TcpListener};\n-/// use std::io::net::udp::UdpSocket;\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+/// use std::old_io::{TcpStream, TcpListener};\n+/// use std::old_io::net::udp::UdpSocket;\n+/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n ///\n /// fn main() {\n ///     // The following lines are equivalent modulo possible \"localhost\" name resolution\n@@ -438,7 +438,7 @@ pub trait ToSocketAddr {\n     fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n         self.to_socket_addr_all()\n             .and_then(|v| v.into_iter().next().ok_or_else(|| IoError {\n-                kind: io::InvalidInput,\n+                kind: old_io::InvalidInput,\n                 desc: \"no address available\",\n                 detail: None\n             }))\n@@ -481,7 +481,7 @@ fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n             match $e {\n                 Some(r) => r,\n                 None => return Err(IoError {\n-                    kind: io::InvalidInput,\n+                    kind: old_io::InvalidInput,\n                     desc: $msg,\n                     detail: None\n                 })\n@@ -526,7 +526,7 @@ impl<'a> ToSocketAddr for &'a str {\n         parse_and_resolve_socket_addr(*self)\n             .and_then(|v| v.into_iter().next()\n                 .ok_or_else(|| IoError {\n-                    kind: io::InvalidInput,\n+                    kind: old_io::InvalidInput,\n                     desc: \"no address available\",\n                     detail: None\n                 })", "previous_filename": "src/libstd/io/net/ip.rs"}, {"sha": "d8394aa8b6a44b4c8e54e7f19ed84970fac85f77", "filename": "src/libstd/old_io/net/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -10,7 +10,7 @@\n \n //! Networking I/O\n \n-use io::{IoError, IoResult, InvalidInput};\n+use old_io::{IoError, IoResult, InvalidInput};\n use ops::FnMut;\n use option::Option::None;\n use result::Result::{Ok, Err};", "previous_filename": "src/libstd/io/net/mod.rs"}, {"sha": "2ed6d8118d57e6ae6b8ac7b461231d1fa37eadae", "filename": "src/libstd/old_io/net/pipe.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -24,7 +24,7 @@ use prelude::v1::*;\n \n use ffi::CString;\n use path::BytesContainer;\n-use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n+use old_io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n use sys::pipe::UnixListener as UnixListenerImp;\n use sys::pipe::UnixStream as UnixStreamImp;\n@@ -48,7 +48,7 @@ impl UnixStream {\n     ///\n     /// ```rust\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::net::pipe::UnixStream;\n+    /// use std::old_io::net::pipe::UnixStream;\n     ///\n     /// let server = Path::new(\"path/to/my/socket\");\n     /// let mut stream = UnixStream::connect(&server);\n@@ -169,8 +169,8 @@ impl UnixListener {\n     ///\n     /// ```\n     /// # fn foo() {\n-    /// use std::io::net::pipe::UnixListener;\n-    /// use std::io::{Listener, Acceptor};\n+    /// use std::old_io::net::pipe::UnixListener;\n+    /// use std::old_io::{Listener, Acceptor};\n     ///\n     /// let server = Path::new(\"/path/to/my/socket\");\n     /// let stream = UnixListener::bind(&server);\n@@ -270,11 +270,11 @@ impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n mod tests {\n     use prelude::v1::*;\n \n-    use io::fs::PathExtensions;\n-    use io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n-    use io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n-    use io::{PermissionDenied, Acceptor, Listener};\n-    use io::test::*;\n+    use old_io::fs::PathExtensions;\n+    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n+    use old_io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n+    use old_io::{PermissionDenied, Acceptor, Listener};\n+    use old_io::test::*;\n     use super::*;\n     use sync::mpsc::channel;\n     use thread::Thread;", "previous_filename": "src/libstd/io/net/pipe.rs"}, {"sha": "62f3c02e98ff678c9a6ff3566d0af84aaffdfb19", "filename": "src/libstd/old_io/net/tcp.rs", "status": "renamed", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -18,11 +18,11 @@\n //! listener (socket server) implements the `Listener` and `Acceptor` traits.\n \n use clone::Clone;\n-use io::IoResult;\n+use old_io::IoResult;\n use result::Result::Err;\n-use io::net::ip::{SocketAddr, ToSocketAddr};\n-use io::{Reader, Writer, Listener, Acceptor};\n-use io::{standard_error, TimedOut};\n+use old_io::net::ip::{SocketAddr, ToSocketAddr};\n+use old_io::{Reader, Writer, Listener, Acceptor};\n+use old_io::{standard_error, TimedOut};\n use option::Option;\n use option::Option::{None, Some};\n use time::Duration;\n@@ -41,7 +41,7 @@ use sys_common;\n /// # Example\n ///\n /// ```no_run\n-/// use std::io::TcpStream;\n+/// use std::old_io::TcpStream;\n ///\n /// {\n ///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n@@ -133,8 +133,8 @@ impl TcpStream {\n     ///\n     /// ```no_run\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::timer;\n-    /// use std::io::TcpStream;\n+    /// use std::old_io::timer;\n+    /// use std::old_io::TcpStream;\n     /// use std::time::Duration;\n     /// use std::thread::Thread;\n     ///\n@@ -276,8 +276,8 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n ///\n /// ```\n /// # fn foo() {\n-/// use std::io::{TcpListener, TcpStream};\n-/// use std::io::{Acceptor, Listener};\n+/// use std::old_io::{TcpListener, TcpStream};\n+/// use std::old_io::{Acceptor, Listener};\n /// use std::thread::Thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n@@ -373,8 +373,8 @@ impl TcpAcceptor {\n     ///\n     /// ```no_run\n     /// # #![allow(unstable)]\n-    /// use std::io::TcpListener;\n-    /// use std::io::{Listener, Acceptor, TimedOut};\n+    /// use std::old_io::TcpListener;\n+    /// use std::old_io::{Listener, Acceptor, TimedOut};\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     ///\n@@ -417,7 +417,7 @@ impl TcpAcceptor {\n     ///\n     /// ```\n     /// # #![allow(unstable)]\n-    /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n+    /// use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile};\n     /// use std::thread::Thread;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n@@ -486,13 +486,13 @@ mod test {\n \n     use sync::mpsc::channel;\n     use thread::Thread;\n-    use io::net::tcp::*;\n-    use io::net::ip::*;\n-    use io::test::*;\n-    use io::{EndOfFile, TimedOut, ShortWrite, IoError};\n-    use io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n-    use io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n-    use io::{Acceptor, Listener};\n+    use old_io::net::tcp::*;\n+    use old_io::net::ip::*;\n+    use old_io::test::*;\n+    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError};\n+    use old_io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n+    use old_io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n+    use old_io::{Acceptor, Listener};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]", "previous_filename": "src/libstd/io/net/tcp.rs"}, {"sha": "d7fc760951e8f9f3d588ef8638450fc08bf8fb2a", "filename": "src/libstd/old_io/net/udp.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -16,8 +16,8 @@\n //! datagram protocol.\n \n use clone::Clone;\n-use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use io::IoResult;\n+use old_io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n+use old_io::IoResult;\n use option::Option;\n use sys::udp::UdpSocket as UdpSocketImp;\n use sys_common;\n@@ -34,8 +34,8 @@ use sys_common;\n /// # #![allow(unused_must_use)]\n /// #![feature(slicing_syntax)]\n ///\n-/// use std::io::net::udp::UdpSocket;\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+/// use std::old_io::net::udp::UdpSocket;\n+/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n /// fn main() {\n ///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n ///     let mut socket = match UdpSocket::bind(addr) {\n@@ -181,9 +181,9 @@ mod test {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use io::net::ip::*;\n-    use io::test::*;\n-    use io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n+    use old_io::net::ip::*;\n+    use old_io::test::*;\n+    use old_io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n     use super::*;\n     use thread::Thread;\n ", "previous_filename": "src/libstd/io/net/udp.rs"}, {"sha": "224f3bfd98c0ff2ba464226ac058299c0c0dcaa9", "filename": "src/libstd/old_io/pipe.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::v1::*;\n \n-use io::IoResult;\n+use old_io::IoResult;\n use libc;\n use sync::Arc;\n \n@@ -49,7 +49,7 @@ impl PipeStream {\n     /// # #![allow(unused_must_use)]\n     /// extern crate libc;\n     ///\n-    /// use std::io::pipe::PipeStream;\n+    /// use std::old_io::pipe::PipeStream;\n     ///\n     /// fn main() {\n     ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n@@ -120,7 +120,7 @@ mod test {\n     #[test]\n     fn partial_read() {\n         use os;\n-        use io::pipe::PipeStream;\n+        use old_io::pipe::PipeStream;\n \n         let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n         let out = PipeStream::open(writer);", "previous_filename": "src/libstd/io/pipe.rs"}, {"sha": "d7c263b3d1fcdf2e8333132dd494a5144272bcbc", "filename": "src/libstd/old_io/process.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -21,9 +21,9 @@ use prelude::v1::*;\n use collections::HashMap;\n use ffi::CString;\n use fmt;\n-use io::pipe::{PipeStream, PipePair};\n-use io::{IoResult, IoError};\n-use io;\n+use old_io::pipe::{PipeStream, PipePair};\n+use old_io::{IoResult, IoError};\n+use old_io;\n use libc;\n use os;\n use path::BytesContainer;\n@@ -58,7 +58,7 @@ use thread::Thread;\n /// # Example\n ///\n /// ```should_fail\n-/// use std::io::Command;\n+/// use std::old_io::Command;\n ///\n /// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n ///     Ok(child) => child,\n@@ -159,7 +159,7 @@ pub type EnvMap = HashMap<EnvKey, CString>;\n /// to be changed (for example, by adding arguments) prior to spawning:\n ///\n /// ```\n-/// use std::io::Command;\n+/// use std::old_io::Command;\n ///\n /// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n ///   Ok(p) => p,\n@@ -359,7 +359,7 @@ impl Command {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::io::Command;\n+    /// use std::old_io::Command;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n     ///     Ok(output) => output,\n@@ -380,7 +380,7 @@ impl Command {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::io::Command;\n+    /// use std::old_io::Command;\n     ///\n     /// let status = match Command::new(\"ls\").status() {\n     ///     Ok(status) => status,\n@@ -583,7 +583,7 @@ impl Process {\n         // newer process that happens to have the same (re-used) id\n         if self.exit_code.is_some() {\n             return Err(IoError {\n-                kind: io::InvalidInput,\n+                kind: old_io::InvalidInput,\n                 desc: \"invalid argument: can't kill an exited process\",\n                 detail: None,\n             })\n@@ -654,8 +654,8 @@ impl Process {\n     ///\n     /// ```no_run\n     /// # #![allow(unstable)]\n-    /// use std::io::{Command, IoResult};\n-    /// use std::io::process::ProcessExit;\n+    /// use std::old_io::{Command, IoResult};\n+    /// use std::old_io::process::ProcessExit;\n     ///\n     /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n     ///     let mut p = try!(Command::new(\"long-running-process\").spawn());\n@@ -698,7 +698,7 @@ impl Process {\n     /// fail.\n     pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> {\n         drop(self.stdin.take());\n-        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n+        fn read(stream: Option<old_io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => {\n@@ -752,12 +752,12 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n-    use io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n+    use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n     use prelude::v1::{Ok, Err, range, drop, Some, None, Vec};\n     use prelude::v1::{Path, String, Reader, Writer, Clone};\n     use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n-    use io::fs::PathExtensions;\n-    use io::timer::*;\n+    use old_io::fs::PathExtensions;\n+    use old_io::timer::*;\n     use rt::running_on_valgrind;\n     use str;\n     use super::{CreatePipe};", "previous_filename": "src/libstd/io/process.rs"}, {"sha": "c1474650f1eb479fa73245b253105b9b708302c3", "filename": "src/libstd/old_io/result.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "previous_filename": "src/libstd/io/result.rs"}, {"sha": "04eedc758cd4c952b20dd81cfd2964a2d78667ef", "filename": "src/libstd/old_io/stdio.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -21,7 +21,7 @@\n //! # #![allow(unused_must_use)]\n //! use std::io;\n //!\n-//! let mut out = io::stdout();\n+//! let mut out = old_io::stdout();\n //! out.write(b\"Hello, world!\");\n //! ```\n \n@@ -32,7 +32,7 @@ use cell::RefCell;\n use clone::Clone;\n use failure::LOCAL_STDERR;\n use fmt;\n-use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n+use old_io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use marker::{Sync, Send};\n use libc;\n@@ -143,7 +143,7 @@ impl StdinReader {\n     /// ```rust\n     /// use std::io;\n     ///\n-    /// for line in io::stdin().lock().lines() {\n+    /// for line in old_io::stdin().lock().lines() {\n     ///     println!(\"{}\", line.unwrap());\n     /// }\n     /// ```\n@@ -539,7 +539,7 @@ mod tests {\n \n     #[test]\n     fn capture_stdout() {\n-        use io::{ChanReader, ChanWriter};\n+        use old_io::{ChanReader, ChanWriter};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n@@ -552,7 +552,7 @@ mod tests {\n \n     #[test]\n     fn capture_stderr() {\n-        use io::{ChanReader, ChanWriter, Reader};\n+        use old_io::{ChanReader, ChanWriter, Reader};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));", "previous_filename": "src/libstd/io/stdio.rs"}, {"sha": "029fef7c19709184a21554a83e70568f9783c59d", "filename": "src/libstd/old_io/tempfile.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -10,8 +10,8 @@\n \n //! Temporary files and directories\n \n-use io::{fs, IoError, IoErrorKind, IoResult};\n-use io;\n+use old_io::{fs, IoError, IoErrorKind, IoResult};\n+use old_io;\n use iter::{IteratorExt, range};\n use ops::Drop;\n use option::Option;\n@@ -29,7 +29,7 @@ use string::String;\n /// # Examples\n ///\n /// ```no_run\n-/// use std::io::TempDir;\n+/// use std::old_io::TempDir;\n ///\n /// {\n ///     // create a temporary directory\n@@ -113,7 +113,7 @@ impl TempDir {\n                 suffix\n             };\n             let path = tmpdir.join(leaf);\n-            match fs::mkdir(&path, io::USER_RWX) {\n+            match fs::mkdir(&path, old_io::USER_RWX) {\n                 Ok(_) => return Ok(TempDir { path: Some(path), disarmed: false }),\n                 Err(IoError{kind:IoErrorKind::PathAlreadyExists,..}) => (),\n                 Err(e) => return Err(e)", "previous_filename": "src/libstd/io/tempfile.rs"}, {"sha": "f49e2397d4282b49fb2f8d0658268f6bf09e422a", "filename": "src/libstd/old_io/test.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -14,7 +14,7 @@ use prelude::v1::*;\n \n use libc;\n use os;\n-use std::io::net::ip::*;\n+use std::old_io::net::ip::*;\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n /// Get a port number, starting at 9600, for use in tests", "previous_filename": "src/libstd/io/test.rs"}, {"sha": "7e15c9ad7fcdba88237e30c2d1a4d8a54a697dcb", "filename": "src/libstd/old_io/timer.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -17,7 +17,7 @@\n \n use sync::mpsc::{Receiver, Sender, channel};\n use time::Duration;\n-use io::IoResult;\n+use old_io::IoResult;\n use sys::timer::Callback;\n use sys::timer::Timer as TimerImp;\n \n@@ -31,7 +31,7 @@ use sys::timer::Timer as TimerImp;\n ///\n /// ```\n /// # fn foo() {\n-/// use std::io::Timer;\n+/// use std::old_io::Timer;\n /// use std::time::Duration;\n ///\n /// let mut timer = Timer::new().unwrap();\n@@ -50,11 +50,11 @@ use sys::timer::Timer as TimerImp;\n /// ```\n ///\n /// If only sleeping is necessary, then a convenience API is provided through\n-/// the `io::timer` module.\n+/// the `old_io::timer` module.\n ///\n /// ```\n /// # fn foo() {\n-/// use std::io::timer;\n+/// use std::old_io::timer;\n /// use std::time::Duration;\n ///\n /// // Put this task to sleep for 5 seconds\n@@ -115,7 +115,7 @@ impl Timer {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// let mut timer = Timer::new().unwrap();\n@@ -128,7 +128,7 @@ impl Timer {\n     /// ```\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// // Incorrect, method chaining-style:\n@@ -167,7 +167,7 @@ impl Timer {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// let mut timer = Timer::new().unwrap();\n@@ -186,7 +186,7 @@ impl Timer {\n     /// ```\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// // Incorrect, method chaining-style.", "previous_filename": "src/libstd/io/timer.rs"}, {"sha": "f3f0b8dd6638efdc85ee821f838dfe6dfab27cd3", "filename": "src/libstd/old_io/util.rs", "status": "renamed", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72b1645103e12b581f7022b893c37b5fe41aef7/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=f72b1645103e12b581f7022b893c37b5fe41aef7", "patch": "@@ -12,7 +12,7 @@\n \n use prelude::v1::*;\n use cmp;\n-use io;\n+use old_io;\n use slice::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n@@ -42,9 +42,9 @@ impl<R: Reader> LimitReader<R> {\n }\n \n impl<R: Reader> Reader for LimitReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         if self.limit == 0 {\n-            return Err(io::standard_error(io::EndOfFile));\n+            return Err(old_io::standard_error(old_io::EndOfFile));\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n@@ -58,11 +58,11 @@ impl<R: Reader> Reader for LimitReader<R> {\n }\n \n impl<R: Buffer> Buffer for LimitReader<R> {\n-    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n         let buf = &amt[..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(buf)\n         }\n@@ -83,7 +83,7 @@ pub struct NullWriter;\n \n impl Writer for NullWriter {\n     #[inline]\n-    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }\n+    fn write(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n@@ -92,14 +92,14 @@ pub struct ZeroReader;\n \n impl Reader for ZeroReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         buf.set_memory(0);\n         Ok(buf.len())\n     }\n }\n \n impl Buffer for ZeroReader {\n-    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         static DATA: [u8; 64] = [0; 64];\n         Ok(DATA.as_slice())\n     }\n@@ -113,14 +113,14 @@ pub struct NullReader;\n \n impl Reader for NullReader {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> {\n-        Err(io::standard_error(io::EndOfFile))\n+    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n \n impl Buffer for NullReader {\n-    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n-        Err(io::standard_error(io::EndOfFile))\n+    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n+        Err(old_io::standard_error(old_io::EndOfFile))\n     }\n     fn consume(&mut self, _amt: uint) {}\n }\n@@ -143,15 +143,15 @@ impl<W> MultiWriter<W> where W: Writer {\n \n impl<W> Writer for MultiWriter<W> where W: Writer {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+    fn write(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n         for writer in self.writers.iter_mut() {\n             try!(writer.write(buf));\n         }\n         Ok(())\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::IoResult<()> {\n+    fn flush(&mut self) -> old_io::IoResult<()> {\n         for writer in self.writers.iter_mut() {\n             try!(writer.flush());\n         }\n@@ -176,13 +176,13 @@ impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n }\n \n impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         loop {\n             let err = match self.cur_reader {\n                 Some(ref mut r) => {\n                     match r.read(buf) {\n                         Ok(len) => return Ok(len),\n-                        Err(ref e) if e.kind == io::EndOfFile => None,\n+                        Err(ref e) if e.kind == old_io::EndOfFile => None,\n                         Err(e) => Some(e),\n                     }\n                 }\n@@ -194,7 +194,7 @@ impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n                 None => {}\n             }\n         }\n-        Err(io::standard_error(io::EndOfFile))\n+        Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n \n@@ -221,20 +221,20 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n }\n \n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n             self.writer.write(&mut buf[..len]).map(|()| len)\n         })\n     }\n }\n \n /// Copies all data from a `Reader` to a `Writer`.\n-pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n+pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()> {\n     let mut buf = [0; super::DEFAULT_BUF_SIZE];\n     loop {\n         let len = match r.read(&mut buf) {\n             Ok(len) => len,\n-            Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n+            Err(ref e) if e.kind == old_io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n         try!(w.write(&buf[..len]));\n@@ -257,14 +257,14 @@ impl<T: Iterator<Item=u8>> IterReader<T> {\n \n impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         let mut len = 0;\n         for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n             *slot = elt;\n             len += 1;\n         }\n         if len == 0 && buf.len() != 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(len)\n         }\n@@ -275,7 +275,7 @@ impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n mod test {\n     use prelude::v1::*;\n \n-    use io::{MemReader, ByRefReader};\n+    use old_io::{MemReader, ByRefReader};\n     use io;\n     use super::*;\n \n@@ -347,12 +347,12 @@ mod test {\n \n         struct TestWriter;\n         impl Writer for TestWriter {\n-            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> {\n+            fn write(&mut self, _buf: &[u8]) -> old_io::IoResult<()> {\n                 unsafe { writes += 1 }\n                 Ok(())\n             }\n \n-            fn flush(&mut self) -> io::IoResult<()> {\n+            fn flush(&mut self) -> old_io::IoResult<()> {\n                 unsafe { flushes += 1 }\n                 Ok(())\n             }\n@@ -400,7 +400,7 @@ mod test {\n             let mut r = LimitReader::new(r.by_ref(), 3);\n             assert_eq!(r.read_line(), Ok(\"012\".to_string()));\n             assert_eq!(r.limit(), 0);\n-            assert_eq!(r.read_line().err().unwrap().kind, io::EndOfFile);\n+            assert_eq!(r.read_line().err().unwrap().kind, old_io::EndOfFile);\n         }\n         {\n             let mut r = LimitReader::new(r.by_ref(), 9);\n@@ -432,7 +432,7 @@ mod test {\n         assert_eq!(len, 2);\n         assert!(buf == [6, 7, 5]);\n \n-        assert_eq!(r.read(&mut buf).unwrap_err().kind, io::EndOfFile);\n+        assert_eq!(r.read(&mut buf).unwrap_err().kind, old_io::EndOfFile);\n     }\n \n     #[test]", "previous_filename": "src/libstd/io/util.rs"}]}