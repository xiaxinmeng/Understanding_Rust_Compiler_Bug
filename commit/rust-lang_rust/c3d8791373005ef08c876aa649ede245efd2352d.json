{"sha": "c3d8791373005ef08c876aa649ede245efd2352d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZDg3OTEzNzMwMDVlZjA4Yzg3NmFhNjQ5ZWRlMjQ1ZWZkMjM1MmQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T16:25:31Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:21:10Z"}, "message": "Rename `Ty.node` to `Ty.kind`", "tree": {"sha": "d60090ad10eecda23484b9c922288929dcb81cd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d60090ad10eecda23484b9c922288929dcb81cd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d8791373005ef08c876aa649ede245efd2352d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d8791373005ef08c876aa649ede245efd2352d", "html_url": "https://github.com/rust-lang/rust/commit/c3d8791373005ef08c876aa649ede245efd2352d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d8791373005ef08c876aa649ede245efd2352d/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4573c9c1e8118be5ffc662c6a64db329db0a245", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4573c9c1e8118be5ffc662c6a64db329db0a245", "html_url": "https://github.com/rust-lang/rust/commit/d4573c9c1e8118be5ffc662c6a64db329db0a245"}], "stats": {"total": 275, "additions": 138, "deletions": 137}, "files": [{"sha": "b06cea5cd1acc0c888642bf0d6635678b3a7b93f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -594,7 +594,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     visitor.visit_id(typ.hir_id);\n \n-    match typ.node {\n+    match typ.kind {\n         TyKind::Slice(ref ty) => {\n             visitor.visit_ty(ty)\n         }"}, {"sha": "a62ef4e840ca2aff10145108c23a45be961dc46f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -346,7 +346,7 @@ struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n \n impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.node {\n+        match ty.kind {\n             | TyKind::Typeof(_)\n             | TyKind::BareFn(_)\n             => return,\n@@ -497,7 +497,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_ty(&mut self, t: &'tcx Ty) {\n-                match t.node {\n+                match t.kind {\n                     // Mirrors the case in visit::walk_ty\n                     TyKind::BareFn(ref f) => {\n                         walk_list!(\n@@ -1104,7 +1104,7 @@ impl<'a> LoweringContext<'a> {\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: this.sess.next_node_id(),\n-                                node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n+                                kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n                                 span: constraint.span,\n                             },\n                             itctx,\n@@ -1165,14 +1165,14 @@ impl<'a> LoweringContext<'a> {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n         let ty = self.ty_path(id, t.span, qpath);\n-        if let hir::TyKind::TraitObject(..) = ty.node {\n+        if let hir::TyKind::TraitObject(..) = ty.kind {\n             self.maybe_lint_bare_trait(t.span, t.id, qself.is_none() && path.is_global());\n         }\n         ty\n     }\n \n     fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty {\n-        let kind = match t.node {\n+        let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n             TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n@@ -1345,7 +1345,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::Ty {\n-            node: kind,\n+            kind,\n             span: t.span,\n             hir_id: self.lower_node_id(t.id),\n         }\n@@ -1505,7 +1505,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax.\n-                if let hir::TyKind::BareFn(_) = t.node {\n+                if let hir::TyKind::BareFn(_) = t.kind {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -2026,7 +2026,7 @@ impl<'a> LoweringContext<'a> {\n                     .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n                     .collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n-                    hir::Ty { node: hir::TyKind::Tup(tys), hir_id: this.next_id(), span }\n+                    hir::Ty { kind: hir::TyKind::Tup(tys), hir_id: this.next_id(), span }\n                 };\n                 (\n                     hir::GenericArgs {\n@@ -2179,16 +2179,16 @@ impl<'a> LoweringContext<'a> {\n                         _ => false,\n                     };\n \n-                    match arg.ty.node {\n+                    match arg.ty.kind {\n                         TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n                         TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n                         // Given we are only considering `ImplicitSelf` types, we needn't consider\n                         // the case where we have a mutable pattern to a reference as that would\n                         // no longer be an `ImplicitSelf`.\n-                        TyKind::Rptr(_, ref mt) if mt.ty.node.is_implicit_self() &&\n+                        TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() &&\n                             mt.mutbl == ast::Mutability::Mutable =>\n                                 hir::ImplicitSelfKind::MutRef,\n-                        TyKind::Rptr(_, ref mt) if mt.ty.node.is_implicit_self() =>\n+                        TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() =>\n                             hir::ImplicitSelfKind::ImmRef,\n                         _ => hir::ImplicitSelfKind::None,\n                     }\n@@ -2403,7 +2403,7 @@ impl<'a> LoweringContext<'a> {\n         let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n \n         hir::FunctionRetTy::Return(P(hir::Ty {\n-            node: opaque_ty_ref,\n+            kind: opaque_ty_ref,\n             span,\n             hir_id: self.next_id(),\n         }))\n@@ -2424,7 +2424,7 @@ impl<'a> LoweringContext<'a> {\n             FunctionRetTy::Default(ret_ty_span) => {\n                 P(hir::Ty {\n                     hir_id: self.next_id(),\n-                    node: hir::TyKind::Tup(hir_vec![]),\n+                    kind: hir::TyKind::Tup(hir_vec![]),\n                     span: *ret_ty_span,\n                 })\n             }\n@@ -3164,7 +3164,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn ty_path(&mut self, mut hir_id: hir::HirId, span: Span, qpath: hir::QPath) -> hir::Ty {\n-        let node = match qpath {\n+        let kind = match qpath {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead.\n                 match path.res {\n@@ -3188,9 +3188,10 @@ impl<'a> LoweringContext<'a> {\n             }\n             _ => hir::TyKind::Path(qpath),\n         };\n+\n         hir::Ty {\n             hir_id,\n-            node,\n+            kind,\n             span,\n         }\n     }\n@@ -3394,7 +3395,7 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n         ExprKind::Call(ref func, _) => {\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n-                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n                     let new_call = segment.ident.as_str() == \"new\";\n                     return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n                 }"}, {"sha": "14311585652c352906313a0d626e52a3f7061730", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -789,7 +789,7 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.node {\n+        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n                 qself,\n@@ -1343,7 +1343,7 @@ impl LoweringContext<'_> {\n                             );\n                         };\n                         // Check if the where clause type is a plain type parameter.\n-                        match bound_pred.bounded_ty.node {\n+                        match bound_pred.bounded_ty.kind {\n                             TyKind::Path(None, ref path)\n                                 if path.segments.len() == 1\n                                     && bound_pred.bound_generic_params.is_empty() =>"}, {"sha": "0bfd8cbdfa263b6378d356b8611177ad241e2372", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -292,7 +292,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id),\n             TyKind::ImplTrait(node_id, _) => {\n                 self.create_def(node_id, DefPathData::ImplTrait, ty.span);"}, {"sha": "e2ea3d26558a2e95bc880b8531d0a5adbd37b0ca", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -479,7 +479,7 @@ impl GenericArgs {\n                 match arg {\n                     GenericArg::Lifetime(_) => {}\n                     GenericArg::Type(ref ty) => {\n-                        if let TyKind::Tup(ref tys) = ty.node {\n+                        if let TyKind::Tup(ref tys) = ty.kind {\n                             return tys;\n                         }\n                         break;\n@@ -1939,7 +1939,7 @@ impl TypeBinding {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub hir_id: HirId,\n-    pub node: TyKind,\n+    pub kind: TyKind,\n     pub span: Span,\n }\n "}, {"sha": "7ca3482295c7d83bdd0d272c6fdd51df6bab720e", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -286,7 +286,7 @@ impl<'a> State<'a> {\n     pub fn print_type(&mut self, ty: &hir::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.node {\n+        match ty.kind {\n             hir::TyKind::Slice(ref ty) => {\n                 self.s.word(\"[\");\n                 self.print_type(&ty);\n@@ -1880,7 +1880,7 @@ impl<'a> State<'a> {\n             s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n             i += 1;\n \n-            if let hir::TyKind::Infer = ty.node {\n+            if let hir::TyKind::Infer = ty.kind {\n                 // Print nothing.\n             } else {\n                 s.s.word(\":\");"}, {"sha": "01588657f3341067fa733d669defb3da11c350be", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -144,11 +144,11 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n                 hir_id: _,\n-                ref node,\n+                ref kind,\n                 ref span,\n             } = *self;\n \n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "42017a2358166e38718ed7487011f102feb3a3a3", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -98,7 +98,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n     }\n \n     fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n-        match arg.node {\n+        match arg.kind {\n             hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n                 intravisit::walk_ty(self, arg);"}, {"sha": "a9a2c15d7d99b6d83b936f56a08cf8d316daecae", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 return None;\n             }\n             if let FunctionRetTy::Return(ty) = &fndecl.output {\n-                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.node, sub) {\n+                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.kind, sub) {\n                     // This is an impl Trait return that evaluates de need of 'static.\n                     // We handle this case better in `static_impl_trait`.\n                     return None;"}, {"sha": "f0271db54f6b90a995c346095a425220c18cadba", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty) {\n-        match &ty.node {\n+        match &ty.kind {\n             TyKind::Path(qpath) => {\n                 if let QPath::Resolved(_, path) = qpath {\n                     if let Some(last) = path.segments.iter().last() {\n@@ -169,7 +169,7 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n }\n \n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n-    match &ty.node {\n+    match &ty.kind {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n                 let did = path.res.opt_def_id()?;"}, {"sha": "7d0b7e8e7e8ee2bd13fa94120ea5aab706d58dd6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Def(item_id, _) => {\n                 let item = self.tcx.hir().expect_item(item_id.id);\n                 intravisit::walk_item(self, item);"}, {"sha": "875d0d7dd02c139c12e58bb4fd26b5c0c4b24aee", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -558,8 +558,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n-        debug!(\"visit_ty: ty.node={:?}\", ty.node);\n-        match ty.node {\n+        debug!(\"visit_ty: ty.kind={:?}\", ty.kind);\n+        match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n@@ -1352,7 +1352,7 @@ fn object_lifetime_defaults_for_item(\n                         continue;\n                     }\n \n-                    let res = match data.bounded_ty.node {\n+                    let res = match data.bounded_ty.kind {\n                         hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n                         _ => continue,\n                     };\n@@ -1487,7 +1487,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut elide_use = None;\n         let mut find_arg_use_span = |inputs: &hir::HirVec<hir::Ty>| {\n             for input in inputs {\n-                match input.node {\n+                match input.kind {\n                     hir::TyKind::Rptr(lt, _) => {\n                         if lt.name.ident() == name {\n                             // include the trailing whitespace between the lifetime and type names\n@@ -2270,8 +2270,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 fn visit_ty(&mut self, ty: &'a hir::Ty) {\n-                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.node {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node\n+                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n+                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n                         {\n                             if self.is_self_ty(path.res) {\n                                 if let Some(lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n@@ -2286,7 +2286,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let mut visitor = SelfVisitor {\n                 map: self.map,\n-                impl_self: impl_self.map(|ty| &ty.node),\n+                impl_self: impl_self.map(|ty| &ty.kind),\n                 lifetime: Set1::Empty,\n             };\n             visitor.visit_ty(&inputs[0]);\n@@ -2364,10 +2364,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_ty(&mut self, ty: &hir::Ty) {\n-                if let hir::TyKind::BareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.kind {\n                     self.outer_index.shift_in(1);\n                 }\n-                match ty.node {\n+                match ty.kind {\n                     hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                         for bound in bounds {\n                             self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n@@ -2384,7 +2384,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         intravisit::walk_ty(self, ty);\n                     }\n                 }\n-                if let hir::TyKind::BareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.kind {\n                     self.outer_index.shift_out(1);\n                 }\n             }\n@@ -2991,7 +2991,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n-            match ty.node {\n+            match ty.kind {\n                 hir::TyKind::Path(hir::QPath::Resolved(Some(_), _))\n                 | hir::TyKind::Path(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type"}, {"sha": "13601c6fe164a0e085c487a1e5fe8d973c6cbd19", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1177,7 +1177,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ..\n             }) => {\n                 (self.tcx.sess.source_map().def_span(span), decl.inputs.iter()\n-                        .map(|arg| match arg.clone().node {\n+                        .map(|arg| match arg.clone().kind {\n                     hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n                         vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()]"}, {"sha": "44899721b1f8589dbb7f9b9938a98f96813dc1e7", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -738,7 +738,7 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n     fn should_ignore_fn(ret_ty: &ast::FnDecl) -> bool {\n         if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n             fn involves_impl_trait(ty: &ast::Ty) -> bool {\n-                match ty.node {\n+                match ty.kind {\n                     ast::TyKind::ImplTrait(..) => true,\n                     ast::TyKind::Slice(ref subty) |\n                     ast::TyKind::Array(ref subty, _) |"}, {"sha": "f7695b18c5f8f995f6cb922ddd0f7508f2188897", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1090,7 +1090,7 @@ impl TypeAliasBounds {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n-                match ty.node {\n+                match ty.kind {\n                     hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                         match path.res {\n                             Res::Def(DefKind::TyParam, _) => true,\n@@ -1750,7 +1750,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                     hir::WherePredicate::BoundPredicate(predicate) => {\n                         // FIXME we can also infer bounds on associated types,\n                         // and should check for them here.\n-                        match predicate.bounded_ty.node {\n+                        match predicate.bounded_ty.kind {\n                             hir::TyKind::Path(hir::QPath::Resolved(\n                                 None,\n                                 ref path,"}, {"sha": "1c72a8c6ddbd600c81758cb1443518a0369d14de", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1799,7 +1799,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        match ty.node {\n+        match ty.kind {\n             hir::TyKind::Array(_, ref length) => {\n                 let def_id = self.tcx.hir().local_def_id(length.hir_id);\n                 self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);"}, {"sha": "9788631fc959033871ee4bf7a06ebb73f45cb110", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1845,7 +1845,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n                             // the lifetime span.\n-                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n+                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].kind {\n                                 // With access to the lifetime, we can get\n                                 // the span of it.\n                                 arguments.push((*argument, lifetime.span));\n@@ -1866,7 +1866,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let return_ty = *sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n                 if let hir::FunctionRetTy::Return(ty) = &fn_decl.output {\n-                    if let hir::TyKind::Rptr(lifetime, _) = ty.node {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.kind {\n                         return_span = lifetime.span;\n                     }\n                 }"}, {"sha": "33520b6755ca47378637ea7c0a4c59609c6f0776", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -642,7 +642,7 @@ fn annotate_struct_field(\n                 if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n                     mutbl: hir::Mutability::MutImmutable,\n                     ref ty\n-                }) = field.ty.node {\n+                }) = field.ty.kind {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and\n                     // type being referenced, that way we can reconstruct the snippet without loss\n                     // of detail."}, {"sha": "c4b508e030f39ac76611088214ac28db0b0b3058", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -425,7 +425,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n-        match argument_hir_ty.node {\n+        match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n             // must highlight the variable.\n@@ -527,7 +527,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             &mut vec![(argument_ty, argument_hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n-            match (&ty.kind, &hir_ty.node) {\n+            match (&ty.kind, &hir_ty.kind) {\n                 // Check if the `argument_ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:"}, {"sha": "5ccf73290a6329eab665ab375bc48f35092dfd0b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -107,7 +107,7 @@ impl<'a> AstValidator<'a> {\n                 // rust-lang/rust#57979: bug in old `visit_generic_args` called\n                 // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n                 // if it happened to occur at `ty`.\n-                if let TyKind::ImplTrait(..) = ty.node {\n+                if let TyKind::ImplTrait(..) = ty.kind {\n                     self.warning_period_57979_didnt_record_next_impl_trait = true;\n                 }\n             }\n@@ -126,7 +126,7 @@ impl<'a> AstValidator<'a> {\n         // rust-lang/rust#57979: bug in old `visit_generic_args` called\n         // `walk_ty` rather than `visit_ty`, skippping outer `impl Trait`\n         // if it happened to occur at `ty`.\n-        if let TyKind::ImplTrait(..) = ty.node {\n+        if let TyKind::ImplTrait(..) = ty.kind {\n             self.warning_period_57979_didnt_record_next_impl_trait = true;\n         }\n         self.visit_ty(ty);\n@@ -149,7 +149,7 @@ impl<'a> AstValidator<'a> {\n \n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n-        match t.node {\n+        match t.kind {\n             TyKind::ImplTrait(..) => {\n                 let outer_impl_trait = self.outer_impl_trait(t.span);\n                 self.with_impl_trait(Some(outer_impl_trait), |this| visit::walk_ty(this, t))\n@@ -456,7 +456,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::BareFn(ref bfty) => {\n                 self.check_fn_decl(&bfty.decl);\n                 self.check_decl_no_pat(&bfty.decl, |span, _| {\n@@ -541,7 +541,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n-                if let TyKind::Err = ty.node {\n+                if let TyKind::Err = ty.kind {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n                         .help(\"use `auto trait Trait {}` instead\").emit();"}, {"sha": "a72c9e574d0df21440c4b93203a98f9f768f632a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1389,14 +1389,14 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.kind {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // Found what we're looking for, so let's stop working.\n                 return\n             }\n         }\n-        if let hir::TyKind::Path(_) = ty.node {\n+        if let hir::TyKind::Path(_) = ty.kind {\n             if self.at_outer_type {\n                 self.outer_type_is_public_path = true;\n             }\n@@ -1628,7 +1628,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.kind {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.hir_id);\n             }"}, {"sha": "ba612bb04ac9e67c958acc3b84f819ead0b0b694", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1120,9 +1120,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n }\n \n macro_rules! method {\n-    ($visit:ident: $ty:ty, $invoc:path, $walk:ident, $kind:ident) => {\n+    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n         fn $visit(&mut self, node: &'b $ty) {\n-            if let $invoc(..) = node.$kind {\n+            if let $invoc(..) = node.kind {\n                 self.visit_invoc(node.id);\n             } else {\n                 visit::$walk(self, node);\n@@ -1132,10 +1132,10 @@ macro_rules! method {\n }\n \n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n-    method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item, kind);\n-    method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr, kind);\n-    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat, kind);\n-    method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty, node);\n+    method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n+    method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n+    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n+    method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.node {"}, {"sha": "9ae1699fb054c93dc30dd72c35c2fe6357d9b8ff", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }"}, {"sha": "0d35cc53ac6f38037ad162ccf5c7389f7c43c013", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -472,7 +472,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         where FilterFn: Fn(Res) -> bool\n     {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n-            match t.node {\n+            match t.kind {\n                 TyKind::Path(None, _) => Some(t.id),\n                 TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not"}, {"sha": "c24552678eb534dcf19718197f7fe8ab7d1accbc", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -385,7 +385,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n \n             if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n-                if let ast::TyKind::ImplTrait(..) = ret_ty.node {\n+                if let ast::TyKind::ImplTrait(..) = ret_ty.kind {\n                     // FIXME: Opaque type desugaring prevents us from easily\n                     // processing trait bounds. See `visit_ty` for more details.\n                 } else {\n@@ -1421,7 +1421,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'l ast::Ty) {\n         self.process_macro_use(t.span);\n-        match t.node {\n+        match t.kind {\n             ast::TyKind::Path(_, ref path) => {\n                 if generated_code(t.span) {\n                     return;"}, {"sha": "bc067ab6ba52acf2e7d78f9810f4088d8b2ba15f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -301,7 +301,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Impl(.., ref trait_ref, ref typ, ref impls) => {\n-                if let ast::TyKind::Path(None, ref path) = typ.node {\n+                if let ast::TyKind::Path(None, ref path) = typ.kind {\n                     // Common case impl for a struct or something basic.\n                     if generated_code(path.span) {\n                         return None;\n@@ -652,7 +652,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 ..\n             }) |\n             Node::Ty(&hir::Ty {\n-                node: hir::TyKind::Path(ref qpath),\n+                kind: hir::TyKind::Path(ref qpath),\n                 ..\n             }) => {\n                 self.tables.qpath_res(qpath, hir_id)"}, {"sha": "87417f577a1ae6ca911717fc442fd2fb4f7c26d0", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -160,7 +160,7 @@ fn text_sig(text: String) -> Signature {\n impl Sig for ast::Ty {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n-        match self.node {\n+        match self.kind {\n             ast::TyKind::Slice(ref ty) => {\n                 let nested = ty.make(offset + 1, id, scx)?;\n                 let text = format!(\"[{}]\", nested.text);"}, {"sha": "6f1d854481a10e90fd516aea00bd5b4358baebf5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -2075,11 +2075,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\",\n-               ast_ty.hir_id, ast_ty, ast_ty.node);\n+               ast_ty.hir_id, ast_ty, ast_ty.kind);\n \n         let tcx = self.tcx();\n \n-        let result_ty = match ast_ty.node {\n+        let result_ty = match ast_ty.kind {\n             hir::TyKind::Slice(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n@@ -2123,7 +2123,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n                     path.res\n                 } else {\n                     Res::Err\n@@ -2270,7 +2270,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n-        match ty.node {\n+        match ty.kind {\n             hir::TyKind::Infer if expected_ty.is_some() => {\n                 self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n                 expected_ty.unwrap()"}, {"sha": "6818d5f521d009ff0fe0d03fd4bec57e0ff634ec", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -445,7 +445,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n                 };\n \n                 impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n-                    match (&impl_arg.node, &trait_arg.node) {\n+                    match (&impl_arg.kind, &trait_arg.kind) {\n                         (&hir::TyKind::Rptr(_, ref impl_mt), &hir::TyKind::Rptr(_, ref trait_mt)) |\n                         (&hir::TyKind::Ptr(ref impl_mt), &hir::TyKind::Ptr(ref trait_mt)) => {\n                             impl_mt.mutbl != trait_mt.mutbl\n@@ -892,7 +892,7 @@ fn compare_synthetic_generics<'tcx>(\n                             fn visit_ty(&mut self, ty: &'v hir::Ty) {\n                                 hir::intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(\n-                                    hir::QPath::Resolved(None, ref path)) = ty.node\n+                                    hir::QPath::Resolved(None, ref path)) = ty.kind\n                                 {\n                                     if let Res::Def(DefKind::TyParam, def_id) = path.res {\n                                         if def_id == self.1 {"}, {"sha": "2ea0afb1793562d47582a6e71143dc9d8c8e2fd5", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -596,7 +596,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let (\n                     hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)),\n                     sym::from,\n-                ) = (&base_ty.node, path_segment.ident.name) {\n+                ) = (&base_ty.kind, path_segment.ident.name) {\n                     if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n                         match ident.name {\n                             sym::i128 | sym::i64 | sym::i32 | sym::i16 | sym::i8 |"}, {"sha": "c076a41f7753b22b23d263e29051f6c8b91f1198", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -886,7 +886,7 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n             fcx\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-            let expected_type = body_ty.and_then(|ty| match ty.node {\n+            let expected_type = body_ty.and_then(|ty| match ty.kind {\n                 hir::TyKind::Infer => Some(AstConv::ast_ty_to_ty(&fcx, ty)),\n                 _ => None\n             }).unwrap_or_else(|| tcx.type_of(def_id));\n@@ -3509,7 +3509,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if let hir::GenericArg::Type(hir_ty) = &arg {\n                                     if let hir::TyKind::Path(\n                                         hir::QPath::TypeRelative(..),\n-                                    ) = &hir_ty.node {\n+                                    ) = &hir_ty.kind {\n                                         // Avoid ICE with associated types. As this is best\n                                         // effort only, it's ok to ignore the case. It\n                                         // would trigger in `is_send::<T::AssocType>();`\n@@ -3722,7 +3722,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.node {\n+                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n                     path.res\n                 } else {\n                     Res::Err\n@@ -4450,7 +4450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (&hir::FunctionRetTy::Return(ref ty), _, _, _) => {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n-                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.node);\n+                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n                 let sp = ty.span;\n                 let ty = AstConv::ast_ty_to_ty(self, ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);"}, {"sha": "019f39ed6e1c8a383a0c76f06611c93a7deb2f0d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -387,7 +387,7 @@ impl ItemCtxt<'tcx> {\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n-    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n                 def_id == tcx.hir().local_def_id(param_id)\n@@ -796,7 +796,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             if self.has_late_bound_regions.is_some() {\n                 return;\n             }\n-            match ty.node {\n+            match ty.kind {\n                 hir::TyKind::BareFn(..) => {\n                     self.outer_index.shift_in(1);\n                     intravisit::walk_ty(self, ty);\n@@ -1214,7 +1214,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             }\n             TraitItemKind::Const(ref ty, body_id)  => {\n                 body_id.and_then(|body_id| {\n-                    if let hir::TyKind::Infer = ty.node {\n+                    if let hir::TyKind::Infer = ty.kind {\n                         Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n                     } else {\n                         None\n@@ -1236,7 +1236,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n-                if let hir::TyKind::Infer = ty.node {\n+                if let hir::TyKind::Infer = ty.kind {\n                     infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n@@ -1268,7 +1268,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             match item.node {\n                 ItemKind::Static(ref ty, .., body_id)\n                 | ItemKind::Const(ref ty, body_id) => {\n-                    if let hir::TyKind::Infer = ty.node {\n+                    if let hir::TyKind::Infer = ty.kind {\n                         infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                     } else {\n                         icx.to_ty(ty)\n@@ -1373,11 +1373,11 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n             match parent_node {\n                 Node::Ty(&hir::Ty {\n-                    node: hir::TyKind::Array(_, ref constant),\n+                    kind: hir::TyKind::Array(_, ref constant),\n                     ..\n                 })\n                 | Node::Ty(&hir::Ty {\n-                    node: hir::TyKind::Typeof(ref constant),\n+                    kind: hir::TyKind::Typeof(ref constant),\n                     ..\n                 })\n                 | Node::Expr(&hir::Expr {\n@@ -1399,13 +1399,13 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         .to_ty(tcx)\n                 }\n \n-                Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n+                Node::Ty(&hir::Ty { kind: hir::TyKind::Path(_), .. }) |\n                 Node::Expr(&hir::Expr { kind: ExprKind::Struct(..), .. }) |\n                 Node::Expr(&hir::Expr { kind: ExprKind::Path(_), .. }) |\n                 Node::TraitRef(..) => {\n                     let path = match parent_node {\n                         Node::Ty(&hir::Ty {\n-                            node: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n+                            kind: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n                             ..\n                         })\n                         | Node::Expr(&hir::Expr {\n@@ -1769,7 +1769,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n pub fn get_infer_ret_ty(output: &'_ hir::FunctionRetTy) -> Option<&hir::Ty> {\n     if let hir::FunctionRetTy::Return(ref ty) = output {\n-        if let hir::TyKind::Infer = ty.node {\n+        if let hir::TyKind::Infer = ty.kind {\n             return Some(&**ty)\n         }\n     }"}, {"sha": "161b1a996a9c09392ad0bd4d4196c613f5cd716b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -2835,7 +2835,7 @@ impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc::hir::*;\n \n-        match self.node {\n+        match self.kind {\n             TyKind::Never => Never,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyKind::Rptr(ref l, ref m) => {\n@@ -3031,7 +3031,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n-            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.node),\n+            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n             TyKind::CVarArgs(_) => CVarArgs,\n         }\n     }"}, {"sha": "73751c422f6e09a12ffe5cff701cd33621cba6b6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -525,7 +525,7 @@ impl Pat {\n     /// Attempt reparsing the pattern as a type.\n     /// This is intended for use by diagnostics.\n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n-        let node = match &self.kind {\n+        let kind = match &self.kind {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n@@ -555,7 +555,7 @@ impl Pat {\n         };\n \n         Some(P(Ty {\n-            node,\n+            kind,\n             id: self.id,\n             span: self.span,\n         }))\n@@ -1051,7 +1051,7 @@ impl Expr {\n         };\n \n         Some(P(Ty {\n-            node: kind,\n+            kind,\n             id: self.id,\n             span: self.span,\n         }))\n@@ -1664,7 +1664,7 @@ pub enum AssocTyConstraintKind {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,\n-    pub node: TyKind,\n+    pub kind: TyKind,\n     pub span: Span,\n }\n \n@@ -1823,9 +1823,9 @@ impl Param {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n-                return match self.ty.node {\n+                return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n+                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.kind.is_implicit_self() => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(\n@@ -1850,7 +1850,7 @@ impl Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n-            node: TyKind::ImplicitSelf,\n+            kind: TyKind::ImplicitSelf,\n             span,\n         });\n         let param = |mutbl, ty| Param {\n@@ -1872,7 +1872,7 @@ impl Param {\n                 Mutability::Immutable,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n-                    node: TyKind::Rptr(\n+                    kind: TyKind::Rptr(\n                         lt,\n                         MutTy {\n                             ty: infer_ty,"}, {"sha": "a009380841231e94e546f95a3a5aa29542842c70", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -568,7 +568,7 @@ impl DummyResult {\n     pub fn raw_ty(sp: Span, is_error: bool) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n             span: sp\n         })\n     }"}, {"sha": "98b434abea4f45ac7ad557e141ca0a2a3e29fddb", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -54,11 +54,11 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty> {\n+    pub fn ty(&self, span: Span, kind: ast::TyKind) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             span,\n-            node: ty\n+            kind,\n         })\n     }\n "}, {"sha": "98a4de4cfe94f7a1d41d2c91b86a9bf732af9ae4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1348,13 +1348,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::Mac(_) => {}\n             _ => return noop_visit_ty(ty, self),\n         };\n \n         visit_clobber(ty, |mut ty| {\n-            match mem::replace(&mut ty.node, ast::TyKind::Err) {\n+            match mem::replace(&mut ty.kind, ast::TyKind::Err) {\n                 ast::TyKind::Mac(mac) =>\n                     self.collect_bang(mac, ty.span, AstFragmentKind::Ty).make_ty(),\n                 _ => unreachable!(),"}, {"sha": "05b4985bb73ce4fc3db0a603480ced7a9771819a", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -34,7 +34,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     });\n     let ty = P(ast::Ty {\n         id,\n-        node: ast::TyKind::Mac(mac_placeholder()),\n+        kind: ast::TyKind::Mac(mac_placeholder()),\n         span,\n     });\n     let pat = P(ast::Pat {\n@@ -71,7 +71,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n             id, span, kind: ast::PatKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Ty => AstFragment::Ty(P(ast::Ty {\n-            id, span, node: ast::TyKind::Mac(mac_placeholder()),\n+            id, span, kind: ast::TyKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Stmts => AstFragment::Stmts(smallvec![{\n             let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ThinVec::new()));\n@@ -318,7 +318,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::Mac(_) => *ty = self.remove(ty.id).make_ty(),\n             _ => noop_visit_ty(ty, self),\n         }"}, {"sha": "1729ae7eae865d9ff89f1d587c0561193c0cec10", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -432,7 +432,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n                 self.check_abi(bare_fn_ty.abi, ty.span);\n             }\n@@ -447,7 +447,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n         if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n-            if let ast::TyKind::Never = output_ty.node {\n+            if let ast::TyKind::Never = output_ty.kind {\n                 // Do nothing.\n             } else {\n                 self.visit_ty(output_ty)"}, {"sha": "c08e154e0450783437df1f1f191d1ede436d6eb6", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -432,9 +432,9 @@ pub fn noop_visit_ty_constraint<T: MutVisitor>(\n }\n \n pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n-    let Ty { id, node, span } = ty.deref_mut();\n+    let Ty { id, kind, span } = ty.deref_mut();\n     vis.visit_id(id);\n-    match node {\n+    match kind {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err |\n             TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Slice(ty) => vis.visit_ty(ty),"}, {"sha": "62cb836e31ea6373931232ba46f102e01df7ee48", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -25,7 +25,7 @@ crate fn dummy_arg(ident: Ident) -> Param {\n         span: ident.span,\n     });\n     let ty = Ty {\n-        node: TyKind::Err,\n+        kind: TyKind::Err,\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n@@ -135,7 +135,7 @@ impl RecoverQPath for Ty {\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self {\n             span: path.span,\n-            node: TyKind::Path(qself, path),\n+            kind: TyKind::Path(qself, path),\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -663,7 +663,7 @@ impl<'a> Parser<'a> {\n             pprust::ty_to_string(ty)\n         );\n \n-        match ty.node {\n+        match ty.kind {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n@@ -1296,7 +1296,7 @@ impl<'a> Parser<'a> {\n         is_trait_item: bool,\n     ) -> PResult<'a, ast::Param> {\n         let sp = param.pat.span;\n-        param.ty.node = TyKind::Err;\n+        param.ty.kind = TyKind::Err;\n         let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n         if is_trait_item {\n             err.span_label(sp, \"must be the first associated function parameter\");\n@@ -1360,7 +1360,7 @@ impl<'a> Parser<'a> {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) = (\n-                &input.pat.kind, &input.ty.node,\n+                &input.pat.kind, &input.ty.kind,\n             ) {\n                 Some(*ident)\n             } else {"}, {"sha": "cc582819b6b6150a5ba60ae41253cde223e8b8cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -1212,7 +1212,7 @@ impl<'a> Parser<'a> {\n                 do_not_enforce_named_arguments_for_c_variadic\n             ) {\n                 Ok(param) => {\n-                    if let TyKind::CVarArgs = param.ty.node {\n+                    if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n                         if p.token != token::CloseDelim(token::Paren) {\n                             let span = p.token.span;"}, {"sha": "c776704b285aaad47a2124282776b01a0cd2f476", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -555,7 +555,7 @@ impl<'a> Parser<'a> {\n                         let span_after_type = parser_snapshot_after_type.token.span;\n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n-                            node: TyKind::Path(None, path),\n+                            kind: TyKind::Path(None, path),\n                             id: DUMMY_NODE_ID,\n                         }));\n \n@@ -1190,7 +1190,7 @@ impl<'a> Parser<'a> {\n         } else {\n             P(Ty {\n                 id: DUMMY_NODE_ID,\n-                node: TyKind::Infer,\n+                kind: TyKind::Infer,\n                 span: self.prev_span,\n             })\n         };"}, {"sha": "27b0325db12156ced926d9bb7f8dfaf2ccc98d8f", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -678,7 +678,7 @@ impl<'a> Parser<'a> {\n                           self.look_ahead(1, |t| t != &token::Lt) {\n             let span = self.prev_span.between(self.token.span);\n             self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n-            P(Ty { node: TyKind::Path(None, err_path(span)), span, id: DUMMY_NODE_ID })\n+            P(Ty { kind: TyKind::Path(None, err_path(span)), span, id: DUMMY_NODE_ID })\n         } else {\n             self.parse_ty()?\n         };\n@@ -715,7 +715,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let ty_first = ty_first.into_inner();\n-                let path = match ty_first.node {\n+                let path = match ty_first.kind {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n@@ -1526,7 +1526,7 @@ impl<'a> Parser<'a> {\n         // The user intended that the type be inferred,\n         // so treat this as if the user wrote e.g. `const A: _ = expr;`.\n         P(Ty {\n-            node: TyKind::Infer,\n+            kind: TyKind::Infer,\n             span: id.span,\n             id: ast::DUMMY_NODE_ID,\n         })"}, {"sha": "b4c006ca2b119e25534629393280de18760435ba", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -55,7 +55,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n-        let node = if self.eat(&token::OpenDelim(token::Paren)) {\n+        let kind = if self.eat(&token::OpenDelim(token::Paren)) {\n             // `(TYPE)` is a parenthesized type.\n             // `(TYPE,)` is a tuple with a single field of type TYPE.\n             let mut ts = vec![];\n@@ -75,7 +75,7 @@ impl<'a> Parser<'a> {\n             if ts.len() == 1 && !last_comma {\n                 let ty = ts.into_iter().nth(0).unwrap().into_inner();\n                 let maybe_bounds = allow_plus && self.token.is_like_plus();\n-                match ty.node {\n+                match ty.kind {\n                     // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                     TyKind::Path(None, ref path) if maybe_bounds => {\n                         self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n@@ -211,7 +211,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_span);\n-        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n+        let ty = P(Ty { kind, span, id: ast::DUMMY_NODE_ID });\n \n         // Try to recover from use of `+` with incorrect priority.\n         self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);"}, {"sha": "7eaaab9e70d84e6ca0a006e77a9dcaf3a02fb596", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -966,7 +966,7 @@ impl<'a> State<'a> {\n     crate fn print_type(&mut self, ty: &ast::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::Slice(ref ty) => {\n                 self.s.word(\"[\");\n                 self.print_type(ty);\n@@ -2760,7 +2760,7 @@ impl<'a> State<'a> {\n \n         self.print_outer_attributes_inline(&input.attrs);\n \n-        match input.ty.node {\n+        match input.ty.kind {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat),\n             _ => {\n                 if let Some(eself) = input.to_self() {"}, {"sha": "16616cf3185fd9611cd41d0dddb1ce9506ae77e5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -333,7 +333,7 @@ pub fn walk_field_pattern<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a FieldPat)\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n-    match typ.node {\n+    match typ.kind {\n         TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => {\n             visitor.visit_ty(ty)\n         }"}, {"sha": "f6747658c070e3af4825f4500ede0811cf942b4e", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -56,7 +56,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         fn make_ty(self: Box<Self>) -> Option<P<ast::Ty>> {\n             Some(P(ast::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n+                kind: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n             }))\n         }"}, {"sha": "b4306a1fd16ea3e7725b171a9a9c50764ec59b54", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -355,7 +355,7 @@ fn find_type_parameters(\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            if let ast::TyKind::Path(_, ref path) = ty.node {\n+            if let ast::TyKind::Path(_, ref path) = ty.kind {\n                 if let Some(segment) = path.segments.first() {\n                     if self.ty_param_names.contains(&segment.ident.name) {\n                         self.types.push(P(ty.clone()));\n@@ -612,7 +612,7 @@ impl<'a> TraitDef<'a> {\n \n                     for ty in tys {\n                         // if we have already handled this type, skip it\n-                        if let ast::TyKind::Path(_, ref p) = ty.node {\n+                        if let ast::TyKind::Path(_, ref p) = ty.kind {\n                             if p.segments.len() == 1 &&\n                                ty_param_names.contains(&p.segments[0].ident.name) {\n                                 continue;"}, {"sha": "a5d5ceb4b4fa12584c5d5c495306c5f786d907e1", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d8791373005ef08c876aa649ede245efd2352d/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=c3d8791373005ef08c876aa649ede245efd2352d", "patch": "@@ -285,7 +285,7 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n         // type implements the `Termination` trait as `libtest` enforces that.\n         let has_output = match decl.output {\n             ast::FunctionRetTy::Default(..) => false,\n-            ast::FunctionRetTy::Ty(ref t) if t.node.is_unit() => false,\n+            ast::FunctionRetTy::Ty(ref t) if t.kind.is_unit() => false,\n             _ => true\n         };\n "}]}