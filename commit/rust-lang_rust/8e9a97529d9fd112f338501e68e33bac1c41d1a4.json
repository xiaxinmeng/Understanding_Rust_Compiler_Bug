{"sha": "8e9a97529d9fd112f338501e68e33bac1c41d1a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOWE5NzUyOWQ5ZmQxMTJmMzM4NTAxZTY4ZTMzYmFjMWM0MWQxYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-23T17:31:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-23T17:31:19Z"}, "message": "Auto merge of #29530 - jseyfried:resolve, r=nikomatsakis\n\nReplace `TypeNsDef` and `ValueNsDef` with a more general type `NsDef`.\n\nDefine a newtype `NameBinding` for `Rc<RefCell<Option<NsDef>>>` and refactor `NameBindings` to be a `NameBinding` for each namespace.\n\nReplace uses of `NameBindings` with `NameBinding` where only one binding is being used (in `NamespaceResult`, `Target,` etc).\n\nRefactor away `resolve_definition_of_name_in_module` and `NameDefinition`, fixing issue #4952.", "tree": {"sha": "ece8bc6dc1f2f2f3048649fa96a1e315f88dcc37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ece8bc6dc1f2f2f3048649fa96a1e315f88dcc37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9a97529d9fd112f338501e68e33bac1c41d1a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9a97529d9fd112f338501e68e33bac1c41d1a4", "html_url": "https://github.com/rust-lang/rust/commit/8e9a97529d9fd112f338501e68e33bac1c41d1a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9a97529d9fd112f338501e68e33bac1c41d1a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69b8e74c31c5bc2a35c40cecbceffba773cdecbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/69b8e74c31c5bc2a35c40cecbceffba773cdecbf", "html_url": "https://github.com/rust-lang/rust/commit/69b8e74c31c5bc2a35c40cecbceffba773cdecbf"}, {"sha": "6a6e1dba55388bdf252e79eec2f084a45e0e862f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6e1dba55388bdf252e79eec2f084a45e0e862f", "html_url": "https://github.com/rust-lang/rust/commit/6a6e1dba55388bdf252e79eec2f084a45e0e862f"}], "stats": {"total": 1202, "additions": 377, "deletions": 825}, "files": [{"sha": "236d9cbe78cad8e87d10258eb8a1dd4388aaba9a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 78, "deletions": 252, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8e9a97529d9fd112f338501e68e33bac1c41d1a4", "patch": "@@ -18,18 +18,15 @@ use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n use resolve_imports::ImportResolution;\n use Module;\n-use ModuleKind::*;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n use {names_to_string, module_to_string};\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n-use TypeNsDef;\n use {resolve_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n-use self::NamespaceError::*;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n@@ -62,29 +59,12 @@ use std::rc::Rc;\n // another item exists with the same name in some namespace.\n #[derive(Copy, Clone, PartialEq)]\n enum DuplicateCheckingMode {\n-    ForbidDuplicateModules,\n-    ForbidDuplicateTypesAndModules,\n+    ForbidDuplicateTypes,\n     ForbidDuplicateValues,\n     ForbidDuplicateTypesAndValues,\n     OverwriteDuplicates,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum NamespaceError {\n-    NoError,\n-    ModuleError,\n-    TypeError,\n-    ValueError,\n-}\n-\n-fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n-    match ns {\n-        NoError => \"\",\n-        ModuleError | TypeError => \"type or module\",\n-        ValueError => \"value\",\n-    }\n-}\n-\n struct GraphBuilder<'a, 'b: 'a, 'tcx: 'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>,\n }\n@@ -106,121 +86,63 @@ impl<'a, 'b:'a, 'tcx:'b> DerefMut for GraphBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(self, krate: &hir::Crate) {\n-        let parent = self.graph_root.get_module();\n         let mut visitor = BuildReducedGraphVisitor {\n+            parent: self.graph_root.clone(),\n             builder: self,\n-            parent: parent,\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n     }\n \n-    /// Adds a new child item to the module definition of the parent node and\n-    /// returns its corresponding name bindings as well as the current parent.\n-    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n-    /// corresponding to the innermost block ID and returns the name bindings\n-    /// as well as the newly-created parent.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if this node does not have a module definition and we are not inside\n-    /// a block.\n+    /// Adds a new child item to the module definition of the parent node,\n+    /// or if there is already a child, does duplicate checking on the child.\n+    /// Returns the child's corresponding name bindings.\n     fn add_child(&self,\n                  name: Name,\n                  parent: &Rc<Module>,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: Span)\n-                 -> Rc<NameBindings> {\n-        // If this is the immediate descendant of a module, then we add the\n-        // child name directly. Otherwise, we create or reuse an anonymous\n-        // module and add the child to that.\n-\n+                 -> NameBindings {\n         self.check_for_conflicts_between_external_crates_and_items(&**parent, name, sp);\n \n         // Add or reuse the child.\n         let child = parent.children.borrow().get(&name).cloned();\n         match child {\n             None => {\n-                let child = Rc::new(NameBindings::new());\n+                let child = NameBindings::new();\n                 parent.children.borrow_mut().insert(name, child.clone());\n                 child\n             }\n             Some(child) => {\n                 // Enforce the duplicate checking mode:\n                 //\n-                // * If we're requesting duplicate module checking, check that\n-                //   there isn't a module in the module with the same name.\n-                //\n                 // * If we're requesting duplicate type checking, check that\n-                //   there isn't a type in the module with the same name.\n+                //   the name isn't defined in the type namespace.\n                 //\n                 // * If we're requesting duplicate value checking, check that\n-                //   there isn't a value in the module with the same name.\n+                //   the name isn't defined in the value namespace.\n                 //\n-                // * If we're requesting duplicate type checking and duplicate\n-                //   value checking, check that there isn't a duplicate type\n-                //   and a duplicate value with the same name.\n+                // * If we're requesting duplicate type and value checking,\n+                //   check that the name isn't defined in either namespace.\n                 //\n                 // * If no duplicate checking was requested at all, do\n                 //   nothing.\n \n-                let mut duplicate_type = NoError;\n                 let ns = match duplicate_checking_mode {\n-                    ForbidDuplicateModules => {\n-                        if child.get_module_if_available().is_some() {\n-                            duplicate_type = ModuleError;\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateTypesAndModules => {\n-                        if child.defined_in_namespace(TypeNS) {\n-                            duplicate_type = TypeError;\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateValues => {\n-                        if child.defined_in_namespace(ValueNS) {\n-                            duplicate_type = ValueError;\n-                        }\n-                        Some(ValueNS)\n-                    }\n-                    ForbidDuplicateTypesAndValues => {\n-                        let mut n = None;\n-                        match child.def_for_namespace(TypeNS) {\n-                            Some(DefMod(_)) | None => {}\n-                            Some(_) => {\n-                                n = Some(TypeNS);\n-                                duplicate_type = TypeError;\n-                            }\n-                        }\n-                        if child.defined_in_namespace(ValueNS) {\n-                            duplicate_type = ValueError;\n-                            n = Some(ValueNS);\n-                        }\n-                        n\n-                    }\n-                    OverwriteDuplicates => None,\n+                    ForbidDuplicateTypes if child.type_ns.defined() => TypeNS,\n+                    ForbidDuplicateValues if child.value_ns.defined() => ValueNS,\n+                    ForbidDuplicateTypesAndValues if child.type_ns.defined() => TypeNS,\n+                    ForbidDuplicateTypesAndValues if child.value_ns.defined() => ValueNS,\n+                    _ => return child,\n                 };\n-                if duplicate_type != NoError {\n-                    // Return an error here by looking up the namespace that\n-                    // had the duplicate.\n-                    let ns = ns.unwrap();\n-                    resolve_error(\n-                        self,\n-                        sp,\n-                        ResolutionError::DuplicateDefinition(\n-                            namespace_error_to_string(duplicate_type),\n-                            name)\n-                    );\n-                    {\n-                        let r = child.span_for_namespace(ns);\n-                        if let Some(sp) = r {\n-                            self.session.span_note(sp,\n-                                                   &format!(\"first definition of {} `{}` here\",\n-                                      namespace_error_to_string(duplicate_type),\n-                                      name));\n-                        }\n-                    }\n+\n+                // Record an error here by looking up the namespace that had the duplicate\n+                let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n+                resolve_error(self, sp, ResolutionError::DuplicateDefinition(ns_str, name));\n+\n+                if let Some(sp) = child[ns].span() {\n+                    let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n+                    self.session.span_note(sp, &note);\n                 }\n                 child\n             }\n@@ -395,11 +317,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n+                    let def = DefMod(def_id);\n+                    let external_module = Module::new(parent_link, Some(def), false, true);\n+\n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n                            module_to_string(&*external_module));\n                     self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n@@ -412,40 +332,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n \n             ItemMod(..) => {\n-                let child = parent.children.borrow().get(&name).cloned();\n-                if let Some(child) = child {\n-                    // check if there's struct of the same name already defined\n-                    if child.defined_in_namespace(TypeNS) &&\n-                       child.get_module_if_available().is_none() {\n-                        self.session.span_warn(sp,\n-                                               &format!(\"duplicate definition of {} `{}`. \\\n-                                                         Defining a module and a struct with \\\n-                                                         the same name will be disallowed soon.\",\n-                                                        namespace_error_to_string(TypeError),\n-                                                        name));\n-                        {\n-                            let r = child.span_for_namespace(TypeNS);\n-                            if let Some(sp) = r {\n-                                self.session.span_note(sp,\n-                                                       &format!(\"first definition of {} `{}` here\",\n-                                          namespace_error_to_string(TypeError),\n-                                          name));\n-                            }\n-                        }\n-                    }\n-                }\n-                let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateTypes, sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n-                let def_id = self.ast_map.local_def_id(item.id);\n-                name_bindings.define_module(parent_link,\n-                                            Some(def_id),\n-                                            NormalModuleKind,\n-                                            false,\n-                                            is_public,\n-                                            sp);\n-\n-                name_bindings.get_module()\n+                let def = DefMod(self.ast_map.local_def_id(item.id));\n+                let module = Module::new(parent_link, Some(def), false, is_public);\n+                name_bindings.define_module(module.clone(), sp);\n+                module\n             }\n \n             ItemForeignMod(..) => parent.clone(),\n@@ -477,42 +370,26 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemTy(..) => {\n                 let name_bindings = self.add_child(name,\n                                                    parent,\n-                                                   ForbidDuplicateTypesAndModules,\n+                                                   ForbidDuplicateTypes,\n                                                    sp);\n \n-                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false),\n-                                          sp,\n-                                          modifiers);\n-\n                 let parent_link = self.get_parent_link(parent, name);\n-                name_bindings.set_module_kind(parent_link,\n-                                              Some(self.ast_map.local_def_id(item.id)),\n-                                              TypeModuleKind,\n-                                              false,\n-                                              is_public,\n-                                              sp);\n+                let def = DefTy(self.ast_map.local_def_id(item.id), false);\n+                let module = Module::new(parent_link, Some(def), false, is_public);\n+                name_bindings.define_module(module, sp);\n                 parent.clone()\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n                 let name_bindings = self.add_child(name,\n                                                    parent,\n-                                                   ForbidDuplicateTypesAndModules,\n+                                                   ForbidDuplicateTypes,\n                                                    sp);\n \n-                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), true),\n-                                          sp,\n-                                          modifiers);\n-\n                 let parent_link = self.get_parent_link(parent, name);\n-                name_bindings.set_module_kind(parent_link,\n-                                              Some(self.ast_map.local_def_id(item.id)),\n-                                              EnumModuleKind,\n-                                              false,\n-                                              is_public,\n-                                              sp);\n-\n-                let module = name_bindings.get_module();\n+                let def = DefTy(self.ast_map.local_def_id(item.id), true);\n+                let module = Module::new(parent_link, Some(def), false, is_public);\n+                name_bindings.define_module(module.clone(), sp);\n \n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n@@ -525,31 +402,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemStruct(ref struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n                 let (forbid, ctor_id) = if struct_def.is_struct() {\n-                    (ForbidDuplicateTypesAndModules, None)\n+                    (ForbidDuplicateTypes, None)\n                 } else {\n-                    let child = parent.children.borrow().get(&name).cloned();\n-                    if let Some(child) = child {\n-                        // check if theres a DefMod\n-                        if let Some(DefMod(_)) = child.def_for_namespace(TypeNS) {\n-                            self.session.span_warn(sp,\n-                                                   &format!(\"duplicate definition of {} `{}`. \\\n-                                                             Defining a module and a struct \\\n-                                                             with the same name will be \\\n-                                                             disallowed soon.\",\n-                                                            namespace_error_to_string(TypeError),\n-                                                            name));\n-                            {\n-                                let r = child.span_for_namespace(TypeNS);\n-                                if let Some(sp) = r {\n-                                    self.session\n-                                        .span_note(sp,\n-                                                   &format!(\"first definition of {} `{}` here\",\n-                                                            namespace_error_to_string(TypeError),\n-                                                            name));\n-                                }\n-                            }\n-                        }\n-                    }\n                     (ForbidDuplicateTypesAndValues, Some(struct_def.id()))\n                 };\n \n@@ -590,20 +444,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemTrait(_, _, _, ref items) => {\n                 let name_bindings = self.add_child(name,\n                                                    parent,\n-                                                   ForbidDuplicateTypesAndModules,\n+                                                   ForbidDuplicateTypes,\n                                                    sp);\n \n+                let def_id = self.ast_map.local_def_id(item.id);\n+\n                 // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent, name);\n-                name_bindings.define_module(parent_link,\n-                                            Some(self.ast_map.local_def_id(item.id)),\n-                                            TraitModuleKind,\n-                                            false,\n-                                            is_public,\n-                                            sp);\n-                let module_parent = name_bindings.get_module();\n-\n-                let def_id = self.ast_map.local_def_id(item.id);\n+                let def = DefTrait(def_id);\n+                let module_parent = Module::new(parent_link, Some(def), false, is_public);\n+                name_bindings.define_module(module_parent.clone(), sp);\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n@@ -635,7 +485,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n                 }\n \n-                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n                 parent.clone()\n             }\n         }\n@@ -704,11 +553,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     {}\",\n                    block_id);\n \n-            let new_module = Rc::new(Module::new(BlockParentLink(Rc::downgrade(parent), block_id),\n-                                                 None,\n-                                                 AnonymousModuleKind,\n-                                                 false,\n-                                                 false));\n+            let parent_link = BlockParentLink(Rc::downgrade(parent), block_id);\n+            let new_module = Module::new(parent_link, None, false, false);\n             parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n             new_module\n         } else {\n@@ -733,45 +579,29 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n         let is_exported = is_public &&\n-                          match new_parent.def_id.get() {\n+                          match new_parent.def_id() {\n             None => true,\n             Some(did) => self.external_exports.contains(&did),\n         };\n         if is_exported {\n             self.external_exports.insert(def.def_id());\n         }\n \n-        let kind = match def {\n-            DefTy(_, true) => EnumModuleKind,\n-            DefTy(_, false) | DefStruct(..) => TypeModuleKind,\n-            _ => NormalModuleKind,\n-        };\n-\n         match def {\n-            DefMod(def_id) |\n-            DefForeignMod(def_id) |\n-            DefStruct(def_id) |\n-            DefTy(def_id, _) => {\n-                let type_def = child_name_bindings.type_def.borrow().clone();\n-                match type_def {\n-                    Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n-                        debug!(\"(building reduced graph for external crate) already created \\\n-                                module\");\n-                        module_def.def_id.set(Some(def_id));\n-                    }\n-                    Some(_) | None => {\n-                        debug!(\"(building reduced graph for external crate) building module {} {}\",\n-                               final_ident,\n-                               is_public);\n-                        let parent_link = self.get_parent_link(new_parent, name);\n-\n-                        child_name_bindings.define_module(parent_link,\n-                                                          Some(def_id),\n-                                                          kind,\n-                                                          true,\n-                                                          is_public,\n-                                                          DUMMY_SP);\n-                    }\n+            DefMod(_) |\n+            DefForeignMod(_) |\n+            DefStruct(_) |\n+            DefTy(..) => {\n+                if let Some(module_def) = child_name_bindings.type_ns.module() {\n+                    debug!(\"(building reduced graph for external crate) already created module\");\n+                    module_def.def.set(Some(def));\n+                } else {\n+                    debug!(\"(building reduced graph for external crate) building module {} {}\",\n+                           final_ident,\n+                           is_public);\n+                    let parent_link = self.get_parent_link(new_parent, name);\n+                    let module = Module::new(parent_link, Some(def), true, is_public);\n+                    child_name_bindings.define_module(module, DUMMY_SP);\n                 }\n             }\n             _ => {}\n@@ -807,12 +637,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                        final_ident);\n                 // impl methods have already been defined with the correct importability\n                 // modifier\n-                let mut modifiers = match *child_name_bindings.value_def.borrow() {\n+                let mut modifiers = match *child_name_bindings.value_ns.borrow() {\n                     Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n                                      (def.modifiers & DefModifiers::IMPORTABLE),\n                     None => modifiers,\n                 };\n-                if new_parent.kind.get() != NormalModuleKind {\n+                if !new_parent.is_normal() {\n                     modifiers = modifiers & !DefModifiers::IMPORTABLE;\n                 }\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n@@ -841,33 +671,30 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-\n                 // Define a module if necessary.\n                 let parent_link = self.get_parent_link(new_parent, name);\n-                child_name_bindings.set_module_kind(parent_link,\n-                                                    Some(def_id),\n-                                                    TraitModuleKind,\n-                                                    true,\n-                                                    is_public,\n-                                                    DUMMY_SP)\n+                let module = Module::new(parent_link, Some(def), true, is_public);\n+                child_name_bindings.define_module(module, DUMMY_SP);\n             }\n             DefTy(..) | DefAssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\",\n                        final_ident);\n \n-                let modifiers = match new_parent.kind.get() {\n-                    NormalModuleKind => modifiers,\n+                let modifiers = match new_parent.is_normal() {\n+                    true => modifiers,\n                     _ => modifiers & !DefModifiers::IMPORTABLE,\n                 };\n \n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                if let DefTy(..) = def {\n+                    child_name_bindings.type_ns.set_modifiers(modifiers);\n+                } else {\n+                    child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                }\n             }\n             DefStruct(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type and value for \\\n                         {}\",\n                        final_ident);\n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                 let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n \n                 if fields.is_empty() {\n@@ -922,7 +749,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                         self.handle_external_def(def,\n                                                  def_visibility,\n-                                                 &*child_name_bindings,\n+                                                 &child_name_bindings,\n                                                  &name.as_str(),\n                                                  name,\n                                                  root);\n@@ -943,7 +770,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         debug!(\"(populating external module) attempting to populate {}\",\n                module_to_string(&**module));\n \n-        let def_id = match module.def_id.get() {\n+        let def_id = match module.def_id() {\n             None => {\n                 debug!(\"(populating external module) ... no def ID!\");\n                 return;\n@@ -977,8 +804,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n         csearch::each_top_level_item_of_crate(&self.session.cstore,\n-                                              root.def_id\n-                                                  .get()\n+                                              root.def_id()\n                                                   .unwrap()\n                                                   .krate,\n                                               |def_like, name, visibility| {"}, {"sha": "51d7ceb946dae2920d2a3307c42093e7de7aa1cf", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 233, "deletions": 496, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8e9a97529d9fd112f338501e68e33bac1c41d1a4", "patch": "@@ -39,7 +39,6 @@ extern crate rustc;\n use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::NamespaceResult::*;\n-use self::NameDefinition::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -50,7 +49,6 @@ use self::AssocItemResolveResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n-use self::ModuleKind::*;\n use self::FallbackChecks::*;\n \n use rustc::front::map as hir_map;\n@@ -518,8 +516,8 @@ enum NamespaceResult {\n     /// not bound in the namespace.\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n-    /// argument, and specified by the NameBindings argument.\n-    BoundResult(Rc<Module>, Rc<NameBindings>),\n+    /// argument, and specified by the NameBinding argument.\n+    BoundResult(Rc<Module>, NameBinding),\n }\n \n impl NamespaceResult {\n@@ -537,15 +535,6 @@ impl NamespaceResult {\n     }\n }\n \n-enum NameDefinition {\n-    // The name was unbound.\n-    NoNameDefinition,\n-    // The name identifies an immediate child.\n-    ChildNameDefinition(Def, LastPrivate),\n-    // The name identifies an import.\n-    ImportNameDefinition(Def, LastPrivate),\n-}\n-\n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n         self.visit_item(self.ast_map.expect_item(item.id))\n@@ -777,24 +766,13 @@ enum ParentLink {\n     BlockParentLink(Weak<Module>, NodeId),\n }\n \n-/// The type of module this is.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum ModuleKind {\n-    NormalModuleKind,\n-    TraitModuleKind,\n-    EnumModuleKind,\n-    TypeModuleKind,\n-    AnonymousModuleKind,\n-}\n-\n /// One node in the tree of modules.\n pub struct Module {\n     parent_link: ParentLink,\n-    def_id: Cell<Option<DefId>>,\n-    kind: Cell<ModuleKind>,\n+    def: Cell<Option<Def>>,\n     is_public: bool,\n \n-    children: RefCell<HashMap<Name, Rc<NameBindings>>>,\n+    children: RefCell<HashMap<Name, NameBindings>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The external module children of this node that were declared with\n@@ -840,15 +818,13 @@ pub struct Module {\n \n impl Module {\n     fn new(parent_link: ParentLink,\n-           def_id: Option<DefId>,\n-           kind: ModuleKind,\n+           def: Option<Def>,\n            external: bool,\n            is_public: bool)\n-           -> Module {\n-        Module {\n+           -> Rc<Module> {\n+        Rc::new(Module {\n             parent_link: parent_link,\n-            def_id: Cell::new(def_id),\n-            kind: Cell::new(kind),\n+            def: Cell::new(def),\n             is_public: is_public,\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n@@ -860,6 +836,24 @@ impl Module {\n             pub_glob_count: Cell::new(0),\n             resolved_import_count: Cell::new(0),\n             populated: Cell::new(!external),\n+        })\n+    }\n+\n+    fn def_id(&self) -> Option<DefId> {\n+        self.def.get().as_ref().map(Def::def_id)\n+    }\n+\n+    fn is_normal(&self) -> bool {\n+        match self.def.get() {\n+            Some(DefMod(_)) | Some(DefForeignMod(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_trait(&self) -> bool {\n+        match self.def.get() {\n+            Some(DefTrait(_)) => true,\n+            _ => false,\n         }\n     }\n \n@@ -900,9 +894,8 @@ impl Module {\n impl fmt::Debug for Module {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,\n-               \"{:?}, kind: {:?}, {}\",\n-               self.def_id,\n-               self.kind,\n+               \"{:?}, {}\",\n+               self.def,\n                if self.is_public {\n                    \"public\"\n                } else {\n@@ -919,263 +912,155 @@ bitflags! {\n     }\n }\n \n-// Records a possibly-private type definition.\n-#[derive(Clone,Debug)]\n-struct TypeNsDef {\n-    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n-    module_def: Option<Rc<Module>>,\n-    type_def: Option<Def>,\n-    type_span: Option<Span>,\n-}\n-\n-// Records a possibly-private value definition.\n-#[derive(Clone, Copy, Debug)]\n-struct ValueNsDef {\n+// Records a possibly-private value, type, or module definition.\n+#[derive(Debug)]\n+struct NsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n-    def: Def,\n-    value_span: Option<Span>,\n+    def_or_module: DefOrModule,\n+    span: Option<Span>,\n }\n \n-// Records the definitions (at most one for each namespace) that a name is\n-// bound to.\n #[derive(Debug)]\n-pub struct NameBindings {\n-    type_def: RefCell<Option<TypeNsDef>>, // < Meaning in type namespace.\n-    value_def: RefCell<Option<ValueNsDef>>, // < Meaning in value namespace.\n+enum DefOrModule {\n+    Def(Def),\n+    Module(Rc<Module>),\n }\n \n-impl NameBindings {\n-    fn new() -> NameBindings {\n-        NameBindings {\n-            type_def: RefCell::new(None),\n-            value_def: RefCell::new(None),\n-        }\n-    }\n-\n-    /// Creates a new module in this set of name bindings.\n-    fn define_module(&self,\n-                     parent_link: ParentLink,\n-                     def_id: Option<DefId>,\n-                     kind: ModuleKind,\n-                     external: bool,\n-                     is_public: bool,\n-                     sp: Span) {\n-        // Merges the module with the existing type def or creates a new one.\n-        let modifiers = if is_public {\n+impl NsDef {\n+    fn create_from_module(module: Rc<Module>, span: Option<Span>) -> Self {\n+        let modifiers = if module.is_public {\n             DefModifiers::PUBLIC\n         } else {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n-        let module_ = Rc::new(Module::new(parent_link, def_id, kind, external, is_public));\n-        let type_def = self.type_def.borrow().clone();\n-        match type_def {\n-            None => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    modifiers: modifiers,\n-                    module_def: Some(module_),\n-                    type_def: None,\n-                    type_span: Some(sp),\n-                });\n-            }\n-            Some(type_def) => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    modifiers: modifiers,\n-                    module_def: Some(module_),\n-                    type_span: Some(sp),\n-                    type_def: type_def.type_def,\n-                });\n-            }\n-        }\n+\n+        NsDef { modifiers: modifiers, def_or_module: DefOrModule::Module(module), span: span }\n     }\n \n-    /// Sets the kind of the module, creating a new one if necessary.\n-    fn set_module_kind(&self,\n-                       parent_link: ParentLink,\n-                       def_id: Option<DefId>,\n-                       kind: ModuleKind,\n-                       external: bool,\n-                       is_public: bool,\n-                       _sp: Span) {\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n-        let type_def = self.type_def.borrow().clone();\n-        match type_def {\n-            None => {\n-                let module = Module::new(parent_link, def_id, kind, external, is_public);\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    modifiers: modifiers,\n-                    module_def: Some(Rc::new(module)),\n-                    type_def: None,\n-                    type_span: None,\n-                });\n-            }\n-            Some(type_def) => {\n-                match type_def.module_def {\n-                    None => {\n-                        let module = Module::new(parent_link, def_id, kind, external, is_public);\n-                        *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                            modifiers: modifiers,\n-                            module_def: Some(Rc::new(module)),\n-                            type_def: type_def.type_def,\n-                            type_span: None,\n-                        });\n-                    }\n-                    Some(module_def) => module_def.kind.set(kind),\n-                }\n-            }\n+    fn create_from_def(def: Def, modifiers: DefModifiers, span: Option<Span>) -> Self {\n+        NsDef { modifiers: modifiers, def_or_module: DefOrModule::Def(def), span: span }\n+    }\n+\n+    fn module(&self) -> Option<Rc<Module>> {\n+        match self.def_or_module {\n+            DefOrModule::Module(ref module) => Some(module.clone()),\n+            DefOrModule::Def(_) => None,\n         }\n     }\n \n-    /// Records a type definition.\n-    fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining type for def {:?} with modifiers {:?}\",\n-               def,\n-               modifiers);\n-        // Merges the type with the existing type def or creates a new one.\n-        let type_def = self.type_def.borrow().clone();\n-        match type_def {\n-            None => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    module_def: None,\n-                    type_def: Some(def),\n-                    type_span: Some(sp),\n-                    modifiers: modifiers,\n-                });\n-            }\n-            Some(type_def) => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    module_def: type_def.module_def,\n-                    type_def: Some(def),\n-                    type_span: Some(sp),\n-                    modifiers: modifiers,\n-                });\n-            }\n+    fn def(&self) -> Option<Def> {\n+        match self.def_or_module {\n+            DefOrModule::Def(def) => Some(def),\n+            DefOrModule::Module(ref module) => module.def.get(),\n         }\n     }\n+}\n \n-    /// Records a value definition.\n-    fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {:?} with modifiers {:?}\",\n-               def,\n-               modifiers);\n-        *self.value_def.borrow_mut() = Some(ValueNsDef {\n-            def: def,\n-            value_span: Some(sp),\n-            modifiers: modifiers,\n-        });\n+// Records at most one definition that a name in a namespace is bound to\n+#[derive(Clone,Debug)]\n+pub struct NameBinding(Rc<RefCell<Option<NsDef>>>);\n+\n+impl NameBinding {\n+    fn new() -> Self {\n+        NameBinding(Rc::new(RefCell::new(None)))\n     }\n \n-    /// Returns the module node if applicable.\n-    fn get_module_if_available(&self) -> Option<Rc<Module>> {\n-        match *self.type_def.borrow() {\n-            Some(ref type_def) => type_def.module_def.clone(),\n-            None => None,\n-        }\n+    fn create_from_module(module: Rc<Module>) -> Self {\n+        NameBinding(Rc::new(RefCell::new(Some(NsDef::create_from_module(module, None)))))\n     }\n \n-    /// Returns the module node. Panics if this node does not have a module\n-    /// definition.\n-    fn get_module(&self) -> Rc<Module> {\n-        match self.get_module_if_available() {\n-            None => {\n-                panic!(\"get_module called on a node with no module definition!\")\n-            }\n-            Some(module_def) => module_def,\n-        }\n+    fn set(&self, ns_def: NsDef) {\n+        *self.0.borrow_mut() = Some(ns_def);\n     }\n \n-    fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n-        match namespace {\n-            TypeNS => return self.type_def.borrow().is_some(),\n-            ValueNS => return self.value_def.borrow().is_some(),\n+    fn set_modifiers(&self, modifiers: DefModifiers) {\n+        if let Some(ref mut ns_def) = *self.0.borrow_mut() {\n+            ns_def.modifiers = modifiers\n         }\n     }\n \n-    fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n-        self.defined_in_namespace_with(namespace, DefModifiers::PUBLIC)\n+    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef>> {\n+        self.0.borrow()\n     }\n \n-    fn defined_in_namespace_with(&self, namespace: Namespace, modifiers: DefModifiers) -> bool {\n-        match namespace {\n-            TypeNS => match *self.type_def.borrow() {\n-                Some(ref def) => def.modifiers.contains(modifiers),\n-                None => false,\n-            },\n-            ValueNS => match *self.value_def.borrow() {\n-                Some(ref def) => def.modifiers.contains(modifiers),\n-                None => false,\n-            },\n-        }\n+    // Lifted versions of the NsDef methods and fields\n+    fn def(&self) -> Option<Def> {\n+        self.borrow().as_ref().and_then(NsDef::def)\n+    }\n+    fn module(&self) -> Option<Rc<Module>> {\n+        self.borrow().as_ref().and_then(NsDef::module)\n+    }\n+    fn span(&self) -> Option<Span> {\n+        self.borrow().as_ref().and_then(|def| def.span)\n+    }\n+    fn modifiers(&self) -> Option<DefModifiers> {\n+        self.borrow().as_ref().and_then(|def| Some(def.modifiers))\n     }\n \n-    fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n-        match namespace {\n-            TypeNS => {\n-                match *self.type_def.borrow() {\n-                    None => None,\n-                    Some(ref type_def) => {\n-                        match type_def.type_def {\n-                            Some(type_def) => Some(type_def),\n-                            None => {\n-                                match type_def.module_def {\n-                                    Some(ref module) => {\n-                                        match module.def_id.get() {\n-                                            Some(did) => Some(DefMod(did)),\n-                                            None => None,\n-                                        }\n-                                    }\n-                                    None => None,\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            ValueNS => {\n-                match *self.value_def.borrow() {\n-                    None => None,\n-                    Some(value_def) => Some(value_def.def),\n-                }\n-            }\n-        }\n+    fn defined(&self) -> bool {\n+        self.borrow().is_some()\n     }\n \n-    fn span_for_namespace(&self, namespace: Namespace) -> Option<Span> {\n-        if self.defined_in_namespace(namespace) {\n-            match namespace {\n-                TypeNS => {\n-                    match *self.type_def.borrow() {\n-                        None => None,\n-                        Some(ref type_def) => type_def.type_span,\n-                    }\n-                }\n-                ValueNS => {\n-                    match *self.value_def.borrow() {\n-                        None => None,\n-                        Some(ref value_def) => value_def.value_span,\n-                    }\n-                }\n-            }\n-        } else {\n-            None\n+    fn defined_with(&self, modifiers: DefModifiers) -> bool {\n+        self.modifiers().map(|m| m.contains(modifiers)).unwrap_or(false)\n+    }\n+\n+    fn is_public(&self) -> bool {\n+        self.defined_with(DefModifiers::PUBLIC)\n+    }\n+\n+    fn def_and_lp(&self) -> (Def, LastPrivate) {\n+        let def = self.def().unwrap();\n+        (def, LastMod(if self.is_public() { AllPublic } else { DependsOn(def.def_id()) }))\n+    }\n+}\n+\n+// Records the definitions (at most one for each namespace) that a name is\n+// bound to.\n+#[derive(Clone,Debug)]\n+pub struct NameBindings {\n+    type_ns: NameBinding, // < Meaning in type namespace.\n+    value_ns: NameBinding, // < Meaning in value namespace.\n+}\n+\n+impl ::std::ops::Index<Namespace> for NameBindings {\n+    type Output = NameBinding;\n+    fn index(&self, namespace: Namespace) -> &NameBinding {\n+        match namespace { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n+    }\n+}\n+\n+impl NameBindings {\n+    fn new() -> NameBindings {\n+        NameBindings {\n+            type_ns: NameBinding::new(),\n+            value_ns: NameBinding::new(),\n         }\n     }\n \n-    fn is_public(&self, namespace: Namespace) -> bool {\n-        match namespace {\n-            TypeNS => {\n-                let type_def = self.type_def.borrow();\n-                type_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n-            }\n-            ValueNS => {\n-                let value_def = self.value_def.borrow();\n-                value_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n-            }\n+    fn create_from_module(module: Rc<Module>) -> NameBindings {\n+        NameBindings {\n+            type_ns: NameBinding::create_from_module(module),\n+            value_ns: NameBinding::new(),\n         }\n     }\n+\n+    /// Creates a new module in this set of name bindings.\n+    fn define_module(&self, module: Rc<Module>, sp: Span) {\n+        self.type_ns.set(NsDef::create_from_module(module, Some(sp)));\n+    }\n+\n+    /// Records a type definition.\n+    fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n+        debug!(\"defining type for def {:?} with modifiers {:?}\", def, modifiers);\n+        self.type_ns.set(NsDef::create_from_def(def, modifiers, Some(sp)));\n+    }\n+\n+    /// Records a value definition.\n+    fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n+        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n+        self.value_ns.set(NsDef::create_from_def(def, modifiers, Some(sp)));\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1217,7 +1102,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n     ast_map: &'a hir_map::Map<'tcx>,\n \n-    graph_root: NameBindings,\n+    graph_root: Rc<Module>,\n \n     trait_item_map: FnvHashMap<(Name, DefId), DefId>,\n \n@@ -1284,20 +1169,10 @@ enum FallbackChecks {\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a hir_map::Map<'tcx>,\n-           crate_span: Span,\n            make_glob_map: MakeGlobMap)\n            -> Resolver<'a, 'tcx> {\n-        let graph_root = NameBindings::new();\n-\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        graph_root.define_module(NoParentLink,\n-                                 Some(root_def_id),\n-                                 NormalModuleKind,\n-                                 false,\n-                                 true,\n-                                 crate_span);\n-\n-        let current_module = graph_root.get_module();\n+        let graph_root = Module::new(NoParentLink, Some(DefMod(root_def_id)), false, true);\n \n         Resolver {\n             session: session,\n@@ -1306,14 +1181,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n-            graph_root: graph_root,\n+            graph_root: graph_root.clone(),\n \n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n \n             unresolved_imports: 0,\n \n-            current_module: current_module,\n+            current_module: graph_root,\n             value_ribs: Vec::new(),\n             type_ribs: Vec::new(),\n             label_ribs: Vec::new(),\n@@ -1364,18 +1239,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n-        NameBindings {\n-            type_def: RefCell::new(Some(TypeNsDef {\n-                modifiers: DefModifiers::IMPORTABLE,\n-                module_def: Some(module),\n-                type_def: None,\n-                type_span: None,\n-            })),\n-            value_def: RefCell::new(None),\n-        }\n-    }\n-\n     /// Checks that the names of external crates don't collide with other\n     /// external crates.\n     fn check_for_conflicts_between_external_crates(&self,\n@@ -1481,38 +1344,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Success((target, used_proxy)) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    match *target.bindings.type_def.borrow() {\n-                        Some(ref type_def) => {\n-                            match type_def.module_def {\n-                                None => {\n-                                    let msg = format!(\"Not a module `{}`\", name);\n-\n-                                    return Failed(Some((span, msg)));\n-                                }\n-                                Some(ref module_def) => {\n-                                    search_module = module_def.clone();\n+                    if let Some(module_def) = target.binding.module() {\n+                        // track extern crates for unused_extern_crate lint\n+                        if let Some(did) = module_def.def_id() {\n+                            self.used_crates.insert(did.krate);\n+                        }\n \n-                                    // track extern crates for unused_extern_crate lint\n-                                    if let Some(did) = module_def.def_id.get() {\n-                                        self.used_crates.insert(did.krate);\n-                                    }\n+                        search_module = module_def;\n \n-                                    // Keep track of the closest\n-                                    // private module used when\n-                                    // resolving this import chain.\n-                                    if !used_proxy && !search_module.is_public {\n-                                        if let Some(did) = search_module.def_id.get() {\n-                                            closest_private = LastMod(DependsOn(did));\n-                                        }\n-                                    }\n-                                }\n+                        // Keep track of the closest private module used\n+                        // when resolving this import chain.\n+                        if !used_proxy && !search_module.is_public {\n+                            if let Some(did) = search_module.def_id() {\n+                                closest_private = LastMod(DependsOn(did));\n                             }\n                         }\n-                        None => {\n-                            // There are no type bindings at all.\n-                            let msg = format!(\"Not a module `{}`\", name);\n-                            return Failed(Some((span, msg)));\n-                        }\n+                    } else {\n+                        let msg = format!(\"Not a module `{}`\", name);\n+                        return Failed(Some((span, msg)));\n                     }\n                 }\n             }\n@@ -1579,7 +1428,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     DontUseLexicalScope => {\n                         // This is a crate-relative path. We will start the\n                         // resolution process at index zero.\n-                        search_module = self.graph_root.get_module();\n+                        search_module = self.graph_root.clone();\n                         start_index = 0;\n                         last_private = LastMod(AllPublic);\n                     }\n@@ -1605,8 +1454,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success(PrefixFound(ref containing_module, index)) => {\n                 search_module = containing_module.clone();\n                 start_index = index;\n-                last_private = LastMod(DependsOn(containing_module.def_id\n-                                                                  .get()\n+                last_private = LastMod(DependsOn(containing_module.def_id()\n                                                                   .unwrap()));\n             }\n         }\n@@ -1636,10 +1484,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n-            Some(name_bindings) if name_bindings.defined_in_namespace(namespace) => {\n+            Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"top name bindings succeeded\");\n                 return Success((Target::new(module_.clone(),\n-                                            name_bindings.clone(),\n+                                            name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n             }\n@@ -1666,7 +1514,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let id = import_resolution.id(namespace);\n                     self.used_imports.insert((id, namespace));\n                     self.record_import_use(id, name);\n-                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n                         self.used_crates.insert(kid);\n                     }\n                     return Success((target, false));\n@@ -1679,9 +1527,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // FIXME (21114): In principle unclear `child` *has* to be lifted.\n             let child = module_.external_module_children.borrow().get(&name).cloned();\n             if let Some(module) = child {\n-                let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module));\n+                let name_binding = NameBinding::create_from_module(module);\n                 debug!(\"lower name bindings succeeded\");\n-                return Success((Target::new(module_, name_bindings, Shadowable::Never),\n+                return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -1697,19 +1545,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     return Failed(None);\n                 }\n                 ModuleParentLink(parent_module_node, _) => {\n-                    match search_module.kind.get() {\n-                        NormalModuleKind => {\n-                            // We stop the search here.\n-                            debug!(\"(resolving item in lexical scope) unresolved module: not \\\n-                                    searching through module parents\");\n+                    if search_module.is_normal() {\n+                        // We stop the search here.\n+                        debug!(\"(resolving item in lexical scope) unresolved module: not \\\n+                                searching through module parents\");\n                             return Failed(None);\n-                        }\n-                        TraitModuleKind |\n-                        EnumModuleKind |\n-                        TypeModuleKind |\n-                        AnonymousModuleKind => {\n-                            search_module = parent_module_node.upgrade().unwrap();\n-                        }\n+                    } else {\n+                        search_module = parent_module_node.upgrade().unwrap();\n                     }\n                 }\n                 BlockParentLink(ref parent_module_node, _) => {\n@@ -1753,26 +1595,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS);\n         match resolve_result {\n             Success((target, _)) => {\n-                let bindings = &*target.bindings;\n-                match *bindings.type_def.borrow() {\n-                    Some(ref type_def) => {\n-                        match type_def.module_def {\n-                            None => {\n-                                debug!(\"!!! (resolving module in lexical scope) module wasn't \\\n-                                        actually a module!\");\n-                                return Failed(None);\n-                            }\n-                            Some(ref module_def) => {\n-                                return Success(module_def.clone());\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        debug!(\"!!! (resolving module in lexical scope) module\n-                                \\\n-                                wasn't actually a module!\");\n-                        return Failed(None);\n-                    }\n+                if let Some(module_def) = target.binding.module() {\n+                    return Success(module_def)\n+                } else {\n+                    debug!(\"!!! (resolving module in lexical scope) module \\\n+                            wasn't actually a module!\");\n+                    return Failed(None);\n                 }\n             }\n             Indeterminate => {\n@@ -1795,13 +1623,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 ModuleParentLink(new_module, _) |\n                 BlockParentLink(new_module, _) => {\n                     let new_module = new_module.upgrade().unwrap();\n-                    match new_module.kind.get() {\n-                        NormalModuleKind => return Some(new_module),\n-                        TraitModuleKind |\n-                        EnumModuleKind |\n-                        TypeModuleKind |\n-                        AnonymousModuleKind => module_ = new_module,\n+                    if new_module.is_normal() {\n+                        return Some(new_module);\n                     }\n+                    module_ = new_module;\n                 }\n             }\n         }\n@@ -1810,17 +1635,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n     fn get_nearest_normal_module_parent_or_self(&mut self, module_: Rc<Module>) -> Rc<Module> {\n-        match module_.kind.get() {\n-            NormalModuleKind => return module_,\n-            TraitModuleKind |\n-            EnumModuleKind |\n-            TypeModuleKind |\n-            AnonymousModuleKind => {\n-                match self.get_nearest_normal_module_parent(module_.clone()) {\n-                    None => module_,\n-                    Some(new_module) => new_module,\n-                }\n-            }\n+        if module_.is_normal() {\n+            return module_;\n+        }\n+        match self.get_nearest_normal_module_parent(module_.clone()) {\n+            None => module_,\n+            Some(new_module) => new_module,\n         }\n     }\n \n@@ -1880,10 +1700,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n-            Some(name_bindings) if name_bindings.defined_in_namespace(namespace) => {\n+            Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"(resolving name in module) found node as child\");\n                 return Success((Target::new(module_.clone(),\n-                                            name_bindings.clone(),\n+                                            name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n             }\n@@ -1919,7 +1739,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let id = import_resolution.id(namespace);\n                         self.used_imports.insert((id, namespace));\n                         self.record_import_use(id, name);\n-                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n                             self.used_crates.insert(kid);\n                         }\n                         return Success((target, true));\n@@ -1934,8 +1754,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // FIXME (21114): In principle unclear `child` *has* to be lifted.\n             let child = module_.external_module_children.borrow().get(&name).cloned();\n             if let Some(module) = child {\n-                let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module));\n-                return Success((Target::new(module_, name_bindings, Shadowable::Never),\n+                let name_binding = NameBinding::create_from_module(module);\n+                return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -1959,7 +1779,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         for (_, child_node) in module_.children.borrow().iter() {\n-            match child_node.get_module_if_available() {\n+            match child_node.type_ns.module() {\n                 None => {\n                     // Continue.\n                 }\n@@ -2012,7 +1832,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n-                        match (*name_bindings).get_module_if_available() {\n+                        match name_bindings.type_ns.module() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n                                        name,\n@@ -2967,32 +2787,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n-                       target.bindings.value_def.borrow());\n-                match *target.bindings.value_def.borrow() {\n+                       target.binding.borrow());\n+                match target.binding.def() {\n                     None => {\n                         panic!(\"resolved name in the value namespace to a set of name bindings \\\n                                 with no def?!\");\n                     }\n-                    Some(def) => {\n-                        // For the two success cases, this lookup can be\n-                        // considered as not having a private component because\n-                        // the lookup happened only within the current module.\n-                        match def.def {\n-                            def @ DefVariant(..) | def @ DefStruct(..) => {\n-                                return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n-                            }\n-                            def @ DefConst(..) | def @ DefAssociatedConst(..) => {\n-                                return FoundConst(def, LastMod(AllPublic), name);\n-                            }\n-                            DefStatic(..) => {\n-                                resolve_error(self, span, ResolutionError::StaticVariableReference);\n-                                return BareIdentifierPatternUnresolved;\n-                            }\n-                            _ => {\n-                                return BareIdentifierPatternUnresolved;\n-                            }\n-                        }\n+                    // For the two success cases, this lookup can be\n+                    // considered as not having a private component because\n+                    // the lookup happened only within the current module.\n+                    Some(def @ DefVariant(..)) | Some(def @ DefStruct(..)) => {\n+                        return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n+                    }\n+                    Some(def @ DefConst(..)) | Some(def @ DefAssociatedConst(..)) => {\n+                        return FoundConst(def, LastMod(AllPublic), name);\n+                    }\n+                    Some(DefStatic(..)) => {\n+                        resolve_error(self, span, ResolutionError::StaticVariableReference);\n+                        return BareIdentifierPatternUnresolved;\n                     }\n+                    _ => return BareIdentifierPatternUnresolved\n                 }\n             }\n \n@@ -3216,85 +3030,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         return Some(def);\n     }\n \n-    // FIXME #4952: Merge me with resolve_name_in_module?\n-    fn resolve_definition_of_name_in_module(&mut self,\n-                                            containing_module: Rc<Module>,\n-                                            name: Name,\n-                                            namespace: Namespace)\n-                                            -> NameDefinition {\n-        // First, search children.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n-\n-        match containing_module.children.borrow().get(&name) {\n-            Some(child_name_bindings) => {\n-                match child_name_bindings.def_for_namespace(namespace) {\n-                    Some(def) => {\n-                        // Found it. Stop the search here.\n-                        let p = child_name_bindings.defined_in_public_namespace(namespace);\n-                        let lp = if p {\n-                            LastMod(AllPublic)\n-                        } else {\n-                            LastMod(DependsOn(def.def_id()))\n-                        };\n-                        return ChildNameDefinition(def, lp);\n-                    }\n-                    None => {}\n-                }\n-            }\n-            None => {}\n-        }\n-\n-        // Next, search import resolutions.\n-        match containing_module.import_resolutions.borrow().get(&name) {\n-            Some(import_resolution) if import_resolution.is_public => {\n-                if let Some(target) = (*import_resolution).target_for_namespace(namespace) {\n-                    match target.bindings.def_for_namespace(namespace) {\n-                        Some(def) => {\n-                            // Found it.\n-                            let id = import_resolution.id(namespace);\n-                            // track imports and extern crates as well\n-                            self.used_imports.insert((id, namespace));\n-                            self.record_import_use(id, name);\n-                            match target.target_module.def_id.get() {\n-                                Some(DefId{krate: kid, ..}) => {\n-                                    self.used_crates.insert(kid);\n-                                }\n-                                _ => {}\n-                            }\n-                            return ImportNameDefinition(def, LastMod(AllPublic));\n-                        }\n-                        None => {\n-                            // This can happen with external impls, due to\n-                            // the imperfect way we read the metadata.\n-                        }\n-                    }\n-                }\n-            }\n-            Some(..) | None => {} // Continue.\n-        }\n-\n-        // Finally, search through external children.\n-        if namespace == TypeNS {\n-            if let Some(module) = containing_module.external_module_children\n-                                                   .borrow()\n-                                                   .get(&name)\n-                                                   .cloned() {\n-                if let Some(def_id) = module.def_id.get() {\n-                    // track used crates\n-                    self.used_crates.insert(def_id.krate);\n-                    let lp = if module.is_public {\n-                        LastMod(AllPublic)\n-                    } else {\n-                        LastMod(DependsOn(def_id))\n-                    };\n-                    return ChildNameDefinition(DefMod(def_id), lp);\n-                }\n-            }\n-        }\n-\n-        return NoNameDefinition;\n-    }\n-\n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n                                     span: Span,\n@@ -3337,18 +3072,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_definition_of_name_in_module(containing_module.clone(),\n-                                                                  name,\n-                                                                  namespace) {\n-            NoNameDefinition => {\n-                // We failed to resolve the name. Report an error.\n-                return None;\n-            }\n-            ChildNameDefinition(def, lp) | ImportNameDefinition(def, lp) => {\n+        let def = match self.resolve_name_in_module(containing_module.clone(),\n+                                                    name,\n+                                                    namespace,\n+                                                    NameSearchType::PathSearch,\n+                                                    false) {\n+            Success((Target { binding, .. }, _)) => {\n+                let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n             }\n+            _ => return None,\n         };\n-        if let Some(DefId{krate: kid, ..}) = containing_module.def_id.get() {\n+        if let Some(DefId{krate: kid, ..}) = containing_module.def_id() {\n             self.used_crates.insert(kid);\n         }\n         return Some(def);\n@@ -3368,7 +3103,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .map(|ps| ps.identifier.name)\n                                   .collect::<Vec<_>>();\n \n-        let root_module = self.graph_root.get_module();\n+        let root_module = self.graph_root.clone();\n \n         let containing_module;\n         let last_private;\n@@ -3403,14 +3138,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_definition_of_name_in_module(containing_module, name, namespace) {\n-            NoNameDefinition => {\n-                // We failed to resolve the name. Report an error.\n-                return None;\n-            }\n-            ChildNameDefinition(def, lp) | ImportNameDefinition(def, lp) => {\n-                return Some((def, last_private.or(lp)));\n+        match self.resolve_name_in_module(containing_module,\n+                                          name,\n+                                          namespace,\n+                                          NameSearchType::PathSearch,\n+                                          false) {\n+            Success((Target { binding, .. }, _)) => {\n+                let (def, lp) = binding.def_and_lp();\n+                Some((def, last_private.or(lp)))\n             }\n+            _ => None,\n         }\n     }\n \n@@ -3458,7 +3195,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module = self.current_module.clone();\n         match self.resolve_item_in_lexical_scope(module, name, namespace) {\n             Success((target, _)) => {\n-                match (*target.bindings).def_for_namespace(namespace) {\n+                match target.binding.def() {\n                     None => {\n                         // This can happen if we were looking for a type and\n                         // found a module instead. Modules don't have defs.\n@@ -3529,7 +3266,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(_) => None,\n                     None => {\n                         match this.current_module.children.borrow().get(last_name) {\n-                            Some(child) => child.get_module_if_available(),\n+                            Some(child) => child.type_ns.module(),\n                             None => None,\n                         }\n                     }\n@@ -3595,7 +3332,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n             if let Some(binding) = module.children.borrow().get(&name) {\n-                if let Some(DefMethod(did)) = binding.def_for_namespace(ValueNS) {\n+                if let Some(DefMethod(did)) = binding.value_ns.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n                     }\n@@ -3913,7 +3650,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             {\n                 for (_, child_names) in search_module.children.borrow().iter() {\n-                    let def = match child_names.def_for_namespace(TypeNS) {\n+                    let def = match child_names.type_ns.def() {\n                         Some(def) => def,\n                         None => continue,\n                     };\n@@ -3933,7 +3670,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => continue,\n                     Some(target) => target,\n                 };\n-                let did = match target.bindings.def_for_namespace(TypeNS) {\n+                let did = match target.binding.def() {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n@@ -3943,7 +3680,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.used_imports.insert((id, TypeNS));\n                     let trait_name = self.get_trait_name(did);\n                     self.record_import_use(id, trait_name);\n-                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n                         self.used_crates.insert(kid);\n                     }\n                 }\n@@ -4144,7 +3881,7 @@ pub fn create_resolver<'a, 'tcx>(session: &'a Session,\n                                  make_glob_map: MakeGlobMap,\n                                  callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n                                  -> Resolver<'a, 'tcx> {\n-    let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n+    let mut resolver = Resolver::new(session, ast_map, make_glob_map);\n \n     resolver.callback = callback;\n "}, {"sha": "3a6a5a031b6a1666aba2b809360fdf219e4b94a8", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=8e9a97529d9fd112f338501e68e33bac1c41d1a4", "patch": "@@ -18,8 +18,8 @@\n // Then this operation can simply be performed as part of item (or import)\n // processing.\n \n-use {Module, NameBindings, Resolver};\n-use Namespace::{self, TypeNS, ValueNS};\n+use {Module, NameBinding, Resolver};\n+use Namespace::{TypeNS, ValueNS};\n \n use build_reduced_graph;\n use module_to_string;\n@@ -54,7 +54,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         // If this isn't a local krate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n-        match module_.def_id.get() {\n+        match module_.def_id() {\n             Some(def_id) if def_id.is_local() => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording exports for local \\\n@@ -79,7 +79,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n         for (_, child_name_bindings) in module_.children.borrow().iter() {\n-            match child_name_bindings.get_module_if_available() {\n+            match child_name_bindings.type_ns.module() {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -98,7 +98,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         let mut exports = Vec::new();\n \n         self.add_exports_for_module(&mut exports, module_);\n-        match module_.def_id.get() {\n+        match module_.def_id() {\n             Some(def_id) => {\n                 let node_id = self.ast_map.as_local_node_id(def_id).unwrap();\n                 self.export_map.insert(node_id, exports);\n@@ -108,12 +108,11 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn add_exports_of_namebindings(&mut self,\n-                                   exports: &mut Vec<Export>,\n-                                   name: ast::Name,\n-                                   namebindings: &NameBindings,\n-                                   ns: Namespace) {\n-        match namebindings.def_for_namespace(ns) {\n+    fn add_export_of_namebinding(&mut self,\n+                                 exports: &mut Vec<Export>,\n+                                 name: ast::Name,\n+                                 namebinding: &NameBinding) {\n+        match namebinding.def() {\n             Some(d) => {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n                        name,\n@@ -139,7 +138,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\", name);\n-                        self.add_exports_of_namebindings(exports, *name, &*target.bindings, ns)\n+                        self.add_export_of_namebinding(exports, *name, &target.binding)\n                     }\n                     _ => (),\n                 }\n@@ -150,6 +149,6 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n \n pub fn record(resolver: &mut Resolver) {\n     let mut recorder = ExportRecorder { resolver: resolver };\n-    let root_module = recorder.graph_root.get_module();\n+    let root_module = recorder.graph_root.clone();\n     recorder.record_exports_for_module_subtree(root_module);\n }"}, {"sha": "4f67d6e2f7e799c9806f61025df120b66456253a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8e9a97529d9fd112f338501e68e33bac1c41d1a4", "patch": "@@ -12,9 +12,8 @@ use self::ImportDirectiveSubclass::*;\n \n use DefModifiers;\n use Module;\n-use ModuleKind;\n use Namespace::{self, TypeNS, ValueNS};\n-use NameBindings;\n+use {NameBindings, NameBinding};\n use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n use NamespaceResult;\n use NameSearchType;\n@@ -86,18 +85,18 @@ impl ImportDirective {\n #[derive(Clone,Debug)]\n pub struct Target {\n     pub target_module: Rc<Module>,\n-    pub bindings: Rc<NameBindings>,\n+    pub binding: NameBinding,\n     pub shadowable: Shadowable,\n }\n \n impl Target {\n     pub fn new(target_module: Rc<Module>,\n-               bindings: Rc<NameBindings>,\n+               binding: NameBinding,\n                shadowable: Shadowable)\n                -> Target {\n         Target {\n             target_module: target_module,\n-            bindings: bindings,\n+            binding: binding,\n             shadowable: shadowable,\n         }\n     }\n@@ -210,7 +209,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    i,\n                    self.resolver.unresolved_imports);\n \n-            let module_root = self.resolver.graph_root.get_module();\n+            let module_root = self.resolver.graph_root.clone();\n             let errors = self.resolve_imports_for_module_subtree(module_root.clone());\n \n             if self.resolver.unresolved_imports == 0 {\n@@ -255,7 +254,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n         for (_, child_node) in module_.children.borrow().iter() {\n-            match child_node.get_module_if_available() {\n+            match child_node.type_ns.module() {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -338,7 +337,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // First, resolve the module path for the directive, if necessary.\n         let container = if module_path.is_empty() {\n             // Use the crate root.\n-            Some((self.resolver.graph_root.get_module(), LastMod(AllPublic)))\n+            Some((self.resolver.graph_root.clone(), LastMod(AllPublic)))\n         } else {\n             match self.resolver.resolve_module_path(module_.clone(),\n                                                     &module_path[..],\n@@ -459,11 +458,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref child_name_bindings) => {\n                 // pub_err makes sure we don't give the same error twice.\n                 let mut pub_err = false;\n-                if child_name_bindings.defined_in_namespace(ValueNS) {\n+                if child_name_bindings.value_ns.defined() {\n                     debug!(\"(resolving single import) found value binding\");\n                     value_result = BoundResult(target_module.clone(),\n-                                               (*child_name_bindings).clone());\n-                    if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n+                                               child_name_bindings.value_ns.clone());\n+                    if directive.is_public && !child_name_bindings.value_ns.is_public() {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                         let note_msg = format!(\"Consider marking `{}` as `pub` in the imported \\\n                                                 module\",\n@@ -473,11 +472,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         pub_err = true;\n                     }\n                 }\n-                if child_name_bindings.defined_in_namespace(TypeNS) {\n+                if child_name_bindings.type_ns.defined() {\n                     debug!(\"(resolving single import) found type binding\");\n                     type_result = BoundResult(target_module.clone(),\n-                                              (*child_name_bindings).clone());\n-                    if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n+                                              child_name_bindings.type_ns.clone());\n+                    if !pub_err && directive.is_public &&\n+                       !child_name_bindings.type_ns.is_public() {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                         let note_msg = format!(\"Consider declaring module `{}` as a `pub mod`\",\n                                                source);\n@@ -540,7 +540,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                 }\n                                 Some(Target {\n                                     target_module,\n-                                    bindings,\n+                                    binding,\n                                     shadowable: _\n                                 }) => {\n                                     debug!(\"(resolving single import) found import in ns {:?}\",\n@@ -549,13 +549,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n                                     this.record_import_use(id, source);\n-                                    match target_module.def_id.get() {\n+                                    match target_module.def_id() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n                                         }\n                                         _ => {}\n                                     }\n-                                    return BoundResult(target_module, bindings);\n+                                    return BoundResult(target_module, binding);\n                                 }\n                             }\n                         }\n@@ -591,7 +591,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         // In this case we continue as if we resolved the import and let the\n                         // check_for_conflicts_between_imports_and_items call below handle\n                         // the conflict\n-                        match (module_.def_id.get(), target_module.def_id.get()) {\n+                        match (module_.def_id(), target_module.def_id()) {\n                             (Some(id1), Some(id2)) if id1 == id2 => {\n                                 if value_result.is_unknown() {\n                                     value_result = UnboundResult;\n@@ -624,15 +624,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external module\");\n                         // track the module as used.\n-                        match module.def_id.get() {\n+                        match module.def_id() {\n                             Some(DefId{krate: kid, ..}) => {\n                                 self.resolver.used_crates.insert(kid);\n                             }\n                             _ => {}\n                         }\n-                        let name_bindings =\n-                            Rc::new(Resolver::create_name_bindings_from_module(module));\n-                        type_result = BoundResult(target_module.clone(), name_bindings);\n+                        let name_binding = NameBinding::create_from_module(module);\n+                        type_result = BoundResult(target_module.clone(), name_binding);\n                         type_used_public = true;\n                     }\n                 }\n@@ -651,26 +650,25 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 };\n \n                 match *result {\n-                    BoundResult(ref target_module, ref name_bindings) => {\n+                    BoundResult(ref target_module, ref name_binding) => {\n                         debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n-                               name_bindings.def_for_namespace(namespace));\n+                               name_binding.def());\n                         self.check_for_conflicting_import(&import_resolution,\n                                                           directive.span,\n                                                           target,\n                                                           namespace);\n \n-                        self.check_that_import_is_importable(&**name_bindings,\n+                        self.check_that_import_is_importable(&name_binding,\n                                                              directive.span,\n-                                                             target,\n-                                                             namespace);\n+                                                             target);\n \n                         let target = Some(Target::new(target_module.clone(),\n-                                                      name_bindings.clone(),\n+                                                      name_binding.clone(),\n                                                       directive.shadowable));\n                         import_resolution.set_target_and_id(namespace, target, directive.id);\n                         import_resolution.is_public = directive.is_public;\n-                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                        *used_public = name_binding.is_public();\n                     }\n                     UnboundResult => {\n                         // Continue.\n@@ -705,7 +703,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n+            let def = target.binding.def().unwrap();\n             (def,\n              if value_used_public {\n                 lp\n@@ -714,7 +712,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             })\n         });\n         let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n+            let def = target.binding.def().unwrap();\n             (def,\n              if type_used_public {\n                 lp\n@@ -857,16 +855,15 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // Add external module children from the containing module.\n         for (&name, module) in target_module.external_module_children.borrow().iter() {\n-            let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n                                          target_module.clone(),\n                                          import_directive,\n                                          name,\n-                                         name_bindings);\n+                                         NameBindings::create_from_module(module.clone()));\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = target_module.def_id.get() {\n+        if let Some(did) = target_module.def_id() {\n             self.resolver.def_map.borrow_mut().insert(id,\n                                                       PathResolution {\n                                                           base_def: DefMod(did),\n@@ -884,7 +881,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                containing_module: Rc<Module>,\n                                import_directive: &ImportDirective,\n                                name: Name,\n-                               name_bindings: Rc<NameBindings>) {\n+                               name_bindings: NameBindings) {\n         let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n@@ -904,7 +901,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             let mut merge_child_item = |namespace| {\n                 let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n \n-                if name_bindings.defined_in_namespace_with(namespace, modifier) {\n+                if name_bindings[namespace].defined_with(modifier) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\",\n                         ValueNS => \"value\",\n@@ -922,7 +919,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n-                                                 name_bindings.clone(),\n+                                                 name_bindings[namespace].clone(),\n                                                  import_directive.shadowable);\n                         dest_import_resolution.set_target_and_id(namespace, Some(target), id);\n                     }\n@@ -955,16 +952,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let ns_word = match namespace {\n                     TypeNS => {\n-                        if let Some(ref ty_def) = *target.bindings.type_def.borrow() {\n-                            match ty_def.module_def {\n-                                Some(ref module) if module.kind.get() ==\n-                                                    ModuleKind::NormalModuleKind => \"module\",\n-                                Some(ref module) if module.kind.get() ==\n-                                                    ModuleKind::TraitModuleKind => \"trait\",\n-                                _ => \"type\",\n-                            }\n-                        } else {\n-                            \"type\"\n+                        match target.binding.module() {\n+                            Some(ref module) if module.is_normal() => \"module\",\n+                            Some(ref module) if module.is_trait() => \"trait\",\n+                            _ => \"type\",\n                         }\n                     }\n                     ValueNS => \"value\",\n@@ -989,11 +980,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that an import is actually importable\n     fn check_that_import_is_importable(&mut self,\n-                                       name_bindings: &NameBindings,\n+                                       name_binding: &NameBinding,\n                                        import_span: Span,\n-                                       name: Name,\n-                                       namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n+                                       name: Name) {\n+        if !name_binding.defined_with(DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\", name);\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n@@ -1032,13 +1022,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         match import_resolution.value_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref value) = *name_bindings.value_def.borrow() {\n+                if let Some(ref value) = *name_bindings.value_ns.borrow() {\n                     span_err!(self.resolver.session,\n                               import_span,\n                               E0255,\n                               \"import `{}` conflicts with value in this module\",\n                               name);\n-                    if let Some(span) = value.value_span {\n+                    if let Some(span) = value.span {\n                         self.resolver.session.span_note(span, \"conflicting value here\");\n                     }\n                 }\n@@ -1048,11 +1038,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         match import_resolution.type_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n-                    let (what, note) = match ty.module_def {\n-                        Some(ref module) if module.kind.get() == ModuleKind::NormalModuleKind =>\n+                if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n+                    let (what, note) = match ty.module() {\n+                        Some(ref module) if module.is_normal() =>\n                             (\"existing submodule\", \"note conflicting module here\"),\n-                        Some(ref module) if module.kind.get() == ModuleKind::TraitModuleKind =>\n+                        Some(ref module) if module.is_trait() =>\n                             (\"trait in this module\", \"note conflicting trait here\"),\n                         _ => (\"type in this module\", \"note conflicting type here\"),\n                     };\n@@ -1062,7 +1052,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                               \"import `{}` conflicts with {}\",\n                               name,\n                               what);\n-                    if let Some(span) = ty.type_span {\n+                    if let Some(span) = ty.span {\n                         self.resolver.session.span_note(span, note);\n                     }\n                 }"}, {"sha": "67969616ca3c93215fda25ae8670a4aad10d33a7", "filename": "src/test/compile-fail/enum-and-module-in-same-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs?ref=8e9a97529d9fd112f338501e68e33bac1c41d1a4", "patch": "@@ -13,7 +13,7 @@ mod Foo {\n }\n \n enum Foo {  //~ ERROR duplicate definition of type or module `Foo`\n-    X //~ ERROR duplicate definition of value `X`\n+    X\n }\n \n fn main() {}"}, {"sha": "535630e0824ca571725c9c766d59e4983a817b7e", "filename": "src/test/compile-fail/issue-21546.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Ftest%2Fcompile-fail%2Fissue-21546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9a97529d9fd112f338501e68e33bac1c41d1a4/src%2Ftest%2Fcompile-fail%2Fissue-21546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21546.rs?ref=8e9a97529d9fd112f338501e68e33bac1c41d1a4", "patch": "@@ -16,7 +16,7 @@ mod Foo { }\n \n #[allow(dead_code)]\n struct Foo;\n-//~^ WARNING duplicate definition of type or module `Foo`\n+//~^ ERROR duplicate definition of type or module `Foo`\n \n \n #[allow(non_snake_case)]\n@@ -25,7 +25,7 @@ mod Bar { }\n \n #[allow(dead_code)]\n struct Bar(i32);\n-//~^ WARNING duplicate definition of type or module `Bar`\n+//~^ ERROR duplicate definition of type or module `Bar`\n \n \n #[allow(dead_code)]\n@@ -34,7 +34,7 @@ struct Baz(i32);\n \n #[allow(non_snake_case)]\n mod Baz { }\n-//~^ WARNING duplicate definition of type or module `Baz`\n+//~^ ERROR duplicate definition of type or module `Baz`\n \n \n #[allow(dead_code)]\n@@ -43,7 +43,7 @@ struct Qux { x: bool }\n \n #[allow(non_snake_case)]\n mod Qux { }\n-//~^ WARNING duplicate definition of type or module `Qux`\n+//~^ ERROR duplicate definition of type or module `Qux`\n \n \n #[allow(dead_code)]\n@@ -52,7 +52,7 @@ struct Quux;\n \n #[allow(non_snake_case)]\n mod Quux { }\n-//~^ WARNING duplicate definition of type or module `Quux`\n+//~^ ERROR duplicate definition of type or module `Quux`\n \n \n #[allow(dead_code)]"}]}