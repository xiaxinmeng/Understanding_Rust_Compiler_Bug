{"sha": "f910d27f87419e17cc59034265f6795db5247dfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MTBkMjdmODc0MTllMTdjYzU5MDM0MjY1ZjY3OTVkYjUyNDdkZmE=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-07-25T09:55:26Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-07-25T10:26:18Z"}, "message": "siphash: Use ptr::copy_nonoverlapping for efficient data loading\n\nUse `ptr::copy_nonoverlapping` (aka memcpy) to load an u64 from the\nbyte stream. This is correct for any alignment, and the compiler will\nuse the appropriate instruction to load the data.\n\nUse unchecked indexing.\n\nThis results in a large improvement of throughput (hashed bytes\n/ second) for long data. Maximum improvement benches at a 70% increase\nin throughput for large values (> 256 bytes) but already values of 16\nbytes or larger improve.\n\nIntroducing unchecked indexing is motivated to reach as good throughput\nas possible. Using ptr::copy_nonoverlapping without unchecked indexing\nwould land the improvement some 20-30 pct units lower.\n\nWe use a debug assertion so that the test suite checks our use of\nunchecked indexing.", "tree": {"sha": "3788c2facf00f062af3de5164250d5a401d6f2b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3788c2facf00f062af3de5164250d5a401d6f2b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f910d27f87419e17cc59034265f6795db5247dfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f910d27f87419e17cc59034265f6795db5247dfa", "html_url": "https://github.com/rust-lang/rust/commit/f910d27f87419e17cc59034265f6795db5247dfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f910d27f87419e17cc59034265f6795db5247dfa/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381d2ed70d3f3c2913e19a950dee0da0149dae1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/381d2ed70d3f3c2913e19a950dee0da0149dae1d", "html_url": "https://github.com/rust-lang/rust/commit/381d2ed70d3f3c2913e19a950dee0da0149dae1d"}], "stats": {"total": 17, "additions": 16, "deletions": 1}, "files": [{"sha": "fae14da22c4c61677c520887e4ad15db27f1be4f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f910d27f87419e17cc59034265f6795db5247dfa/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f910d27f87419e17cc59034265f6795db5247dfa/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=f910d27f87419e17cc59034265f6795db5247dfa", "patch": "@@ -10,6 +10,7 @@\n \n //! An implementation of SipHash 2-4.\n \n+use ptr;\n use prelude::*;\n use super::Hasher;\n \n@@ -65,6 +66,20 @@ macro_rules! u8to64_le {\n     });\n }\n \n+/// Load a full u64 word from a byte stream, in LE order. Use\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load u64 from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+8\n+#[inline]\n+unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n+    debug_assert!(i + 8 <= buf.len());\n+    let mut data = 0u64;\n+    ptr::copy_nonoverlapping(buf.get_unchecked(i),\n+                             &mut data as *mut _ as *mut u8, 8);\n+    data.to_le()\n+}\n+\n macro_rules! rotl {\n     ($x:expr, $b:expr) =>\n     (($x << $b) | ($x >> (64_i32.wrapping_sub($b))))\n@@ -151,7 +166,7 @@ impl SipHasher {\n \n         let mut i = needed;\n         while i < end {\n-            let mi = u8to64_le!(msg, i);\n+            let mi = unsafe { load_u64_le(msg, i) };\n \n             self.v3 ^= mi;\n             compress!(self.v0, self.v1, self.v2, self.v3);"}]}