{"sha": "11491938f80988c7261a1179cf71a25c379c8783", "node_id": "C_kwDOAAsO6NoAKDExNDkxOTM4ZjgwOTg4YzcyNjFhMTE3OWNmNzFhMjVjMzc5Yzg3ODM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-29T17:58:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-29T17:58:08Z"}, "message": "Auto merge of #89011 - bjorn3:restructure_rt, r=dtolnay\n\nRestructure std::rt\n\nThese changes should reduce binary size slightly while at the same slightly improving performance of startup, thread spawning and `std::thread::current()`. I haven't verified if the compiler is able to optimize some of these cases already, but at least for some others the compiler is unable to do these optimizations as they slightly change behavior in cases where program startup would crash anyway by omitting a backtrace and panic location.\n\nI can remove 6f6bb16 if preferred.", "tree": {"sha": "a9d9fa6a784d7eb409400b627ff6ac1aee6722c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d9fa6a784d7eb409400b627ff6ac1aee6722c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11491938f80988c7261a1179cf71a25c379c8783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11491938f80988c7261a1179cf71a25c379c8783", "html_url": "https://github.com/rust-lang/rust/commit/11491938f80988c7261a1179cf71a25c379c8783", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11491938f80988c7261a1179cf71a25c379c8783/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f9f7810c975234ce4730488d32661a76a00428", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f9f7810c975234ce4730488d32661a76a00428", "html_url": "https://github.com/rust-lang/rust/commit/50f9f7810c975234ce4730488d32661a76a00428"}, {"sha": "37608c7c501b12b634834363827e314f6750946f", "url": "https://api.github.com/repos/rust-lang/rust/commits/37608c7c501b12b634834363827e314f6750946f", "html_url": "https://github.com/rust-lang/rust/commit/37608c7c501b12b634834363827e314f6750946f"}], "stats": {"total": 226, "additions": 112, "deletions": 114}, "files": [{"sha": "9e7e92bdc781989a4ee8c10411df791312a6cb4c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -520,20 +520,20 @@ pub mod task {\n     pub use alloc::task::*;\n }\n \n-// Platform-abstraction modules\n+// The runtime entry point and a few unstable public functions used by the\n+// compiler\n #[macro_use]\n-mod sys_common;\n+pub mod rt;\n+\n+// Platform-abstraction modules\n mod sys;\n+mod sys_common;\n \n pub mod alloc;\n \n // Private support modules\n mod panicking;\n \n-// The runtime entry point and a few unstable public functions used by the\n-// compiler\n-pub mod rt;\n-\n #[path = \"../../backtrace/src/lib.rs\"]\n #[allow(dead_code, unused_attributes)]\n mod backtrace_rs;"}, {"sha": "5c68400114d49744de3e73b1663db7555664b021", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -1907,7 +1907,7 @@ impl Child {\n /// [platform-specific behavior]: #platform-specific-behavior\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn exit(code: i32) -> ! {\n-    crate::sys_common::rt::cleanup();\n+    crate::rt::cleanup();\n     crate::sys::os::exit(code)\n }\n "}, {"sha": "4d72aff011684c8c2efe874ce0e1105e405ef4e0", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 85, "deletions": 3, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -13,11 +13,93 @@\n     issue = \"none\"\n )]\n #![doc(hidden)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![allow(unused_macros)]\n+\n+use crate::ffi::CString;\n \n // Re-export some of our utilities which are expected by other crates.\n pub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};\n pub use core::panicking::panic_display;\n \n+use crate::sync::Once;\n+use crate::sys;\n+use crate::sys_common::thread_info;\n+use crate::thread::Thread;\n+\n+// Prints to the \"panic output\", depending on the platform this may be:\n+// - the standard error output\n+// - some dedicated platform specific output\n+// - nothing (so this macro is a no-op)\n+macro_rules! rtprintpanic {\n+    ($($t:tt)*) => {\n+        if let Some(mut out) = crate::sys::stdio::panic_output() {\n+            let _ = crate::io::Write::write_fmt(&mut out, format_args!($($t)*));\n+        }\n+    }\n+}\n+\n+macro_rules! rtabort {\n+    ($($t:tt)*) => {\n+        {\n+            rtprintpanic!(\"fatal runtime error: {}\\n\", format_args!($($t)*));\n+            crate::sys::abort_internal();\n+        }\n+    }\n+}\n+\n+macro_rules! rtassert {\n+    ($e:expr) => {\n+        if !$e {\n+            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n+        }\n+    };\n+}\n+\n+macro_rules! rtunwrap {\n+    ($ok:ident, $e:expr) => {\n+        match $e {\n+            $ok(v) => v,\n+            ref err => {\n+                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n+                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n+            }\n+        }\n+    };\n+}\n+\n+// One-time runtime initialization.\n+// Runs before `main`.\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+#[cfg_attr(test, allow(dead_code))]\n+unsafe fn init(argc: isize, argv: *const *const u8) {\n+    unsafe {\n+        sys::init(argc, argv);\n+\n+        let main_guard = sys::thread::guard::init();\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread = Thread::new(Some(rtunwrap!(Ok, CString::new(\"main\"))));\n+        thread_info::set(main_guard, thread);\n+    }\n+}\n+\n+// One-time runtime cleanup.\n+// Runs after `main` or at program exit.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub(crate) fn cleanup() {\n+    static CLEANUP: Once = Once::new();\n+    CLEANUP.call_once(|| unsafe {\n+        // Flush stdout and disable buffering.\n+        crate::io::cleanup();\n+        // SAFETY: Only called once during runtime cleanup.\n+        sys::cleanup();\n+    });\n+}\n+\n // To reduce the generated code of the new `lang_start`, this function is doing\n // the real work.\n #[cfg(not(test))]\n@@ -26,7 +108,7 @@ fn lang_start_internal(\n     argc: isize,\n     argv: *const *const u8,\n ) -> Result<isize, !> {\n-    use crate::{mem, panic, sys, sys_common};\n+    use crate::{mem, panic};\n     let rt_abort = move |e| {\n         mem::forget(e);\n         rtabort!(\"initialization or cleanup bug\");\n@@ -42,14 +124,14 @@ fn lang_start_internal(\n     // prevent libstd from accidentally introducing a panic to these functions. Another is from\n     // user code from `main` or, more nefariously, as described in e.g. issue #86030.\n     // SAFETY: Only called once during runtime initialization.\n-    panic::catch_unwind(move || unsafe { sys_common::rt::init(argc, argv) }).map_err(rt_abort)?;\n+    panic::catch_unwind(move || unsafe { init(argc, argv) }).map_err(rt_abort)?;\n     let ret_code = panic::catch_unwind(move || panic::catch_unwind(main).unwrap_or(101) as isize)\n         .map_err(move |e| {\n             mem::forget(e);\n             rtprintpanic!(\"drop of the panic payload panicked\");\n             sys::abort_internal()\n         });\n-    panic::catch_unwind(sys_common::rt::cleanup).map_err(rt_abort)?;\n+    panic::catch_unwind(cleanup).map_err(rt_abort)?;\n     ret_code\n }\n "}, {"sha": "1c37f4ee4981e51f07cc2d30df4ab60fed59823b", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -120,7 +120,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n \n     unsafe fn reset_sigpipe() {\n         #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n-        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n+        rtassert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n     }\n }\n "}, {"sha": "5a5913ebd79a35bbe657c15c524119e6248fd2ea", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -28,8 +28,6 @@ pub mod memchr;\n pub mod mutex;\n pub mod process;\n pub mod remutex;\n-#[macro_use]\n-pub mod rt;\n pub mod rwlock;\n pub mod thread;\n pub mod thread_info;"}, {"sha": "02013ecc4ced6b8769f3a4f7c8b6b1c2ecfaf8b7", "filename": "library/std/src/sys_common/rt.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/50f9f7810c975234ce4730488d32661a76a00428/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f9f7810c975234ce4730488d32661a76a00428/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs?ref=50f9f7810c975234ce4730488d32661a76a00428", "patch": "@@ -1,81 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-#![allow(unused_macros)]\n-\n-use crate::sync::Once;\n-use crate::sys;\n-use crate::sys_common::thread_info;\n-use crate::thread::Thread;\n-\n-// One-time runtime initialization.\n-// Runs before `main`.\n-// SAFETY: must be called only once during runtime initialization.\n-// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n-#[cfg_attr(test, allow(dead_code))]\n-pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    unsafe {\n-        sys::init(argc, argv);\n-\n-        let main_guard = sys::thread::guard::init();\n-        // Next, set up the current Thread with the guard information we just\n-        // created. Note that this isn't necessary in general for new threads,\n-        // but we just do this to name the main thread and to give it correct\n-        // info about the stack bounds.\n-        let thread = Thread::new(Some(\"main\".to_owned()));\n-        thread_info::set(main_guard, thread);\n-    }\n-}\n-\n-// One-time runtime cleanup.\n-// Runs after `main` or at program exit.\n-// NOTE: this is not guaranteed to run, for example when the program aborts.\n-#[cfg_attr(test, allow(dead_code))]\n-pub fn cleanup() {\n-    static CLEANUP: Once = Once::new();\n-    CLEANUP.call_once(|| unsafe {\n-        // Flush stdout and disable buffering.\n-        crate::io::cleanup();\n-        // SAFETY: Only called once during runtime cleanup.\n-        sys::cleanup();\n-    });\n-}\n-\n-// Prints to the \"panic output\", depending on the platform this may be:\n-// - the standard error output\n-// - some dedicated platform specific output\n-// - nothing (so this macro is a no-op)\n-macro_rules! rtprintpanic {\n-    ($($t:tt)*) => {\n-        if let Some(mut out) = crate::sys::stdio::panic_output() {\n-            let _ = crate::io::Write::write_fmt(&mut out, format_args!($($t)*));\n-        }\n-    }\n-}\n-\n-macro_rules! rtabort {\n-    ($($t:tt)*) => {\n-        {\n-            rtprintpanic!(\"fatal runtime error: {}\\n\", format_args!($($t)*));\n-            crate::sys::abort_internal();\n-        }\n-    }\n-}\n-\n-macro_rules! rtassert {\n-    ($e:expr) => {\n-        if !$e {\n-            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n-        }\n-    };\n-}\n-\n-macro_rules! rtunwrap {\n-    ($ok:ident, $e:expr) => {\n-        match $e {\n-            $ok(v) => v,\n-            ref err => {\n-                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n-                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n-            }\n-        }\n-    };\n-}"}, {"sha": "38c9e50009af5eb98193dc559b4dac28834083d3", "filename": "library/std/src/sys_common/thread_info.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_info.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -1,4 +1,5 @@\n #![allow(dead_code)] // stack_guard isn't used right now on all platforms\n+#![allow(unused_unsafe)] // thread_local with `const {}` triggers this liny\n \n use crate::cell::RefCell;\n use crate::sys::thread::guard::Guard;\n@@ -9,20 +10,21 @@ struct ThreadInfo {\n     thread: Thread,\n }\n \n-thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n+thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = const { RefCell::new(None) } }\n \n impl ThreadInfo {\n     fn with<R, F>(f: F) -> Option<R>\n     where\n         F: FnOnce(&mut ThreadInfo) -> R,\n     {\n         THREAD_INFO\n-            .try_with(move |c| {\n-                if c.borrow().is_none() {\n-                    *c.borrow_mut() =\n-                        Some(ThreadInfo { stack_guard: None, thread: Thread::new(None) })\n-                }\n-                f(c.borrow_mut().as_mut().unwrap())\n+            .try_with(move |thread_info| {\n+                let mut thread_info = thread_info.borrow_mut();\n+                let thread_info = thread_info.get_or_insert_with(|| ThreadInfo {\n+                    stack_guard: None,\n+                    thread: Thread::new(None),\n+                });\n+                f(thread_info)\n             })\n             .ok()\n     }\n@@ -37,10 +39,9 @@ pub fn stack_guard() -> Option<Guard> {\n }\n \n pub fn set(stack_guard: Option<Guard>, thread: Thread) {\n-    THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n-    THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo { stack_guard, thread }));\n-}\n-\n-pub fn reset_guard(stack_guard: Option<Guard>) {\n-    THREAD_INFO.with(move |c| c.borrow_mut().as_mut().unwrap().stack_guard = stack_guard);\n+    THREAD_INFO.with(move |thread_info| {\n+        let mut thread_info = thread_info.borrow_mut();\n+        rtassert!(thread_info.is_none());\n+        *thread_info = Some(ThreadInfo { stack_guard, thread });\n+    });\n }"}, {"sha": "9d659102b032086aa9255e95a9980b8f3c8397d8", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11491938f80988c7261a1179cf71a25c379c8783/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=11491938f80988c7261a1179cf71a25c379c8783", "patch": "@@ -457,7 +457,9 @@ impl Builder {\n \n         let stack_size = stack_size.unwrap_or_else(thread::min_stack);\n \n-        let my_thread = Thread::new(name);\n+        let my_thread = Thread::new(name.map(|name| {\n+            CString::new(name).expect(\"thread name may not contain interior null bytes\")\n+        }));\n         let their_thread = my_thread.clone();\n \n         let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n@@ -1073,12 +1075,8 @@ pub struct Thread {\n impl Thread {\n     // Used only internally to construct a thread object without spawning\n     // Panics if the name contains nuls.\n-    pub(crate) fn new(name: Option<String>) -> Thread {\n-        let cname =\n-            name.map(|n| CString::new(n).expect(\"thread name may not contain interior null bytes\"));\n-        Thread {\n-            inner: Arc::new(Inner { name: cname, id: ThreadId::new(), parker: Parker::new() }),\n-        }\n+    pub(crate) fn new(name: Option<CString>) -> Thread {\n+        Thread { inner: Arc::new(Inner { name, id: ThreadId::new(), parker: Parker::new() }) }\n     }\n \n     /// Atomically makes the handle's token available if it is not already."}]}