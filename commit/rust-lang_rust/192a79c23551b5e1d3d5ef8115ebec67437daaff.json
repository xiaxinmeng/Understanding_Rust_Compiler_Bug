{"sha": "192a79c23551b5e1d3d5ef8115ebec67437daaff", "node_id": "C_kwDOAAsO6NoAKDE5MmE3OWMyMzU1MWI1ZTFkM2Q1ZWY4MTE1ZWJlYzY3NDM3ZGFhZmY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-31T14:58:11Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-31T14:58:11Z"}, "message": "Remove hir::Expr::MacroStmts\n\nThis hir expression isn't needed and only existed as it was simpler to\ndeal with at first as it gave us a direct mapping for the ast version of\nthe same construct. This PR removes it, properly handling the statements\nthat are introduced by macro call expressions.", "tree": {"sha": "020a18af5d41cf9c6e49d8006548af151d7c7d08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020a18af5d41cf9c6e49d8006548af151d7c7d08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/192a79c23551b5e1d3d5ef8115ebec67437daaff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/192a79c23551b5e1d3d5ef8115ebec67437daaff", "html_url": "https://github.com/rust-lang/rust/commit/192a79c23551b5e1d3d5ef8115ebec67437daaff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/192a79c23551b5e1d3d5ef8115ebec67437daaff/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9e22079c4cb8ffb0076cf52c37be343582ad418", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e22079c4cb8ffb0076cf52c37be343582ad418", "html_url": "https://github.com/rust-lang/rust/commit/d9e22079c4cb8ffb0076cf52c37be343582ad418"}], "stats": {"total": 198, "additions": 88, "deletions": 110}, "files": [{"sha": "cb6fdbfc562e9c08717d208baec112a89b99b442", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -550,20 +550,6 @@ impl ExprCollector<'_> {\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n-            ast::Expr::MacroStmts(e) => {\n-                let statements: Box<[_]> =\n-                    e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n-                let tail = e.expr().map(|e| self.collect_expr(e));\n-\n-                if e.syntax().children().next().is_none() {\n-                    // HACK: make sure that macros that expand to nothing aren't treated as a `()`\n-                    // expression when used in block tail position.\n-                    cov_mark::hit!(empty_macro_in_trailing_position_is_removed);\n-                    return None;\n-                }\n-\n-                self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n-            }\n             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n         })\n     }\n@@ -640,7 +626,58 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Statement> {\n+    fn collect_macro_as_stmt(\n+        &mut self,\n+        mac: ast::MacroExpr,\n+    ) -> Option<(Vec<Statement>, Option<ExprId>)> {\n+        let mac_call = mac.macro_call()?;\n+        let syntax_ptr = AstPtr::new(&ast::Expr::from(mac));\n+        let macro_ptr = AstPtr::new(&mac_call);\n+        let expansion = self.collect_macro_call(\n+            mac_call,\n+            macro_ptr,\n+            false,\n+            |this, expansion: Option<ast::MacroStmts>| match expansion {\n+                Some(expansion) => {\n+                    let mut statements: Vec<_> = expansion\n+                        .statements()\n+                        .filter_map(|stmt| this.collect_stmt(stmt))\n+                        .flatten()\n+                        .collect();\n+                    let tail = expansion.expr().and_then(|expr| match expr {\n+                        ast::Expr::MacroExpr(mac) => {\n+                            let (stmts, tail) = this.collect_macro_as_stmt(mac)?;\n+                            statements.extend(stmts);\n+                            tail\n+                        }\n+                        expr => Some(this.collect_expr(expr)),\n+                    });\n+                    Some((statements, tail))\n+                }\n+                None => None,\n+            },\n+        );\n+        let mut stmts = Vec::new();\n+        let expr = match expansion {\n+            Some((statements, tail)) => {\n+                stmts.extend(statements);\n+                // Make the macro-call point to its expanded expression so we can query\n+                // semantics on syntax pointers to the macro\n+                let src = self.expander.to_source(syntax_ptr);\n+                match tail {\n+                    Some(tail) => {\n+                        self.source_map.expr_map.insert(src, tail);\n+                        tail\n+                    }\n+                    None => self.make_expr(Expr::Missing, Ok(src.clone())),\n+                }\n+            }\n+            None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+        };\n+        Some((stmts, Some(expr)))\n+    }\n+\n+    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Vec<Statement>> {\n         match s {\n             ast::Stmt::LetStmt(stmt) => {\n                 if self.check_cfg(&stmt).is_none() {\n@@ -654,7 +691,7 @@ impl ExprCollector<'_> {\n                     .let_else()\n                     .and_then(|let_else| let_else.block_expr())\n                     .map(|block| self.collect_block(block));\n-                Some(Statement::Let { pat, type_ref, initializer, else_branch })\n+                Some(vec![Statement::Let { pat, type_ref, initializer, else_branch }])\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n                 let expr = stmt.expr();\n@@ -665,47 +702,15 @@ impl ExprCollector<'_> {\n                 }\n                 let has_semi = stmt.semicolon_token().is_some();\n                 // Note that macro could be expanded to multiple statements\n-                if let Some(expr @ ast::Expr::MacroExpr(mac)) = &expr {\n-                    let mac_call = mac.macro_call()?;\n-                    let syntax_ptr = AstPtr::new(expr);\n-                    let macro_ptr = AstPtr::new(&mac_call);\n-                    let stmt = self.collect_macro_call(\n-                        mac_call,\n-                        macro_ptr,\n-                        false,\n-                        |this, expansion: Option<ast::MacroStmts>| match expansion {\n-                            Some(expansion) => {\n-                                let statements = expansion\n-                                    .statements()\n-                                    .filter_map(|stmt| this.collect_stmt(stmt))\n-                                    .collect();\n-                                let tail = expansion.expr().map(|expr| this.collect_expr(expr));\n-\n-                                let mac_stmts = this.alloc_expr(\n-                                    Expr::MacroStmts { tail, statements },\n-                                    AstPtr::new(&ast::Expr::MacroStmts(expansion)),\n-                                );\n-\n-                                Some(mac_stmts)\n-                            }\n-                            None => None,\n-                        },\n-                    );\n-\n-                    let expr = match stmt {\n-                        Some(expr) => {\n-                            // Make the macro-call point to its expanded expression so we can query\n-                            // semantics on syntax pointers to the macro\n-                            let src = self.expander.to_source(syntax_ptr);\n-                            self.source_map.expr_map.insert(src, expr);\n-                            expr\n-                        }\n-                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n-                    };\n-                    Some(Statement::Expr { expr, has_semi })\n+                if let Some(ast::Expr::MacroExpr(mac)) = expr {\n+                    let (mut statements, tail) = self.collect_macro_as_stmt(mac)?;\n+                    if let Some(expr) = tail {\n+                        statements.push(Statement::Expr { expr, has_semi });\n+                    }\n+                    Some(statements)\n                 } else {\n                     let expr = self.collect_expr_opt(expr);\n-                    Some(Statement::Expr { expr, has_semi })\n+                    Some(vec![Statement::Expr { expr, has_semi }])\n                 }\n             }\n             ast::Stmt::Item(_item) => None,\n@@ -730,8 +735,15 @@ impl ExprCollector<'_> {\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n         let mut statements: Vec<_> =\n-            block.statements().filter_map(|s| self.collect_stmt(s)).collect();\n-        let tail = block.tail_expr().and_then(|e| self.maybe_collect_expr(e));\n+            block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n+        let tail = block.tail_expr().and_then(|e| match e {\n+            ast::Expr::MacroExpr(mac) => {\n+                let (stmts, tail) = self.collect_macro_as_stmt(mac)?;\n+                statements.extend(stmts);\n+                tail\n+            }\n+            expr => self.maybe_collect_expr(expr),\n+        });\n         let tail = tail.or_else(|| {\n             let stmt = statements.pop()?;\n             if let Statement::Expr { expr, has_semi: false } = stmt {"}, {"sha": "f2fed954444e2ca80b04a41a7bafa488f87905e4", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -422,19 +422,6 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \"}}\");\n             }\n-            Expr::MacroStmts { statements, tail } => {\n-                w!(self, \"{{ // macro statements\");\n-                self.indented(|p| {\n-                    for stmt in statements.iter() {\n-                        p.print_stmt(stmt);\n-                    }\n-                    if let Some(tail) = tail {\n-                        p.print_expr(*tail);\n-                    }\n-                });\n-                self.newline();\n-                w!(self, \"}}\");\n-            }\n         }\n     }\n "}, {"sha": "9b28e38029e02d07feab6faa32ef5af675145530", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -176,9 +176,6 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n     scopes.set_scope(expr, *scope);\n     match &body[expr] {\n-        Expr::MacroStmts { statements, tail } => {\n-            compute_block_scopes(statements, *tail, body, scopes, scope);\n-        }\n         Expr::Block { statements, tail, id, label } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));\n             // Overwrite the old scope for the block expr, so that every block scope can be found"}, {"sha": "419d3feec3b6c2240c8be326edb0ad24a402c9eb", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -206,10 +206,6 @@ pub enum Expr {\n     Unsafe {\n         body: ExprId,\n     },\n-    MacroStmts {\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n     Array(Array),\n     Literal(Literal),\n     Underscore,\n@@ -263,7 +259,7 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::MacroStmts { tail, statements } | Expr::Block { statements, tail, .. } => {\n+            Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {"}, {"sha": "fc128102f225a18cc066193e649e843dd2147906", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -969,7 +969,7 @@ impl ExpandTo {\n         if parent.kind() == MACRO_EXPR\n             && parent\n                 .parent()\n-                .map_or(true, |p| matches!(p.kind(), EXPR_STMT | STMT_LIST | MACRO_STMTS))\n+                .map_or(false, |p| matches!(p.kind(), EXPR_STMT | STMT_LIST | MACRO_STMTS))\n         {\n             return ExpandTo::Statements;\n         }"}, {"sha": "a42a00ea598eb86913280da1f9b6f72503ec6590", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -794,9 +794,6 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_float_var(),\n                 },\n             },\n-            Expr::MacroStmts { tail, statements } => {\n-                self.infer_block(tgt_expr, statements, *tail, expected)\n-            }\n             Expr::Underscore => {\n                 // Underscore expressions may only appear in assignee expressions,\n                 // which are handled by `infer_assignee_expr()`, so any underscore"}, {"sha": "a1a2fdd1fb287074da6f37df6a84c53775cf9dd0", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -193,8 +193,6 @@ fn expr_macro_def_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n             39..442 '{     ...!(); }': ()\n             73..94 'spam!(...am!())': {unknown}\n             100..119 'for _ ...!() {}': ()\n@@ -276,8 +274,6 @@ fn expr_macro_rules_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n             53..456 '{     ...!(); }': ()\n             87..108 'spam!(...am!())': {unknown}\n             114..133 'for _ ...!() {}': ()\n@@ -312,16 +308,16 @@ fn expr_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..8 'leta=();': ()\n             !3..4 'a': ()\n             !5..7 '()': ()\n             57..84 '{     ...); } }': ()\n+            63..82 'id! { ... (); }': ()\n         \"#]],\n     );\n }\n \n #[test]\n-fn recurisve_macro_expanded_in_stmts() {\n+fn recursive_macro_expanded_in_stmts() {\n     check_infer(\n         r#\"\n         macro_rules! ng {\n@@ -340,11 +336,7 @@ fn recurisve_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..7 'leta=3;': ()\n-            !0..13 'ng!{[leta=3]}': ()\n-            !0..13 'ng!{[leta=]3}': ()\n-            !0..13 'ng!{[leta]=3}': ()\n-            !0..13 'ng!{[let]a=3}': ()\n+            !0..13 'ng!{[leta=3]}': {unknown}\n             !3..4 'a': i32\n             !5..6 '3': i32\n             196..237 '{     ...= a; }': ()\n@@ -369,8 +361,7 @@ fn recursive_inner_item_macro_rules() {\n         \"#,\n         expect![[r#\"\n             !0..1 '1': i32\n-            !0..7 'mac!($)': ()\n-            !0..26 'macro_...>{1};}': ()\n+            !0..7 'mac!($)': {unknown}\n             107..143 '{     ...!(); }': ()\n             129..130 'a': i32\n         \"#]],"}, {"sha": "cc49c3d45fcd9e6533c576bdbce9dd4fb99a2401", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -573,12 +573,12 @@ fn issue_6811() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..16 'let_a=...t_b=1;': ()\n             !3..5 '_a': i32\n             !6..7 '1': i32\n             !11..13 '_b': i32\n             !14..15 '1': i32\n             103..131 '{     ...!(); }': ()\n+            109..128 'profil...ion!()': {unknown}\n         \"#]],\n     );\n }\n@@ -1679,7 +1679,6 @@ fn main() {\n \n #[test]\n fn trailing_empty_macro() {\n-    cov_mark::check!(empty_macro_in_trailing_position_is_removed);\n     check_no_mismatches(\n         r#\"\n macro_rules! m2 {"}, {"sha": "342912b678a1db836de2a77eb92f674fbc7246cd", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -140,11 +140,19 @@ impl SourceAnalyzer {\n     ) -> Option<InFile<ast::Expr>> {\n         let macro_file = self.body_source_map()?.node_macro_file(expr.as_ref())?;\n         let expanded = db.parse_or_expand(macro_file)?;\n-\n-        let res = match ast::MacroCall::cast(expanded.clone()) {\n-            Some(call) => self.expand_expr(db, InFile::new(macro_file, call))?,\n-            _ => InFile::new(macro_file, ast::Expr::cast(expanded)?),\n+        let res = if let Some(stmts) = ast::MacroStmts::cast(expanded.clone()) {\n+            match stmts.expr()? {\n+                ast::Expr::MacroExpr(mac) => {\n+                    self.expand_expr(db, InFile::new(macro_file, mac.macro_call()?))?\n+                }\n+                expr => InFile::new(macro_file, expr),\n+            }\n+        } else if let Some(call) = ast::MacroCall::cast(expanded.clone()) {\n+            self.expand_expr(db, InFile::new(macro_file, call))?\n+        } else {\n+            InFile::new(macro_file, ast::Expr::cast(expanded)?)\n         };\n+\n         Some(res)\n     }\n "}, {"sha": "b890e2b58df8f2688923c1262665e7361a747881", "filename": "crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -315,7 +315,6 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         | ast::Expr::IndexExpr(_)\n         | ast::Expr::Literal(_)\n         | ast::Expr::MacroExpr(_)\n-        | ast::Expr::MacroStmts(_)\n         | ast::Expr::MethodCallExpr(_)\n         | ast::Expr::ParenExpr(_)\n         | ast::Expr::PathExpr(_)"}, {"sha": "894795435451c8e2691fe805253987719cd80313", "filename": "crates/syntax/rust.ungram", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Frust.ungram?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -343,7 +343,6 @@ Expr =\n | Literal\n | LoopExpr\n | MacroExpr\n-| MacroStmts\n | MatchExpr\n | MethodCallExpr\n | ParenExpr"}, {"sha": "449402e5f5b30af4f6e69e3b26c27aa234a2b93c", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192a79c23551b5e1d3d5ef8115ebec67437daaff/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=192a79c23551b5e1d3d5ef8115ebec67437daaff", "patch": "@@ -1526,7 +1526,6 @@ pub enum Expr {\n     Literal(Literal),\n     LoopExpr(LoopExpr),\n     MacroExpr(MacroExpr),\n-    MacroStmts(MacroStmts),\n     MatchExpr(MatchExpr),\n     MethodCallExpr(MethodCallExpr),\n     ParenExpr(ParenExpr),\n@@ -3342,9 +3341,6 @@ impl From<LoopExpr> for Expr {\n impl From<MacroExpr> for Expr {\n     fn from(node: MacroExpr) -> Expr { Expr::MacroExpr(node) }\n }\n-impl From<MacroStmts> for Expr {\n-    fn from(node: MacroStmts) -> Expr { Expr::MacroStmts(node) }\n-}\n impl From<MatchExpr> for Expr {\n     fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n }\n@@ -3411,7 +3407,6 @@ impl AstNode for Expr {\n                 | LITERAL\n                 | LOOP_EXPR\n                 | MACRO_EXPR\n-                | MACRO_STMTS\n                 | MATCH_EXPR\n                 | METHOD_CALL_EXPR\n                 | PAREN_EXPR\n@@ -3448,7 +3443,6 @@ impl AstNode for Expr {\n             LITERAL => Expr::Literal(Literal { syntax }),\n             LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n             MACRO_EXPR => Expr::MacroExpr(MacroExpr { syntax }),\n-            MACRO_STMTS => Expr::MacroStmts(MacroStmts { syntax }),\n             MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n             METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n             PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n@@ -3487,7 +3481,6 @@ impl AstNode for Expr {\n             Expr::Literal(it) => &it.syntax,\n             Expr::LoopExpr(it) => &it.syntax,\n             Expr::MacroExpr(it) => &it.syntax,\n-            Expr::MacroStmts(it) => &it.syntax,\n             Expr::MatchExpr(it) => &it.syntax,\n             Expr::MethodCallExpr(it) => &it.syntax,\n             Expr::ParenExpr(it) => &it.syntax,"}]}