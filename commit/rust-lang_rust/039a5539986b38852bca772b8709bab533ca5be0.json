{"sha": "039a5539986b38852bca772b8709bab533ca5be0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzOWE1NTM5OTg2YjM4ODUyYmNhNzcyYjg3MDliYWI1MzNjYTViZTA=", "commit": {"author": {"name": "Michael Sproul", "email": "micsproul@gmail.com", "date": "2015-04-07T06:49:40Z"}, "committer": {"name": "Michael Sproul", "email": "micsproul@gmail.com", "date": "2015-04-07T18:16:32Z"}, "message": "Add more extended error messages for match exprs.", "tree": {"sha": "11c4dc684bc94a3f01d1d25e5a53a8189d36f7cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11c4dc684bc94a3f01d1d25e5a53a8189d36f7cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/039a5539986b38852bca772b8709bab533ca5be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/039a5539986b38852bca772b8709bab533ca5be0", "html_url": "https://github.com/rust-lang/rust/commit/039a5539986b38852bca772b8709bab533ca5be0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/039a5539986b38852bca772b8709bab533ca5be0/comments", "author": {"login": "michaelsproul", "id": 4452260, "node_id": "MDQ6VXNlcjQ0NTIyNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelsproul", "html_url": "https://github.com/michaelsproul", "followers_url": "https://api.github.com/users/michaelsproul/followers", "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}", "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions", "organizations_url": "https://api.github.com/users/michaelsproul/orgs", "repos_url": "https://api.github.com/users/michaelsproul/repos", "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelsproul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelsproul", "id": 4452260, "node_id": "MDQ6VXNlcjQ0NTIyNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelsproul", "html_url": "https://github.com/michaelsproul", "followers_url": "https://api.github.com/users/michaelsproul/followers", "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}", "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions", "organizations_url": "https://api.github.com/users/michaelsproul/orgs", "repos_url": "https://api.github.com/users/michaelsproul/repos", "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelsproul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19e9828fb8f87c51175f638461a5b4051d022158", "url": "https://api.github.com/repos/rust-lang/rust/commits/19e9828fb8f87c51175f638461a5b4051d022158", "html_url": "https://github.com/rust-lang/rust/commit/19e9828fb8f87c51175f638461a5b4051d022158"}], "stats": {"total": 87, "additions": 81, "deletions": 6}, "files": [{"sha": "b15304d6dc50c5c5ce646efff5a4700306e39c35", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/039a5539986b38852bca772b8709bab533ca5be0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/039a5539986b38852bca772b8709bab533ca5be0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=039a5539986b38852bca772b8709bab533ca5be0", "patch": "@@ -24,14 +24,24 @@ This means that perhaps some of the preceding patterns are too general, this one\n is too specific or the ordering is incorrect.\n \"##,\n \n+E0002: r##\"\n+This error indicates that an empty match expression is illegal because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired.  This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`.\n+\"##,\n+\n E0003: r##\"\n-Not-a-Number (NaN) values can not be compared for equality and hence can never\n+Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. To match against NaN values, you should\n instead use the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n \"##,\n \n E0004: r##\"\n-This error indicates that the compiler can not guarantee a matching pattern for\n+This error indicates that the compiler cannot guarantee a matching pattern for\n one or more possible inputs to a match expression. Guaranteed matches are\n required in order to assign values to match expressions, or alternatively,\n determine the flow of execution.\n@@ -54,14 +64,80 @@ E0006: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n name will be extracted in all cases. If you encounter this error you probably need\n to use a `match` or `if let` to deal with the possibility of failure.\n+\"##,\n+\n+E0007: r##\"\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code like\n+the following is invalid as it requires the entire Option<String> to be moved\n+into a variable called `op_string` while simultaneously requiring the inner\n+String to be moved into a variable called `s`.\n+\n+let x = Some(\"s\".to_string());\n+match x {\n+    op_string @ Some(s) => ...\n+    None => ...\n+}\n+\n+See also Error 303.\n+\"##,\n+\n+E0008: r##\"\n+Names bound in match arms retain their type in pattern guards. As such, if a\n+name is bound by move in a pattern, it should also be moved to wherever it is\n+referenced in the pattern guard code. Doing so however would prevent the name\n+from being available in the body of the match arm. Consider the following:\n+\n+match Some(\"hi\".to_string()) {\n+    Some(s) if s.len() == 0 => // use s.\n+    ...\n+}\n+\n+The variable `s` has type String, and its use in the guard is as a variable of\n+type String. The guard code effectively executes in a separate scope to the body\n+of the arm, so the value would be moved into this anonymous scope and therefore\n+become unavailable in the body of the arm. Although this example seems\n+innocuous, the problem is most clear when considering functions that take their\n+argument by value.\n+\n+match Some(\"hi\".to_string()) {\n+    Some(s) if { drop(s); false } => (),\n+    Some(s) => // use s.\n+    ...\n+}\n+\n+The value would be dropped in the guard then become unavailable not only in the\n+body of that arm but also in all subsequent arms! The solution is to bind by\n+reference when using guards or refactor the entire expression, perhaps by\n+putting the condition inside the body of the arm.\n+\"##,\n+\n+E0303: r##\"\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+// Code like this...\n+match Some(5) {\n+    ref op_num @ Some(num) => ...\n+    None => ...\n+}\n+\n+// ... should be updated to code like this.\n+match Some(5) {\n+    Some(num) => {\n+        let op_num = &Some(num);\n+        ...\n+    }\n+    None => ...\n+}\n+\n+See also https://github.com/rust-lang/rust/issues/14587\n \"##\n \n }\n \n register_diagnostics! {\n-    E0002,\n-    E0007,\n-    E0008,\n     E0009,\n     E0010,\n     E0011,\n@@ -124,7 +200,6 @@ register_diagnostics! {\n     E0300, // unexpanded macro\n     E0301, // cannot mutable borrow in a pattern guard\n     E0302, // cannot assign in a pattern guard\n-    E0303, // pattern bindings are not allowed after an `@`\n     E0304, // expected signed integer constant\n     E0305, // expected constant\n     E0306, // expected positive integer for repeat count"}]}