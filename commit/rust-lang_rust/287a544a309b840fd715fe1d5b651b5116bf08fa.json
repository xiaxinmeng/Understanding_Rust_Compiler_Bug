{"sha": "287a544a309b840fd715fe1d5b651b5116bf08fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4N2E1NDRhMzA5Yjg0MGZkNzE1ZmUxZDViNjUxYjUxMTZiZjA4ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-09T01:00:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-09T01:00:37Z"}, "message": "Auto merge of #24158 - sanxiyn:cast, r=nrc\n\nFix #13993.\r\nFix #17167.", "tree": {"sha": "832884f8302321e2699db7f5ad353322ec485201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/832884f8302321e2699db7f5ad353322ec485201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/287a544a309b840fd715fe1d5b651b5116bf08fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/287a544a309b840fd715fe1d5b651b5116bf08fa", "html_url": "https://github.com/rust-lang/rust/commit/287a544a309b840fd715fe1d5b651b5116bf08fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/287a544a309b840fd715fe1d5b651b5116bf08fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6436e348e97a09c2155d0dcd710416e6e0d84371", "url": "https://api.github.com/repos/rust-lang/rust/commits/6436e348e97a09c2155d0dcd710416e6e0d84371", "html_url": "https://github.com/rust-lang/rust/commit/6436e348e97a09c2155d0dcd710416e6e0d84371"}, {"sha": "e2ff1881b2c892aab0ed721a1ecdb4309053dcab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ff1881b2c892aab0ed721a1ecdb4309053dcab", "html_url": "https://github.com/rust-lang/rust/commit/e2ff1881b2c892aab0ed721a1ecdb4309053dcab"}], "stats": {"total": 378, "additions": 224, "deletions": 154}, "files": [{"sha": "3773ff7078e9c33549a104effc70b8adf1b2be38", "filename": "src/librustc_typeck/check/cast.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=287a544a309b840fd715fe1d5b651b5116bf08fa", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for type-checking cast expressions.\n+\n+use super::coercion;\n+use super::demand;\n+use super::FnCtxt;\n+use super::structurally_resolved_type;\n+\n+use lint;\n+use middle::infer;\n+use middle::ty;\n+use middle::ty::Ty;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+/// Reifies a cast check to be checked once we have full type information for\n+/// a function context.\n+pub struct CastCheck<'tcx> {\n+    expr: ast::Expr,\n+    expr_ty: Ty<'tcx>,\n+    cast_ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n+impl<'tcx> CastCheck<'tcx> {\n+    pub fn new(expr: ast::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n+               -> CastCheck<'tcx> {\n+        CastCheck {\n+            expr: expr,\n+            expr_ty: expr_ty,\n+            cast_ty: cast_ty,\n+            span: span,\n+        }\n+    }\n+}\n+\n+pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n+    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          t_1: Ty<'tcx>,\n+                                          t_e: Ty<'tcx>) {\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"illegal cast; cast through an \\\n+                    integer first: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_string(t_1))\n+        }, t_e, None);\n+    }\n+\n+    let span = cast.span;\n+    let e = &cast.expr;\n+    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n+    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n+\n+    // Check for trivial casts.\n+    if !ty::type_has_ty_infer(t_1) {\n+        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n+            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n+                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                        e.id,\n+                                        span,\n+                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                                 replaced by coercion, this might require type \\\n+                                                 ascription or a temporary variable\",\n+                                                fcx.infcx().ty_to_string(t_e),\n+                                                fcx.infcx().ty_to_string(t_1)));\n+            } else {\n+                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                        e.id,\n+                                        span,\n+                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                                 replaced by coercion, this might require type \\\n+                                                 ascription or a temporary variable\",\n+                                                fcx.infcx().ty_to_string(t_e),\n+                                                fcx.infcx().ty_to_string(t_1)));\n+            }\n+            return;\n+        }\n+    }\n+\n+    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n+    let t_e_is_scalar = ty::type_is_scalar(t_e);\n+    let t_e_is_integral = ty::type_is_integral(t_e);\n+    let t_e_is_float = ty::type_is_floating_point(t_e);\n+    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n+\n+    let t_1_is_scalar = ty::type_is_scalar(t_1);\n+    let t_1_is_integral = ty::type_is_integral(t_1);\n+    let t_1_is_char = ty::type_is_char(t_1);\n+    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n+    let t_1_is_float = ty::type_is_floating_point(t_1);\n+    let t_1_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_1);\n+\n+    // casts to scalars other than `char` and `bare fn` are trivial\n+    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+\n+    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n+        demand::coerce(fcx, e.span, t_1, &e);\n+    } else if t_1_is_char {\n+        let t_e = fcx.infcx().shallow_resolve(t_e);\n+        if t_e.sty != ty::ty_uint(ast::TyU8) {\n+            fcx.type_error_message(span, |actual| {\n+                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n+            }, t_e, None);\n+        }\n+    } else if t_1.sty == ty::ty_bool {\n+        span_err!(fcx.tcx().sess, span, E0054,\n+                  \"cannot cast as `bool`, compare with zero instead\");\n+    } else if t_e_is_float && (t_1_is_scalar || t_1_is_c_enum) &&\n+        !(t_1_is_integral || t_1_is_float) {\n+        // Casts from float must go through an integer\n+        cast_through_integer_err(fcx, span, t_1, t_e)\n+    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) &&\n+        !(t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n+        // Casts to float must go through an integer or boolean\n+        cast_through_integer_err(fcx, span, t_1, t_e)\n+    } else if t_e_is_c_enum && t_1_is_trivial {\n+        if ty::type_is_unsafe_ptr(t_1) {\n+            // ... and likewise with C enum -> *T\n+            cast_through_integer_err(fcx, span, t_1, t_e)\n+        }\n+        // casts from C-like enums are allowed\n+    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n+        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n+            match t1.sty {\n+                ty::ty_vec(_, Some(_)) => {}\n+                _ => return false\n+            }\n+            if ty::type_needs_infer(t2) {\n+                // This prevents this special case from going off when casting\n+                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n+                // #14893.)\n+                return false\n+            }\n+\n+            let el = ty::sequence_element_type(fcx.tcx(), t1);\n+            infer::mk_eqty(fcx.infcx(),\n+                           false,\n+                           infer::Misc(sp),\n+                           el,\n+                           t2).is_ok()\n+        }\n+\n+        // Due to the limitations of LLVM global constants,\n+        // region pointers end up pointing at copies of\n+        // vector elements instead of the original values.\n+        // To allow unsafe pointers to work correctly, we\n+        // need to special-case obtaining an unsafe pointer\n+        // from a region pointer to a vector.\n+\n+        /* this cast is only allowed from &[T, ..n] to *T or\n+        &T to *T. */\n+        match (&t_e.sty, &t_1.sty) {\n+            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n+             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n+            if types_compatible(fcx, e.span, mt1, mt2) => {\n+                /* this case is allowed */\n+            }\n+            _ => {\n+                demand::coerce(fcx, e.span, t_1, &e);\n+            }\n+        }\n+    } else if fcx.type_is_fat_ptr(t_e, span) && !fcx.type_is_fat_ptr(t_1, span) {\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"illegal cast; cast from fat pointer: `{}` as `{}`\",\n+                    actual, fcx.infcx().ty_to_string(t_1))\n+        }, t_e, None);\n+    } else if !(t_e_is_scalar && t_1_is_trivial) {\n+        /*\n+        If more type combinations should be supported than are\n+        supported here, then file an enhancement issue and\n+        record the issue number in this comment.\n+        */\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"non-scalar cast: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_string(t_1))\n+        }, t_e, None);\n+    }\n+}"}, {"sha": "f7bbc693ce59b9e3e285fab6c821e5286281946b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 152, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=287a544a309b840fd715fe1d5b651b5116bf08fa", "patch": "@@ -139,6 +139,7 @@ pub mod demand;\n pub mod method;\n mod upvar;\n pub mod wf;\n+mod cast;\n mod closure;\n mod callee;\n mod compare_method;\n@@ -185,7 +186,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // back and process them.\n     deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'tcx>>>>,\n \n-    deferred_cast_checks: RefCell<Vec<CastCheck<'tcx>>>,\n+    deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n }\n \n trait DeferredCallResolution<'tcx> {\n@@ -194,15 +195,6 @@ trait DeferredCallResolution<'tcx> {\n \n type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx>;\n \n-/// Reifies a cast check to be checked once we have full type information for\n-/// a function context.\n-struct CastCheck<'tcx> {\n-    expr: ast::Expr,\n-    expr_ty: Ty<'tcx>,\n-    cast_ty: Ty<'tcx>,\n-    span: Span,\n-}\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy, Clone)]\n@@ -1071,141 +1063,6 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n \n-fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n-    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          span: Span,\n-                                          t_1: Ty<'tcx>,\n-                                          t_e: Ty<'tcx>) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast through an \\\n-                    integer first: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n-    }\n-\n-    let span = cast.span;\n-    let e = &cast.expr;\n-    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n-    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n-\n-    // Check for trivial casts.\n-    if !ty::type_has_ty_infer(t_1) {\n-        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n-            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n-            } else {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n-            }\n-            return;\n-        }\n-    }\n-\n-    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n-    let t_e_is_scalar = ty::type_is_scalar(t_e);\n-    let t_e_is_integral = ty::type_is_integral(t_e);\n-    let t_e_is_float = ty::type_is_floating_point(t_e);\n-    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n-\n-    let t_1_is_scalar = ty::type_is_scalar(t_1);\n-    let t_1_is_char = ty::type_is_char(t_1);\n-    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n-    let t_1_is_float = ty::type_is_floating_point(t_1);\n-\n-    // casts to scalars other than `char` and `bare fn` are trivial\n-    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-\n-    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n-        demand::coerce(fcx, e.span, t_1, &e);\n-    } else if t_1_is_char {\n-        let t_e = fcx.infcx().shallow_resolve(t_e);\n-        if t_e.sty != ty::ty_uint(ast::TyU8) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-            }, t_e, None);\n-        }\n-    } else if t_1.sty == ty::ty_bool {\n-        span_err!(fcx.tcx().sess, span, E0054,\n-                  \"cannot cast as `bool`, compare with zero instead\");\n-    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) && !(\n-        t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n-        // Casts to float must go through an integer or boolean\n-        cast_through_integer_err(fcx, span, t_1, t_e)\n-    } else if t_e_is_c_enum && t_1_is_trivial {\n-        if ty::type_is_unsafe_ptr(t_1) {\n-            // ... and likewise with C enum -> *T\n-            cast_through_integer_err(fcx, span, t_1, t_e)\n-        }\n-        // casts from C-like enums are allowed\n-    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n-            match t1.sty {\n-                ty::ty_vec(_, Some(_)) => {}\n-                _ => return false\n-            }\n-            if ty::type_needs_infer(t2) {\n-                // This prevents this special case from going off when casting\n-                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n-                // #14893.)\n-                return false\n-            }\n-\n-            let el = ty::sequence_element_type(fcx.tcx(), t1);\n-            infer::mk_eqty(fcx.infcx(),\n-                           false,\n-                           infer::Misc(sp),\n-                           el,\n-                           t2).is_ok()\n-        }\n-\n-        // Due to the limitations of LLVM global constants,\n-        // region pointers end up pointing at copies of\n-        // vector elements instead of the original values.\n-        // To allow unsafe pointers to work correctly, we\n-        // need to special-case obtaining an unsafe pointer\n-        // from a region pointer to a vector.\n-\n-        /* this cast is only allowed from &[T, ..n] to *T or\n-        &T to *T. */\n-        match (&t_e.sty, &t_1.sty) {\n-            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n-             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n-            if types_compatible(fcx, e.span, mt1, mt2) => {\n-                /* this case is allowed */\n-            }\n-            _ => {\n-                demand::coerce(fcx, e.span, t_1, &e);\n-            }\n-        }\n-    } else if !(t_e_is_scalar && t_1_is_trivial) {\n-        /*\n-        If more type combinations should be supported than are\n-        supported here, then file an enhancement issue and\n-        record the issue number in this comment.\n-        */\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"non-scalar cast: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n-    }\n-}\n-\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n@@ -1702,6 +1559,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                  span)\n     }\n \n+    pub fn type_is_fat_ptr(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        if let Some(mt) = ty::deref(ty, true) {\n+            return !self.type_is_known_to_be_sized(mt.ty, span);\n+        }\n+        false\n+    }\n+\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -1925,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n         for check in deferred_cast_checks.iter() {\n-            check_cast(self, check);\n+            cast::check_cast(self, check);\n         }\n \n         deferred_cast_checks.clear();\n@@ -3537,12 +3401,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            deferred_cast_checks.push(CastCheck {\n-                expr: (**e).clone(),\n-                expr_ty: t_e,\n-                cast_ty: t_1,\n-                span: expr.span,\n-            });\n+            let cast_check = cast::CastCheck::new((**e).clone(), t_e, t_1, expr.span);\n+            deferred_cast_checks.push(cast_check);\n         }\n       }\n       ast::ExprVec(ref args) => {"}, {"sha": "ac5969410fc0122788afef4f00cf06380f97239d", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=287a544a309b840fd715fe1d5b651b5116bf08fa", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a: &[i32] = &[1, 2, 3];\n+    let b: Box<[i32]> = Box::new([1, 2, 3]);\n+    let p = a as *const [i32];\n+\n+    a as usize; //~ ERROR cast from fat pointer\n+    b as usize; //~ ERROR cast from fat pointer\n+    p as usize; //~ ERROR cast from fat pointer\n+}"}, {"sha": "b4246f2ed87f3009e181b2a501f31cd8e42e4d80", "filename": "src/test/compile-fail/unsupported-cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287a544a309b840fd715fe1d5b651b5116bf08fa/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs?ref=287a544a309b840fd715fe1d5b651b5116bf08fa", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test FIXME: #13993\n-// error-pattern:unsupported cast\n+// error-pattern:illegal cast\n+\n+#![feature(libc)]\n \n extern crate libc;\n "}]}