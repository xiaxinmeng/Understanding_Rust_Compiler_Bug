{"sha": "5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNDRkMzIyMmY3NmIxZjBiN2M0YmZmYmZmNWViYzQwYTI5YzNjNjM=", "commit": {"author": {"name": "Ramana Venkata", "email": "vramana@users.noreply.github.com", "date": "2017-11-12T16:19:02Z"}, "committer": {"name": "Ramana Venkata", "email": "vramana@users.noreply.github.com", "date": "2017-11-14T20:54:25Z"}, "message": "Fix printing of upvar in closures", "tree": {"sha": "cff2d2fef00925c5628bf5bf37cfd058ca9338ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cff2d2fef00925c5628bf5bf37cfd058ca9338ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "html_url": "https://github.com/rust-lang/rust/commit/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63/comments", "author": {"login": "vramana", "id": 3112509, "node_id": "MDQ6VXNlcjMxMTI1MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3112509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vramana", "html_url": "https://github.com/vramana", "followers_url": "https://api.github.com/users/vramana/followers", "following_url": "https://api.github.com/users/vramana/following{/other_user}", "gists_url": "https://api.github.com/users/vramana/gists{/gist_id}", "starred_url": "https://api.github.com/users/vramana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vramana/subscriptions", "organizations_url": "https://api.github.com/users/vramana/orgs", "repos_url": "https://api.github.com/users/vramana/repos", "events_url": "https://api.github.com/users/vramana/events{/privacy}", "received_events_url": "https://api.github.com/users/vramana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vramana", "id": 3112509, "node_id": "MDQ6VXNlcjMxMTI1MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3112509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vramana", "html_url": "https://github.com/vramana", "followers_url": "https://api.github.com/users/vramana/followers", "following_url": "https://api.github.com/users/vramana/following{/other_user}", "gists_url": "https://api.github.com/users/vramana/gists{/gist_id}", "starred_url": "https://api.github.com/users/vramana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vramana/subscriptions", "organizations_url": "https://api.github.com/users/vramana/orgs", "repos_url": "https://api.github.com/users/vramana/repos", "events_url": "https://api.github.com/users/vramana/events{/privacy}", "received_events_url": "https://api.github.com/users/vramana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6d691b43c9c967dbd41c6850a9c71e96482fa9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d691b43c9c967dbd41c6850a9c71e96482fa9c", "html_url": "https://github.com/rust-lang/rust/commit/a6d691b43c9c967dbd41c6850a9c71e96482fa9c"}], "stats": {"total": 106, "additions": 70, "deletions": 36}, "files": [{"sha": "2a7a62cd64b59e937b3dec67f234d73002f29b51", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "patch": "@@ -11,7 +11,6 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n use rustc::hir;\n-use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n@@ -1022,7 +1021,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                      access_lvalue: (ShallowOrDeep, &Lvalue<'tcx>),\n                                      flow_state: &InProgress<'b, 'gcx, 'tcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue<'tcx>) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -1249,7 +1248,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: &str,\n-                           (lvalue, span): (&Lvalue, Span),\n+                           (lvalue, span): (&Lvalue<'tcx>, Span),\n                            mpi: MovePathIndex,\n                            curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n \n@@ -1291,8 +1290,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_move_out_while_borrowed(&mut self,\n                                       _context: Context,\n-                                      (lvalue, span): (&Lvalue, Span),\n-                                      borrow: &BorrowData) {\n+                                      (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                      borrow: &BorrowData<'tcx>) {\n         self.tcx.cannot_move_when_borrowed(span,\n                                            &self.describe_lvalue(lvalue),\n                                            Origin::Mir)\n@@ -1306,8 +1305,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_use_while_mutably_borrowed(&mut self,\n                                          _context: Context,\n-                                         (lvalue, span): (&Lvalue, Span),\n-                                         borrow : &BorrowData) {\n+                                         (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                         borrow : &BorrowData<'tcx>) {\n \n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n             span, &self.describe_lvalue(lvalue),\n@@ -1383,8 +1382,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_conflicting_borrow(&mut self,\n                                  context: Context,\n-                                 common_prefix: &Lvalue,\n-                                 (lvalue, span): (&Lvalue, Span),\n+                                 common_prefix: &Lvalue<'tcx>,\n+                                 (lvalue, span): (&Lvalue<'tcx>, Span),\n                                  gen_borrow_kind: BorrowKind,\n                                  issued_borrow: &BorrowData,\n                                  end_issued_loan_span: Option<Span>) {\n@@ -1454,7 +1453,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_illegal_mutation_of_borrowed(&mut self,\n                                            _: Context,\n-                                           (lvalue, span): (&Lvalue, Span),\n+                                           (lvalue, span): (&Lvalue<'tcx>, Span),\n                                            loan: &BorrowData) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n             span, self.retrieve_borrow_span(loan), &self.describe_lvalue(lvalue), Origin::Mir);\n@@ -1464,7 +1463,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_illegal_reassignment(&mut self,\n                                    _context: Context,\n-                                   (lvalue, span): (&Lvalue, Span),\n+                                   (lvalue, span): (&Lvalue<'tcx>, Span),\n                                    assigned_span: Span) {\n         self.tcx.cannot_reassign_immutable(span,\n                                            &self.describe_lvalue(lvalue),\n@@ -1475,7 +1474,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 .emit();\n     }\n \n-    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+    fn report_assignment_to_static(&mut self,\n+                                   _context: Context,\n+                                   (lvalue, span): (&Lvalue<'tcx>, Span)) {\n         let mut err = self.tcx.cannot_assign_static(\n             span, &self.describe_lvalue(lvalue), Origin::Mir);\n         err.emit();\n@@ -1484,14 +1485,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     // End-user visible description of `lvalue`\n-    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n+    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> String {\n         let mut buf = String::new();\n         self.append_lvalue_to_string(lvalue, &mut buf, None);\n         buf\n     }\n \n     // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String, autoderef: Option<bool>) {\n+    fn append_lvalue_to_string(&self,\n+                               lvalue: &Lvalue<'tcx>,\n+                               buf: &mut String,\n+                               autoderef: Option<bool>) {\n         match *lvalue {\n             Lvalue::Local(local) => {\n                 self.append_local_to_string(local, buf, \"_\");\n@@ -1501,41 +1505,50 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n             Lvalue::Projection(ref proj) => {\n                 let mut autoderef = autoderef.unwrap_or(false);\n-                let (prefix, suffix, index_operand) = match proj.elem {\n+\n+                match proj.elem {\n                     ProjectionElem::Deref => {\n                         if autoderef {\n-                            (\"\", format!(\"\"), None)\n+                            self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n                         } else {\n-                            (\"(*\", format!(\")\"), None)\n+                            buf.push_str(&\"(*\");\n+                            self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                            buf.push_str(&\")\");\n                         }\n                     },\n-                    ProjectionElem::Downcast(..) =>\n-                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n+                    ProjectionElem::Downcast(..) => {\n+                        self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                    },\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n-                        (\"\", format!(\".{}\", self.describe_field(&proj.base, field.index())), None)\n+                        let is_projection_from_ty_closure = proj.base.ty(self.mir, self.tcx)\n+                                .to_ty(self.tcx).is_closure();\n+\n+                        let field_name = self.describe_field(&proj.base, field.index());\n+                        if is_projection_from_ty_closure {\n+                            buf.push_str(&format!(\"{}\", field_name));\n+                        } else {\n+                            self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                            buf.push_str(&format!(\".{}\", field_name));\n+                        }\n                     },\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n-                        (\"\",   format!(\"\"), Some(index))\n+\n+                        self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                        buf.push_str(\"[\");\n+                        self.append_local_to_string(index, buf, \"..\");\n+                        buf.push_str(\"]\");\n                     },\n                     ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n                         autoderef = true;\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        (\"\",   format!(\"[..]\"), None)\n+                        self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                        buf.push_str(&\"[..]\");\n                     },\n                 };\n-                buf.push_str(prefix);\n-                self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n-                if let Some(index) = index_operand {\n-                    buf.push_str(\"[\");\n-                    self.append_local_to_string(index, buf, \"..\");\n-                    buf.push_str(\"]\");\n-                } else {\n-                    buf.push_str(&suffix);\n-                }\n             }\n         }\n     }\n@@ -1609,12 +1622,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n                     let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n-                    let local_def = self.tcx.with_freevars(node_id, |fv| fv[field_index].def);\n+                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field_index]);\n \n-                    match local_def {\n-                        Def::Local(local_node_id) => self.tcx.hir.name(local_node_id).to_string(),\n-                        _ => unreachable!()\n-                    }\n+                    self.tcx.hir.name(freevar.var_id()).to_string()\n                  }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented"}, {"sha": "06d61242ec2f88ef892fd01916c9d174f30aa99b", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "patch": "@@ -327,4 +327,28 @@ fn main() {\n             _ => panic!(\"other case\")\n         }\n     }\n+    // Field from upvar\n+    {\n+        let mut x = 0;\n+        || {\n+            let y = &mut x;\n+            &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n+                    //[mir]~^ ERROR cannot borrow `**x` as mutable more than once at a time (Ast)\n+                    //[mir]~| ERROR cannot borrow `(*x)` as mutable more than once at a time (Mir)\n+            *y = 1;\n+        };\n+    }\n+    // Field from upvar nested\n+    {\n+        let mut x = 0;\n+           || {\n+               || {\n+                let y = &mut x;\n+                &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n+                        //[mir]~^ ERROR cannot borrow `**x` as mutable more than once at a time (Ast)\n+                        //[mir]~| ERROR cannot borrow `(*x)` as mutable more than once at a time (Mir)\n+                *y = 1;\n+                }\n+           };\n+    }\n }"}]}