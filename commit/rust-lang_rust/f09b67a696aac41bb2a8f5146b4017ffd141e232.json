{"sha": "f09b67a696aac41bb2a8f5146b4017ffd141e232", "node_id": "C_kwDOAAsO6NoAKGYwOWI2N2E2OTZhYWM0MWJiMmE4ZjUxNDZiNDAxN2ZmZDE0MWUyMzI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-10-23T21:26:29Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-10-29T12:37:01Z"}, "message": "Fix panic when documenting libproc-macro", "tree": {"sha": "36dfd3ec7435e395bf5320148ade758249c8bea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36dfd3ec7435e395bf5320148ade758249c8bea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f09b67a696aac41bb2a8f5146b4017ffd141e232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f09b67a696aac41bb2a8f5146b4017ffd141e232", "html_url": "https://github.com/rust-lang/rust/commit/f09b67a696aac41bb2a8f5146b4017ffd141e232", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f09b67a696aac41bb2a8f5146b4017ffd141e232/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd68d207a5713850f757b7355e175021062db059", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd68d207a5713850f757b7355e175021062db059", "html_url": "https://github.com/rust-lang/rust/commit/dd68d207a5713850f757b7355e175021062db059"}], "stats": {"total": 23, "additions": 10, "deletions": 13}, "files": [{"sha": "9ccc4e5b89f76ba83130e74e42d99d7dc7c81a43", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f09b67a696aac41bb2a8f5146b4017ffd141e232/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09b67a696aac41bb2a8f5146b4017ffd141e232/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=f09b67a696aac41bb2a8f5146b4017ffd141e232", "patch": "@@ -66,7 +66,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n             debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n             if let Some(target_prim) = target.primitive_type() {\n                 cleaner.prims.insert(target_prim);\n-            } else if let Some(target_did) = target.def_id() {\n+            } else if let Some(target_did) = target.def_id_no_primitives() {\n                 // `impl Deref<Target = S> for S`\n                 if target_did == type_did {\n                     // Avoid infinite cycles\n@@ -82,7 +82,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     for it in &new_items {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n             if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n-                && cleaner.keep_impl(for_)\n+                && cleaner.keep_impl(for_, true)\n             {\n                 let target = items\n                     .iter()\n@@ -97,7 +97,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                 } else if let Some(did) = target.def_id(&cx.cache) {\n                     cleaner.items.insert(did.into());\n                 }\n-                if let Some(for_did) = for_.def_id() {\n+                if let Some(for_did) = for_.def_id_no_primitives() {\n                     if type_did_to_deref_target.insert(for_did, target).is_none() {\n                         // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n                         // `Deref` target type and the impl for type positions, this map of types is keyed by\n@@ -113,10 +113,10 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n     new_items.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_impl(for_)\n-                || trait_\n-                    .as_ref()\n-                    .map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n+            cleaner.keep_impl(\n+                for_,\n+                trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n+            ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || blanket_impl.is_some()\n         } else {\n             true\n@@ -215,17 +215,14 @@ struct BadImplStripper {\n }\n \n impl BadImplStripper {\n-    fn keep_impl(&self, ty: &Type) -> bool {\n+    fn keep_impl(&self, ty: &Type, is_deref: bool) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n-        } else if ty.def_id_no_primitives().is_some() {\n-            // We want to keep *ALL* deref implementations in case some of them are used in\n-            // the current crate.\n-            // FIXME: Try to filter the one actually used...\n-            true\n+        } else if let Some(did) = ty.def_id_no_primitives() {\n+            is_deref || self.keep_impl_with_def_id(did.into())\n         } else {\n             false\n         }"}]}