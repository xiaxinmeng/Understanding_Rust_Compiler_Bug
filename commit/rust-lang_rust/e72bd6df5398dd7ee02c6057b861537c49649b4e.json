{"sha": "e72bd6df5398dd7ee02c6057b861537c49649b4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MmJkNmRmNTM5OGRkN2VlMDJjNjA1N2I4NjE1MzdjNDk2NDliNGU=", "commit": {"author": {"name": "Vitali Lovich", "email": "vlovich@google.com", "date": "2018-02-02T20:07:16Z"}, "committer": {"name": "Vitali Lovich", "email": "vlovich@google.com", "date": "2018-02-02T20:13:48Z"}, "message": "Review response\n\nMake condition closure accept mut T&.\nClarify spurious wakeup documentation.\nCleanup doc example code.", "tree": {"sha": "1ca163501d777cdd8b3ad5f2fbc2ba25c64461b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ca163501d777cdd8b3ad5f2fbc2ba25c64461b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e72bd6df5398dd7ee02c6057b861537c49649b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e72bd6df5398dd7ee02c6057b861537c49649b4e", "html_url": "https://github.com/rust-lang/rust/commit/e72bd6df5398dd7ee02c6057b861537c49649b4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e72bd6df5398dd7ee02c6057b861537c49649b4e/comments", "author": null, "committer": null, "parents": [{"sha": "404e1a67007a254ab35e4fe8a8650e9335590a76", "url": "https://api.github.com/repos/rust-lang/rust/commits/404e1a67007a254ab35e4fe8a8650e9335590a76", "html_url": "https://github.com/rust-lang/rust/commit/404e1a67007a254ab35e4fe8a8650e9335590a76"}], "stats": {"total": 18, "additions": 10, "deletions": 8}, "files": [{"sha": "76b68fc4f4fe93bb28bf454e7b0e0170fe7ecf7d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e72bd6df5398dd7ee02c6057b861537c49649b4e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72bd6df5398dd7ee02c6057b861537c49649b4e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=e72bd6df5398dd7ee02c6057b861537c49649b4e", "patch": "@@ -220,8 +220,9 @@ impl Condvar {\n     }\n \n     /// Blocks the current thread until this condition variable receives a\n-    /// notification and the required condition is met. There are no spurious\n-    /// wakeups when calling this.\n+    /// notification and the required condition is met. Spurious wakeups are\n+    /// ignored and this function will only return once the condition has been\n+    /// met.\n     ///\n     /// This function will atomically unlock the mutex specified (represented by\n     /// `guard`) and block the current thread. This means that any calls\n@@ -260,14 +261,14 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// // As long as the value inside the `Mutex` is false, we wait.\n-    /// cvar.wait_until(lock.lock().unwrap(), |ref started| { started });\n+    /// cvar.wait_until(lock.lock().unwrap(), |started| { started });\n     /// ```\n     #[stable(feature = \"wait_until\", since = \"1.24\")]\n     pub fn wait_until<'a, T, F>(&self, mut guard: MutexGuard<'a, T>,\n                                 mut condition: F)\n                                 -> LockResult<MutexGuard<'a, T>>\n-                                where F: FnMut(&T) -> bool {\n-        while !condition(&*guard) {\n+                                where F: FnMut(&mut T) -> bool {\n+        while !condition(&mut *guard) {\n             guard = self.wait(guard)?;\n         }\n         Ok(guard)\n@@ -418,7 +419,8 @@ impl Condvar {\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n+    /// specified duration.  Spurious wakes will not cause this function to\n+    /// return.\n     ///\n     /// The semantics of this function are equivalent to [`wait_until`] except\n     /// that the thread will be blocked for roughly no longer than `dur`. This\n@@ -472,10 +474,10 @@ impl Condvar {\n     pub fn wait_timeout_until<'a, T, F>(&self, mut guard: MutexGuard<'a, T>,\n                                         mut dur: Duration, mut condition: F)\n                                         -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n-                                        where F: FnMut(&T) -> bool {\n+                                        where F: FnMut(&mut T) -> bool {\n         let timed_out = Duration::new(0, 0);\n         loop {\n-            if !condition(&*guard) {\n+            if !condition(&mut *guard) {\n                 return Ok((guard, WaitTimeoutResult(false)));\n             } else if dur == timed_out {\n                 return Ok((guard, WaitTimeoutResult(true)));"}]}