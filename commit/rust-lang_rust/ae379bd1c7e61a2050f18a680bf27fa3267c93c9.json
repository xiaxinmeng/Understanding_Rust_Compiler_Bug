{"sha": "ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMzc5YmQxYzdlNjFhMjA1MGYxOGE2ODBiZjI3ZmEzMjY3YzkzYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-11T04:34:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-11T04:34:07Z"}, "message": "Auto merge of #48691 - Zoxc:profq-chan, r=michaelwoerister\n\nMove PROFQ_CHAN to a Session field\n\nr? @michaelwoerister", "tree": {"sha": "8841b8dee197a217b346e1b3ca9488f9cf53a8ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8841b8dee197a217b346e1b3ca9488f9cf53a8ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "html_url": "https://github.com/rust-lang/rust/commit/ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bae326f6d3b647ebd01901854b0920976780755", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bae326f6d3b647ebd01901854b0920976780755", "html_url": "https://github.com/rust-lang/rust/commit/0bae326f6d3b647ebd01901854b0920976780755"}, {"sha": "184fd32a0334a81315e7ad2cfc8139e2c7341a62", "url": "https://api.github.com/repos/rust-lang/rust/commits/184fd32a0334a81315e7ad2cfc8139e2c7341a62", "html_url": "https://github.com/rust-lang/rust/commit/184fd32a0334a81315e7ad2cfc8139e2c7341a62"}], "stats": {"total": 345, "additions": 175, "deletions": 170}, "files": [{"sha": "210bdd8d5ddca7ae8758eceff5814dd280246282", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use errors::DiagnosticBuilder;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHashingContextProvider};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n@@ -20,7 +19,7 @@ use std::hash::Hash;\n use ty::TyCtxt;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n-use ich::Fingerprint;\n+use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n@@ -189,47 +188,49 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/incremental-compilation.html\n-    pub fn with_task<C, A, R, HCX>(&self,\n+    pub fn with_task<'gcx, C, A, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    arg: A,\n                                    task: fn(C, A) -> R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, task,\n             |data, key| data.borrow_mut().push_task(key),\n             |data, key| data.borrow_mut().pop_task(key))\n     }\n \n-    fn with_task_impl<C, A, R, HCX>(&self,\n+    fn with_task_impl<'gcx, C, A, R>(&self,\n                                     key: DepNode,\n                                     cx: C,\n                                     arg: A,\n                                     task: fn(C, A) -> R,\n                                     push: fn(&RefCell<CurrentDepGraph>, DepNode),\n                                     pop: fn(&RefCell<CurrentDepGraph>, DepNode) -> DepNodeIndex)\n                                     -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         if let Some(ref data) = self.data {\n             push(&data.current, key);\n-            if cfg!(debug_assertions) {\n-                profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n \n             // In incremental mode, hash the result of the task. We don't\n             // do anything with the hash yet, but we are computing it\n             // anyway so that\n             //  - we make sure that the infrastructure works and\n             //  - we can get an idea of the runtime cost.\n-            let mut hcx = cx.create_stable_hashing_context();\n+            let mut hcx = cx.get_stable_hashing_context();\n+\n+            if cfg!(debug_assertions) {\n+                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n+            };\n \n             let result = task(cx, arg);\n+\n             if cfg!(debug_assertions) {\n-                profq_msg(ProfileQueriesMsg::TaskEnd)\n+                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n             let dep_node_index = pop(&data.current, key);\n@@ -274,7 +275,7 @@ impl DepGraph {\n             (result, dep_node_index)\n         } else {\n             if key.kind.fingerprint_needed_for_crate_hash() {\n-                let mut hcx = cx.create_stable_hashing_context();\n+                let mut hcx = cx.get_stable_hashing_context();\n                 let result = task(cx, arg);\n                 let mut stable_hasher = StableHasher::new();\n                 result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -314,14 +315,14 @@ impl DepGraph {\n \n     /// Execute something within an \"eval-always\" task which is a task\n     // that runs whenever anything changes.\n-    pub fn with_eval_always_task<C, A, R, HCX>(&self,\n+    pub fn with_eval_always_task<'gcx, C, A, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    arg: A,\n                                    task: fn(C, A) -> R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, task,\n             |data, key| data.borrow_mut().push_eval_always_task(key),"}, {"sha": "33e0d0e69449756e7199ae9f45fb78244ef26801", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -30,7 +30,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n+use rustc_data_structures::stable_hasher::{HashStable,\n                                            StableHasher, StableHasherResult,\n                                            ToStableHashKey};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -192,17 +192,33 @@ impl<'a> StableHashingContext<'a> {\n     }\n }\n \n-impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n-    type ContextType = StableHashingContext<'a>;\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        (*self).create_stable_hashing_context()\n+/// Something that can provide a stable hashing context.\n+pub trait StableHashingContextProvider<'a> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a>;\n+}\n+\n+impl<'a, 'b, T: StableHashingContextProvider<'a>> StableHashingContextProvider<'a>\n+for &'b T {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+        (**self).get_stable_hashing_context()\n     }\n }\n \n+impl<'a, 'b, T: StableHashingContextProvider<'a>> StableHashingContextProvider<'a>\n+for &'b mut T {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+        (**self).get_stable_hashing_context()\n+    }\n+}\n+\n+impl<'a, 'gcx, 'lcx> StableHashingContextProvider<'a> for TyCtxt<'a, 'gcx, 'lcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+        (*self).create_stable_hashing_context()\n+    }\n+}\n \n-impl<'a> StableHashingContextProvider for StableHashingContext<'a> {\n-    type ContextType = StableHashingContext<'a>;\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n         self.clone()\n     }\n }"}, {"sha": "1b77a2e7c82b985d119b0fbdef3d9dd2e1c18d7e", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -12,7 +12,7 @@\n \n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n-pub use self::hcx::{StableHashingContext, NodeIdHashingMode,\n+pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls, compute_ignored_attr_names};\n mod fingerprint;\n mod caching_codemap_view;"}, {"sha": "01e1037b6222ad0474981ad33f2d73da58a16dd6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -24,8 +24,9 @@ use session::config::{DebugInfoLevel, OutputType};\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n+use util::common::ProfileQueriesMsg;\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock};\n \n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder, DiagnosticId};\n@@ -53,6 +54,7 @@ use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::sync::{Once, ONCE_INIT};\n use std::time::Duration;\n+use std::sync::mpsc;\n \n mod code_stats;\n pub mod config;\n@@ -126,6 +128,9 @@ pub struct Session {\n     /// A cache of attributes ignored by StableHashingContext\n     pub ignored_attr_names: FxHashSet<Symbol>,\n \n+    /// Used by -Z profile-queries in util::common\n+    pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n+\n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n \n@@ -1131,6 +1136,7 @@ pub fn build_session_(\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n         ignored_attr_names: ich::compute_ignored_attr_names(),\n+        profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             svh_time: Cell::new(Duration::from_secs(0)),\n             incr_comp_hashes_time: Cell::new(Duration::from_secs(0)),"}, {"sha": "68d108889020509b0b12c1fdacbbb9d7dcefeba6", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -164,8 +164,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n         if cfg!(debug_assertions) {\n-            if  $tcx.sess.profile_queries() {\n-                profq_msg($msg)\n+            if $tcx.sess.profile_queries() {\n+                profq_msg($tcx.sess, $msg)\n             }\n         }\n     }"}, {"sha": "e1ae41f24721acd860ca8fdf53446c336ff740bf", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -26,6 +26,7 @@ use ty::maps::{QueryMsg};\n use dep_graph::{DepNode};\n use proc_macro;\n use lazy_static;\n+use session::Session;\n \n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n@@ -55,9 +56,6 @@ pub fn install_panic_hook() {\n     lazy_static::initialize(&DEFAULT_HOOK);\n }\n \n-/// Initialized for -Z profile-queries\n-thread_local!(static PROFQ_CHAN: RefCell<Option<Sender<ProfileQueriesMsg>>> = RefCell::new(None));\n-\n /// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n #[derive(Clone,Debug)]\n pub struct ProfQDumpParams {\n@@ -97,29 +95,23 @@ pub enum ProfileQueriesMsg {\n }\n \n /// If enabled, send a message to the profile-queries thread\n-pub fn profq_msg(msg: ProfileQueriesMsg) {\n-    PROFQ_CHAN.with(|sender|{\n-        if let Some(s) = sender.borrow().as_ref() {\n-            s.send(msg).unwrap()\n-        } else {\n-            // Do nothing.\n-            //\n-            // FIXME(matthewhammer): Multi-threaded translation phase triggers the panic below.\n-            // From backtrace: rustc_trans::back::write::spawn_work::{{closure}}.\n-            //\n-            // panic!(\"no channel on which to send profq_msg: {:?}\", msg)\n-        }\n-    })\n+pub fn profq_msg(sess: &Session, msg: ProfileQueriesMsg) {\n+    if let Some(s) = sess.profile_channel.borrow().as_ref() {\n+        s.send(msg).unwrap()\n+    } else {\n+        // Do nothing\n+    }\n }\n \n /// Set channel for profile queries channel\n-pub fn profq_set_chan(s: Sender<ProfileQueriesMsg>) -> bool {\n-    PROFQ_CHAN.with(|chan|{\n-        if chan.borrow().is_none() {\n-            *chan.borrow_mut() = Some(s);\n-            true\n-        } else { false }\n-    })\n+pub fn profq_set_chan(sess: &Session, s: Sender<ProfileQueriesMsg>) -> bool {\n+    let mut channel = sess.profile_channel.borrow_mut();\n+    if channel.is_none() {\n+        *channel = Some(s);\n+        true\n+    } else {\n+        false\n+    }\n }\n \n /// Read the current depth of `time()` calls. This is used to\n@@ -135,7 +127,13 @@ pub fn set_time_depth(depth: usize) {\n     TIME_DEPTH.with(|slot| slot.set(depth));\n }\n \n-pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n+pub fn time<T, F>(sess: &Session, what: &str, f: F) -> T where\n+    F: FnOnce() -> T,\n+{\n+    time_ext(sess.time_passes(), Some(sess), what, f)\n+}\n+\n+pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n     if !do_it { return f(); }\n@@ -146,15 +144,19 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         r\n     });\n \n-    if cfg!(debug_assertions) {\n-        profq_msg(ProfileQueriesMsg::TimeBegin(what.to_string()))\n-    };\n+    if let Some(sess) = sess {\n+        if cfg!(debug_assertions) {\n+            profq_msg(sess, ProfileQueriesMsg::TimeBegin(what.to_string()))\n+        }\n+    }\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n-    if cfg!(debug_assertions) {\n-        profq_msg(ProfileQueriesMsg::TimeEnd)\n-    };\n+    if let Some(sess) = sess {\n+        if cfg!(debug_assertions) {\n+            profq_msg(sess, ProfileQueriesMsg::TimeEnd)\n+        }\n+    }\n \n     print_time_passes_entry_internal(what, dur);\n "}, {"sha": "a8f689e5c81a385af248ab709c0114e4094eee6c", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -165,29 +165,6 @@ impl<W> Hasher for StableHasher<W> {\n     }\n }\n \n-\n-/// Something that can provide a stable hashing context.\n-pub trait StableHashingContextProvider {\n-    type ContextType;\n-    fn create_stable_hashing_context(&self) -> Self::ContextType;\n-}\n-\n-impl<'a, T: StableHashingContextProvider> StableHashingContextProvider for &'a T {\n-    type ContextType = T::ContextType;\n-\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        (**self).create_stable_hashing_context()\n-    }\n-}\n-\n-impl<'a, T: StableHashingContextProvider> StableHashingContextProvider for &'a mut T {\n-    type ContextType = T::ContextType;\n-\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        (**self).create_stable_hashing_context()\n-    }\n-}\n-\n /// Something that implements `HashStable<CTX>` can be hashed in a way that is\n /// stable across multiple compilation sessions.\n pub trait HashStable<CTX> {"}, {"sha": "485ee1130d306eeba133bde339e707a2f9a26168", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -89,7 +89,7 @@ pub fn compile_input(trans: Box<TransCrate>,\n     }\n \n     if sess.profile_queries() {\n-        profile::begin();\n+        profile::begin(sess);\n     }\n \n     // We need nested scopes here, because the intermediate results can keep\n@@ -181,7 +181,7 @@ pub fn compile_input(trans: Box<TransCrate>,\n         let arenas = AllArenas::new();\n \n         // Construct the HIR map\n-        let hir_map = time(sess.time_passes(),\n+        let hir_map = time(sess,\n                            \"indexing hir\",\n                            || hir_map::map_crate(sess, cstore, &mut hir_forest, &defs));\n \n@@ -517,10 +517,10 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n     sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n \n     if sess.profile_queries() {\n-        profile::begin();\n+        profile::begin(sess);\n     }\n \n-    let krate = time(sess.time_passes(), \"parsing\", || {\n+    let krate = time(sess, \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n                 parse::parse_crate_from_file(file, &sess.parse_sess)\n@@ -645,8 +645,6 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                        -> Result<InnerExpansionResult<'a>, CompileIncomplete>\n     where F: FnOnce(&ast::Crate) -> CompileResult,\n {\n-    let time_passes = sess.time_passes();\n-\n     let (mut krate, features) = syntax::config::features(krate, &sess.parse_sess,\n                                                          sess.opts.test,\n                                                          sess.opts.debugging_opts.epoch);\n@@ -664,7 +662,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     );\n \n     if sess.opts.incremental.is_some() {\n-        time(time_passes, \"garbage collect incremental cache directory\", || {\n+        time(sess, \"garbage collect incremental cache directory\", || {\n             if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n                 warn!(\"Error while trying to garbage collect incremental \\\n                        compilation cache directory: {}\", e);\n@@ -674,22 +672,22 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     // If necessary, compute the dependency graph (in the background).\n     let future_dep_graph = if sess.opts.build_dep_graph() {\n-        Some(rustc_incremental::load_dep_graph(sess, time_passes))\n+        Some(rustc_incremental::load_dep_graph(sess))\n     } else {\n         None\n     };\n \n-    time(time_passes, \"recursion limit\", || {\n+    time(sess, \"recursion limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n-    krate = time(time_passes, \"crate injection\", || {\n+    krate = time(sess, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.clone();\n         syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name)\n     });\n \n     let mut addl_plugins = Some(addl_plugins);\n-    let registrars = time(time_passes, \"plugin loading\", || {\n+    let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(sess,\n                                    &cstore,\n                                    &krate,\n@@ -699,7 +697,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     let mut registry = registry.unwrap_or(Registry::new(sess, krate.span));\n \n-    time(time_passes, \"plugin registration\", || {\n+    time(sess, \"plugin registration\", || {\n         if sess.features_untracked().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                                     diagnostics::plugin::expand_diagnostic_used);\n@@ -752,7 +750,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n \n-    krate = time(time_passes, \"expansion\", || {\n+    krate = time(sess, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n         // dependent dlls. Note that this uses cfg!(windows) as opposed to\n@@ -814,7 +812,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         krate\n     });\n \n-    krate = time(time_passes, \"maybe building test harness\", || {\n+    krate = time(sess, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n                                          &mut resolver,\n                                          sess.opts.test,\n@@ -833,7 +831,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     // bunch of checks in the `modify` function below. For now just skip this\n     // step entirely if we're rustdoc as it's not too useful anyway.\n     if !sess.opts.actually_rustdoc {\n-        krate = time(time_passes, \"maybe creating a macro crate\", || {\n+        krate = time(sess, \"maybe creating a macro crate\", || {\n             let crate_types = sess.crate_types.borrow();\n             let num_crate_types = crate_types.len();\n             let is_proc_macro_crate = crate_types.contains(&config::CrateTypeProcMacro);\n@@ -848,7 +846,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         });\n     }\n \n-    krate = time(time_passes, \"creating allocators\", || {\n+    krate = time(sess, \"creating allocators\", || {\n         allocator::expand::modify(&sess.parse_sess,\n                                   &mut resolver,\n                                   krate,\n@@ -869,11 +867,11 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    time(time_passes,\n+    time(sess,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));\n \n-    time(time_passes, \"name resolution\", || -> CompileResult {\n+    time(sess, \"name resolution\", || -> CompileResult {\n         resolver.resolve_crate(&krate);\n         Ok(())\n     })?;\n@@ -883,7 +881,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     }\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n-    time(time_passes, \"complete gated feature checking\", || {\n+    time(sess, \"complete gated feature checking\", || {\n         sess.track_errors(|| {\n             syntax::feature_gate::check_crate(&krate,\n                                               &sess.parse_sess,\n@@ -898,15 +896,15 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     let dep_graph = match future_dep_graph {\n         None => DepGraph::new_disabled(),\n         Some(future) => {\n-            let prev_graph = time(time_passes, \"blocked while dep-graph loading finishes\", || {\n+            let prev_graph = time(sess, \"blocked while dep-graph loading finishes\", || {\n                 future.open()\n                       .expect(\"Could not join with background dep_graph thread\")\n                       .open(sess)\n             });\n             DepGraph::new(prev_graph)\n         }\n     };\n-    let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n+    let hir_forest = time(sess, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, &mut resolver);\n \n         if sess.opts.debugging_opts.hir_stats {\n@@ -916,7 +914,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         hir_map::Forest::new(hir_crate, &dep_graph)\n     });\n \n-    time(time_passes,\n+    time(sess,\n          \"early lint checks\",\n          || lint::check_ast_crate(sess, &krate));\n \n@@ -973,22 +971,20 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n                             mpsc::Receiver<Box<Any + Send>>,\n                             CompileResult) -> R\n {\n-    let time_passes = sess.time_passes();\n-\n-    let query_result_on_disk_cache = time(time_passes,\n+    let query_result_on_disk_cache = time(sess,\n         \"load query result cache\",\n         || rustc_incremental::load_query_result_cache(sess));\n \n-    time(time_passes,\n+    time(sess,\n          \"looking for entry point\",\n          || middle::entry::find_entry_point(sess, &hir_map));\n \n-    sess.plugin_registrar_fn.set(time(time_passes, \"looking for plugin registrar\", || {\n+    sess.plugin_registrar_fn.set(time(sess, \"looking for plugin registrar\", || {\n         plugin::build::find_plugin_registrar(sess.diagnostic(), &hir_map)\n     }));\n     sess.derive_registrar_fn.set(derive_registrar::find(&hir_map));\n \n-    time(time_passes,\n+    time(sess,\n          \"loop checking\",\n          || loops::check_crate(sess, &hir_map));\n \n@@ -1020,11 +1016,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n         // tcx available.\n         rustc_incremental::dep_graph_tcx_init(tcx);\n \n-        time(sess.time_passes(), \"attribute checking\", || {\n+        time(sess, \"attribute checking\", || {\n             hir::check_attr::check_crate(tcx)\n         });\n \n-        time(time_passes,\n+        time(sess,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));\n \n@@ -1037,38 +1033,38 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n             }\n         }\n \n-        time(time_passes,\n+        time(sess,\n              \"rvalue promotion\",\n              || rvalue_promotion::check_crate(tcx));\n \n         analysis.access_levels =\n-            time(time_passes, \"privacy checking\", || rustc_privacy::check_crate(tcx));\n+            time(sess, \"privacy checking\", || rustc_privacy::check_crate(tcx));\n \n-        time(time_passes,\n+        time(sess,\n              \"intrinsic checking\",\n              || middle::intrinsicck::check_crate(tcx));\n \n-        time(time_passes,\n+        time(sess,\n              \"match checking\",\n              || mir::matchck_crate(tcx));\n \n         // this must run before MIR dump, because\n         // \"not all control paths return a value\" is reported here.\n         //\n         // maybe move the check to a MIR pass?\n-        time(time_passes,\n+        time(sess,\n              \"liveness checking\",\n              || middle::liveness::check_crate(tcx));\n \n-        time(time_passes,\n+        time(sess,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n \n-        time(time_passes,\n+        time(sess,\n              \"MIR borrow checking\",\n              || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id); });\n \n-        time(time_passes,\n+        time(sess,\n              \"MIR effect checking\",\n              || for def_id in tcx.body_owners() {\n                  mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n@@ -1083,13 +1079,13 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n             return Ok(f(tcx, analysis, rx, sess.compile_status()));\n         }\n \n-        time(time_passes, \"death checking\", || middle::dead::check_crate(tcx));\n+        time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n \n-        time(time_passes, \"unused lib feature checking\", || {\n+        time(sess, \"unused lib feature checking\", || {\n             stability::check_unused_or_stable_features(tcx)\n         });\n \n-        time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n+        time(sess, \"lint checking\", || lint::check_crate(tcx));\n \n         return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })\n@@ -1101,18 +1097,16 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(trans: &TransCrate,\n                                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            rx: mpsc::Receiver<Box<Any + Send>>)\n                                            -> Box<Any> {\n-    let time_passes = tcx.sess.time_passes();\n-\n-    time(time_passes,\n+    time(tcx.sess,\n          \"resolving dependency formats\",\n          || ::rustc::middle::dependency_format::calculate(tcx));\n \n     let translation =\n-        time(time_passes, \"translation\", move || {\n+        time(tcx.sess, \"translation\", move || {\n             trans.trans_crate(tcx, rx)\n         });\n     if tcx.sess.profile_queries() {\n-        profile::dump(\"profile_queries\".to_string())\n+        profile::dump(&tcx.sess, \"profile_queries\".to_string())\n     }\n \n     translation"}, {"sha": "f6aa58213fc90f3cb62bf6ff51f4df233bdbb8ce", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -914,7 +914,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n pub fn enable_save_analysis(control: &mut CompileController) {\n     control.keep_ast = true;\n     control.after_analysis.callback = box |state| {\n-        time(state.session.time_passes(), \"save analysis\", || {\n+        time(state.session, \"save analysis\", || {\n             save::process_crate(state.tcx.unwrap(),\n                                 state.expanded_crate.unwrap(),\n                                 state.analysis.unwrap(),"}, {"sha": "a362556717bddf693ae2ee3429bc90734195e448", "filename": "src/librustc_driver/profile/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::session::Session;\n use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n use std::sync::mpsc::{Receiver};\n use std::io::{Write};\n@@ -17,11 +18,11 @@ use std::time::{Duration, Instant};\n pub mod trace;\n \n /// begin a profile thread, if not already running\n-pub fn begin() {\n+pub fn begin(sess: &Session) {\n     use std::thread;\n     use std::sync::mpsc::{channel};\n     let (tx, rx) = channel();\n-    if profq_set_chan(tx) {\n+    if profq_set_chan(sess, tx) {\n         thread::spawn(move||profile_queries_thread(rx));\n     }\n }\n@@ -30,7 +31,7 @@ pub fn begin() {\n /// wait for this dump to complete.\n ///\n /// wraps the RPC (send/recv channel logic) of requesting a dump.\n-pub fn dump(path:String) {\n+pub fn dump(sess: &Session, path: String) {\n     use std::sync::mpsc::{channel};\n     let (tx, rx) = channel();\n     let params = ProfQDumpParams{\n@@ -39,7 +40,7 @@ pub fn dump(path:String) {\n         // is written; false for now\n         dump_profq_msg_log:true,\n     };\n-    profq_msg(ProfileQueriesMsg::Dump(params));\n+    profq_msg(sess, ProfileQueriesMsg::Dump(params));\n     let _ = rx.recv().unwrap();\n }\n "}, {"sha": "38468e29427b0fa1f6cda03b785cb451a201fa56", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -14,7 +14,7 @@ use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::OnDiskCache;\n-use rustc::util::common::time;\n+use rustc::util::common::time_ext;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::Path;\n@@ -147,12 +147,14 @@ impl<T> MaybeAsync<T> {\n }\n \n /// Launch a thread and load the dependency graph in the background.\n-pub fn load_dep_graph(sess: &Session, time_passes: bool) ->\n+pub fn load_dep_graph(sess: &Session) ->\n     MaybeAsync<LoadResult<PreviousDepGraph>>\n {\n     // Since `sess` isn't `Sync`, we perform all accesses to `sess`\n     // before we fire the background thread.\n \n+    let time_passes = sess.time_passes();\n+\n     if sess.opts.incremental.is_none() {\n         // No incremental compilation.\n         return MaybeAsync::Sync(LoadResult::Ok {\n@@ -167,7 +169,7 @@ pub fn load_dep_graph(sess: &Session, time_passes: bool) ->\n     let expected_hash = sess.opts.dep_tracking_hash();\n \n     MaybeAsync::Async(std::thread::spawn(move || {\n-        time(time_passes, \"background load prev dep-graph\", move || {\n+        time_ext(time_passes, None, \"background load prev dep-graph\", move || {\n             match load_data(report_incremental_info, &path) {\n                 LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n                 LoadResult::Error { message } => LoadResult::Error { message },"}, {"sha": "ca1e3563089dbdfe226f2621604255d097d8b137", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -33,14 +33,14 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             return;\n         }\n \n-        time(sess.time_passes(), \"persist query result cache\", || {\n+        time(sess, \"persist query result cache\", || {\n             save_in(sess,\n                     query_cache_path(sess),\n                     |e| encode_query_cache(tcx, e));\n         });\n \n         if tcx.sess.opts.debugging_opts.incremental_queries {\n-            time(sess.time_passes(), \"persist dep-graph\", || {\n+            time(sess, \"persist dep-graph\", || {\n                 save_in(sess,\n                         dep_graph_path(sess),\n                         |e| encode_dep_graph(tcx, e));"}, {"sha": "867498d0c59e154d64a6fc4d7a931d779d04af7d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -690,7 +690,7 @@ fn link_natively(sess: &Session,\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = time(sess.time_passes(), \"running linker\", || {\n+        prog = time(sess, \"running linker\", || {\n             exec_linker(sess, &mut cmd, tmpdir)\n         });\n         let output = match prog {\n@@ -1321,7 +1321,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time(sess.time_passes(), &format!(\"altering {}.rlib\", name), || {\n+        time(sess, &format!(\"altering {}.rlib\", name), || {\n             let cfg = archive_config(sess, &dst, Some(cratepath));\n             let mut archive = ArchiveBuilder::new(cfg);\n             archive.update_symbols();"}, {"sha": "2a473f1ecbcc5efcff393a10b751c22a0ae96998", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -19,7 +19,7 @@ use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n-use rustc::util::common::time;\n+use rustc::util::common::time_ext;\n use time_graph::Timeline;\n use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n \n@@ -172,7 +172,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n+                let (bc, id) = time_ext(cgcx.time_passes, None, &format!(\"decode {}\", name), || {\n                     match DecodedBytecode::new(bc_encoded) {\n                         Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n                         Err(e) => Err(diag_handler.fatal(&e)),\n@@ -253,7 +253,7 @@ fn fat_lto(cgcx: &CodegenContext,\n     let mut linker = Linker::new(llmod);\n     for (bc_decoded, name) in serialized_modules {\n         info!(\"linking {:?}\", name);\n-        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n+        time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n             let data = bc_decoded.data();\n             linker.add(&data).map_err(|()| {\n                 let msg = format!(\"failed to load bc of {:?}\", name);\n@@ -498,7 +498,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n         assert!(!pass.is_null());\n         llvm::LLVMRustAddPass(pm, pass);\n \n-        time(cgcx.time_passes, \"LTO passes\", ||\n+        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n              llvm::LLVMRunPassManager(pm, llmod));\n \n         llvm::LLVMDisposePassManager(pm);"}, {"sha": "7651a8e748e3c0ba87f9b43e2bd69000ebed34e6", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -31,7 +31,8 @@ use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKi\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n-use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n+use rustc::util::common::{time_ext, time_depth, set_time_depth, print_time_passes_entry};\n+use rustc::util::common::path2cstr;\n use rustc::util::fs::{link_or_copy};\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n use errors::emitter::{Emitter};\n@@ -563,11 +564,19 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         diag_handler.abort_if_errors();\n \n         // Finally, run the actual optimization passes\n-        time(config.time_passes, &format!(\"llvm function passes [{}]\", module_name.unwrap()), ||\n-             llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+        time_ext(config.time_passes,\n+                 None,\n+                 &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n+                 || {\n+            llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n+        });\n         timeline.record(\"fpm\");\n-        time(config.time_passes, &format!(\"llvm module passes [{}]\", module_name.unwrap()), ||\n-             llvm::LLVMRunPassManager(mpm, llmod));\n+        time_ext(config.time_passes,\n+                 None,\n+                 &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n+                 || {\n+            llvm::LLVMRunPassManager(mpm, llmod)\n+        });\n \n         // Deallocate managers that we're now done with\n         llvm::LLVMDisposePassManager(fpm);\n@@ -682,7 +691,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         }\n     }\n \n-    time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+    time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n          || -> Result<(), FatalError> {\n         if config.emit_ir {\n             let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);"}, {"sha": "76e05ae7dcb8010cab071453bfd4ed39f0b879f9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -712,7 +712,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n-        time(tcx.sess.time_passes(), \"write metadata\", || {\n+        time(tcx.sess, \"write metadata\", || {\n             write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n@@ -790,7 +790,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 llcx,\n                 tm: create_target_machine(tcx.sess),\n             };\n-            time(tcx.sess.time_passes(), \"write allocator module\", || {\n+            time(tcx.sess, \"write allocator module\", || {\n                 allocator::trans(tcx, &modules, kind)\n             });\n \n@@ -924,11 +924,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    time(tcx.sess.time_passes(),\n+    time(tcx.sess,\n          \"assert dep graph\",\n          || rustc_incremental::assert_dep_graph(tcx));\n \n-    time(tcx.sess.time_passes(),\n+    time(tcx.sess,\n          \"serialize dep graph\",\n          || rustc_incremental::save_dep_graph(tcx));\n }\n@@ -939,7 +939,6 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n ) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n-    let time_passes = tcx.sess.time_passes();\n \n     let collection_mode = match tcx.sess.opts.debugging_opts.print_trans_items {\n         Some(ref s) => {\n@@ -968,7 +967,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     };\n \n     let (items, inlining_map) =\n-        time(time_passes, \"translation item collection\", || {\n+        time(tcx.sess, \"translation item collection\", || {\n             collector::collect_crate_mono_items(tcx, collection_mode)\n     });\n \n@@ -982,7 +981,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n         PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n     };\n \n-    let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n+    let codegen_units = time(tcx.sess, \"codegen unit partitioning\", || {\n         partitioning::partition(tcx,\n                                 items.iter().cloned(),\n                                 strategy,"}, {"sha": "39eb38658fee9349061d5a7adb136a7471d4674d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -238,7 +238,7 @@ impl TransCrate for LlvmTransCrate {\n             back::write::dump_incremental_data(&trans);\n         }\n \n-        time(sess.time_passes(),\n+        time(sess,\n              \"serialize work products\",\n              move || rustc_incremental::save_work_products(sess, &dep_graph));\n \n@@ -251,7 +251,7 @@ impl TransCrate for LlvmTransCrate {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        time(sess.time_passes(), \"linking\", || {\n+        time(sess, \"linking\", || {\n             back::link::link_binary(sess, &trans, outputs, &trans.crate_name.as_str());\n         });\n "}, {"sha": "49a23f14338b448b530cac17e05e3605908cbe51", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae379bd1c7e61a2050f18a680bf27fa3267c93c9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ae379bd1c7e61a2050f18a680bf27fa3267c93c9", "patch": "@@ -315,41 +315,39 @@ pub fn provide(providers: &mut Providers) {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> Result<(), CompileIncomplete>\n {\n-    let time_passes = tcx.sess.time_passes();\n-\n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.track_errors(|| {\n-        time(time_passes, \"type collecting\", ||\n+        time(tcx.sess, \"type collecting\", ||\n              collect::collect_item_types(tcx));\n \n     })?;\n \n     tcx.sess.track_errors(|| {\n-        time(time_passes, \"outlives testing\", ||\n+        time(tcx.sess, \"outlives testing\", ||\n             outlives::test::test_inferred_outlives(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n-        time(time_passes, \"impl wf inference\", ||\n+        time(tcx.sess, \"impl wf inference\", ||\n              impl_wf_check::impl_wf_check(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n-      time(time_passes, \"coherence checking\", ||\n+      time(tcx.sess, \"coherence checking\", ||\n           coherence::check_coherence(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n-        time(time_passes, \"variance testing\", ||\n+        time(tcx.sess, \"variance testing\", ||\n              variance::test::test_variance(tcx));\n     })?;\n \n-    time(time_passes, \"wf checking\", || check::check_wf_new(tcx))?;\n+    time(tcx.sess, \"wf checking\", || check::check_wf_new(tcx))?;\n \n-    time(time_passes, \"item-types checking\", || check::check_item_types(tcx))?;\n+    time(tcx.sess, \"item-types checking\", || check::check_item_types(tcx))?;\n \n-    time(time_passes, \"item-bodies checking\", || check::check_item_bodies(tcx))?;\n+    time(tcx.sess, \"item-bodies checking\", || check::check_item_bodies(tcx))?;\n \n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);"}]}