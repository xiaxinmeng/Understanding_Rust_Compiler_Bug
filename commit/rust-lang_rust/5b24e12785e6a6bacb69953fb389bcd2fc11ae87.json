{"sha": "5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "node_id": "C_kwDOAAsO6NoAKDViMjRlMTI3ODVlNmE2YmFjYjY5OTUzZmIzODliY2QyZmMxMWFlODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-11T23:26:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-11T23:26:55Z"}, "message": "Auto merge of #111395 - scottmcm:slice-iter-zst-experiment, r=the8472\n\nSimplify the implementation of iterators over slices of ZSTs\n\nCurrently, slice iterators over ZSTs store `end = start.wrapping_byte_add(len)`.\n\nThat's slightly convenient for `is_empty`, but kinda annoying for pretty much everything else -- see bugs like #42789, for example.\n\nThis PR instead changes it to just `end = ptr::invalid(len)` instead.\n\nThat's easier to think about (IMHO, at least) as well as easier to represent.\n\n`next` is still to big to get inlined into the mir-opt/pre-codegen/ tests, but if I bump the inline threshold to force it to show the whole thing, this implementation is also less MIR:\n```\n> git diff --numstat\n241     370     tests/mir-opt/pre-codegen/slice_iter.forward_loop.PreCodegen.after.mir\n255     329     tests/mir-opt/pre-codegen/slice_iter.reverse_loop.PreCodegen.after.mir\n184     216     tests/mir-opt/pre-codegen/slice_iter.slice_iter_mut_next_back.PreCodegen.after.mir\n182     254     tests/mir-opt/pre-codegen/slice_iter.slice_iter_next.PreCodegen.after.mir\n```\n(That's \u224870 lines less for `Iter::next`, for example.)\n\nr? `@ghost`\n\n~~Built atop #111282, so draft until that lands.~~", "tree": {"sha": "3eb9d69f5ecb64af4ab0a034bbe4323ddfcc7da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eb9d69f5ecb64af4ab0a034bbe4323ddfcc7da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "html_url": "https://github.com/rust-lang/rust/commit/5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd", "html_url": "https://github.com/rust-lang/rust/commit/2a8221dbdfd180a2d56d4b0089f4f3952d8c2bcd"}, {"sha": "15aa7fad7ec83db399c8a85c6b6777d0efc7bc53", "url": "https://api.github.com/repos/rust-lang/rust/commits/15aa7fad7ec83db399c8a85c6b6777d0efc7bc53", "html_url": "https://github.com/rust-lang/rust/commit/15aa7fad7ec83db399c8a85c6b6777d0efc7bc53"}], "stats": {"total": 86, "additions": 51, "deletions": 35}, "files": [{"sha": "b492d2f07bc13d91f22f3195fea3c01e9f16fa1b", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -449,6 +449,19 @@ impl<T: ?Sized> NonNull<T> {\n         // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n         unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }\n     }\n+\n+    /// See [`pointer::add`] for semantics and safety requirements.\n+    #[inline]\n+    pub(crate) const unsafe fn add(self, delta: usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: We require that the delta stays in-bounds of the object, and\n+        // thus it cannot become null, as that would require wrapping the\n+        // address space, which no legal objects are allowed to do.\n+        // And the caller promised the `delta` is sound to add.\n+        unsafe { NonNull { pointer: self.pointer.add(delta) } }\n+    }\n }\n \n impl<T> NonNull<[T]> {"}, {"sha": "67fcef0f4663c609df6892f18f05ce03b165f239", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -13,7 +13,7 @@ use crate::iter::{\n use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem::{self, SizedTypeProperties};\n use crate::num::NonZeroUsize;\n-use crate::ptr::NonNull;\n+use crate::ptr::{invalid, invalid_mut, NonNull};\n \n use super::{from_raw_parts, from_raw_parts_mut};\n \n@@ -67,9 +67,7 @@ pub struct Iter<'a, T: 'a> {\n     ptr: NonNull<T>,\n     /// For non-ZSTs, the non-null pointer to the past-the-end element.\n     ///\n-    /// For ZSTs, this is `ptr.wrapping_byte_add(len)`.\n-    ///\n-    /// For all types, `ptr == end` tests whether the iterator is empty.\n+    /// For ZSTs, this is `ptr::invalid(len)`.\n     end: *const T,\n     _marker: PhantomData<&'a T>,\n }\n@@ -94,8 +92,7 @@ impl<'a, T> Iter<'a, T> {\n         unsafe {\n             assume(!ptr.is_null());\n \n-            let end =\n-                if T::IS_ZST { ptr.wrapping_byte_add(slice.len()) } else { ptr.add(slice.len()) };\n+            let end = if T::IS_ZST { invalid(slice.len()) } else { ptr.add(slice.len()) };\n \n             Self { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: PhantomData }\n         }\n@@ -193,9 +190,7 @@ pub struct IterMut<'a, T: 'a> {\n     ptr: NonNull<T>,\n     /// For non-ZSTs, the non-null pointer to the past-the-end element.\n     ///\n-    /// For ZSTs, this is `ptr.wrapping_byte_add(len)`.\n-    ///\n-    /// For all types, `ptr == end` tests whether the iterator is empty.\n+    /// For ZSTs, this is `ptr::invalid_mut(len)`.\n     end: *mut T,\n     _marker: PhantomData<&'a mut T>,\n }\n@@ -235,8 +230,7 @@ impl<'a, T> IterMut<'a, T> {\n         unsafe {\n             assume(!ptr.is_null());\n \n-            let end =\n-                if T::IS_ZST { ptr.wrapping_byte_add(slice.len()) } else { ptr.add(slice.len()) };\n+            let end = if T::IS_ZST { invalid_mut(slice.len()) } else { ptr.add(slice.len()) };\n \n             Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }\n         }"}, {"sha": "3462c0e020a3d96938d59a7a1f3edea88b6f2f12", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -1,28 +1,44 @@\n //! Macros used by iterators of slice.\n \n+// Shrinks the iterator when T is a ZST, setting the length to `new_len`.\n+// `new_len` must not exceed `self.len()`.\n+macro_rules! zst_set_len {\n+    ($self: ident, $new_len: expr) => {{\n+        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n+\n+        // SAFETY: same as `invalid(_mut)`, but the macro doesn't know\n+        // which versions of that function to call, so open-code it.\n+        $self.end = unsafe { mem::transmute::<usize, _>($new_len) };\n+    }};\n+}\n+\n+// Shrinks the iterator when T is a ZST, reducing the length by `n`.\n+// `n` must not exceed `self.len()`.\n+macro_rules! zst_shrink {\n+    ($self: ident, $n: ident) => {\n+        let new_len = $self.end.addr() - $n;\n+        zst_set_len!($self, new_len);\n+    };\n+}\n+\n // Inlining is_empty and len makes a huge performance difference\n macro_rules! is_empty {\n-    // The way we encode the length of a ZST iterator, this works both for ZST\n-    // and non-ZST.\n     ($self: ident) => {\n-        $self.ptr.as_ptr() as *const T == $self.end\n+        if T::IS_ZST { $self.end.addr() == 0 } else { $self.ptr.as_ptr() as *const _ == $self.end }\n     };\n }\n \n macro_rules! len {\n     ($self: ident) => {{\n         #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n \n-        let start = $self.ptr;\n         if T::IS_ZST {\n-            // This _cannot_ use `ptr_sub` because we depend on wrapping\n-            // to represent the length of long ZST slice iterators.\n-            $self.end.addr().wrapping_sub(start.as_ptr().addr())\n+            $self.end.addr()\n         } else {\n             // To get rid of some bounds checks (see `position`), we use ptr_sub instead of\n             // offset_from (Tested by `codegen/slice-position-bounds-check`.)\n             // SAFETY: by the type invariant pointers are aligned and `start <= end`\n-            unsafe { $self.end.sub_ptr(start.as_ptr()) }\n+            unsafe { $self.end.sub_ptr($self.ptr.as_ptr()) }\n         }\n     }};\n }\n@@ -50,14 +66,6 @@ macro_rules! iterator {\n             ($self: ident) => {& $( $mut_ )? *$self.pre_dec_end(1)}\n         }\n \n-        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n-        // backwards by `n`. `n` must not exceed `self.len()`.\n-        macro_rules! zst_shrink {\n-            ($self: ident, $n: ident) => {\n-                $self.end = $self.end.wrapping_byte_sub($n);\n-            }\n-        }\n-\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n@@ -73,16 +81,15 @@ macro_rules! iterator {\n             // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn post_inc_start(&mut self, offset: usize) -> * $raw_mut T {\n+                let old = self.ptr;\n                 if T::IS_ZST {\n                     zst_shrink!(self, offset);\n-                    self.ptr.as_ptr()\n                 } else {\n-                    let old = self.ptr.as_ptr();\n                     // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                     // so this new pointer is inside `self` and thus guaranteed to be non-null.\n-                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().add(offset)) };\n-                    old\n+                    self.ptr = unsafe { self.ptr.add(offset) };\n                 }\n+                old.as_ptr()\n             }\n \n             // Helper function for moving the end of the iterator backwards by `offset` elements,\n@@ -155,9 +162,7 @@ macro_rules! iterator {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n                     if T::IS_ZST {\n-                        // We have to do it this way as `ptr` may never be 0, but `end`\n-                        // could be (due to wrapping).\n-                        self.end = self.ptr.as_ptr();\n+                        zst_set_len!(self, 0);\n                     } else {\n                         // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                         unsafe {\n@@ -356,7 +361,11 @@ macro_rules! iterator {\n             fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n-                    self.end = self.ptr.as_ptr();\n+                    if T::IS_ZST {\n+                        zst_set_len!(self, 0);\n+                    } else {\n+                        self.end = self.ptr.as_ptr();\n+                    }\n                     return None;\n                 }\n                 // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs."}]}