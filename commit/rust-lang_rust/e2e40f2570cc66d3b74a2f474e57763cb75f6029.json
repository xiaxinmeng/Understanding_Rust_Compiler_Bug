{"sha": "e2e40f2570cc66d3b74a2f474e57763cb75f6029", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZTQwZjI1NzBjYzY2ZDNiNzRhMmY0NzRlNTc3NjNjYjc1ZjYwMjk=", "commit": {"author": {"name": "Krishna Sai Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2020-01-09T17:49:15Z"}, "committer": {"name": "Krishna Sai Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2020-01-09T17:49:15Z"}, "message": "Detect usage of invalid atomic ordering in memory fences\n\nDetect usage of `core::sync::atomic::{fence, compiler_fence}`\nwith `Ordering::Relaxed` and suggest valid alternatives.", "tree": {"sha": "687daeb879ee9f34bf055fcdf5ad8366a918cb41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687daeb879ee9f34bf055fcdf5ad8366a918cb41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e40f2570cc66d3b74a2f474e57763cb75f6029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e40f2570cc66d3b74a2f474e57763cb75f6029", "html_url": "https://github.com/rust-lang/rust/commit/e2e40f2570cc66d3b74a2f474e57763cb75f6029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e40f2570cc66d3b74a2f474e57763cb75f6029/comments", "author": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac795a6f3aaaaa4d39afda0845e24891ca892126", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac795a6f3aaaaa4d39afda0845e24891ca892126", "html_url": "https://github.com/rust-lang/rust/commit/ac795a6f3aaaaa4d39afda0845e24891ca892126"}], "stats": {"total": 99, "additions": 65, "deletions": 34}, "files": [{"sha": "f5b0b625023f154cf6f98110fee6b1493e3f6936", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 64, "deletions": 33, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e2e40f2570cc66d3b74a2f474e57763cb75f6029/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e40f2570cc66d3b74a2f474e57763cb75f6029/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=e2e40f2570cc66d3b74a2f474e57763cb75f6029", "patch": "@@ -9,7 +9,7 @@ use rustc_session::declare_tool_lint;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of invalid atomic\n-    /// ordering in Atomic*::{load, store} calls.\n+    /// ordering in atomic loads/stores and memory fences.\n     ///\n     /// **Why is this bad?** Using an invalid atomic ordering\n     /// will cause a panic at run-time.\n@@ -18,7 +18,7 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,no_run\n-    /// # use std::sync::atomic::{AtomicBool, Ordering};\n+    /// # use std::sync::atomic::{self, AtomicBool, Ordering};\n     ///\n     /// let x = AtomicBool::new(true);\n     ///\n@@ -27,10 +27,13 @@ declare_clippy_lint! {\n     ///\n     /// x.store(false, Ordering::Acquire);\n     /// x.store(false, Ordering::AcqRel);\n+    ///\n+    /// atomic::fence(Ordering::Relaxed);\n+    /// atomic::compiler_fence(Ordering::Relaxed);\n     /// ```\n     pub INVALID_ATOMIC_ORDERING,\n     correctness,\n-    \"usage of invalid atomic ordering in atomic load/store calls\"\n+    \"usage of invalid atomic ordering in atomic loads/stores and memory fences\"\n }\n \n declare_lint_pass!(AtomicOrdering => [INVALID_ATOMIC_ORDERING]);\n@@ -66,37 +69,65 @@ fn match_ordering_def_path(cx: &LateContext<'_, '_>, did: DefId, orderings: &[&s\n         .any(|ordering| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering]))\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AtomicOrdering {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(ref method_path, _, args) = &expr.kind;\n-            let method = method_path.ident.name.as_str();\n-            if type_is_atomic(cx, &args[0]);\n-            if method == \"load\" || method == \"store\";\n-            let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n-            if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n-            if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n-            then {\n-                if method == \"load\" &&\n-                    match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n-                    span_help_and_lint(\n-                        cx,\n-                        INVALID_ATOMIC_ORDERING,\n-                        ordering_arg.span,\n-                        \"atomic loads cannot have `Release` and `AcqRel` ordering\",\n-                        \"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\"\n-                    );\n-                } else if method == \"store\" &&\n-                    match_ordering_def_path(cx, ordering_def_id, &[\"Acquire\", \"AcqRel\"]) {\n-                    span_help_and_lint(\n-                        cx,\n-                        INVALID_ATOMIC_ORDERING,\n-                        ordering_arg.span,\n-                        \"atomic stores cannot have `Acquire` and `AcqRel` ordering\",\n-                        \"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\"\n-                    );\n-                }\n+fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method_path, _, args) = &expr.kind;\n+        let method = method_path.ident.name.as_str();\n+        if type_is_atomic(cx, &args[0]);\n+        if method == \"load\" || method == \"store\";\n+        let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n+        if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n+        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n+        then {\n+            if method == \"load\" &&\n+                match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n+                span_help_and_lint(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    ordering_arg.span,\n+                    \"atomic loads cannot have `Release` and `AcqRel` ordering\",\n+                    \"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\"\n+                );\n+            } else if method == \"store\" &&\n+                match_ordering_def_path(cx, ordering_def_id, &[\"Acquire\", \"AcqRel\"]) {\n+                span_help_and_lint(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    ordering_arg.span,\n+                    \"atomic stores cannot have `Acquire` and `AcqRel` ordering\",\n+                    \"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\"\n+                );\n             }\n         }\n     }\n }\n+\n+fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Call(ref func, ref args) = expr.kind;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if [\"fence\", \"compiler_fence\"]\n+            .iter()\n+            .any(|func| match_def_path(cx, def_id, &[\"core\", \"sync\", \"atomic\", func]));\n+        if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n+        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n+        if match_ordering_def_path(cx, ordering_def_id, &[\"Relaxed\"]);\n+        then {\n+            span_help_and_lint(\n+                cx,\n+                INVALID_ATOMIC_ORDERING,\n+                args[0].span,\n+                \"memory fences cannot have `Relaxed` ordering\",\n+                \"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\"\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AtomicOrdering {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        check_atomic_load_store(cx, expr);\n+        check_memory_fence(cx, expr);\n+    }\n+}"}, {"sha": "b133a79976244f1561c6ad775910707b15a7d431", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e40f2570cc66d3b74a2f474e57763cb75f6029/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e40f2570cc66d3b74a2f474e57763cb75f6029/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=e2e40f2570cc66d3b74a2f474e57763cb75f6029", "patch": "@@ -836,7 +836,7 @@ pub const ALL_LINTS: [Lint; 346] = [\n     Lint {\n         name: \"invalid_atomic_ordering\",\n         group: \"correctness\",\n-        desc: \"usage of invalid atomic ordering in atomic load/store calls\",\n+        desc: \"usage of invalid atomic ordering in atomic loads/stores and memory fences\",\n         deprecation: None,\n         module: \"atomic_ordering\",\n     },"}]}