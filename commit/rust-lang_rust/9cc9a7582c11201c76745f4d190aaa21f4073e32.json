{"sha": "9cc9a7582c11201c76745f4d190aaa21f4073e32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzlhNzU4MmMxMTIwMWM3Njc0NWY0ZDE5MGFhYTIxZjQwNzNlMzI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-15T01:41:11Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-01-18T00:54:11Z"}, "message": "add a lazy forward iterator to TreeMap", "tree": {"sha": "ba469247b184c4b3819b2c7eda89d44fb11488d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba469247b184c4b3819b2c7eda89d44fb11488d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc9a7582c11201c76745f4d190aaa21f4073e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc9a7582c11201c76745f4d190aaa21f4073e32", "html_url": "https://github.com/rust-lang/rust/commit/9cc9a7582c11201c76745f4d190aaa21f4073e32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc9a7582c11201c76745f4d190aaa21f4073e32/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f754764d60e79752c7cca1f8289eedeb469cad0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f754764d60e79752c7cca1f8289eedeb469cad0", "html_url": "https://github.com/rust-lang/rust/commit/7f754764d60e79752c7cca1f8289eedeb469cad0"}], "stats": {"total": 72, "additions": 70, "deletions": 2}, "files": [{"sha": "858ebbf70732799caef0e68ac23bde23184c8f75", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9cc9a7582c11201c76745f4d190aaa21f4073e32/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc9a7582c11201c76745f4d190aaa21f4073e32/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=9cc9a7582c11201c76745f4d190aaa21f4073e32", "patch": "@@ -23,8 +23,6 @@ use core::prelude::*;\n // as a right child. The time complexity is the same, and re-balancing\n // operations are more frequent but also cheaper.\n \n-// TODO: lazy iteration, for O(n) Eq and set operations instead of O(n*log(m))\n-\n // TODO: implement Ord for TreeSet\n // could be superset/subset-based or in-order lexicographic comparison... but\n // there are methods for is_superset/is_subset so lexicographic is more useful\n@@ -138,8 +136,43 @@ impl <K: Ord, V> TreeMap<K, V> {\n         if ret { self.length -= 1 }\n         ret\n     }\n+\n+    /// Get a lazy iterator over the nodes in the map. Requires that it\n+    /// be frozen (immutable).\n+    fn iter(&self) -> TreeMapIterator/&self<K, V> {\n+        TreeMapIterator{stack: ~[], node: &self.root}\n+    }\n+}\n+\n+/// Lazy forward iterator over a map\n+pub struct TreeMapIterator<K: Ord, V> {\n+    priv stack: ~[&~TreeNode<K, V>],\n+    priv node: &Option<~TreeNode<K, V>>\n }\n \n+impl <K: Ord, V> TreeMapIterator<K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return None.\n+    fn next(&mut self) -> Option<(&self/K, &self/V)> {\n+        while self.stack.is_not_empty() || self.node.is_some() {\n+            match *self.node {\n+              Some(ref x) => {\n+                  self.stack.push(x);\n+                  self.node = &x.left;\n+              }\n+              None => {\n+                let res = self.stack.pop();\n+                self.node = &res.right;\n+                return Some((&res.key, &res.value));\n+              }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+\n pub struct TreeSet<T: Ord> {\n     priv map: TreeMap<T, ()>\n }\n@@ -611,6 +644,41 @@ mod test_treemap {\n         assert b.insert(5, 19);\n         assert a == b;\n     }\n+\n+    #[test]\n+    fn test_lazy_iterator() {\n+        let mut m = TreeMap::new();\n+        let (x1, y1) = (2, 5);\n+        let (x2, y2) = (9, 12);\n+        let (x3, y3) = (20, -3);\n+        let (x4, y4) = (29, 5);\n+        let (x5, y5) = (103, 3);\n+\n+        assert m.insert(x1, y1);\n+        assert m.insert(x2, y2);\n+        assert m.insert(x3, y3);\n+        assert m.insert(x4, y4);\n+        assert m.insert(x5, y5);\n+\n+        let m = m;\n+        let mut iter = m.iter();\n+\n+        // ICE:\n+        //assert iter.next() == Some((&x1, &y1));\n+        //assert iter.next().eq(&Some((&x1, &y1)));\n+\n+        assert iter.next().unwrap() == (&x1, &y1);\n+        assert iter.next().unwrap() == (&x2, &y2);\n+        assert iter.next().unwrap() == (&x3, &y3);\n+        assert iter.next().unwrap() == (&x4, &y4);\n+        assert iter.next().unwrap() == (&x5, &y5);\n+\n+        // ICE:\n+        //assert iter.next() == None;\n+        //assert iter.next().eq(&None);\n+\n+        assert iter.next().is_none();\n+    }\n }\n \n #[cfg(test)]"}]}