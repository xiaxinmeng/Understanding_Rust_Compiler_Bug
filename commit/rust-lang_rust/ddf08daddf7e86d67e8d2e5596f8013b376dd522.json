{"sha": "ddf08daddf7e86d67e8d2e5596f8013b376dd522", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZjA4ZGFkZGY3ZTg2ZDY3ZThkMmU1NTk2ZjgwMTNiMzc2ZGQ1MjI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T16:46:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T16:46:07Z"}, "message": "Fix const arguments grammar", "tree": {"sha": "f129b02a4c02651f074a3255626919f251f1fc34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f129b02a4c02651f074a3255626919f251f1fc34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddf08daddf7e86d67e8d2e5596f8013b376dd522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf08daddf7e86d67e8d2e5596f8013b376dd522", "html_url": "https://github.com/rust-lang/rust/commit/ddf08daddf7e86d67e8d2e5596f8013b376dd522", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddf08daddf7e86d67e8d2e5596f8013b376dd522/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "040b4c800d5279e77a6825fc90cb2921d26c7f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/040b4c800d5279e77a6825fc90cb2921d26c7f95", "html_url": "https://github.com/rust-lang/rust/commit/040b4c800d5279e77a6825fc90cb2921d26c7f95"}], "stats": {"total": 670, "additions": 335, "deletions": 335}, "files": [{"sha": "aef7cd6fbb2d5f86fe2bc537bead3b0dcf68fd1f", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf08daddf7e86d67e8d2e5596f8013b376dd522/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf08daddf7e86d67e8d2e5596f8013b376dd522/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=ddf08daddf7e86d67e8d2e5596f8013b376dd522", "patch": "@@ -52,7 +52,7 @@ fn type_arg(p: &mut Parser) {\n             m.complete(p, CONST_ARG);\n         }\n         k if k.is_literal() => {\n-            p.bump(k);\n+            expressions::literal(p);\n             m.complete(p, CONST_ARG);\n         }\n         _ => {"}, {"sha": "97a882bf0aac8f6f85c474367e0f0d2e447289d1", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 331, "deletions": 332, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/ddf08daddf7e86d67e8d2e5596f8013b376dd522/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf08daddf7e86d67e8d2e5596f8013b376dd522/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=ddf08daddf7e86d67e8d2e5596f8013b376dd522", "patch": "@@ -106,8 +106,7 @@ pub struct ConstArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ConstArg {\n-    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n-    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n@@ -117,23 +116,6 @@ impl TypeBoundList {\n     pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Literal {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for Literal {}\n-impl Literal {}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BlockExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for BlockExpr {}\n-impl BlockExpr {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -437,6 +419,17 @@ impl WhereClause {\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct BlockExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for BlockExpr {}\n+impl BlockExpr {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -590,6 +583,12 @@ impl WherePred {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Literal {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for Literal {}\n+impl Literal {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1292,6 +1291,39 @@ pub enum Type {\n     TupleType(TupleType),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum Expr {\n+    ArrayExpr(ArrayExpr),\n+    AwaitExpr(AwaitExpr),\n+    BinExpr(BinExpr),\n+    BlockExpr(BlockExpr),\n+    BoxExpr(BoxExpr),\n+    BreakExpr(BreakExpr),\n+    CallExpr(CallExpr),\n+    CastExpr(CastExpr),\n+    ClosureExpr(ClosureExpr),\n+    ContinueExpr(ContinueExpr),\n+    EffectExpr(EffectExpr),\n+    FieldExpr(FieldExpr),\n+    ForExpr(ForExpr),\n+    IfExpr(IfExpr),\n+    IndexExpr(IndexExpr),\n+    Literal(Literal),\n+    LoopExpr(LoopExpr),\n+    MacroCall(MacroCall),\n+    MatchExpr(MatchExpr),\n+    MethodCallExpr(MethodCallExpr),\n+    ParenExpr(ParenExpr),\n+    PathExpr(PathExpr),\n+    PrefixExpr(PrefixExpr),\n+    RangeExpr(RangeExpr),\n+    RecordExpr(RecordExpr),\n+    RefExpr(RefExpr),\n+    ReturnExpr(ReturnExpr),\n+    TryExpr(TryExpr),\n+    TupleExpr(TupleExpr),\n+    WhileExpr(WhileExpr),\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Item {\n     Const(Const),\n     Enum(Enum),\n@@ -1333,39 +1365,6 @@ pub enum FieldList {\n     TupleFieldList(TupleFieldList),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum Expr {\n-    ArrayExpr(ArrayExpr),\n-    AwaitExpr(AwaitExpr),\n-    BinExpr(BinExpr),\n-    BlockExpr(BlockExpr),\n-    BoxExpr(BoxExpr),\n-    BreakExpr(BreakExpr),\n-    CallExpr(CallExpr),\n-    CastExpr(CastExpr),\n-    ClosureExpr(ClosureExpr),\n-    ContinueExpr(ContinueExpr),\n-    EffectExpr(EffectExpr),\n-    FieldExpr(FieldExpr),\n-    ForExpr(ForExpr),\n-    IfExpr(IfExpr),\n-    IndexExpr(IndexExpr),\n-    Literal(Literal),\n-    LoopExpr(LoopExpr),\n-    MacroCall(MacroCall),\n-    MatchExpr(MatchExpr),\n-    MethodCallExpr(MethodCallExpr),\n-    ParenExpr(ParenExpr),\n-    PathExpr(PathExpr),\n-    PrefixExpr(PrefixExpr),\n-    RangeExpr(RangeExpr),\n-    RecordExpr(RecordExpr),\n-    RefExpr(RefExpr),\n-    ReturnExpr(ReturnExpr),\n-    TryExpr(TryExpr),\n-    TupleExpr(TupleExpr),\n-    WhileExpr(WhileExpr),\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AdtDef {\n     Enum(Enum),\n     Struct(Struct),\n@@ -1537,28 +1536,6 @@ impl AstNode for TypeBoundList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Literal {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-impl AstNode for BlockExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for SourceFile {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -1834,6 +1811,17 @@ impl AstNode for WhereClause {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for BlockExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for SelfParam {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == SELF_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -1988,6 +1976,17 @@ impl AstNode for WherePred {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for Literal {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for TokenTree {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == TOKEN_TREE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2892,265 +2891,53 @@ impl AstNode for Type {\n         }\n     }\n }\n-impl From<Const> for Item {\n-    fn from(node: Const) -> Item { Item::Const(node) }\n+impl From<ArrayExpr> for Expr {\n+    fn from(node: ArrayExpr) -> Expr { Expr::ArrayExpr(node) }\n }\n-impl From<Enum> for Item {\n-    fn from(node: Enum) -> Item { Item::Enum(node) }\n+impl From<AwaitExpr> for Expr {\n+    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }\n }\n-impl From<ExternBlock> for Item {\n-    fn from(node: ExternBlock) -> Item { Item::ExternBlock(node) }\n+impl From<BinExpr> for Expr {\n+    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }\n }\n-impl From<ExternCrate> for Item {\n-    fn from(node: ExternCrate) -> Item { Item::ExternCrate(node) }\n+impl From<BlockExpr> for Expr {\n+    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }\n }\n-impl From<Fn> for Item {\n-    fn from(node: Fn) -> Item { Item::Fn(node) }\n+impl From<BoxExpr> for Expr {\n+    fn from(node: BoxExpr) -> Expr { Expr::BoxExpr(node) }\n }\n-impl From<Impl> for Item {\n-    fn from(node: Impl) -> Item { Item::Impl(node) }\n+impl From<BreakExpr> for Expr {\n+    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }\n }\n-impl From<MacroCall> for Item {\n-    fn from(node: MacroCall) -> Item { Item::MacroCall(node) }\n+impl From<CallExpr> for Expr {\n+    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }\n }\n-impl From<Module> for Item {\n-    fn from(node: Module) -> Item { Item::Module(node) }\n+impl From<CastExpr> for Expr {\n+    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n }\n-impl From<Static> for Item {\n-    fn from(node: Static) -> Item { Item::Static(node) }\n+impl From<ClosureExpr> for Expr {\n+    fn from(node: ClosureExpr) -> Expr { Expr::ClosureExpr(node) }\n }\n-impl From<Struct> for Item {\n-    fn from(node: Struct) -> Item { Item::Struct(node) }\n+impl From<ContinueExpr> for Expr {\n+    fn from(node: ContinueExpr) -> Expr { Expr::ContinueExpr(node) }\n }\n-impl From<Trait> for Item {\n-    fn from(node: Trait) -> Item { Item::Trait(node) }\n+impl From<EffectExpr> for Expr {\n+    fn from(node: EffectExpr) -> Expr { Expr::EffectExpr(node) }\n }\n-impl From<TypeAlias> for Item {\n-    fn from(node: TypeAlias) -> Item { Item::TypeAlias(node) }\n+impl From<FieldExpr> for Expr {\n+    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }\n }\n-impl From<Union> for Item {\n-    fn from(node: Union) -> Item { Item::Union(node) }\n+impl From<ForExpr> for Expr {\n+    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }\n }\n-impl From<Use> for Item {\n-    fn from(node: Use) -> Item { Item::Use(node) }\n+impl From<IfExpr> for Expr {\n+    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }\n }\n-impl AstNode for Item {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CONST | ENUM | EXTERN_BLOCK | EXTERN_CRATE | FN | IMPL | MACRO_CALL | MODULE\n-            | STATIC | STRUCT | TRAIT | TYPE_ALIAS | UNION | USE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            CONST => Item::Const(Const { syntax }),\n-            ENUM => Item::Enum(Enum { syntax }),\n-            EXTERN_BLOCK => Item::ExternBlock(ExternBlock { syntax }),\n-            EXTERN_CRATE => Item::ExternCrate(ExternCrate { syntax }),\n-            FN => Item::Fn(Fn { syntax }),\n-            IMPL => Item::Impl(Impl { syntax }),\n-            MACRO_CALL => Item::MacroCall(MacroCall { syntax }),\n-            MODULE => Item::Module(Module { syntax }),\n-            STATIC => Item::Static(Static { syntax }),\n-            STRUCT => Item::Struct(Struct { syntax }),\n-            TRAIT => Item::Trait(Trait { syntax }),\n-            TYPE_ALIAS => Item::TypeAlias(TypeAlias { syntax }),\n-            UNION => Item::Union(Union { syntax }),\n-            USE => Item::Use(Use { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            Item::Const(it) => &it.syntax,\n-            Item::Enum(it) => &it.syntax,\n-            Item::ExternBlock(it) => &it.syntax,\n-            Item::ExternCrate(it) => &it.syntax,\n-            Item::Fn(it) => &it.syntax,\n-            Item::Impl(it) => &it.syntax,\n-            Item::MacroCall(it) => &it.syntax,\n-            Item::Module(it) => &it.syntax,\n-            Item::Static(it) => &it.syntax,\n-            Item::Struct(it) => &it.syntax,\n-            Item::Trait(it) => &it.syntax,\n-            Item::TypeAlias(it) => &it.syntax,\n-            Item::Union(it) => &it.syntax,\n-            Item::Use(it) => &it.syntax,\n-        }\n-    }\n+impl From<IndexExpr> for Expr {\n+    fn from(node: IndexExpr) -> Expr { Expr::IndexExpr(node) }\n }\n-impl From<OrPat> for Pat {\n-    fn from(node: OrPat) -> Pat { Pat::OrPat(node) }\n-}\n-impl From<ParenPat> for Pat {\n-    fn from(node: ParenPat) -> Pat { Pat::ParenPat(node) }\n-}\n-impl From<RefPat> for Pat {\n-    fn from(node: RefPat) -> Pat { Pat::RefPat(node) }\n-}\n-impl From<BoxPat> for Pat {\n-    fn from(node: BoxPat) -> Pat { Pat::BoxPat(node) }\n-}\n-impl From<BindPat> for Pat {\n-    fn from(node: BindPat) -> Pat { Pat::BindPat(node) }\n-}\n-impl From<PlaceholderPat> for Pat {\n-    fn from(node: PlaceholderPat) -> Pat { Pat::PlaceholderPat(node) }\n-}\n-impl From<DotDotPat> for Pat {\n-    fn from(node: DotDotPat) -> Pat { Pat::DotDotPat(node) }\n-}\n-impl From<PathPat> for Pat {\n-    fn from(node: PathPat) -> Pat { Pat::PathPat(node) }\n-}\n-impl From<RecordPat> for Pat {\n-    fn from(node: RecordPat) -> Pat { Pat::RecordPat(node) }\n-}\n-impl From<TupleStructPat> for Pat {\n-    fn from(node: TupleStructPat) -> Pat { Pat::TupleStructPat(node) }\n-}\n-impl From<TuplePat> for Pat {\n-    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }\n-}\n-impl From<SlicePat> for Pat {\n-    fn from(node: SlicePat) -> Pat { Pat::SlicePat(node) }\n-}\n-impl From<RangePat> for Pat {\n-    fn from(node: RangePat) -> Pat { Pat::RangePat(node) }\n-}\n-impl From<LiteralPat> for Pat {\n-    fn from(node: LiteralPat) -> Pat { Pat::LiteralPat(node) }\n-}\n-impl From<MacroPat> for Pat {\n-    fn from(node: MacroPat) -> Pat { Pat::MacroPat(node) }\n-}\n-impl AstNode for Pat {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            OR_PAT | PAREN_PAT | REF_PAT | BOX_PAT | BIND_PAT | PLACEHOLDER_PAT | DOT_DOT_PAT\n-            | PATH_PAT | RECORD_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT\n-            | LITERAL_PAT | MACRO_PAT => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            OR_PAT => Pat::OrPat(OrPat { syntax }),\n-            PAREN_PAT => Pat::ParenPat(ParenPat { syntax }),\n-            REF_PAT => Pat::RefPat(RefPat { syntax }),\n-            BOX_PAT => Pat::BoxPat(BoxPat { syntax }),\n-            BIND_PAT => Pat::BindPat(BindPat { syntax }),\n-            PLACEHOLDER_PAT => Pat::PlaceholderPat(PlaceholderPat { syntax }),\n-            DOT_DOT_PAT => Pat::DotDotPat(DotDotPat { syntax }),\n-            PATH_PAT => Pat::PathPat(PathPat { syntax }),\n-            RECORD_PAT => Pat::RecordPat(RecordPat { syntax }),\n-            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),\n-            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),\n-            SLICE_PAT => Pat::SlicePat(SlicePat { syntax }),\n-            RANGE_PAT => Pat::RangePat(RangePat { syntax }),\n-            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),\n-            MACRO_PAT => Pat::MacroPat(MacroPat { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            Pat::OrPat(it) => &it.syntax,\n-            Pat::ParenPat(it) => &it.syntax,\n-            Pat::RefPat(it) => &it.syntax,\n-            Pat::BoxPat(it) => &it.syntax,\n-            Pat::BindPat(it) => &it.syntax,\n-            Pat::PlaceholderPat(it) => &it.syntax,\n-            Pat::DotDotPat(it) => &it.syntax,\n-            Pat::PathPat(it) => &it.syntax,\n-            Pat::RecordPat(it) => &it.syntax,\n-            Pat::TupleStructPat(it) => &it.syntax,\n-            Pat::TuplePat(it) => &it.syntax,\n-            Pat::SlicePat(it) => &it.syntax,\n-            Pat::RangePat(it) => &it.syntax,\n-            Pat::LiteralPat(it) => &it.syntax,\n-            Pat::MacroPat(it) => &it.syntax,\n-        }\n-    }\n-}\n-impl From<RecordFieldList> for FieldList {\n-    fn from(node: RecordFieldList) -> FieldList { FieldList::RecordFieldList(node) }\n-}\n-impl From<TupleFieldList> for FieldList {\n-    fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }\n-}\n-impl AstNode for FieldList {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            RECORD_FIELD_LIST | TUPLE_FIELD_LIST => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            RECORD_FIELD_LIST => FieldList::RecordFieldList(RecordFieldList { syntax }),\n-            TUPLE_FIELD_LIST => FieldList::TupleFieldList(TupleFieldList { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            FieldList::RecordFieldList(it) => &it.syntax,\n-            FieldList::TupleFieldList(it) => &it.syntax,\n-        }\n-    }\n-}\n-impl From<ArrayExpr> for Expr {\n-    fn from(node: ArrayExpr) -> Expr { Expr::ArrayExpr(node) }\n-}\n-impl From<AwaitExpr> for Expr {\n-    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }\n-}\n-impl From<BinExpr> for Expr {\n-    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }\n-}\n-impl From<BlockExpr> for Expr {\n-    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }\n-}\n-impl From<BoxExpr> for Expr {\n-    fn from(node: BoxExpr) -> Expr { Expr::BoxExpr(node) }\n-}\n-impl From<BreakExpr> for Expr {\n-    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }\n-}\n-impl From<CallExpr> for Expr {\n-    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }\n-}\n-impl From<CastExpr> for Expr {\n-    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n-}\n-impl From<ClosureExpr> for Expr {\n-    fn from(node: ClosureExpr) -> Expr { Expr::ClosureExpr(node) }\n-}\n-impl From<ContinueExpr> for Expr {\n-    fn from(node: ContinueExpr) -> Expr { Expr::ContinueExpr(node) }\n-}\n-impl From<EffectExpr> for Expr {\n-    fn from(node: EffectExpr) -> Expr { Expr::EffectExpr(node) }\n-}\n-impl From<FieldExpr> for Expr {\n-    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }\n-}\n-impl From<ForExpr> for Expr {\n-    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }\n-}\n-impl From<IfExpr> for Expr {\n-    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }\n-}\n-impl From<IndexExpr> for Expr {\n-    fn from(node: IndexExpr) -> Expr { Expr::IndexExpr(node) }\n-}\n-impl From<Literal> for Expr {\n-    fn from(node: Literal) -> Expr { Expr::Literal(node) }\n+impl From<Literal> for Expr {\n+    fn from(node: Literal) -> Expr { Expr::Literal(node) }\n }\n impl From<LoopExpr> for Expr {\n     fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }\n@@ -3276,6 +3063,218 @@ impl AstNode for Expr {\n         }\n     }\n }\n+impl From<Const> for Item {\n+    fn from(node: Const) -> Item { Item::Const(node) }\n+}\n+impl From<Enum> for Item {\n+    fn from(node: Enum) -> Item { Item::Enum(node) }\n+}\n+impl From<ExternBlock> for Item {\n+    fn from(node: ExternBlock) -> Item { Item::ExternBlock(node) }\n+}\n+impl From<ExternCrate> for Item {\n+    fn from(node: ExternCrate) -> Item { Item::ExternCrate(node) }\n+}\n+impl From<Fn> for Item {\n+    fn from(node: Fn) -> Item { Item::Fn(node) }\n+}\n+impl From<Impl> for Item {\n+    fn from(node: Impl) -> Item { Item::Impl(node) }\n+}\n+impl From<MacroCall> for Item {\n+    fn from(node: MacroCall) -> Item { Item::MacroCall(node) }\n+}\n+impl From<Module> for Item {\n+    fn from(node: Module) -> Item { Item::Module(node) }\n+}\n+impl From<Static> for Item {\n+    fn from(node: Static) -> Item { Item::Static(node) }\n+}\n+impl From<Struct> for Item {\n+    fn from(node: Struct) -> Item { Item::Struct(node) }\n+}\n+impl From<Trait> for Item {\n+    fn from(node: Trait) -> Item { Item::Trait(node) }\n+}\n+impl From<TypeAlias> for Item {\n+    fn from(node: TypeAlias) -> Item { Item::TypeAlias(node) }\n+}\n+impl From<Union> for Item {\n+    fn from(node: Union) -> Item { Item::Union(node) }\n+}\n+impl From<Use> for Item {\n+    fn from(node: Use) -> Item { Item::Use(node) }\n+}\n+impl AstNode for Item {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONST | ENUM | EXTERN_BLOCK | EXTERN_CRATE | FN | IMPL | MACRO_CALL | MODULE\n+            | STATIC | STRUCT | TRAIT | TYPE_ALIAS | UNION | USE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            CONST => Item::Const(Const { syntax }),\n+            ENUM => Item::Enum(Enum { syntax }),\n+            EXTERN_BLOCK => Item::ExternBlock(ExternBlock { syntax }),\n+            EXTERN_CRATE => Item::ExternCrate(ExternCrate { syntax }),\n+            FN => Item::Fn(Fn { syntax }),\n+            IMPL => Item::Impl(Impl { syntax }),\n+            MACRO_CALL => Item::MacroCall(MacroCall { syntax }),\n+            MODULE => Item::Module(Module { syntax }),\n+            STATIC => Item::Static(Static { syntax }),\n+            STRUCT => Item::Struct(Struct { syntax }),\n+            TRAIT => Item::Trait(Trait { syntax }),\n+            TYPE_ALIAS => Item::TypeAlias(TypeAlias { syntax }),\n+            UNION => Item::Union(Union { syntax }),\n+            USE => Item::Use(Use { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Item::Const(it) => &it.syntax,\n+            Item::Enum(it) => &it.syntax,\n+            Item::ExternBlock(it) => &it.syntax,\n+            Item::ExternCrate(it) => &it.syntax,\n+            Item::Fn(it) => &it.syntax,\n+            Item::Impl(it) => &it.syntax,\n+            Item::MacroCall(it) => &it.syntax,\n+            Item::Module(it) => &it.syntax,\n+            Item::Static(it) => &it.syntax,\n+            Item::Struct(it) => &it.syntax,\n+            Item::Trait(it) => &it.syntax,\n+            Item::TypeAlias(it) => &it.syntax,\n+            Item::Union(it) => &it.syntax,\n+            Item::Use(it) => &it.syntax,\n+        }\n+    }\n+}\n+impl From<OrPat> for Pat {\n+    fn from(node: OrPat) -> Pat { Pat::OrPat(node) }\n+}\n+impl From<ParenPat> for Pat {\n+    fn from(node: ParenPat) -> Pat { Pat::ParenPat(node) }\n+}\n+impl From<RefPat> for Pat {\n+    fn from(node: RefPat) -> Pat { Pat::RefPat(node) }\n+}\n+impl From<BoxPat> for Pat {\n+    fn from(node: BoxPat) -> Pat { Pat::BoxPat(node) }\n+}\n+impl From<BindPat> for Pat {\n+    fn from(node: BindPat) -> Pat { Pat::BindPat(node) }\n+}\n+impl From<PlaceholderPat> for Pat {\n+    fn from(node: PlaceholderPat) -> Pat { Pat::PlaceholderPat(node) }\n+}\n+impl From<DotDotPat> for Pat {\n+    fn from(node: DotDotPat) -> Pat { Pat::DotDotPat(node) }\n+}\n+impl From<PathPat> for Pat {\n+    fn from(node: PathPat) -> Pat { Pat::PathPat(node) }\n+}\n+impl From<RecordPat> for Pat {\n+    fn from(node: RecordPat) -> Pat { Pat::RecordPat(node) }\n+}\n+impl From<TupleStructPat> for Pat {\n+    fn from(node: TupleStructPat) -> Pat { Pat::TupleStructPat(node) }\n+}\n+impl From<TuplePat> for Pat {\n+    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }\n+}\n+impl From<SlicePat> for Pat {\n+    fn from(node: SlicePat) -> Pat { Pat::SlicePat(node) }\n+}\n+impl From<RangePat> for Pat {\n+    fn from(node: RangePat) -> Pat { Pat::RangePat(node) }\n+}\n+impl From<LiteralPat> for Pat {\n+    fn from(node: LiteralPat) -> Pat { Pat::LiteralPat(node) }\n+}\n+impl From<MacroPat> for Pat {\n+    fn from(node: MacroPat) -> Pat { Pat::MacroPat(node) }\n+}\n+impl AstNode for Pat {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            OR_PAT | PAREN_PAT | REF_PAT | BOX_PAT | BIND_PAT | PLACEHOLDER_PAT | DOT_DOT_PAT\n+            | PATH_PAT | RECORD_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT\n+            | LITERAL_PAT | MACRO_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            OR_PAT => Pat::OrPat(OrPat { syntax }),\n+            PAREN_PAT => Pat::ParenPat(ParenPat { syntax }),\n+            REF_PAT => Pat::RefPat(RefPat { syntax }),\n+            BOX_PAT => Pat::BoxPat(BoxPat { syntax }),\n+            BIND_PAT => Pat::BindPat(BindPat { syntax }),\n+            PLACEHOLDER_PAT => Pat::PlaceholderPat(PlaceholderPat { syntax }),\n+            DOT_DOT_PAT => Pat::DotDotPat(DotDotPat { syntax }),\n+            PATH_PAT => Pat::PathPat(PathPat { syntax }),\n+            RECORD_PAT => Pat::RecordPat(RecordPat { syntax }),\n+            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),\n+            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),\n+            SLICE_PAT => Pat::SlicePat(SlicePat { syntax }),\n+            RANGE_PAT => Pat::RangePat(RangePat { syntax }),\n+            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),\n+            MACRO_PAT => Pat::MacroPat(MacroPat { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Pat::OrPat(it) => &it.syntax,\n+            Pat::ParenPat(it) => &it.syntax,\n+            Pat::RefPat(it) => &it.syntax,\n+            Pat::BoxPat(it) => &it.syntax,\n+            Pat::BindPat(it) => &it.syntax,\n+            Pat::PlaceholderPat(it) => &it.syntax,\n+            Pat::DotDotPat(it) => &it.syntax,\n+            Pat::PathPat(it) => &it.syntax,\n+            Pat::RecordPat(it) => &it.syntax,\n+            Pat::TupleStructPat(it) => &it.syntax,\n+            Pat::TuplePat(it) => &it.syntax,\n+            Pat::SlicePat(it) => &it.syntax,\n+            Pat::RangePat(it) => &it.syntax,\n+            Pat::LiteralPat(it) => &it.syntax,\n+            Pat::MacroPat(it) => &it.syntax,\n+        }\n+    }\n+}\n+impl From<RecordFieldList> for FieldList {\n+    fn from(node: RecordFieldList) -> FieldList { FieldList::RecordFieldList(node) }\n+}\n+impl From<TupleFieldList> for FieldList {\n+    fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }\n+}\n+impl AstNode for FieldList {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            RECORD_FIELD_LIST | TUPLE_FIELD_LIST => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            RECORD_FIELD_LIST => FieldList::RecordFieldList(RecordFieldList { syntax }),\n+            TUPLE_FIELD_LIST => FieldList::TupleFieldList(TupleFieldList { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            FieldList::RecordFieldList(it) => &it.syntax,\n+            FieldList::TupleFieldList(it) => &it.syntax,\n+        }\n+    }\n+}\n impl From<Enum> for AdtDef {\n     fn from(node: Enum) -> AdtDef { AdtDef::Enum(node) }\n }\n@@ -3432,22 +3431,22 @@ impl std::fmt::Display for Type {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Item {\n+impl std::fmt::Display for Expr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Pat {\n+impl std::fmt::Display for Item {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for FieldList {\n+impl std::fmt::Display for Pat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Expr {\n+impl std::fmt::Display for FieldList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3537,16 +3536,6 @@ impl std::fmt::Display for TypeBoundList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Literal {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for BlockExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for SourceFile {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3672,6 +3661,11 @@ impl std::fmt::Display for WhereClause {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for BlockExpr {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for SelfParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3742,6 +3736,11 @@ impl std::fmt::Display for WherePred {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for Literal {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "69e98b9d6c0267beb49835a90e9f946d324c905a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0039_type_arg.rast", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddf08daddf7e86d67e8d2e5596f8013b376dd522/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0039_type_arg.rast", "raw_url": "https://github.com/rust-lang/rust/raw/ddf08daddf7e86d67e8d2e5596f8013b376dd522/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0039_type_arg.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0039_type_arg.rast?ref=ddf08daddf7e86d67e8d2e5596f8013b376dd522", "patch": "@@ -27,7 +27,8 @@ SOURCE_FILE@0..46\n             COMMA@23..24 \",\"\n             WHITESPACE@24..25 \" \"\n             CONST_ARG@25..26\n-              INT_NUMBER@25..26 \"1\"\n+              LITERAL@25..26\n+                INT_NUMBER@25..26 \"1\"\n             COMMA@26..27 \",\"\n             WHITESPACE@27..28 \" \"\n             CONST_ARG@28..33"}, {"sha": "8536b974819a0f365e39506a540516320c369ca3", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf08daddf7e86d67e8d2e5596f8013b376dd522/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/ddf08daddf7e86d67e8d2e5596f8013b376dd522/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=ddf08daddf7e86d67e8d2e5596f8013b376dd522", "patch": "@@ -26,7 +26,7 @@ LifetimeArg =\n   'lifetime'\n \n ConstArg =\n-  Literal | BlockExpr BlockExpr\n+  Expr\n \n SourceFile =\n   'shebang'?"}]}