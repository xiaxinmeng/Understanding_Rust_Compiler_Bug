{"sha": "144e576c87627a01dc6ab387f57a21a03659021d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NGU1NzZjODc2MjdhMDFkYzZhYjM4N2Y1N2EyMWEwMzY1OTAyMWQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2016-08-22T22:57:54Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2016-08-27T13:20:45Z"}, "message": "Use `FnvHashMap` in more places\n\n* A step towards #34902\n* More stable error messages in some places related to crate loading\n* Possible slight performance improvements since all `HashMap`s\n  replaced had small keys where `FnvHashMap` should be faster\n  (although I didn't measure)", "tree": {"sha": "1cf8bd0e641af202523655d242d19d7df5b8b10e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cf8bd0e641af202523655d242d19d7df5b8b10e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/144e576c87627a01dc6ab387f57a21a03659021d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/144e576c87627a01dc6ab387f57a21a03659021d", "html_url": "https://github.com/rust-lang/rust/commit/144e576c87627a01dc6ab387f57a21a03659021d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/144e576c87627a01dc6ab387f57a21a03659021d/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "url": "https://api.github.com/repos/rust-lang/rust/commits/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91", "html_url": "https://github.com/rust-lang/rust/commit/099b9fdb1a170b57ffd7174b3c3042cc86b7fe91"}], "stats": {"total": 156, "additions": 76, "deletions": 80}, "files": [{"sha": "f793d489cab064866ce927a07b32a8f707bf396a", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -32,15 +32,16 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n-use std::collections::hash_map::{self, Entry};\n+use util::nodemap::FnvHashMap;\n+use std::collections::hash_map::Entry;\n \n use super::InferCtxt;\n use super::unify_key::ToType;\n \n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n-    freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_map: FnvHashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -49,7 +50,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n-            freshen_map: hash_map::HashMap::new(),\n+            freshen_map: FnvHashMap(),\n         }\n     }\n "}, {"sha": "f44b149a84617de12abdabd5d27af7f54e67f66a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -22,8 +22,8 @@ use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n+use util::nodemap::FnvHashSet;\n \n-use std::collections::HashSet;\n use syntax::{ast, codemap};\n use syntax::attr;\n use syntax_pos;\n@@ -48,7 +48,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<HashSet<ast::NodeId>>,\n+    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n-            live_symbols: box HashSet::new(),\n+            live_symbols: box FnvHashSet(),\n             struct_has_extern_repr: false,\n             ignore_non_const_paths: false,\n             inherited_pub_visibility: false,\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn mark_live_symbols(&mut self) {\n-        let mut scanned = HashSet::new();\n+        let mut scanned = FnvHashSet();\n         while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n@@ -395,7 +395,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> Box<HashSet<ast::NodeId>> {\n+                       -> Box<FnvHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -413,7 +413,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<HashSet<ast::NodeId>>,\n+    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {"}, {"sha": "e29a7cf9d68467a332147ee06ccf853825231ff6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -22,9 +22,8 @@ use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n use middle::privacy;\n use session::config;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{NodeSet, FnvHashSet};\n \n-use std::collections::HashSet;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n@@ -204,7 +203,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n-        let mut scanned = HashSet::new();\n+        let mut scanned = FnvHashSet();\n         loop {\n             let search_item = match self.worklist.pop() {\n                 Some(item) => item,"}, {"sha": "b2c87db8ef56636293142e40894fef91b49152ed", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -221,6 +221,7 @@ use rustc::session::Session;\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::common;\n+use rustc::util::nodemap::FnvHashMap;\n \n use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n@@ -230,7 +231,6 @@ use syntax_pos::Span;\n use rustc_back::target::Target;\n \n use std::cmp;\n-use std::collections::HashMap;\n use std::fmt;\n use std::fs;\n use std::io;\n@@ -413,7 +413,7 @@ impl<'a> Context<'a> {\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n-        let mut candidates = HashMap::new();\n+        let mut candidates = FnvHashMap();\n         let mut staticlibs = vec!();\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n@@ -456,7 +456,7 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                                 .or_insert_with(|| (HashMap::new(), HashMap::new()));\n+                                 .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             fs::canonicalize(path).map(|p| {\n                 if rlib {\n@@ -477,7 +477,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n-        let mut libraries = HashMap::new();\n+        let mut libraries = FnvHashMap();\n         for (_hash, (rlibs, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n@@ -527,7 +527,7 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    fn extract_one(&mut self, m: HashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n+    fn extract_one(&mut self, m: FnvHashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n                    slot: &mut Option<(Svh, MetadataBlob)>) -> Option<(PathBuf, PathKind)> {\n         let mut ret: Option<(PathBuf, PathKind)> = None;\n         let mut error = 0;\n@@ -669,8 +669,8 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut rlibs = HashMap::new();\n-        let mut dylibs = HashMap::new();\n+        let mut rlibs = FnvHashMap();\n+        let mut dylibs = FnvHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {"}, {"sha": "2cd60f04e69a1dadc22e2b8375b63f79cccbe64e", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -14,8 +14,8 @@ use creader::CrateReader;\n use cstore::CStore;\n \n use rustc::session::Session;\n+use rustc::util::nodemap::{FnvHashSet, FnvHashMap};\n \n-use std::collections::{HashSet, HashMap};\n use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n@@ -45,13 +45,13 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n     span_err!(a, b, E0467, \"bad macro reexport\");\n }\n \n-pub type MacroSelection = HashMap<token::InternedString, Span>;\n+pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<ast::MacroDef> {\n         // Parse the attributes relating to macros.\n-        let mut import = Some(HashMap::new());  // None => load all\n-        let mut reexport = HashMap::new();\n+        let mut import = Some(FnvHashMap());  // None => load all\n+        let mut reexport = FnvHashMap();\n \n         for attr in &extern_crate.attrs {\n             let mut used = true;\n@@ -120,7 +120,7 @@ impl<'a> MacroLoader<'a> {\n         }\n \n         let mut macros = Vec::new();\n-        let mut seen = HashSet::new();\n+        let mut seen = FnvHashSet();\n \n         for mut def in self.reader.read_exported_macros(vi) {\n             let name = def.ident.name.as_str();"}, {"sha": "a9e3c6ffe9ed887d028208dab5d64fa7e49d70e3", "filename": "src/librustc_resolve/assign_ids.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -10,14 +10,14 @@\n \n use Resolver;\n use rustc::session::Session;\n+use rustc::util::nodemap::FnvHashMap;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n use syntax::util::small_vector::SmallVector;\n \n-use std::collections::HashMap;\n use std::mem;\n \n impl<'a> Resolver<'a> {\n@@ -31,7 +31,7 @@ impl<'a> Resolver<'a> {\n \n struct NodeIdAssigner<'a> {\n     sess: &'a Session,\n-    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<Mark>>,\n+    macros_at_scope: &'a mut FnvHashMap<ast::NodeId, Vec<Mark>>,\n }\n \n impl<'a> Folder for NodeIdAssigner<'a> {"}, {"sha": "6a4a48377c783280e9ae40b379337fc99c00aea0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -68,7 +68,6 @@ use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, T\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n-use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n@@ -498,7 +497,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<ast::Ident, BindingInfo>;\n+type BindingMap = FnvHashMap<ast::Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -703,14 +702,14 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<ast::Ident, Def>,\n+    bindings: FnvHashMap<ast::Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n impl<'a> Rib<'a> {\n     fn new(kind: RibKind<'a>) -> Rib<'a> {\n         Rib {\n-            bindings: HashMap::new(),\n+            bindings: FnvHashMap(),\n             kind: kind,\n         }\n     }\n@@ -773,7 +772,7 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: Cell<bool>,\n \n@@ -797,7 +796,7 @@ impl<'a> ModuleS<'a> {\n             parent_link: parent_link,\n             def: def,\n             extern_crate_id: None,\n-            resolutions: RefCell::new(HashMap::new()),\n+            resolutions: RefCell::new(FnvHashMap()),\n             no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -930,12 +929,12 @@ impl<'a> NameBinding<'a> {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: HashMap<Name, PrimTy>,\n+    primitive_types: FnvHashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n-        let mut table = PrimitiveTypeTable { primitive_types: HashMap::new() };\n+        let mut table = PrimitiveTypeTable { primitive_types: FnvHashMap() };\n \n         table.intern(\"bool\", TyBool);\n         table.intern(\"char\", TyChar);\n@@ -969,7 +968,7 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: HashMap<NodeId, Vec<Mark>>,\n+    macros_at_scope: FnvHashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n@@ -1043,8 +1042,8 @@ pub struct Resolver<'a> {\n     // all imports, but only glob imports are actually interesting).\n     pub glob_map: GlobMap,\n \n-    used_imports: HashSet<(NodeId, Namespace)>,\n-    used_crates: HashSet<CrateNum>,\n+    used_imports: FnvHashSet<(NodeId, Namespace)>,\n+    used_crates: FnvHashSet<CrateNum>,\n     pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -1164,7 +1163,7 @@ impl<'a> Resolver<'a> {\n             session: session,\n \n             definitions: Definitions::new(),\n-            macros_at_scope: HashMap::new(),\n+            macros_at_scope: FnvHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1199,8 +1198,8 @@ impl<'a> Resolver<'a> {\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            used_imports: HashSet::new(),\n-            used_crates: HashSet::new(),\n+            used_imports: FnvHashSet(),\n+            used_crates: FnvHashSet(),\n             maybe_unused_trait_imports: NodeSet(),\n \n             privacy_errors: Vec::new(),\n@@ -1729,7 +1728,7 @@ impl<'a> Resolver<'a> {\n         match type_parameters {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = HashMap::new();\n+                let mut seen_bindings = FnvHashMap();\n                 for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n@@ -1793,7 +1792,7 @@ impl<'a> Resolver<'a> {\n         self.label_ribs.push(Rib::new(rib_kind));\n \n         // Add each argument to the rib.\n-        let mut bindings_list = HashMap::new();\n+        let mut bindings_list = FnvHashMap();\n         for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n \n@@ -1994,15 +1993,15 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut HashMap::new());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FnvHashMap());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut binding_map = HashMap::new();\n+        let mut binding_map = FnvHashMap();\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n@@ -2062,7 +2061,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n-        let mut bindings_list = HashMap::new();\n+        let mut bindings_list = FnvHashMap();\n         for pattern in &arm.pats {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n@@ -2202,7 +2201,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut HashMap<ast::Ident, NodeId>)\n+                     bindings: &mut FnvHashMap<ast::Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2303,7 +2302,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut HashMap<ast::Ident, NodeId>) {\n+                       bindings: &mut FnvHashMap<ast::Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -3016,7 +3015,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FnvHashMap());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3026,7 +3025,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FnvHashMap());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3036,7 +3035,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FnvHashMap());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3297,7 +3296,7 @@ impl<'a> Resolver<'a> {\n \n     fn report_privacy_errors(&self) {\n         if self.privacy_errors.len() == 0 { return }\n-        let mut reported_spans = HashSet::new();\n+        let mut reported_spans = FnvHashSet();\n         for &PrivacyError(span, name, binding) in &self.privacy_errors {\n             if !reported_spans.insert(span) { continue }\n             if binding.is_extern_crate() {"}, {"sha": "a183fc0858aa8feb46ac35344dce4d9887ec60f6", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -80,14 +80,13 @@ use type_of;\n use value::Value;\n use Disr;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeSet, FnvHashSet};\n+use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n@@ -1915,7 +1914,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     }\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n-        let mut item_to_cgus = HashMap::new();\n+        let mut item_to_cgus = FnvHashMap();\n \n         for cgu in &codegen_units {\n             for (&trans_item, &linkage) in cgu.items() {"}, {"sha": "d0b0242544981c619e1ebc2b2d2c8db78a810bb6", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -16,9 +16,9 @@ use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n+use rustc::util::nodemap::FnvHashMap;\n use {CrateCtxt, require_same_types};\n \n-use std::collections::{HashMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::parse::token;\n@@ -365,7 +365,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                         return\n                     }\n \n-                    let mut structural_to_nomimal = HashMap::new();\n+                    let mut structural_to_nomimal = FnvHashMap();\n \n                     let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n@@ -405,7 +405,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         ccx: &CrateCtxt<'a, 'tcx>,\n         position: &str,\n         span: Span,\n-        structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        structural_to_nominal: &mut FnvHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n         expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n {\n     use intrinsics::Type::*;"}, {"sha": "29366823fffdc89feb9ecb176daa1f2879ae0132", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -20,10 +20,10 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n+use rustc::util::nodemap::FnvHashSet;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir;\n-use std::collections::HashSet;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -40,7 +40,7 @@ struct ProbeContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n-    impl_dups: HashSet<DefId>,\n+    impl_dups: FnvHashSet<DefId>,\n     import_id: Option<ast::NodeId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n-            impl_dups: HashSet::new(),\n+            impl_dups: FnvHashSet(),\n             import_id: None,\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n@@ -574,7 +574,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                          expr_id: ast::NodeId)\n                                                          -> Result<(), MethodError<'tcx>>\n     {\n-        let mut duplicates = HashSet::new();\n+        let mut duplicates = FnvHashSet();\n         let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits {\n@@ -591,7 +591,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n-        let mut duplicates = HashSet::new();\n+        let mut duplicates = FnvHashSet();\n         for trait_info in suggest::all_traits(self.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(trait_info.def_id)?;"}, {"sha": "fb24971c4251dfdc53ce617860f063e709b2fa40", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -104,10 +104,9 @@ use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::{HashSet};\n use std::mem::replace;\n use std::ops::Deref;\n use syntax::abi::Abi;\n@@ -2045,7 +2044,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .filter_map(|t| self.default(t).map(|d| (t, d)))\n                     .collect();\n \n-            let mut unbound_tyvars = HashSet::new();\n+            let mut unbound_tyvars = FnvHashSet();\n \n             debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n \n@@ -2192,7 +2191,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n     fn find_conflicting_default(&self,\n-                                unbound_vars: &HashSet<Ty<'tcx>>,\n+                                unbound_vars: &FnvHashSet<Ty<'tcx>>,\n                                 default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n                                 conflict: Ty<'tcx>)\n                                 -> Option<type_variable::Default<'tcx>> {"}, {"sha": "6b6a688bf1d18779e31057a9835d2e09baa1496a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -16,8 +16,8 @@ use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::util::nodemap::FnvHashSet;\n \n-use std::collections::HashSet;\n use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -456,7 +456,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n-        let mut constrained_parameters: HashSet<_> =\n+        let mut constrained_parameters: FnvHashSet<_> =\n             variances[ast_generics.lifetimes.len()..]\n                      .iter().enumerate()\n                      .filter(|&(_, &variance)| variance != ty::Bivariant)\n@@ -519,7 +519,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n     let parent = tcx.lookup_generics(generics.parent.unwrap());\n-    let impl_params: HashSet<_> = parent.types.iter().map(|tp| tp.name).collect();\n+    let impl_params: FnvHashSet<_> = parent.types.iter().map(|tp| tp.name).collect();\n \n     for method_param in &generics.types {\n         if impl_params.contains(&method_param.name) {"}, {"sha": "30b9d15587069e704361635dfe35175a59410cd1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -73,13 +73,12 @@ use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FnvHashMap};\n+use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n use {CrateCtxt, write_ty_to_tcx};\n \n use rustc_const_math::ConstInt;\n \n use std::cell::RefCell;\n-use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n \n@@ -1927,9 +1926,9 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: HashSet<_> = inline_bounds.into_iter()\n-                                              .chain(where_bounds)\n-                                              .collect();\n+    let all_bounds: FnvHashSet<_> = inline_bounds.into_iter()\n+                                                 .chain(where_bounds)\n+                                                 .collect();\n     return if all_bounds.len() > 1 {\n         ty::ObjectLifetimeDefault::Ambiguous\n     } else if all_bounds.len() == 0 {\n@@ -2146,7 +2145,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n-    let mut input_parameters: HashSet<_> =\n+    let mut input_parameters: FnvHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n@@ -2175,15 +2174,15 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n-    let mut input_parameters: HashSet<_> =\n+    let mut input_parameters: FnvHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n     ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    let lifetimes_in_associated_types: HashSet<_> = impl_items.iter()\n+    let lifetimes_in_associated_types: FnvHashSet<_> = impl_items.iter()\n         .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n         .filter_map(|item| match item {\n             ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,"}, {"sha": "9e5c3a5d575bff6988c30b44ee6b1a0aaea11717", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144e576c87627a01dc6ab387f57a21a03659021d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=144e576c87627a01dc6ab387f57a21a03659021d", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::{self, Ty};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use std::collections::HashSet;\n+use rustc::util::nodemap::FnvHashSet;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Parameter {\n@@ -71,7 +71,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n \n pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                              input_parameters: &mut HashSet<Parameter>)\n+                                              input_parameters: &mut FnvHashSet<Parameter>)\n {\n     let mut predicates = predicates.to_owned();\n     setup_constraining_predicates(&mut predicates, impl_trait_ref, input_parameters);\n@@ -120,7 +120,7 @@ pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>]\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                           input_parameters: &mut HashSet<Parameter>)\n+                                           input_parameters: &mut FnvHashSet<Parameter>)\n {\n     // The canonical way of doing the needed topological sort\n     // would be a DFS, but getting the graph and its ownership"}]}