{"sha": "cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNDZiZDUwMzdhODYyMzdiOWJlNGViMjE4ZDU3ZDcxYmI4ZTJjY2Y=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-02-20T11:13:35Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-04-23T22:54:14Z"}, "message": "Replace the robin-hood hash table with hashbrown", "tree": {"sha": "3d90cb7b28c0b746389402a70f95961358c3d9e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d90cb7b28c0b746389402a70f95961358c3d9e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "html_url": "https://github.com/rust-lang/rust/commit/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fa7a21534bde7315bc78be970a342262ddf7a58", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa7a21534bde7315bc78be970a342262ddf7a58", "html_url": "https://github.com/rust-lang/rust/commit/1fa7a21534bde7315bc78be970a342262ddf7a58"}], "stats": {"total": 2683, "additions": 405, "deletions": 2278}, "files": [{"sha": "ecb08314f6d05ce44d063a6acd54abaacbd1f49c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 405, "deletions": 1144, "changes": 1549, "blob_url": "https://github.com/rust-lang/rust/blob/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "patch": "@@ -1,222 +1,18 @@\n use self::Entry::*;\n-use self::VacantEntryState::*;\n \n-use crate::intrinsics::unlikely;\n-use crate::collections::CollectionAllocErr;\n-use crate::cell::Cell;\n+use hashbrown::hash_map as base;\n+\n use crate::borrow::Borrow;\n-use crate::cmp::max;\n+use crate::cell::Cell;\n+use crate::collections::CollectionAllocErr;\n use crate::fmt::{self, Debug};\n #[allow(deprecated)]\n-use crate::hash::{Hash, Hasher, BuildHasher, SipHasher13};\n+use crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\n use crate::iter::{FromIterator, FusedIterator};\n-use crate::mem::{self, replace};\n-use crate::ops::{Deref, DerefMut, Index};\n+use crate::ops::Index;\n use crate::sys;\n \n-use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucketMut, RawTable,\n-                   SafeHash};\n-use super::table::BucketState::{Empty, Full};\n-use super::table::Fallibility::{Fallible, Infallible};\n-\n-const MIN_NONZERO_RAW_CAPACITY: usize = 32; // must be a power of two\n-\n-/// The default behavior of HashMap implements a maximum load factor of 90.9%.\n-#[derive(Clone)]\n-struct DefaultResizePolicy;\n-\n-impl DefaultResizePolicy {\n-    #[inline]\n-    fn new() -> DefaultResizePolicy {\n-        DefaultResizePolicy\n-    }\n-\n-    /// A hash map's \"capacity\" is the number of elements it can hold without\n-    /// being resized. Its \"raw capacity\" is the number of slots required to\n-    /// provide that capacity, accounting for maximum loading. The raw capacity\n-    /// is always zero or a power of two.\n-    #[inline]\n-    fn try_raw_capacity(&self, len: usize) -> Result<usize, CollectionAllocErr> {\n-        if len == 0 {\n-            Ok(0)\n-        } else {\n-            // 1. Account for loading: `raw_capacity >= len * 1.1`.\n-            // 2. Ensure it is a power of two.\n-            // 3. Ensure it is at least the minimum size.\n-            let mut raw_cap = len.checked_mul(11)\n-                .map(|l| l / 10)\n-                .and_then(|l| l.checked_next_power_of_two())\n-                .ok_or(CollectionAllocErr::CapacityOverflow)?;\n-\n-            raw_cap = max(MIN_NONZERO_RAW_CAPACITY, raw_cap);\n-            Ok(raw_cap)\n-        }\n-    }\n-\n-    #[inline]\n-    fn raw_capacity(&self, len: usize) -> usize {\n-        self.try_raw_capacity(len).expect(\"raw_capacity overflow\")\n-    }\n-\n-    /// The capacity of the given raw capacity.\n-    #[inline]\n-    fn capacity(&self, raw_cap: usize) -> usize {\n-        // This doesn't have to be checked for overflow since allocation size\n-        // in bytes will overflow earlier than multiplication by 10.\n-        //\n-        // As per https://github.com/rust-lang/rust/pull/30991 this is updated\n-        // to be: (raw_cap * den + den - 1) / num\n-        (raw_cap * 10 + 10 - 1) / 11\n-    }\n-}\n-\n-// The main performance trick in this hashmap is called Robin Hood Hashing.\n-// It gains its excellent performance from one essential operation:\n-//\n-//    If an insertion collides with an existing element, and that element's\n-//    \"probe distance\" (how far away the element is from its ideal location)\n-//    is higher than how far we've already probed, swap the elements.\n-//\n-// This massively lowers variance in probe distance, and allows us to get very\n-// high load factors with good performance. The 90% load factor I use is rather\n-// conservative.\n-//\n-// > Why a load factor of approximately 90%?\n-//\n-// In general, all the distances to initial buckets will converge on the mean.\n-// At a load factor of \u03b1, the odds of finding the target bucket after k\n-// probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n-// on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n-// this down to make the math easier on the CPU and avoid its FPU.\n-// Since on average we start the probing in the middle of a cache line, this\n-// strategy pulls in two cache lines of hashes on every lookup. I think that's\n-// pretty good, but if you want to trade off some space, it could go down to one\n-// cache line on average with an \u03b1 of 0.84.\n-//\n-// > Wait, what? Where did you get 1-\u03b1^k from?\n-//\n-// On the first probe, your odds of a collision with an existing element is \u03b1.\n-// The odds of doing this twice in a row is approximately \u03b1^2. For three times,\n-// \u03b1^3, etc. Therefore, the odds of colliding k times is \u03b1^k. The odds of NOT\n-// colliding after k tries is 1-\u03b1^k.\n-//\n-// The paper from 1986 cited below mentions an implementation which keeps track\n-// of the distance-to-initial-bucket histogram. This approach is not suitable\n-// for modern architectures because it requires maintaining an internal data\n-// structure. This allows very good first guesses, but we are most concerned\n-// with guessing entire cache lines, not individual indexes. Furthermore, array\n-// accesses are no longer linear and in one direction, as we have now. There\n-// is also memory and cache pressure that this would entail that would be very\n-// difficult to properly see in a microbenchmark.\n-//\n-// ## Future Improvements (FIXME!)\n-//\n-// Allow the load factor to be changed dynamically and/or at initialization.\n-//\n-// Also, would it be possible for us to reuse storage when growing the\n-// underlying table? This is exactly the use case for 'realloc', and may\n-// be worth exploring.\n-//\n-// ## Future Optimizations (FIXME!)\n-//\n-// Another possible design choice that I made without any real reason is\n-// parameterizing the raw table over keys and values. Technically, all we need\n-// is the size and alignment of keys and values, and the code should be just as\n-// efficient (well, we might need one for power-of-two size and one for not...).\n-// This has the potential to reduce code bloat in rust executables, without\n-// really losing anything except 4 words (key size, key alignment, val size,\n-// val alignment) which can be passed in to every call of a `RawTable` function.\n-// This would definitely be an avenue worth exploring if people start complaining\n-// about the size of rust executables.\n-//\n-// Annotate exceedingly likely branches in `table::make_hash`\n-// and `search_hashed` to reduce instruction cache pressure\n-// and mispredictions once it becomes possible (blocked on issue #11092).\n-//\n-// Shrinking the table could simply reallocate in place after moving buckets\n-// to the first half.\n-//\n-// The growth algorithm (fragment of the Proof of Correctness)\n-// --------------------\n-//\n-// The growth algorithm is basically a fast path of the naive reinsertion-\n-// during-resize algorithm. Other paths should never be taken.\n-//\n-// Consider growing a robin hood hashtable of capacity n. Normally, we do this\n-// by allocating a new table of capacity `2n`, and then individually reinsert\n-// each element in the old table into the new one. This guarantees that the\n-// new table is a valid robin hood hashtable with all the desired statistical\n-// properties. Remark that the order we reinsert the elements in should not\n-// matter. For simplicity and efficiency, we will consider only linear\n-// reinsertions, which consist of reinserting all elements in the old table\n-// into the new one by increasing order of index. However we will not be\n-// starting our reinsertions from index 0 in general. If we start from index\n-// i, for the purpose of reinsertion we will consider all elements with real\n-// index j < i to have virtual index n + j.\n-//\n-// Our hash generation scheme consists of generating a 64-bit hash and\n-// truncating the most significant bits. When moving to the new table, we\n-// simply introduce a new bit to the front of the hash. Therefore, if an\n-// element has ideal index i in the old table, it can have one of two ideal\n-// locations in the new table. If the new bit is 0, then the new ideal index\n-// is i. If the new bit is 1, then the new ideal index is n + i. Intuitively,\n-// we are producing two independent tables of size n, and for each element we\n-// independently choose which table to insert it into with equal probability.\n-// However, rather than wrapping around themselves on overflowing their\n-// indexes, the first table overflows into the second, and the second into the\n-// first. Visually, our new table will look something like:\n-//\n-// [yy_xxx_xxxx_xxx|xx_yyy_yyyy_yyy]\n-//\n-// Where x's are elements inserted into the first table, y's are elements\n-// inserted into the second, and _'s are empty sections. We now define a few\n-// key concepts that we will use later. Note that this is a very abstract\n-// perspective of the table. A real resized table would be at least half\n-// empty.\n-//\n-// Theorem: A linear robin hood reinsertion from the first ideal element\n-// produces identical results to a linear naive reinsertion from the same\n-// element.\n-//\n-// FIXME(Gankro, pczarn): review the proof and put it all in a separate README.md\n-//\n-// Adaptive early resizing\n-// ----------------------\n-// To protect against degenerate performance scenarios (including DOS attacks),\n-// the implementation includes an adaptive behavior that can resize the map\n-// early (before its capacity is exceeded) when suspiciously long probe sequences\n-// are encountered.\n-//\n-// With this algorithm in place it would be possible to turn a CPU attack into\n-// a memory attack due to the aggressive resizing. To prevent that the\n-// adaptive behavior only triggers when the map is at least half full.\n-// This reduces the effectiveness of the algorithm but also makes it completely safe.\n-//\n-// The previous safety measure also prevents degenerate interactions with\n-// really bad quality hash algorithms that can make normal inputs look like a\n-// DOS attack.\n-//\n-const DISPLACEMENT_THRESHOLD: usize = 128;\n-//\n-// The threshold of 128 is chosen to minimize the chance of exceeding it.\n-// In particular, we want that chance to be less than 10^-8 with a load of 90%.\n-// For displacement, the smallest constant that fits our needs is 90,\n-// so we round that up to 128.\n-//\n-// At a load factor of \u03b1, the odds of finding the target bucket after exactly n\n-// unsuccessful probes[1] are\n-//\n-// Pr_\u03b1{displacement = n} =\n-// (1 - \u03b1) / \u03b1 * \u2211_{k\u22651} e^(-k\u03b1) * (k\u03b1)^(k+n) / (k + n)! * (1 - k\u03b1 / (k + n + 1))\n-//\n-// We use this formula to find the probability of triggering the adaptive behavior\n-//\n-// Pr_0.909{displacement > 128} = 1.601 * 10^-11\n-//\n-// 1. Alfredo Viola (2005). Distributional analysis of Robin Hood linear probing\n-//    hashing with buckets.\n-\n-/// A hash map implemented with linear probing and Robin Hood bucket stealing.\n+/// A hash map implemented with quadratic probing and SIMD lookup.\n ///\n /// By default, `HashMap` uses a hashing algorithm selected to provide\n /// resistance against HashDoS attacks. The algorithm is randomly seeded, and a\n@@ -254,13 +50,13 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n /// the [`Eq`] trait, changes while it is in the map. This is normally only\n /// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// Relevant papers/articles:\n+/// The hash table implementation is a Rust port of Google's [SwissTable].\n+/// The original C++ version of SwissTable can be found [here], and this\n+/// [CppCon talk] gives an overview of how the algorithm works.\n ///\n-/// 1. Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n-/// 2. Emmanuel Goossaert. [\"Robin Hood\n-///    hashing\"](http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n-/// 3. Emmanuel Goossaert. [\"Robin Hood hashing: backward shift\n-///    deletion\"](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n+/// [SwissTable]: https://abseil.io/blog/20180927-swisstables\n+/// [here]: https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h\n+/// [CppCon talk]: https://www.youtube.com/watch?v=ncHmEUmJZf4\n ///\n /// # Examples\n ///\n@@ -407,277 +203,7 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {\n-    // All hashes are keyed on these values, to prevent hash collision attacks.\n-    hash_builder: S,\n-\n-    table: RawTable<K, V>,\n-\n-    resize_policy: DefaultResizePolicy,\n-}\n-\n-/// Search for a pre-hashed key.\n-/// If you don't already know the hash, use search or search_mut instead\n-#[inline]\n-fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>>,\n-          F: FnMut(&K) -> bool\n-{\n-    // This is the only function where capacity can be zero. To avoid\n-    // undefined behavior when Bucket::new gets the raw bucket in this\n-    // case, immediately return the appropriate search result.\n-    if table.capacity() == 0 {\n-        return InternalEntry::TableIsEmpty;\n-    }\n-\n-    search_hashed_nonempty(table, hash, is_match, true)\n-}\n-\n-/// Search for a pre-hashed key when the hash map is known to be non-empty.\n-#[inline]\n-fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F,\n-                                      compare_hashes: bool)\n-    -> InternalEntry<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>>,\n-          F: FnMut(&K) -> bool\n-{\n-    // Do not check the capacity as an extra branch could slow the lookup.\n-\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let mut displacement = 0;\n-\n-    loop {\n-        let full = match probe.peek() {\n-            Empty(bucket) => {\n-                // Found a hole!\n-                return InternalEntry::Vacant {\n-                    hash,\n-                    elem: NoElem(bucket, displacement),\n-                };\n-            }\n-            Full(bucket) => bucket,\n-        };\n-\n-        let probe_displacement = full.displacement();\n-\n-        if probe_displacement < displacement {\n-            // Found a luckier bucket than me.\n-            // We can finish the search early if we hit any bucket\n-            // with a lower distance to initial bucket than we've probed.\n-            return InternalEntry::Vacant {\n-                hash,\n-                elem: NeqElem(full, probe_displacement),\n-            };\n-        }\n-\n-        // If the hash doesn't match, it can't be this one..\n-        if !compare_hashes || hash == full.hash() {\n-            // If the key doesn't match, it can't be this one..\n-            if is_match(full.read().0) {\n-                return InternalEntry::Occupied { elem: full };\n-            }\n-        }\n-        displacement += 1;\n-        probe = full.next();\n-        debug_assert!(displacement <= size);\n-    }\n-}\n-\n-/// Same as `search_hashed_nonempty` but for mutable access.\n-#[inline]\n-fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F,\n-                                          compare_hashes: bool)\n-    -> InternalEntry<K, V, M>\n-    where M: DerefMut<Target = RawTable<K, V>>,\n-          F: FnMut(&K) -> bool\n-{\n-    // Do not check the capacity as an extra branch could slow the lookup.\n-\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let mut displacement = 0;\n-\n-    loop {\n-        let mut full = match probe.peek() {\n-            Empty(bucket) => {\n-                // Found a hole!\n-                return InternalEntry::Vacant {\n-                    hash,\n-                    elem: NoElem(bucket, displacement),\n-                };\n-            }\n-            Full(bucket) => bucket,\n-        };\n-\n-        let probe_displacement = full.displacement();\n-\n-        if probe_displacement < displacement {\n-            // Found a luckier bucket than me.\n-            // We can finish the search early if we hit any bucket\n-            // with a lower distance to initial bucket than we've probed.\n-            return InternalEntry::Vacant {\n-                hash,\n-                elem: NeqElem(full, probe_displacement),\n-            };\n-        }\n-\n-        // If the hash doesn't match, it can't be this one..\n-        if hash == full.hash() || !compare_hashes {\n-            // If the key doesn't match, it can't be this one..\n-            if is_match(full.read_mut().0) {\n-                return InternalEntry::Occupied { elem: full };\n-            }\n-        }\n-        displacement += 1;\n-        probe = full.next();\n-        debug_assert!(displacement <= size);\n-    }\n-}\n-\n-fn pop_internal<K, V>(starting_bucket: FullBucketMut<'_, K, V>)\n-    -> (K, V, &mut RawTable<K, V>)\n-{\n-    let (empty, retkey, retval) = starting_bucket.take();\n-    let mut gap = match empty.gap_peek() {\n-        Ok(b) => b,\n-        Err(b) => return (retkey, retval, b.into_table()),\n-    };\n-\n-    while gap.full().displacement() != 0 {\n-        gap = match gap.shift() {\n-            Ok(b) => b,\n-            Err(b) => {\n-                return (retkey, retval, b.into_table());\n-            },\n-        };\n-    }\n-\n-    // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval, gap.into_table())\n-}\n-\n-/// Performs robin hood bucket stealing at the given `bucket`. You must\n-/// also pass that bucket's displacement so we don't have to recalculate it.\n-///\n-/// `hash`, `key`, and `val` are the elements to \"robin hood\" into the hashtable.\n-fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n-                                mut displacement: usize,\n-                                mut hash: SafeHash,\n-                                mut key: K,\n-                                mut val: V)\n-                                -> FullBucketMut<'a, K, V> {\n-    let size = bucket.table().size();\n-    let raw_capacity = bucket.table().capacity();\n-    // There can be at most `size - dib` buckets to displace, because\n-    // in the worst case, there are `size` elements and we already are\n-    // `displacement` buckets away from the initial one.\n-    let idx_end = (bucket.index() + size - bucket.displacement()) % raw_capacity;\n-    // Save the *starting point*.\n-    let mut bucket = bucket.stash();\n-\n-    loop {\n-        let (old_hash, old_key, old_val) = bucket.replace(hash, key, val);\n-        hash = old_hash;\n-        key = old_key;\n-        val = old_val;\n-\n-        loop {\n-            displacement += 1;\n-            let probe = bucket.next();\n-            debug_assert!(probe.index() != idx_end);\n-\n-            let full_bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    let bucket = bucket.put(hash, key, val);\n-                    // Now that it's stolen, just read the value's pointer\n-                    // right out of the table! Go back to the *starting point*.\n-                    //\n-                    // This use of `into_table` is misleading. It turns the\n-                    // bucket, which is a FullBucket on top of a\n-                    // FullBucketMut, into just one FullBucketMut. The \"table\"\n-                    // refers to the inner FullBucketMut in this context.\n-                    return bucket.into_table();\n-                }\n-                Full(bucket) => bucket,\n-            };\n-\n-            let probe_displacement = full_bucket.displacement();\n-\n-            bucket = full_bucket;\n-\n-            // Robin hood! Steal the spot.\n-            if probe_displacement < displacement {\n-                displacement = probe_displacement;\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash\n-        where X: Hash\n-    {\n-        table::make_hash(&self.hash_builder, x)\n-    }\n-\n-    /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, or if you need an\n-    /// InternalEntry, use search_hashed or search_hashed_nonempty.\n-    #[inline]\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q)\n-        -> Option<FullBucket<K, V, &'a RawTable<K, V>>>\n-        where K: Borrow<Q>,\n-              Q: Eq + Hash\n-    {\n-        if self.is_empty() {\n-            return None;\n-        }\n-\n-        let hash = self.make_hash(q);\n-        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()), true)\n-            .into_occupied_bucket()\n-    }\n-\n-    #[inline]\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q)\n-        -> Option<FullBucket<K, V, &'a mut RawTable<K, V>>>\n-        where K: Borrow<Q>,\n-              Q: Eq + Hash\n-    {\n-        if self.is_empty() {\n-            return None;\n-        }\n-\n-        let hash = self.make_hash(q);\n-        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()), true)\n-            .into_occupied_bucket()\n-    }\n-\n-    // The caller should ensure that invariants by Robin Hood Hashing hold\n-    // and that there's space in the underlying table.\n-    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let mut buckets = Bucket::new(&mut self.table, hash);\n-        let start_index = buckets.index();\n-\n-        loop {\n-            // We don't need to compare hashes for value swap.\n-            // Not even DIBs for Robin Hood.\n-            buckets = match buckets.peek() {\n-                Empty(empty) => {\n-                    empty.put(hash, k, v);\n-                    return;\n-                }\n-                Full(b) => b.into_bucket(),\n-            };\n-            buckets.next();\n-            debug_assert!(buckets.index() != start_index);\n-        }\n-    }\n+    base: base::HashMap<K, V, S>,\n }\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n@@ -732,13 +258,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.resize_policy.capacity(self.raw_capacity())\n-    }\n-\n-    /// Returns the hash map's raw capacity.\n-    #[inline]\n-    fn raw_capacity(&self) -> usize {\n-        self.table.capacity()\n+        self.base.capacity()\n     }\n \n     /// An iterator visiting all keys in arbitrary order.\n@@ -831,7 +351,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter { inner: self.table.iter() }\n+        Iter { base: self.base.iter() }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n@@ -859,7 +379,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut { inner: self.table.iter_mut() }\n+        IterMut { base: self.base.iter_mut() }\n     }\n \n     /// Returns the number of elements in the map.\n@@ -876,7 +396,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        self.table.size()\n+        self.base.len()\n     }\n \n     /// Returns `true` if the map contains no elements.\n@@ -894,7 +414,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n+        self.base.is_empty()\n     }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n@@ -919,7 +439,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<'_, K, V> {\n-        Drain { inner: self.table.drain() }\n+        Drain { base: self.base.drain() }\n     }\n \n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n@@ -938,13 +458,14 @@ impl<K, V, S> HashMap<K, V, S> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n-        self.drain();\n+        self.base.clear();\n     }\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash,\n+    S: BuildHasher,\n {\n     /// Creates an empty `HashMap` which will use the given hash builder to hash\n     /// keys.\n@@ -970,9 +491,7 @@ impl<K, V, S> HashMap<K, V, S>\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n         HashMap {\n-            hash_builder,\n-            resize_policy: DefaultResizePolicy::new(),\n-            table: RawTable::new(0),\n+            base: base::HashMap::with_hasher(hash_builder),\n         }\n     }\n \n@@ -1000,12 +519,8 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n-        let resize_policy = DefaultResizePolicy::new();\n-        let raw_cap = resize_policy.raw_capacity(capacity);\n         HashMap {\n-            hash_builder,\n-            resize_policy,\n-            table: RawTable::new(raw_cap),\n+            base: base::HashMap::with_capacity_and_hasher(capacity, hash_builder),\n         }\n     }\n \n@@ -1023,9 +538,10 @@ impl<K, V, S> HashMap<K, V, S>\n     /// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n     /// let hasher: &RandomState = map.hasher();\n     /// ```\n+    #[inline]\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n-        &self.hash_builder\n+        self.base.hasher()\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n@@ -1048,11 +564,7 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        match self.reserve_internal(additional, Infallible) {\n-            Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr) => unreachable!(),\n-            Ok(()) => { /* yay */ }\n-        }\n+        self.base.reserve(additional)\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -1072,92 +584,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, isize> = HashMap::new();\n     /// map.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n     /// ```\n-    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n-        self.reserve_internal(additional, Fallible)\n-    }\n-\n     #[inline]\n-    fn reserve_internal(&mut self, additional: usize, fallibility: Fallibility)\n-        -> Result<(), CollectionAllocErr> {\n-\n-        let remaining = self.capacity() - self.len(); // this can't overflow\n-        if remaining < additional {\n-            let min_cap = self.len()\n-                .checked_add(additional)\n-                .ok_or(CollectionAllocErr::CapacityOverflow)?;\n-            let raw_cap = self.resize_policy.try_raw_capacity(min_cap)?;\n-            self.try_resize(raw_cap, fallibility)?;\n-        } else if self.table.tag() && remaining <= self.len() {\n-            // Probe sequence is too long and table is half full,\n-            // resize early to reduce probing length.\n-            let new_capacity = self.table.capacity() * 2;\n-            self.try_resize(new_capacity, fallibility)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Resizes the internal vectors to a new capacity. It's your\n-    /// responsibility to:\n-    ///   1) Ensure `new_raw_cap` is enough for all the elements, accounting\n-    ///      for the load factor.\n-    ///   2) Ensure `new_raw_cap` is a power of two or zero.\n-    #[inline(never)]\n-    #[cold]\n-    fn try_resize(\n-        &mut self,\n-        new_raw_cap: usize,\n-        fallibility: Fallibility,\n-    ) -> Result<(), CollectionAllocErr> {\n-        assert!(self.table.size() <= new_raw_cap);\n-        assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n-\n-        let mut old_table = replace(\n-            &mut self.table,\n-            match fallibility {\n-                Infallible => RawTable::new(new_raw_cap),\n-                Fallible => RawTable::try_new(new_raw_cap)?,\n-            }\n-        );\n-        let old_size = old_table.size();\n-\n-        if old_table.size() == 0 {\n-            return Ok(());\n-        }\n-\n-        let mut bucket = Bucket::head_bucket(&mut old_table);\n-\n-        // This is how the buckets might be laid out in memory:\n-        // ($ marks an initialized bucket)\n-        //  ________________\n-        // |$$$_$$$$$$_$$$$$|\n-        //\n-        // But we've skipped the entire initial cluster of buckets\n-        // and will continue iteration in this order:\n-        //  ________________\n-        //     |$$$$$$_$$$$$\n-        //                  ^ wrap around once end is reached\n-        //  ________________\n-        //  $$$_____________|\n-        //    ^ exit once table.size == 0\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(bucket) => {\n-                    let h = bucket.hash();\n-                    let (b, k, v) = bucket.take();\n-                    self.insert_hashed_ordered(h, k, v);\n-                    if b.table().size() == 0 {\n-                        break;\n-                    }\n-                    b.into_bucket()\n-                }\n-                Empty(b) => b.into_bucket(),\n-            };\n-            bucket.next();\n-        }\n-\n-        assert_eq!(self.table.size(), old_size);\n-        Ok(())\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.base\n+            .try_reserve(additional)\n+            .map_err(map_collection_alloc_err)\n     }\n \n     /// Shrinks the capacity of the map as much as possible. It will drop\n@@ -1176,20 +608,10 @@ impl<K, V, S> HashMap<K, V, S>\n     /// map.shrink_to_fit();\n     /// assert!(map.capacity() >= 2);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        let new_raw_cap = self.resize_policy.raw_capacity(self.len());\n-        if self.raw_capacity() != new_raw_cap {\n-            let old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n-            let old_size = old_table.size();\n-\n-            // Shrink the table. Naive algorithm for resizing:\n-            for (h, k, v) in old_table.into_iter() {\n-                self.insert_hashed_nocheck(h, k, v);\n-            }\n-\n-            debug_assert_eq!(self.table.size(), old_size);\n-        }\n+        self.base.shrink_to_fit();\n     }\n \n     /// Shrinks the capacity of the map with a lower limit. It will drop\n@@ -1214,40 +636,14 @@ impl<K, V, S> HashMap<K, V, S>\n     /// map.shrink_to(0);\n     /// assert!(map.capacity() >= 2);\n     /// ```\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n-        assert!(self.capacity() >= min_capacity, \"Tried to shrink to a larger capacity\");\n-\n-        let new_raw_cap = self.resize_policy.raw_capacity(max(self.len(), min_capacity));\n-        if self.raw_capacity() != new_raw_cap {\n-            let old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n-            let old_size = old_table.size();\n-\n-            // Shrink the table. Naive algorithm for resizing:\n-            for (h, k, v) in old_table.into_iter() {\n-                self.insert_hashed_nocheck(h, k, v);\n-            }\n-\n-            debug_assert_eq!(self.table.size(), old_size);\n-        }\n-    }\n-\n-    /// Insert a pre-hashed key-value pair, without first checking\n-    /// that there's enough room in the buckets. Returns a reference to the\n-    /// newly insert value.\n-    ///\n-    /// If the key already exists, the hashtable will be returned untouched\n-    /// and a reference to the existing element will be returned.\n-    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n-        let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n-        match entry {\n-            Some(Occupied(mut elem)) => Some(elem.insert(v)),\n-            Some(Vacant(elem)) => {\n-                elem.insert(v);\n-                None\n-            }\n-            None => unreachable!(),\n-        }\n+        assert!(\n+            self.capacity() >= min_capacity,\n+            \"Tried to shrink to a larger capacity\"\n+        );\n+        self.base.shrink_to(min_capacity);\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1269,13 +665,10 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(letters[&'u'], 1);\n     /// assert_eq!(letters.get(&'y'), None);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n-        // Gotta resize now.\n-        self.reserve(1);\n-        let hash = self.make_hash(&key);\n-        search_hashed(&mut self.table, hash, |q| q.eq(&key))\n-            .into_entry(key).expect(\"unreachable\")\n+        map_entry(self.base.rustc_entry(key))\n     }\n \n     /// Returns a reference to the value corresponding to the key.\n@@ -1300,10 +693,11 @@ impl<K, V, S> HashMap<K, V, S>\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.search(k).map(|bucket| bucket.into_refs().1)\n+        self.base.get(k)\n     }\n \n     /// Returns the key-value pair corresponding to the supplied key.\n@@ -1327,11 +721,13 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(map.get_key_value(&2), None);\n     /// ```\n     #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    #[inline]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.search(k).map(|bucket| bucket.into_refs())\n+        self.base.get_key_value(k)\n     }\n \n     /// Returns `true` if the map contains a value for the specified key.\n@@ -1354,11 +750,13 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.search(k).is_some()\n+        self.base.contains_key(k)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1383,11 +781,13 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(map[&1], \"b\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n+        self.base.get_mut(k)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1416,10 +816,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        let hash = self.make_hash(&k);\n-        self.reserve(1);\n-        self.insert_hashed_nocheck(hash, k, v)\n+        self.base.insert(k, v)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n@@ -1443,11 +842,13 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n+        self.base.remove(k)\n     }\n \n     /// Removes a key from the map, returning the stored key and value if the\n@@ -1473,15 +874,13 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # }\n     /// ```\n     #[stable(feature = \"hash_map_remove_entry\", since = \"1.27.0\")]\n+    #[inline]\n     pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.search_mut(k)\n-            .map(|bucket| {\n-                let (k, v, _) = pop_internal(bucket);\n-                (k, v)\n-            })\n+        self.base.remove_entry(k)\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1498,45 +897,18 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(map.len(), 4);\n     /// ```\n     #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n-    pub fn retain<F>(&mut self, mut f: F)\n-        where F: FnMut(&K, &mut V) -> bool\n+    #[inline]\n+    pub fn retain<F>(&mut self, f: F)\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n     {\n-        if self.table.size() == 0 {\n-            return;\n-        }\n-        let mut elems_left = self.table.size();\n-        let mut bucket = Bucket::head_bucket(&mut self.table);\n-        bucket.prev();\n-        let start_index = bucket.index();\n-        while elems_left != 0 {\n-            bucket = match bucket.peek() {\n-                Full(mut full) => {\n-                    elems_left -= 1;\n-                    let should_remove = {\n-                        let (k, v) = full.read_mut();\n-                        !f(k, v)\n-                    };\n-                    if should_remove {\n-                        let prev_raw = full.raw();\n-                        let (_, _, t) = pop_internal(full);\n-                        Bucket::new_from(prev_raw, t)\n-                    } else {\n-                        full.into_bucket()\n-                    }\n-                },\n-                Empty(b) => {\n-                    b.into_bucket()\n-                }\n-            };\n-            bucket.prev();  // reverse iteration\n-            debug_assert!(elems_left == 0 || bucket.index() != start_index);\n-        }\n+        self.base.retain(f)\n     }\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n+where\n+    S: BuildHasher,\n {\n     /// Creates a raw entry builder for the HashMap.\n     ///\n@@ -1569,10 +941,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// so that the map now contains keys which compare equal, search may start\n     /// acting erratically, with two keys randomly masking each other. Implementations\n     /// are free to assume this doesn't happen (within the limits of memory-safety).\n-    #[inline(always)]\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<'_, K, V, S> {\n-        self.reserve(1);\n         RawEntryBuilderMut { map: self }\n     }\n \n@@ -1591,6 +962,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// `get` should be preferred.\n     ///\n     /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S> {\n         RawEntryBuilder { map: self }\n@@ -1599,32 +971,36 @@ impl<K, V, S> HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          V: PartialEq,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash,\n+    V: PartialEq,\n+    S: BuildHasher,\n {\n     fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n \n-        self.iter().all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n+        self.iter()\n+            .all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          V: Eq,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash,\n+    V: Eq,\n+    S: BuildHasher,\n {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash + Debug,\n-          V: Debug,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash + Debug,\n+    V: Debug,\n+    S: BuildHasher,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n@@ -1633,20 +1009,23 @@ impl<K, V, S> Debug for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Default for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher + Default\n+where\n+    K: Eq + Hash,\n+    S: BuildHasher + Default,\n {\n     /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n+    #[inline]\n     fn default() -> HashMap<K, V, S> {\n         HashMap::with_hasher(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S> Index<&Q> for HashMap<K, V, S>\n-    where K: Eq + Hash + Borrow<Q>,\n-          Q: Eq + Hash,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash + Borrow<Q>,\n+    Q: Eq + Hash,\n+    S: BuildHasher,\n {\n     type Output = V;\n \n@@ -1670,23 +1049,24 @@ impl<K, Q: ?Sized, V, S> Index<&Q> for HashMap<K, V, S>\n /// [`HashMap`]: struct.HashMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: table::Iter<'a, K, V>,\n+    base: base::Iter<'a, K, V>,\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Clone for Iter<'_, K, V> {\n+    #[inline]\n     fn clone(&self) -> Self {\n-        Iter { inner: self.inner.clone() }\n+        Iter {\n+            base: self.base.clone(),\n+        }\n     }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.clone())\n-            .finish()\n+        f.debug_list().entries(self.clone()).finish()\n     }\n }\n \n@@ -1699,7 +1079,17 @@ impl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n /// [`HashMap`]: struct.HashMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: table::IterMut<'a, K, V>,\n+    base: base::IterMut<'a, K, V>,\n+}\n+\n+impl<'a, K, V> IterMut<'a, K, V> {\n+    /// Returns a iterator of references over the remaining items.\n+    #[inline]\n+    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n+        Iter {\n+            base: self.base.rustc_iter(),\n+        }\n+    }\n }\n \n /// An owning iterator over the entries of a `HashMap`.\n@@ -1711,7 +1101,17 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// [`HashMap`]: struct.HashMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    pub(super) inner: table::IntoIter<K, V>,\n+    base: base::IntoIter<K, V>,\n+}\n+\n+impl<K, V> IntoIter<K, V> {\n+    /// Returns a iterator of references over the remaining items.\n+    #[inline]\n+    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n+        Iter {\n+            base: self.base.rustc_iter(),\n+        }\n+    }\n }\n \n /// An iterator over the keys of a `HashMap`.\n@@ -1729,17 +1129,18 @@ pub struct Keys<'a, K: 'a, V: 'a> {\n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Clone for Keys<'_, K, V> {\n+    #[inline]\n     fn clone(&self) -> Self {\n-        Keys { inner: self.inner.clone() }\n+        Keys {\n+            inner: self.inner.clone(),\n+        }\n     }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.clone())\n-            .finish()\n+        f.debug_list().entries(self.clone()).finish()\n     }\n }\n \n@@ -1758,17 +1159,18 @@ pub struct Values<'a, K: 'a, V: 'a> {\n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Clone for Values<'_, K, V> {\n+    #[inline]\n     fn clone(&self) -> Self {\n-        Values { inner: self.inner.clone() }\n+        Values {\n+            inner: self.inner.clone(),\n+        }\n     }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.clone())\n-            .finish()\n+        f.debug_list().entries(self.clone()).finish()\n     }\n }\n \n@@ -1781,7 +1183,17 @@ impl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n /// [`HashMap`]: struct.HashMap.html\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    pub(super) inner: table::Drain<'a, K, V>,\n+    base: base::Drain<'a, K, V>,\n+}\n+\n+impl<'a, K, V> Drain<'a, K, V> {\n+    /// Returns a iterator of references over the remaining items.\n+    #[inline]\n+    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n+        Iter {\n+            base: self.base.rustc_iter(),\n+        }\n+    }\n }\n \n /// A mutable iterator over the values of a `HashMap`.\n@@ -1796,47 +1208,6 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n }\n \n-enum InternalEntry<K, V, M> {\n-    Occupied { elem: FullBucket<K, V, M> },\n-    Vacant {\n-        hash: SafeHash,\n-        elem: VacantEntryState<K, V, M>,\n-    },\n-    TableIsEmpty,\n-}\n-\n-impl<K, V, M> InternalEntry<K, V, M> {\n-    #[inline]\n-    fn into_occupied_bucket(self) -> Option<FullBucket<K, V, M>> {\n-        match self {\n-            InternalEntry::Occupied { elem } => Some(elem),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n-    #[inline]\n-    fn into_entry(self, key: K) -> Option<Entry<'a, K, V>> {\n-        match self {\n-            InternalEntry::Occupied { elem } => {\n-                Some(Occupied(OccupiedEntry {\n-                    key: Some(key),\n-                    elem,\n-                }))\n-            }\n-            InternalEntry::Vacant { hash, elem } => {\n-                Some(Vacant(VacantEntry {\n-                    hash,\n-                    key,\n-                    elem,\n-                }))\n-            }\n-            InternalEntry::TableIsEmpty => None,\n-        }\n-    }\n-}\n-\n /// A builder for computing where in a HashMap a key-value pair would be stored.\n ///\n /// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n@@ -1871,7 +1242,7 @@ pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n /// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+    base: base::RawOccupiedEntryMut<'a, K, V>,\n }\n \n /// A view into a vacant entry in a `HashMap`.\n@@ -1880,8 +1251,7 @@ pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n /// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n-    hash_builder: &'a S,\n+    base: base::RawVacantEntryMut<'a, K, V, S>,\n }\n \n /// A builder for computing where in a HashMap a key-value pair would be stored.\n@@ -1895,128 +1265,81 @@ pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n }\n \n impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n-    where S: BuildHasher,\n-          K: Eq + Hash,\n+where\n+    S: BuildHasher,\n {\n     /// Creates a `RawEntryMut` from the given key.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        let mut hasher = self.map.hash_builder.build_hasher();\n-        k.hash(&mut hasher);\n-        self.from_key_hashed_nocheck(hasher.finish(), k)\n+        map_raw_entry(self.map.base.raw_entry_mut().from_key(k))\n     }\n \n     /// Creates a `RawEntryMut` from the given key and its hash.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n-        where K: Borrow<Q>,\n-              Q: Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n     {\n-        self.from_hash(hash, |q| q.borrow().eq(k))\n+        map_raw_entry(\n+            self.map\n+                .base\n+                .raw_entry_mut()\n+                .from_key_hashed_nocheck(hash, k),\n+        )\n     }\n \n-    #[inline]\n-    fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool)  -> RawEntryMut<'a, K, V, S>\n-        where for<'b> F: FnMut(&'b K) -> bool,\n-    {\n-        match search_hashed_nonempty_mut(&mut self.map.table,\n-                                         SafeHash::new(hash),\n-                                         is_match,\n-                                         compare_hashes) {\n-            InternalEntry::Occupied { elem } => {\n-                RawEntryMut::Occupied(RawOccupiedEntryMut { elem })\n-            }\n-            InternalEntry::Vacant { elem, .. } => {\n-                RawEntryMut::Vacant(RawVacantEntryMut {\n-                    elem,\n-                    hash_builder: &self.map.hash_builder,\n-                })\n-            }\n-            InternalEntry::TableIsEmpty => {\n-                unreachable!()\n-            }\n-        }\n-    }\n     /// Creates a `RawEntryMut` from the given hash.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n-        where for<'b> F: FnMut(&'b K) -> bool,\n+    where\n+        for<'b> F: FnMut(&'b K) -> bool,\n     {\n-        self.search(hash, is_match, true)\n-    }\n-\n-    /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n-    /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n-    /// hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-    pub fn search_bucket<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n-        where for<'b> F: FnMut(&'b K) -> bool,\n-    {\n-        self.search(hash, is_match, false)\n+        map_raw_entry(self.map.base.raw_entry_mut().from_hash(hash, is_match))\n     }\n }\n \n impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n-    where S: BuildHasher,\n+where\n+    S: BuildHasher,\n {\n     /// Access an entry by key.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        let mut hasher = self.map.hash_builder.build_hasher();\n-        k.hash(&mut hasher);\n-        self.from_key_hashed_nocheck(hasher.finish(), k)\n+        self.map.base.raw_entry().from_key(k)\n     }\n \n     /// Access an entry by a key and its hash.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n-\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n     {\n-        self.from_hash(hash, |q| q.borrow().eq(k))\n-    }\n-\n-    fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool) -> Option<(&'a K, &'a V)>\n-        where F: FnMut(&K) -> bool\n-    {\n-        if unsafe { unlikely(self.map.table.size() == 0) } {\n-            return None;\n-        }\n-        match search_hashed_nonempty(&self.map.table,\n-                                     SafeHash::new(hash),\n-                                     is_match,\n-                                     compare_hashes) {\n-            InternalEntry::Occupied { elem } => Some(elem.into_refs()),\n-            InternalEntry::Vacant { .. } => None,\n-            InternalEntry::TableIsEmpty => unreachable!(),\n-        }\n+        self.map.base.raw_entry().from_key_hashed_nocheck(hash, k)\n     }\n \n     /// Access an entry by hash.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n-        where F: FnMut(&K) -> bool\n-    {\n-        self.search(hash, is_match, true)\n-    }\n-\n-    /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n-    /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n-    /// hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-    pub fn search_bucket<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n-        where F: FnMut(&K) -> bool\n+    where\n+        F: FnMut(&K) -> bool,\n     {\n-        self.search(hash, is_match, false)\n+        self.map.base.raw_entry().from_hash(hash, is_match)\n     }\n }\n \n@@ -2038,10 +1361,12 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 10).1 *= 2;\n     /// assert_eq!(map[\"poneyland\"], 6);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n-        where K: Hash,\n-              S: BuildHasher,\n+    where\n+        K: Hash,\n+        S: BuildHasher,\n     {\n         match self {\n             RawEntryMut::Occupied(entry) => entry.into_key_value(),\n@@ -2066,11 +1391,13 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n-        where F: FnOnce() -> (K, V),\n-              K: Hash,\n-              S: BuildHasher,\n+    where\n+        F: FnOnce() -> (K, V),\n+        K: Hash,\n+        S: BuildHasher,\n     {\n         match self {\n             RawEntryMut::Occupied(entry) => entry.into_key_value(),\n@@ -2104,9 +1431,11 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     ///    .or_insert(\"poneyland\", 0);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn and_modify<F>(self, f: F) -> Self\n-        where F: FnOnce(&mut K, &mut V)\n+    where\n+        F: FnOnce(&mut K, &mut V),\n     {\n         match self {\n             RawEntryMut::Occupied(mut entry) => {\n@@ -2115,155 +1444,147 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n                     f(k, v);\n                 }\n                 RawEntryMut::Occupied(entry)\n-            },\n+            }\n             RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n         }\n     }\n }\n \n impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn key(&self) -> &K {\n-        self.elem.read().0\n+        self.base.key()\n     }\n \n     /// Gets a mutable reference to the key in the entry.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn key_mut(&mut self) -> &mut K {\n-        self.elem.read_mut().0\n+        self.base.key_mut()\n     }\n \n     /// Converts the entry into a mutable reference to the key in the entry\n     /// with a lifetime bound to the map itself.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn into_key(self) -> &'a mut K {\n-        self.elem.into_mut_refs().0\n+        self.base.into_key()\n     }\n \n     /// Gets a reference to the value in the entry.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get(&self) -> &V {\n-        self.elem.read().1\n+        self.base.get()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn into_mut(self) -> &'a mut V {\n-        self.elem.into_mut_refs().1\n+        self.base.into_mut()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get_mut(&mut self) -> &mut V {\n-        self.elem.read_mut().1\n+        self.base.get_mut()\n     }\n \n     /// Gets a reference to the key and value in the entry.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get_key_value(&mut self) -> (&K, &V) {\n-        self.elem.read()\n+        self.base.get_key_value()\n     }\n \n     /// Gets a mutable reference to the key and value in the entry.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n-        self.elem.read_mut()\n+        self.base.get_key_value_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n     /// with a lifetime bound to the map itself.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n-        self.elem.into_mut_refs()\n+        self.base.into_key_value()\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert(&mut self, value: V) -> V {\n-        mem::replace(self.get_mut(), value)\n+        self.base.insert(value)\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert_key(&mut self, key: K) -> K {\n-        mem::replace(self.key_mut(), key)\n+        self.base.insert_key(key)\n     }\n \n     /// Takes the value out of the entry, and returns it.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn remove(self) -> V {\n-        pop_internal(self.elem).1\n+        self.base.remove()\n     }\n \n     /// Take the ownership of the key and value from the map.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn remove_entry(self) -> (K, V) {\n-        let (k, v, _) = pop_internal(self.elem);\n-        (k, v)\n+        self.base.remove_entry()\n     }\n }\n \n impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n-        where K: Hash,\n-              S: BuildHasher,\n+    where\n+        K: Hash,\n+        S: BuildHasher,\n     {\n-        let mut hasher = self.hash_builder.build_hasher();\n-        key.hash(&mut hasher);\n-        self.insert_hashed_nocheck(hasher.finish(), key, value)\n+        self.base.insert(key, value)\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n-        let hash = SafeHash::new(hash);\n-        let b = match self.elem {\n-            NeqElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                robin_hood(bucket, disp, hash, key, value)\n-            },\n-            NoElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                bucket.put(hash, key, value)\n-            },\n-        };\n-        b.into_mut_refs()\n+    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V)\n+    where\n+        K: Hash,\n+        S: BuildHasher,\n+    {\n+        self.base.insert_hashed_nocheck(hash, key, value)\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<K, V, S> Debug for RawEntryBuilderMut<'_, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"RawEntryBuilder\")\n-         .finish()\n+        f.debug_struct(\"RawEntryBuilder\").finish()\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            RawEntryMut::Vacant(ref v) => {\n-                f.debug_tuple(\"RawEntry\")\n-                    .field(v)\n-                    .finish()\n-            }\n-            RawEntryMut::Occupied(ref o) => {\n-                f.debug_tuple(\"RawEntry\")\n-                    .field(o)\n-                    .finish()\n-            }\n+            RawEntryMut::Vacant(ref v) => f.debug_tuple(\"RawEntry\").field(v).finish(),\n+            RawEntryMut::Occupied(ref o) => f.debug_tuple(\"RawEntry\").field(o).finish(),\n         }\n     }\n }\n@@ -2272,25 +1593,23 @@ impl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n impl<K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"RawOccupiedEntryMut\")\n-         .field(\"key\", self.key())\n-         .field(\"value\", self.get())\n-         .finish()\n+            .field(\"key\", self.key())\n+            .field(\"value\", self.get())\n+            .finish()\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<K, V, S> Debug for RawVacantEntryMut<'_, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"RawVacantEntryMut\")\n-         .finish()\n+        f.debug_struct(\"RawVacantEntryMut\").finish()\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"RawEntryBuilder\")\n-         .finish()\n+        f.debug_struct(\"RawEntryBuilder\").finish()\n     }\n }\n \n@@ -2304,29 +1623,19 @@ impl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-             OccupiedEntry<'a, K, V>),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n \n     /// A vacant entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-           VacantEntry<'a, K, V>),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n }\n \n-#[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n+#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\n impl<K: Debug, V: Debug> Debug for Entry<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            Vacant(ref v) => {\n-                f.debug_tuple(\"Entry\")\n-                    .field(v)\n-                    .finish()\n-            }\n-            Occupied(ref o) => {\n-                f.debug_tuple(\"Entry\")\n-                    .field(o)\n-                    .finish()\n-            }\n+            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n         }\n     }\n }\n@@ -2337,16 +1646,10 @@ impl<K: Debug, V: Debug> Debug for Entry<'_, K, V> {\n /// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    key: Option<K>,\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+    base: base::RustcOccupiedEntry<'a, K, V>,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<'a, K: 'a + Send, V: 'a + Send> Send for OccupiedEntry<'a, K, V> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<'a, K: 'a + Sync, V: 'a + Sync> Sync for OccupiedEntry<'a, K, V> {}\n-\n-#[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n+#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\n impl<K: Debug, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OccupiedEntry\")\n@@ -2362,39 +1665,22 @@ impl<K: Debug, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n /// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n-    key: K,\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+    base: base::RustcVacantEntry<'a, K, V>,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<'a, K: 'a + Send, V: 'a + Send> Send for VacantEntry<'a, K, V> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<'a, K: 'a + Sync, V: 'a + Sync> Sync for VacantEntry<'a, K, V> {}\n-\n-#[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n+#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\n impl<K: Debug, V> Debug for VacantEntry<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"VacantEntry\")\n-            .field(self.key())\n-            .finish()\n+        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n     }\n }\n \n-/// Possible states of a VacantEntry.\n-enum VacantEntryState<K, V, M> {\n-    /// The index is occupied, but the key to insert has precedence,\n-    /// and will kick the current one out on insertion.\n-    NeqElem(FullBucket<K, V, M>, usize),\n-    /// The index is genuinely vacant.\n-    NoElem(EmptyBucket<K, V, M>, usize),\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n+    #[inline]\n     fn into_iter(self) -> Iter<'a, K, V> {\n         self.iter()\n     }\n@@ -2405,6 +1691,7 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n+    #[inline]\n     fn into_iter(self) -> IterMut<'a, K, V> {\n         self.iter_mut()\n     }\n@@ -2432,8 +1719,11 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S> {\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, i32)> = map.into_iter().collect();\n     /// ```\n+    #[inline]\n     fn into_iter(self) -> IntoIter<K, V> {\n-        IntoIter { inner: self.table.into_iter() }\n+        IntoIter {\n+            base: self.base.into_iter(),\n+        }\n     }\n }\n \n@@ -2443,18 +1733,18 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next()\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.inner.len()\n+        self.base.len()\n     }\n }\n \n@@ -2467,32 +1757,31 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next()\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.inner.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for IterMut<'_, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K, V> fmt::Debug for IterMut<'_, K, V>\n-    where K: fmt::Debug,\n-          V: fmt::Debug,\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.inner.iter())\n-            .finish()\n+        f.debug_list().entries(self.iter()).finish()\n     }\n }\n \n@@ -2502,18 +1791,18 @@ impl<K, V> Iterator for IntoIter<K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n-        self.inner.next().map(|(_, k, v)| (k, v))\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.inner.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -2522,9 +1811,7 @@ impl<K, V> FusedIterator for IntoIter<K, V> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: Debug, V: Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.inner.iter())\n-            .finish()\n+        f.debug_list().entries(self.iter()).finish()\n     }\n }\n \n@@ -2599,13 +1886,12 @@ impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K, V> fmt::Debug for ValuesMut<'_, K, V>\n-    where K: fmt::Debug,\n-          V: fmt::Debug,\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.inner.inner.iter())\n-            .finish()\n+        f.debug_list().entries(self.inner.iter()).finish()\n     }\n }\n \n@@ -2615,32 +1901,31 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n-        self.inner.next().map(|(_, k, v)| (k, v))\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<K, V> ExactSizeIterator for Drain<'_, K, V> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.inner.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for Drain<'_, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K, V> fmt::Debug for Drain<'_, K, V>\n-    where K: fmt::Debug,\n-          V: fmt::Debug,\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list()\n-            .entries(self.inner.iter())\n-            .finish()\n+        f.debug_list().entries(self.iter()).finish()\n     }\n }\n \n@@ -2662,6 +1947,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// *map.entry(\"poneyland\").or_insert(10) *= 2;\n     /// assert_eq!(map[\"poneyland\"], 6);\n     /// ```\n+    #[inline]\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -2685,6 +1971,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n+    #[inline]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -2702,6 +1989,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n     /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n     /// ```\n+    #[inline]\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -2730,19 +2018,20 @@ impl<'a, K, V> Entry<'a, K, V> {\n     ///    .or_insert(42);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n     pub fn and_modify<F>(self, f: F) -> Self\n-        where F: FnOnce(&mut V)\n+    where\n+        F: FnOnce(&mut V),\n     {\n         match self {\n             Occupied(mut entry) => {\n                 f(entry.get_mut());\n                 Occupied(entry)\n-            },\n+            }\n             Vacant(entry) => Vacant(entry),\n         }\n     }\n-\n }\n \n impl<'a, K, V: Default> Entry<'a, K, V> {\n@@ -2762,6 +2051,7 @@ impl<'a, K, V: Default> Entry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], None);\n     /// # }\n     /// ```\n+    #[inline]\n     pub fn or_default(self) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -2782,9 +2072,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// map.entry(\"poneyland\").or_insert(12);\n     /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n     /// ```\n+    #[inline]\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n-        self.elem.read().0\n+        self.base.key()\n     }\n \n     /// Take the ownership of the key and value from the map.\n@@ -2805,10 +2096,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map.contains_key(\"poneyland\"), false);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n     pub fn remove_entry(self) -> (K, V) {\n-        let (k, v, _) = pop_internal(self.elem);\n-        (k, v)\n+        self.base.remove_entry()\n     }\n \n     /// Gets a reference to the value in the entry.\n@@ -2826,9 +2117,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///     assert_eq!(o.get(), &12);\n     /// }\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n-        self.elem.read().1\n+        self.base.get()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n@@ -2858,9 +2150,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], 24);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n-        self.elem.read_mut().1\n+        self.base.get_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n@@ -2886,9 +2179,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], 22);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n-        self.elem.into_mut_refs().1\n+        self.base.into_mut()\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n@@ -2908,11 +2202,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], 15);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, mut value: V) -> V {\n-        let old_value = self.get_mut();\n-        mem::swap(&mut value, old_value);\n-        value\n+    pub fn insert(&mut self, value: V) -> V {\n+        self.base.insert(value)\n     }\n \n     /// Takes the value out of the entry, and returns it.\n@@ -2932,9 +2225,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map.contains_key(\"poneyland\"), false);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n-        pop_internal(self.elem).1\n+        self.base.remove()\n     }\n \n     /// Replaces the entry, returning the old key and value. The new key in the hash map will be\n@@ -2958,14 +2252,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// }\n     ///\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n-    pub fn replace_entry(mut self, value: V) -> (K, V) {\n-        let (old_key, old_value) = self.elem.read_mut();\n-\n-        let old_key = mem::replace(old_key, self.key.unwrap());\n-        let old_value = mem::replace(old_value, value);\n-\n-        (old_key, old_value)\n+    pub fn replace_entry(self, value: V) -> (K, V) {\n+        self.base.replace_entry(value)\n     }\n \n     /// Replaces the key in the hash map with the key used to create this entry.\n@@ -2993,10 +2283,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///     }\n     /// }\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n-    pub fn replace_key(mut self) -> K {\n-        let (old_key, _) = self.elem.read_mut();\n-        mem::replace(old_key, self.key.unwrap())\n+    pub fn replace_key(self) -> K {\n+        self.base.replace_key()\n     }\n }\n \n@@ -3012,9 +2302,10 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n     /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n     /// ```\n+    #[inline]\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n-        &self.key\n+        self.base.key()\n     }\n \n     /// Take ownership of the key.\n@@ -3031,9 +2322,10 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     ///     v.into_key();\n     /// }\n     /// ```\n+    #[inline]\n     #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n     pub fn into_key(self) -> K {\n-        self.key\n+        self.base.into_key()\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n@@ -3052,30 +2344,18 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// }\n     /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        let b = match self.elem {\n-            NeqElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                robin_hood(bucket, disp, self.hash, self.key, value)\n-            },\n-            NoElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                bucket.put(self.hash, self.key, value)\n-            },\n-        };\n-        b.into_mut_refs().1\n+        self.base.insert(value)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher + Default\n+where\n+    K: Eq + Hash,\n+    S: BuildHasher + Default,\n {\n     fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> {\n         let mut map = HashMap::with_hasher(Default::default());\n@@ -3086,35 +2366,26 @@ impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash,\n+    S: BuildHasher,\n {\n+    #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n-        // Keys may be already present or show multiple times in the iterator.\n-        // Reserve the entire hint lower bound if the map is empty.\n-        // Otherwise reserve half the hint (rounded up), so the map\n-        // will only resize twice in the worst case.\n-        let iter = iter.into_iter();\n-        let reserve = if self.is_empty() {\n-            iter.size_hint().0\n-        } else {\n-            (iter.size_hint().0 + 1) / 2\n-        };\n-        self.reserve(reserve);\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n+        self.base.extend(iter)\n     }\n }\n \n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n-    where K: Eq + Hash + Copy,\n-          V: Copy,\n-          S: BuildHasher\n+where\n+    K: Eq + Hash + Copy,\n+    V: Copy,\n+    S: BuildHasher,\n {\n+    #[inline]\n     fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n-        self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n+        self.base.extend(iter)\n     }\n }\n \n@@ -3255,6 +2526,32 @@ impl fmt::Debug for RandomState {\n     }\n }\n \n+#[inline]\n+fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K, V> {\n+    match raw {\n+        base::RustcEntry::Occupied(base) => Entry::Occupied(OccupiedEntry { base }),\n+        base::RustcEntry::Vacant(base) => Entry::Vacant(VacantEntry { base }),\n+    }\n+}\n+\n+#[inline]\n+fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> CollectionAllocErr {\n+    match err {\n+        hashbrown::CollectionAllocErr::CapacityOverflow => CollectionAllocErr::CapacityOverflow,\n+        hashbrown::CollectionAllocErr::AllocErr => CollectionAllocErr::AllocErr,\n+    }\n+}\n+\n+#[inline]\n+fn map_raw_entry<'a, K: 'a, V: 'a, S: 'a>(\n+    raw: base::RawEntryMut<'a, K, V, S>,\n+) -> RawEntryMut<'a, K, V, S> {\n+    match raw {\n+        base::RawEntryMut::Occupied(base) => RawEntryMut::Occupied(RawOccupiedEntryMut { base }),\n+        base::RawEntryMut::Vacant(base) => RawEntryMut::Vacant(RawVacantEntryMut { base }),\n+    }\n+}\n+\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> {\n@@ -3287,21 +2584,21 @@ fn assert_covariance() {\n     fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> {\n         v\n     }\n-    fn drain<'new>(d: Drain<'static, &'static str, &'static str>)\n-                   -> Drain<'new, &'new str, &'new str> {\n+    fn drain<'new>(\n+        d: Drain<'static, &'static str, &'static str>,\n+    ) -> Drain<'new, &'new str, &'new str> {\n         d\n     }\n }\n \n #[cfg(test)]\n mod test_map {\n-    use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n+    use super::HashMap;\n     use super::RandomState;\n     use crate::cell::RefCell;\n     use rand::{thread_rng, Rng};\n     use realstd::collections::CollectionAllocErr::*;\n-    use realstd::mem::size_of;\n     use realstd::usize;\n \n     #[test]\n@@ -3438,19 +2735,19 @@ mod test_map {\n \n                 DROP_VECTOR.with(|v| {\n                     assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i+100], 1);\n+                    assert_eq!(v.borrow()[i + 100], 1);\n                 });\n             }\n \n             DROP_VECTOR.with(|v| {\n                 for i in 0..50 {\n                     assert_eq!(v.borrow()[i], 0);\n-                    assert_eq!(v.borrow()[i+100], 0);\n+                    assert_eq!(v.borrow()[i + 100], 0);\n                 }\n \n                 for i in 50..100 {\n                     assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i+100], 1);\n+                    assert_eq!(v.borrow()[i + 100], 1);\n                 }\n             });\n         }\n@@ -3507,13 +2804,9 @@ mod test_map {\n             for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = (0..100)\n-                    .filter(|&i| v.borrow()[i] == 1)\n-                    .count();\n+                let nk = (0..100).filter(|&i| v.borrow()[i] == 1).count();\n \n-                let nv = (0..100)\n-                    .filter(|&i| v.borrow()[i + 100] == 1)\n-                    .count();\n+                let nv = (0..100).filter(|&i| v.borrow()[i + 100] == 1).count();\n \n                 assert_eq!(nk, 50);\n                 assert_eq!(nv, 50);\n@@ -3701,7 +2994,7 @@ mod test_map {\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n         for i in 0..32 {\n-            assert!(m.insert(i, i*2).is_none());\n+            assert!(m.insert(i, i * 2).is_none());\n         }\n         assert_eq!(m.len(), 32);\n \n@@ -3789,8 +3082,7 @@ mod test_map {\n \n         let map_str = format!(\"{:?}\", map);\n \n-        assert!(map_str == \"{1: 2, 3: 4}\" ||\n-                map_str == \"{3: 4, 1: 2}\");\n+        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n         assert_eq!(format!(\"{:?}\", empty), \"{}\");\n     }\n \n@@ -3817,7 +3109,7 @@ mod test_map {\n         let mut m = HashMap::new();\n \n         assert_eq!(m.len(), 0);\n-        assert_eq!(m.raw_capacity(), 0);\n+        assert_eq!(m.raw_capacity(), 1);\n         assert!(m.is_empty());\n \n         m.insert(0, 0);\n@@ -3857,7 +3149,7 @@ mod test_map {\n         m.shrink_to_fit();\n         assert_eq!(m.raw_capacity(), raw_cap);\n         // again, a little more than half full\n-        for _ in 0..raw_cap / 2 - 1 {\n+        for _ in 0..raw_cap / 2 {\n             i -= 1;\n             m.remove(&i);\n         }\n@@ -4008,7 +3300,6 @@ mod test_map {\n         assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n-\n         // Existing key (update)\n         match map.entry(2) {\n             Vacant(_) => unreachable!(),\n@@ -4031,7 +3322,6 @@ mod test_map {\n         assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n-\n         // Inexistent key (insert)\n         match map.entry(10) {\n             Occupied(_) => unreachable!(),\n@@ -4046,11 +3336,10 @@ mod test_map {\n     #[test]\n     fn test_entry_take_doesnt_corrupt() {\n         #![allow(deprecated)] //rand\n-        // Test for #19292\n+                              // Test for #19292\n         fn check(m: &HashMap<i32, ()>) {\n             for k in m.keys() {\n-                assert!(m.contains_key(k),\n-                        \"{} is in keys() but not in the map?\", k);\n+                assert!(m.contains_key(k), \"{} is in keys() but not in the map?\", k);\n             }\n         }\n \n@@ -4155,7 +3444,7 @@ mod test_map {\n \n     #[test]\n     fn test_retain() {\n-        let mut map: HashMap<i32, i32> = (0..100).map(|x|(x, x*10)).collect();\n+        let mut map: HashMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n \n         map.retain(|&k, _| k % 2 == 0);\n         assert_eq!(map.len(), 50);\n@@ -4164,51 +3453,20 @@ mod test_map {\n         assert_eq!(map[&6], 60);\n     }\n \n-    #[test]\n-    fn test_adaptive() {\n-        const TEST_LEN: usize = 5000;\n-        // by cloning we get maps with the same hasher seed\n-        let mut first = HashMap::new();\n-        let mut second = first.clone();\n-        first.extend((0..TEST_LEN).map(|i| (i, i)));\n-        second.extend((TEST_LEN..TEST_LEN * 2).map(|i| (i, i)));\n-\n-        for (&k, &v) in &second {\n-            let prev_cap = first.capacity();\n-            let expect_grow = first.len() == prev_cap;\n-            first.insert(k, v);\n-            if !expect_grow && first.capacity() != prev_cap {\n-                return;\n-            }\n-        }\n-        panic!(\"Adaptive early resize failed\");\n-    }\n-\n     #[test]\n     fn test_try_reserve() {\n-\n-        let mut empty_bytes: HashMap<u8,u8> = HashMap::new();\n+        let mut empty_bytes: HashMap<u8, u8> = HashMap::new();\n \n         const MAX_USIZE: usize = usize::MAX;\n \n-        // HashMap and RawTables use complicated size calculations\n-        // hashes_size is sizeof(HashUint) * capacity;\n-        // pairs_size is sizeof((K. V)) * capacity;\n-        // alignment_hashes_size is 8\n-        // alignment_pairs size is 4\n-        let size_of_multiplier = (size_of::<usize>() + size_of::<(u8, u8)>()).next_power_of_two();\n-        // The following formula is used to calculate the new capacity\n-        let max_no_ovf = ((MAX_USIZE / 11) * 10) / size_of_multiplier - 1;\n-\n         if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\"); }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n \n-        if size_of::<usize>() < 8 {\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(max_no_ovf) {\n-            } else { panic!(\"isize::MAX + 1 should trigger a CapacityOverflow!\") }\n+        if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n         } else {\n-            if let Err(AllocErr) = empty_bytes.try_reserve(max_no_ovf) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            panic!(\"usize::MAX / 8 should trigger an OOM!\")\n         }\n     }\n \n@@ -4238,9 +3496,14 @@ mod test_map {\n         }\n         let hash1 = compute_hash(&map, 1);\n         assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n-        assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n-        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n-        assert_eq!(map.raw_entry().search_bucket(hash1, |k| *k == 1).unwrap(), (&1, &100));\n+        assert_eq!(\n+            map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(),\n+            (&1, &100)\n+        );\n+        assert_eq!(\n+            map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(),\n+            (&1, &100)\n+        );\n         assert_eq!(map.len(), 6);\n \n         // Existing key (update)\n@@ -4254,9 +3517,14 @@ mod test_map {\n         }\n         let hash2 = compute_hash(&map, 2);\n         assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n-        assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n-        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n-        assert_eq!(map.raw_entry().search_bucket(hash2, |k| *k == 2).unwrap(), (&2, &200));\n+        assert_eq!(\n+            map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(),\n+            (&2, &200)\n+        );\n+        assert_eq!(\n+            map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(),\n+            (&2, &200)\n+        );\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n@@ -4270,10 +3538,8 @@ mod test_map {\n         assert_eq!(map.raw_entry().from_key(&3), None);\n         assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n         assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n-        assert_eq!(map.raw_entry().search_bucket(hash3, |k| *k == 3), None);\n         assert_eq!(map.len(), 5);\n \n-\n         // Nonexistent key (insert)\n         match map.raw_entry_mut().from_key(&10) {\n             Occupied(_) => unreachable!(),\n@@ -4293,7 +3559,6 @@ mod test_map {\n             assert_eq!(map.raw_entry().from_key(&k), kv);\n             assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n             assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n-            assert_eq!(map.raw_entry().search_bucket(hash, |q| *q == k), kv);\n \n             match map.raw_entry_mut().from_key(&k) {\n                 Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n@@ -4307,10 +3572,6 @@ mod test_map {\n                 Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n                 Vacant(_) => assert_eq!(v, None),\n             }\n-            match map.raw_entry_mut().search_bucket(hash, |q| *q == k) {\n-                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n-                Vacant(_) => assert_eq!(v, None),\n-            }\n         }\n     }\n "}, {"sha": "a6d89a4d32abf0074cc022a2cdfc02d3f70ddd3e", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "patch": "@@ -1,6 +1,5 @@\n //! Unordered containers, implemented as hash-tables\n \n mod bench;\n-mod table;\n pub mod map;\n pub mod set;"}, {"sha": "b56a27c80bc83163607b46a5a0bb1b3cd08a0452", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf46bd5037a86237b9be4eb218d57d71bb8e2ccf/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=cf46bd5037a86237b9be4eb218d57d71bb8e2ccf", "patch": "@@ -1227,7 +1227,6 @@ impl<K> FusedIterator for IntoIter<K> {}\n impl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let entries_iter = self.iter\n-            .inner\n             .iter()\n             .map(|(k, _)| k);\n         f.debug_list().entries(entries_iter).finish()\n@@ -1261,7 +1260,6 @@ impl<K> FusedIterator for Drain<'_, K> {}\n impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let entries_iter = self.iter\n-            .inner\n             .iter()\n             .map(|(k, _)| k);\n         f.debug_list().entries(entries_iter).finish()"}, {"sha": "2113b448910abaf713996960ee22929e90c16ea7", "filename": "src/libstd/collections/hash/table.rs", "status": "removed", "additions": 0, "deletions": 1131, "changes": 1131, "blob_url": "https://github.com/rust-lang/rust/blob/1fa7a21534bde7315bc78be970a342262ddf7a58/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa7a21534bde7315bc78be970a342262ddf7a58/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=1fa7a21534bde7315bc78be970a342262ddf7a58", "patch": "@@ -1,1131 +0,0 @@\n-use crate::alloc::{Global, Alloc, Layout, LayoutErr, handle_alloc_error};\n-use crate::collections::CollectionAllocErr;\n-use crate::hash::{BuildHasher, Hash, Hasher};\n-use crate::marker;\n-use crate::mem::{self, size_of, needs_drop};\n-use crate::ops::{Deref, DerefMut};\n-use crate::ptr::{self, Unique, NonNull};\n-use crate::hint;\n-\n-use self::BucketState::*;\n-\n-/// Integer type used for stored hash values.\n-///\n-/// No more than bit_width(usize) bits are needed to select a bucket.\n-///\n-/// The most significant bit is ours to use for tagging `SafeHash`.\n-///\n-/// (Even if we could have usize::MAX bytes allocated for buckets,\n-/// each bucket stores at least a `HashUint`, so there can be no more than\n-/// usize::MAX / size_of(usize) buckets.)\n-type HashUint = usize;\n-\n-const EMPTY_BUCKET: HashUint = 0;\n-const EMPTY: usize = 1;\n-\n-/// Special `Unique<HashUint>` that uses the lower bit of the pointer\n-/// to expose a boolean tag.\n-/// Note: when the pointer is initialized to EMPTY `.ptr()` will return\n-/// null and the tag functions shouldn't be used.\n-struct TaggedHashUintPtr(Unique<HashUint>);\n-\n-impl TaggedHashUintPtr {\n-    #[inline]\n-    unsafe fn new(ptr: *mut HashUint) -> Self {\n-        debug_assert!(ptr as usize & 1 == 0 || ptr as usize == EMPTY as usize);\n-        TaggedHashUintPtr(Unique::new_unchecked(ptr))\n-    }\n-\n-    #[inline]\n-    fn set_tag(&mut self, value: bool) {\n-        let mut usize_ptr = self.0.as_ptr() as usize;\n-        unsafe {\n-            if value {\n-                usize_ptr |= 1;\n-            } else {\n-                usize_ptr &= !1;\n-            }\n-            self.0 = Unique::new_unchecked(usize_ptr as *mut HashUint)\n-        }\n-    }\n-\n-    #[inline]\n-    fn tag(&self) -> bool {\n-        (self.0.as_ptr() as usize) & 1 == 1\n-    }\n-\n-    #[inline]\n-    fn ptr(&self) -> *mut HashUint {\n-        (self.0.as_ptr() as usize & !1) as *mut HashUint\n-    }\n-}\n-\n-/// The raw hashtable, providing safe-ish access to the unzipped and highly\n-/// optimized arrays of hashes, and key-value pairs.\n-///\n-/// This design is a lot faster than the naive\n-/// `Vec<Option<(u64, K, V)>>`, because we don't pay for the overhead of an\n-/// option on every element, and we get a generally more cache-aware design.\n-///\n-/// Essential invariants of this structure:\n-///\n-///   - if `t.hashes[i] == EMPTY_BUCKET`, then `Bucket::at_index(&t, i).raw`\n-///     points to 'undefined' contents. Don't read from it. This invariant is\n-///     enforced outside this module with the `EmptyBucket`, `FullBucket`,\n-///     and `SafeHash` types.\n-///\n-///   - An `EmptyBucket` is only constructed at an index with\n-///     a hash of EMPTY_BUCKET.\n-///\n-///   - A `FullBucket` is only constructed at an index with a\n-///     non-EMPTY_BUCKET hash.\n-///\n-///   - A `SafeHash` is only constructed for non-`EMPTY_BUCKET` hash. We get\n-///     around hashes of zero by changing them to 0x8000_0000_0000_0000,\n-///     which will likely map to the same bucket, while not being confused\n-///     with \"empty\".\n-///\n-///   - Both \"arrays represented by pointers\" are the same length:\n-///     `capacity`. This is set at creation and never changes. The arrays\n-///     are unzipped and are more cache aware (scanning through 8 hashes\n-///     brings in at most 2 cache lines, since they're all right beside each\n-///     other). This layout may waste space in padding such as in a map from\n-///     u64 to u8, but is a more cache conscious layout as the key-value pairs\n-///     are only very shortly probed and the desired value will be in the same\n-///     or next cache line.\n-///\n-/// You can kind of think of this module/data structure as a safe wrapper\n-/// around just the \"table\" part of the hashtable. It enforces some\n-/// invariants at the type level and employs some performance trickery,\n-/// but in general is just a tricked out `Vec<Option<(u64, K, V)>>`.\n-///\n-/// The hashtable also exposes a special boolean tag. The tag defaults to false\n-/// when the RawTable is created and is accessible with the `tag` and `set_tag`\n-/// functions.\n-pub struct RawTable<K, V> {\n-    capacity_mask: usize,\n-    size: usize,\n-    hashes: TaggedHashUintPtr,\n-\n-    // Because K/V do not appear directly in any of the types in the struct,\n-    // inform rustc that in fact instances of K and V are reachable from here.\n-    marker: marker::PhantomData<(K, V)>,\n-}\n-\n-// An unsafe view of a RawTable bucket\n-// Valid indexes are within [0..table_capacity)\n-pub struct RawBucket<K, V> {\n-    hash_start: *mut HashUint,\n-    // We use *const to ensure covariance with respect to K and V\n-    pair_start: *const (K, V),\n-    idx: usize,\n-    _marker: marker::PhantomData<(K, V)>,\n-}\n-\n-impl<K, V> Copy for RawBucket<K, V> {}\n-impl<K, V> Clone for RawBucket<K, V> {\n-    fn clone(&self) -> RawBucket<K, V> {\n-        *self\n-    }\n-}\n-\n-pub struct Bucket<K, V, M> {\n-    raw: RawBucket<K, V>,\n-    table: M,\n-}\n-\n-impl<K, V, M: Copy> Copy for Bucket<K, V, M> {}\n-impl<K, V, M: Copy> Clone for Bucket<K, V, M> {\n-    fn clone(&self) -> Bucket<K, V, M> {\n-        *self\n-    }\n-}\n-\n-pub struct EmptyBucket<K, V, M> {\n-    raw: RawBucket<K, V>,\n-    table: M,\n-}\n-\n-pub struct FullBucket<K, V, M> {\n-    raw: RawBucket<K, V>,\n-    table: M,\n-}\n-\n-pub type FullBucketMut<'table, K, V> = FullBucket<K, V, &'table mut RawTable<K, V>>;\n-\n-pub enum BucketState<K, V, M> {\n-    Empty(EmptyBucket<K, V, M>),\n-    Full(FullBucket<K, V, M>),\n-}\n-\n-// A GapThenFull encapsulates the state of two consecutive buckets at once.\n-// The first bucket, called the gap, is known to be empty.\n-// The second bucket is full.\n-pub struct GapThenFull<K, V, M> {\n-    gap: EmptyBucket<K, V, ()>,\n-    full: FullBucket<K, V, M>,\n-}\n-\n-/// A hash that is not zero, since we use a hash of zero to represent empty\n-/// buckets.\n-#[derive(PartialEq, Copy, Clone)]\n-pub struct SafeHash {\n-    hash: HashUint,\n-}\n-\n-impl SafeHash {\n-    /// Peek at the hash value, which is guaranteed to be non-zero.\n-    #[inline(always)]\n-    pub fn inspect(&self) -> HashUint {\n-        self.hash\n-    }\n-\n-    #[inline(always)]\n-    pub fn new(hash: u64) -> Self {\n-        // We need to avoid 0 in order to prevent collisions with\n-        // EMPTY_HASH. We can maintain our precious uniform distribution\n-        // of initial indexes by unconditionally setting the MSB,\n-        // effectively reducing the hashes by one bit.\n-        //\n-        // Truncate hash to fit in `HashUint`.\n-        let hash_bits = size_of::<HashUint>() * 8;\n-        SafeHash { hash: (1 << (hash_bits - 1)) | (hash as HashUint) }\n-    }\n-}\n-\n-/// We need to remove hashes of 0. That's reserved for empty buckets.\n-/// This function wraps up `hash_keyed` to be the only way outside this\n-/// module to generate a SafeHash.\n-pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n-    where T: Hash,\n-          S: BuildHasher\n-{\n-    let mut state = hash_state.build_hasher();\n-    t.hash(&mut state);\n-    SafeHash::new(state.finish())\n-}\n-\n-// `replace` casts a `*HashUint` to a `*SafeHash`. Since we statically\n-// ensure that a `FullBucket` points to an index with a non-zero hash,\n-// and a `SafeHash` is just a `HashUint` with a different name, this is\n-// safe.\n-//\n-// This test ensures that a `SafeHash` really IS the same size as a\n-// `HashUint`. If you need to change the size of `SafeHash` (and\n-// consequently made this test fail), `replace` needs to be\n-// modified to no longer assume this.\n-#[test]\n-fn can_alias_safehash_as_hash() {\n-    assert_eq!(size_of::<SafeHash>(), size_of::<HashUint>())\n-}\n-\n-// RawBucket methods are unsafe as it's possible to\n-// make a RawBucket point to invalid memory using safe code.\n-impl<K, V> RawBucket<K, V> {\n-    unsafe fn hash(&self) -> *mut HashUint {\n-        self.hash_start.add(self.idx)\n-    }\n-    unsafe fn pair(&self) -> *mut (K, V) {\n-        self.pair_start.add(self.idx) as *mut (K, V)\n-    }\n-    unsafe fn hash_pair(&self) -> (*mut HashUint, *mut (K, V)) {\n-        (self.hash(), self.pair())\n-    }\n-}\n-\n-// Buckets hold references to the table.\n-impl<K, V, M> FullBucket<K, V, M> {\n-    /// Borrow a reference to the table.\n-    pub fn table(&self) -> &M {\n-        &self.table\n-    }\n-    /// Borrow a mutable reference to the table.\n-    pub fn table_mut(&mut self) -> &mut M {\n-        &mut self.table\n-    }\n-    /// Move out the reference to the table.\n-    pub fn into_table(self) -> M {\n-        self.table\n-    }\n-    /// Gets the raw index.\n-    pub fn index(&self) -> usize {\n-        self.raw.idx\n-    }\n-    /// Gets the raw bucket.\n-    pub fn raw(&self) -> RawBucket<K, V> {\n-        self.raw\n-    }\n-}\n-\n-impl<K, V, M> EmptyBucket<K, V, M> {\n-    /// Borrow a reference to the table.\n-    pub fn table(&self) -> &M {\n-        &self.table\n-    }\n-    /// Borrow a mutable reference to the table.\n-    pub fn table_mut(&mut self) -> &mut M {\n-        &mut self.table\n-    }\n-}\n-\n-impl<K, V, M> Bucket<K, V, M> {\n-    /// Gets the raw index.\n-    pub fn index(&self) -> usize {\n-        self.raw.idx\n-    }\n-    /// get the table.\n-    pub fn into_table(self) -> M {\n-        self.table\n-    }\n-}\n-\n-impl<K, V, M> Deref for FullBucket<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>>\n-{\n-    type Target = RawTable<K, V>;\n-    fn deref(&self) -> &RawTable<K, V> {\n-        &self.table\n-    }\n-}\n-\n-/// `Put` is implemented for types which provide access to a table and cannot be invalidated\n-///  by filling a bucket. A similar implementation for `Take` is possible.\n-pub trait Put<K, V> {\n-    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V>;\n-}\n-\n-\n-impl<K, V> Put<K, V> for &mut RawTable<K, V> {\n-    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n-        *self\n-    }\n-}\n-\n-impl<K, V, M> Put<K, V> for Bucket<K, V, M>\n-    where M: Put<K, V>\n-{\n-    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n-        self.table.borrow_table_mut()\n-    }\n-}\n-\n-impl<K, V, M> Put<K, V> for FullBucket<K, V, M>\n-    where M: Put<K, V>\n-{\n-    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n-        self.table.borrow_table_mut()\n-    }\n-}\n-\n-impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n-    #[inline]\n-    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n-        Bucket::at_index(table, hash.inspect() as usize)\n-    }\n-\n-    pub fn new_from(r: RawBucket<K, V>, t: M)\n-        -> Bucket<K, V, M>\n-    {\n-        Bucket {\n-            raw: r,\n-            table: t,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n-        // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n-        // This is an uncommon case though, so avoid it in release builds.\n-        debug_assert!(table.capacity() > 0,\n-                      \"Table should have capacity at this point\");\n-        let ib_index = ib_index & table.capacity_mask;\n-        Bucket {\n-            raw: table.raw_bucket_at(ib_index),\n-            table,\n-        }\n-    }\n-\n-    pub fn first(table: M) -> Bucket<K, V, M> {\n-        Bucket {\n-            raw: table.raw_bucket_at(0),\n-            table,\n-        }\n-    }\n-\n-    // \"So a few of the first shall be last: for many be called,\n-    // but few chosen.\"\n-    //\n-    // We'll most likely encounter a few buckets at the beginning that\n-    // have their initial buckets near the end of the table. They were\n-    // placed at the beginning as the probe wrapped around the table\n-    // during insertion. We must skip forward to a bucket that won't\n-    // get reinserted too early and won't unfairly steal others spot.\n-    // This eliminates the need for robin hood.\n-    pub fn head_bucket(table: M) -> Bucket<K, V, M> {\n-        let mut bucket = Bucket::first(table);\n-\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(full) => {\n-                    if full.displacement() == 0 {\n-                        // This bucket occupies its ideal spot.\n-                        // It indicates the start of another \"cluster\".\n-                        bucket = full.into_bucket();\n-                        break;\n-                    }\n-                    // Leaving this bucket in the last cluster for later.\n-                    full.into_bucket()\n-                }\n-                Empty(b) => {\n-                    // Encountered a hole between clusters.\n-                    b.into_bucket()\n-                }\n-            };\n-            bucket.next();\n-        }\n-        bucket\n-    }\n-\n-    /// Reads a bucket at a given index, returning an enum indicating whether\n-    /// it's initialized or not. You need to match on this enum to get\n-    /// the appropriate types to call most of the other functions in\n-    /// this module.\n-    pub fn peek(self) -> BucketState<K, V, M> {\n-        match unsafe { *self.raw.hash() } {\n-            EMPTY_BUCKET => {\n-                Empty(EmptyBucket {\n-                    raw: self.raw,\n-                    table: self.table,\n-                })\n-            }\n-            _ => {\n-                Full(FullBucket {\n-                    raw: self.raw,\n-                    table: self.table,\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Modifies the bucket in place to make it point to the next slot.\n-    pub fn next(&mut self) {\n-        self.raw.idx = self.raw.idx.wrapping_add(1) & self.table.capacity_mask;\n-    }\n-\n-    /// Modifies the bucket in place to make it point to the previous slot.\n-    pub fn prev(&mut self) {\n-        self.raw.idx = self.raw.idx.wrapping_sub(1) & self.table.capacity_mask;\n-    }\n-}\n-\n-impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n-    #[inline]\n-    pub fn next(self) -> Bucket<K, V, M> {\n-        let mut bucket = self.into_bucket();\n-        bucket.next();\n-        bucket\n-    }\n-\n-    #[inline]\n-    pub fn into_bucket(self) -> Bucket<K, V, M> {\n-        Bucket {\n-            raw: self.raw,\n-            table: self.table,\n-        }\n-    }\n-\n-    pub fn gap_peek(self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n-        let gap = EmptyBucket {\n-            raw: self.raw,\n-            table: (),\n-        };\n-\n-        match self.next().peek() {\n-            Full(bucket) => {\n-                Ok(GapThenFull {\n-                    gap,\n-                    full: bucket,\n-                })\n-            }\n-            Empty(e) => Err(e.into_bucket()),\n-        }\n-    }\n-}\n-\n-impl<K, V, M> EmptyBucket<K, V, M>\n-    where M: Put<K, V>\n-{\n-    /// Puts given key and value pair, along with the key's hash,\n-    /// into this bucket in the hashtable. Note how `self` is 'moved' into\n-    /// this function, because this slot will no longer be empty when\n-    /// we return! A `FullBucket` is returned for later use, pointing to\n-    /// the newly-filled slot in the hashtable.\n-    ///\n-    /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n-    pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n-        unsafe {\n-            *self.raw.hash() = hash.inspect();\n-            ptr::write(self.raw.pair(), (key, value));\n-\n-            self.table.borrow_table_mut().size += 1;\n-        }\n-\n-        FullBucket {\n-            raw: self.raw,\n-            table: self.table,\n-        }\n-    }\n-}\n-\n-impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n-    #[inline]\n-    pub fn next(self) -> Bucket<K, V, M> {\n-        let mut bucket = self.into_bucket();\n-        bucket.next();\n-        bucket\n-    }\n-\n-    #[inline]\n-    pub fn into_bucket(self) -> Bucket<K, V, M> {\n-        Bucket {\n-            raw: self.raw,\n-            table: self.table,\n-        }\n-    }\n-\n-    /// Duplicates the current position. This can be useful for operations\n-    /// on two or more buckets.\n-    pub fn stash(self) -> FullBucket<K, V, Self> {\n-        FullBucket {\n-            raw: self.raw,\n-            table: self,\n-        }\n-    }\n-\n-    /// Gets the distance between this bucket and the 'ideal' location\n-    /// as determined by the key's hash stored in it.\n-    ///\n-    /// In the cited blog posts above, this is called the \"distance to\n-    /// initial bucket\", or DIB. Also known as \"probe count\".\n-    pub fn displacement(&self) -> usize {\n-        // Calculates the distance one has to travel when going from\n-        // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n-        // if the destination is not reached before the end of the table.\n-        (self.raw.idx.wrapping_sub(self.hash().inspect() as usize)) & self.table.capacity_mask\n-    }\n-\n-    #[inline]\n-    pub fn hash(&self) -> SafeHash {\n-        unsafe { SafeHash { hash: *self.raw.hash() } }\n-    }\n-\n-    /// Gets references to the key and value at a given index.\n-    pub fn read(&self) -> (&K, &V) {\n-        unsafe {\n-            let pair_ptr = self.raw.pair();\n-            (&(*pair_ptr).0, &(*pair_ptr).1)\n-        }\n-    }\n-}\n-\n-// We take a mutable reference to the table instead of accepting anything that\n-// implements `DerefMut` to prevent fn `take` from being called on `stash`ed\n-// buckets.\n-impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n-    /// Removes this bucket's key and value from the hashtable.\n-    ///\n-    /// This works similarly to `put`, building an `EmptyBucket` out of the\n-    /// taken bucket.\n-    pub fn take(self) -> (EmptyBucket<K, V, &'t mut RawTable<K, V>>, K, V) {\n-        self.table.size -= 1;\n-\n-        unsafe {\n-            *self.raw.hash() = EMPTY_BUCKET;\n-            let (k, v) = ptr::read(self.raw.pair());\n-            (EmptyBucket {\n-                 raw: self.raw,\n-                 table: self.table,\n-             },\n-            k,\n-            v)\n-        }\n-    }\n-}\n-\n-// This use of `Put` is misleading and restrictive, but safe and sufficient for our use cases\n-// where `M` is a full bucket or table reference type with mutable access to the table.\n-impl<K, V, M> FullBucket<K, V, M>\n-    where M: Put<K, V>\n-{\n-    pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n-        unsafe {\n-            let old_hash = ptr::replace(self.raw.hash() as *mut SafeHash, h);\n-            let (old_key, old_val) = ptr::replace(self.raw.pair(), (k, v));\n-\n-            (old_hash, old_key, old_val)\n-        }\n-    }\n-}\n-\n-impl<K, V, M> FullBucket<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>> + DerefMut\n-{\n-    /// Gets mutable references to the key and value at a given index.\n-    pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        unsafe {\n-            let pair_ptr = self.raw.pair();\n-            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n-        }\n-    }\n-}\n-\n-impl<'t, K, V, M> FullBucket<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>> + 't\n-{\n-    /// Exchange a bucket state for immutable references into the table.\n-    /// Because the underlying reference to the table is also consumed,\n-    /// no further changes to the structure of the table are possible;\n-    /// in exchange for this, the returned references have a longer lifetime\n-    /// than the references returned by `read()`.\n-    pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe {\n-            let pair_ptr = self.raw.pair();\n-            (&(*pair_ptr).0, &(*pair_ptr).1)\n-        }\n-    }\n-}\n-\n-impl<'t, K, V, M> FullBucket<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>> + DerefMut + 't\n-{\n-    /// This works similarly to `into_refs`, exchanging a bucket state\n-    /// for mutable references into the table.\n-    pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        unsafe {\n-            let pair_ptr = self.raw.pair();\n-            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n-        }\n-    }\n-}\n-\n-impl<K, V, M> GapThenFull<K, V, M>\n-    where M: Deref<Target = RawTable<K, V>>\n-{\n-    #[inline]\n-    pub fn full(&self) -> &FullBucket<K, V, M> {\n-        &self.full\n-    }\n-\n-    pub fn into_table(self) -> M {\n-        self.full.into_table()\n-    }\n-\n-    pub fn shift(mut self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n-        unsafe {\n-            let (gap_hash, gap_pair) = self.gap.raw.hash_pair();\n-            let (full_hash, full_pair) = self.full.raw.hash_pair();\n-            *gap_hash = mem::replace(&mut *full_hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(full_pair, gap_pair, 1);\n-        }\n-\n-        let FullBucket { raw: prev_raw, .. } = self.full;\n-\n-        match self.full.next().peek() {\n-            Full(bucket) => {\n-                self.gap.raw = prev_raw;\n-\n-                self.full = bucket;\n-\n-                Ok(self)\n-            }\n-            Empty(b) => Err(b.into_bucket()),\n-        }\n-    }\n-}\n-\n-// Returns a Layout which describes the allocation required for a hash table,\n-// and the offset of the array of (key, value) pairs in the allocation.\n-#[inline(always)]\n-fn calculate_layout<K, V>(capacity: usize) -> Result<(Layout, usize), LayoutErr> {\n-    let hashes = Layout::array::<HashUint>(capacity)?;\n-    let pairs = Layout::array::<(K, V)>(capacity)?;\n-    hashes.extend(pairs).map(|(layout, _)| {\n-        // LLVM seems to have trouble properly const-propagating pairs.align(),\n-        // possibly due to the use of NonZeroUsize. This little hack allows it\n-        // to generate optimal code.\n-        //\n-        // See https://github.com/rust-lang/rust/issues/51346 for more details.\n-        (\n-            layout,\n-            hashes.size() + hashes.padding_needed_for(mem::align_of::<(K, V)>()),\n-        )\n-    })\n-}\n-\n-pub(crate) enum Fallibility {\n-    Fallible,\n-    Infallible,\n-}\n-\n-use self::Fallibility::*;\n-\n-impl<K, V> RawTable<K, V> {\n-    /// Does not initialize the buckets. The caller should ensure they,\n-    /// at the very least, set every hash to EMPTY_BUCKET.\n-    /// Returns an error if it cannot allocate or capacity overflows.\n-    unsafe fn new_uninitialized_internal(\n-        capacity: usize,\n-        fallibility: Fallibility,\n-    ) -> Result<RawTable<K, V>, CollectionAllocErr> {\n-        if capacity == 0 {\n-            return Ok(RawTable {\n-                size: 0,\n-                capacity_mask: capacity.wrapping_sub(1),\n-                hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n-                marker: marker::PhantomData,\n-            });\n-        }\n-\n-        // Allocating hashmaps is a little tricky. We need to allocate two\n-        // arrays, but since we know their sizes and alignments up front,\n-        // we just allocate a single array, and then have the subarrays\n-        // point into it.\n-        let (layout, _) = calculate_layout::<K, V>(capacity)?;\n-        let buffer = Global.alloc(layout).map_err(|e| match fallibility {\n-            Infallible => handle_alloc_error(layout),\n-            Fallible => e,\n-        })?;\n-\n-        Ok(RawTable {\n-            capacity_mask: capacity.wrapping_sub(1),\n-            size: 0,\n-            hashes: TaggedHashUintPtr::new(buffer.cast().as_ptr()),\n-            marker: marker::PhantomData,\n-        })\n-    }\n-\n-    /// Does not initialize the buckets. The caller should ensure they,\n-    /// at the very least, set every hash to EMPTY_BUCKET.\n-    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n-        match Self::new_uninitialized_internal(capacity, Infallible) {\n-            Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr) => unreachable!(),\n-            Ok(table) => { table }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n-        let (_, pairs_offset) = calculate_layout::<K, V>(self.capacity())\n-            .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });\n-        let buffer = self.hashes.ptr() as *mut u8;\n-        unsafe {\n-            RawBucket {\n-                hash_start: buffer as *mut HashUint,\n-                pair_start: buffer.add(pairs_offset) as *const (K, V),\n-                idx: index,\n-                _marker: marker::PhantomData,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn new_internal(\n-        capacity: usize,\n-        fallibility: Fallibility,\n-    ) -> Result<RawTable<K, V>, CollectionAllocErr> {\n-        unsafe {\n-            let ret = RawTable::new_uninitialized_internal(capacity, fallibility)?;\n-            if capacity > 0 {\n-                ptr::write_bytes(ret.hashes.ptr(), 0, capacity);\n-            }\n-            Ok(ret)\n-        }\n-    }\n-\n-    /// Tries to create a new raw table from a given capacity. If it cannot allocate,\n-    /// it returns with AllocErr.\n-    #[inline]\n-    pub fn try_new(capacity: usize) -> Result<RawTable<K, V>, CollectionAllocErr> {\n-        Self::new_internal(capacity, Fallible)\n-    }\n-\n-    /// Creates a new raw table from a given capacity. All buckets are\n-    /// initially empty.\n-    #[inline]\n-    pub fn new(capacity: usize) -> RawTable<K, V> {\n-        match Self::new_internal(capacity, Infallible) {\n-            Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr) => unreachable!(),\n-            Ok(table) => { table }\n-        }\n-    }\n-\n-    /// The hashtable's capacity, similar to a vector's.\n-    pub fn capacity(&self) -> usize {\n-        self.capacity_mask.wrapping_add(1)\n-    }\n-\n-    /// The number of elements ever `put` in the hashtable, minus the number\n-    /// of elements ever `take`n.\n-    pub fn size(&self) -> usize {\n-        self.size\n-    }\n-\n-    fn raw_buckets(&self) -> RawBuckets<'_, K, V> {\n-        RawBuckets {\n-            raw: self.raw_bucket_at(0),\n-            elems_left: self.size,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            iter: self.raw_buckets(),\n-        }\n-    }\n-\n-    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut {\n-            iter: self.raw_buckets(),\n-            _marker: marker::PhantomData,\n-        }\n-    }\n-\n-    pub fn into_iter(self) -> IntoIter<K, V> {\n-        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n-        // Replace the marker regardless of lifetime bounds on parameters.\n-        IntoIter {\n-            iter: RawBuckets {\n-                raw,\n-                elems_left,\n-                marker: marker::PhantomData,\n-            },\n-            table: self,\n-        }\n-    }\n-\n-    pub fn drain(&mut self) -> Drain<'_, K, V> {\n-        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n-        // Replace the marker regardless of lifetime bounds on parameters.\n-        Drain {\n-            iter: RawBuckets {\n-                raw,\n-                elems_left,\n-                marker: marker::PhantomData,\n-            },\n-            table: NonNull::from(self),\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Drops buckets in reverse order. It leaves the table in an inconsistent\n-    /// state and should only be used for dropping the table's remaining\n-    /// entries. It's used in the implementation of Drop.\n-    unsafe fn rev_drop_buckets(&mut self) {\n-        // initialize the raw bucket past the end of the table\n-        let mut raw = self.raw_bucket_at(self.capacity());\n-        let mut elems_left = self.size;\n-\n-        while elems_left != 0 {\n-            raw.idx -= 1;\n-\n-            if *raw.hash() != EMPTY_BUCKET {\n-                elems_left -= 1;\n-                ptr::drop_in_place(raw.pair());\n-            }\n-        }\n-    }\n-\n-    /// Sets the table tag.\n-    pub fn set_tag(&mut self, value: bool) {\n-        self.hashes.set_tag(value)\n-    }\n-\n-    /// Gets the table tag.\n-    pub fn tag(&self) -> bool {\n-        self.hashes.tag()\n-    }\n-}\n-\n-/// A raw iterator. The basis for some other iterators in this module. Although\n-/// this interface is safe, it's not used outside this module.\n-struct RawBuckets<'a, K, V> {\n-    raw: RawBucket<K, V>,\n-    elems_left: usize,\n-\n-    // Strictly speaking, this should be &'a (K,V), but that would\n-    // require that K:'a, and we often use RawBuckets<'static...> for\n-    // move iterations, so that messes up a lot of other things. So\n-    // just use `&'a (K,V)` as this is not a publicly exposed type\n-    // anyway.\n-    marker: marker::PhantomData<&'a ()>,\n-}\n-\n-// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-impl<K, V> Clone for RawBuckets<'_, K, V> {\n-    fn clone(&self) -> Self {\n-        RawBuckets {\n-            raw: self.raw,\n-            elems_left: self.elems_left,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-\n-impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n-    type Item = RawBucket<K, V>;\n-\n-    fn next(&mut self) -> Option<RawBucket<K, V>> {\n-        if self.elems_left == 0 {\n-            return None;\n-        }\n-\n-        loop {\n-            unsafe {\n-                let item = self.raw;\n-                self.raw.idx += 1;\n-                if *item.hash() != EMPTY_BUCKET {\n-                    self.elems_left -= 1;\n-                    return Some(item);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n-    }\n-}\n-\n-impl<K, V> ExactSizeIterator for RawBuckets<'_, K, V> {\n-    fn len(&self) -> usize {\n-        self.elems_left\n-    }\n-}\n-\n-/// Iterator over shared references to entries in a table.\n-pub struct Iter<'a, K: 'a, V: 'a> {\n-    iter: RawBuckets<'a, K, V>,\n-}\n-\n-unsafe impl<K: Sync, V: Sync> Sync for Iter<'_, K, V> {}\n-unsafe impl<K: Sync, V: Sync> Send for Iter<'_, K, V> {}\n-\n-// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-impl<K, V> Clone for Iter<'_, K, V> {\n-    fn clone(&self) -> Self {\n-        Iter {\n-            iter: self.iter.clone(),\n-        }\n-    }\n-}\n-\n-/// Iterator over mutable references to entries in a table.\n-pub struct IterMut<'a, K: 'a, V: 'a> {\n-    iter: RawBuckets<'a, K, V>,\n-    // To ensure invariance with respect to V\n-    _marker: marker::PhantomData<&'a mut V>,\n-}\n-\n-unsafe impl<K: Sync, V: Sync> Sync for IterMut<'_, K, V> {}\n-// Both K: Sync and K: Send are correct for IterMut's Send impl,\n-// but Send is the more useful bound\n-unsafe impl<K: Send, V: Send> Send for IterMut<'_, K, V> {}\n-\n-impl<'a, K: 'a, V: 'a> IterMut<'a, K, V> {\n-    pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            iter: self.iter.clone(),\n-        }\n-    }\n-}\n-\n-/// Iterator over the entries in a table, consuming the table.\n-pub struct IntoIter<K, V> {\n-    table: RawTable<K, V>,\n-    iter: RawBuckets<'static, K, V>,\n-}\n-\n-unsafe impl<K: Sync, V: Sync> Sync for IntoIter<K, V> {}\n-unsafe impl<K: Send, V: Send> Send for IntoIter<K, V> {}\n-\n-impl<K, V> IntoIter<K, V> {\n-    pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            iter: self.iter.clone(),\n-        }\n-    }\n-}\n-\n-/// Iterator over the entries in a table, clearing the table.\n-pub struct Drain<'a, K: 'a, V: 'a> {\n-    table: NonNull<RawTable<K, V>>,\n-    iter: RawBuckets<'static, K, V>,\n-    marker: marker::PhantomData<&'a RawTable<K, V>>,\n-}\n-\n-unsafe impl<K: Sync, V: Sync> Sync for Drain<'_, K, V> {}\n-unsafe impl<K: Send, V: Send> Send for Drain<'_, K, V> {}\n-\n-impl<'a, K, V> Drain<'a, K, V> {\n-    pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            iter: self.iter.clone(),\n-        }\n-    }\n-}\n-\n-impl<'a, K, V> Iterator for Iter<'a, K, V> {\n-    type Item = (&'a K, &'a V);\n-\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.iter.next().map(|raw| unsafe {\n-            let pair_ptr = raw.pair();\n-            (&(*pair_ptr).0, &(*pair_ptr).1)\n-        })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-}\n-\n-impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n-    type Item = (&'a K, &'a mut V);\n-\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.iter.next().map(|raw| unsafe {\n-            let pair_ptr = raw.pair();\n-            (&(*pair_ptr).0, &mut (*pair_ptr).1)\n-        })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-}\n-\n-impl<K, V> Iterator for IntoIter<K, V> {\n-    type Item = (SafeHash, K, V);\n-\n-    fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|raw| {\n-            self.table.size -= 1;\n-            unsafe {\n-                let (k, v) = ptr::read(raw.pair());\n-                (SafeHash { hash: *raw.hash() }, k, v)\n-            }\n-        })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    fn len(&self) -> usize {\n-        self.iter().len()\n-    }\n-}\n-\n-impl<'a, K, V> Iterator for Drain<'a, K, V> {\n-    type Item = (SafeHash, K, V);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|raw| {\n-            unsafe {\n-                self.table.as_mut().size -= 1;\n-                let (k, v) = ptr::read(raw.pair());\n-                (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n-            }\n-        })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<K, V> ExactSizeIterator for Drain<'_, K, V> {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-}\n-\n-impl<K, V> Drop for Drain<'_, K, V> {\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n-impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n-    fn clone(&self) -> RawTable<K, V> {\n-        unsafe {\n-            let cap = self.capacity();\n-            let mut new_ht = RawTable::new_uninitialized(cap);\n-\n-            let mut new_buckets = new_ht.raw_bucket_at(0);\n-            let mut buckets = self.raw_bucket_at(0);\n-            while buckets.idx < cap {\n-                *new_buckets.hash() = *buckets.hash();\n-                if *new_buckets.hash() != EMPTY_BUCKET {\n-                    let pair_ptr = buckets.pair();\n-                    let kv = ((*pair_ptr).0.clone(), (*pair_ptr).1.clone());\n-                    ptr::write(new_buckets.pair(), kv);\n-                }\n-                buckets.idx += 1;\n-                new_buckets.idx += 1;\n-            }\n-\n-            new_ht.size = self.size();\n-            new_ht.set_tag(self.tag());\n-\n-            new_ht\n-        }\n-    }\n-}\n-\n-unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n-    fn drop(&mut self) {\n-        if self.capacity() == 0 {\n-            return;\n-        }\n-\n-        // This is done in reverse because we've likely partially taken\n-        // some elements out with `.into_iter()` from the front.\n-        // Check if the size is 0, so we don't do a useless scan when\n-        // dropping empty tables such as on resize.\n-        // Also avoid double drop of elements that have been already moved out.\n-        unsafe {\n-            if needs_drop::<(K, V)>() {\n-                // avoid linear runtime for types that don't need drop\n-                self.rev_drop_buckets();\n-            }\n-        }\n-\n-        let (layout, _) = calculate_layout::<K, V>(self.capacity())\n-            .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });\n-        unsafe {\n-            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).cast(), layout);\n-            // Remember how everything was allocated out of one buffer\n-            // during initialization? We only need one call to free here.\n-        }\n-    }\n-}"}]}