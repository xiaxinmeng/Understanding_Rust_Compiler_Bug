{"sha": "befa2dffdafe77fdd344690558f1334e721b42db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZmEyZGZmZGFmZTc3ZmRkMzQ0NjkwNTU4ZjEzMzRlNzIxYjQyZGI=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-02-25T21:06:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-25T21:06:21Z"}, "message": "Rollup merge of #82467 - ojeda:tidy-normalize-safety-comments, r=kennytm\n\nlibrary: Normalize safety-for-unsafe-block comments\n\nAlmost all safety comments are of the form `// SAFETY:`,\nso normalize the rest and fix a few of them that should\nhave been a `/// # Safety` section instead.\n\nFurthermore, make `tidy` only allow the uppercase form. While\ncurrently `tidy` only checks `core`, it is a good idea to prevent\n`core` from drifting to non-uppercase comments, so that later\nwe can start checking `alloc` etc. too.\n\nSigned-off-by: Miguel Ojeda <ojeda@kernel.org>", "tree": {"sha": "0061636d949683d72fa90bc55212c68f29325280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0061636d949683d72fa90bc55212c68f29325280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/befa2dffdafe77fdd344690558f1334e721b42db", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgOBFNCRBK7hj4Ov3rIwAAdHIIAHbOYQEVHdCTxauE8+/yt1f+\nlxSCDhXkj4p4uTgLT6VlqqMZWL3CVWQ3L2oCeUgE1fNwcXPGGvJsAf1tynXLybND\nZJPykFUor1bqapOvUzVt5/tjbPFK/wjHn1XWdLhi+dDgyOw4B1mjqBynqAXBvRxD\noWmgkuJS7tSnFtUmIfi1r4MN4Lv9N8Kf/QdjoTCJHjZK46EFWrwlDpiuxzRWnstB\nmK+pMiR2j1pSCgkf47YqHvi9RhcyTYlkQgoPXytPBdueBe21Owc/GdZU2GK4bghr\nx6ubH637qWlNDNIQuiEwK08m8J1o3ZRJ1td5uaRNkUwowZ3gwi1GKGqHvlvSyJc=\n=8jjQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 0061636d949683d72fa90bc55212c68f29325280\nparent 503d50b94cb7864d126131a538913f8ab83bd6bc\nparent eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d\nauthor Aaron Hill <aa1ronham@gmail.com> 1614287181 -0500\ncommitter GitHub <noreply@github.com> 1614287181 -0500\n\nRollup merge of #82467 - ojeda:tidy-normalize-safety-comments, r=kennytm\n\nlibrary: Normalize safety-for-unsafe-block comments\n\nAlmost all safety comments are of the form `// SAFETY:`,\nso normalize the rest and fix a few of them that should\nhave been a `/// # Safety` section instead.\n\nFurthermore, make `tidy` only allow the uppercase form. While\ncurrently `tidy` only checks `core`, it is a good idea to prevent\n`core` from drifting to non-uppercase comments, so that later\nwe can start checking `alloc` etc. too.\n\nSigned-off-by: Miguel Ojeda <ojeda@kernel.org>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/befa2dffdafe77fdd344690558f1334e721b42db", "html_url": "https://github.com/rust-lang/rust/commit/befa2dffdafe77fdd344690558f1334e721b42db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/befa2dffdafe77fdd344690558f1334e721b42db/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "503d50b94cb7864d126131a538913f8ab83bd6bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/503d50b94cb7864d126131a538913f8ab83bd6bc", "html_url": "https://github.com/rust-lang/rust/commit/503d50b94cb7864d126131a538913f8ab83bd6bc"}, {"sha": "eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "html_url": "https://github.com/rust-lang/rust/commit/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d"}], "stats": {"total": 45, "additions": 26, "deletions": 19}, "files": [{"sha": "941f82a8070a02e1861c23d57a567c4d2993ed4e", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -278,14 +278,14 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         let out_ptr = match self.handle.insert_recursing(self.key, value) {\n             (Fit(_), val_ptr) => {\n-                // Safety: We have consumed self.handle and the handle returned.\n+                // SAFETY: We have consumed self.handle and the handle returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 map.length += 1;\n                 val_ptr\n             }\n             (Split(ins), val_ptr) => {\n                 drop(ins.left);\n-                // Safety: We have consumed self.handle and the reference returned.\n+                // SAFETY: We have consumed self.handle and the reference returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 let root = map.root.as_mut().unwrap();\n                 root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);"}, {"sha": "b1b2619428366fbfcb18d19a9432a0884d83aa0f", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -1938,13 +1938,13 @@ impl<T, A: Allocator> Vec<T, A> {\n     pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n         let ptr = self.as_mut_ptr();\n \n-        // Safety:\n+        // SAFETY:\n         // - `ptr` is guaranteed to be in bounds for `capacity` elements\n         // - `len` is guaranteed to less or equal to `capacity`\n         // - `MaybeUninit<T>` has the same layout as `T`\n         let spare_ptr = unsafe { ptr.cast::<MaybeUninit<T>>().add(self.len) };\n \n-        // Safety:\n+        // SAFETY:\n         // - `ptr` is guaranteed to be valid for `len` elements\n         // - `spare_ptr` is offseted from `ptr` by `len`, so it doesn't overlap `initialized` slice\n         unsafe {\n@@ -2154,7 +2154,8 @@ pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<\n }\n \n trait ExtendFromWithinSpec {\n-    /// Safety:\n+    /// # Safety\n+    ///\n     /// - `src` needs to be valid index\n     /// - `self.capacity() - self.len()` must be `>= src.len()`\n     unsafe fn spec_extend_from_within(&mut self, src: Range<usize>);\n@@ -2165,14 +2166,14 @@ impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         let initialized = {\n             let (this, spare) = self.split_at_spare_mut();\n \n-            // Safety:\n+            // SAFETY:\n             // - caller guaratees that src is a valid index\n             let to_clone = unsafe { this.get_unchecked(src) };\n \n             to_clone.iter().cloned().zip(spare.iter_mut()).map(|(e, s)| s.write(e)).count()\n         };\n \n-        // Safety:\n+        // SAFETY:\n         // - elements were just initialized\n         unsafe {\n             let new_len = self.len() + initialized;\n@@ -2187,11 +2188,11 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         {\n             let (init, spare) = self.split_at_spare_mut();\n \n-            // Safety:\n+            // SAFETY:\n             // - caller guaratees that `src` is a valid index\n             let source = unsafe { init.get_unchecked(src) };\n \n-            // Safety:\n+            // SAFETY:\n             // - Both pointers are created from unique slice references (`&mut [_]`)\n             //   so they are valid and do not overlap.\n             // - Elements are :Copy so it's OK to to copy them, without doing\n@@ -2203,7 +2204,7 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n             unsafe { ptr::copy_nonoverlapping(source.as_ptr(), spare.as_mut_ptr() as _, count) };\n         }\n \n-        // Safety:\n+        // SAFETY:\n         // - The elements were just initialized by `copy_nonoverlapping`\n         self.len += count;\n     }"}, {"sha": "eb60df214c489cff2d420e15b68f811cdbdd2d22", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -106,7 +106,7 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n                     Ok(0) => return Ok(len), // EOF reached\n                     Ok(bytes_read) => {\n                         assert!(bytes_read <= spare_cap.len());\n-                        // Safety: The initializer contract guarantees that either it or `read`\n+                        // SAFETY: The initializer contract guarantees that either it or `read`\n                         // will have initialized these bytes. And we just checked that the number\n                         // of bytes is within the buffer capacity.\n                         unsafe { buf.set_len(buf.len() + bytes_read) };"}, {"sha": "aec2a2aa639edc799f2d87fff6535e595a984dff", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -440,13 +440,17 @@ impl<T> SyncOnceCell<T> {\n         res\n     }\n \n-    /// Safety: The value must be initialized\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n     unsafe fn get_unchecked(&self) -> &T {\n         debug_assert!(self.is_initialized());\n         (&*self.value.get()).assume_init_ref()\n     }\n \n-    /// Safety: The value must be initialized\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n     unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n         debug_assert!(self.is_initialized());\n         (&mut *self.value.get()).assume_init_mut()\n@@ -456,7 +460,7 @@ impl<T> SyncOnceCell<T> {\n unsafe impl<#[may_dangle] T> Drop for SyncOnceCell<T> {\n     fn drop(&mut self) {\n         if self.is_initialized() {\n-            // Safety: The cell is initialized and being dropped, so it can't\n+            // SAFETY: The cell is initialized and being dropped, so it can't\n             // be accessed again. We also don't touch the `T` other than\n             // dropping it, which validates our usage of #[may_dangle].\n             unsafe { (&mut *self.value.get()).assume_init_drop() };"}, {"sha": "b8f512f6a232fc88fdf64fd3b2eb05fa1f3441f6", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -8,7 +8,9 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n-// Safety: `bytes` must be a valid wtf8 encoded slice\n+/// # Safety\n+///\n+/// `bytes` must be a valid wtf8 encoded slice\n #[inline]\n unsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n     // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n@@ -130,7 +132,7 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n             // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n             let path = &path.bytes()[separator_end..];\n \n-            // Safety: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n+            // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n             // is encoded in a single byte, therefore `bytes[separator_start]` and\n             // `bytes[separator_end]` must be code point boundaries and thus\n             // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices."}, {"sha": "70b31b19f824cb16eda7030a235fc7de88d3f4c5", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -103,7 +103,7 @@ impl StaticRWLock {\n     /// The lock is automatically unlocked when the returned guard is dropped.\n     #[inline]\n     pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n-        // Safety: All methods require static references, therefore self\n+        // SAFETY: All methods require static references, therefore self\n         // cannot be moved between invocations.\n         unsafe {\n             self.0.read();\n@@ -117,7 +117,7 @@ impl StaticRWLock {\n     /// The lock is automatically unlocked when the returned guard is dropped.\n     #[inline]\n     pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n-        // Safety: All methods require static references, therefore self\n+        // SAFETY: All methods require static references, therefore self\n         // cannot be moved between invocations.\n         unsafe {\n             self.0.write();"}, {"sha": "75c43343023f9a08ece28e7e1dfdbf092c9d8c73", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befa2dffdafe77fdd344690558f1334e721b42db/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befa2dffdafe77fdd344690558f1334e721b42db/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=befa2dffdafe77fdd344690558f1334e721b42db", "patch": "@@ -289,7 +289,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     suppressible_tidy_err!(err, skip_undocumented_unsafe, \"undocumented unsafe\");\n                 }\n             }\n-            if line.contains(\"// SAFETY:\") || line.contains(\"// Safety:\") {\n+            if line.contains(\"// SAFETY:\") {\n                 last_safety_comment = true;\n             } else if line.trim().starts_with(\"//\") || line.trim().is_empty() {\n                 // keep previous value"}]}