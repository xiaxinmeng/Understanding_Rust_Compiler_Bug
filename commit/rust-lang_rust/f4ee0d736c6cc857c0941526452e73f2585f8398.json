{"sha": "f4ee0d736c6cc857c0941526452e73f2585f8398", "node_id": "C_kwDOAAsO6NoAKGY0ZWUwZDczNmM2Y2M4NTdjMDk0MTUyNjQ1MmU3M2YyNTg1ZjgzOTg", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-09T11:38:57Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-09T11:39:24Z"}, "message": "move tests", "tree": {"sha": "39f9c5f478236ac30b7c9aab3f76301dfc7d369f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f9c5f478236ac30b7c9aab3f76301dfc7d369f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4ee0d736c6cc857c0941526452e73f2585f8398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ee0d736c6cc857c0941526452e73f2585f8398", "html_url": "https://github.com/rust-lang/rust/commit/f4ee0d736c6cc857c0941526452e73f2585f8398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4ee0d736c6cc857c0941526452e73f2585f8398/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1abe3f8275d1921c0f025edddd8bf7ad57faa333", "url": "https://api.github.com/repos/rust-lang/rust/commits/1abe3f8275d1921c0f025edddd8bf7ad57faa333", "html_url": "https://github.com/rust-lang/rust/commit/1abe3f8275d1921c0f025edddd8bf7ad57faa333"}], "stats": {"total": 158, "additions": 66, "deletions": 92}, "files": [{"sha": "386bd4f1b561722f8dde525c7d7c2c5478649e9d", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee0d736c6cc857c0941526452e73f2585f8398/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee0d736c6cc857c0941526452e73f2585f8398/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=f4ee0d736c6cc857c0941526452e73f2585f8398", "patch": "@@ -16,7 +16,8 @@ use expect_test::{expect, Expect};\n use hir_expand::{db::AstDatabase, InFile, MacroFile};\n use stdx::format_to;\n use syntax::{\n-    ast, AstNode,\n+    ast::{self, edit::IndentLevel},\n+    AstNode,\n     SyntaxKind::{self, IDENT},\n     SyntaxNode, T,\n };\n@@ -63,6 +64,8 @@ fn check(ra_fixture: &str, expect: Expect) {\n         }\n         if let Some((parse, _token_map)) = exp.value {\n             let pp = pretty_print_macro_expansion(parse.syntax_node());\n+            let indent = IndentLevel::from_node(call.syntax());\n+            let pp = reindent(indent, pp);\n             format_to!(expn_text, \"{}\", pp);\n         }\n         let range = call.syntax().text_range();\n@@ -73,23 +76,38 @@ fn check(ra_fixture: &str, expect: Expect) {\n     expect.assert_eq(&expanded_text);\n }\n \n+fn reindent(indent: IndentLevel, pp: String) -> String {\n+    if !pp.contains('\\n') {\n+        return pp;\n+    }\n+    let mut lines = pp.split_inclusive('\\n');\n+    let mut res = lines.next().unwrap().to_string();\n+    for line in lines {\n+        if line.trim().is_empty() {\n+            res.push_str(&line)\n+        } else {\n+            format_to!(res, \"{}{}\", indent, line)\n+        }\n+    }\n+    res\n+}\n+\n fn pretty_print_macro_expansion(expn: SyntaxNode) -> String {\n     let mut res = String::new();\n     let mut prev_kind = SyntaxKind::EOF;\n     for token in iter::successors(expn.first_token(), |t| t.next_token()) {\n         let curr_kind = token.kind();\n-        let needs_space = match (prev_kind, curr_kind) {\n-            _ if prev_kind.is_trivia() || curr_kind.is_trivia() => false,\n-            (T![=], _) | (_, T![=]) => true,\n-            (IDENT, IDENT) => true,\n-            (IDENT, _) => curr_kind.is_keyword(),\n-            (_, IDENT) => prev_kind.is_keyword(),\n-            _ => false,\n+        let space = match (prev_kind, curr_kind) {\n+            _ if prev_kind.is_trivia() || curr_kind.is_trivia() => \"\",\n+            (T![=], _) | (_, T![=]) => \" \",\n+            (T![;], _) => \"\\n\",\n+            (IDENT, IDENT) => \" \",\n+            (IDENT, _) if curr_kind.is_keyword() => \" \",\n+            (_, IDENT) if prev_kind.is_keyword() => \" \",\n+            _ => \"\",\n         };\n \n-        if needs_space {\n-            res.push(' ')\n-        }\n+        res.push_str(space);\n         prev_kind = curr_kind;\n         format_to!(res, \"{}\", token)\n     }\n@@ -148,10 +166,45 @@ macro_rules! m {\n     () => { type qual: ::T = qual::T; }\n }\n type qual: ::T = qual::T;\n-        \"#]],\n+\"#]],\n     )\n }\n \n+#[test]\n+fn round_trips_literals() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => {\n+        let _ = 'c';\n+        let _ = 1000;\n+        let _ = 12E+99_f64;\n+        let _ = \"rust1\";\n+    }\n+}\n+fn f() {\n+    m!()\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    () => {\n+        let _ = 'c';\n+        let _ = 1000;\n+        let _ = 12E+99_f64;\n+        let _ = \"rust1\";\n+    }\n+}\n+fn f() {\n+    let_ = 'c';\n+    let_ = 1000;\n+    let_ = 12E+99_f64;\n+    let_ = \"rust1\";\n+}\n+\"#]],\n+    );\n+}\n+\n #[test]\n fn broken_parenthesis_sequence() {\n     check(\n@@ -168,6 +221,6 @@ macro_rules! m2 { ($x:ident) => {} }\n \n /* error: Failed to find macro definition */\n /* error: Failed to lower macro args to token tree */\n-        \"#]],\n+\"#]],\n     )\n }"}, {"sha": "f3c9af1ccb4b693398a6b09fc5b07c68f6446624", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee0d736c6cc857c0941526452e73f2585f8398/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee0d736c6cc857c0941526452e73f2585f8398/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=f4ee0d736c6cc857c0941526452e73f2585f8398", "patch": "@@ -743,82 +743,3 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n         self.inner.error(error, self.text_pos)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::tests::parse_macro;\n-    use parser::TokenSource;\n-    use syntax::{\n-        ast::{make, AstNode},\n-        ted,\n-    };\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn convert_tt_token_source() {\n-        let expansion = parse_macro(\n-            r#\"\n-            macro_rules! literals {\n-                ($i:ident) => {\n-                    {\n-                        let a = 'c';\n-                        let c = 1000;\n-                        let f = 12E+99_f64;\n-                        let s = \"rust1\";\n-                    }\n-                }\n-            }\n-            \"#,\n-        )\n-        .expand_tt(\"literals!(foo);\");\n-        let tts = &[expansion.into()];\n-        let buffer = tt::buffer::TokenBuffer::from_tokens(tts);\n-        let mut tt_src = SubtreeTokenSource::new(&buffer);\n-        let mut tokens = vec![];\n-        while tt_src.current().kind != EOF {\n-            tokens.push((tt_src.current().kind, tt_src.text()));\n-            tt_src.bump();\n-        }\n-\n-        // [${]\n-        // [let] [a] [=] ['c'] [;]\n-        assert_eq!(tokens[2 + 3].1, \"'c'\");\n-        assert_eq!(tokens[2 + 3].0, CHAR);\n-        // [let] [c] [=] [1000] [;]\n-        assert_eq!(tokens[2 + 5 + 3].1, \"1000\");\n-        assert_eq!(tokens[2 + 5 + 3].0, INT_NUMBER);\n-        // [let] [f] [=] [12E+99_f64] [;]\n-        assert_eq!(tokens[2 + 10 + 3].1, \"12E+99_f64\");\n-        assert_eq!(tokens[2 + 10 + 3].0, FLOAT_NUMBER);\n-\n-        // [let] [s] [=] [\"rust1\"] [;]\n-        assert_eq!(tokens[2 + 15 + 3].1, \"\\\"rust1\\\"\");\n-        assert_eq!(tokens[2 + 15 + 3].0, STRING);\n-    }\n-\n-    #[test]\n-    fn test_token_tree_last_child_is_white_space() {\n-        let source_file = ast::SourceFile::parse(\"f!{}\").ok().unwrap();\n-        let macro_call = source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-        let token_tree = macro_call.token_tree().unwrap();\n-\n-        // Token Tree now is :\n-        // TokenTree\n-        // - TokenTree\n-        //   - T!['{']\n-        //   - T!['}']\n-\n-        let token_tree = token_tree.clone_for_update();\n-        ted::append_child(token_tree.syntax(), make::tokens::single_space());\n-        let token_tree = token_tree.clone_subtree();\n-        // Token Tree now is :\n-        // TokenTree\n-        // - T!['{']\n-        // - T!['}']\n-        // - WHITE_SPACE\n-\n-        let tt = syntax_node_to_token_tree(token_tree.syntax()).0;\n-        assert_eq!(tt.delimiter_kind(), Some(tt::DelimiterKind::Brace));\n-    }\n-}"}]}