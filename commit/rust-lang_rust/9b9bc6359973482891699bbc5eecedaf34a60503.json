{"sha": "9b9bc6359973482891699bbc5eecedaf34a60503", "node_id": "C_kwDOAAsO6NoAKDliOWJjNjM1OTk3MzQ4Mjg5MTY5OWJiYzVlZWNlZGFmMzRhNjA1MDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-25T02:32:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-25T02:32:11Z"}, "message": "Auto merge of #100977 - JohnTitor:rollup-8hc7rxh, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #99332 (Stabilize `#![feature(label_break_value)]`)\n - #99954 (let-else: break out to one scope higher for let-else)\n - #100188 (Parser will not suggest invalid expression when use public)\n - #100780 (save_analysis: Migrate diagnostic)\n - #100808 (Migrate `rustc_interface` diagnostics )\n - #100921 (Add a warning about `Option/Result::and()` being eagerly evaluated)\n - #100960 (rustdoc: ayu code color selector more specific)\n - #100964 (Sync rustc_codegen_cranelift)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9e3e576cf00fad6255b93a7ff98f2b296ffaeb0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e3e576cf00fad6255b93a7ff98f2b296ffaeb0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9bc6359973482891699bbc5eecedaf34a60503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9bc6359973482891699bbc5eecedaf34a60503", "html_url": "https://github.com/rust-lang/rust/commit/9b9bc6359973482891699bbc5eecedaf34a60503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9bc6359973482891699bbc5eecedaf34a60503/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "html_url": "https://github.com/rust-lang/rust/commit/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1"}, {"sha": "f2878a656b944ceed6f4a98d7e255784266a3dc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2878a656b944ceed6f4a98d7e255784266a3dc0", "html_url": "https://github.com/rust-lang/rust/commit/f2878a656b944ceed6f4a98d7e255784266a3dc0"}], "stats": {"total": 4101, "additions": 2658, "deletions": 1443}, "files": [{"sha": "9464c87fc728b3e5c72c56eac2daf91987886913", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -4421,9 +4421,11 @@ dependencies = [\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "f9b4d76f28f8a6a03ab6352b722defa246301c5a", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -13,7 +13,7 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n-#![feature(label_break_value)]\n+#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(slice_internals)]"}, {"sha": "4ac96ec8b609c82dbfd98c0b8dc527e0741e8a53", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -647,14 +647,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n-            ast::ExprKind::Block(_, Some(label)) => {\n-                gate_feature_post!(\n-                    &self,\n-                    label_break_value,\n-                    label.ident.span,\n-                    \"labels on blocks are unstable\"\n-                );\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e)\n@@ -823,7 +815,6 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(box_patterns, \"box pattern syntax is experimental\");\n     gate_all!(exclusive_range_pattern, \"exclusive range pattern syntax is experimental\");\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n-    gate_all!(label_break_value, \"labels on blocks are unstable\");\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n     gate_all!(type_ascription, \"type ascription is experimental\");\n "}, {"sha": "732edd66196d7de4c3d8d18e0c944e05d279906c", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -22,4 +22,4 @@ task:\n     - # Reduce amount of benchmark runs as they are slow\n     - export COMPILE_RUNS=2\n     - export RUN_RUNS=2\n-    - ./test.sh\n+    - ./y.rs test"}, {"sha": "e8897e9ae81454a01145a9b4343f66cafdb00565", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -103,7 +103,7 @@ jobs:\n         # Enable extra checks\n         export CG_CLIF_ENABLE_VERIFIER=1\n \n-        ./test.sh\n+        ./y.rs test\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build\n@@ -162,14 +162,14 @@ jobs:\n       #name: Test\n       run: |\n         # Enable backtraces for easier debugging\n-        #export RUST_BACKTRACE=1\n+        #$Env:RUST_BACKTRACE=1\n \n         # Reduce amount of benchmark runs as they are slow\n-        #export COMPILE_RUNS=2\n-        #export RUN_RUNS=2\n+        #$Env:COMPILE_RUNS=2\n+        #$Env:RUN_RUNS=2\n \n         # Enable extra checks\n-        #export CG_CLIF_ENABLE_VERIFIER=1\n+        #$Env:CG_CLIF_ENABLE_VERIFIER=1\n \n         ./y.exe build\n "}, {"sha": "6fd3e4443de5c29a78797daa438342723ce3468b", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -8,6 +8,8 @@ perf.data.old\n *.string*\n /y.bin\n /y.bin.dSYM\n+/y.exe\n+/y.pdb\n /build\n /build_sysroot/sysroot_src\n /build_sysroot/compiler-builtins\n@@ -17,3 +19,4 @@ perf.data.old\n /regex\n /simple-raytracer\n /portable-simd\n+/abi-checker"}, {"sha": "edae7e471578a88a9ec482c52397ab5330ac4cda", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 92, "deletions": 55, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -50,18 +50,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"749d0d6022c9038dccf480bdde2a38d435937335bf2bb0f14e815d94517cdce8\"\n+checksum = \"93945adbccc8d731503d3038814a51e8317497c9e205411820348132fa01a358\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e94370cc7b37bf652ccd8bb8f09bd900997f7ccf97520edfc75554bb5c4abbea\"\n+checksum = \"2b482acc9d0d0d1ad3288a90a8150ee648be3dce8dc8c8669ff026f72debdc31\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -77,30 +77,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e0a3cea8fdab90e44018c5b9a1dfd460d8ee265ac354337150222a354628bdb6\"\n+checksum = \"f9ec188d71e663192ef9048f204e410a7283b609942efc9fcc77da6d496edbb8\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ac72f76f2698598951ab26d8c96eaa854810e693e7dd52523958b5909fde6b2\"\n+checksum = \"3ad794b1b1c2c7bd9f7b76cfe0f084eaf7753e55d56191c3f7d89e8fa4978b99\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09eaeacfcd2356fe0e66b295e8f9d59fdd1ac3ace53ba50de14d628ec902f72d\"\n+checksum = \"342da0d5056f4119d3c311c4aab2460ceb6ee6e127bb395b76dd2279a09ea7a5\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dba69c9980d5ffd62c18a2bde927855fcd7c8dc92f29feaf8636052662cbd99c\"\n+checksum = \"dfff792f775b07d4d9cfe9f1c767ce755c6cbadda1bbd6db18a1c75ff9f7376a\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -110,15 +110,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d2920dc1e05cac40304456ed3301fde2c09bd6a9b0210bcfa2f101398d628d5b\"\n+checksum = \"8d51089478849f2ac8ef60a8a2d5346c8d4abfec0e45ac5b24530ef9f9499e1e\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1c3c5ed067f2c81577e431f3039148a9c187b33cc79e0d1731fede27d801ec56\"\n+checksum = \"095936e41720f86004b4c57ce88e6a13af28646bb3a6fb4afbebd5ae90c50029\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -129,24 +129,24 @@ dependencies = [\n  \"log\",\n  \"region\",\n  \"target-lexicon\",\n- \"winapi\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eee6784303bf9af235237a4885f7417e09a35df896d38ea969a0081064b3ede4\"\n+checksum = \"704a1aea4723d97eafe0fb7af110f6f6868b1ac95f5380bbc9adb2a3b8cf97e8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f04dfa45f9b2a6f587c564d6b63388e00cd6589d2df6ea2758cf79e1a13285e6\"\n+checksum = \"885debe62f2078638d6585f54c9f05f5c2008f22ce5a2a9100ada785fc065dbd\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -155,9 +155,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0bf38b2c505db749276793116c0cb30bd096206c7810e471677a453134881881\"\n+checksum = \"aac1310cf1081ae8eca916c92cd163b977c77cab6e831fa812273c26ff921816\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -187,9 +187,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.6\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad\"\n+checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -198,43 +198,37 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.1\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n  \"indexmap\",\n ]\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.11.2\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n  \"ahash\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.12.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n-\n [[package]]\n name = \"indexmap\"\n version = \"1.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown 0.12.3\",\n+ \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.127\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n \n [[package]]\n name = \"libloading\"\n@@ -248,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"log\"\n-version = \"0.4.14\"\n+version = \"0.4.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n+checksum = \"abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -266,33 +260,33 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.1\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"object\"\n-version = \"0.28.4\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n  \"crc32fast\",\n- \"hashbrown 0.11.2\",\n+ \"hashbrown\",\n  \"indexmap\",\n  \"memchr\",\n ]\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.10.0\"\n+version = \"1.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n+checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.2.3\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a8d23b35d7177df3b9d31ed8a9ab4bf625c668be77a319d4f5efd4a5257701c\"\n+checksum = \"d43a209257d978ef079f3d446331d0f1794f5e0fc19b306a199983857833a779\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -340,15 +334,15 @@ checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.8.1\"\n+version = \"1.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc88c725d61fc6c3132893370cac4a0200e3fedf5da8331c570664b1987f5ca2\"\n+checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.3\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7fa7e55043acb85fca6b3c01485a2eeb6b69c5d21002e273c79e465f43b7ac1\"\n+checksum = \"c02424087780c9b71cc96799eaeddff35af2bc513278cda5c99fc1f5d026d3c1\"\n \n [[package]]\n name = \"version_check\"\n@@ -358,9 +352,9 @@ checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"wasi\"\n-version = \"0.10.2+wasi-snapshot-preview1\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"winapi\"\n@@ -383,3 +377,46 @@ name = \"winapi-x86_64-pc-windows-gnu\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+dependencies = [\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\""}, {"sha": "e7c3427485480119829d0322b76cb0feb217e5f8", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -8,15 +8,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.85.3\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.85.3\"\n-cranelift-module = \"0.85.3\"\n-cranelift-native = \"0.85.3\"\n-cranelift-jit = { version = \"0.85.3\", optional = true }\n-cranelift-object = \"0.85.3\"\n+cranelift-codegen = { version = \"0.87.0\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.87.0\"\n+cranelift-module = \"0.87.0\"\n+cranelift-native = \"0.87.0\"\n+cranelift-jit = { version = \"0.87.0\", optional = true }\n+cranelift-object = \"0.87.0\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.28.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\""}, {"sha": "1e84c7fa3657b37afeb26614a49896fab8846b40", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -52,9 +52,7 @@ configuration options.\n ## Not yet supported\n \n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n-    * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n-      `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n-      have to specify specific registers instead.\n+    * On UNIX there is support for invoking an external assembler for `global_asm!` and `asm!`.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n \n ## License"}, {"sha": "6c5043bb6f8e1e86cdde105d5607a4355581d5a4", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -56,9 +56,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.75\"\n+version = \"0.1.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c6e3183e88f659a862835db8f4b67dbeed3d93e44dd4927eef78edb1c149d784\"\n+checksum = \"4f873ce2bd3550b0b565f878b3d04ea8253f4259dc3d20223af2e1ba86f5ecca\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -69,9 +69,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a6fe28e0bf9357092740362502f5cc7955d8dc125ebda71dec72336c2e15c62e\"\n+checksum = \"203540e710bfadb90e5e29930baf5d10270cec1f43ab34f46f78b147b2de715a\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -80,9 +80,9 @@ dependencies = [\n \n [[package]]\n name = \"fortanix-sgx-abi\"\n-version = \"0.3.3\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c56c422ef86062869b2d57ae87270608dc5929969dd130a6e248979cf4fb6ca6\"\n+checksum = \"57cafc2274c10fab234f176b25903ce17e690fca7597090d50880e047a0389c5\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -123,9 +123,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.4\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7668753748e445859e4e373c3d41117235d9feed578392f5a3a73efdc751ca4a\"\n+checksum = \"897cd85af6387be149f55acf168e41be176a02de7872403aaab184afc2f327e6\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -135,9 +135,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.132\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "67dbd0a38a4fb4d44d0579e907bbc1a4c6bc9de0", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_checker.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,60 @@\n+use super::build_sysroot;\n+use super::config;\n+use super::utils::spawn_and_wait;\n+use build_system::SysrootKind;\n+use std::env;\n+use std::path::Path;\n+use std::process::Command;\n+\n+pub(crate) fn run(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_build_dir: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    if !config::get_bool(\"testsuite.abi-checker\") {\n+        eprintln!(\"[SKIP] abi-checker\");\n+        return;\n+    }\n+\n+    if host_triple != target_triple {\n+        eprintln!(\"[SKIP] abi-checker (cross-compilation not supported)\");\n+        return;\n+    }\n+\n+    eprintln!(\"Building sysroot for abi-checker\");\n+    build_sysroot::build_sysroot(\n+        channel,\n+        sysroot_kind,\n+        target_dir,\n+        cg_clif_build_dir,\n+        host_triple,\n+        target_triple,\n+    );\n+\n+    eprintln!(\"Running abi-checker\");\n+    let mut abi_checker_path = env::current_dir().unwrap();\n+    abi_checker_path.push(\"abi-checker\");\n+    env::set_current_dir(abi_checker_path.clone()).unwrap();\n+\n+    let build_dir = abi_checker_path.parent().unwrap().join(\"build\");\n+    let cg_clif_dylib_path = build_dir.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n+        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n+    );\n+\n+    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n+\n+    let mut cmd = Command::new(\"cargo\");\n+    cmd.arg(\"run\");\n+    cmd.arg(\"--target\");\n+    cmd.arg(target_triple);\n+    cmd.arg(\"--\");\n+    cmd.arg(\"--pairs\");\n+    cmd.args(pairs);\n+    cmd.arg(\"--add-rustc-codegen-backend\");\n+    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib_path.display()));\n+\n+    spawn_and_wait(cmd);\n+}"}, {"sha": "9e59b8199b4123076a960771b4f2132a86d3cd54", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -2,6 +2,8 @@ use std::env;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use super::utils::is_ci;\n+\n pub(crate) fn build_backend(\n     channel: &str,\n     host_triple: &str,\n@@ -14,7 +16,7 @@ pub(crate) fn build_backend(\n \n     let mut rustflags = env::var(\"RUSTFLAGS\").unwrap_or_default();\n \n-    if env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\") {\n+    if is_ci() {\n         // Deny warnings on CI\n         rustflags += \" -Dwarnings\";\n "}, {"sha": "7e205b0fd0b3b85dab07cb83a620a56fd256a233", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -2,18 +2,20 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n-use super::rustc_info::{get_file_name, get_rustc_version};\n+use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n use super::utils::{spawn_and_wait, try_hard_link};\n use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: PathBuf,\n+    cg_clif_build_dir: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n+    eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n+\n     if target_dir.exists() {\n         fs::remove_dir_all(target_dir).unwrap();\n     }\n@@ -35,11 +37,13 @@ pub(crate) fn build_sysroot(\n \n     // Build and copy rustc and cargo wrappers\n     for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n+        let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n+\n         let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n         build_cargo_wrapper_cmd\n             .arg(PathBuf::from(\"scripts\").join(format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(target_dir.join(wrapper))\n+            .arg(target_dir.join(wrapper_name))\n             .arg(\"-g\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }"}, {"sha": "c3706dc6f82039cfee03fe18fdb7ef7c3f8c36d6", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -2,11 +2,15 @@ use std::env;\n use std::path::PathBuf;\n use std::process;\n \n+use self::utils::is_ci;\n+\n+mod abi_checker;\n mod build_backend;\n mod build_sysroot;\n mod config;\n mod prepare;\n mod rustc_info;\n+mod tests;\n mod utils;\n \n fn usage() {\n@@ -15,6 +19,9 @@ fn usage() {\n     eprintln!(\n         \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n     );\n+    eprintln!(\n+        \"  ./y.rs test [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n+    );\n }\n \n macro_rules! arg_error {\n@@ -25,11 +32,13 @@ macro_rules! arg_error {\n     }};\n }\n \n+#[derive(PartialEq, Debug)]\n enum Command {\n     Build,\n+    Test,\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum SysrootKind {\n     None,\n     Clif,\n@@ -42,16 +51,22 @@ pub fn main() {\n     // The target dir is expected in the default location. Guard against the user changing it.\n     env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n \n+    if is_ci() {\n+        // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n+        env::set_var(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+    }\n+\n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n         Some(\"prepare\") => {\n             if args.next().is_some() {\n-                arg_error!(\"./x.rs prepare doesn't expect arguments\");\n+                arg_error!(\"./y.rs prepare doesn't expect arguments\");\n             }\n             prepare::prepare();\n             process::exit(0);\n         }\n         Some(\"build\") => Command::Build,\n+        Some(\"test\") => Command::Test,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n         Some(command) => arg_error!(\"Unknown command {}\", command),\n         None => {\n@@ -117,12 +132,35 @@ pub fn main() {\n \n     let cg_clif_build_dir =\n         build_backend::build_backend(channel, &host_triple, use_unstable_features);\n-    build_sysroot::build_sysroot(\n-        channel,\n-        sysroot_kind,\n-        &target_dir,\n-        cg_clif_build_dir,\n-        &host_triple,\n-        &target_triple,\n-    );\n+    match command {\n+        Command::Test => {\n+            tests::run_tests(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+\n+            abi_checker::run(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+        }\n+        Command::Build => {\n+            build_sysroot::build_sysroot(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+        }\n+    }\n }"}, {"sha": "d23b7f00dcf16da744be926925043d5716cad145", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -14,6 +14,14 @@ pub(crate) fn prepare() {\n     eprintln!(\"[INSTALL] hyperfine\");\n     Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n \n+    clone_repo_shallow_github(\n+        \"abi-checker\",\n+        \"Gankra\",\n+        \"abi-checker\",\n+        \"a2232d45f202846f5c02203c9f27355360f9a2ff\",\n+    );\n+    apply_patches(\"abi-checker\", Path::new(\"abi-checker\"));\n+\n     clone_repo_shallow_github(\n         \"rand\",\n         \"rust-random\",\n@@ -50,8 +58,7 @@ pub(crate) fn prepare() {\n     spawn_and_wait(build_cmd);\n     fs::copy(\n         Path::new(\"simple-raytracer/target/debug\").join(get_file_name(\"main\", \"bin\")),\n-        // FIXME use get_file_name here too once testing is migrated to rust\n-        \"simple-raytracer/raytracer_cg_llvm\",\n+        Path::new(\"simple-raytracer\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }"}, {"sha": "913b589afcc87f658510195969fd03aef5d683e2", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -63,3 +63,12 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n     assert!(file_name.contains(crate_name));\n     file_name\n }\n+\n+/// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n+/// underscores (`_`). This is specially made for the the rustc and cargo wrappers\n+/// which have a dash in the name, and that is not allowed in a crate name.\n+pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n+    let crate_name = crate_name.replace('-', \"_\");\n+    let wrapper_name = get_file_name(&crate_name, crate_type);\n+    wrapper_name.replace('_', \"-\")\n+}"}, {"sha": "e21397cece8b32e28d7d7d6c206d4dad07e79ca1", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,619 @@\n+use super::build_sysroot;\n+use super::config;\n+use super::rustc_info::get_wrapper_file_name;\n+use super::utils::{spawn_and_wait, spawn_and_wait_with_input};\n+use build_system::SysrootKind;\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+struct TestCase {\n+    config: &'static str,\n+    func: &'static dyn Fn(&TestRunner),\n+}\n+\n+impl TestCase {\n+    const fn new(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n+        Self { config, func }\n+    }\n+}\n+\n+const NO_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"build.mini_core\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mini_core.rs\",\n+            \"--crate-name\",\n+            \"mini_core\",\n+            \"--crate-type\",\n+            \"lib,dylib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"build.example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/example.rs\",\n+            \"--crate-type\",\n+            \"lib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n+        let mut jit_cmd = runner.rustc_command([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit\",\n+            \"-Cprefer-dynamic\",\n+            \"example/mini_core_hello_world.rs\",\n+            \"--cfg\",\n+            \"jit\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n+        spawn_and_wait(jit_cmd);\n+\n+        eprintln!(\"[JIT-lazy] mini_core_hello_world\");\n+        let mut jit_cmd = runner.rustc_command([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit-lazy\",\n+            \"-Cprefer-dynamic\",\n+            \"example/mini_core_hello_world.rs\",\n+            \"--cfg\",\n+            \"jit\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n+        spawn_and_wait(jit_cmd);\n+    }),\n+    TestCase::new(\"aot.mini_core_hello_world\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mini_core_hello_world.rs\",\n+            \"--crate-name\",\n+            \"mini_core_hello_world\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-g\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n+    }),\n+];\n+\n+const BASE_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"aot.arbitrary_self_types_pointers_and_wrappers\", &|runner| {\n+        runner.run_rustc([\n+            \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n+            \"--crate-name\",\n+            \"arbitrary_self_types_pointers_and_wrappers\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n+    }),\n+    TestCase::new(\"aot.issue_91827_extern_types\", &|runner| {\n+        runner.run_rustc([\n+            \"example/issue-91827-extern-types.rs\",\n+            \"--crate-name\",\n+            \"issue_91827_extern_types\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"issue_91827_extern_types\", []);\n+    }),\n+    TestCase::new(\"build.alloc_system\", &|runner| {\n+        runner.run_rustc([\n+            \"example/alloc_system.rs\",\n+            \"--crate-type\",\n+            \"lib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"aot.alloc_example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/alloc_example.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"alloc_example\", []);\n+    }),\n+    TestCase::new(\"jit.std_example\", &|runner| {\n+        runner.run_rustc([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit\",\n+            \"-Cprefer-dynamic\",\n+            \"example/std_example.rs\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+\n+        eprintln!(\"[JIT-lazy] std_example\");\n+        runner.run_rustc([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit-lazy\",\n+            \"-Cprefer-dynamic\",\n+            \"example/std_example.rs\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"aot.std_example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/std_example.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"std_example\", [\"arg\"]);\n+    }),\n+    TestCase::new(\"aot.dst_field_align\", &|runner| {\n+        runner.run_rustc([\n+            \"example/dst-field-align.rs\",\n+            \"--crate-name\",\n+            \"dst_field_align\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"dst_field_align\", []);\n+    }),\n+    TestCase::new(\"aot.subslice-patterns-const-eval\", &|runner| {\n+        runner.run_rustc([\n+            \"example/subslice-patterns-const-eval.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"subslice-patterns-const-eval\", []);\n+    }),\n+    TestCase::new(\"aot.track-caller-attribute\", &|runner| {\n+        runner.run_rustc([\n+            \"example/track-caller-attribute.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"track-caller-attribute\", []);\n+    }),\n+    TestCase::new(\"aot.float-minmax-pass\", &|runner| {\n+        runner.run_rustc([\n+            \"example/float-minmax-pass.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"float-minmax-pass\", []);\n+    }),\n+    TestCase::new(\"aot.mod_bench\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mod_bench.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"mod_bench\", []);\n+    }),\n+];\n+\n+const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"test.rust-random/rand\", &|runner| {\n+        runner.in_dir([\"rand\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                eprintln!(\"[TEST] rust-random/rand\");\n+                runner.run_cargo([\"test\", \"--workspace\"]);\n+            } else {\n+                eprintln!(\"[AOT] rust-random/rand\");\n+                runner.run_cargo([\n+                    \"build\",\n+                    \"--workspace\",\n+                    \"--target\",\n+                    &runner.target_triple,\n+                    \"--tests\",\n+                ]);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n+        runner.in_dir([\"simple-raytracer\"], |runner| {\n+            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string());\n+\n+            if runner.host_triple == runner.target_triple {\n+                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+                let mut bench_compile = Command::new(\"hyperfine\");\n+                bench_compile.arg(\"--runs\");\n+                bench_compile.arg(&run_runs);\n+                bench_compile.arg(\"--warmup\");\n+                bench_compile.arg(\"1\");\n+                bench_compile.arg(\"--prepare\");\n+                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"clean\"])));\n+\n+                if cfg!(windows) {\n+                    bench_compile.arg(\"cmd /C \\\"set RUSTFLAGS= && cargo build\\\"\");\n+                } else {\n+                    bench_compile.arg(\"RUSTFLAGS='' cargo build\");\n+                }\n+\n+                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"build\"])));\n+                spawn_and_wait(bench_compile);\n+\n+                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+                fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n+                    .unwrap();\n+\n+                let mut bench_run = Command::new(\"hyperfine\");\n+                bench_run.arg(\"--runs\");\n+                bench_run.arg(&run_runs);\n+                bench_run.arg(PathBuf::from(\"./raytracer_cg_llvm\"));\n+                bench_run.arg(PathBuf::from(\"./raytracer_cg_clif\"));\n+                spawn_and_wait(bench_run);\n+            } else {\n+                runner.run_cargo([\"clean\"]);\n+                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n+                eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n+                runner.run_cargo([\"build\", \"--target\", &runner.target_triple]);\n+                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.libcore\", &|runner| {\n+        runner.in_dir([\"build_sysroot\", \"sysroot_src\", \"library\", \"core\", \"tests\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                runner.run_cargo([\"test\"]);\n+            } else {\n+                eprintln!(\"Cross-Compiling: Not running tests\");\n+                runner.run_cargo([\"build\", \"--target\", &runner.target_triple, \"--tests\"]);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n+        runner.in_dir([\"regex\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            // newer aho_corasick versions throw a deprecation warning\n+            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+\n+            let mut build_cmd = runner.cargo_command([\n+                \"build\",\n+                \"--example\",\n+                \"shootout-regex-dna\",\n+                \"--target\",\n+                &runner.target_triple,\n+            ]);\n+            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+            spawn_and_wait(build_cmd);\n+\n+            if runner.host_triple == runner.target_triple {\n+                let mut run_cmd = runner.cargo_command([\n+                    \"run\",\n+                    \"--example\",\n+                    \"shootout-regex-dna\",\n+                    \"--target\",\n+                    &runner.target_triple,\n+                ]);\n+                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+\n+                let input =\n+                    fs::read_to_string(PathBuf::from(\"examples/regexdna-input.txt\")).unwrap();\n+                let expected_path = PathBuf::from(\"examples/regexdna-output.txt\");\n+                let expected = fs::read_to_string(&expected_path).unwrap();\n+\n+                let output = spawn_and_wait_with_input(run_cmd, input);\n+                // Make sure `[codegen mono items] start` doesn't poison the diff\n+                let output = output\n+                    .lines()\n+                    .filter(|line| !line.contains(\"codegen mono items\"))\n+                    .chain(Some(\"\")) // This just adds the trailing newline\n+                    .collect::<Vec<&str>>()\n+                    .join(\"\\r\\n\");\n+\n+                let output_matches = expected.lines().eq(output.lines());\n+                if !output_matches {\n+                    let res_path = PathBuf::from(\"res.txt\");\n+                    fs::write(&res_path, &output).unwrap();\n+\n+                    if cfg!(windows) {\n+                        println!(\"Output files don't match!\");\n+                        println!(\"Expected Output:\\n{}\", expected);\n+                        println!(\"Actual Output:\\n{}\", output);\n+                    } else {\n+                        let mut diff = Command::new(\"diff\");\n+                        diff.arg(\"-u\");\n+                        diff.arg(res_path);\n+                        diff.arg(expected_path);\n+                        spawn_and_wait(diff);\n+                    }\n+\n+                    std::process::exit(1);\n+                }\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.regex\", &|runner| {\n+        runner.in_dir([\"regex\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            // newer aho_corasick versions throw a deprecation warning\n+            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+\n+            if runner.host_triple == runner.target_triple {\n+                let mut run_cmd = runner.cargo_command([\n+                    \"test\",\n+                    \"--tests\",\n+                    \"--\",\n+                    \"--exclude-should-panic\",\n+                    \"--test-threads\",\n+                    \"1\",\n+                    \"-Zunstable-options\",\n+                    \"-q\",\n+                ]);\n+                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+                spawn_and_wait(run_cmd);\n+            } else {\n+                eprintln!(\"Cross-Compiling: Not running tests\");\n+                let mut build_cmd =\n+                    runner.cargo_command([\"build\", \"--tests\", \"--target\", &runner.target_triple]);\n+                build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+                spawn_and_wait(build_cmd);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.portable-simd\", &|runner| {\n+        runner.in_dir([\"portable-simd\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+            runner.run_cargo([\"build\", \"--all-targets\", \"--target\", &runner.target_triple]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                runner.run_cargo([\"test\", \"-q\"]);\n+            }\n+        });\n+    }),\n+];\n+\n+pub(crate) fn run_tests(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_build_dir: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    let runner = TestRunner::new(host_triple.to_string(), target_triple.to_string());\n+\n+    if config::get_bool(\"testsuite.no_sysroot\") {\n+        build_sysroot::build_sysroot(\n+            channel,\n+            SysrootKind::None,\n+            &target_dir,\n+            cg_clif_build_dir,\n+            &host_triple,\n+            &target_triple,\n+        );\n+\n+        let _ = fs::remove_dir_all(Path::new(\"target\").join(\"out\"));\n+        runner.run_testsuite(NO_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] no_sysroot tests\");\n+    }\n+\n+    let run_base_sysroot = config::get_bool(\"testsuite.base_sysroot\");\n+    let run_extended_sysroot = config::get_bool(\"testsuite.extended_sysroot\");\n+\n+    if run_base_sysroot || run_extended_sysroot {\n+        build_sysroot::build_sysroot(\n+            channel,\n+            sysroot_kind,\n+            &target_dir,\n+            cg_clif_build_dir,\n+            &host_triple,\n+            &target_triple,\n+        );\n+    }\n+\n+    if run_base_sysroot {\n+        runner.run_testsuite(BASE_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] base_sysroot tests\");\n+    }\n+\n+    if run_extended_sysroot {\n+        runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] extended_sysroot tests\");\n+    }\n+}\n+\n+struct TestRunner {\n+    root_dir: PathBuf,\n+    out_dir: PathBuf,\n+    jit_supported: bool,\n+    rust_flags: String,\n+    run_wrapper: Vec<String>,\n+    host_triple: String,\n+    target_triple: String,\n+}\n+\n+impl TestRunner {\n+    pub fn new(host_triple: String, target_triple: String) -> Self {\n+        let root_dir = env::current_dir().unwrap();\n+\n+        let mut out_dir = root_dir.clone();\n+        out_dir.push(\"target\");\n+        out_dir.push(\"out\");\n+\n+        let is_native = host_triple == target_triple;\n+        let jit_supported =\n+            target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n+\n+        let mut rust_flags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n+        let mut run_wrapper = Vec::new();\n+\n+        if !is_native {\n+            match target_triple.as_str() {\n+                \"aarch64-unknown-linux-gnu\" => {\n+                    // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+                    rust_flags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rust_flags);\n+                    run_wrapper = vec![\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\"];\n+                }\n+                \"x86_64-pc-windows-gnu\" => {\n+                    // We are cross-compiling for Windows. Run tests in wine.\n+                    run_wrapper = vec![\"wine\"];\n+                }\n+                _ => {\n+                    println!(\"Unknown non-native platform\");\n+                }\n+            }\n+        }\n+\n+        // FIXME fix `#[linkage = \"extern_weak\"]` without this\n+        if host_triple.contains(\"darwin\") {\n+            rust_flags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rust_flags);\n+        }\n+\n+        Self {\n+            root_dir,\n+            out_dir,\n+            jit_supported,\n+            rust_flags,\n+            run_wrapper: run_wrapper.iter().map(|s| s.to_string()).collect(),\n+            host_triple,\n+            target_triple,\n+        }\n+    }\n+\n+    pub fn run_testsuite(&self, tests: &[TestCase]) {\n+        for &TestCase { config, func } in tests {\n+            let (tag, testname) = config.split_once('.').unwrap();\n+            let tag = tag.to_uppercase();\n+            let is_jit_test = tag == \"JIT\";\n+\n+            if !config::get_bool(config) || (is_jit_test && !self.jit_supported) {\n+                eprintln!(\"[{tag}] {testname} (skipped)\");\n+                continue;\n+            } else {\n+                eprintln!(\"[{tag}] {testname}\");\n+            }\n+\n+            func(self);\n+        }\n+    }\n+\n+    fn in_dir<'a, I, F>(&self, dir: I, callback: F)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+        F: FnOnce(&TestRunner),\n+    {\n+        let current = env::current_dir().unwrap();\n+        let mut new = current.clone();\n+        for d in dir {\n+            new.push(d);\n+        }\n+\n+        env::set_current_dir(new).unwrap();\n+        callback(self);\n+        env::set_current_dir(current).unwrap();\n+    }\n+\n+    fn rustc_command<I, S>(&self, args: I) -> Command\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let mut rustc_clif = self.root_dir.clone();\n+        rustc_clif.push(\"build\");\n+        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+\n+        let mut cmd = Command::new(rustc_clif);\n+        cmd.args(self.rust_flags.split_whitespace());\n+        cmd.arg(\"-L\");\n+        cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n+        cmd.arg(\"--out-dir\");\n+        cmd.arg(format!(\"{}\", self.out_dir.display()));\n+        cmd.arg(\"-Cdebuginfo=2\");\n+        cmd.args(args);\n+        cmd\n+    }\n+\n+    fn run_rustc<I, S>(&self, args: I)\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        spawn_and_wait(self.rustc_command(args));\n+    }\n+\n+    fn run_out_command<'a, I>(&self, name: &str, args: I)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+    {\n+        let mut full_cmd = vec![];\n+\n+        // Prepend the RUN_WRAPPER's\n+        if !self.run_wrapper.is_empty() {\n+            full_cmd.extend(self.run_wrapper.iter().cloned());\n+        }\n+\n+        full_cmd.push({\n+            let mut out_path = self.out_dir.clone();\n+            out_path.push(name);\n+            out_path.to_str().unwrap().to_string()\n+        });\n+\n+        for arg in args.into_iter() {\n+            full_cmd.push(arg.to_string());\n+        }\n+\n+        let mut cmd_iter = full_cmd.into_iter();\n+        let first = cmd_iter.next().unwrap();\n+\n+        let mut cmd = Command::new(first);\n+        cmd.args(cmd_iter);\n+\n+        spawn_and_wait(cmd);\n+    }\n+\n+    fn cargo_command<I, S>(&self, args: I) -> Command\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let mut cargo_clif = self.root_dir.clone();\n+        cargo_clif.push(\"build\");\n+        cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+\n+        let mut cmd = Command::new(cargo_clif);\n+        cmd.args(args);\n+        cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n+        cmd\n+    }\n+\n+    fn run_cargo<'a, I>(&self, args: I)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+    {\n+        spawn_and_wait(self.cargo_command(args));\n+    }\n+}"}, {"sha": "bdf8f8ecd9970cb4b71976de33a953101047c808", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,6 +1,8 @@\n+use std::env;\n use std::fs;\n+use std::io::Write;\n use std::path::Path;\n-use std::process::{self, Command};\n+use std::process::{self, Command, Stdio};\n \n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n@@ -18,6 +20,27 @@ pub(crate) fn spawn_and_wait(mut cmd: Command) {\n     }\n }\n \n+#[track_caller]\n+pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> String {\n+    let mut child = cmd\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn child process\");\n+\n+    let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n+    std::thread::spawn(move || {\n+        stdin.write_all(input.as_bytes()).expect(\"Failed to write to stdin\");\n+    });\n+\n+    let output = child.wait_with_output().expect(\"Failed to read stdout\");\n+    if !output.status.success() {\n+        process::exit(1);\n+    }\n+\n+    String::from_utf8(output.stdout).unwrap()\n+}\n+\n pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n     for entry in fs::read_dir(from).unwrap() {\n         let entry = entry.unwrap();\n@@ -33,3 +56,7 @@ pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n         }\n     }\n }\n+\n+pub(crate) fn is_ci() -> bool {\n+    env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\")\n+}"}, {"sha": "62e52bd1958005655adbe4609fa3fbfe05c4b907", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -3,4 +3,4 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old} y.bin\n-rm -rf rand/ regex/ simple-raytracer/ portable-simd/\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/"}, {"sha": "2264d301d592003b27f679becdeb32e90d583023", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -15,3 +15,38 @@\n # This option can be changed while the build system is already running for as long as sysroot\n # building hasn't started yet.\n #keep_sysroot\n+\n+\n+# Testsuite\n+#\n+# Each test suite item has a corresponding key here. The default is to run all tests.\n+# Comment any of these lines to skip individual tests.\n+\n+testsuite.no_sysroot\n+build.mini_core\n+build.example\n+jit.mini_core_hello_world\n+aot.mini_core_hello_world\n+\n+testsuite.base_sysroot\n+aot.arbitrary_self_types_pointers_and_wrappers\n+aot.issue_91827_extern_types\n+build.alloc_system\n+aot.alloc_example\n+jit.std_example\n+aot.std_example\n+aot.dst_field_align\n+aot.subslice-patterns-const-eval\n+aot.track-caller-attribute\n+aot.float-minmax-pass\n+aot.mod_bench\n+\n+testsuite.extended_sysroot\n+test.rust-random/rand\n+bench.simple-raytracer\n+test.libcore\n+test.regex-shootout-regex-dna\n+test.regex\n+test.portable-simd\n+\n+testsuite.abi-checker"}, {"sha": "42f8aa50ba1a99d73f84d9de07eb550d1c778637", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -535,7 +535,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, alloc: ()) {\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n     libc::free(ptr.pointer.0 as *mut u8);\n }\n \n@@ -575,11 +575,19 @@ pub mod intrinsics {\n }\n \n pub mod libc {\n+    // With the new Universal CRT, msvc has switched to all the printf functions being inline wrapper\n+    // functions. legacy_stdio_definitions.lib which provides the printf wrapper functions as normal\n+    // symbols to link against.\n+    #[cfg_attr(unix, link(name = \"c\"))]\n+    #[cfg_attr(target_env=\"msvc\", link(name=\"legacy_stdio_definitions\"))]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+\n     #[cfg_attr(unix, link(name = \"c\"))]\n     #[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n     extern \"C\" {\n         pub fn puts(s: *const i8) -> i32;\n-        pub fn printf(format: *const i8, ...) -> i32;\n         pub fn malloc(size: usize) -> *mut u8;\n         pub fn free(ptr: *mut u8);\n         pub fn memcpy(dst: *mut u8, src: *const u8, size: usize);"}, {"sha": "e83be3a3df5c4f410f470099f1d623df22a2c76b", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -139,7 +139,7 @@ pub struct bool_11 {\n     field10: bool,\n }\n \n-extern \"C\" fn bool_struct_in_11(arg0: bool_11) {}\n+extern \"C\" fn bool_struct_in_11(_arg0: bool_11) {}\n \n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n@@ -321,7 +321,7 @@ fn main() {\n     #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n-    #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+    #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n     unsafe {\n         global_asm_test();\n     }\n@@ -343,7 +343,7 @@ fn main() {\n }\n }\n \n-#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n extern \"C\" {\n     fn global_asm_test();\n }\n@@ -358,6 +358,16 @@ global_asm! {\n     \"\n }\n \n+#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"darwin\"))]\n+global_asm! {\n+    \"\n+    .global _global_asm_test\n+    _global_asm_test:\n+    // comment that would normally be removed by LLVM\n+    ret\n+    \"\n+}\n+\n #[repr(C)]\n enum c_void {\n     _1,\n@@ -375,6 +385,7 @@ struct pthread_attr_t {\n }\n \n #[link(name = \"pthread\")]\n+#[cfg(unix)]\n extern \"C\" {\n     fn pthread_attr_init(attr: *mut pthread_attr_t) -> c_int;\n \n@@ -391,6 +402,91 @@ extern \"C\" {\n     ) -> c_int;\n }\n \n+type DWORD = u32;\n+type LPDWORD = *mut u32;\n+\n+type LPVOID = *mut c_void;\n+type HANDLE = *mut c_void;\n+\n+#[link(name = \"msvcrt\")]\n+#[cfg(windows)]\n+extern \"C\" {\n+    fn WaitForSingleObject(\n+        hHandle: LPVOID,\n+        dwMilliseconds: DWORD\n+    ) -> DWORD;\n+\n+    fn CreateThread(\n+        lpThreadAttributes: LPVOID, // Technically LPSECURITY_ATTRIBUTES, but we don't use it anyway\n+        dwStackSize: usize,\n+        lpStartAddress: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n+        lpParameter: LPVOID,\n+        dwCreationFlags: DWORD,\n+        lpThreadId: LPDWORD\n+    ) -> HANDLE;\n+}\n+\n+struct Thread {\n+    #[cfg(windows)]\n+    handle: HANDLE,\n+    #[cfg(unix)]\n+    handle: pthread_t,\n+}\n+\n+impl Thread {\n+    unsafe fn create(f: extern \"C\" fn(_: *mut c_void) -> *mut c_void) -> Self {\n+        #[cfg(unix)]\n+        {\n+            let mut attr: pthread_attr_t = zeroed();\n+            let mut thread: pthread_t = 0;\n+\n+            if pthread_attr_init(&mut attr) != 0 {\n+                assert!(false);\n+            }\n+\n+            if pthread_create(&mut thread, &attr, f, 0 as *mut c_void) != 0 {\n+                assert!(false);\n+            }\n+\n+            Thread {\n+                handle: thread,\n+            }\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            let handle = CreateThread(0 as *mut c_void, 0, f, 0 as *mut c_void, 0, 0 as *mut u32);\n+\n+            if (handle as u64) == 0 {\n+                assert!(false);\n+            }\n+\n+            Thread {\n+                handle,\n+            }\n+        }\n+    }\n+\n+\n+    unsafe fn join(self) {\n+        #[cfg(unix)]\n+        {\n+            let mut res = 0 as *mut c_void;\n+            pthread_join(self.handle, &mut res);\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            // The INFINITE macro is used to signal operations that do not timeout.\n+            let infinite = 0xffffffff;\n+            assert!(WaitForSingleObject(self.handle, infinite) == 0);\n+        }\n+    }\n+}\n+\n+\n+\n+\n #[thread_local]\n #[cfg(not(jit))]\n static mut TLS: u8 = 42;\n@@ -404,21 +500,10 @@ extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n #[cfg(not(jit))]\n fn test_tls() {\n     unsafe {\n-        let mut attr: pthread_attr_t = zeroed();\n-        let mut thread: pthread_t = 0;\n-\n         assert_eq!(TLS, 42);\n \n-        if pthread_attr_init(&mut attr) != 0 {\n-            assert!(false);\n-        }\n-\n-        if pthread_create(&mut thread, &attr, mutate_tls, 0 as *mut c_void) != 0 {\n-            assert!(false);\n-        }\n-\n-        let mut res = 0 as *mut c_void;\n-        pthread_join(thread, &mut res);\n+        let thread = Thread::create(mutate_tls);\n+        thread.join();\n \n         // TLS of main thread must not have been changed by the other thread.\n         assert_eq!(TLS, 42);"}, {"sha": "526366a7598760b95bb6d107ca3dbf20a8f0f871", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-checker-Disable-failing-tests.patch", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,36 @@\n+From 1a315ba225577dbbd1f449d9609f16f984f68708 Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonso360@users.noreply.github.com>\n+Date: Fri, 12 Aug 2022 22:51:58 +0000\n+Subject: [PATCH] Disable abi-checker tests\n+\n+---\n+ src/report.rs | 14 ++++++++++++++\n+ 1 file changed, 14 insertions(+)\n+\n+diff --git a/src/report.rs b/src/report.rs\n+index 7346f5e..8347762 100644\n+--- a/src/report.rs\n++++ b/src/report.rs\n+@@ -45,6 +45,20 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n+     //\n+     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n+\n++    // Currently MSVC has some broken ABI issues. Furthermore, they cause\n++    // a STATUS_ACCESS_VIOLATION, so we can't even run them. Ensure that they compile and link.\n++    if cfg!(windows) && (test.test_name == \"bool\" || test.test_name == \"ui128\") {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n++    // structs is broken in the current release of cranelift for aarch64.\n++    // It has been fixed for cranelift 0.88: https://github.com/bytecodealliance/wasmtime/pull/4634\n++    if cfg!(target_arch = \"aarch64\") && test.test_name == \"structs\" {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n+     // END OF VENDOR RESERVED AREA\n+     //\n+     //\n+--\n+2.34.1"}, {"sha": "f3cd7ee77e26e34586ac8cc146d0791f960c4520", "filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -46,5 +46,17 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 13b12db..96fe4b9 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -185,6 +185,7 @@ fn ptr_bitops() {\n+ }\n+ \n+ #[test]\n++#[cfg_attr(target_arch = \"s390x\", ignore)] // s390x backend doesn't support stack alignment >8 bytes\n+ #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+ fn ptr_bitops_tagging() {\n+     #[repr(align(16))]\n -- \n 2.21.0 (Apple Git-122)"}, {"sha": "14f2746ecb19f0f342a286bf752732d678a94414", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-07-25\"\n+channel = \"nightly-2022-08-24\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "9b5ffa4096049c04b9b2b509e9ec80107a7e1a92", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "patch": "@@ -1,203 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -e\n-\n-export CG_CLIF_DISPLAY_CG_TIME=1\n-export CG_CLIF_DISABLE_INCR_CACHE=1\n-\n-export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n-export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}\n-\n-export RUN_WRAPPER=''\n-\n-case \"$TARGET_TRIPLE\" in\n-   x86_64*)\n-      export JIT_SUPPORTED=1\n-      ;;\n-   *)\n-      export JIT_SUPPORTED=0\n-      ;;\n-esac\n-\n-if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n-   export JIT_SUPPORTED=0\n-   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n-      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-      export RUSTFLAGS='-Clinker=aarch64-linux-gnu-gcc '$RUSTFLAGS\n-      export RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n-   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n-      # We are cross-compiling for Windows. Run tests in wine.\n-      export RUN_WRAPPER='wine'\n-   else\n-      echo \"Unknown non-native platform\"\n-   fi\n-fi\n-\n-# FIXME fix `#[linkage = \"extern_weak\"]` without this\n-if [[ \"$(uname)\" == 'Darwin' ]]; then\n-   export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n-fi\n-\n-MY_RUSTC=\"$(pwd)/build/rustc-clif $RUSTFLAGS -L crate=target/out --out-dir target/out -Cdebuginfo=2\"\n-\n-function no_sysroot_tests() {\n-    echo \"[BUILD] mini_core\"\n-    $MY_RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target \"$TARGET_TRIPLE\"\n-\n-    echo \"[BUILD] example\"\n-    $MY_RUSTC example/example.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n-\n-    if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n-        echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n-\n-        echo \"[JIT-lazy] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n-    else\n-        echo \"[JIT] mini_core_hello_world (skipped)\"\n-    fi\n-\n-    echo \"[AOT] mini_core_hello_world\"\n-    $MY_RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n-    # (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n-}\n-\n-function base_sysroot_tests() {\n-    echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n-    $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n-\n-    echo \"[AOT] issue_91827_extern_types\"\n-    $MY_RUSTC example/issue-91827-extern-types.rs --crate-name issue_91827_extern_types --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/issue_91827_extern_types\n-\n-    echo \"[BUILD] alloc_system\"\n-    $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n-\n-    echo \"[AOT] alloc_example\"\n-    $MY_RUSTC example/alloc_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/alloc_example\n-\n-    if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n-        echo \"[JIT] std_example\"\n-        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n-\n-        echo \"[JIT-lazy] std_example\"\n-        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n-    else\n-        echo \"[JIT] std_example (skipped)\"\n-    fi\n-\n-    echo \"[AOT] std_example\"\n-    $MY_RUSTC example/std_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/std_example arg\n-\n-    echo \"[AOT] dst_field_align\"\n-    $MY_RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/dst_field_align\n-\n-    echo \"[AOT] subslice-patterns-const-eval\"\n-    $MY_RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n-\n-    echo \"[AOT] track-caller-attribute\"\n-    $MY_RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/track-caller-attribute\n-\n-    echo \"[AOT] float-minmax-pass\"\n-    $MY_RUSTC example/float-minmax-pass.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/float-minmax-pass\n-\n-    echo \"[AOT] mod_bench\"\n-    $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/mod_bench\n-}\n-\n-function extended_sysroot_tests() {\n-    pushd rand\n-    ../build/cargo-clif clean\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[TEST] rust-random/rand\"\n-        ../build/cargo-clif test --workspace\n-    else\n-        echo \"[AOT] rust-random/rand\"\n-        ../build/cargo-clif build --workspace --target $TARGET_TRIPLE --tests\n-    fi\n-    popd\n-\n-    pushd simple-raytracer\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-        hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"../build/cargo-clif clean\" \\\n-        \"RUSTFLAGS='' cargo build\" \\\n-        \"../build/cargo-clif build\"\n-\n-        echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-        cp ./target/debug/main ./raytracer_cg_clif\n-        hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_clif\n-    else\n-        ../build/cargo-clif clean\n-        echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n-        echo \"[COMPILE] ebobby/simple-raytracer\"\n-        ../build/cargo-clif build --target $TARGET_TRIPLE\n-        echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n-    fi\n-    popd\n-\n-    pushd build_sysroot/sysroot_src/library/core/tests\n-    echo \"[TEST] libcore\"\n-    ../../../../../build/cargo-clif clean\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        ../../../../../build/cargo-clif test\n-    else\n-        ../../../../../build/cargo-clif build --target $TARGET_TRIPLE --tests\n-    fi\n-    popd\n-\n-    pushd regex\n-    echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-    ../build/cargo-clif clean\n-    export RUSTFLAGS=\"$RUSTFLAGS --cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n-    # Make sure `[codegen mono items] start` doesn't poison the diff\n-    ../build/cargo-clif build --example shootout-regex-dna --target $TARGET_TRIPLE\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        cat examples/regexdna-input.txt \\\n-            | ../build/cargo-clif run --example shootout-regex-dna --target $TARGET_TRIPLE \\\n-            | grep -v \"Spawned thread\" > res.txt\n-        diff -u res.txt examples/regexdna-output.txt\n-    fi\n-\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[TEST] rust-lang/regex tests\"\n-        ../build/cargo-clif test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n-    else\n-        echo \"[AOT] rust-lang/regex tests\"\n-        ../build/cargo-clif build --tests --target $TARGET_TRIPLE\n-    fi\n-    popd\n-\n-    pushd portable-simd\n-    echo \"[TEST] rust-lang/portable-simd\"\n-    ../build/cargo-clif clean\n-    ../build/cargo-clif build --all-targets --target $TARGET_TRIPLE\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        ../build/cargo-clif test -q\n-    fi\n-    popd\n-}\n-\n-case \"$1\" in\n-    \"no_sysroot\")\n-        no_sysroot_tests\n-        ;;\n-    \"base_sysroot\")\n-        base_sysroot_tests\n-        ;;\n-    \"extended_sysroot\")\n-        extended_sysroot_tests\n-        ;;\n-    *)\n-        echo \"unknown test suite\"\n-        ;;\n-esac"}, {"sha": "f4ad76b3bab3c77edeb007f2c8b8c6dd9ef1e193", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -23,7 +23,7 @@ fn reg_to_abi_param(reg: Reg) -> AbiParam {\n         (RegKind::Integer, 9..=16) => types::I128,\n         (RegKind::Float, 4) => types::F32,\n         (RegKind::Float, 8) => types::F64,\n-        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        (RegKind::Vector, size) => types::I8.by(u32::try_from(size).unwrap()).unwrap(),\n         _ => unreachable!(\"{:?}\", reg),\n     };\n     AbiParam::new(clif_ty)\n@@ -184,7 +184,7 @@ pub(super) fn from_casted_value<'tcx>(\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n-    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+    let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n         // specify stack slot alignment.\n@@ -193,7 +193,7 @@ pub(super) fn from_casted_value<'tcx>(\n         // larger alignment than the integer.\n         size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,\n     });\n-    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let ptr = Pointer::stack_slot(stack_slot);\n     let mut offset = 0;\n     let mut block_params_iter = block_params.iter().copied();\n     for param in abi_params {"}, {"sha": "44c34d6c8cb79928ecf5aacac453df0f292bed82", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 109, "deletions": 118, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -6,21 +6,43 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n-use indexmap::IndexSet;\n-\n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n use crate::pretty_clif::CommentWriter;\n \n-pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+pub(crate) struct CodegenedFunction {\n+    symbol_name: String,\n+    func_id: FuncId,\n+    func: Function,\n+    clif_comments: CommentWriter,\n+    func_debug_cx: Option<FunctionDebugContext>,\n+}\n+\n+#[cfg_attr(not(feature = \"jit\"), allow(dead_code))]\n+pub(crate) fn codegen_and_compile_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) {\n-    let tcx = cx.tcx;\n-\n     let _inst_guard =\n         crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n+\n+    let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n+    let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n+\n+    compile_fn(cx, cached_context, module, codegened_func);\n+}\n+\n+pub(crate) fn codegen_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_func: Function,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) -> CodegenedFunction {\n     debug_assert!(!instance.substs.needs_infer());\n \n     let mir = tcx.instance_mir(instance.def);\n@@ -34,15 +56,14 @@ pub(crate) fn codegen_fn<'tcx>(\n     });\n \n     // Declare function\n-    let symbol_name = tcx.symbol_name(instance);\n+    let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), instance);\n-    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n-\n-    cx.cached_context.clear();\n+    let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n     // Make the FunctionBuilder\n     let mut func_ctx = FunctionBuilderContext::new();\n-    let mut func = std::mem::replace(&mut cx.cached_context.func, Function::new());\n+    let mut func = cached_func;\n+    func.clear();\n     func.name = ExternalName::user(0, func_id.as_u32());\n     func.signature = sig;\n     func.collect_debug_info();\n@@ -59,13 +80,20 @@ pub(crate) fn codegen_fn<'tcx>(\n     let pointer_type = target_config.pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n+    let func_debug_cx = if let Some(debug_context) = &mut cx.debug_context {\n+        Some(debug_context.define_function(tcx, &symbol_name, mir.span))\n+    } else {\n+        None\n+    };\n+\n     let mut fx = FunctionCx {\n         cx,\n         module,\n         tcx,\n         target_config,\n         pointer_type,\n         constants_cx: ConstantCx::new(),\n+        func_debug_cx,\n \n         instance,\n         symbol_name,\n@@ -78,81 +106,48 @@ pub(crate) fn codegen_fn<'tcx>(\n         caller_location: None, // set by `codegen_fn_prelude`\n \n         clif_comments,\n-        source_info_set: indexmap::IndexSet::new(),\n+        last_source_file: None,\n         next_ssa_var: 0,\n     };\n \n-    let arg_uninhabited = fx\n-        .mir\n-        .args_iter()\n-        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n-\n-    if !crate::constant::check_constants(&mut fx) {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n-    } else if arg_uninhabited {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-    } else {\n-        tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess\n-                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n-            codegen_fn_content(&mut fx);\n-        });\n-    }\n+    tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n-    let instance = fx.instance;\n+    let symbol_name = fx.symbol_name;\n     let clif_comments = fx.clif_comments;\n-    let source_info_set = fx.source_info_set;\n-    let local_map = fx.local_map;\n+    let func_debug_cx = fx.func_debug_cx;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"unopt\",\n-        module.isa(),\n-        instance,\n-        &func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        crate::pretty_clif::write_clif_file(\n+            tcx.output_filenames(()),\n+            &symbol_name,\n+            \"unopt\",\n+            module.isa(),\n+            &func,\n+            &clif_comments,\n+        );\n+    }\n \n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    compile_fn(\n-        cx,\n-        module,\n-        instance,\n-        symbol_name.name,\n-        func_id,\n-        func,\n-        clif_comments,\n-        source_info_set,\n-        local_map,\n-    );\n+    CodegenedFunction { symbol_name, func_id, func, clif_comments, func_debug_cx }\n }\n \n-fn compile_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+pub(crate) fn compile_fn(\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n-    instance: Instance<'tcx>,\n-    symbol_name: &str,\n-    func_id: FuncId,\n-    func: Function,\n-    mut clif_comments: CommentWriter,\n-    source_info_set: IndexSet<SourceInfo>,\n-    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+    codegened_func: CodegenedFunction,\n ) {\n-    let tcx = cx.tcx;\n+    let clif_comments = codegened_func.clif_comments;\n \n     // Store function in context\n-    let context = &mut cx.cached_context;\n+    let context = cached_context;\n     context.clear();\n-    context.func = func;\n+    context.func = codegened_func.func;\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n@@ -164,17 +159,6 @@ fn compile_fn<'tcx>(\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n-    // Perform rust specific optimizations\n-    tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(\n-            tcx,\n-            module.isa(),\n-            instance,\n-            context,\n-            &mut clif_comments,\n-        );\n-    });\n-\n     #[cfg(any())] // This is never true\n     let _clif_guard = {\n         use std::fmt::Write;\n@@ -203,46 +187,44 @@ fn compile_fn<'tcx>(\n     };\n \n     // Define function\n-    tcx.sess.time(\"define function\", || {\n-        context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module.define_function(func_id, context).unwrap();\n+    cx.profiler.verbose_generic_activity(\"define function\").run(|| {\n+        context.want_disasm = cx.should_write_ir;\n+        module.define_function(codegened_func.func_id, context).unwrap();\n     });\n \n-    // Write optimized function to file for debugging\n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"opt\",\n-        module.isa(),\n-        instance,\n-        &context.func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        // Write optimized function to file for debugging\n+        crate::pretty_clif::write_clif_file(\n+            &cx.output_filenames,\n+            &codegened_func.symbol_name,\n+            \"opt\",\n+            module.isa(),\n+            &context.func,\n+            &clif_comments,\n+        );\n \n-    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n-        crate::pretty_clif::write_ir_file(\n-            tcx,\n-            || format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-            |file| file.write_all(disasm.as_bytes()),\n-        )\n+        if let Some(disasm) = &context.compiled_code().unwrap().disasm {\n+            crate::pretty_clif::write_ir_file(\n+                &cx.output_filenames,\n+                &format!(\"{}.vcode\", codegened_func.symbol_name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n     }\n \n     // Define debuginfo for function\n     let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n-    tcx.sess.time(\"generate debug info\", || {\n+    cx.profiler.verbose_generic_activity(\"generate debug info\").run(|| {\n         if let Some(debug_context) = debug_context {\n-            debug_context.define_function(\n-                instance,\n-                func_id,\n-                symbol_name,\n-                isa,\n+            codegened_func.func_debug_cx.unwrap().finalize(\n+                debug_context,\n+                codegened_func.func_id,\n                 context,\n-                &source_info_set,\n-                local_map,\n             );\n         }\n-        unwind_context.add_function(func_id, &context, isa);\n+        unwind_context.add_function(codegened_func.func_id, &context, isa);\n     });\n }\n \n@@ -268,7 +250,27 @@ pub(crate) fn verify_func(\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n+fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n+    if !crate::constant::check_constants(fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        // compilation should have been aborted\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+    if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+    fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n+\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n@@ -457,17 +459,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     template,\n                     operands,\n                     *options,\n+                    *destination,\n                 );\n-\n-                match *destination {\n-                    Some(destination) => {\n-                        let destination_block = fx.get_block(destination);\n-                        fx.bcx.ins().jump(destination_block, &[]);\n-                    }\n-                    None => {\n-                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-                    }\n-                }\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 // FIXME implement unwinding\n@@ -711,9 +704,7 @@ fn codegen_stmt<'tcx>(\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);\n-                    let discr =\n-                        crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n-                    lval.write_cvalue(fx, discr);\n+                    crate::discriminant::codegen_get_discriminant(fx, lval, value, dest_layout);\n                 }\n                 Rvalue::Repeat(ref operand, times) => {\n                     let operand = codegen_operand(fx, operand);"}, {"sha": "589594465783e1611c688cd17f5c82325ae9576f", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,14 +1,18 @@\n use cranelift_codegen::isa::TargetFrontendConfig;\n+use gimli::write::FileId;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n-use rustc_middle::ty::SymbolName;\n+use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -74,7 +78,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n                 _ => unreachable!(),\n             };\n \n-            match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+            match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n                 // Cranelift currently only implements icmp for 128bit vectors.\n                 Some(vector_ty) if vector_ty.bits() == 128 => vector_ty,\n                 _ => return None,\n@@ -232,15 +236,16 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n }\n \n pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) cx: &'clif mut crate::CodegenCx,\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) target_config: TargetFrontendConfig, // Cached from module\n     pub(crate) pointer_type: Type,                  // Cached from module\n     pub(crate) constants_cx: ConstantCx,\n+    pub(crate) func_debug_cx: Option<FunctionDebugContext>,\n \n     pub(crate) instance: Instance<'tcx>,\n-    pub(crate) symbol_name: SymbolName<'tcx>,\n+    pub(crate) symbol_name: String,\n     pub(crate) mir: &'tcx Body<'tcx>,\n     pub(crate) fn_abi: Option<&'tcx FnAbi<'tcx, Ty<'tcx>>>,\n \n@@ -252,7 +257,11 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n-    pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n+\n+    /// Last accessed source file and it's debuginfo file id.\n+    ///\n+    /// For optimization purposes only\n+    pub(crate) last_source_file: Option<(Lrc<SourceFile>, FileId)>,\n \n     /// This should only be accessed by `CPlace::new_var`.\n     pub(crate) next_ssa_var: u32,\n@@ -336,8 +345,31 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n-        let (index, _) = self.source_info_set.insert_full(source_info);\n-        self.bcx.set_srcloc(SourceLoc::new(index as u32));\n+        if let Some(debug_context) = &mut self.cx.debug_context {\n+            let (file, line, column) =\n+                DebugContext::get_span_loc(self.tcx, self.mir.span, source_info.span);\n+\n+            // add_source_file is very slow.\n+            // Optimize for the common case of the current file not being changed.\n+            let mut cached_file_id = None;\n+            if let Some((ref last_source_file, last_file_id)) = self.last_source_file {\n+                // If the allocations are not equal, the files may still be equal, but that\n+                // doesn't matter, as this is just an optimization.\n+                if rustc_data_structures::sync::Lrc::ptr_eq(last_source_file, &file) {\n+                    cached_file_id = Some(last_file_id);\n+                }\n+            }\n+\n+            let file_id = if let Some(file_id) = cached_file_id {\n+                file_id\n+            } else {\n+                debug_context.add_source_file(&file)\n+            };\n+\n+            let source_loc =\n+                self.func_debug_cx.as_mut().unwrap().add_dbg_loc(file_id, line, column);\n+            self.bcx.set_srcloc(source_loc);\n+        }\n     }\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa"}, {"sha": "dfde97920461e21de9d6cfcc40581d5eda55234e", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,168 @@\n+use std::sync::{Arc, Condvar, Mutex};\n+\n+use rustc_session::Session;\n+\n+use jobserver::HelperThread;\n+\n+// FIXME don't panic when a worker thread panics\n+\n+pub(super) struct ConcurrencyLimiter {\n+    helper_thread: Option<HelperThread>,\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl ConcurrencyLimiter {\n+    pub(super) fn new(sess: &Session, pending_jobs: usize) -> Self {\n+        let state = Arc::new(Mutex::new(state::ConcurrencyLimiterState::new(pending_jobs)));\n+        let available_token_condvar = Arc::new(Condvar::new());\n+\n+        let state_helper = state.clone();\n+        let available_token_condvar_helper = available_token_condvar.clone();\n+        let helper_thread = sess\n+            .jobserver\n+            .clone()\n+            .into_helper_thread(move |token| {\n+                let mut state = state_helper.lock().unwrap();\n+                state.add_new_token(token.unwrap());\n+                available_token_condvar_helper.notify_one();\n+            })\n+            .unwrap();\n+        ConcurrencyLimiter {\n+            helper_thread: Some(helper_thread),\n+            state,\n+            available_token_condvar: Arc::new(Condvar::new()),\n+        }\n+    }\n+\n+    pub(super) fn acquire(&mut self) -> ConcurrencyLimiterToken {\n+        let mut state = self.state.lock().unwrap();\n+        loop {\n+            state.assert_invariants();\n+\n+            if state.try_start_job() {\n+                return ConcurrencyLimiterToken {\n+                    state: self.state.clone(),\n+                    available_token_condvar: self.available_token_condvar.clone(),\n+                };\n+            }\n+\n+            self.helper_thread.as_mut().unwrap().request_token();\n+            state = self.available_token_condvar.wait(state).unwrap();\n+        }\n+    }\n+\n+    pub(super) fn job_already_done(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_already_done();\n+    }\n+}\n+\n+impl Drop for ConcurrencyLimiter {\n+    fn drop(&mut self) {\n+        //\n+        self.helper_thread.take();\n+\n+        // Assert that all jobs have finished\n+        let state = Mutex::get_mut(Arc::get_mut(&mut self.state).unwrap()).unwrap();\n+        state.assert_done();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) struct ConcurrencyLimiterToken {\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl Drop for ConcurrencyLimiterToken {\n+    fn drop(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_finished();\n+        self.available_token_condvar.notify_one();\n+    }\n+}\n+\n+mod state {\n+    use jobserver::Acquired;\n+\n+    #[derive(Debug)]\n+    pub(super) struct ConcurrencyLimiterState {\n+        pending_jobs: usize,\n+        active_jobs: usize,\n+\n+        // None is used to represent the implicit token, Some to represent explicit tokens\n+        tokens: Vec<Option<Acquired>>,\n+    }\n+\n+    impl ConcurrencyLimiterState {\n+        pub(super) fn new(pending_jobs: usize) -> Self {\n+            ConcurrencyLimiterState { pending_jobs, active_jobs: 0, tokens: vec![None] }\n+        }\n+\n+        pub(super) fn assert_invariants(&self) {\n+            // There must be no excess active jobs\n+            assert!(self.active_jobs <= self.pending_jobs);\n+\n+            // There may not be more active jobs than there are tokens\n+            assert!(self.active_jobs <= self.tokens.len());\n+        }\n+\n+        pub(super) fn assert_done(&self) {\n+            assert_eq!(self.pending_jobs, 0);\n+            assert_eq!(self.active_jobs, 0);\n+        }\n+\n+        pub(super) fn add_new_token(&mut self, token: Acquired) {\n+            self.tokens.push(Some(token));\n+            self.drop_excess_capacity();\n+        }\n+\n+        pub(super) fn try_start_job(&mut self) -> bool {\n+            if self.active_jobs < self.tokens.len() {\n+                // Using existing token\n+                self.job_started();\n+                return true;\n+            }\n+\n+            false\n+        }\n+\n+        pub(super) fn job_started(&mut self) {\n+            self.assert_invariants();\n+            self.active_jobs += 1;\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_finished(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.active_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_already_done(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        fn drop_excess_capacity(&mut self) {\n+            self.assert_invariants();\n+\n+            // Drop all tokens that can never be used anymore\n+            self.tokens.truncate(std::cmp::max(self.pending_jobs, 1));\n+\n+            // Keep some excess tokens to satisfy requests faster\n+            const MAX_EXTRA_CAPACITY: usize = 2;\n+            self.tokens.truncate(std::cmp::max(self.active_jobs + MAX_EXTRA_CAPACITY, 1));\n+\n+            self.assert_invariants();\n+        }\n+    }\n+}"}, {"sha": "9583cd2ec60f8a5bcf3bb3d4b0b74ea806f97614", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -9,7 +9,7 @@ use gimli::{RunTimeEndian, SectionId};\n use super::object::WriteDebugInfo;\n use super::DebugContext;\n \n-impl DebugContext<'_> {\n+impl DebugContext {\n     pub(crate) fn emit(&mut self, product: &mut ObjectProduct) {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();"}, {"sha": "3ad0c420eaf0b010b313e4dae0a785778eb21f0f", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 93, "deletions": 120, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -3,8 +3,10 @@\n use std::ffi::OsStr;\n use std::path::{Component, Path};\n \n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_span::{\n     FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n };\n@@ -14,7 +16,6 @@ use cranelift_codegen::MachSrcLoc;\n \n use gimli::write::{\n     Address, AttributeValue, FileId, FileInfo, LineProgram, LineString, LineStringTable,\n-    UnitEntryId,\n };\n \n // OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n@@ -47,9 +48,9 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     }\n }\n \n-pub(crate) const MD5_LEN: usize = 16;\n+const MD5_LEN: usize = 16;\n \n-pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n+fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n@@ -59,160 +60,132 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     }\n }\n \n-fn line_program_add_file(\n-    line_program: &mut LineProgram,\n-    line_strings: &mut LineStringTable,\n-    file: &SourceFile,\n-) -> FileId {\n-    match &file.name {\n-        FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n-            let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n-            let file_name = osstr_as_utf8_bytes(file_name);\n-\n-            let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n-                line_program.add_directory(dir_name)\n-            } else {\n-                line_program.default_directory()\n-            };\n-            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+impl DebugContext {\n+    pub(crate) fn get_span_loc(\n+        tcx: TyCtxt<'_>,\n+        function_span: Span,\n+        span: Span,\n+    ) -> (Lrc<SourceFile>, u64, u64) {\n+        // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+            span\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        };\n \n-            let info = make_file_info(file.src_hash);\n+        match tcx.sess.source_map().lookup_line(span.lo()) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(span.lo());\n \n-            line_program.file_has_md5 &= info.is_some();\n-            line_program.add_file(file_name, dir_id, info)\n+                (\n+                    file,\n+                    u64::try_from(line).unwrap() + 1,\n+                    u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                )\n+            }\n+            Err(file) => (file, 0, 0),\n         }\n-        // FIXME give more appropriate file names\n-        filename => {\n-            let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(\n-                filename.prefer_remapped().to_string().into_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(dummy_file_name, dir_id, None)\n+    }\n+\n+    pub(crate) fn add_source_file(&mut self, source_file: &SourceFile) -> FileId {\n+        let line_program: &mut LineProgram = &mut self.dwarf.unit.line_program;\n+        let line_strings: &mut LineStringTable = &mut self.dwarf.line_strings;\n+\n+        match &source_file.name {\n+            FileName::Real(path) => {\n+                let (dir_path, file_name) =\n+                    split_path_dir_and_file(path.remapped_path_if_available());\n+                let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n+                let file_name = osstr_as_utf8_bytes(file_name);\n+\n+                let dir_id = if !dir_name.is_empty() {\n+                    let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                    line_program.add_directory(dir_name)\n+                } else {\n+                    line_program.default_directory()\n+                };\n+                let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+\n+                let info = make_file_info(source_file.src_hash);\n+\n+                line_program.file_has_md5 &= info.is_some();\n+                line_program.add_file(file_name, dir_id, info)\n+            }\n+            // FIXME give more appropriate file names\n+            filename => {\n+                let dir_id = line_program.default_directory();\n+                let dummy_file_name = LineString::new(\n+                    filename.prefer_remapped().to_string().into_bytes(),\n+                    line_program.encoding(),\n+                    line_strings,\n+                );\n+                line_program.add_file(dummy_file_name, dir_id, None)\n+            }\n         }\n     }\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n-        let loc = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n-\n-        let file_id = line_program_add_file(\n-            &mut self.dwarf.unit.line_program,\n-            &mut self.dwarf.line_strings,\n-            &loc.file,\n-        );\n-\n-        let entry = self.dwarf.unit.get_mut(entry_id);\n-\n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n-        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n-        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n+impl FunctionDebugContext {\n+    pub(crate) fn add_dbg_loc(&mut self, file_id: FileId, line: u64, column: u64) -> SourceLoc {\n+        let (index, _) = self.source_loc_set.insert_full((file_id, line, column));\n+        SourceLoc::new(u32::try_from(index).unwrap())\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n+        debug_context: &mut DebugContext,\n         symbol: usize,\n-        entry_id: UnitEntryId,\n         context: &Context,\n-        function_span: Span,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let tcx = self.tcx;\n-        let line_program = &mut self.dwarf.unit.line_program;\n-\n-        let line_strings = &mut self.dwarf.line_strings;\n-        let mut last_span = None;\n-        let mut last_file = None;\n-        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n-            if let Some(last_span) = last_span {\n-                if span == last_span {\n-                    line_program.generate_row();\n-                    return;\n-                }\n-            }\n-            last_span = Some(span);\n-\n-            // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n-            // In order to have a good line stepping behavior in debugger, we overwrite debug\n-            // locations of macro expansions with that of the outermost expansion site\n-            // (unless the crate is being compiled with `-Z debug-macros`).\n-            let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n-                span\n-            } else {\n-                // Walk up the macro expansion chain until we reach a non-expanded span.\n-                // We also stop at the function body level because no line stepping can occur\n-                // at the level above that.\n-                rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        let create_row_for_span =\n+            |debug_context: &mut DebugContext, source_loc: (FileId, u64, u64)| {\n+                let (file_id, line, col) = source_loc;\n+\n+                debug_context.dwarf.unit.line_program.row().file = file_id;\n+                debug_context.dwarf.unit.line_program.row().line = line;\n+                debug_context.dwarf.unit.line_program.row().column = col;\n+                debug_context.dwarf.unit.line_program.generate_row();\n             };\n \n-            let (file, line, col) = match tcx.sess.source_map().lookup_line(span.lo()) {\n-                Ok(SourceFileAndLine { sf: file, line }) => {\n-                    let line_pos = file.line_begin_pos(span.lo());\n-\n-                    (\n-                        file,\n-                        u64::try_from(line).unwrap() + 1,\n-                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n-                    )\n-                }\n-                Err(file) => (file, 0, 0),\n-            };\n-\n-            // line_program_add_file is very slow.\n-            // Optimize for the common case of the current file not being changed.\n-            let current_file_changed = if let Some(last_file) = &last_file {\n-                // If the allocations are not equal, then the files may still be equal, but that\n-                // is not a problem, as this is just an optimization.\n-                !rustc_data_structures::sync::Lrc::ptr_eq(last_file, &file)\n-            } else {\n-                true\n-            };\n-            if current_file_changed {\n-                let file_id = line_program_add_file(line_program, line_strings, &file);\n-                line_program.row().file = file_id;\n-                last_file = Some(file);\n-            }\n-\n-            line_program.row().line = line;\n-            line_program.row().column = col;\n-            line_program.generate_row();\n-        };\n-\n-        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n+        debug_context\n+            .dwarf\n+            .unit\n+            .line_program\n+            .begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n \n         let mut func_end = 0;\n \n-        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        let mcr = context.compiled_code().unwrap();\n         for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-            line_program.row().address_offset = u64::from(start);\n+            debug_context.dwarf.unit.line_program.row().address_offset = u64::from(start);\n             if !loc.is_default() {\n-                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                create_row_for_span(line_program, source_info.span);\n+                let source_loc = *self.source_loc_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(debug_context, source_loc);\n             } else {\n-                create_row_for_span(line_program, function_span);\n+                create_row_for_span(debug_context, self.function_source_loc);\n             }\n             func_end = end;\n         }\n \n-        line_program.end_sequence(u64::from(func_end));\n+        debug_context.dwarf.unit.line_program.end_sequence(u64::from(func_end));\n \n         let func_end = mcr.buffer.total_size();\n \n         assert_ne!(func_end, 0);\n \n-        let entry = self.dwarf.unit.get_mut(entry_id);\n+        let entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n-        self.emit_location(entry_id, function_span);\n-\n         func_end\n     }\n }"}, {"sha": "c55db2017ee68c31c53b0a59e12c82b6b72c6c7e", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 44, "deletions": 238, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -7,35 +7,34 @@ mod unwind;\n \n use crate::prelude::*;\n \n-use rustc_index::vec::IndexVec;\n-\n-use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{Endianness, LabelValueLoc, ValueLabel};\n+use cranelift_codegen::ir::Endianness;\n use cranelift_codegen::isa::TargetIsa;\n-use cranelift_codegen::ValueLocRange;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n-    LocationList, Range, RangeList, UnitEntryId,\n+    Address, AttributeValue, DwarfUnit, FileId, LineProgram, LineString, Range, RangeList,\n+    UnitEntryId,\n };\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n+use indexmap::IndexSet;\n \n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n \n-pub(crate) struct DebugContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n+pub(crate) struct DebugContext {\n     endian: RunTimeEndian,\n \n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n+}\n \n-    types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n+pub(crate) struct FunctionDebugContext {\n+    entry_id: UnitEntryId,\n+    function_source_loc: (FileId, u64, u64),\n+    source_loc_set: indexmap::IndexSet<(FileId, u64, u64)>,\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+impl DebugContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa) -> Self {\n         let encoding = Encoding {\n             format: Format::Dwarf32,\n             // FIXME this should be configurable\n@@ -101,127 +100,18 @@ impl<'tcx> DebugContext<'tcx> {\n             root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n-        DebugContext {\n-            tcx,\n-\n-            endian,\n-\n-            dwarf,\n-            unit_range_list: RangeList(Vec::new()),\n-\n-            types: FxHashMap::default(),\n-        }\n-    }\n-\n-    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let name = format!(\"{}\", ty);\n-        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-\n-        let type_id = match ty.kind() {\n-            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n-            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n-            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n-            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n-            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n-            ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let pointee = self.dwarf_ty(*pointee_ty);\n-\n-                let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc_hir::Mutability::Mut));\n-                type_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(pointee));\n-\n-                type_id\n-            }\n-            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let variant = adt_def.non_enum_variant();\n-\n-                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n-                    let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout.field(\n-                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                        field_idx,\n-                    );\n-\n-                    let field_type = self.dwarf_ty(field_layout.ty);\n-\n-                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n-                    let field_entry = self.dwarf.unit.get_mut(field_id);\n-\n-                    field_entry.set(\n-                        gimli::DW_AT_name,\n-                        AttributeValue::String(field_def.name.as_str().to_string().into_bytes()),\n-                    );\n-                    field_entry.set(\n-                        gimli::DW_AT_data_member_location,\n-                        AttributeValue::Udata(field_offset.bytes()),\n-                    );\n-                    field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n-                }\n-\n-                type_id\n-            }\n-            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n-\n-        self.types.insert(ty, type_id);\n-\n-        type_id\n-    }\n-\n-    fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let dw_ty = self.dwarf_ty(ty);\n-\n-        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n-        let var_entry = self.dwarf.unit.get_mut(var_id);\n-\n-        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-\n-        var_id\n+        DebugContext { endian, dwarf, unit_range_list: RangeList(Vec::new()) }\n     }\n \n     pub(crate) fn define_function(\n         &mut self,\n-        instance: Instance<'tcx>,\n-        func_id: FuncId,\n+        tcx: TyCtxt<'_>,\n         name: &str,\n-        isa: &dyn TargetIsa,\n-        context: &Context,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n-        local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n-    ) {\n-        let symbol = func_id.as_u32() as usize;\n-        let mir = self.tcx.instance_mir(instance.def);\n+        function_span: Span,\n+    ) -> FunctionDebugContext {\n+        let (file, line, column) = DebugContext::get_span_loc(tcx, function_span, function_span);\n+\n+        let file_id = self.add_source_file(&file);\n \n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n@@ -233,125 +123,41 @@ impl<'tcx> DebugContext<'tcx> {\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n         entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(line));\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(column));\n \n-        self.unit_range_list.0.push(Range::StartLength {\n+        FunctionDebugContext {\n+            entry_id,\n+            function_source_loc: (file_id, line, column),\n+            source_loc_set: IndexSet::new(),\n+        }\n+    }\n+}\n+\n+impl FunctionDebugContext {\n+    pub(crate) fn finalize(\n+        mut self,\n+        debug_context: &mut DebugContext,\n+        func_id: FuncId,\n+        context: &Context,\n+    ) {\n+        let symbol = func_id.as_u32() as usize;\n+\n+        let end = self.create_debug_lines(debug_context, symbol, context);\n+\n+        debug_context.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        let func_entry = self.dwarf.unit.get_mut(entry_id);\n+        let func_entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n-\n-        // FIXME make it more reliable and implement scopes before re-enabling this.\n-        if false {\n-            let value_labels_ranges = std::collections::HashMap::new(); // FIXME\n-\n-            for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    mir.local_decls[local].ty,\n-                );\n-                let var_id = self.define_local(entry_id, format!(\"{:?}\", local), ty);\n-\n-                let location = place_location(\n-                    self,\n-                    isa,\n-                    symbol,\n-                    &local_map,\n-                    &value_labels_ranges,\n-                    Place { local, projection: ty::List::empty() },\n-                );\n-\n-                let var_entry = self.dwarf.unit.get_mut(var_id);\n-                var_entry.set(gimli::DW_AT_location, location);\n-            }\n-        }\n-\n-        // FIXME create locals for all entries in mir.var_debug_info\n-    }\n-}\n-\n-fn place_location<'tcx>(\n-    debug_context: &mut DebugContext<'tcx>,\n-    isa: &dyn TargetIsa,\n-    symbol: usize,\n-    local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n-    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n-        ValueLabel,\n-        Vec<ValueLocRange>,\n-    >,\n-    place: Place<'tcx>,\n-) -> AttributeValue {\n-    assert!(place.projection.is_empty()); // FIXME implement them\n-\n-    match local_map[place.local].inner() {\n-        CPlaceInner::Var(_local, var) => {\n-            let value_label = cranelift_codegen::ir::ValueLabel::new(var.index());\n-            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n-                let loc_list = LocationList(\n-                    value_loc_ranges\n-                        .iter()\n-                        .map(|value_loc_range| Location::StartEnd {\n-                            begin: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.start),\n-                            },\n-                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n-                            data: translate_loc(isa, value_loc_range.loc).unwrap(),\n-                        })\n-                        .collect(),\n-                );\n-                let loc_list_id = debug_context.dwarf.unit.locations.add(loc_list);\n-\n-                AttributeValue::LocationListRef(loc_list_id)\n-            } else {\n-                // FIXME set value labels for unused locals\n-\n-                AttributeValue::Exprloc(Expression::new())\n-            }\n-        }\n-        CPlaceInner::VarPair(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::VarLane(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::Addr(_, _) => {\n-            // FIXME implement this (used by arguments and returns)\n-\n-            AttributeValue::Exprloc(Expression::new())\n-\n-            // For PointerBase::Stack:\n-            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot)).unwrap())\n-        }\n-    }\n-}\n-\n-// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(isa: &dyn TargetIsa, loc: LabelValueLoc) -> Option<Expression> {\n-    match loc {\n-        LabelValueLoc::Reg(reg) => {\n-            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n-            let mut expr = Expression::new();\n-            expr.op_reg(gimli::Register(machine_reg));\n-            Some(expr)\n-        }\n-        LabelValueLoc::SPOffset(offset) => {\n-            let mut expr = Expression::new();\n-            expr.op_breg(X86_64::RSP, offset);\n-            Some(expr)\n-        }\n     }\n }"}, {"sha": "e41ae1fbdbac54cd9a58bb80f4d8c9905e1738dc", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -62,16 +62,14 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    dest: CPlace<'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n-) -> CValue<'tcx> {\n+) {\n     let layout = value.layout();\n \n-    if layout.abi == Abi::Uninhabited {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::UnreachableCodeReached);\n-        // Return a dummy value\n-        return CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout);\n+    if layout.abi.is_uninhabited() {\n+        return;\n     }\n \n     let (tag_scalar, tag_field, tag_encoding) = match &layout.variants {\n@@ -89,7 +87,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             } else {\n                 ty::ScalarInt::try_from_uint(discr_val, dest_layout.size).unwrap()\n             };\n-            return CValue::const_val(fx, dest_layout, discr_val);\n+            let res = CValue::const_val(fx, dest_layout, discr_val);\n+            dest.write_cvalue(fx, res);\n+            return;\n         }\n         Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n             (tag, *tag_field, tag_encoding)\n@@ -110,7 +110,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 _ => false,\n             };\n             let val = clif_intcast(fx, tag, cast_to, signed);\n-            CValue::by_val(val, dest_layout)\n+            let res = CValue::by_val(val, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n@@ -170,7 +171,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n \n             let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n-            CValue::by_val(discr, dest_layout)\n+            let res = CValue::by_val(discr, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n     }\n }"}, {"sha": "8eabe1cbcb15030380e0ac333315d3326c765629", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 315, "deletions": 245, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,33 +1,129 @@\n //! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n //! standalone executable.\n \n+use std::fs::File;\n use std::path::PathBuf;\n+use std::sync::Arc;\n+use std::thread::JoinHandle;\n \n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::back::metadata::create_compressed_metadata_file;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{DebugInfo, OutputType};\n+use rustc_session::config::{DebugInfo, OutputFilenames, OutputType};\n use rustc_session::Session;\n \n-use cranelift_codegen::isa::TargetIsa;\n use cranelift_object::{ObjectBuilder, ObjectModule};\n \n+use crate::concurrency_limiter::{ConcurrencyLimiter, ConcurrencyLimiterToken};\n+use crate::global_asm::GlobalAsmConfig;\n use crate::{prelude::*, BackendConfig};\n \n-struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+struct ModuleCodegenResult {\n+    module_regular: CompiledModule,\n+    module_global_asm: Option<CompiledModule>,\n+    existing_work_product: Option<(WorkProductId, WorkProduct)>,\n+}\n+\n+enum OngoingModuleCodegen {\n+    Sync(Result<ModuleCodegenResult, String>),\n+    Async(JoinHandle<Result<ModuleCodegenResult, String>>),\n+}\n \n-impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+impl<HCX> HashStable<HCX> for OngoingModuleCodegen {\n     fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n         // do nothing\n     }\n }\n \n-fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+pub(crate) struct OngoingCodegen {\n+    modules: Vec<OngoingModuleCodegen>,\n+    allocator_module: Option<CompiledModule>,\n+    metadata_module: Option<CompiledModule>,\n+    metadata: EncodedMetadata,\n+    crate_info: CrateInfo,\n+    concurrency_limiter: ConcurrencyLimiter,\n+}\n+\n+impl OngoingCodegen {\n+    pub(crate) fn join(\n+        self,\n+        sess: &Session,\n+        backend_config: &BackendConfig,\n+    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n+        let mut work_products = FxHashMap::default();\n+        let mut modules = vec![];\n+\n+        for module_codegen in self.modules {\n+            let module_codegen_result = match module_codegen {\n+                OngoingModuleCodegen::Sync(module_codegen_result) => module_codegen_result,\n+                OngoingModuleCodegen::Async(join_handle) => match join_handle.join() {\n+                    Ok(module_codegen_result) => module_codegen_result,\n+                    Err(panic) => std::panic::resume_unwind(panic),\n+                },\n+            };\n+\n+            let module_codegen_result = match module_codegen_result {\n+                Ok(module_codegen_result) => module_codegen_result,\n+                Err(err) => sess.fatal(&err),\n+            };\n+            let ModuleCodegenResult { module_regular, module_global_asm, existing_work_product } =\n+                module_codegen_result;\n+\n+            if let Some((work_product_id, work_product)) = existing_work_product {\n+                work_products.insert(work_product_id, work_product);\n+            } else {\n+                let work_product = if backend_config.disable_incr_cache {\n+                    None\n+                } else if let Some(module_global_asm) = &module_global_asm {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[\n+                            (\"o\", &module_regular.object.as_ref().unwrap()),\n+                            (\"asm.o\", &module_global_asm.object.as_ref().unwrap()),\n+                        ],\n+                    )\n+                } else {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[(\"o\", &module_regular.object.as_ref().unwrap())],\n+                    )\n+                };\n+                if let Some((work_product_id, work_product)) = work_product {\n+                    work_products.insert(work_product_id, work_product);\n+                }\n+            }\n+\n+            modules.push(module_regular);\n+            if let Some(module_global_asm) = module_global_asm {\n+                modules.push(module_global_asm);\n+            }\n+        }\n+\n+        drop(self.concurrency_limiter);\n+\n+        (\n+            CodegenResults {\n+                modules,\n+                allocator_module: self.allocator_module,\n+                metadata_module: self.metadata_module,\n+                metadata: self.metadata,\n+                crate_info: self.crate_info,\n+            },\n+            work_products,\n+        )\n+    }\n+}\n+\n+fn make_module(sess: &Session, backend_config: &BackendConfig, name: String) -> ObjectModule {\n+    let isa = crate::build_isa(sess, backend_config);\n+\n     let mut builder =\n         ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n     // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n@@ -37,15 +133,15 @@ fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectM\n     ObjectModule::new(builder)\n }\n \n-fn emit_module(\n-    tcx: TyCtxt<'_>,\n-    backend_config: &BackendConfig,\n+fn emit_cgu(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n     name: String,\n-    kind: ModuleKind,\n     module: ObjectModule,\n-    debug: Option<DebugContext<'_>>,\n+    debug: Option<DebugContext>,\n     unwind_context: UnwindContext,\n-) -> ModuleCodegenResult {\n+    global_asm_object_file: Option<PathBuf>,\n+) -> Result<ModuleCodegenResult, String> {\n     let mut product = module.finish();\n \n     if let Some(mut debug) = debug {\n@@ -54,144 +150,199 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let tmp_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(&name));\n-    let obj = product.object.write().unwrap();\n+    let module_regular =\n+        emit_module(output_filenames, prof, product.object, ModuleKind::Regular, name.clone())?;\n+\n+    Ok(ModuleCodegenResult {\n+        module_regular,\n+        module_global_asm: global_asm_object_file.map(|global_asm_object_file| CompiledModule {\n+            name: format!(\"{name}.asm\"),\n+            kind: ModuleKind::Regular,\n+            object: Some(global_asm_object_file),\n+            dwarf_object: None,\n+            bytecode: None,\n+        }),\n+        existing_work_product: None,\n+    })\n+}\n \n-    tcx.sess.prof.artifact_size(\"object_file\", name.clone(), obj.len().try_into().unwrap());\n+fn emit_module(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n+    object: cranelift_object::object::write::Object<'_>,\n+    kind: ModuleKind,\n+    name: String,\n+) -> Result<CompiledModule, String> {\n+    let tmp_file = output_filenames.temp_path(OutputType::Object, Some(&name));\n+    let mut file = match File::create(&tmp_file) {\n+        Ok(file) => file,\n+        Err(err) => return Err(format!(\"error creating object file: {}\", err)),\n+    };\n \n-    if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n+    if let Err(err) = object.write_stream(&mut file) {\n+        return Err(format!(\"error writing object file: {}\", err));\n     }\n \n-    let work_product = if backend_config.disable_incr_cache {\n-        None\n-    } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n-            tcx.sess,\n-            &name,\n-            &[(\"o\", &tmp_file)],\n-        )\n-    };\n+    prof.artifact_size(\"object_file\", &*name, file.metadata().unwrap().len());\n \n-    ModuleCodegenResult(\n-        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n-        work_product,\n-    )\n+    Ok(CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None })\n }\n \n fn reuse_workproduct_for_cgu(\n     tcx: TyCtxt<'_>,\n     cgu: &CodegenUnit<'_>,\n-    work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n-) -> CompiledModule {\n+) -> Result<ModuleCodegenResult, String> {\n     let work_product = cgu.previous_work_product(tcx);\n-    let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+    let obj_out_regular =\n+        tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n+    let source_file_regular = rustc_incremental::in_incr_comp_dir_sess(\n         &tcx.sess,\n         &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-        tcx.sess.err(&format!(\n+\n+    if let Err(err) = rustc_fs_util::link_or_copy(&source_file_regular, &obj_out_regular) {\n+        return Err(format!(\n             \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n+            source_file_regular.display(),\n+            obj_out_regular.display(),\n             err\n         ));\n     }\n+    let obj_out_global_asm =\n+        crate::global_asm::add_file_stem_postfix(obj_out_regular.clone(), \".asm\");\n+    let has_global_asm = if let Some(asm_o) = work_product.saved_files.get(\"asm.o\") {\n+        let source_file_global_asm = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, asm_o);\n+        if let Err(err) = rustc_fs_util::link_or_copy(&source_file_global_asm, &obj_out_global_asm)\n+        {\n+            return Err(format!(\n+                \"unable to copy {} to {}: {}\",\n+                source_file_regular.display(),\n+                obj_out_regular.display(),\n+                err\n+            ));\n+        }\n+        true\n+    } else {\n+        false\n+    };\n \n-    work_products.insert(cgu.work_product_id(), work_product);\n-\n-    CompiledModule {\n-        name: cgu.name().to_string(),\n-        kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n-        bytecode: None,\n-    }\n+    Ok(ModuleCodegenResult {\n+        module_regular: CompiledModule {\n+            name: cgu.name().to_string(),\n+            kind: ModuleKind::Regular,\n+            object: Some(obj_out_regular),\n+            dwarf_object: None,\n+            bytecode: None,\n+        },\n+        module_global_asm: if has_global_asm {\n+            Some(CompiledModule {\n+                name: cgu.name().to_string(),\n+                kind: ModuleKind::Regular,\n+                object: Some(obj_out_global_asm),\n+                dwarf_object: None,\n+                bytecode: None,\n+            })\n+        } else {\n+            None\n+        },\n+        existing_work_product: Some((cgu.work_product_id(), work_product)),\n+    })\n }\n \n fn module_codegen(\n     tcx: TyCtxt<'_>,\n-    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n-) -> ModuleCodegenResult {\n-    let cgu = tcx.codegen_unit(cgu_name);\n-    let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut module = make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n-\n-    let mut cx = crate::CodegenCx::new(\n-        tcx,\n-        backend_config.clone(),\n-        module.isa(),\n-        tcx.sess.opts.debuginfo != DebugInfo::None,\n-        cgu_name,\n-    );\n-    super::predefine_mono_items(tcx, &mut module, &mono_items);\n-    for (mono_item, _) in mono_items {\n-        match mono_item {\n-            MonoItem::Fn(inst) => {\n-                cx.tcx\n-                    .sess\n-                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n-            }\n-            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n-            MonoItem::GlobalAsm(item_id) => {\n-                let item = cx.tcx.hir().item(item_id);\n-                if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n-                    if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        cx.global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n-                    } else {\n-                        cx.global_asm.push_str(\"\\n.att_syntax\\n\");\n-                    }\n-                    for piece in asm.template {\n-                        match *piece {\n-                            InlineAsmTemplatePiece::String(ref s) => cx.global_asm.push_str(s),\n-                            InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n-                        }\n-                    }\n-                    cx.global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n-                } else {\n-                    bug!(\"Expected GlobalAsm found {:?}\", item);\n+    (backend_config, global_asm_config, cgu_name, token): (\n+        BackendConfig,\n+        Arc<GlobalAsmConfig>,\n+        rustc_span::Symbol,\n+        ConcurrencyLimiterToken,\n+    ),\n+) -> OngoingModuleCodegen {\n+    let (cgu_name, mut cx, mut module, codegened_functions) = tcx.sess.time(\"codegen cgu\", || {\n+        let cgu = tcx.codegen_unit(cgu_name);\n+        let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+        let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+\n+        let mut cx = crate::CodegenCx::new(\n+            tcx,\n+            backend_config.clone(),\n+            module.isa(),\n+            tcx.sess.opts.debuginfo != DebugInfo::None,\n+            cgu_name,\n+        );\n+        super::predefine_mono_items(tcx, &mut module, &mono_items);\n+        let mut codegened_functions = vec![];\n+        for (mono_item, _) in mono_items {\n+            match mono_item {\n+                MonoItem::Fn(inst) => {\n+                    tcx.sess.time(\"codegen fn\", || {\n+                        let codegened_function = crate::base::codegen_fn(\n+                            tcx,\n+                            &mut cx,\n+                            Function::new(),\n+                            &mut module,\n+                            inst,\n+                        );\n+                        codegened_functions.push(codegened_function);\n+                    });\n+                }\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(tcx, &mut module, def_id)\n+                }\n+                MonoItem::GlobalAsm(item_id) => {\n+                    crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n                 }\n             }\n         }\n-    }\n-    crate::main_shim::maybe_create_entry_wrapper(\n-        tcx,\n-        &mut module,\n-        &mut cx.unwind_context,\n-        false,\n-        cgu.is_primary(),\n-    );\n-\n-    let debug_context = cx.debug_context;\n-    let unwind_context = cx.unwind_context;\n-    let codegen_result = tcx.sess.time(\"write object file\", || {\n-        emit_module(\n+        crate::main_shim::maybe_create_entry_wrapper(\n             tcx,\n-            &backend_config,\n-            cgu.name().as_str().to_string(),\n-            ModuleKind::Regular,\n-            module,\n-            debug_context,\n-            unwind_context,\n-        )\n+            &mut module,\n+            &mut cx.unwind_context,\n+            false,\n+            cgu.is_primary(),\n+        );\n+\n+        let cgu_name = cgu.name().as_str().to_owned();\n+\n+        (cgu_name, cx, module, codegened_functions)\n     });\n \n-    codegen_global_asm(tcx, cgu.name().as_str(), &cx.global_asm);\n+    OngoingModuleCodegen::Async(std::thread::spawn(move || {\n+        cx.profiler.clone().verbose_generic_activity(\"compile functions\").run(|| {\n+            let mut cached_context = Context::new();\n+            for codegened_func in codegened_functions {\n+                crate::base::compile_fn(&mut cx, &mut cached_context, &mut module, codegened_func);\n+            }\n+        });\n \n-    codegen_result\n+        let global_asm_object_file =\n+            cx.profiler.verbose_generic_activity(\"compile assembly\").run(|| {\n+                crate::global_asm::compile_global_asm(&global_asm_config, &cgu_name, &cx.global_asm)\n+            })?;\n+\n+        let codegen_result = cx.profiler.verbose_generic_activity(\"write object file\").run(|| {\n+            emit_cgu(\n+                &global_asm_config.output_filenames,\n+                &cx.profiler,\n+                cgu_name,\n+                module,\n+                cx.debug_context,\n+                cx.unwind_context,\n+                global_asm_object_file,\n+            )\n+        });\n+        std::mem::drop(token);\n+        codegen_result\n+    }))\n }\n \n pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    let mut work_products = FxHashMap::default();\n-\n+) -> Box<OngoingCodegen> {\n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n         tcx.collect_and_partition_mono_items(()).1\n     } else {\n@@ -206,62 +357,69 @@ pub(crate) fn run_aot(\n         }\n     }\n \n+    let global_asm_config = Arc::new(crate::global_asm::GlobalAsmConfig::new(tcx));\n+\n+    let mut concurrency_limiter = ConcurrencyLimiter::new(tcx.sess, cgus.len());\n+\n     let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n-                let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+                let cgu_reuse = if backend_config.disable_incr_cache {\n+                    CguReuse::No\n+                } else {\n+                    determine_cgu_reuse(tcx, cgu)\n+                };\n                 tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n-                    _ if backend_config.disable_incr_cache => {}\n-                    CguReuse::No => {}\n-                    CguReuse::PreLto => {\n-                        return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+                    CguReuse::No => {\n+                        let dep_node = cgu.codegen_dep_node(tcx);\n+                        tcx.dep_graph\n+                            .with_task(\n+                                dep_node,\n+                                tcx,\n+                                (\n+                                    backend_config.clone(),\n+                                    global_asm_config.clone(),\n+                                    cgu.name(),\n+                                    concurrency_limiter.acquire(),\n+                                ),\n+                                module_codegen,\n+                                Some(rustc_middle::dep_graph::hash_result),\n+                            )\n+                            .0\n+                    }\n+                    CguReuse::PreLto => unreachable!(),\n+                    CguReuse::PostLto => {\n+                        concurrency_limiter.job_already_done();\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n                     }\n-                    CguReuse::PostLto => unreachable!(),\n-                }\n-\n-                let dep_node = cgu.codegen_dep_node(tcx);\n-                let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n-                    dep_node,\n-                    tcx,\n-                    (backend_config.clone(), cgu.name()),\n-                    module_codegen,\n-                    Some(rustc_middle::dep_graph::hash_result),\n-                );\n-\n-                if let Some((id, product)) = work_product {\n-                    work_products.insert(id, product);\n                 }\n-\n-                module\n             })\n             .collect::<Vec<_>>()\n     });\n \n     tcx.sess.abort_if_errors();\n \n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut allocator_module = make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n-    assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n+    let mut allocator_module = make_module(tcx.sess, &backend_config, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n-        let ModuleCodegenResult(module, work_product) = emit_module(\n-            tcx,\n-            &backend_config,\n-            \"allocator_shim\".to_string(),\n+        let mut product = allocator_module.finish();\n+        allocator_unwind_context.emit(&mut product);\n+\n+        match emit_module(\n+            tcx.output_filenames(()),\n+            &tcx.sess.prof,\n+            product.object,\n             ModuleKind::Allocator,\n-            allocator_module,\n-            None,\n-            allocator_unwind_context,\n-        );\n-        if let Some((id, product)) = work_product {\n-            work_products.insert(id, product);\n+            \"allocator_shim\".to_owned(),\n+        ) {\n+            Ok(allocator_module) => Some(allocator_module),\n+            Err(err) => tcx.sess.fatal(err),\n         }\n-        Some(module)\n     } else {\n         None\n     };\n@@ -308,102 +466,14 @@ pub(crate) fn run_aot(\n     }\n     .to_owned();\n \n-    Box::new((\n-        CodegenResults {\n-            modules,\n-            allocator_module,\n-            metadata_module,\n-            metadata,\n-            crate_info: CrateInfo::new(tcx, target_cpu),\n-        },\n-        work_products,\n-    ))\n-}\n-\n-fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n-    use std::io::Write;\n-    use std::process::{Command, Stdio};\n-\n-    if global_asm.is_empty() {\n-        return;\n-    }\n-\n-    if cfg!(not(feature = \"inline_asm\"))\n-        || tcx.sess.target.is_like_osx\n-        || tcx.sess.target.is_like_windows\n-    {\n-        if global_asm.contains(\"__rust_probestack\") {\n-            return;\n-        }\n-\n-        // FIXME fix linker error on macOS\n-        if cfg!(not(feature = \"inline_asm\")) {\n-            tcx.sess.fatal(\n-                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n-            );\n-        } else {\n-            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n-        }\n-    }\n-\n-    let assembler = crate::toolchain::get_toolchain_binary(tcx.sess, \"as\");\n-    let linker = crate::toolchain::get_toolchain_binary(tcx.sess, \"ld\");\n-\n-    // Remove all LLVM style comments\n-    let global_asm = global_asm\n-        .lines()\n-        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n-        .collect::<Vec<_>>()\n-        .join(\"\\n\");\n-\n-    let output_object_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu_name));\n-\n-    // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n-    let mut child = Command::new(assembler)\n-        .arg(\"-o\")\n-        .arg(&global_asm_object_file)\n-        .stdin(Stdio::piped())\n-        .spawn()\n-        .expect(\"Failed to spawn `as`.\");\n-    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n-    let status = child.wait().expect(\"Failed to wait for `as`.\");\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n-    }\n-\n-    // Link the global asm and main object file together\n-    let main_object_file = add_file_stem_postfix(output_object_file.clone(), \".main\");\n-    std::fs::rename(&output_object_file, &main_object_file).unwrap();\n-    let status = Command::new(linker)\n-        .arg(\"-r\") // Create a new object file\n-        .arg(\"-o\")\n-        .arg(output_object_file)\n-        .arg(&main_object_file)\n-        .arg(&global_asm_object_file)\n-        .status()\n-        .unwrap();\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\n-            \"Failed to link `{}` and `{}` together\",\n-            main_object_file.display(),\n-            global_asm_object_file.display(),\n-        ));\n-    }\n-\n-    std::fs::remove_file(global_asm_object_file).unwrap();\n-    std::fs::remove_file(main_object_file).unwrap();\n-}\n-\n-fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n-    let mut new_filename = path.file_stem().unwrap().to_owned();\n-    new_filename.push(postfix);\n-    if let Some(extension) = path.extension() {\n-        new_filename.push(\".\");\n-        new_filename.push(extension);\n-    }\n-    path.set_file_name(new_filename);\n-    path\n+    Box::new(OngoingCodegen {\n+        modules,\n+        allocator_module,\n+        metadata_module,\n+        metadata,\n+        crate_info: CrateInfo::new(tcx, target_cpu),\n+        concurrency_limiter,\n+    })\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n@@ -432,5 +502,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PostLto } else { CguReuse::No }\n }"}, {"sha": "0e77e4004c0bb5d0ef4c814c9003fa114c1b51d1", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -61,11 +61,11 @@ impl UnsafeMessage {\n     }\n }\n \n-fn create_jit_module<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn create_jit_module(\n+    tcx: TyCtxt<'_>,\n     backend_config: &BackendConfig,\n     hotswap: bool,\n-) -> (JITModule, CodegenCx<'tcx>) {\n+) -> (JITModule, CodegenCx) {\n     let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n     let imported_symbols = load_imported_symbols_for_jit(tcx.sess, crate_info);\n \n@@ -111,6 +111,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         &backend_config,\n         matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n     );\n+    let mut cached_context = Context::new();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(());\n     let mono_items = cgus\n@@ -128,11 +129,19 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_and_compile_fn(\n+                                tcx,\n+                                &mut cx,\n+                                &mut cached_context,\n+                                &mut jit_module,\n+                                inst,\n+                            )\n                         });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n+                    CodegenMode::JitLazy => {\n+                        codegen_shim(tcx, &mut cx, &mut cached_context, &mut jit_module, inst)\n+                    }\n                 },\n                 MonoItem::Static(def_id) => {\n                     crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n@@ -259,7 +268,15 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n                 false,\n                 Symbol::intern(\"dummy_cgu_name\"),\n             );\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_and_compile_fn(\n+                    tcx,\n+                    &mut cx,\n+                    &mut Context::new(),\n+                    jit_module,\n+                    instance,\n+                )\n+            });\n \n             assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n@@ -334,9 +351,13 @@ fn load_imported_symbols_for_jit(\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n-    let tcx = cx.tcx;\n-\n+fn codegen_shim<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut CodegenCx,\n+    cached_context: &mut Context,\n+    module: &mut JITModule,\n+    inst: Instance<'tcx>,\n+) {\n     let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name;\n@@ -357,8 +378,9 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n         )\n         .unwrap();\n \n-    cx.cached_context.clear();\n-    let trampoline = &mut cx.cached_context.func;\n+    let context = cached_context;\n+    context.clear();\n+    let trampoline = &mut context.func;\n     trampoline.signature = sig.clone();\n \n     let mut builder_ctx = FunctionBuilderContext::new();\n@@ -381,5 +403,6 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    module.define_function(func_id, &mut cx.cached_context).unwrap();\n+    module.define_function(func_id, context).unwrap();\n+    cx.unwind_context.add_function(func_id, context, module.isa());\n }"}, {"sha": "dcbcaba30feeda219cea9d7042dd73e40167fe82", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,114 @@\n+//! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n+//! standalone executable.\n+\n+use std::io::Write;\n+use std::path::PathBuf;\n+use std::process::{Command, Stdio};\n+use std::sync::Arc;\n+\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir::ItemId;\n+use rustc_session::config::{OutputFilenames, OutputType};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn codegen_global_asm_item(tcx: TyCtxt<'_>, global_asm: &mut String, item_id: ItemId) {\n+    let item = tcx.hir().item(item_id);\n+    if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n+        if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n+        } else {\n+            global_asm.push_str(\"\\n.att_syntax\\n\");\n+        }\n+        for piece in asm.template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => global_asm.push_str(s),\n+                InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+            }\n+        }\n+        global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n+    } else {\n+        bug!(\"Expected GlobalAsm found {:?}\", item);\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct GlobalAsmConfig {\n+    asm_enabled: bool,\n+    assembler: PathBuf,\n+    pub(crate) output_filenames: Arc<OutputFilenames>,\n+}\n+\n+impl GlobalAsmConfig {\n+    pub(crate) fn new(tcx: TyCtxt<'_>) -> Self {\n+        let asm_enabled = cfg!(feature = \"inline_asm\") && !tcx.sess.target.is_like_windows;\n+\n+        GlobalAsmConfig {\n+            asm_enabled,\n+            assembler: crate::toolchain::get_toolchain_binary(tcx.sess, \"as\"),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+        }\n+    }\n+}\n+\n+pub(crate) fn compile_global_asm(\n+    config: &GlobalAsmConfig,\n+    cgu_name: &str,\n+    global_asm: &str,\n+) -> Result<Option<PathBuf>, String> {\n+    if global_asm.is_empty() {\n+        return Ok(None);\n+    }\n+\n+    if !config.asm_enabled {\n+        if global_asm.contains(\"__rust_probestack\") {\n+            return Ok(None);\n+        }\n+\n+        // FIXME fix linker error on macOS\n+        if cfg!(not(feature = \"inline_asm\")) {\n+            return Err(\n+                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\"\n+                    .to_owned(),\n+            );\n+        } else {\n+            return Err(\"asm! and global_asm! are not yet supported on Windows\".to_owned());\n+        }\n+    }\n+\n+    // Remove all LLVM style comments\n+    let global_asm = global_asm\n+        .lines()\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+\n+    let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n+\n+    // Assemble `global_asm`\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let mut child = Command::new(&config.assembler)\n+        .arg(\"-o\")\n+        .arg(&global_asm_object_file)\n+        .stdin(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn `as`.\");\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n+    let status = child.wait().expect(\"Failed to wait for `as`.\");\n+    if !status.success() {\n+        return Err(format!(\"Failed to assemble `{}`\", global_asm));\n+    }\n+\n+    Ok(Some(global_asm_object_file))\n+}\n+\n+pub(crate) fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n+    let mut new_filename = path.file_stem().unwrap().to_owned();\n+    new_filename.push(postfix);\n+    if let Some(extension) = path.extension() {\n+        new_filename.push(\".\");\n+        new_filename.push(extension);\n+    }\n+    path.set_file_name(new_filename);\n+    path\n+}"}, {"sha": "8b3d475cb1802dcc1662145ca0cc4a1c99a8119c", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 136, "deletions": 40, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -15,15 +15,19 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n+    destination: Option<mir::BasicBlock>,\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n     if !template.is_empty() {\n+        // Used by panic_abort\n         if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            fx.bcx.ins().trap(TrapCode::User(1));\n             return;\n-        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        }\n+\n+        // Used by stdarch\n+        if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n             && matches!(\n                 template[1],\n                 InlineAsmTemplatePiece::Placeholder {\n@@ -47,51 +51,46 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         {\n             assert_eq!(operands.len(), 4);\n             let (leaf, eax_place) = match operands[1] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let ebx_place = match operands[0] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n+                InlineAsmOperand::Out {\n+                    reg:\n                         InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                            X86InlineAsmRegClass::reg\n-                        ))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                            X86InlineAsmRegClass::reg,\n+                        )),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n             let (sub_leaf, ecx_place) = match operands[2] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let edx_place = match operands[3] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n \n@@ -101,12 +100,99 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n             ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n             edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n             return;\n-        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        }\n+\n+        // Used by compiler-builtins\n+        if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n             // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n             crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+            return;\n         } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n             crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+            return;\n+        }\n+\n+        // Used by measureme\n+        if template[0] == InlineAsmTemplatePiece::String(\"xor %eax, %eax\".to_string())\n+            && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[2] == InlineAsmTemplatePiece::String(\"mov %rbx, \".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[6] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[7] == InlineAsmTemplatePiece::String(\"mov \".to_string())\n+            && matches!(\n+                template[8],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[9] == InlineAsmTemplatePiece::String(\", %rbx\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"rdpmc\".to_string()) {\n+            // Return zero dummy values for all performance counters\n+            match operands[0] {\n+                InlineAsmOperand::In {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    value: _,\n+                } => {}\n+                _ => unreachable!(),\n+            };\n+            let lo = match operands[1] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+            let hi = match operands[2] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+\n+            let u32_layout = fx.layout_of(fx.tcx.types.u32);\n+            let zero = fx.bcx.ins().iconst(types::I32, 0);\n+            lo.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+            hi.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"lock xadd \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 1, modifier: None, span: _ }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\", (\".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: None, span: _ }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\")\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n         }\n     }\n \n@@ -175,6 +261,16 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     }\n \n     call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n+\n+    match destination {\n+        Some(destination) => {\n+            let destination_block = fx.get_block(destination);\n+            fx.bcx.ins().jump(destination_block, &[]);\n+        }\n+        None => {\n+            fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        }\n+    }\n }\n \n struct InlineAssemblyGenerator<'a, 'tcx> {\n@@ -637,7 +733,7 @@ fn call_inline_asm<'tcx>(\n     inputs: Vec<(Size, Value)>,\n     outputs: Vec<(Size, CPlace<'tcx>)>,\n ) {\n-    let stack_slot = fx.bcx.func.create_stack_slot(StackSlotData {\n+    let stack_slot = fx.bcx.func.create_sized_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });"}, {"sha": "5120b89c4e8b0b28dba764aac67ed47cbfac3f1a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n-    crate::trap::trap_unreachable(\n+    crate::trap::trap_unimplemented(\n         fx,\n         \"__cpuid_count arch intrinsic doesn't yet support specified leaf\",\n     );"}, {"sha": "a799dca938e21bb4ef79027aaf408263aa961389", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -139,6 +139,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 .sess\n                 .warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n         }\n     }\n "}, {"sha": "ef3d5ccea8a2406d42d1cae971cd9a1658a94473", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -44,7 +44,7 @@ fn report_atomic_type_validation_error<'tcx>(\n         ),\n     );\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n@@ -53,7 +53,7 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n         _ => unreachable!(),\n     };\n \n-    match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+    match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n         // Cranelift currently only implements icmp for 128bit vectors.\n         Some(vector_ty) if vector_ty.bits() == 128 => Some(vector_ty),\n         _ => None,\n@@ -301,7 +301,44 @@ fn codegen_float_intrinsic_call<'tcx>(\n         _ => unreachable!(),\n     };\n \n-    let res = fx.easy_call(name, &args, ty);\n+    let layout = fx.layout_of(ty);\n+    let res = match intrinsic {\n+        sym::fmaf32 | sym::fmaf64 => {\n+            let a = args[0].load_scalar(fx);\n+            let b = args[1].load_scalar(fx);\n+            let c = args[2].load_scalar(fx);\n+            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+        }\n+        sym::copysignf32 | sym::copysignf64 => {\n+            let a = args[0].load_scalar(fx);\n+            let b = args[1].load_scalar(fx);\n+            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+        }\n+        sym::fabsf32\n+        | sym::fabsf64\n+        | sym::floorf32\n+        | sym::floorf64\n+        | sym::ceilf32\n+        | sym::ceilf64\n+        | sym::truncf32\n+        | sym::truncf64 => {\n+            let a = args[0].load_scalar(fx);\n+\n+            let val = match intrinsic {\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                _ => unreachable!(),\n+            };\n+\n+            CValue::by_val(val, layout)\n+        }\n+        // These intrinsics aren't supported natively by Cranelift.\n+        // Lower them to a libcall.\n+        _ => fx.easy_call(name, &args, ty),\n+    };\n+\n     ret.write_cvalue(fx, res);\n \n     true\n@@ -818,8 +855,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx\n@@ -851,8 +886,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx"}, {"sha": "a32b413d45f938d093f7f4efcae7e3a8fc2a240a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -14,7 +14,7 @@ fn report_simd_type_validation_error(\n ) {\n     fx.tcx.sess.span_err(span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n@@ -157,7 +157,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                             ),\n                         );\n                         // Prevent verifier error\n-                        crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n                         return;\n                     }\n                 }\n@@ -274,12 +274,17 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 idx_const\n             } else {\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n-                let res = crate::trap::trap_unimplemented_ret_value(\n+                let trap_block = fx.bcx.create_block();\n+                let dummy_block = fx.bcx.create_block();\n+                let true_ = fx.bcx.ins().iconst(types::I8, 1);\n+                fx.bcx.ins().brnz(true_, trap_block, &[]);\n+                fx.bcx.ins().jump(dummy_block, &[]);\n+                fx.bcx.switch_to_block(trap_block);\n+                crate::trap::trap_unimplemented(\n                     fx,\n-                    ret.layout(),\n                     \"Index argument for `simd_extract` is not a constant\",\n                 );\n-                ret.write_cvalue(fx, res);\n+                fx.bcx.switch_to_block(dummy_block);\n                 return;\n             };\n \n@@ -392,21 +397,15 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             let layout = a.layout();\n             let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let res_lane_layout = fx.layout_of(lane_ty);\n \n             for lane in 0..lane_count {\n-                let a_lane = a.value_lane(fx, lane);\n-                let b_lane = b.value_lane(fx, lane);\n-                let c_lane = c.value_lane(fx, lane);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_lane(fx, lane).load_scalar(fx);\n \n-                let res_lane = match lane_ty.kind() {\n-                    ty::Float(FloatTy::F32) => {\n-                        fx.easy_call(\"fmaf\", &[a_lane, b_lane, c_lane], lane_ty)\n-                    }\n-                    ty::Float(FloatTy::F64) => {\n-                        fx.easy_call(\"fma\", &[a_lane, b_lane, c_lane], lane_ty)\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                let res_lane = fx.bcx.ins().fma(a_lane, b_lane, c_lane);\n+                let res_lane = CValue::by_val(res_lane, res_lane_layout);\n \n                 ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n             }"}, {"sha": "913414e7618213d99adb63a711ef18412e747695", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -4,6 +4,7 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n+extern crate jobserver;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_ast;\n@@ -25,10 +26,12 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n+use std::sync::Arc;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_errors::ErrorGuaranteed;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n@@ -51,11 +54,13 @@ mod cast;\n mod codegen_i128;\n mod common;\n mod compiler_builtins;\n+mod concurrency_limiter;\n mod config;\n mod constant;\n mod debuginfo;\n mod discriminant;\n mod driver;\n+mod global_asm;\n mod inline_asm;\n mod intrinsics;\n mod linkage;\n@@ -119,19 +124,20 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n \n /// The codegen context holds any information shared between the codegen of individual functions\n /// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n-struct CodegenCx<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct CodegenCx {\n+    profiler: SelfProfilerRef,\n+    output_filenames: Arc<OutputFilenames>,\n+    should_write_ir: bool,\n     global_asm: String,\n     inline_asm_index: Cell<usize>,\n-    cached_context: Context,\n-    debug_context: Option<DebugContext<'tcx>>,\n+    debug_context: Option<DebugContext>,\n     unwind_context: UnwindContext,\n     cgu_name: Symbol,\n }\n \n-impl<'tcx> CodegenCx<'tcx> {\n+impl CodegenCx {\n     fn new(\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         backend_config: BackendConfig,\n         isa: &dyn TargetIsa,\n         debug_info: bool,\n@@ -147,10 +153,11 @@ impl<'tcx> CodegenCx<'tcx> {\n             None\n         };\n         CodegenCx {\n-            tcx,\n+            profiler: tcx.prof.clone(),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+            should_write_ir: crate::pretty_clif::should_write_ir(tcx),\n             global_asm: String::new(),\n             inline_asm_index: Cell::new(0),\n-            cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n             cgu_name,\n@@ -159,7 +166,7 @@ impl<'tcx> CodegenCx<'tcx> {\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: Option<BackendConfig>,\n+    pub config: RefCell<Option<BackendConfig>>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -169,6 +176,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             Lto::No | Lto::ThinLocal => {}\n             Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n+\n+        let mut config = self.config.borrow_mut();\n+        if config.is_none() {\n+            let new_config = BackendConfig::from_opts(&sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| sess.fatal(&err));\n+            *config = Some(new_config);\n+        }\n     }\n \n     fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<rustc_span::Symbol> {\n@@ -186,15 +200,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n         tcx.sess.abort_if_errors();\n-        let config = if let Some(config) = self.config.clone() {\n-            config\n-        } else {\n-            if !tcx.sess.unstable_options() && !tcx.sess.opts.cg.llvm_args.is_empty() {\n-                tcx.sess.fatal(\"`-Z unstable-options` must be passed to allow configuring cg_clif\");\n-            }\n-            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n-                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n-        };\n+        let config = self.config.borrow().clone().unwrap();\n         match config.codegen_mode {\n             CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n             CodegenMode::Jit | CodegenMode::JitLazy => {\n@@ -210,12 +216,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn join_codegen(\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n-        _sess: &Session,\n+        sess: &Session,\n         _outputs: &OutputFilenames,\n     ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorGuaranteed> {\n-        Ok(*ongoing_codegen\n-            .downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>()\n-            .unwrap())\n+        Ok(ongoing_codegen\n+            .downcast::<driver::aot::OngoingCodegen>()\n+            .unwrap()\n+            .join(sess, self.config.borrow().as_ref().unwrap()))\n     }\n \n     fn link(\n@@ -312,5 +319,5 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend { config: None })\n+    Box::new(CraneliftCodegenBackend { config: RefCell::new(None) })\n }"}, {"sha": "0df7e82294bd23521b72225d3746116488cac4d3", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,20 +1,3 @@\n //! Various optimizations specific to cg_clif\n \n-use cranelift_codegen::isa::TargetIsa;\n-\n-use crate::prelude::*;\n-\n pub(crate) mod peephole;\n-\n-pub(crate) fn optimize_function<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    isa: &dyn TargetIsa,\n-    instance: Instance<'tcx>,\n-    ctx: &mut Context,\n-    clif_comments: &mut crate::pretty_clif::CommentWriter,\n-) {\n-    // FIXME classify optimizations over opt levels once we have more\n-\n-    crate::pretty_clif::write_clif_file(tcx, \"preopt\", isa, instance, &ctx.func, &*clif_comments);\n-    crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n-}"}, {"sha": "a7af162687c34c5cd0fa4ffbea65459779231eb7", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -62,7 +62,7 @@ use cranelift_codegen::{\n };\n \n use rustc_middle::ty::layout::FnAbiOf;\n-use rustc_session::config::OutputType;\n+use rustc_session::config::{OutputFilenames, OutputType};\n \n use crate::prelude::*;\n \n@@ -205,60 +205,55 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n }\n \n pub(crate) fn write_ir_file(\n-    tcx: TyCtxt<'_>,\n-    name: impl FnOnce() -> String,\n+    output_filenames: &OutputFilenames,\n+    name: &str,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n-    if !should_write_ir(tcx) {\n-        return;\n-    }\n-\n-    let clif_output_dir = tcx.output_filenames(()).with_extension(\"clif\");\n+    let clif_output_dir = output_filenames.with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n         Ok(()) => {}\n         Err(err) if err.kind() == std::io::ErrorKind::AlreadyExists => {}\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(name());\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n+        // Using early_warn as no Session is available here\n+        rustc_session::early_warn(\n+            rustc_session::config::ErrorOutputType::default(),\n+            &format!(\"error writing ir file: {}\", err),\n+        );\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn write_clif_file(\n+    output_filenames: &OutputFilenames,\n+    symbol_name: &str,\n     postfix: &str,\n     isa: &dyn cranelift_codegen::isa::TargetIsa,\n-    instance: Instance<'tcx>,\n     func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n     // FIXME work around filename too long errors\n-    write_ir_file(\n-        tcx,\n-        || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func)\n-                .unwrap();\n+    write_ir_file(output_filenames, &format!(\"{}.{}.clif\", symbol_name, postfix), |file| {\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func).unwrap();\n \n-            for flag in isa.flags().iter() {\n-                writeln!(file, \"set {}\", flag)?;\n-            }\n-            write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n-            for isa_flag in isa.isa_flags().iter() {\n-                write!(file, \" {}\", isa_flag)?;\n-            }\n-            writeln!(file, \"\\n\")?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        for flag in isa.flags().iter() {\n+            writeln!(file, \"set {}\", flag)?;\n+        }\n+        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        for isa_flag in isa.isa_flags().iter() {\n+            write!(file, \" {}\", isa_flag)?;\n+        }\n+        writeln!(file, \"\\n\")?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}, {"sha": "b6b465e1f4e0a808a394c07b68ee0563d1538314", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -8,10 +8,8 @@ use rustc_session::Session;\n /// Tries to infer the path of a binary for the target toolchain from the linker name.\n pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n     let (mut linker, _linker_flavor) = linker_and_flavor(sess);\n-    let linker_file_name = linker\n-        .file_name()\n-        .and_then(|name| name.to_str())\n-        .unwrap_or_else(|| sess.fatal(\"couldn't extract file name from specified linker\"));\n+    let linker_file_name =\n+        linker.file_name().unwrap().to_str().expect(\"linker filename should be valid UTF-8\");\n \n     if linker_file_name == \"ld.lld\" {\n         if tool != \"ld\" {"}, {"sha": "82a2ec579549669afca23f19c1fac2e0eba12936", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -25,33 +25,10 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }\n \n-/// Use this for example when a function call should never return. This will fill the current block,\n-/// so you can **not** add instructions to it afterwards.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n-    codegen_print(fx, msg.as_ref());\n-    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-}\n /// Use this when something is unimplemented, but `libcore` or `libstd` requires it to codegen.\n-/// Unlike `trap_unreachable` this will not fill the current block, so you **must** add instructions\n-/// to it afterwards.\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n-    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-    fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n-}\n-\n-/// Like `trap_unimplemented` but returns a fake value of the specified type.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n-    msg: impl AsRef<str>,\n-) -> CValue<'tcx> {\n-    trap_unimplemented(fx, msg);\n-    CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n+    fx.bcx.ins().trap(TrapCode::User(!0));\n }"}, {"sha": "2ee98546c992a1ec8cce8ccd3c7e2a2fdb9d06a8", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> CValue<'tcx> {\n                 let clif_ty = match layout.abi {\n                     Abi::Scalar(scalar) => scalar_to_clif_type(fx.tcx, scalar),\n                     Abi::Vector { element, count } => scalar_to_clif_type(fx.tcx, element)\n-                        .by(u16::try_from(count).unwrap())\n+                        .by(u32::try_from(count).unwrap())\n                         .unwrap(),\n                     _ => unreachable!(\"{:?}\", layout.ty),\n                 };\n@@ -330,7 +330,7 @@ impl<'tcx> CPlace<'tcx> {\n                 .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n         }\n \n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n             // specify stack slot alignment.\n@@ -472,7 +472,7 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n-                    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n                         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n                         // specify stack slot alignment.\n@@ -519,7 +519,7 @@ impl<'tcx> CPlace<'tcx> {\n                 if let ty::Array(element, len) = dst_layout.ty.kind() {\n                     // Can only happen for vector types\n                     let len =\n-                        u16::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n+                        u32::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n                     let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n \n                     let data = match from.0 {\n@@ -614,7 +614,7 @@ impl<'tcx> CPlace<'tcx> {\n                     dst_align,\n                     src_align,\n                     true,\n-                    MemFlags::trusted(),\n+                    flags,\n                 );\n             }\n             CValueInner::ByRef(_, Some(_)) => todo!(),"}, {"sha": "3d929a1d50ce2435307a7834c1fe04c1c73b94bd", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,13 +1,2 @@\n #!/usr/bin/env bash\n-set -e\n-\n-./y.rs build --sysroot none \"$@\"\n-\n-rm -r target/out || true\n-\n-scripts/tests.sh no_sysroot\n-\n-./y.rs build \"$@\"\n-\n-scripts/tests.sh base_sysroot\n-scripts/tests.sh extended_sysroot\n+exec ./y.rs test"}, {"sha": "577f42ef3017c81f071bdd6fa9ca0697ab9241b9", "filename": "compiler/rustc_error_codes/src/error_codes/E0695.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0695.md", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0695.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0695.md?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -3,7 +3,6 @@ A `break` statement without a label appeared inside a labeled block.\n Erroneous code example:\n \n ```compile_fail,E0695\n-# #![feature(label_break_value)]\n loop {\n     'a: {\n         break;\n@@ -14,7 +13,6 @@ loop {\n Make sure to always label the `break`:\n \n ```\n-# #![feature(label_break_value)]\n 'l: loop {\n     'a: {\n         break 'l;\n@@ -25,7 +23,6 @@ Make sure to always label the `break`:\n Or if you want to `break` the labeled block:\n \n ```\n-# #![feature(label_break_value)]\n loop {\n     'a: {\n         break 'a;"}, {"sha": "bbcb8fc28cffa1a24a5f5f0d7d44303185562703", "filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -4,3 +4,40 @@ interface_ferris_identifier =\n \n interface_emoji_identifier =\n     identifiers cannot contain emoji: `{$ident}`\n+\n+interface_mixed_bin_crate =\n+    cannot mix `bin` crate type with others\n+\n+interface_mixed_proc_macro_crate =\n+    cannot mix `proc-macro` crate type with others\n+\n+interface_proc_macro_doc_without_arg =\n+    Trying to document proc macro crate without passing '--crate-type proc-macro to rustdoc\n+    .warn = The generated documentation may be incorrect\n+\n+interface_error_writing_dependencies =\n+    error writing dependencies to `{$path}`: {$error}\n+\n+interface_input_file_would_be_overwritten =\n+    the input file \"{$path}\" would be overwritten by the generated executable\n+\n+interface_generated_file_conflicts_with_directory =\n+    the generated executable for the input file \"{$input_path}\" conflicts with the existing directory \"{$dir_path}\"\n+\n+interface_temps_dir_error =\n+    failed to find or create the directory specified by `--temps-dir`\n+\n+interface_out_dir_error =\n+    failed to find or create the directory specified by `--out-dir`\n+\n+interface_cant_emit_mir =\n+    could not emit MIR: {$error}\n+\n+interface_rustc_error_fatal =\n+    fatal error triggered by #[rustc_error]\n+\n+interface_rustc_error_unexpected_annotation =\n+    unexpected annotation used with `#[rustc_error(...)]!\n+\n+interface_failed_writing_file =\n+    failed to write file {$path}: {$error}\""}, {"sha": "36c2ff4682301c967c1656e4ac8441d9f6c92196", "filename": "compiler/rustc_error_messages/locales/en-US/save_analysis.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1 @@\n+save_analysis_could_not_open = Could not open `{$file_name}`: `{$err}`"}, {"sha": "2d001d445be02b632356729b07acd98d1ecceb38", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -43,6 +43,7 @@ fluent_messages! {\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n+    save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n }\n "}, {"sha": "506198df4d8edd2e24896c219bd9e9416ee576ba", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -13,6 +13,7 @@ use rustc_span::{edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::path::{Path, PathBuf};\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n /// `.disable_suggestions()` was called on the `Diagnostic`.\n@@ -83,6 +84,7 @@ into_diagnostic_arg_using_display!(\n     u64,\n     i128,\n     u128,\n+    std::io::Error,\n     std::num::NonZeroU32,\n     hir::Target,\n     Edition,\n@@ -124,6 +126,18 @@ impl IntoDiagnosticArg for String {\n     }\n }\n \n+impl<'a> IntoDiagnosticArg for &'a Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for PathBuf {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for usize {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Number(self)"}, {"sha": "37b2b0ecad7721ef853b11099545fa0cdac48a0e", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -186,6 +186,8 @@ declare_features! (\n     /// Allows some increased flexibility in the name resolution rules,\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n+    /// Allows `'a: { break 'a; }`.\n+    (accepted, label_break_value, \"1.65.0\", Some(48594), None),\n     /// Allows `if/while p && let q = r && ...` chains.\n     (accepted, let_chains, \"1.64.0\", Some(53667), None),\n     /// Allows `break {expr}` with a value inside `loop`s."}, {"sha": "22178dd2123e50389681de48c2dd72d24e161f66", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -420,8 +420,6 @@ declare_features! (\n     (active, intra_doc_pointers, \"1.51.0\", Some(80896), None),\n     /// Allows `#[instruction_set(_)]` attribute\n     (active, isa_attribute, \"1.48.0\", Some(74727), None),\n-    /// Allows `'a: { break 'a; }`.\n-    (active, label_break_value, \"1.28.0\", Some(48594), None),\n     // Allows setting the threshold for the `large_assignments` lint.\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n     /// Allows `let...else` statements."}, {"sha": "8f02a6cc4a14d25514596bd534c383e875c7107e", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -17,7 +17,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(extend_one)]\n-#![feature(label_break_value)]\n+#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "6a497aed4aba75900410fe8b166cd56b92293a21", "filename": "compiler/rustc_interface/src/errors.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,89 @@\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{Span, Symbol};\n+\n+use std::io;\n+use std::path::Path;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::ferris_identifier)]\n+pub struct FerrisIdentifier {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"ferris\", applicability = \"maybe-incorrect\")]\n+    pub first_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::emoji_identifier)]\n+pub struct EmojiIdentifier {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub ident: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::mixed_bin_crate)]\n+pub struct MixedBinCrate;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::mixed_proc_macro_crate)]\n+pub struct MixedProcMacroCrate;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::proc_macro_doc_without_arg)]\n+pub struct ProcMacroDocWithoutArg;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::error_writing_dependencies)]\n+pub struct ErrorWritingDependencies<'a> {\n+    pub path: &'a Path,\n+    pub error: io::Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::input_file_would_be_overwritten)]\n+pub struct InputFileWouldBeOverWritten<'a> {\n+    pub path: &'a Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::generated_file_conflicts_with_directory)]\n+pub struct GeneratedFileConflictsWithDirectory<'a> {\n+    pub input_path: &'a Path,\n+    pub dir_path: &'a Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::temps_dir_error)]\n+pub struct TempsDirError;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::out_dir_error)]\n+pub struct OutDirError;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::cant_emit_mir)]\n+pub struct CantEmitMIR {\n+    pub error: io::Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::rustc_error_fatal)]\n+pub struct RustcErrorFatal {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::rustc_error_unexpected_annotation)]\n+pub struct RustcErrorUnexpectedAnnotation {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(interface::failed_writing_file)]\n+pub struct FailedWritingFile<'a> {\n+    pub path: &'a Path,\n+    pub error: io::Error,\n+}"}, {"sha": "258e38c3bdb9e09197fc006865defaa66903149a", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -5,8 +5,11 @@\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n mod callbacks;\n+mod errors;\n pub mod interface;\n mod passes;\n mod proc_macro_decls;"}, {"sha": "66c6a229b89e4564b4e9130f3191eded516adcf7", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,3 +1,8 @@\n+use crate::errors::{\n+    CantEmitMIR, EmojiIdentifier, ErrorWritingDependencies, FerrisIdentifier,\n+    GeneratedFileConflictsWithDirectory, InputFileWouldBeOverWritten, MixedBinCrate,\n+    MixedProcMacroCrate, OutDirError, ProcMacroDocWithoutArg, TempsDirError,\n+};\n use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n@@ -13,7 +18,6 @@ use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::StableCrateId;\n use rustc_hir::definitions::Definitions;\n use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n-use rustc_macros::SessionDiagnostic;\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n@@ -31,7 +35,7 @@ use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{FileName, Span};\n+use rustc_span::FileName;\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n use tracing::{info, warn};\n@@ -264,23 +268,6 @@ impl LintStoreExpand for LintStoreExpandImpl<'_> {\n     }\n }\n \n-#[derive(SessionDiagnostic)]\n-#[diag(interface::ferris_identifier)]\n-struct FerrisIdentifier {\n-    #[primary_span]\n-    spans: Vec<Span>,\n-    #[suggestion(code = \"ferris\", applicability = \"maybe-incorrect\")]\n-    first_span: Span,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(interface::emoji_identifier)]\n-struct EmojiIdentifier {\n-    #[primary_span]\n-    spans: Vec<Span>,\n-    ident: Symbol,\n-}\n-\n /// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided, injection of a dependency on the\n@@ -392,10 +379,10 @@ pub fn configure_and_expand(\n \n     if crate_types.len() > 1 {\n         if is_executable_crate {\n-            sess.err(\"cannot mix `bin` crate type with others\");\n+            sess.emit_err(MixedBinCrate);\n         }\n         if is_proc_macro_crate {\n-            sess.err(\"cannot mix `proc-macro` crate type with others\");\n+            sess.emit_err(MixedProcMacroCrate);\n         }\n     }\n \n@@ -406,13 +393,7 @@ pub fn configure_and_expand(\n     // However, we do emit a warning, to let such users know that they should\n     // start passing '--crate-type proc-macro'\n     if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n-        let mut msg = sess.diagnostic().struct_warn(\n-            \"Trying to document proc macro crate \\\n-             without passing '--crate-type proc-macro to rustdoc\",\n-        );\n-\n-        msg.warn(\"The generated documentation may be incorrect\");\n-        msg.emit();\n+        sess.emit_warning(ProcMacroDocWithoutArg);\n     } else {\n         krate = sess.time(\"maybe_create_a_macro_crate\", || {\n             let is_test_crate = sess.opts.test;\n@@ -666,11 +647,9 @@ fn write_out_deps(\n                     .emit_artifact_notification(&deps_filename, \"dep-info\");\n             }\n         }\n-        Err(e) => sess.fatal(&format!(\n-            \"error writing dependencies to `{}`: {}\",\n-            deps_filename.display(),\n-            e\n-        )),\n+        Err(error) => {\n+            sess.emit_fatal(ErrorWritingDependencies { path: &deps_filename, error });\n+        }\n     }\n }\n \n@@ -700,29 +679,20 @@ pub fn prepare_outputs(\n     if let Some(ref input_path) = compiler.input_path {\n         if sess.opts.will_create_output_file() {\n             if output_contains_path(&output_paths, input_path) {\n-                let reported = sess.err(&format!(\n-                    \"the input file \\\"{}\\\" would be overwritten by the generated \\\n-                        executable\",\n-                    input_path.display()\n-                ));\n+                let reported = sess.emit_err(InputFileWouldBeOverWritten { path: input_path });\n                 return Err(reported);\n             }\n-            if let Some(dir_path) = output_conflicts_with_dir(&output_paths) {\n-                let reported = sess.err(&format!(\n-                    \"the generated executable for the input file \\\"{}\\\" conflicts with the \\\n-                        existing directory \\\"{}\\\"\",\n-                    input_path.display(),\n-                    dir_path.display()\n-                ));\n+            if let Some(ref dir_path) = output_conflicts_with_dir(&output_paths) {\n+                let reported =\n+                    sess.emit_err(GeneratedFileConflictsWithDirectory { input_path, dir_path });\n                 return Err(reported);\n             }\n         }\n     }\n \n     if let Some(ref dir) = compiler.temps_dir {\n         if fs::create_dir_all(dir).is_err() {\n-            let reported =\n-                sess.err(\"failed to find or create the directory specified by `--temps-dir`\");\n+            let reported = sess.emit_err(TempsDirError);\n             return Err(reported);\n         }\n     }\n@@ -735,8 +705,7 @@ pub fn prepare_outputs(\n     if !only_dep_info {\n         if let Some(ref dir) = compiler.output_dir {\n             if fs::create_dir_all(dir).is_err() {\n-                let reported =\n-                    sess.err(\"failed to find or create the directory specified by `--out-dir`\");\n+                let reported = sess.emit_err(OutDirError);\n                 return Err(reported);\n             }\n         }\n@@ -1019,8 +988,8 @@ pub fn start_codegen<'tcx>(\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n-        if let Err(e) = rustc_mir_transform::dump_mir::emit_mir(tcx, outputs) {\n-            tcx.sess.err(&format!(\"could not emit MIR: {}\", e));\n+        if let Err(error) = rustc_mir_transform::dump_mir::emit_mir(tcx, outputs) {\n+            tcx.sess.emit_err(CantEmitMIR { error });\n             tcx.sess.abort_if_errors();\n         }\n     }"}, {"sha": "65fa8d7495a4bf16cc76277a97bf5593e3e29fd9", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::{FailedWritingFile, RustcErrorFatal, RustcErrorUnexpectedAnnotation};\n use crate::interface::{Compiler, Result};\n use crate::passes::{self, BoxedResolver, QueryContext};\n \n@@ -274,18 +275,14 @@ impl<'tcx> Queries<'tcx> {\n \n                 // Bare `#[rustc_error]`.\n                 None => {\n-                    tcx.sess.span_fatal(\n-                        tcx.def_span(def_id),\n-                        \"fatal error triggered by #[rustc_error]\",\n-                    );\n+                    tcx.sess.emit_fatal(RustcErrorFatal { span: tcx.def_span(def_id) });\n                 }\n \n                 // Some other attribute.\n                 Some(_) => {\n-                    tcx.sess.span_warn(\n-                        tcx.def_span(def_id),\n-                        \"unexpected annotation used with `#[rustc_error(...)]!\",\n-                    );\n+                    tcx.sess.emit_warning(RustcErrorUnexpectedAnnotation {\n+                        span: tcx.def_span(def_id),\n+                    });\n                 }\n             }\n         }\n@@ -360,9 +357,8 @@ impl Linker {\n         if sess.opts.unstable_opts.no_link {\n             let encoded = CodegenResults::serialize_rlink(&codegen_results);\n             let rlink_file = self.prepare_outputs.with_extension(config::RLINK_EXT);\n-            std::fs::write(&rlink_file, encoded).map_err(|err| {\n-                sess.fatal(&format!(\"failed to write file {}: {}\", rlink_file.display(), err));\n-            })?;\n+            std::fs::write(&rlink_file, encoded)\n+                .map_err(|error| sess.emit_fatal(FailedWritingFile { path: &rlink_file, error }))?;\n             return Ok(());\n         }\n "}, {"sha": "280b6aad12c0a9bbe702e5ed5a8f500916ca7a8b", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,6 +1,7 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n+use rustc_middle::middle::region::Scope;\n use rustc_middle::thir::*;\n use rustc_middle::{mir::*, ty};\n use rustc_span::Span;\n@@ -34,10 +35,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             &stmts,\n                             expr,\n                             safety_mode,\n+                            region_scope,\n                         ))\n                     })\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, &stmts, expr, safety_mode)\n+                    this.ast_block_stmts(\n+                        destination,\n+                        block,\n+                        span,\n+                        &stmts,\n+                        expr,\n+                        safety_mode,\n+                        region_scope,\n+                    )\n                 }\n             })\n         })\n@@ -51,6 +61,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         stmts: &[StmtId],\n         expr: Option<&Expr<'tcx>>,\n         safety_mode: BlockSafety,\n+        region_scope: Scope,\n     ) -> BlockAnd<()> {\n         let this = self;\n \n@@ -73,6 +84,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let mut let_scope_stack = Vec::with_capacity(8);\n         let outer_source_scope = this.source_scope;\n         let outer_in_scope_unsafe = this.in_scope_unsafe;\n+        // This scope information is kept for breaking out of the parent remainder scope in case\n+        // one let-else pattern matching fails.\n+        // By doing so, we can be sure that even temporaries that receive extended lifetime\n+        // assignments are dropped, too.\n+        let mut last_remainder_scope = region_scope;\n         this.update_source_scope_for_safety_mode(span, safety_mode);\n \n         let source_info = this.source_info(span);\n@@ -132,7 +148,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                                 initializer_span,\n                                                 else_block,\n                                                 visibility_scope,\n-                                                *remainder_scope,\n+                                                last_remainder_scope,\n                                                 remainder_span,\n                                                 pattern,\n                                             )\n@@ -178,6 +194,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     if let Some(source_scope) = visibility_scope {\n                         this.source_scope = source_scope;\n                     }\n+                    last_remainder_scope = *remainder_scope;\n                 }\n             }\n "}, {"sha": "f2d79ce756c27bc89b2a3147fb73b161fed94434", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -22,7 +22,7 @@ use rustc_errors::{\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n use std::ops::{Deref, DerefMut};\n \n@@ -977,15 +977,6 @@ impl<'a> Parser<'a> {\n         let mut err = self.struct_span_err(self.token.span, &msg_exp);\n \n         if let TokenKind::Ident(symbol, _) = &self.prev_token.kind {\n-            if symbol.as_str() == \"public\" {\n-                err.span_suggestion_short(\n-                    self.prev_token.span,\n-                    \"write `pub` instead of `public` to make the item public\",\n-                    \"pub\",\n-                    appl,\n-                );\n-            }\n-\n             if [\"def\", \"fun\", \"func\", \"function\"].contains(&symbol.as_str()) {\n                 err.span_suggestion_short(\n                     self.prev_token.span,\n@@ -996,6 +987,19 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        // `pub` may be used for an item or `pub(crate)`\n+        if self.prev_token.is_ident_named(sym::public)\n+            && (self.token.can_begin_item()\n+                || self.token.kind == TokenKind::OpenDelim(Delimiter::Parenthesis))\n+        {\n+            err.span_suggestion_short(\n+                self.prev_token.span,\n+                \"write `pub` instead of `public` to make the item public\",\n+                \"pub\",\n+                appl,\n+            );\n+        }\n+\n         // Add suggestion for a missing closing angle bracket if '>' is included in expected_tokens\n         // there are unclosed angle brackets\n         if self.unmatched_angle_bracket_count > 0"}, {"sha": "18aa109d7a60a640d4bb048bc9c86b1e9e2bc178", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -2014,10 +2014,6 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        if let Some(label) = opt_label {\n-            self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n-        }\n-\n         if self.token.is_whole_block() {\n             self.sess.emit_err(InvalidBlockMacroSegment {\n                 span: self.token.span,"}, {"sha": "181e27f334b40219e08be56fb5c3cc5f9b70e4f9", "filename": "compiler/rustc_save_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2FCargo.toml?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -9,9 +9,11 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n serde_json = \"1\"\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "f0ce41d02a6fb2d2a1b3029d220fdbbf6a82c806", "filename": "compiler/rustc_save_analysis/src/errors.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,10 @@\n+use rustc_macros::SessionDiagnostic;\n+\n+use std::path::Path;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(save_analysis::could_not_open)]\n+pub(crate) struct CouldNotOpen<'a> {\n+    pub file_name: &'a Path,\n+    pub err: std::io::Error,\n+}"}, {"sha": "619e083d89ad398b1991ecbf49e808e37409321a", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -3,11 +3,15 @@\n #![feature(let_else)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![feature(never_type)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n mod dump_visitor;\n mod dumper;\n #[macro_use]\n mod span_utils;\n+mod errors;\n mod sig;\n \n use rustc_ast as ast;\n@@ -928,7 +932,7 @@ impl<'a> DumpHandler<'a> {\n         info!(\"Writing output to {}\", file_name.display());\n \n         let output_file = BufWriter::new(File::create(&file_name).unwrap_or_else(|e| {\n-            sess.fatal(&format!(\"Could not open {}: {}\", file_name.display(), e))\n+            sess.emit_fatal(errors::CouldNotOpen { file_name: file_name.as_path(), err: e })\n         }));\n \n         (output_file, file_name)"}, {"sha": "5085e3aedfd6510bc04eecb7b7071fd8af66c2cf", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1119,6 +1119,7 @@ symbols! {\n         ptr_offset_from_unsigned,\n         pub_macro_rules,\n         pub_restricted,\n+        public,\n         pure,\n         pushpop_unsafe,\n         qreg,"}, {"sha": "e0dd28bee30b6e5b2ab8ec89c36c5ca13ec8be6b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -16,7 +16,7 @@\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n #![feature(hash_drain_filter)]\n-#![feature(label_break_value)]\n+#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(let_else)]\n #![feature(if_let_guard)]\n #![feature(never_type)]"}, {"sha": "5699f642bafa946eff9b7e12c4e9ebc0bb8e0bd6", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -64,7 +64,7 @@ This API is completely unstable and subject to change.\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n #![feature(iter_intersperse)]\n-#![feature(label_break_value)]\n+#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "934175863630f760d4c6c2c29905d5db8cce59f7", "filename": "library/core/src/option.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1189,6 +1189,12 @@ impl<T> Option<T> {\n \n     /// Returns [`None`] if the option is [`None`], otherwise returns `optb`.\n     ///\n+    /// Arguments passed to `and` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`and_then`], which is\n+    /// lazily evaluated.\n+    ///\n+    /// [`and_then`]: Option::and_then\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "75dcb4cdba9e264c048fd4059a68be7b911bd7e4", "filename": "library/core/src/result.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1285,6 +1285,11 @@ impl<T, E> Result<T, E> {\n \n     /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n     ///\n+    /// Arguments passed to `and` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`and_then`], which is\n+    /// lazily evaluated.\n+    ///\n+    /// [`and_then`]: Result::and_then\n     ///\n     /// # Examples\n     ///"}, {"sha": "50e3acc9400760e2327d87773688a59e5b3a48c8", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -252,7 +252,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exhaustive_patterns)]\n #![feature(intra_doc_pointers)]\n-#![feature(label_break_value)]\n+#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(lang_items)]\n #![feature(let_else)]\n #![feature(linkage)]"}, {"sha": "63009006b3f1f906a2fb449ed130fc0a84535b07", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -47,7 +47,7 @@ h4 {\n .docblock pre > code, pre > code {\n \tcolor: #e6e1cf;\n }\n-span code {\n+.item-info code {\n \tcolor: #e6e1cf;\n }\n .docblock a > code {"}, {"sha": "6fc38f45517ef74dc38864b8d00e0d4dc2b59548", "filename": "src/test/ui/feature-gates/feature-gate-label_break_value.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.rs?ref=5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "patch": "@@ -1,5 +0,0 @@\n-pub fn main() {\n-    'a: { //~ ERROR labels on blocks are unstable\n-        break 'a;\n-    }\n-}"}, {"sha": "4b43fdc593fa352a6ac212f0ad0a05087bdba82d", "filename": "src/test/ui/feature-gates/feature-gate-label_break_value.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.stderr?ref=5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: labels on blocks are unstable\n-  --> $DIR/feature-gate-label_break_value.rs:2:5\n-   |\n-LL |     'a: {\n-   |     ^^\n-   |\n-   = note: see issue #48594 <https://github.com/rust-lang/rust/issues/48594> for more information\n-   = help: add `#![feature(label_break_value)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "10992c50597b6512ef1a2949f10b1fac04bbc6e8", "filename": "src/test/ui/for-loop-while/label_break_value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_assignments)]\n-#![feature(label_break_value)]\n \n // Test control flow to follow label_break_value semantics\n fn label_break(a: bool, b: bool) -> u32 {"}, {"sha": "fcf2e0f294e5c19ef349d3a7a7bf597804605dbd", "filename": "src/test/ui/for-loop-while/label_break_value_invalid.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value_invalid.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,4 @@\n #![crate_type = \"lib\"]\n-#![feature(label_break_value)]\n \n fn lbv_macro_test_hygiene_respected() {\n     macro_rules! mac2 {"}, {"sha": "f6999c4ab116a10a9bba68b1109db4e08f7bdf1f", "filename": "src/test/ui/for-loop-while/label_break_value_invalid.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value_invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value_invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Flabel_break_value_invalid.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n error[E0426]: use of undeclared label `'a`\n-  --> $DIR/label_break_value_invalid.rs:7:19\n+  --> $DIR/label_break_value_invalid.rs:6:19\n    |\n LL |             break 'a $val;\n    |                   ^^ undeclared label `'a`\n@@ -10,7 +10,7 @@ LL |                 mac2!(2);\n    = note: this error originates in the macro `mac2` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0426]: use of undeclared label `'a`\n-  --> $DIR/label_break_value_invalid.rs:29:19\n+  --> $DIR/label_break_value_invalid.rs:28:19\n    |\n LL |     let x: u8 = mac3!('b: {\n    |                       -- a label with a similar name is reachable\n@@ -22,7 +22,7 @@ LL |             break 'a 3;\n    |                   help: try using similarly named label: `'b`\n \n error[E0426]: use of undeclared label `'a`\n-  --> $DIR/label_break_value_invalid.rs:34:29\n+  --> $DIR/label_break_value_invalid.rs:33:29\n    |\n LL |     let x: u8 = mac3!(break 'a 4);\n    |                             ^^ undeclared label `'a`"}, {"sha": "94a9c2ab8be8e681d34bbb6a5d3bf550371dd120", "filename": "src/test/ui/issues/issue-62480.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fissues%2Fissue-62480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fissues%2Fissue-62480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62480.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {\n     // This used to ICE during liveness check because `target_id` passed to\n     // `propagate_through_expr` would be the closure and not the `loop`, which wouldn't be found in"}, {"sha": "db230537037a45b71c7349b0f5d162ccd0b6f7e5", "filename": "src/test/ui/issues/issue-62480.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fissues%2Fissue-62480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fissues%2Fissue-62480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62480.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n error[E0767]: use of unreachable label `'a`\n-  --> $DIR/issue-62480.rs:8:18\n+  --> $DIR/issue-62480.rs:6:18\n    |\n LL |     'a: {\n    |     -- unreachable label defined here\n@@ -9,7 +9,7 @@ LL |         || break 'a\n    = note: labels are unreachable through functions, closures, async blocks and modules\n \n error[E0267]: `break` inside of a closure\n-  --> $DIR/issue-62480.rs:8:12\n+  --> $DIR/issue-62480.rs:6:12\n    |\n LL |         || break 'a\n    |         -- ^^^^^^^^ cannot `break` inside of a closure"}, {"sha": "22172f4fd2e88e4edfe1bdb3db164c93b9bdf2ee", "filename": "src/test/ui/label/label_break_value_continue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_continue.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,4 +1,3 @@\n-#![feature(label_break_value)]\n #![allow(unused_labels)]\n \n // Simple continue pointing to an unlabeled break should yield in an error"}, {"sha": "284d213d65eaab32f007c46539055d63511f8c63", "filename": "src/test/ui/label/label_break_value_continue.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_continue.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,11 +1,11 @@\n error[E0695]: unlabeled `continue` inside of a labeled block\n-  --> $DIR/label_break_value_continue.rs:7:9\n+  --> $DIR/label_break_value_continue.rs:6:9\n    |\n LL |         continue;\n    |         ^^^^^^^^ `continue` statements that would diverge to or through a labeled block need to bear a label\n \n error[E0696]: `continue` pointing to a labeled block\n-  --> $DIR/label_break_value_continue.rs:14:9\n+  --> $DIR/label_break_value_continue.rs:13:9\n    |\n LL | /     'b: {\n LL | |         continue 'b;\n@@ -14,7 +14,7 @@ LL | |     }\n    | |_____- labeled block the `continue` points to\n \n error[E0695]: unlabeled `continue` inside of a labeled block\n-  --> $DIR/label_break_value_continue.rs:22:13\n+  --> $DIR/label_break_value_continue.rs:21:13\n    |\n LL |             continue;\n    |             ^^^^^^^^ `continue` statements that would diverge to or through a labeled block need to bear a label"}, {"sha": "70227d869337df668670bfd8c7fb83e3630c62cd", "filename": "src/test/ui/label/label_break_value_desugared_break.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_desugared_break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_desugared_break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_desugared_break.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n // compile-flags: --edition 2018\n-#![feature(label_break_value, try_blocks)]\n+#![feature(try_blocks)]\n \n // run-pass\n fn main() {\n@@ -9,4 +9,11 @@ fn main() {\n             break 'foo;\n         }\n     };\n+\n+    'foo: {\n+        let _: Result<(), ()> = try {\n+            Err(())?;\n+            break 'foo;\n+        };\n+    }\n }"}, {"sha": "fb75276b4f4d1f92289fa0677dbe9512665ae827", "filename": "src/test/ui/label/label_break_value_illegal_uses.fixed", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.fixed?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,4 @@\n // run-rustfix\n-#![feature(label_break_value)]\n \n // These are forbidden occurrences of label-break-value\n "}, {"sha": "3cbf41380e6c551601be1b7d3d9150149398c760", "filename": "src/test/ui/label/label_break_value_illegal_uses.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,4 @@\n // run-rustfix\n-#![feature(label_break_value)]\n \n // These are forbidden occurrences of label-break-value\n "}, {"sha": "15016ffd54ab60d21592401ab078e57b591c90bf", "filename": "src/test/ui/label/label_break_value_illegal_uses.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,23 +1,23 @@\n error: block label not supported here\n-  --> $DIR/label_break_value_illegal_uses.rs:8:12\n+  --> $DIR/label_break_value_illegal_uses.rs:7:12\n    |\n LL |     unsafe 'b: {}\n    |            ^^^ not supported here\n \n error: block label not supported here\n-  --> $DIR/label_break_value_illegal_uses.rs:12:13\n+  --> $DIR/label_break_value_illegal_uses.rs:11:13\n    |\n LL |     if true 'b: {}\n    |             ^^^ not supported here\n \n error: block label not supported here\n-  --> $DIR/label_break_value_illegal_uses.rs:16:21\n+  --> $DIR/label_break_value_illegal_uses.rs:15:21\n    |\n LL |     if true {} else 'b: {}\n    |                     ^^^ not supported here\n \n error: block label not supported here\n-  --> $DIR/label_break_value_illegal_uses.rs:20:17\n+  --> $DIR/label_break_value_illegal_uses.rs:19:17\n    |\n LL |     match false 'b: {\n    |                 ^^^ not supported here"}, {"sha": "2a4f5d57493e1887587278cd12c0f1f3e38adc9c", "filename": "src/test/ui/label/label_break_value_unlabeled_break.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_unlabeled_break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_unlabeled_break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_unlabeled_break.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,4 +1,3 @@\n-#![feature(label_break_value)]\n #![allow(unused_labels)]\n \n // Simple unlabeled break should yield in an error"}, {"sha": "a2ccd27b83663a8e63432e6137812fd38765739e", "filename": "src/test/ui/label/label_break_value_unlabeled_break.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_unlabeled_break.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_unlabeled_break.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_unlabeled_break.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,11 +1,11 @@\n error[E0695]: unlabeled `break` inside of a labeled block\n-  --> $DIR/label_break_value_unlabeled_break.rs:7:9\n+  --> $DIR/label_break_value_unlabeled_break.rs:6:9\n    |\n LL |         break;\n    |         ^^^^^ `break` statements that would diverge to or through a labeled block need to bear a label\n \n error[E0695]: unlabeled `break` inside of a labeled block\n-  --> $DIR/label_break_value_unlabeled_break.rs:15:13\n+  --> $DIR/label_break_value_unlabeled_break.rs:14:13\n    |\n LL |             break;\n    |             ^^^^^ `break` statements that would diverge to or through a labeled block need to bear a label"}, {"sha": "07fcc16e7bbda3c74d4a86d4821cabc4bfca1560", "filename": "src/test/ui/let-else/let-else-temporary-lifetime.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -74,6 +74,17 @@ fn main() {\n             };\n         }\n     }\n+    {\n+        fn must_pass() {\n+            let rc = Rc::new(());\n+            let &None = &Some(Rc::clone(&rc)) else {\n+                Rc::try_unwrap(rc).unwrap();\n+                return;\n+            };\n+            unreachable!();\n+        }\n+        must_pass();\n+    }\n     {\n         // test let-else drops temps before else block\n         // NOTE: this test has to be the last block in the `main`"}, {"sha": "87a5392fd30fdd314421581f72cbc6b4290c2df2", "filename": "src/test/ui/lint/unused_labels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flint%2Funused_labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flint%2Funused_labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_labels.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -4,7 +4,6 @@\n \n // check-pass\n \n-#![feature(label_break_value)]\n #![warn(unused_labels)]\n \n fn main() {"}, {"sha": "846da792bed5543d15ed5ab9dcfe549873eb8002", "filename": "src/test/ui/lint/unused_labels.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flint%2Funused_labels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Flint%2Funused_labels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_labels.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n warning: label name `'many_used_shadowed` shadows a label name that is already in scope\n-  --> $DIR/unused_labels.rs:62:9\n+  --> $DIR/unused_labels.rs:61:9\n    |\n LL |     'many_used_shadowed: for _ in 0..10 {\n    |     ------------------- first declared here\n@@ -8,55 +8,55 @@ LL |         'many_used_shadowed: for _ in 0..10 {\n    |         ^^^^^^^^^^^^^^^^^^^ label `'many_used_shadowed` already in scope\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:11:5\n+  --> $DIR/unused_labels.rs:10:5\n    |\n LL |     'unused_while_label: while 0 == 0 {\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/unused_labels.rs:8:9\n+  --> $DIR/unused_labels.rs:7:9\n    |\n LL | #![warn(unused_labels)]\n    |         ^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:16:5\n+  --> $DIR/unused_labels.rs:15:5\n    |\n LL |     'unused_while_let_label: while let Some(_) = opt {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:20:5\n+  --> $DIR/unused_labels.rs:19:5\n    |\n LL |     'unused_for_label: for _ in 0..10 {\n    |     ^^^^^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:36:9\n+  --> $DIR/unused_labels.rs:35:9\n    |\n LL |         'unused_loop_label_inner_2: for _ in 0..10 {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:42:5\n+  --> $DIR/unused_labels.rs:41:5\n    |\n LL |     'unused_loop_label_outer_3: for _ in 0..10 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:60:5\n+  --> $DIR/unused_labels.rs:59:5\n    |\n LL |     'many_used_shadowed: for _ in 0..10 {\n    |     ^^^^^^^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:72:5\n+  --> $DIR/unused_labels.rs:71:5\n    |\n LL |     'unused_loop_label: loop {\n    |     ^^^^^^^^^^^^^^^^^^\n \n warning: unused label\n-  --> $DIR/unused_labels.rs:78:5\n+  --> $DIR/unused_labels.rs:77:5\n    |\n LL |     'unused_block_label: {\n    |     ^^^^^^^^^^^^^^^^^^^"}, {"sha": "dd159cb5b6efca50f6b5ef3e956efc9cbe62e285", "filename": "src/test/ui/macros/stringify.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -9,7 +9,6 @@\n #![feature(decl_macro)]\n #![feature(generators)]\n #![feature(half_open_range_patterns)]\n-#![feature(label_break_value)]\n #![feature(more_qualified_paths)]\n #![feature(raw_ref_op)]\n #![feature(trait_alias)]"}, {"sha": "c6d7ae383b247ad496c9ef6066af97ee2147debc", "filename": "src/test/ui/parser/bad-interpolated-block.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {}\n \n macro_rules! m {"}, {"sha": "2a0999afdfaf8c0d0cf4ec67ec5a0e78aa2094db", "filename": "src/test/ui/parser/bad-interpolated-block.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n error: cannot use a `block` macro fragment here\n-  --> $DIR/bad-interpolated-block.rs:7:15\n+  --> $DIR/bad-interpolated-block.rs:5:15\n    |\n LL |         'lab: $b;\n    |         ------^^\n@@ -12,7 +12,7 @@ LL |     m!({});\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: cannot use a `block` macro fragment here\n-  --> $DIR/bad-interpolated-block.rs:8:16\n+  --> $DIR/bad-interpolated-block.rs:6:16\n    |\n LL |         unsafe $b;\n    |         -------^^\n@@ -25,7 +25,7 @@ LL |     m!({});\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: cannot use a `block` macro fragment here\n-  --> $DIR/bad-interpolated-block.rs:9:23\n+  --> $DIR/bad-interpolated-block.rs:7:23\n    |\n LL |         |x: u8| -> () $b;\n    |                       ^^ the `block` fragment is within this context"}, {"sha": "d9ebd7473bc721dcaf975d7da7fea57924741caf", "filename": "src/test/ui/parser/labeled-no-colon-expr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {\n     'l0 while false {} //~ ERROR labeled expression must be followed by `:`\n     'l1 for _ in 0..1 {} //~ ERROR labeled expression must be followed by `:`"}, {"sha": "62288fe152da335ff6fbb5db3bc0bb73a24ef32c", "filename": "src/test/ui/parser/labeled-no-colon-expr.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n error: labeled expression must be followed by `:`\n-  --> $DIR/labeled-no-colon-expr.rs:4:5\n+  --> $DIR/labeled-no-colon-expr.rs:2:5\n    |\n LL |     'l0 while false {}\n    |     ----^^^^^^^^^^^^^^\n@@ -10,7 +10,7 @@ LL |     'l0 while false {}\n    = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n \n error: labeled expression must be followed by `:`\n-  --> $DIR/labeled-no-colon-expr.rs:5:5\n+  --> $DIR/labeled-no-colon-expr.rs:3:5\n    |\n LL |     'l1 for _ in 0..1 {}\n    |     ----^^^^^^^^^^^^^^^^\n@@ -21,7 +21,7 @@ LL |     'l1 for _ in 0..1 {}\n    = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n \n error: labeled expression must be followed by `:`\n-  --> $DIR/labeled-no-colon-expr.rs:6:5\n+  --> $DIR/labeled-no-colon-expr.rs:4:5\n    |\n LL |     'l2 loop {}\n    |     ----^^^^^^^\n@@ -32,7 +32,7 @@ LL |     'l2 loop {}\n    = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n \n error: labeled expression must be followed by `:`\n-  --> $DIR/labeled-no-colon-expr.rs:7:5\n+  --> $DIR/labeled-no-colon-expr.rs:5:5\n    |\n LL |     'l3 {}\n    |     ----^^\n@@ -43,7 +43,7 @@ LL |     'l3 {}\n    = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/labeled-no-colon-expr.rs:8:9\n+  --> $DIR/labeled-no-colon-expr.rs:6:9\n    |\n LL |     'l4 0;\n    |         ^ expected `while`, `for`, `loop` or `{` after a label\n@@ -55,7 +55,7 @@ LL +     0;\n    |\n \n error: labeled expression must be followed by `:`\n-  --> $DIR/labeled-no-colon-expr.rs:8:9\n+  --> $DIR/labeled-no-colon-expr.rs:6:9\n    |\n LL |     'l4 0;\n    |     ----^\n@@ -66,7 +66,7 @@ LL |     'l4 0;\n    = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n \n error: cannot use a `block` macro fragment here\n-  --> $DIR/labeled-no-colon-expr.rs:13:17\n+  --> $DIR/labeled-no-colon-expr.rs:11:17\n    |\n LL |             'l5 $b;\n    |             ----^^\n@@ -79,7 +79,7 @@ LL |     m!({});\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: labeled expression must be followed by `:`\n-  --> $DIR/labeled-no-colon-expr.rs:16:8\n+  --> $DIR/labeled-no-colon-expr.rs:14:8\n    |\n LL |             'l5 $b;\n    |             ---- help: add `:` after the label"}, {"sha": "a4fa68ba5cc2f3c65f317f4826c1af261a03cc21", "filename": "src/test/ui/parser/public-instead-of-pub-1.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.fixed?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,11 @@\n+// Checks what happens when `public` is used instead of the correct, `pub`\n+// run-rustfix\n+\n+pub enum Test {\n+    //~^ ERROR expected one of `!` or `::`, found keyword `enum`\n+    //~^^ HELP write `pub` instead of `public` to make the item public\n+    A,\n+    B,\n+}\n+\n+fn main() { }"}, {"sha": "43565c9b1d25fd46d9934142f863b6a0702937ec", "filename": "src/test/ui/parser/public-instead-of-pub-1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,11 @@\n+// Checks what happens when `public` is used instead of the correct, `pub`\n+// run-rustfix\n+\n+public enum Test {\n+    //~^ ERROR expected one of `!` or `::`, found keyword `enum`\n+    //~^^ HELP write `pub` instead of `public` to make the item public\n+    A,\n+    B,\n+}\n+\n+fn main() { }"}, {"sha": "795a5bcf5dfa6def88057235001ddcce7b30743e", "filename": "src/test/ui/parser/public-instead-of-pub-1.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-1.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,13 @@\n+error: expected one of `!` or `::`, found keyword `enum`\n+  --> $DIR/public-instead-of-pub-1.rs:4:8\n+   |\n+LL | public enum Test {\n+   |        ^^^^ expected one of `!` or `::`\n+   |\n+help: write `pub` instead of `public` to make the item public\n+   |\n+LL | pub enum Test {\n+   | ~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "8a43c361e0510d85efd735a4503250e20c84d536", "filename": "src/test/ui/parser/public-instead-of-pub-2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-2.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,7 @@\n+// Checks what happens when `public` is used instead of the correct, `pub`\n+// Won't give help message for this case\n+\n+public let x = 1;\n+//~^ ERROR expected one of `!` or `::`, found keyword `let`\n+\n+fn main() { }"}, {"sha": "efe225656fd7f02e491162989075e21ecfe5592b", "filename": "src/test/ui/parser/public-instead-of-pub-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpublic-instead-of-pub-2.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `!` or `::`, found keyword `let`\n+  --> $DIR/public-instead-of-pub-2.rs:4:8\n+   |\n+LL | public let x = 1;\n+   |        ^^^ expected one of `!` or `::`\n+\n+error: aborting due to previous error\n+"}, {"sha": "c2e76444d115edda41dc09a677d4e31bbe14fd58", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.fixed", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.fixed?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,4 @@\n // run-rustfix\n-#![feature(label_break_value)]\n fn main() {\n     let _ = 1 + 1; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n "}, {"sha": "fc11c646a8c68d5b17660355069310ea9ac95e16", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,4 @@\n // run-rustfix\n-#![feature(label_break_value)]\n fn main() {\n     let _ = 'label: 1 + 1; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n "}, {"sha": "d66ce6950904c53855da6218a86649ef286302a7", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,5 @@\n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:4:21\n+  --> $DIR/recover-labeled-non-block-expr.rs:3:21\n    |\n LL |     let _ = 'label: 1 + 1;\n    |                     ^ expected `while`, `for`, `loop` or `{` after a label\n@@ -11,7 +11,7 @@ LL +     let _ = 1 + 1;\n    |\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:6:13\n+  --> $DIR/recover-labeled-non-block-expr.rs:5:13\n    |\n LL |     'label: match () { () => {}, };\n    |             ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n@@ -23,7 +23,7 @@ LL +     match () { () => {}, };\n    |\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:7:13\n+  --> $DIR/recover-labeled-non-block-expr.rs:6:13\n    |\n LL |     'label: match () { () => break 'label, };\n    |             ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n@@ -34,7 +34,7 @@ LL |     'label: { match () { () => break 'label, } };\n    |             +                                  +\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:9:13\n+  --> $DIR/recover-labeled-non-block-expr.rs:8:13\n    |\n LL |     'label: match () { () => 'lp: loop { break 'lp 0 }, };\n    |             ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n@@ -45,7 +45,7 @@ LL |     'label: { match () { () => 'lp: loop { break 'lp 0 }, } };\n    |             +                                               +\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:12:22\n+  --> $DIR/recover-labeled-non-block-expr.rs:11:22\n    |\n LL |     let _i = 'label: match x {\n    |                      ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n@@ -60,7 +60,7 @@ LL ~     } };\n    |\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:26:24\n+  --> $DIR/recover-labeled-non-block-expr.rs:25:24\n    |\n LL |     let _val = 'label: (1, if other == 3 { break 'label (2, 3) } else { other });\n    |                        ^ expected `while`, `for`, `loop` or `{` after a label"}, {"sha": "c3235f06779b3ee6aacb1ec051ce2c68536c1195", "filename": "src/tools/clippy/tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,6 +1,5 @@\n #![warn(clippy::semicolon_if_nothing_returned)]\n #![allow(clippy::redundant_closure)]\n-#![feature(label_break_value)]\n #![feature(let_else)]\n \n fn get_unit() {}"}, {"sha": "78813e7cc1c39c5aa294f08db14ca9cfe0688a50", "filename": "src/tools/clippy/tests/ui/semicolon_if_nothing_returned.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.stderr?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,31 +1,31 @@\n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:10:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:9:5\n    |\n LL |     println!(\"Hello\")\n    |     ^^^^^^^^^^^^^^^^^ help: add a `;` here: `println!(\"Hello\");`\n    |\n    = note: `-D clippy::semicolon-if-nothing-returned` implied by `-D warnings`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:14:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:13:5\n    |\n LL |     get_unit()\n    |     ^^^^^^^^^^ help: add a `;` here: `get_unit();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:19:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:18:5\n    |\n LL |     y = x + 1\n    |     ^^^^^^^^^ help: add a `;` here: `y = x + 1;`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:25:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:24:9\n    |\n LL |         hello()\n    |         ^^^^^^^ help: add a `;` here: `hello();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:36:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:35:9\n    |\n LL |         ptr::drop_in_place(s.as_mut_ptr())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add a `;` here: `ptr::drop_in_place(s.as_mut_ptr());`"}, {"sha": "e68ca2c5907fcc55c1b36cabcb781d49d5ab48c3", "filename": "src/tools/rustfmt/tests/source/issue-3217.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-3217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-3217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fissue-3217.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {\n     let mut res = 0;\n     's_39: { if res == 0i32 { println!(\"Hello, world!\"); } }"}, {"sha": "403bf4c340a4eaf58e3958795bc85dd0df98056d", "filename": "src/tools/rustfmt/tests/target/issue-3217.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-3217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-3217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-3217.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {\n     let mut res = 0;\n     's_39: {"}, {"sha": "7f8d6ad12888c2a31fe3133427f7230799863f46", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9bc6359973482891699bbc5eecedaf34a60503/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=9b9bc6359973482891699bbc5eecedaf34a60503", "patch": "@@ -300,6 +300,12 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-x86_64-pc-windows-gnu\",\n+    \"windows-sys\",\n+    \"windows_aarch64_msvc\",\n+    \"windows_i686_gnu\",\n+    \"windows_i686_msvc\",\n+    \"windows_x86_64_gnu\",\n+    \"windows_x86_64_msvc\",\n ];\n \n const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &["}]}