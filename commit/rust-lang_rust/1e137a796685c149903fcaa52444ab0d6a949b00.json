{"sha": "1e137a796685c149903fcaa52444ab0d6a949b00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMTM3YTc5NjY4NWMxNDk5MDNmY2FhNTI0NDRhYjBkNmE5NDliMDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-15T22:18:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T07:06:28Z"}, "message": "fix drop typing; use same machinery for validating (sanity checking) dyn trait ptrs and slices", "tree": {"sha": "ee642a931d0607e2b3fd98a021c9c46574b9bc39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee642a931d0607e2b3fd98a021c9c46574b9bc39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e137a796685c149903fcaa52444ab0d6a949b00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e137a796685c149903fcaa52444ab0d6a949b00", "html_url": "https://github.com/rust-lang/rust/commit/1e137a796685c149903fcaa52444ab0d6a949b00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e137a796685c149903fcaa52444ab0d6a949b00/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09b15e9856c3ef77992cc30e772d29a896597041", "url": "https://api.github.com/repos/rust-lang/rust/commits/09b15e9856c3ef77992cc30e772d29a896597041", "html_url": "https://github.com/rust-lang/rust/commit/09b15e9856c3ef77992cc30e772d29a896597041"}], "stats": {"total": 178, "additions": 115, "deletions": 63}, "files": [{"sha": "82ff36d65acf0b0dce4b16597d661e5d9c2b559e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1e137a796685c149903fcaa52444ab0d6a949b00", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout, Primitive\n };\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::fx::{FxHashSet, FxHasher};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -24,7 +24,7 @@ use syntax::source_map::{self, Span};\n use syntax::ast::Mutability;\n \n use super::{\n-    Value, ValTy, Operand, MemPlace, MPlaceTy, Place,\n+    Value, ValTy, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n     Memory, Machine\n };\n \n@@ -442,10 +442,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+        &self,\n+        t: T,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> T {\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n-        let substituted = ty.subst(*self.tcx, substs);\n+        let substituted = t.subst(*self.tcx, substs);\n         self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted)\n     }\n \n@@ -844,35 +848,41 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 match dest.layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n                     | Some(ty::TyStr)\n                     | Some(ty::TySlice(_)) => {\n-                        // check the length\n+                        // check the length (for nicer error messages)\n                         let len_mplace = self.mplace_field(dest, 1)?;\n                         let len = self.read_scalar(len_mplace.into())?;\n                         let len = match len.to_bits(len_mplace.layout.size) {\n                             Err(_) => return validation_failure!(\"length is not a valid integer\", path),\n                             Ok(len) => len as u64,\n                         };\n-                        // get the fat ptr\n+                        // get the fat ptr, and recursively check it\n                         let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                        let mut path = path.clone();\n-                        self.dump_field_name(&mut path, dest.layout.ty, 0, variant).unwrap();\n-                        // check all fields\n-                        for i in 0..len {\n+                        assert_eq!(ptr.extra, PlaceExtra::Length(len));\n+                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                        if seen.insert(unpacked_ptr) {\n                             let mut path = path.clone();\n-                            self.dump_field_name(&mut path, ptr.layout.ty, i as usize, 0).unwrap();\n-                            let field = self.mplace_field(ptr, i)?;\n-                            self.validate_mplace(field, path, seen, todo)?;\n+                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n+                            todo.push((unpacked_ptr, path))\n                         }\n-                        // FIXME: For a TyStr, check that this is valid UTF-8\n                     },\n                     Some(ty::TyDynamic(..)) => {\n-                        let vtable_mplace = self.mplace_field(dest, 1)?;\n-                        let vtable = self.read_scalar(vtable_mplace.into())?;\n-                        if vtable.to_ptr().is_err() {\n-                            return validation_failure!(\"vtable address is not a pointer\", path);\n+                        // check the vtable (for nicer error messages)\n+                        let vtable = self.read_scalar(self.mplace_field(dest, 1)?.into())?;\n+                        let vtable = match vtable.to_ptr() {\n+                            Err(_) => return validation_failure!(\"vtable address is not a pointer\", path),\n+                            Ok(vtable) => vtable,\n+                        };\n+                        // get the fat ptr, and recursively check it\n+                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                        assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n+                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                        if seen.insert(unpacked_ptr) {\n+                            let mut path = path.clone();\n+                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n+                            todo.push((unpacked_ptr, path))\n                         }\n-                        // get the fat ptr\n-                        let _ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                        // FIXME: What can we verify about this?\n+                        // FIXME: More checks for the vtable... making sure it is exactly\n+                        // the one one would expect for this type.\n                     },\n                     Some(ty) =>\n                         bug!(\"Unexpected fat pointer target type {:?}\", ty),\n@@ -884,6 +894,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             let field = self.mplace_field(dest, i as u64)?;\n                             self.validate_mplace(field, path, seen, todo)?;\n                         }\n+                        // FIXME: For a TyStr, check that this is valid UTF-8.\n                     },\n                 }\n "}, {"sha": "b53aa4e2e65b8269bfbedec7ee5bfeae11d8879d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1e137a796685c149903fcaa52444ab0d6a949b00", "patch": "@@ -721,4 +721,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         };\n         Ok(OpTy { op, layout: place.layout })\n     }\n+\n+    /// Turn a place that is a dyn trait (i.e., PlaceExtra::Vtable and the appropriate layout)\n+    /// or a slice into the specific fixed-size place and layout that is given by the vtable/len.\n+    /// This \"unpacks\" the existential quantifier, so to speak.\n+    pub fn unpack_unsized_mplace(&self, mplace: MPlaceTy<'tcx>) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        trace!(\"Unpacking {:?} ({:?})\", *mplace, mplace.layout.ty);\n+        let layout = match mplace.extra {\n+            PlaceExtra::Vtable(vtable) => {\n+                // the drop function signature\n+                let drop_instance = self.read_drop_type_from_vtable(vtable)?;\n+                trace!(\"Found drop fn: {:?}\", drop_instance);\n+                let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n+                let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+                // the drop function takes *mut T where T is the type being dropped, so get that\n+                let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n+                let layout = self.layout_of(ty)?;\n+                // Sanity checks\n+                let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n+                assert_eq!(size, layout.size);\n+                assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+                // Done!\n+                layout\n+            },\n+            PlaceExtra::Length(len) => {\n+                let ty = self.tcx.mk_array(mplace.layout.field(self, 0)?.ty, len);\n+                self.layout_of(ty)?\n+            }\n+            PlaceExtra::None => bug!(\"Expected a fat pointer\"),\n+        };\n+        trace!(\"Unpacked type: {:?}\", layout.ty);\n+        Ok(MPlaceTy {\n+            mplace: MemPlace { extra: PlaceExtra::None, ..*mplace },\n+            layout\n+        })\n+    }\n }"}, {"sha": "598ee74fbfc46f04db76ddc37844364344a63ae5", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=1e137a796685c149903fcaa52444ab0d6a949b00", "patch": "@@ -1,57 +1,45 @@\n use rustc::mir::BasicBlock;\n-use rustc::ty::{self, Ty, layout::LayoutOf};\n+use rustc::ty::{self, layout::LayoutOf};\n use syntax::source_map::Span;\n \n use rustc::mir::interpret::{EvalResult};\n-use interpret::{Machine, EvalContext, PlaceTy, Value, OpTy, Operand};\n+use interpret::{Machine, EvalContext, PlaceTy, PlaceExtra, OpTy, Operand};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub(crate) fn drop_place(\n+    pub(crate) fn drop_in_place(\n         &mut self,\n         place: PlaceTy<'tcx>,\n         instance: ty::Instance<'tcx>,\n         span: Span,\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n-        let val = self.force_allocation(place)?.to_ref(&self);\n-        self.drop(val, instance, place.layout.ty, span, target)\n-    }\n-\n-    fn drop(\n-        &mut self,\n-        arg: Value,\n-        instance: ty::Instance<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-        target: BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"drop: {:?},\\n  {:?}, {:?}\", arg, ty.sty, instance.def);\n+        let place = self.force_allocation(place)?;\n \n-        let (instance, arg) = match ty.sty {\n+        let (instance, place) = match place.layout.ty.sty {\n             ty::TyDynamic(..) => {\n-                if let Value::ScalarPair(ptr, vtable) = arg {\n-                    // Figure out the specific drop function to call, and just pass along\n-                    // the thin part of the pointer.\n-                    let instance = self.read_drop_type_from_vtable(vtable.to_ptr()?)?;\n-                    trace!(\"Dropping via vtable: {:?}\", instance.def);\n-                    (instance, Value::Scalar(ptr))\n-                } else {\n-                    bug!(\"expected fat ptr, got {:?}\", arg);\n-                }\n+                // Dropping a trait object.\n+                let vtable = match place.extra {\n+                    PlaceExtra::Vtable(vtable) => vtable,\n+                    _ => bug!(\"Expected vtable when dropping {:#?}\", place),\n+                };\n+                let place = self.unpack_unsized_mplace(place)?;\n+                let instance = self.read_drop_type_from_vtable(vtable)?;\n+                (instance, place)\n             }\n-            _ => (instance, arg),\n+            _ => (instance, place),\n         };\n \n-        // the drop function expects a reference to the value\n-        let fn_sig = self.tcx.fn_sig(instance.def_id()).skip_binder().clone();\n+        let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n+        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+\n         let arg = OpTy {\n-            op: Operand::Immediate(arg),\n-            layout: self.layout_of(fn_sig.output())?,\n+            op: Operand::Immediate(place.to_ref(&self)),\n+            layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n-        trace!(\"Dropped type: {:?}\", fn_sig.output());\n \n         // This should always be (), but getting it from the sig seems\n         // easier than creating a layout of ()."}, {"sha": "5ceff57bfee47b3532f11911fe3af4069079467e", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=1e137a796685c149903fcaa52444ab0d6a949b00", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n                 let instance = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n-                self.drop_place(\n+                self.drop_in_place(\n                     place,\n                     instance,\n                     terminator.source_info.span,"}, {"sha": "45e70a9dbc96c999fa24768f0c4bb3f0d26e86dc", "filename": "src/test/ui/union-ub-fat-ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs?ref=1e137a796685c149903fcaa52444ab0d6a949b00", "patch": "@@ -66,16 +66,18 @@ trait Trait {}\n \n // OK\n const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n-// should lint\n+// bad\n const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+//~^ ERROR this constant likely exhibits undefined behavior\n // bad\n const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n //~^ ERROR this constant likely exhibits undefined behavior\n \n // OK\n const A2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n-// should lint\n+// bad\n const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+//~^ ERROR this constant likely exhibits undefined behavior\n // bad\n const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n //~^ ERROR this constant likely exhibits undefined behavior"}, {"sha": "924d0d667f27122b124c06672f38d4c1d5f24d1b", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e137a796685c149903fcaa52444ab0d6a949b00/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=1e137a796685c149903fcaa52444ab0d6a949b00", "patch": "@@ -1,43 +1,59 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:72:1\n+  --> $DIR/union-ub-fat-ptr.rs:70:1\n+   |\n+LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:73:1\n    |\n LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:80:1\n+  --> $DIR/union-ub-fat-ptr.rs:79:1\n+   |\n+LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:82:1\n    |\n LL | const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:84:1\n+  --> $DIR/union-ub-fat-ptr.rs:86:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to access memory with alignment N, but alignment N is required\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:87:1\n+  --> $DIR/union-ub-fat-ptr.rs:89:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a memory access tried to interpret some bytes as a pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:90:1\n+  --> $DIR/union-ub-fat-ptr.rs:92:1\n    |\n LL | const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered vtable address is not a pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}