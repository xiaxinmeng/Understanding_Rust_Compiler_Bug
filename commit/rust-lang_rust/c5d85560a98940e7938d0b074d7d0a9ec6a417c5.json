{"sha": "c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZDg1NTYwYTk4OTQwZTc5MzhkMGIwNzRkN2QwYTllYzZhNDE3YzU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-27T12:00:46Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-02T12:29:28Z"}, "message": "rand: remove (almost) all ~[]'s from Vec.\n\nThere are a few instances of them in tests which are using functions\nfrom std etc. that still are using ~[].", "tree": {"sha": "cb666339236d555a67c9bb6538f577f0f4e5d0cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb666339236d555a67c9bb6538f577f0f4e5d0cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "html_url": "https://github.com/rust-lang/rust/commit/c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c98713486579f7f18bed64c2a160f8ef89b5733f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c98713486579f7f18bed64c2a160f8ef89b5733f", "html_url": "https://github.com/rust-lang/rust/commit/c98713486579f7f18bed64c2a160f8ef89b5733f"}], "stats": {"total": 212, "additions": 106, "deletions": 106}, "files": [{"sha": "d44dfbef253780d591f50a4f86e1a1645f4d8e93", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -112,7 +112,7 @@ mod tests {\n         for _ in range(0, 20) {\n             let mut input = ~[];\n             for _ in range(0, 2000) {\n-                input.push_all(r.choose(words.as_slice()));\n+                input.push_all(r.choose(words.as_slice()).as_slice());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());"}, {"sha": "af63e52e885aa5ab0b3a22c92df82fa30dc699fb", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -91,18 +91,18 @@ pub struct Weighted<T> {\n /// ```rust\n /// use rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n ///\n-/// let wc = WeightedChoice::new(~[Weighted { weight: 2, item: 'a' },\n-///                                Weighted { weight: 4, item: 'b' },\n-///                                Weighted { weight: 1, item: 'c' }]);\n+/// let wc = WeightedChoice::new(vec!(Weighted { weight: 2, item: 'a' },\n+///                                   Weighted { weight: 4, item: 'b' },\n+///                                   Weighted { weight: 1, item: 'c' }));\n /// let mut rng = rand::task_rng();\n /// for _ in range(0, 16) {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));\n /// }\n /// ```\n pub struct WeightedChoice<T> {\n-    pub items: ~[Weighted<T>],\n-    pub weight_range: Range<uint>\n+    items: Vec<Weighted<T>>,\n+    weight_range: Range<uint>\n }\n \n impl<T: Clone> WeightedChoice<T> {\n@@ -112,7 +112,7 @@ impl<T: Clone> WeightedChoice<T> {\n     /// - `v` is empty\n     /// - the total weight is 0\n     /// - the total weight is larger than a `uint` can contain.\n-    pub fn new(mut items: ~[Weighted<T>]) -> WeightedChoice<T> {\n+    pub fn new(mut items: Vec<Weighted<T>>) -> WeightedChoice<T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n \n@@ -153,8 +153,8 @@ impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n         let sample_weight = self.weight_range.ind_sample(rng);\n \n         // short circuit when it's the first item\n-        if sample_weight < self.items[0].weight {\n-            return self.items[0].item.clone();\n+        if sample_weight < self.items.get(0).weight {\n+            return self.items.get(0).item.clone();\n         }\n \n         let mut idx = 0;\n@@ -169,7 +169,7 @@ impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n         // one is exactly the total weight.)\n         while modifier > 1 {\n             let i = idx + modifier / 2;\n-            if self.items[i].weight <= sample_weight {\n+            if self.items.get(i).weight <= sample_weight {\n                 // we're small, so look to the right, but allow this\n                 // exact element still.\n                 idx = i;\n@@ -182,7 +182,7 @@ impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n             }\n             modifier /= 2;\n         }\n-        return self.items[idx + 1].item.clone();\n+        return self.items.get(idx + 1).item.clone();\n     }\n }\n \n@@ -297,54 +297,54 @@ mod tests {\n             }}\n         );\n \n-        t!(~[Weighted { weight: 1, item: 10}], ~[10]);\n+        t!(vec!(Weighted { weight: 1, item: 10}), [10]);\n \n         // skip some\n-        t!(~[Weighted { weight: 0, item: 20},\n-             Weighted { weight: 2, item: 21},\n-             Weighted { weight: 0, item: 22},\n-             Weighted { weight: 1, item: 23}],\n-           ~[21,21, 23]);\n+        t!(vec!(Weighted { weight: 0, item: 20},\n+                Weighted { weight: 2, item: 21},\n+                Weighted { weight: 0, item: 22},\n+                Weighted { weight: 1, item: 23}),\n+           [21,21, 23]);\n \n         // different weights\n-        t!(~[Weighted { weight: 4, item: 30},\n-             Weighted { weight: 3, item: 31}],\n-           ~[30,30,30,30, 31,31,31]);\n+        t!(vec!(Weighted { weight: 4, item: 30},\n+                Weighted { weight: 3, item: 31}),\n+           [30,30,30,30, 31,31,31]);\n \n         // check that we're binary searching\n         // correctly with some vectors of odd\n         // length.\n-        t!(~[Weighted { weight: 1, item: 40},\n-             Weighted { weight: 1, item: 41},\n-             Weighted { weight: 1, item: 42},\n-             Weighted { weight: 1, item: 43},\n-             Weighted { weight: 1, item: 44}],\n-           ~[40, 41, 42, 43, 44]);\n-        t!(~[Weighted { weight: 1, item: 50},\n-             Weighted { weight: 1, item: 51},\n-             Weighted { weight: 1, item: 52},\n-             Weighted { weight: 1, item: 53},\n-             Weighted { weight: 1, item: 54},\n-             Weighted { weight: 1, item: 55},\n-             Weighted { weight: 1, item: 56}],\n-           ~[50, 51, 52, 53, 54, 55, 56]);\n+        t!(vec!(Weighted { weight: 1, item: 40},\n+                Weighted { weight: 1, item: 41},\n+                Weighted { weight: 1, item: 42},\n+                Weighted { weight: 1, item: 43},\n+                Weighted { weight: 1, item: 44}),\n+           [40, 41, 42, 43, 44]);\n+        t!(vec!(Weighted { weight: 1, item: 50},\n+                Weighted { weight: 1, item: 51},\n+                Weighted { weight: 1, item: 52},\n+                Weighted { weight: 1, item: 53},\n+                Weighted { weight: 1, item: 54},\n+                Weighted { weight: 1, item: 55},\n+                Weighted { weight: 1, item: 56}),\n+           [50, 51, 52, 53, 54, 55, 56]);\n     }\n \n     #[test] #[should_fail]\n     fn test_weighted_choice_no_items() {\n-        WeightedChoice::<int>::new(~[]);\n+        WeightedChoice::<int>::new(vec!());\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(~[Weighted { weight: 0, item: 0},\n-                              Weighted { weight: 0, item: 1}]);\n+        WeightedChoice::new(vec!(Weighted { weight: 0, item: 0},\n+                                 Weighted { weight: 0, item: 1}));\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_weight_overflows() {\n         let x = (-1) as uint / 2; // x + x + 2 is the overflow\n-        WeightedChoice::new(~[Weighted { weight: x, item: 0 },\n-                              Weighted { weight: 1, item: 1 },\n-                              Weighted { weight: x, item: 2 },\n-                              Weighted { weight: 1, item: 3 }]);\n+        WeightedChoice::new(vec!(Weighted { weight: x, item: 0 },\n+                                 Weighted { weight: 1, item: 1 },\n+                                 Weighted { weight: x, item: 2 },\n+                                 Weighted { weight: 1, item: 3 }));\n     }\n }"}, {"sha": "23371ed2bd8bc4ac8405e97d5e25f895c37bbdf7", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -441,7 +441,6 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n mod test {\n     use super::{IsaacRng, Isaac64Rng};\n     use {Rng, SeedableRng, task_rng};\n-    use std::slice;\n \n     #[test]\n     fn test_rng_32_rand_seeded() {\n@@ -479,7 +478,7 @@ mod test {\n         let mut r: IsaacRng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_str(100);\n \n-        r.reseed(s);\n+        r.reseed(s.as_slice());\n \n         let string2 = r.gen_ascii_str(100);\n         assert_eq!(string1, string2);\n@@ -490,7 +489,7 @@ mod test {\n         let mut r: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_str(100);\n \n-        r.reseed(s);\n+        r.reseed(s.as_slice());\n \n         let string2 = r.gen_ascii_str(100);\n         assert_eq!(string1, string2);\n@@ -501,43 +500,43 @@ mod test {\n         let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = slice::from_fn(10, |_| ra.next_u32());\n+        let v = Vec::from_fn(10, |_| ra.next_u32());\n         assert_eq!(v,\n-                   ~[2558573138, 873787463, 263499565, 2103644246, 3595684709,\n-                     4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n+                   vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n+                        4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n \n         let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u32(); }\n \n-        let v = slice::from_fn(10, |_| rb.next_u32());\n+        let v = Vec::from_fn(10, |_| rb.next_u32());\n         assert_eq!(v,\n-                   ~[3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n-                     1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n+                   vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n+                        1576568959, 3507990155, 179069555, 141456972, 2478885421));\n     }\n     #[test]\n     fn test_rng_64_true_values() {\n         let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = slice::from_fn(10, |_| ra.next_u64());\n+        let v = Vec::from_fn(10, |_| ra.next_u64());\n         assert_eq!(v,\n-                   ~[547121783600835980, 14377643087320773276, 17351601304698403469,\n-                     1238879483818134882, 11952566807690396487, 13970131091560099343,\n-                     4469761996653280935, 15552757044682284409, 6860251611068737823,\n-                     13722198873481261842]);\n+                   vec!(547121783600835980, 14377643087320773276, 17351601304698403469,\n+                        1238879483818134882, 11952566807690396487, 13970131091560099343,\n+                        4469761996653280935, 15552757044682284409, 6860251611068737823,\n+                        13722198873481261842));\n \n         let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u64(); }\n \n-        let v = slice::from_fn(10, |_| rb.next_u64());\n+        let v = Vec::from_fn(10, |_| rb.next_u64());\n         assert_eq!(v,\n-                   ~[18143823860592706164, 8491801882678285927, 2699425367717515619,\n-                     17196852593171130876, 2606123525235546165, 15790932315217671084,\n-                     596345674630742204, 9947027391921273664, 11788097613744130851,\n-                     10391409374914919106]);\n+                   vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n+                        17196852593171130876, 2606123525235546165, 15790932315217671084,\n+                        596345674630742204, 9947027391921273664, 11788097613744130851,\n+                        10391409374914919106));\n     }\n }"}, {"sha": "2b710baeff0744e9343de18f4ccdcded5c8b5faf", "filename": "src/librand/lib.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -73,6 +73,7 @@ println!(\"{:?}\", tuple_ptr)\n #![feature(macro_rules, managed_boxes, phase)]\n \n #![allow(visible_private_types)] // NOTE: remove after a stage0 snap\n+#![deny(deprecated_owned_vector)]\n \n #[cfg(test)]\n #[phase(syntax, link)] extern crate log;\n@@ -82,7 +83,6 @@ use std::io::IoResult;\n use std::kinds::marker;\n use std::local_data;\n use std::str;\n-use std::slice;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use os::OSRng;\n@@ -199,12 +199,12 @@ pub trait Rng {\n     /// use rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n-    /// let x: ~[uint] = rng.gen_vec(10);\n-    /// println!(\"{:?}\", x);\n-    /// println!(\"{:?}\", rng.gen_vec::<(f64, bool)>(5));\n+    /// let x: Vec<uint> = rng.gen_vec(10);\n+    /// println!(\"{}\", x);\n+    /// println!(\"{}\", rng.gen_vec::<(f64, bool)>(5));\n     /// ```\n-    fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {\n-        slice::from_fn(len, |_| self.gen())\n+    fn gen_vec<T: Rand>(&mut self, len: uint) -> Vec<T> {\n+        Vec::from_fn(len, |_| self.gen())\n     }\n \n     /// Generate a random value in the range [`low`, `high`). Fails if\n@@ -300,12 +300,11 @@ pub trait Rng {\n     /// ```rust\n     /// use rand::{task_rng, Rng};\n     ///\n-    /// println!(\"{:?}\", task_rng().shuffle(~[1,2,3]));\n+    /// println!(\"{}\", task_rng().shuffle(vec!(1,2,3)));\n     /// ```\n-    fn shuffle<T>(&mut self, values: ~[T]) -> ~[T] {\n-        let mut v = values;\n-        self.shuffle_mut(v);\n-        v\n+    fn shuffle<T>(&mut self, mut values: Vec<T>) -> Vec<T> {\n+        self.shuffle_mut(values.as_mut_slice());\n+        values\n     }\n \n     /// Shuffle a mutable vector in place.\n@@ -341,10 +340,10 @@ pub trait Rng {\n     ///\n     /// let mut rng = task_rng();\n     /// let sample = rng.sample(range(1, 100), 5);\n-    /// println!(\"{:?}\", sample);\n+    /// println!(\"{}\", sample);\n     /// ```\n-    fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A] {\n-        let mut reservoir : ~[A] = slice::with_capacity(n);\n+    fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> Vec<A> {\n+        let mut reservoir = Vec::with_capacity(n);\n         for (i, elem) in iter.enumerate() {\n             if i < n {\n                 reservoir.push(elem);\n@@ -353,7 +352,7 @@ pub trait Rng {\n \n             let k = self.gen_range(0, i + 1);\n             if k < reservoir.len() {\n-                reservoir[k] = elem\n+                *reservoir.get_mut(k) = elem\n             }\n         }\n         reservoir\n@@ -695,7 +694,6 @@ pub struct Closed01<F>(F);\n \n #[cfg(test)]\n mod test {\n-    use std::slice;\n     use super::{Rng, task_rng, random, SeedableRng, StdRng};\n \n     struct ConstRng { i: u64 }\n@@ -714,8 +712,8 @@ mod test {\n         let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n                        80, 81, 82, 83, 84, 85, 86, 87];\n         for &n in lengths.iter() {\n-            let mut v = slice::from_elem(n, 0u8);\n-            r.fill_bytes(v);\n+            let mut v = Vec::from_elem(n, 0u8);\n+            r.fill_bytes(v.as_mut_slice());\n \n             // use this to get nicer error messages.\n             for (i, &byte) in v.iter().enumerate() {\n@@ -813,16 +811,16 @@ mod test {\n     #[test]\n     fn test_shuffle() {\n         let mut r = task_rng();\n-        let empty: ~[int] = ~[];\n-        assert_eq!(r.shuffle(~[]), empty);\n-        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        let empty = Vec::<int>::new();\n+        assert_eq!(r.shuffle(vec!()), empty);\n+        assert_eq!(r.shuffle(vec!(1, 1, 1)), vec!(1, 1, 1));\n     }\n \n     #[test]\n     fn test_task_rng() {\n         let mut r = task_rng();\n         r.gen::<int>();\n-        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.shuffle(vec!(1, 1, 1)), vec!(1, 1, 1));\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n \n@@ -844,7 +842,7 @@ mod test {\n         let max_val = 100;\n \n         let mut r = task_rng();\n-        let vals = range(min_val, max_val).collect::<~[int]>();\n+        let vals = range(min_val, max_val).collect::<Vec<int>>();\n         let small_sample = r.sample(vals.iter(), 5);\n         let large_sample = r.sample(vals.iter(), vals.len() + 5);\n \n@@ -870,7 +868,7 @@ mod test {\n         let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_str(100);\n \n-        r.reseed(s);\n+        r.reseed(s.as_slice());\n \n         let string2 = r.gen_ascii_str(100);\n         assert_eq!(string1, string2);"}, {"sha": "762e09fb3f51130efc0aaad3cf4478a6cbf7902c", "filename": "src/librand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fos.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -204,7 +204,7 @@ mod test {\n     #[test]\n     fn test_os_rng_tasks() {\n \n-        let mut txs = ~[];\n+        let mut txs = vec!();\n         for _ in range(0, 20) {\n             let (tx, rx) = channel();\n             txs.push(tx);"}, {"sha": "dff821d83298f93f716bdc5656ac8edefcdfc21c", "filename": "src/librand/reader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -68,6 +68,7 @@ impl<R: Reader> Rng for ReaderRng<R> {\n }\n \n #[cfg(test)]\n+#[allow(deprecated_owned_vector)]\n mod test {\n     use super::ReaderRng;\n     use std::io::MemReader;"}, {"sha": "fe2ff319c1cadb2ad4ffb0e440fa9d475648278a", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -205,8 +205,8 @@ mod test {\n     #[test]\n     fn test_rng_fill_bytes() {\n         use task_rng;\n-        let mut v = ~[0u8, .. fill_bytes_v_len];\n-        task_rng().fill_bytes(v);\n+        let mut v = Vec::from_elem(fill_bytes_v_len, 0u8);\n+        task_rng().fill_bytes(v.as_mut_slice());\n \n         // Sanity test: if we've gotten here, `fill_bytes` has not infinitely\n         // recursed."}, {"sha": "3e1f62da039ef55fd93c9666104ab01e21770a79", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -3442,19 +3442,21 @@ mod tests {\n \n     #[test]\n     fn test_sort() {\n+        use realstd::slice::Vector;\n+        use realstd::clone::Clone;\n         for len in range(4u, 25) {\n             for _ in range(0, 100) {\n                 let mut v = task_rng().gen_vec::<uint>(len);\n                 let mut v1 = v.clone();\n \n-                v.sort();\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+                v.as_mut_slice().sort();\n+                assert!(v.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.sort_by(|a, b| a.cmp(b));\n-                assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n+                v1.as_mut_slice().sort_by(|a, b| a.cmp(b));\n+                assert!(v1.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.sort_by(|a, b| b.cmp(a));\n-                assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+                v1.as_mut_slice().sort_by(|a, b| b.cmp(a));\n+                assert!(v1.as_slice().windows(2).all(|w| w[0] >= w[1]));\n             }\n         }\n \n@@ -4487,8 +4489,8 @@ mod bench {\n     fn sort_random_small(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[u64] = rng.gen_vec(5);\n-            v.sort();\n+            let mut v = rng.gen_vec::<u64>(5);\n+            v.as_mut_slice().sort();\n         });\n         bh.bytes = 5 * mem::size_of::<u64>() as u64;\n     }\n@@ -4497,8 +4499,8 @@ mod bench {\n     fn sort_random_medium(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[u64] = rng.gen_vec(100);\n-            v.sort();\n+            let mut v = rng.gen_vec::<u64>(100);\n+            v.as_mut_slice().sort();\n         });\n         bh.bytes = 100 * mem::size_of::<u64>() as u64;\n     }\n@@ -4507,8 +4509,8 @@ mod bench {\n     fn sort_random_large(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[u64] = rng.gen_vec(10000);\n-            v.sort();\n+            let mut v = rng.gen_vec::<u64>(10000);\n+            v.as_mut_slice().sort();\n         });\n         bh.bytes = 10000 * mem::size_of::<u64>() as u64;\n     }\n@@ -4528,7 +4530,7 @@ mod bench {\n     fn sort_big_random_small(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[BigSortable] = rng.gen_vec(5);\n+            let mut v = rng.gen_vec::<BigSortable>(5);\n             v.sort();\n         });\n         bh.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n@@ -4538,7 +4540,7 @@ mod bench {\n     fn sort_big_random_medium(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[BigSortable] = rng.gen_vec(100);\n+            let mut v = rng.gen_vec::<BigSortable>(100);\n             v.sort();\n         });\n         bh.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n@@ -4548,7 +4550,7 @@ mod bench {\n     fn sort_big_random_large(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[BigSortable] = rng.gen_vec(10000);\n+            let mut v = rng.gen_vec::<BigSortable>(10000);\n             v.sort();\n         });\n         bh.bytes = 10000 * mem::size_of::<BigSortable>() as u64;"}, {"sha": "f70cb908b52d0a5d62d2022fd929dcce9493da13", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -196,7 +196,7 @@ impl Uuid {\n     pub fn new_v4() -> Uuid {\n         let ub = rand::task_rng().gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, ub);\n+        slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n         uuid.set_variant(VariantRFC4122);\n         uuid.set_version(Version4Random);\n         uuid\n@@ -510,7 +510,7 @@ impl rand::Rand for Uuid {\n     fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n         let ub = rng.gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, ub);\n+        slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n         uuid.set_variant(VariantRFC4122);\n         uuid.set_version(Version4Random);\n         uuid"}, {"sha": "0190355e127ca690b4cd911f056981baed042115", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d85560a98940e7938d0b074d7d0a9ec6a417c5/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=c5d85560a98940e7938d0b074d7d0a9ec6a417c5", "patch": "@@ -52,7 +52,7 @@ pub fn main() {\n             // work out the total number of comparisons required to sort\n             // this array...\n             let mut count = 0;\n-            main.clone().sort_by(|a, b| { count += 1; a.cmp(b) });\n+            main.clone().as_mut_slice().sort_by(|a, b| { count += 1; a.cmp(b) });\n \n             // ... and then fail on each and every single one.\n             for fail_countdown in range(0, count) {\n@@ -67,7 +67,7 @@ pub fn main() {\n                 task::try(proc() {\n                         let mut v = v;\n                         let mut fail_countdown = fail_countdown;\n-                        v.sort_by(|a, b| {\n+                        v.as_mut_slice().sort_by(|a, b| {\n                                 if fail_countdown == 0 {\n                                     fail!()\n                                 }"}]}