{"sha": "fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMGQxY2I3ZDhlNTZkMmZjOGYyZTgxMjhlNTM0YmVlMGRkZTdkMWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T18:28:38Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T18:35:05Z"}, "message": "rustc: Make mk_imm_tup() take an interior vector", "tree": {"sha": "5e75f427e74e5b70f2f5d2695b24d5160c524fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e75f427e74e5b70f2f5d2695b24d5160c524fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "html_url": "https://github.com/rust-lang/rust/commit/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b841152a4007d9251803bbbb7e4f9d7633f3c51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b841152a4007d9251803bbbb7e4f9d7633f3c51d", "html_url": "https://github.com/rust-lang/rust/commit/b841152a4007d9251803bbbb7e4f9d7633f3c51d"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "8dd6d3226da1632e58090b83047a991fadd5bea8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 53, "deletions": 45, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "patch": "@@ -1209,22 +1209,22 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n             }\n             case (ty::ty_fn(_, _, _, _, _)) {\n                 ret ty::mk_imm_tup(ccx.tcx,\n-                                   [ty::mk_imm_box(ccx.tcx,\n-                                                   ty::mk_nil(ccx.tcx)),\n-                                    ty::mk_imm_box(ccx.tcx,\n-                                                   ty::mk_nil(ccx.tcx))]);\n+                                   ~[ty::mk_imm_box(ccx.tcx,\n+                                                    ty::mk_nil(ccx.tcx)),\n+                                     ty::mk_imm_box(ccx.tcx,\n+                                                    ty::mk_nil(ccx.tcx))]);\n             }\n             case (ty::ty_obj(_)) {\n                 ret ty::mk_imm_tup(ccx.tcx,\n-                                   [ty::mk_imm_box(ccx.tcx,\n-                                                   ty::mk_nil(ccx.tcx)),\n-                                    ty::mk_imm_box(ccx.tcx,\n-                                                   ty::mk_nil(ccx.tcx))]);\n+                                   ~[ty::mk_imm_box(ccx.tcx,\n+                                                    ty::mk_nil(ccx.tcx)),\n+                                     ty::mk_imm_box(ccx.tcx,\n+                                                    ty::mk_nil(ccx.tcx))]);\n             }\n             case (ty::ty_res(_, ?sub, ?tps)) {\n                 auto sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n-                ret ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx),\n-                                             simplify_type(ccx, sub1)]);\n+                ret ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx),\n+                                              simplify_type(ccx, sub1)]);\n             }\n             case (_) { ret typ; }\n         }\n@@ -1256,7 +1256,11 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n     auto max_size = 0u;\n     auto variants = ty::tag_variants(cx.tcx, tid);\n     for (ty::variant_info variant in variants) {\n-        auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, variant.args));\n+        // TODO: Remove this vec->ivec conversion.\n+        auto args = ~[];\n+        for (ty::t typ in variant.args) { args += ~[typ]; }\n+\n+        auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, args));\n         // Perform any type parameter substitutions.\n \n         tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n@@ -1469,7 +1473,11 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t, ValueRef base, &vec[int] ixs) ->\n     // flattened the incoming structure.\n \n     auto s = split_type(cx.fcx.lcx.ccx, t, ixs, 0u);\n-    auto prefix_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, s.prefix);\n+\n+    auto args = ~[];\n+    for (ty::t typ in s.prefix) { args += ~[typ]; }\n+    auto prefix_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, args);\n+\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n@@ -1498,11 +1506,11 @@ fn GEP_tag(@block_ctxt cx, ValueRef llblobptr, &ast::def_id tag_id,\n     auto elem_ty = ty::mk_nil(cx.fcx.lcx.ccx.tcx); // typestate infelicity\n \n     auto i = 0;\n-    let vec[ty::t] true_arg_tys = [];\n+    let ty::t[] true_arg_tys = ~[];\n     for (ty::t aty in arg_tys) {\n         auto arg_ty =\n             ty::substitute_type_params(cx.fcx.lcx.ccx.tcx, ty_substs, aty);\n-        true_arg_tys += [arg_ty];\n+        true_arg_tys += ~[arg_ty];\n         if (i == ix) { elem_ty = arg_ty; }\n         i += 1;\n     }\n@@ -1559,7 +1567,7 @@ fn trans_malloc_boxed(&@block_ctxt cx, ty::t t) -> result {\n         ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n                        // The mk_int here is the space being\n                        // reserved for the refcount.\n-                       [ty::mk_int(cx.fcx.lcx.ccx.tcx), t]);\n+                       ~[ty::mk_int(cx.fcx.lcx.ccx.tcx), t]);\n     auto box_ptr = ty::mk_imm_box(cx.fcx.lcx.ccx.tcx, t);\n     auto sz = size_of(cx, boxed_body);\n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n@@ -2111,9 +2119,8 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n                   ty::t inner_t, &vec[ty::t] tps) -> result {\n     auto ccx = cx.fcx.lcx.ccx;\n-\n     auto inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n-    auto tup_ty = ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n+    auto tup_ty = ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx), inner_t_s]);\n     auto drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n@@ -5343,17 +5350,21 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n                 vec::push[ValueRef](bound_vals, arg.val);\n-                vec::push[ty::t](bound_tys,\n-                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+                bound_tys += [ty::expr_ty(cx.fcx.lcx.ccx.tcx, e)];\n             }\n \n             // Synthesize a closure type.\n \n             // First, synthesize a tuple type containing the types of all the\n             // bound expressions.\n             // bindings_ty = [bound_ty1, bound_ty2, ...]\n+\n+            // TODO: Remove this vec->ivec conversion.\n+            auto bound_tys_ivec = ~[];\n+            for (ty::t typ in bound_tys) { bound_tys_ivec += ~[typ]; }\n+\n             let ty::t bindings_ty =\n-                ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, bound_tys);\n+                ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, bound_tys_ivec);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty::t structure that has the same \"shape\" as the LLVM type\n@@ -5362,18 +5373,18 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             // Make a vector that contains ty_param_count copies of tydesc_ty.\n             // (We'll need room for that many tydescs in the closure.)\n             let ty::t tydesc_ty = ty::mk_type(cx.fcx.lcx.ccx.tcx);\n-            let vec[ty::t] captured_tys =\n-                vec::init_elt[ty::t](tydesc_ty, ty_param_count);\n+            let ty::t[] captured_tys =\n+                std::ivec::init_elt[ty::t](tydesc_ty, ty_param_count);\n \n             // Get all the types we've got (some of which we synthesized\n             // ourselves) into a vector.  The whole things ends up looking\n             // like:\n \n             // closure_tys = [tydesc_ty, outgoing_fty, [bound_ty1, bound_ty2,\n             // ...], [tydesc_ty, tydesc_ty, ...]]\n-            let vec[ty::t] closure_tys =\n-                [tydesc_ty, outgoing_fty, bindings_ty,\n-                 ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, captured_tys)];\n+            let ty::t[] closure_tys =\n+                ~[tydesc_ty, outgoing_fty, bindings_ty,\n+                  ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, captured_tys)];\n \n             // Finally, synthesize a type for that whole vector.\n             let ty::t closure_ty =\n@@ -5745,8 +5756,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n     auto body = bcx.build.GEP(vec_val, [C_int(0), C_int(abi::vec_elt_data)]);\n     auto pseudo_tup_ty =\n         ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n-                       vec::init_elt[ty::t](unit_ty,\n-                                            vec::len[@ast::expr](args)));\n+                       std::ivec::init_elt[ty::t](unit_ty, vec::len(args)));\n     let int i = 0;\n     for (@ast::expr e in args) {\n         auto src_res = trans_expr(bcx, e);\n@@ -6524,7 +6534,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     // Translate the arguments, remembering their types and where the values\n     // ended up.\n \n-    let vec[ty::t] arg_tys = [];\n+    let ty::t[] arg_tys = ~[];\n     let vec[ValueRef] arg_vals = [];\n     for (@ast::expr e in args) {\n         auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n@@ -6535,7 +6545,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n         bcx = arg.bcx;\n \n         vec::push[ValueRef](arg_vals, arg.val);\n-        vec::push[ty::t](arg_tys, e_ty);\n+        arg_tys += ~[e_ty];\n     }\n     // Make the tuple.\n \n@@ -6785,13 +6795,13 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // the outer object?\n     let vec[ast::anon_obj_field] additional_fields = [];\n     let vec[result] additional_field_vals = [];\n-    let vec[ty::t] additional_field_tys = [];\n+    let ty::t[] additional_field_tys = ~[];\n     alt (anon_obj.fields) {\n         case (none) { }\n         case (some(?fields)) {\n             additional_fields = fields;\n             for (ast::anon_obj_field f in fields) {\n-                additional_field_tys += [node_id_type(ccx, f.id)];\n+                additional_field_tys += ~[node_id_type(ccx, f.id)];\n                 additional_field_vals += [trans_expr(bcx, f.expr)];\n             }\n         }\n@@ -6895,18 +6905,18 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         // actually supporting typarams for anon objs yet, but let's\n         // create space for them in case we ever want them.\n         let ty::t tydesc_ty = ty::mk_type(ccx.tcx);\n-        let vec[ty::t] tps = [];\n+        let ty::t[] tps = ~[];\n         for (ast::ty_param tp in ty_params) {\n-            vec::push[ty::t](tps, tydesc_ty);\n+            tps += ~[tydesc_ty];\n         }\n         // Synthesize a tuple type for typarams: [typaram, ...]\n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n \n         // Tuple type for body: \n         // [tydesc_ty, [typaram, ...], [field, ...], with_obj]\n         let ty::t body_ty =\n-            ty::mk_imm_tup(ccx.tcx, [tydesc_ty, typarams_ty, \n-                                     fields_ty, with_obj_ty]);\n+            ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty,\n+                                      fields_ty, with_obj_ty]);\n \n         // Hand this type we've synthesized off to trans_malloc_boxed, which\n         // allocates a box, including space for a refcount.\n@@ -7498,9 +7508,9 @@ fn arg_tys_of_fn(&@crate_ctxt ccx,ast::node_id id) -> vec[ty::arg] {\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n     auto bcx = llstaticallocas_block_ctxt(fcx);\n-    let vec[ty::t] field_tys = [];\n+    let ty::t[] field_tys = ~[];\n     for (ast::obj_field f in bcx.fcx.lcx.obj_fields) {\n-        field_tys += [node_id_type(bcx.fcx.lcx.ccx, f.id)];\n+        field_tys += ~[node_id_type(bcx.fcx.lcx.ccx, f.id)];\n     }\n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n@@ -7761,24 +7771,22 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     } else {\n         // Otherwise, we have to synthesize a big structural type for the\n         // object body.\n-        let vec[ty::t] obj_fields = [];\n-        for (ty::arg a in arg_tys) { vec::push[ty::t](obj_fields, a.ty); }\n+        let ty::t[] obj_fields = ~[];\n+        for (ty::arg a in arg_tys) { obj_fields += ~[a.ty]; }\n \n         // Tuple type for fields: [field, ...]\n         let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n \n         auto tydesc_ty = ty::mk_type(ccx.tcx);\n-        let vec[ty::t] tps = [];\n-        for (ast::ty_param tp in ty_params) {\n-            vec::push[ty::t](tps, tydesc_ty);\n-        }\n+        let ty::t[] tps = ~[];\n+        for (ast::ty_param tp in ty_params) { tps += ~[tydesc_ty]; }\n \n         // Tuple type for typarams: [typaram, ...]\n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n \n         // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n         let ty::t body_ty =\n-            ty::mk_imm_tup(ccx.tcx, [tydesc_ty, typarams_ty, fields_ty]);\n+            ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty, fields_ty]);\n \n         // Hand this type we've synthesized off to trans_malloc_boxed, which\n         // allocates a box, including space for a refcount.\n@@ -7879,7 +7887,7 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n     auto arg_t = arg_tys_of_fn(cx.ccx, ctor_id).(0).ty;\n-    auto tup_t = ty::mk_imm_tup(cx.ccx.tcx, [ty::mk_int(cx.ccx.tcx), arg_t]);\n+    auto tup_t = ty::mk_imm_tup(cx.ccx.tcx, ~[ty::mk_int(cx.ccx.tcx), arg_t]);\n     auto arg = load_if_immediate\n         (bcx, fcx.llargs.get(dtor.decl.inputs.(0).id), arg_t);\n "}, {"sha": "29df9cc9c84c1f0b93d107e9c10d81bdc7fbddfa", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "patch": "@@ -587,7 +587,7 @@ fn mk_task(&ctxt cx) -> t { ret gen_ty(cx, ty_task); }\n \n fn mk_tup(&ctxt cx, &mt[] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n \n-fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n+fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n     // TODO: map\n \n     let ty::mt[] mts = ~[];\n@@ -1055,7 +1055,11 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n         case (ty_tag(?did, ?tps)) {\n             auto variants = tag_variants(cx, did);\n             for (variant_info variant in variants) {\n-                auto tup_ty = mk_imm_tup(cx, variant.args);\n+                // TODO: Remove this vec->ivec conversion.\n+                auto args = ~[];\n+                for (ty::t arg in variant.args) { args += ~[arg]; }\n+\n+                auto tup_ty = mk_imm_tup(cx, args);\n                 // Perform any type parameter substitutions.\n \n                 tup_ty = substitute_type_params(cx, tps, tup_ty);\n@@ -1229,7 +1233,12 @@ fn type_owns_heap_mem(&ctxt cx, &t ty) -> bool {\n         case (ty_tag(?did, ?tps)) {\n             auto variants = tag_variants(cx, did);\n             for (variant_info variant in variants) {\n-                auto tup_ty = mk_imm_tup(cx, variant.args);\n+                // TODO: Remove this vec->ivec conversion.\n+                auto args = ~[];\n+                for (ty::t arg in variant.args) { args += ~[arg]; }\n+\n+                auto tup_ty = mk_imm_tup(cx, args);\n+\n                 // Perform any type parameter substitutions.\n                 tup_ty = substitute_type_params(cx, tps, tup_ty);\n                 if (type_owns_heap_mem(cx, tup_ty)) { result = true; }"}]}