{"sha": "e87205c578cabb5fe42131db83981ffe66a5c043", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NzIwNWM1NzhjYWJiNWZlNDIxMzFkYjgzOTgxZmZlNjZhNWMwNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-08T10:01:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-08T10:01:36Z"}, "message": "auto merge of #9658 : michaelwoerister/rust/namespace_fixes, r=jdm\n\nThis should fix some outstanding namespace issues. It also fixes an issue with LLVM metadata uniquing that caused an LLVM assertion when compiling libstd.\r\n\r\nOne thing to keep in mind is that the `-O` flag and the debug info flags are essentially incompatible. It may work but I would not consider this in any way supported at the moment. On the other hand, there is also good news: With the changes in this PR I am able to compile all of rust with extra-debug-info:\r\n```\r\nmake RUSTFLAGS_STAGE2='-Zextra-debug-info' check\r\n```\r\ncompiles the whole thing without warning and passes the whole test suite (given that `configure` is run with `--disable-optimize`). That's kind of nice `:)` Still, I'm reluctant to automatically close the related issues (#9167, #9190, #9268) without confirmation from the openers. I'll post to the individual threads once this gets merged.", "tree": {"sha": "552fbc08261d9fc19bdbcd8b44f26b28bed8da55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/552fbc08261d9fc19bdbcd8b44f26b28bed8da55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e87205c578cabb5fe42131db83981ffe66a5c043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e87205c578cabb5fe42131db83981ffe66a5c043", "html_url": "https://github.com/rust-lang/rust/commit/e87205c578cabb5fe42131db83981ffe66a5c043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e87205c578cabb5fe42131db83981ffe66a5c043/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9196290af3934481bd413e11057725f248fd104", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9196290af3934481bd413e11057725f248fd104", "html_url": "https://github.com/rust-lang/rust/commit/c9196290af3934481bd413e11057725f248fd104"}, {"sha": "85deeeab59e7b5845590b40d8a430b51580f1428", "url": "https://api.github.com/repos/rust-lang/rust/commits/85deeeab59e7b5845590b40d8a430b51580f1428", "html_url": "https://github.com/rust-lang/rust/commit/85deeeab59e7b5845590b40d8a430b51580f1428"}], "stats": {"total": 331, "additions": 109, "deletions": 222}, "files": [{"sha": "1c56f699c130d78f615f4dba098c597247b61333", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=e87205c578cabb5fe42131db83981ffe66a5c043", "patch": "@@ -1968,7 +1968,8 @@ pub mod llvm {\n                                              DerivedFrom: DIType,\n                                              Elements: DIArray,\n                                              RunTimeLang: c_uint,\n-                                             VTableHolder: ValueRef)\n+                                             VTableHolder: ValueRef,\n+                                             UniqueId: *c_char)\n                                              -> DICompositeType;\n \n         #[fast_ffi]"}, {"sha": "9b6db062233a5f1aff37d00926b87aac0b611052", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e87205c578cabb5fe42131db83981ffe66a5c043", "patch": "@@ -3119,11 +3119,6 @@ pub fn trans_crate(sess: session::Session,\n                                      symbol_hasher,\n                                      link_meta,\n                                      analysis.reachable);\n-\n-    if ccx.sess.opts.debuginfo {\n-        debuginfo::initialize(ccx, &crate);\n-    }\n-\n     {\n         let _icx = push_ctxt(\"text\");\n         trans_mod(ccx, &crate.module);"}, {"sha": "a982a4767fdcf7c743dd67875b05f818b775f8d0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 94, "deletions": 210, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e87205c578cabb5fe42131db83981ffe66a5c043", "patch": "@@ -104,11 +104,13 @@ use util::ppaux;\n \n use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n+use std::hashmap::HashSet;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n+use std::unstable::atomics;\n use std::vec;\n use syntax::codemap::{Span, Pos};\n-use syntax::{ast, codemap, ast_util, ast_map, opt_vec, visit};\n+use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n \n@@ -136,8 +138,10 @@ pub struct CrateDebugContext {\n     priv current_debug_location: DebugLocation,\n     priv created_files: HashMap<~str, DIFile>,\n     priv created_types: HashMap<uint, DIType>,\n-    priv local_namespace_map: HashMap<ast::NodeId, @NamespaceTreeNode>,\n-    priv extern_namespaces: HashMap<~[ast::Ident], @NamespaceTreeNode>,\n+    priv namespace_map: HashMap<~[ast::Ident], @NamespaceTreeNode>,\n+    // This collection is used to assert that composite types (structs, enums, ...) have their\n+    // members only set once:\n+    priv composite_types_completed: HashSet<DIType>,\n }\n \n impl CrateDebugContext {\n@@ -153,8 +157,8 @@ impl CrateDebugContext {\n             current_debug_location: UnknownLocation,\n             created_files: HashMap::new(),\n             created_types: HashMap::new(),\n-            local_namespace_map: HashMap::new(),\n-            extern_namespaces: HashMap::new(),\n+            namespace_map: HashMap::new(),\n+            composite_types_completed: HashSet::new(),\n         };\n     }\n }\n@@ -224,16 +228,6 @@ enum VariableKind {\n     CapturedVariable,\n }\n \n-pub fn initialize(cx: &mut CrateContext, crate: &ast::Crate) {\n-    if cx.dbg_cx.is_none() {\n-        return;\n-    }\n-\n-    let crate_namespace_ident = token::str_to_ident(cx.link_meta.name);\n-    let mut visitor = NamespaceVisitor::new_crate_visitor(cx, crate_namespace_ident);\n-    visit::walk_crate(&mut visitor, crate, ());\n-}\n-\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     if cx.dbg_cx.is_none() {\n@@ -548,11 +542,11 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n     let fnitem = cx.tcx.items.get_copy(&fn_ast_id);\n-    let (ident, fn_decl, generics, top_level_block, span) = match fnitem {\n+    let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n                 ast::item_fn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, fn_decl, generics, top_level_block, item.span)\n+                    (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess.span_bug(item.span,\n@@ -571,7 +565,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, generics, top_level_block, span)\n+            (ident, fn_decl, generics, top_level_block, span, true)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n@@ -583,7 +577,9 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                         // enclosing function.\n                         &empty_generics,\n                         top_level_block,\n-                        expr.span)\n+                        expr.span,\n+                        // Don't try to lookup the item path:\n+                        false)\n                 }\n                 _ => cx.sess.span_bug(expr.span,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n@@ -601,7 +597,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, generics, top_level_block, span)\n+            (ident, fn_decl, generics, top_level_block, span, true)\n         }\n         ast_map::node_foreign_item(@ast::foreign_item { _ }, _, _, _) |\n         ast_map::node_variant(*) |\n@@ -633,18 +629,16 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                                                       file_metadata,\n                                                       &mut function_name);\n \n-    let namespace_node = debug_context(cx).local_namespace_map.find_copy(&fn_ast_id);\n-    let (linkage_name, containing_scope) = match namespace_node {\n-        Some(namespace_node) => {\n-            (namespace_node.mangled_name_of_contained_item(function_name), namespace_node.scope)\n-        }\n-        None => {\n-            // This branch is only hit when there is a bug in the NamespaceVisitor.\n-            cx.sess.span_warn(span, format!(\"debuginfo: Could not find namespace node for function\n-                                          with name {}. This is a bug! Please report this to\n-                                          github.com/mozilla/rust/issues\", function_name));\n-            (function_name.clone(), file_metadata)\n-        }\n+    // There is no ast_map::path for ast::ExprFnBlock-type functions. For now, just don't put them\n+    // into a namespace. In the future this could be improved somehow (storing a path in the\n+    // ast_map, or construct a path using the enclosing function).\n+    let (linkage_name, containing_scope) = if has_path {\n+        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id), span);\n+        let linkage_name = namespace_node.mangled_name_of_contained_item(function_name);\n+        let containing_scope = namespace_node.scope;\n+        (linkage_name, containing_scope)\n+    } else {\n+        (function_name.clone(), file_metadata)\n     };\n \n     let scope_line = get_scope_line(cx, top_level_block, loc.line);\n@@ -682,16 +676,6 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    // Create namespaces for the interior of this function\n-    {\n-        let mut namespace_visitor = NamespaceVisitor::new_function_visitor(cx,\n-                                                                           function_name,\n-                                                                           namespace_node,\n-                                                                           file_metadata,\n-                                                                           span);\n-        visit::walk_block(&mut namespace_visitor, top_level_block, ());\n-    }\n-\n     return FunctionDebugContext(fn_debug_context);\n \n     fn get_function_signature(cx: &mut CrateContext,\n@@ -1584,6 +1568,17 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n                                  member_descriptions: &[MemberDescription],\n                                  file_metadata: DIFile,\n                                  definition_span: Span) {\n+    // In some rare cases LLVM metadata uniquing would lead to an existing type description being\n+    // used instead of a new one created in create_struct_stub. This would cause a hard to trace\n+    // assertion in DICompositeType::SetTypeArray(). The following check makes sure that we get a\n+    // better error message if this should happen again due to some regression.\n+    if debug_context(cx).composite_types_completed.contains(&composite_type_metadata) {\n+        cx.sess.span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - Already \\\n+                                           completed forward declaration re-encountered.\");\n+    } else {\n+        debug_context(cx).composite_types_completed.insert(composite_type_metadata);\n+    }\n+\n     let loc = span_start(cx, definition_span);\n \n     let member_metadata: ~[DIDescriptor] = member_descriptions\n@@ -1632,8 +1627,16 @@ fn create_struct_stub(cx: &mut CrateContext,\n     let loc = span_start(cx, definition_span);\n     let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n \n-    return do struct_type_name.with_c_str |name| {\n-        unsafe {\n+    // We assign unique IDs to the type stubs so LLVM metadata uniquing does not reuse instances\n+    // where we don't want it.\n+    let unique_id = unsafe {\n+        static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+        format!(\"DiStructStub{}\", unique_id_counter.fetch_add(1, atomics::SeqCst))\n+    };\n+\n+    return unsafe {\n+        do struct_type_name.with_c_str |name| {\n+        do unique_id.with_c_str |unique_id| {\n             // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n             // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n             let empty_array = create_DIArray(DIB(cx), []);\n@@ -1650,8 +1653,9 @@ fn create_struct_stub(cx: &mut CrateContext,\n                 ptr::null(),\n                 empty_array,\n                 0,\n-                ptr::null())\n-    }};\n+                ptr::null(),\n+                unique_id)\n+    }}};\n }\n \n fn boxed_type_metadata(cx: &mut CrateContext,\n@@ -2199,8 +2203,8 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n                                    def_id: ast::DefId,\n                                    warning_span: Span)\n                                 -> (DIScope, Span) {\n-    if def_id.crate == ast::LOCAL_CRATE {\n-        let containing_scope = debug_context(cx).local_namespace_map.get_copy(&def_id.node).scope;\n+    let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n+    let definition_span = if def_id.crate == ast::LOCAL_CRATE {\n         let definition_span = match cx.tcx.items.find(&def_id.node) {\n             Some(&ast_map::node_item(@ast::item { span, _ }, _)) => span,\n             ref node => {\n@@ -2210,12 +2214,13 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n                 codemap::dummy_sp()\n             }\n         };\n-        (containing_scope, definition_span)\n+        definition_span\n     } else {\n-        let item_path = ty::item_path(cx.tcx, def_id);\n         // For external items there is no span information\n-        (namespace_for_external_item(cx, &item_path).scope, codemap::dummy_sp())\n-    }\n+        codemap::dummy_sp()\n+    };\n+\n+    (containing_scope, definition_span)\n }\n \n // This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n@@ -2703,29 +2708,41 @@ impl NamespaceTreeNode {\n     }\n }\n \n-fn namespace_for_external_item(cx: &mut CrateContext,\n-                               item_path: &ast_map::path)\n-                            -> @NamespaceTreeNode {\n-    if item_path.len() < 2 {\n-        cx.sess.bug(format!(\"debuginfo::namespace_for_external_item() - Invalid item_path: {}\",\n-            ast_map::path_to_str(*item_path, token::get_ident_interner())));\n-    }\n+fn namespace_for_item(cx: &mut CrateContext,\n+                      def_id: ast::DefId,\n+                      warning_span: Span)\n+                   -> @NamespaceTreeNode {\n+    let namespace_path = {\n+        let mut item_path = ty::item_path(cx.tcx, def_id);\n \n-    let path_excluding_item = item_path.slice_to(item_path.len() - 1);\n-    let mut current_key = vec::with_capacity(path_excluding_item.len());\n-    let mut parent_node: Option<@NamespaceTreeNode> = None;\n-    let last_index = path_excluding_item.len() - 1;\n+        if (def_id.crate == ast::LOCAL_CRATE && item_path.len() < 1) ||\n+           (def_id.crate != ast::LOCAL_CRATE && item_path.len() < 2) {\n+            cx.sess.bug(format!(\"debuginfo::namespace_for_item() - Item path too short: {}\",\n+                ast_map::path_to_str(item_path, token::get_ident_interner())));\n+        }\n \n-    for (i, &path_element) in path_excluding_item.iter().enumerate() {\n-        let ident = match path_element {\n-            ast_map::path_mod(ident)            |\n-            ast_map::path_name(ident)           |\n-            ast_map::path_pretty_name(ident, _) => ident\n-        };\n+        // remove the name of the item\n+        item_path.pop();\n+\n+        if def_id.crate == ast::LOCAL_CRATE {\n+            // prepend crate name if not already present\n+            let crate_namespace_ident = token::str_to_ident(cx.link_meta.name);\n+            item_path.insert(0, ast_map::path_mod(crate_namespace_ident));\n+        }\n \n+        item_path\n+    };\n+\n+    let mut current_key = vec::with_capacity(namespace_path.len());\n+    let mut parent_node: Option<@NamespaceTreeNode> = None;\n+    let last_index = namespace_path.len() - 1;\n+\n+    // Create/Lookup namespace for each element of the path.\n+    for (i, &path_element) in namespace_path.iter().enumerate() {\n+        let ident = path_element.ident();\n         current_key.push(ident);\n \n-        let existing_node = debug_context(cx).extern_namespaces.find_copy(&current_key);\n+        let existing_node = debug_context(cx).namespace_map.find_copy(&current_key);\n         let current_node = match existing_node {\n             Some(existing_node) => existing_node,\n             None => {\n@@ -2743,7 +2760,7 @@ fn namespace_for_external_item(cx: &mut CrateContext,\n                             parent_scope,\n                             namespace_name,\n                             ptr::null(), // cannot reconstruct file ...\n-                            0)           // ... or line information\n+                            0)           // ... or line information, but that's not so important.\n                     }\n                 };\n \n@@ -2753,7 +2770,7 @@ fn namespace_for_external_item(cx: &mut CrateContext,\n                     parent: parent_node,\n                 };\n \n-                debug_context(cx).extern_namespaces.insert(current_key.clone(), node);\n+                debug_context(cx).namespace_map.insert(current_key.clone(), node);\n \n                 node\n             }\n@@ -2766,142 +2783,9 @@ fn namespace_for_external_item(cx: &mut CrateContext,\n         }\n     }\n \n-    cx.sess.bug(\"debuginfo::namespace_for_external_item() - Code path should be unreachable\");\n-}\n-\n-struct NamespaceVisitor<'self> {\n-    module_ident: ast::Ident,\n-    scope_stack: ~[@NamespaceTreeNode],\n-    crate_context: &'self mut CrateContext,\n-}\n-\n-impl<'self> NamespaceVisitor<'self> {\n-\n-    fn new_crate_visitor<'a>(cx: &'a mut CrateContext,\n-                             crate_ident: ast::Ident)\n-                          -> NamespaceVisitor<'a> {\n-        NamespaceVisitor {\n-            module_ident: crate_ident,\n-            scope_stack: ~[],\n-            crate_context: cx,\n-        }\n-    }\n-\n-    fn new_function_visitor<'a>(cx: &'a mut CrateContext,\n-                                function_name: &str,\n-                                parent_node: Option<@NamespaceTreeNode>,\n-                                file_metadata: DIFile,\n-                                span: Span)\n-                             -> NamespaceVisitor<'a> {\n-        let companion_name = function_name + \"()\";\n-        let companion_ident = token::str_to_ident(companion_name);\n-        let parent_scope = match parent_node {\n-            Some(parent_node) => parent_node.scope,\n-            None => ptr::null()\n-        };\n-        let line = span_start(cx, span).line as c_uint;\n-\n-        let namespace_metadata = unsafe {\n-            do companion_name.with_c_str |companion_name| {\n-                llvm::LLVMDIBuilderCreateNameSpace(\n-                    DIB(cx),\n-                    parent_scope,\n-                    companion_name,\n-                    file_metadata,\n-                    line)\n-            }\n-        };\n-\n-        let function_node = @NamespaceTreeNode {\n-            scope: namespace_metadata,\n-            ident: companion_ident,\n-            parent: parent_node,\n-        };\n-\n-        return NamespaceVisitor {\n-            module_ident: special_idents::invalid,\n-            scope_stack: ~[function_node],\n-            crate_context: cx,\n-        };\n-    }\n-}\n-\n-// Possible optimization: Only recurse if needed.\n-impl<'self> visit::Visitor<()> for NamespaceVisitor<'self> {\n-\n-    fn visit_mod(&mut self,\n-                 module: &ast::_mod,\n-                 span: Span,\n-                 _: ast::NodeId,\n-                 _: ()) {\n-        let module_name = token::ident_to_str(&self.module_ident);\n-\n-        let (parent_node, parent_scope) = if self.scope_stack.len() > 0 {\n-            let parent_node = *self.scope_stack.last();\n-            (Some(parent_node), parent_node.scope)\n-        } else {\n-            (None, ptr::null())\n-        };\n-\n-        let loc = span_start(self.crate_context, span);\n-        let file_metadata = file_metadata(self.crate_context, loc.file.name);\n-\n-        let namespace_metadata = unsafe {\n-            do module_name.with_c_str |module_name| {\n-                llvm::LLVMDIBuilderCreateNameSpace(\n-                    DIB(self.crate_context),\n-                    parent_scope,\n-                    module_name,\n-                    file_metadata,\n-                    loc.line as c_uint)\n-            }\n-        };\n-\n-        let this_node = @NamespaceTreeNode {\n-            scope: namespace_metadata,\n-            ident: self.module_ident,\n-            parent: parent_node,\n-        };\n-\n-        self.scope_stack.push(this_node);\n-\n-        visit::walk_mod(self, module, ());\n-\n-        self.scope_stack.pop();\n-    }\n-\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n-        match item.node {\n-            ast::item_mod(*) => {\n-                // always store the last module ident so visit_mod() has it available\n-                self.module_ident = item.ident;\n-            }\n-            ast::item_fn(*) => { /* handled by visit_fn */ }\n-            _ => {\n-                debug_context(self.crate_context)\n-                    .local_namespace_map\n-                    .insert(item.id, *self.scope_stack.last());\n-            }\n-        }\n-\n-        visit::walk_item(self, item, ());\n-    }\n-\n-    fn visit_foreign_item(&mut self, item: @ast::foreign_item, _: ()) {\n-        debug_context(self.crate_context)\n-            .local_namespace_map\n-            .insert(item.id, *self.scope_stack.last());\n-    }\n-\n-    fn visit_fn(&mut self,\n-                _: &visit::fn_kind,\n-                _: &ast::fn_decl,\n-                _: &ast::Block,\n-                _: Span,\n-                node_id: ast::NodeId,\n-                _: ()) {\n-        debug_context(self.crate_context)\n-            .local_namespace_map\n-            .insert(node_id, *self.scope_stack.last());\n-    }\n+    // Should be unreachable:\n+    let error_message = format!(\"debuginfo::namespace_for_item() - Code path should be \\\n+                                 unreachable. namespace_path was {}\",\n+                                 ast_map::path_to_str(namespace_path, token::get_ident_interner()));\n+    cx.sess.span_bug(warning_span, error_message);\n }"}, {"sha": "31a02dceb1c09e17b2cbdcf8f25085c3afe5a12b", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e87205c578cabb5fe42131db83981ffe66a5c043/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=e87205c578cabb5fe42131db83981ffe66a5c043", "patch": "@@ -548,14 +548,21 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n     LLVMValueRef DerivedFrom,\n     LLVMValueRef Elements,\n     unsigned RunTimeLang,\n-    LLVMValueRef VTableHolder) {\n+    LLVMValueRef VTableHolder,\n+    const char *UniqueId) {\n     return wrap(Builder->createStructType(\n-        unwrapDI<DIDescriptor>(Scope), Name,\n-        unwrapDI<DIFile>(File), LineNumber,\n-        SizeInBits, AlignInBits, Flags,\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNumber,\n+        SizeInBits,\n+        AlignInBits,\n+        Flags,\n         unwrapDI<DIType>(DerivedFrom),\n-        unwrapDI<DIArray>(Elements), RunTimeLang,\n-        unwrapDI<MDNode*>(VTableHolder)));\n+        unwrapDI<DIArray>(Elements),\n+        RunTimeLang,\n+        unwrapDI<MDNode*>(VTableHolder),\n+        UniqueId));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateMemberType("}]}