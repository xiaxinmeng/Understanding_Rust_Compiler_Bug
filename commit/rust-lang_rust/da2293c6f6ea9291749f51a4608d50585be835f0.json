{"sha": "da2293c6f6ea9291749f51a4608d50585be835f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMjI5M2M2ZjZlYTkyOTE3NDlmNTFhNDYwOGQ1MDU4NWJlODM1ZjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T03:09:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T05:19:57Z"}, "message": "std: Deal with fallout of rtio changes", "tree": {"sha": "94284257df2ec6f351401dd304cdf0f1d1071881", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94284257df2ec6f351401dd304cdf0f1d1071881"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da2293c6f6ea9291749f51a4608d50585be835f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da2293c6f6ea9291749f51a4608d50585be835f0", "html_url": "https://github.com/rust-lang/rust/commit/da2293c6f6ea9291749f51a4608d50585be835f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da2293c6f6ea9291749f51a4608d50585be835f0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ec36c358f74fe83332231e774ea20a21d165120", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec36c358f74fe83332231e774ea20a21d165120", "html_url": "https://github.com/rust-lang/rust/commit/5ec36c358f74fe83332231e774ea20a21d165120"}], "stats": {"total": 663, "additions": 453, "deletions": 210}, "files": [{"sha": "f4eeebeeea06fe6f903da27ec7cf325a164d2f06", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -27,10 +27,10 @@ use option::{Some, None, Option};\n use owned::Box;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n+use rt::mutex::NativeMutex;\n use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n-use unstable::mutex::NativeMutex;\n \n use mpsc = sync::mpsc_queue;\n "}, {"sha": "7fe505573b799bb12257a682a043fe6fde04df5d", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -43,10 +43,10 @@ use owned::Box;\n use ptr::RawPtr;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n+use rt::mutex::{NativeMutex, LockGuard};\n use rt::task::{Task, BlockedTask};\n use sync::atomics;\n use ty::Unsafe;\n-use unstable::mutex::{NativeMutex, LockGuard};\n use vec::Vec;\n \n pub struct Packet<T> {"}, {"sha": "49e8d37923661bf2c614768af0ebbb8d139e4a81", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 112, "deletions": 33, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -52,19 +52,22 @@ fs::unlink(&path);\n use c_str::ToCStr;\n use clone::Clone;\n use container::Container;\n+use io;\n use iter::Iterator;\n use kinds::Send;\n-use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write, Open, IoError, Truncate};\n-use super::{FileMode, FileAccess, FileStat, IoResult, FilePermission};\n-use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n-use io;\n+use libc;\n use option::{Some, None, Option};\n use owned::Box;\n-use result::{Ok, Err};\n-use path;\n use path::{Path, GenericPath};\n+use path;\n+use result::{Ok, Err};\n+use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n+use rt::rtio;\n use slice::{OwnedVector, ImmutableVector};\n+use super::UnstableFileStat;\n+use super::{FileMode, FileAccess, FileStat, IoResult, FilePermission};\n+use super::{Reader, Writer, Seek, Append, SeekCur, SeekEnd, SeekSet};\n+use super::{SeekStyle, Read, Write, ReadWrite, Open, IoError, Truncate};\n use vec::Vec;\n \n /// Unconstrained file access type that exposes read and write operations\n@@ -126,6 +129,16 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> IoResult<File> {\n+        let mode = match mode {\n+            Open => rtio::Open,\n+            Append => rtio::Append,\n+            Truncate => rtio::Truncate,\n+        };\n+        let access = match access {\n+            Read => rtio::Read,\n+            Write => rtio::Write,\n+            ReadWrite => rtio::ReadWrite,\n+        };\n         LocalIo::maybe_raise(|io| {\n             io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n                 File {\n@@ -134,7 +147,7 @@ impl File {\n                     last_nread: -1\n                 }\n             })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -184,15 +197,15 @@ impl File {\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n     pub fn fsync(&mut self) -> IoResult<()> {\n-        self.fd.fsync()\n+        self.fd.fsync().map_err(IoError::from_rtio_error)\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n-        self.fd.datasync()\n+        self.fd.datasync().map_err(IoError::from_rtio_error)\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -204,7 +217,7 @@ impl File {\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        self.fd.truncate(size)\n+        self.fd.truncate(size).map_err(IoError::from_rtio_error)\n     }\n \n     /// Tests whether this stream has reached EOF.\n@@ -217,7 +230,10 @@ impl File {\n \n     /// Queries information about the underlying file.\n     pub fn stat(&mut self) -> IoResult<FileStat> {\n-        self.fd.fstat()\n+        match self.fd.fstat() {\n+            Ok(s) => Ok(from_rtio(s)),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n@@ -243,7 +259,9 @@ impl File {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_unlink(&path.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -268,9 +286,10 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// to perform a `stat` call on the given path or if there is no entry in the\n /// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    LocalIo::maybe_raise(|io| {\n-        io.fs_stat(&path.to_c_str())\n-    })\n+    match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n+        Ok(s) => Ok(from_rtio(s)),\n+        Err(e) => Err(IoError::from_rtio_error(e)),\n+    }\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -282,9 +301,46 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    LocalIo::maybe_raise(|io| {\n-        io.fs_lstat(&path.to_c_str())\n-    })\n+    match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n+        Ok(s) => Ok(from_rtio(s)),\n+        Err(e) => Err(IoError::from_rtio_error(e)),\n+    }\n+}\n+\n+fn from_rtio(s: rtio::FileStat) -> FileStat {\n+    let rtio::FileStat {\n+        size, kind, perm, created, modified,\n+        accessed, device, inode, rdev,\n+        nlink, uid, gid, blksize, blocks, flags, gen\n+    } = s;\n+\n+    FileStat {\n+        size: size,\n+        kind: match (kind as libc::c_int) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        },\n+        perm: FilePermission::from_bits_truncate(perm as u32),\n+        created: created,\n+        modified: modified,\n+        accessed: accessed,\n+        unstable: UnstableFileStat {\n+            device: device,\n+            inode: inode,\n+            rdev: rdev,\n+            nlink: nlink,\n+            uid: uid,\n+            gid: gid,\n+            blksize: blksize,\n+            blocks: blocks,\n+            flags: flags,\n+            gen: gen,\n+        },\n+    }\n }\n \n /// Rename a file or directory to a new name.\n@@ -304,7 +360,9 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n /// permissions to view the contents, or if some other intermittent I/O error\n /// occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -382,25 +440,33 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_chmod(&path.to_c_str(), mode.bits() as uint)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_chown(&path.to_c_str(), uid, gid)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_link(&src.to_c_str(), &dst.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_symlink(&src.to_c_str(), &dst.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -412,7 +478,7 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     LocalIo::maybe_raise(|io| {\n         Ok(Path::new(try!(io.fs_readlink(&path.to_c_str()))))\n-    })\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Create a new, empty directory at the provided path\n@@ -433,7 +499,9 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// This call will return an error if the user lacks permissions to make a new\n /// directory at the provided path, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_mkdir(&path.to_c_str(), mode.bits() as uint)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Remove an existing, empty directory\n@@ -453,7 +521,9 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This call will return an error if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_rmdir(&path.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -492,7 +562,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n         Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).move_iter().map(|a| {\n             Path::new(a)\n         }).collect())\n-    })\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -616,7 +686,9 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_utime(&path.to_c_str(), atime, mtime)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n impl Reader for File {\n@@ -629,28 +701,35 @@ impl Reader for File {\n                     _ => Ok(read as uint)\n                 }\n             },\n-            Err(e) => Err(e),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n         }\n     }\n }\n \n impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.fd.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.fd.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n-        self.fd.tell()\n+        self.fd.tell().map_err(IoError::from_rtio_error)\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let style = match style {\n+            SeekSet => rtio::SeekSet,\n+            SeekCur => rtio::SeekCur,\n+            SeekEnd => rtio::SeekEnd,\n+        };\n         match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n                 Ok(())\n             }\n-            Err(e) => Err(e),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n         }\n     }\n }"}, {"sha": "94d60cb3ce76fe3cf782fbb600330c0b05102b89", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -225,6 +225,7 @@ use option::{Option, Some, None};\n use os;\n use owned::Box;\n use result::{Ok, Err, Result};\n+use rt::rtio;\n use slice::{Vector, MutableVector, ImmutableVector};\n use str::{StrSlice, StrAllocating};\n use str;\n@@ -323,6 +324,14 @@ impl IoError {\n                 libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n                 libc::ERROR_OPERATION_ABORTED =>\n                     (TimedOut, \"operation timed out\"),\n+                libc::WSAEINVAL => (InvalidInput, \"invalid argument\"),\n+                libc::ERROR_CALL_NOT_IMPLEMENTED =>\n+                    (IoUnavailable, \"function not implemented\"),\n+                libc::ERROR_CALL_NOT_IMPLEMENTED =>\n+                    (MismatchedFileTypeForOperation,\n+                     \"invalid handle provided to function\"),\n+                libc::ERROR_NOTHING_TO_TERMINATE =>\n+                    (InvalidInput, \"no process to kill\"),\n \n                 // libuv maps this error code to EISDIR. we do too. if it is found\n                 // to be incorrect, we can add in some more machinery to only\n@@ -351,9 +360,17 @@ impl IoError {\n                 libc::EADDRINUSE => (ConnectionRefused, \"address in use\"),\n                 libc::ENOENT => (FileNotFound, \"no such file or directory\"),\n                 libc::EISDIR => (InvalidInput, \"illegal operation on a directory\"),\n-\n-                // These two constants can have the same value on some systems, but\n-                // different values on others, so we can't use a match clause\n+                libc::ENOSYS => (IoUnavailable, \"function not implemented\"),\n+                libc::EINVAL => (InvalidInput, \"invalid argument\"),\n+                libc::ENOTTY =>\n+                    (MismatchedFileTypeForOperation,\n+                     \"file descriptor is not a TTY\"),\n+                libc::ETIMEDOUT => (TimedOut, \"operation timed out\"),\n+                libc::ECANCELED => (TimedOut, \"operation aborted\"),\n+\n+                // These two constants can have the same value on some systems,\n+                // but different values on others, so we can't use a match\n+                // clause\n                 x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n                     (ResourceUnavailable, \"resource temporarily unavailable\"),\n \n@@ -382,6 +399,17 @@ impl IoError {\n     pub fn last_error() -> IoError {\n         IoError::from_errno(os::errno() as uint, true)\n     }\n+\n+    fn from_rtio_error(err: rtio::IoError) -> IoError {\n+        let rtio::IoError { code, extra, detail } = err;\n+        let mut ioerr = IoError::from_errno(code, false);\n+        ioerr.detail = detail;\n+        ioerr.kind = match ioerr.kind {\n+            TimedOut if extra > 0 => ShortWrite(extra),\n+            k => k,\n+        };\n+        return ioerr;\n+    }\n }\n \n impl fmt::Show for IoError {"}, {"sha": "8d5fd2b99fd7b6e2fdff9997ffe3bb8f0a27a722", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -20,10 +20,12 @@ getaddrinfo()\n #![allow(missing_doc)]\n \n use iter::Iterator;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n+use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo};\n+use rt::rtio;\n use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n@@ -89,9 +91,34 @@ pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n ///\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n+#[allow(unused_variable)]\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> IoResult<Vec<Info>> {\n-    LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n+    let hint = hint.map(|Hint { family, socktype, protocol, flags }| {\n+        rtio::AddrinfoHint {\n+            family: family,\n+            socktype: 0, // FIXME: this should use the above variable\n+            protocol: 0, // FIXME: this should use the above variable\n+            flags: flags,\n+        }\n+    });\n+    match LocalIo::maybe_raise(|io| {\n+        io.get_host_addresses(hostname, servname, hint)\n+    }) {\n+        Ok(v) => Ok(v.move_iter().map(|info| {\n+            Info {\n+                address: SocketAddr {\n+                    ip: super::from_rtio(info.address.ip),\n+                    port: info.address.port,\n+                },\n+                family: info.family,\n+                socktype: None, // FIXME: this should use the above variable\n+                protocol: None, // FIXME: this should use the above variable\n+                flags: info.flags,\n+            }\n+        }).collect()),\n+        Err(e) => Err(IoError::from_rtio_error(e)),\n+    }\n }\n \n // Ignored on android since we cannot give tcp/ip"}, {"sha": "54af83462eed6dd35a3c8272f42ed0b41164e625", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -10,6 +10,9 @@\n \n //! Networking I/O\n \n+use rt::rtio;\n+use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr};\n+\n pub use self::addrinfo::get_host_addresses;\n \n pub mod addrinfo;\n@@ -18,3 +21,21 @@ pub mod udp;\n pub mod ip;\n // FIXME(#12093) - this should not be called unix\n pub mod unix;\n+\n+fn to_rtio(ip: IpAddr) -> rtio::IpAddr {\n+    match ip {\n+        Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n+        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            rtio::Ipv6Addr(a, b, c, d, e, f, g, h)\n+        }\n+    }\n+}\n+\n+fn from_rtio(ip: rtio::IpAddr) -> IpAddr {\n+    match ip {\n+        rtio::Ipv4Addr(a, b, c, d) => Ipv4Addr(a, b, c, d),\n+        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            Ipv6Addr(a, b, c, d, e, f, g, h)\n+        }\n+    }\n+}"}, {"sha": "8ce77faa29621eebc1409e2179bb596fd572cb6f", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -32,6 +32,7 @@ use option::{None, Some, Option};\n use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n+use rt::rtio;\n \n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n@@ -67,22 +68,22 @@ impl TcpStream {\n             Some(addr) => vec!(addr),\n             None => try!(get_host_addresses(host))\n         };\n-        let mut err = IoError{\n+        let mut err = IoError {\n             kind: ConnectionFailed,\n             desc: \"no addresses found for hostname\",\n             detail: None\n         };\n-        for address in addresses.iter() {\n-            let socket_addr = SocketAddr{ip: *address, port: port};\n+        for addr in addresses.iter() {\n+            let addr = rtio::SocketAddr{ ip: super::to_rtio(*addr), port: port };\n             let result = LocalIo::maybe_raise(|io| {\n-                io.tcp_connect(socket_addr, None).map(TcpStream::new)\n+                io.tcp_connect(addr, None).map(TcpStream::new)\n             });\n             match result {\n                 Ok(stream) => {\n                     return Ok(stream)\n                 }\n                 Err(connect_err) => {\n-                    err = connect_err\n+                    err = IoError::from_rtio_error(connect_err)\n                 }\n             }\n         }\n@@ -101,19 +102,31 @@ impl TcpStream {\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n                            timeout_ms: u64) -> IoResult<TcpStream> {\n+        let SocketAddr { ip, port } = addr;\n+        let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n             io.tcp_connect(addr, Some(timeout_ms)).map(TcpStream::new)\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n     pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.peer_name()\n+        match self.obj.peer_name() {\n+            Ok(rtio::SocketAddr { ip, port }) => {\n+                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Returns the socket address of the local half of this TCP connection.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.socket_name()\n+        match self.obj.socket_name() {\n+            Ok(rtio::SocketAddr { ip, port }) => {\n+                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n@@ -123,7 +136,7 @@ impl TcpStream {\n             self.obj.nodelay()\n         } else {\n             self.obj.control_congestion()\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the keepalive timeout to the timeout specified.\n@@ -136,7 +149,7 @@ impl TcpStream {\n         match delay_in_seconds {\n             Some(i) => self.obj.keepalive(i),\n             None => self.obj.letdie(),\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Closes the reading half of this connection.\n@@ -168,7 +181,9 @@ impl TcpStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> { self.obj.close_read() }\n+    pub fn close_read(&mut self) -> IoResult<()> {\n+        self.obj.close_read().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Closes the writing half of this connection.\n     ///\n@@ -177,7 +192,9 @@ impl TcpStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+    pub fn close_write(&mut self) -> IoResult<()> {\n+        self.obj.close_write().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n     ///\n@@ -261,11 +278,15 @@ impl Clone for TcpStream {\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n /// A structure representing a socket server. This listener is used to create a\n@@ -319,10 +340,13 @@ impl TcpListener {\n     pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> {\n         match FromStr::from_str(addr) {\n             Some(ip) => {\n-                let socket_addr = SocketAddr{ip: ip, port: port};\n+                let addr = rtio::SocketAddr{\n+                    ip: super::to_rtio(ip),\n+                    port: port,\n+                };\n                 LocalIo::maybe_raise(|io| {\n-                    io.tcp_bind(socket_addr).map(|l| TcpListener { obj: l })\n-                })\n+                    io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n+                }).map_err(IoError::from_rtio_error)\n             }\n             None => {\n                 Err(IoError{\n@@ -336,13 +360,21 @@ impl TcpListener {\n \n     /// Returns the local socket address of this listener.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.socket_name()\n+        match self.obj.socket_name() {\n+            Ok(rtio::SocketAddr { ip, port }) => {\n+                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n     fn listen(self) -> IoResult<TcpAcceptor> {\n-        self.obj.listen().map(|acceptor| TcpAcceptor { obj: acceptor })\n+        match self.obj.listen() {\n+            Ok(acceptor) => Ok(TcpAcceptor { obj: acceptor }),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n@@ -403,7 +435,10 @@ impl TcpAcceptor {\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n     fn accept(&mut self) -> IoResult<TcpStream> {\n-        self.obj.accept().map(TcpStream::new)\n+        match self.obj.accept(){\n+            Ok(s) => Ok(TcpStream::new(s)),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n "}, {"sha": "538bba36958115447410a84c59f2ed5e274068d8", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -17,12 +17,13 @@\n \n use clone::Clone;\n use io::net::ip::{SocketAddr, IpAddr};\n-use io::{Reader, Writer, IoResult};\n+use io::{Reader, Writer, IoResult, IoError};\n use kinds::Send;\n use owned::Box;\n use option::Option;\n use result::{Ok, Err};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n+use rt::rtio;\n \n /// A User Datagram Protocol socket.\n ///\n@@ -62,22 +63,32 @@ pub struct UdpSocket {\n impl UdpSocket {\n     /// Creates a UDP socket from the given socket address.\n     pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n+        let SocketAddr { ip, port } = addr;\n         LocalIo::maybe_raise(|io| {\n+            let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n             io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n     pub fn recvfrom(&mut self, buf: &mut [u8])\n                     -> IoResult<(uint, SocketAddr)> {\n-        self.obj.recvfrom(buf)\n+        match self.obj.recvfrom(buf) {\n+            Ok((amt, rtio::SocketAddr { ip, port })) => {\n+                Ok((amt, SocketAddr { ip: super::from_rtio(ip), port: port }))\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Sends data on the socket to the given address. Returns nothing on\n     /// success.\n     pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        self.obj.sendto(buf, dst)\n+        self.obj.sendto(buf, rtio::SocketAddr {\n+            ip: super::to_rtio(dst.ip),\n+            port: dst.port,\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n@@ -95,19 +106,24 @@ impl UdpSocket {\n \n     /// Returns the socket address that this socket was created from.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.socket_name()\n+        match self.obj.socket_name() {\n+            Ok(a) => Ok(SocketAddr { ip: super::from_rtio(a.ip), port: a.port }),\n+            Err(e) => Err(IoError::from_rtio_error(e))\n+        }\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n     #[experimental]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.obj.join_multicast(multi)\n+        let e = self.obj.join_multicast(super::to_rtio(multi));\n+        e.map_err(IoError::from_rtio_error)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n     #[experimental]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.obj.leave_multicast(multi)\n+        let e = self.obj.leave_multicast(super::to_rtio(multi));\n+        e.map_err(IoError::from_rtio_error)\n     }\n \n     /// Set the multicast loop flag to the specified value\n@@ -119,19 +135,19 @@ impl UdpSocket {\n             self.obj.loop_multicast_locally()\n         } else {\n             self.obj.dont_loop_multicast_locally()\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the multicast TTL\n     #[experimental]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.multicast_time_to_live(ttl)\n+        self.obj.multicast_time_to_live(ttl).map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets this socket's TTL\n     #[experimental]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.time_to_live(ttl)\n+        self.obj.time_to_live(ttl).map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the broadcast flag on or off\n@@ -141,7 +157,7 @@ impl UdpSocket {\n             self.obj.hear_broadcasts()\n         } else {\n             self.obj.ignore_broadcasts()\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the read/write timeout for this socket."}, {"sha": "9715a821e4fcba5d17704f83c4e5de5dcdea4977", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -28,7 +28,7 @@ use prelude::*;\n \n use c_str::ToCStr;\n use clone::Clone;\n-use io::{Listener, Acceptor, Reader, Writer, IoResult};\n+use io::{Listener, Acceptor, Reader, Writer, IoResult, IoError};\n use kinds::Send;\n use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n@@ -58,7 +58,7 @@ impl UnixStream {\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_connect(&path.to_c_str(), None).map(|p| UnixStream { obj: p })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Connect to a pipe named by `path`, timing out if the specified number of\n@@ -72,7 +72,7 @@ impl UnixStream {\n         LocalIo::maybe_raise(|io| {\n             let s = io.unix_connect(&path.to_c_str(), Some(timeout_ms));\n             s.map(|p| UnixStream { obj: p })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n \n@@ -83,7 +83,9 @@ impl UnixStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> { self.obj.close_read() }\n+    pub fn close_read(&mut self) -> IoResult<()> {\n+        self.obj.close_read().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Closes the writing half of this connection.\n     ///\n@@ -92,7 +94,9 @@ impl UnixStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+    pub fn close_write(&mut self) -> IoResult<()> {\n+        self.obj.close_write().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n@@ -126,11 +130,15 @@ impl Clone for UnixStream {\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n /// A value that can listen for incoming named pipe connection requests.\n@@ -165,13 +173,15 @@ impl UnixListener {\n     pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n     fn listen(self) -> IoResult<UnixAcceptor> {\n-        self.obj.listen().map(|obj| UnixAcceptor { obj: obj })\n+        self.obj.listen().map(|obj| {\n+            UnixAcceptor { obj: obj }\n+        }).map_err(IoError::from_rtio_error)\n     }\n }\n \n@@ -202,7 +212,9 @@ impl UnixAcceptor {\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.obj.accept().map(|s| UnixStream { obj: s })\n+        self.obj.accept().map(|s| {\n+            UnixStream { obj: s }\n+        }).map_err(IoError::from_rtio_error)\n     }\n }\n "}, {"sha": "11bb27573c29afece830187f28e270c62c839a28", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -16,7 +16,7 @@\n #![allow(missing_doc)]\n \n use prelude::*;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use libc;\n use owned::Box;\n use rt::rtio::{RtioPipe, LocalIo};\n@@ -51,7 +51,7 @@ impl PipeStream {\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n         LocalIo::maybe_raise(|io| {\n             io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     #[doc(hidden)]\n@@ -67,11 +67,15 @@ impl Clone for PipeStream {\n }\n \n impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "059286339a6fa2db624ed892dc33b838737e4099", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -16,12 +16,13 @@ use prelude::*;\n \n use str;\n use fmt;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use io;\n use libc;\n use mem;\n use owned::Box;\n use rt::rtio::{RtioProcess, ProcessConfig, IoFactory, LocalIo};\n+use rt::rtio;\n use c_str::CString;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -232,16 +233,25 @@ impl Command {\n \n     /// Executes the command as a child process, which is returned.\n     pub fn spawn(&self) -> IoResult<Process> {\n+        fn to_rtio(p: StdioContainer) -> rtio::StdioContainer {\n+            match p {\n+                Ignored => rtio::Ignored,\n+                InheritFd(fd) => rtio::InheritFd(fd),\n+                CreatePipe(a, b) => rtio::CreatePipe(a, b),\n+            }\n+        }\n+        let extra_io: Vec<rtio::StdioContainer> =\n+            self.extra_io.iter().map(|x| to_rtio(*x)).collect();\n         LocalIo::maybe_raise(|io| {\n             let cfg = ProcessConfig {\n                 program: &self.program,\n                 args: self.args.as_slice(),\n                 env: self.env.as_ref().map(|env| env.as_slice()),\n                 cwd: self.cwd.as_ref(),\n-                stdin: self.stdin,\n-                stdout: self.stdout,\n-                stderr: self.stderr,\n-                extra_io: self.extra_io.as_slice(),\n+                stdin: to_rtio(self.stdin),\n+                stdout: to_rtio(self.stdout),\n+                stderr: to_rtio(self.stderr),\n+                extra_io: extra_io.as_slice(),\n                 uid: self.uid,\n                 gid: self.gid,\n                 detach: self.detach,\n@@ -258,7 +268,7 @@ impl Command {\n                     extra_io: io.collect(),\n                 }\n             })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -393,7 +403,9 @@ impl Process {\n     /// be successfully delivered if the child has exited, but not yet been\n     /// reaped.\n     pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n-        LocalIo::maybe_raise(|io| io.kill(id, signal))\n+        LocalIo::maybe_raise(|io| {\n+            io.kill(id, signal)\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Returns the process id of this child process\n@@ -415,7 +427,7 @@ impl Process {\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n     pub fn signal(&mut self, signal: int) -> IoResult<()> {\n-        self.handle.kill(signal)\n+        self.handle.kill(signal).map_err(IoError::from_rtio_error)\n     }\n \n     /// Sends a signal to this child requesting that it exits. This is\n@@ -442,7 +454,11 @@ impl Process {\n     /// `set_timeout` and the timeout expires before the child exits.\n     pub fn wait(&mut self) -> IoResult<ProcessExit> {\n         drop(self.stdin.take());\n-        self.handle.wait()\n+        match self.handle.wait() {\n+            Ok(rtio::ExitSignal(s)) => Ok(ExitSignal(s)),\n+            Ok(rtio::ExitStatus(s)) => Ok(ExitStatus(s)),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Sets a timeout, in milliseconds, for future calls to wait()."}, {"sha": "598a8667d41e93a4d4e4fab53a3e702c55b717b9", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -28,7 +28,7 @@ use mem::drop;\n use option::{Some, None};\n use owned::Box;\n use result::{Ok, Err};\n-use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n+use rt::rtio::{IoFactory, LocalIo, RtioSignal, Callback};\n use slice::ImmutableVector;\n use vec::Vec;\n \n@@ -122,17 +122,28 @@ impl Listener {\n     /// If this function fails to register a signal handler, then an error will\n     /// be returned.\n     pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {\n+        struct SignalCallback {\n+            signum: Signum,\n+            tx: Sender<Signum>,\n+        }\n+        impl Callback for SignalCallback {\n+            fn call(&mut self) { self.tx.send(self.signum) }\n+        }\n+\n         if self.handles.iter().any(|&(sig, _)| sig == signum) {\n             return Ok(()); // self is already listening to signum, so succeed\n         }\n         match LocalIo::maybe_raise(|io| {\n-            io.signal(signum, self.tx.clone())\n+            io.signal(signum as int, box SignalCallback {\n+                signum: signum,\n+                tx: self.tx.clone(),\n+            })\n         }) {\n             Ok(handle) => {\n                 self.handles.push((signum, handle));\n                 Ok(())\n             }\n-            Err(e) => Err(e)\n+            Err(e) => Err(io::IoError::from_rtio_error(e))\n         }\n     }\n "}, {"sha": "5db09076c98e0316e67ecee567d5861e433bbff7", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 36, "deletions": 64, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -27,20 +27,19 @@ out.write(bytes!(\"Hello, world!\"));\n \n */\n \n+use failure::local_stderr;\n use fmt;\n use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n-use libc;\n use kinds::Send;\n-use mem::replace;\n+use libc;\n use option::{Option, Some, None};\n use owned::Box;\n-use prelude::drop;\n use result::{Ok, Err};\n use rt;\n use rt::local::Local;\n-use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use rt::task::Task;\n+use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use str::StrSlice;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n@@ -82,9 +81,11 @@ fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n             Ok(tty) => f(TTY(tty)),\n             Err(_) => f(File(io.fs_from_raw_fd(fd, DontClose))),\n         })\n-    }).unwrap()\n+    }).map_err(IoError::from_rtio_error).unwrap()\n }\n \n+local_data_key!(local_stdout: Box<Writer:Send>)\n+\n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// The returned handled is buffered by default with a `BufferedReader`. If\n@@ -154,22 +155,6 @@ pub fn stderr_raw() -> StdWriter {\n     src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n-fn reset_helper(w: Box<Writer:Send>,\n-                f: |&mut Task, Box<Writer:Send>| -> Option<Box<Writer:Send>>)\n-                -> Option<Box<Writer:Send>> {\n-    let mut t = Local::borrow(None::<Task>);\n-    // Be sure to flush any pending output from the writer\n-    match f(&mut *t, w) {\n-        Some(mut w) => {\n-            drop(t);\n-            // FIXME: is failing right here?\n-            w.flush().unwrap();\n-            Some(w)\n-        }\n-        None => None\n-    }\n-}\n-\n /// Resets the task-local stdout handle to the specified writer\n ///\n /// This will replace the current task's stdout handle, returning the old\n@@ -179,7 +164,10 @@ fn reset_helper(w: Box<Writer:Send>,\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stdout stream.\n pub fn set_stdout(stdout: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n-    reset_helper(stdout, |t, w| replace(&mut t.stdout, Some(w)))\n+    local_stdout.replace(Some(stdout)).and_then(|mut s| {\n+        let _ = s.flush();\n+        Some(s)\n+    })\n }\n \n /// Resets the task-local stderr handle to the specified writer\n@@ -191,7 +179,10 @@ pub fn set_stdout(stdout: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n pub fn set_stderr(stderr: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n-    reset_helper(stderr, |t, w| replace(&mut t.stderr, Some(w)))\n+    local_stderr.replace(Some(stderr)).and_then(|mut s| {\n+        let _ = s.flush();\n+        Some(s)\n+    })\n }\n \n // Helper to access the local task's stdout handle\n@@ -204,42 +195,18 @@ pub fn set_stderr(stderr: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n-    let task: Option<Box<Task>> = Local::try_take();\n-    let result = match task {\n-        Some(mut task) => {\n-            // Printing may run arbitrary code, so ensure that the task is in\n-            // TLS to allow all std services. Note that this means a print while\n-            // printing won't use the task's normal stdout handle, but this is\n-            // necessary to ensure safety (no aliasing).\n-            let mut my_stdout = task.stdout.take();\n-            Local::put(task);\n-\n-            if my_stdout.is_none() {\n-                my_stdout = Some(box stdout() as Box<Writer:Send>);\n-            }\n-            let ret = f(*my_stdout.get_mut_ref());\n-\n-            // Note that we need to be careful when putting the stdout handle\n-            // back into the task. If the handle was set to `Some` while\n-            // printing, then we can run aribitrary code when destroying the\n-            // previous handle. This means that the local task needs to be in\n-            // TLS while we do this.\n-            //\n-            // To protect against this, we do a little dance in which we\n-            // temporarily take the task, swap the handles, put the task in TLS,\n-            // and only then drop the previous handle.\n-            let prev = replace(&mut Local::borrow(None::<Task>).stdout, my_stdout);\n-            drop(prev);\n-            ret\n-        }\n-\n-        None => {\n-            let mut io = rt::Stdout;\n-            f(&mut io as &mut Writer)\n-        }\n+fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n+    let result = if Local::exists(None::<Task>) {\n+        let mut my_stdout = local_stdout.replace(None).unwrap_or_else(|| {\n+            box stdout() as Box<Writer:Send>\n+        });\n+        let result = f(my_stdout);\n+        local_stdout.replace(Some(my_stdout));\n+        result\n+    } else {\n+        let mut io = rt::Stdout;\n+        f(&mut io as &mut Writer)\n     };\n-\n     match result {\n         Ok(()) => {}\n         Err(e) => fail!(\"failed printing to stdout: {}\", e),\n@@ -311,7 +278,7 @@ impl Reader for StdReader {\n                 tty.read(buf)\n             },\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n-        };\n+        }.map_err(IoError::from_rtio_error);\n         match ret {\n             // When reading a piped stdin, libuv will return 0-length reads when\n             // stdin reaches EOF. For pretty much all other streams it will\n@@ -342,7 +309,9 @@ impl StdWriter {\n     /// connected to a TTY instance, or if querying the TTY instance fails.\n     pub fn winsize(&mut self) -> IoResult<(int, int)> {\n         match self.inner {\n-            TTY(ref mut tty) => tty.get_winsize(),\n+            TTY(ref mut tty) => {\n+                tty.get_winsize().map_err(IoError::from_rtio_error)\n+            }\n             File(..) => {\n                 Err(IoError {\n                     kind: OtherIoError,\n@@ -362,7 +331,9 @@ impl StdWriter {\n     /// connected to a TTY instance, or if querying the TTY instance fails.\n     pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         match self.inner {\n-            TTY(ref mut tty) => tty.set_raw(raw),\n+            TTY(ref mut tty) => {\n+                tty.set_raw(raw).map_err(IoError::from_rtio_error)\n+            }\n             File(..) => {\n                 Err(IoError {\n                     kind: OtherIoError,\n@@ -387,7 +358,7 @@ impl Writer for StdWriter {\n         match self.inner {\n             TTY(ref mut tty) => tty.write(buf),\n             File(ref mut file) => file.write(buf),\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n }\n \n@@ -413,12 +384,13 @@ mod tests {\n     })\n \n     iotest!(fn capture_stderr() {\n-        use io::{ChanReader, ChanWriter};\n+        use realstd::comm::channel;\n+        use realstd::io::{Writer, ChanReader, ChanWriter, Reader};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n-            set_stderr(box w);\n+            ::realstd::io::stdio::set_stderr(box w);\n             fail!(\"my special message\");\n         });\n         let s = r.read_to_str().unwrap();"}, {"sha": "78b8e55c65174419db0b87f0b26642e1edf4f2de", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -17,11 +17,11 @@ and create receivers which will receive notifications after a period of time.\n \n */\n \n-use comm::Receiver;\n-use io::IoResult;\n+use comm::{Receiver, Sender, channel};\n+use io::{IoResult, IoError};\n use kinds::Send;\n use owned::Box;\n-use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n+use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n \n /// A synchronous timer object\n ///\n@@ -67,6 +67,8 @@ pub struct Timer {\n     obj: Box<RtioTimer:Send>,\n }\n \n+struct TimerCallback { tx: Sender<()> }\n+\n /// Sleep the current task for `msecs` milliseconds.\n pub fn sleep(msecs: u64) {\n     let timer = Timer::new();\n@@ -80,7 +82,9 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> IoResult<Timer> {\n-        LocalIo::maybe_raise(|io| io.timer_init().map(|t| Timer { obj: t }))\n+        LocalIo::maybe_raise(|io| {\n+            io.timer_init().map(|t| Timer { obj: t })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Blocks the current task for `msecs` milliseconds.\n@@ -99,7 +103,9 @@ impl Timer {\n     /// by this timer, and that the returned receiver will be invalidated once\n     /// the timer is destroyed (when it falls out of scope).\n     pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n-        self.obj.oneshot(msecs)\n+        let (tx, rx) = channel();\n+        self.obj.oneshot(msecs, box TimerCallback { tx: tx });\n+        return rx\n     }\n \n     /// Creates a receiver which will have a continuous stream of notifications\n@@ -112,7 +118,15 @@ impl Timer {\n     /// by this timer, and that the returned receiver will be invalidated once\n     /// the timer is destroyed (when it falls out of scope).\n     pub fn periodic(&mut self, msecs: u64) -> Receiver<()> {\n-        self.obj.period(msecs)\n+        let (tx, rx) = channel();\n+        self.obj.period(msecs, box TimerCallback { tx: tx });\n+        return rx\n+    }\n+}\n+\n+impl Callback for TimerCallback {\n+    fn call(&mut self) {\n+        let _ = self.tx.send_opt(());\n     }\n }\n "}, {"sha": "fe5fabef9d95f8f6538d5e6de2a159173a3bfa5c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -103,8 +103,8 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, globs, asm, managed_boxes, thread_local, link_args,\n-           linkage, default_type_params, phase, concat_idents, quad_precision_float)]\n+#![feature(macro_rules, globs, managed_boxes,\n+           linkage, default_type_params, phase)]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -123,9 +123,10 @@\n \n extern crate alloc;\n extern crate core;\n-extern crate libc;\n-extern crate core_rand = \"rand\";\n extern crate core_collections = \"collections\";\n+extern crate core_rand = \"rand\";\n+extern crate libc;\n+extern crate rustrt;\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate realstd = \"std\";\n@@ -168,6 +169,9 @@ pub use core_collections::str;\n pub use core_collections::string;\n pub use core_collections::vec;\n \n+pub use rustrt::c_str;\n+pub use rustrt::local_data;\n+\n // Run tests with libgreen instead of libnative.\n //\n // FIXME: This egregiously hacks around starting the test runner in a different\n@@ -231,19 +235,16 @@ pub mod collections;\n \n pub mod task;\n pub mod comm;\n-pub mod local_data;\n pub mod sync;\n \n \n /* Runtime and platform support */\n \n-pub mod c_str;\n pub mod c_vec;\n pub mod os;\n pub mod io;\n pub mod path;\n pub mod fmt;\n-pub mod cleanup;\n \n // Private APIs\n #[unstable]\n@@ -253,6 +254,7 @@ pub mod unstable;\n // but name resolution doesn't work without it being pub.\n #[unstable]\n pub mod rt;\n+mod failure;\n \n #[doc(hidden)]\n pub fn issue_14344_workaround() { // FIXME #14344 force linkage to happen correctly"}, {"sha": "9a7e061c47282b260cc02b6ec79746e1a1c4d1fa", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -189,7 +189,7 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n "}, {"sha": "c804918ae4b411fd74f364cb702ff6d73dc5d189", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -13,7 +13,7 @@\n //! necessary for running libstd.\n \n // All platforms need to link to rustrt\n-#[link(name = \"rustrt\", kind = \"static\")]\n+#[link(name = \"rust_builtin\", kind = \"static\")]\n extern {}\n \n // LLVM implements the `frem` instruction as a call to `fmod`, which lives in"}, {"sha": "39e420685abd971c0d6e02fbbe0405f161b0ba6a", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -63,7 +63,7 @@ use ptr;\n use rt::heap::{allocate, deallocate};\n use slice::ImmutableVector;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n-use unstable::sync::Exclusive;\n+use rt::exclusive::Exclusive;\n use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n@@ -121,7 +121,7 @@ pub enum Stolen<T> {\n /// will only use this structure when allocating a new buffer or deallocating a\n /// previous one.\n pub struct BufferPool<T> {\n-    pool: Exclusive<Vec<Box<Buffer<T>>>>,\n+    pool: Arc<Exclusive<Vec<Box<Buffer<T>>>>>,\n }\n \n /// An internal buffer used by the chase-lev deque. This structure is actually\n@@ -148,7 +148,7 @@ impl<T: Send> BufferPool<T> {\n     /// Allocates a new buffer pool which in turn can be used to allocate new\n     /// deques.\n     pub fn new() -> BufferPool<T> {\n-        BufferPool { pool: Exclusive::new(vec!()) }\n+        BufferPool { pool: Arc::new(Exclusive::new(vec!())) }\n     }\n \n     /// Allocates a new work-stealing deque which will send/receiving memory to\n@@ -162,25 +162,21 @@ impl<T: Send> BufferPool<T> {\n \n     fn alloc(&self, bits: int) -> Box<Buffer<T>> {\n         unsafe {\n-            self.pool.with(|pool| {\n-                match pool.iter().position(|x| x.size() >= (1 << bits)) {\n-                    Some(i) => pool.remove(i).unwrap(),\n-                    None => box Buffer::new(bits)\n-                }\n-            })\n+            let mut pool = self.pool.lock();\n+            match pool.iter().position(|x| x.size() >= (1 << bits)) {\n+                Some(i) => pool.remove(i).unwrap(),\n+                None => box Buffer::new(bits)\n+            }\n         }\n     }\n \n     fn free(&self, buf: Box<Buffer<T>>) {\n         unsafe {\n-            let mut buf = Some(buf);\n-            self.pool.with(|pool| {\n-                let buf = buf.take_unwrap();\n-                match pool.iter().position(|v| v.size() > buf.size()) {\n-                    Some(i) => pool.insert(i, buf),\n-                    None => pool.push(buf),\n-                }\n-            })\n+            let mut pool = self.pool.lock();\n+            match pool.iter().position(|v| v.size() > buf.size()) {\n+                Some(i) => pool.insert(i, buf),\n+                None => pool.push(buf),\n+            }\n         }\n     }\n }"}, {"sha": "55ebba69d905955eb807ef53f951f3f73073638e", "filename": "src/libstd/task.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -38,12 +38,13 @@\n \n use any::Any;\n use comm::{Sender, Receiver, channel};\n-use io::Writer;\n+use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::{None, Some, Option};\n use owned::Box;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n+use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n \n@@ -53,18 +54,10 @@ use str::{Str, SendStr, IntoMaybeOwned};\n #[cfg(test)] use str::StrAllocating;\n #[cfg(test)] use string::String;\n \n-/// Indicates the manner in which a task exited.\n-///\n-/// A task that completes without failing is considered to exit successfully.\n-///\n-/// If you wish for this result's delivery to block until all\n-/// children tasks complete, recommend using a result future.\n-pub type TaskResult = Result<(), Box<Any:Send>>;\n-\n /// Task configuration options\n pub struct TaskOpts {\n     /// Enable lifecycle notifications on the given channel\n-    pub notify_chan: Option<Sender<TaskResult>>,\n+    pub notify_chan: Option<Sender<task::Result>>,\n     /// A name for the task-to-be, for identification in failure messages\n     pub name: Option<SendStr>,\n     /// The size of the stack for the spawned task\n@@ -114,7 +107,7 @@ impl TaskBuilder {\n     ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> Receiver<TaskResult> {\n+    pub fn future_result(&mut self) -> Receiver<task::Result> {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -180,7 +173,28 @@ impl TaskBuilder {\n             Some(t) => t,\n             None => fail!(\"need a local task to spawn a new task\"),\n         };\n-        t.spawn_sibling(self.opts, f);\n+        let TaskOpts { notify_chan, name, stack_size, stdout, stderr } = self.opts;\n+\n+        let opts = task::TaskOpts {\n+            on_exit: notify_chan.map(|c| proc(r) c.send(r)),\n+            name: name,\n+            stack_size: stack_size,\n+        };\n+        if stdout.is_some() || stderr.is_some() {\n+            t.spawn_sibling(opts, proc() {\n+                match stdout {\n+                    Some(handle) => { let _ = stdio::set_stdout(handle); }\n+                    None => {}\n+                }\n+                match stderr {\n+                    Some(handle) => { let _ = stdio::set_stderr(handle); }\n+                    None => {}\n+                }\n+                f();\n+            });\n+        } else {\n+            t.spawn_sibling(opts, f);\n+        }\n     }\n \n     /**"}, {"sha": "c05cdc85cc53affe5cc9d29ca52ccad48bedfa00", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -224,7 +224,7 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n-        use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire"}, {"sha": "985ef2e142cfd2f6b2bd1422e252deb738110a0e", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2293c6f6ea9291749f51a4608d50585be835f0/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=da2293c6f6ea9291749f51a4608d50585be835f0", "patch": "@@ -11,7 +11,3 @@\n #![doc(hidden)]\n \n pub mod dynamic_lib;\n-\n-pub mod sync;\n-pub mod mutex;\n-"}]}