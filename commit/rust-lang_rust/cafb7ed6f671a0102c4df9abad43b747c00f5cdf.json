{"sha": "cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZmI3ZWQ2ZjY3MWEwMTAyYzRkZjlhYmFkNDNiNzQ3YzAwZjVjZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T14:21:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T14:21:55Z"}, "message": "auto merge of #13099 : FlaPer87/rust/master, r=huonw", "tree": {"sha": "407d3a104a64ebde4e26e5a574ddadf0c47e8df4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/407d3a104a64ebde4e26e5a574ddadf0c47e8df4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "html_url": "https://github.com/rust-lang/rust/commit/cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cd0a5ed268e54c5ba935adc01f9cb0e6bc0348f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd0a5ed268e54c5ba935adc01f9cb0e6bc0348f", "html_url": "https://github.com/rust-lang/rust/commit/1cd0a5ed268e54c5ba935adc01f9cb0e6bc0348f"}, {"sha": "576e36e674d645cd4682cf2df43fb25c3d1a71d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/576e36e674d645cd4682cf2df43fb25c3d1a71d4", "html_url": "https://github.com/rust-lang/rust/commit/576e36e674d645cd4682cf2df43fb25c3d1a71d4"}], "stats": {"total": 1074, "additions": 9, "deletions": 1065}, "files": [{"sha": "5fd08793ce723c672f66a15af2ae21f454f0d695", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_uv]; // remove this after stage0\n-#[allow(attribute_usage)]; // remove this after stage0\n-extern crate native; // remove this after stage0\n-\n #[cfg(rustdoc)]\n extern crate this = \"rustdoc\";\n "}, {"sha": "94e340368feb499d6acfe42047b22523a5a1dde5", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -24,7 +24,6 @@\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[allow(missing_doc)];\n #[feature(managed_boxes)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n extern crate collections;\n "}, {"sha": "fba85b0523127d0148376bd8aac8f229bfd686ca", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -21,7 +21,6 @@\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n #[feature(macro_rules, managed_boxes, default_type_params, phase)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n extern crate rand;\n "}, {"sha": "d586d08bd0d759894cdd5937ad10cc47f30346ad", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -174,7 +174,6 @@\n // NB this does *not* include globs, please keep it that way.\n #[feature(macro_rules, phase)];\n #[allow(visible_private_types)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n extern crate rand;"}, {"sha": "da8f2ea139d1dbb9c6c5359e18448191ab6de4b8", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -50,7 +50,6 @@\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[deny(unused_result, unused_must_use)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "e405ace38670bb6a4417d0f6c75d2afd4aabe6f4", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -71,7 +71,6 @@ println!(\"{:?}\", tuple_ptr)\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n #[feature(macro_rules, managed_boxes, phase)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n #[cfg(test)]\n #[phase(syntax, link)] extern crate log;"}, {"sha": "6aff15301048d79a25644436707c6141bd8b6f3f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -30,7 +30,6 @@ This API is completely unstable and subject to change.\n #[allow(deprecated)];\n #[feature(macro_rules, globs, struct_variant, managed_boxes, quote,\n           default_type_params, phase)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n extern crate flate;\n extern crate arena;"}, {"sha": "82ca84190f7e5a6c5d730f756a60ac771c91a6b6", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -42,7 +42,6 @@ via `close` and `delete` methods.\n #[feature(macro_rules)];\n #[deny(unused_result, unused_must_use)];\n #[allow(visible_private_types)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n #[cfg(test)] extern crate green;\n #[cfg(test)] extern crate realrustuv = \"rustuv\";"}, {"sha": "8a5829da9d6ffad120e3574829335bb54052abbf", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -22,7 +22,6 @@ Core encoding and decoding interfaces.\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[feature(macro_rules, managed_boxes, default_type_params, phase)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n // test harness access\n #[cfg(test)]"}, {"sha": "78e3df4b6f8ebc89202f3f2c80776f7ce12bca70", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -164,90 +164,7 @@ pub trait TyVisitor {\n     fn visit_self(&mut self) -> bool;\n }\n \n-#[cfg(stage0)]\n-extern \"rust-intrinsic\" {\n-    pub fn atomic_cxchg<T>(dst: &mut T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_acq<T>(dst: &mut T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_rel<T>(dst: &mut T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_acqrel<T>(dst: &mut T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_relaxed<T>(dst: &mut T, old: T, src: T) -> T;\n-\n-    pub fn atomic_load<T>(src: &T) -> T;\n-    pub fn atomic_load_acq<T>(src: &T) -> T;\n-    pub fn atomic_load_relaxed<T>(src: &T) -> T;\n-\n-    pub fn atomic_store<T>(dst: &mut T, val: T);\n-    pub fn atomic_store_rel<T>(dst: &mut T, val: T);\n-    pub fn atomic_store_relaxed<T>(dst: &mut T, val: T);\n-\n-    pub fn atomic_xchg<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xchg_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xchg_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xchg_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xchg_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_xadd<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xadd_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xadd_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xadd_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xadd_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_xsub<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xsub_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xsub_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xsub_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xsub_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_and<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_and_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_and_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_and_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_and_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_nand<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_nand_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_nand_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_nand_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_nand_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_or<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_or_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_or_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_or_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_or_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_xor<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xor_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xor_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xor_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_xor_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_max<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_max_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_max_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_max_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_max_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_min<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_min_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_min_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_min_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_min_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_umin<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umin_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umin_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umin_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umin_relaxed<T>(dst: &mut T, src: T) -> T;\n-\n-    pub fn atomic_umax<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umax_acq<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umax_rel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umax_acqrel<T>(dst: &mut T, src: T) -> T;\n-    pub fn atomic_umax_relaxed<T>(dst: &mut T, src: T) -> T;\n-}\n \n-#[cfg(not(stage0))]\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased"}, {"sha": "2ce41a33c29c7f83290183d071d62b08ffefe2df", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -41,16 +41,6 @@ pub trait Pod {\n }\n \n /// Types that can be safely shared between threads, hence thread-safe.\n-#[cfg(stage0)]\n-pub trait Share {\n-    // Empty\n-}\n-\n-#[cfg(stage0)]\n-impl<T> Share for T {}\n-\n-/// Types that can be safely shared between threads, hence thread-safe.\n-#[cfg(not(stage0))]\n #[lang=\"share\"]\n pub trait Share {\n     // Empty"}, {"sha": "021a932fc8bbb87538e8d8350b8ccc97df55c276", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -58,7 +58,6 @@\n #[no_std];\n \n #[deny(missing_doc)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top\n@@ -78,9 +77,6 @@\n #[cfg(test)] pub use cmp = realstd::cmp;\n #[cfg(test)] pub use ty = realstd::ty;\n \n-#[cfg(stage0)]\n-pub use vec_ng = vec;\n-\n // Run tests with libgreen instead of libnative.\n //\n // FIXME: This egregiously hacks around starting the test runner in a different"}, {"sha": "b501972532d62daf791ac9f0890e9d818ae57f27", "filename": "src/libstd/sync/atomics_stage0.rs", "status": "removed", "additions": 0, "deletions": 930, "changes": 930, "blob_url": "https://github.com/rust-lang/rust/blob/1cd0a5ed268e54c5ba935adc01f9cb0e6bc0348f/src%2Flibstd%2Fsync%2Fatomics_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd0a5ed268e54c5ba935adc01f9cb0e6bc0348f/src%2Flibstd%2Fsync%2Fatomics_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics_stage0.rs?ref=1cd0a5ed268e54c5ba935adc01f9cb0e6bc0348f", "patch": "@@ -1,930 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Atomic types\n-//!\n-//! Atomic types provide primitive shared-memory communication between\n-//! threads, and are the building blocks of other concurrent\n-//! types.\n-//!\n-//! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicInt`, `AtomicUint`, and `AtomicOption`.\n-//! Atomic types present operations that, when used correctly, synchronize\n-//! updates between threads.\n-//!\n-//! Each method takes an `Ordering` which represents the strength of\n-//! the memory barrier for that operation. These orderings are the\n-//! same as [C++11 atomic orderings][1].\n-//!\n-//! [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n-//!\n-//! Atomic variables are safe to share between threads (they implement `Share`)\n-//! but they do not themselves provide the mechanism for sharing. The most\n-//! common way to share an atomic variable is to put it into an `Arc` (an\n-//! atomically-reference-counted shared pointer).\n-//!\n-//! Most atomic types may be stored in static variables, initialized using\n-//! the provided static initializers like `INIT_ATOMIC_BOOL`. Atomic statics\n-//! are often used for lazy global initialization.\n-//!\n-//!\n-//! # Examples\n-//!\n-//! A simple spinlock:\n-//!\n-//! ```ignore\n-//! # // FIXME: Needs PR #12430\n-//! extern crate sync;\n-//!\n-//! use sync::Arc;\n-//! use std::sync::atomics::{AtomicUint, SeqCst};\n-//! use std::task::deschedule;\n-//!\n-//! fn main() {\n-//!     let spinlock = Arc::new(AtomicUint::new(1));\n-//!\n-//!     let spinlock_clone = spinlock.clone();\n-//!     spawn(proc() {\n-//!         spinlock_clone.store(0, SeqCst);\n-//!     });\n-//!\n-//!     // Wait for the other task to release the lock\n-//!     while spinlock.load(SeqCst) != 0 {\n-//!         // Since tasks may not be preemptive (if they are green threads)\n-//!         // yield to the scheduler to let the other task run. Low level\n-//!         // concurrent code needs to take into account Rust's two threading\n-//!         // models.\n-//!         deschedule();\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! Transferring a heap object with `AtomicOption`:\n-//!\n-//! ```ignore\n-//! # // FIXME: Needs PR #12430\n-//! extern crate sync;\n-//!\n-//! use sync::Arc;\n-//! use std::sync::atomics::{AtomicOption, SeqCst};\n-//!\n-//! fn main() {\n-//!     struct BigObject;\n-//!\n-//!     let shared_big_object = Arc::new(AtomicOption::empty());\n-//!\n-//!     let shared_big_object_clone = shared_big_object.clone();\n-//!     spawn(proc() {\n-//!         let unwrapped_big_object = shared_big_object_clone.take(SeqCst);\n-//!         if unwrapped_big_object.is_some() {\n-//!             println!(\"got a big object from another task\");\n-//!         } else {\n-//!             println!(\"other task hasn't sent big object yet\");\n-//!         }\n-//!     });\n-//!\n-//!     shared_big_object.swap(~BigObject, SeqCst);\n-//! }\n-//! ```\n-//!\n-//! Keep a global count of live tasks:\n-//!\n-//! ```\n-//! use std::sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n-//!\n-//! static mut GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n-//!\n-//! unsafe {\n-//!     let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n-//!     println!(\"live tasks: {}\", old_task_count + 1);\n-//! }\n-//! ```\n-\n-#[allow(missing_doc)];\n-\n-use intrinsics;\n-use cast;\n-use std::kinds::marker;\n-use option::{Option,Some,None};\n-use ops::Drop;\n-use ty::Unsafe;\n-\n-/// An atomic boolean type.\n-pub struct AtomicBool {\n-    priv v: Unsafe<uint>,\n-    priv nopod: marker::NoPod\n-}\n-\n-/// A signed atomic integer type, supporting basic atomic arithmetic operations\n-pub struct AtomicInt {\n-    priv v: Unsafe<int>,\n-    priv nopod: marker::NoPod\n-}\n-\n-/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n-pub struct AtomicUint {\n-    priv v: Unsafe<uint>,\n-    priv nopod: marker::NoPod\n-}\n-\n-/// An unsigned atomic integer type that is forced to be 64-bits. This does not\n-/// support all operations.\n-pub struct AtomicU64 {\n-    priv v: Unsafe<u64>,\n-    priv nopod: marker::NoPod\n-}\n-\n-/// An unsafe atomic pointer. Only supports basic atomic operations\n-pub struct AtomicPtr<T> {\n-    priv p: Unsafe<uint>,\n-    priv nopod: marker::NoPod\n-}\n-\n-/// An atomic, nullable unique pointer\n-///\n-/// This can be used as the concurrency primitive for operations that transfer\n-/// owned heap objects across tasks.\n-#[unsafe_no_drop_flag]\n-pub struct AtomicOption<T> {\n-    priv p: Unsafe<uint>,\n-}\n-\n-/// Atomic memory orderings\n-///\n-/// Memory orderings limit the ways that both the compiler and CPU may reorder\n-/// instructions around atomic operations. At its most restrictive,\n-/// \"sequentially consistent\" atomics allow neither reads nor writes\n-/// to be moved either before or after the atomic operation; on the other end\n-/// \"relaxed\" atomics allow all reorderings.\n-///\n-/// Rust's memory orderings are the same as in C++[1].\n-///\n-/// [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n-pub enum Ordering {\n-    /// No ordering constraints, only atomic operations\n-    Relaxed,\n-    /// When coupled with a store, all previous writes become visible\n-    /// to another thread that performs a load with `Acquire` ordering\n-    /// on the same value\n-    Release,\n-    /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with `Release` ordering on the same value\n-    /// in another thread\n-    Acquire,\n-    /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering\n-    AcqRel,\n-    /// Like `AcqRel` with the additional guarantee that all threads see all\n-    /// sequentially consistent operations in the same order.\n-    SeqCst\n-}\n-\n-/// An `AtomicBool` initialized to `false`\n-pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nopod: marker::NoPod };\n-/// An `AtomicInt` initialized to `0`\n-pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nopod: marker::NoPod };\n-/// An `AtomicUint` initialized to `0`\n-pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nopod: marker::NoPod };\n-/// An `AtomicU64` initialized to `0`\n-pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: Unsafe{value: 0,\n-                                                               marker1: marker::InvariantType},\n-                                                     nopod: marker::NoPod };\n-\n-\n-// NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n-static UINT_TRUE: uint = -1;\n-\n-impl AtomicBool {\n-    /// Create a new `AtomicBool`\n-    pub fn new(v: bool) -> AtomicBool {\n-        let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: Unsafe::new(val), nopod: marker::NoPod }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&*self.v.get(), order) > 0 }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&mut self, val: bool, order: Ordering) {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # // FIXME: Needs PR #12430\n-    /// extern crate sync;\n-    ///\n-    /// use sync::Arc;\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// fn main() {\n-    ///     let spinlock = Arc::new(AtomicBool::new(false));\n-    ///     let spinlock_clone = spin_lock.clone();\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n-    ///     });\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n-    ///     });\n-    /// }\n-    ///\n-    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n-    ///     // CAS loop until we are able to replace `false` with `true`\n-    ///     while spinlock.compare_and_swap(false, true, SeqCst) == false {\n-    ///         // Since tasks may not be preemptive (if they are green threads)\n-    ///         // yield to the scheduler to let the other task run. Low level\n-    ///         // concurrent code needs to take into account Rust's two threading\n-    ///         // models.\n-    ///         deschedule();\n-    ///     }\n-    ///\n-    ///     // Now we have the spinlock\n-    ///     f();\n-    ///\n-    ///     // Release the lock\n-    ///     spinlock.store(false);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn compare_and_swap(&mut self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { UINT_TRUE } else { 0 };\n-        let new = if new { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) > 0 }\n-    }\n-\n-    /// A logical \"and\" operation\n-    ///\n-    /// Performs a logical \"and\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_and(&mut *self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"nand\" operation\n-    ///\n-    /// Performs a logical \"nand\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst) as int);\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_nand(&mut *self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"or\" operation\n-    ///\n-    /// Performs a logical \"or\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_or(&mut *self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"xor\" operation\n-    ///\n-    /// Performs a logical \"xor\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let mut foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_xor(&mut *self.v.get(), val, order) > 0 }\n-    }\n-}\n-\n-impl AtomicInt {\n-    /// Create a new `AtomicInt`\n-    pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: Unsafe::new(v), nopod: marker::NoPod}\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(&*self.v.get(), order) }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&mut self, val: int, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n-    }\n-\n-    /// Add to the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicInt, SeqCst};\n-    ///\n-    /// let mut foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicInt, SeqCst};\n-    ///\n-    /// let mut foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(-10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n-    }\n-}\n-\n-// temporary workaround\n-// it causes link failure on MIPS target\n-// libgcc doesn't implement 64-bit atomic operations for MIPS32\n-#[cfg(not(target_arch = \"mips\"))]\n-impl AtomicU64 {\n-    pub fn new(v: u64) -> AtomicU64 {\n-        AtomicU64 { v: Unsafe::new(v), nopod: marker::NoPod }\n-    }\n-\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> u64 {\n-        unsafe { atomic_load(&*self.v.get(), order) }\n-    }\n-\n-    #[inline]\n-    pub fn store(&mut self, val: u64, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n-    }\n-\n-    #[inline]\n-    pub fn swap(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn compare_and_swap(&mut self, old: u64, new: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_add(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_sub(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n-    }\n-}\n-\n-impl AtomicUint {\n-    /// Create a new `AtomicUint`\n-    pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: Unsafe::new(v), nopod: marker::NoPod }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(&*self.v.get(), order) }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&mut self, val: uint, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n-    }\n-\n-    /// Add to the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let mut foo = AtomicUint::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let mut foo = AtomicUint::new(10);\n-    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n-    }\n-}\n-\n-impl<T> AtomicPtr<T> {\n-    /// Create a new `AtomicPtr`\n-    pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: Unsafe::new(p as uint), nopod: marker::NoPod }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_load(&*self.p.get(), order) as *mut T\n-        }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.p.get(), ptr as uint, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(&mut *self.p.get(), ptr as uint, order) as *mut T }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_compare_and_swap(&mut *self.p.get(), old as uint,\n-                                    new as uint, order) as *mut T\n-        }\n-    }\n-}\n-\n-impl<T> AtomicOption<T> {\n-    /// Create a new `AtomicOption`\n-    pub fn new(p: ~T) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: Unsafe::new(cast::transmute(p)) } }\n-    }\n-\n-    /// Create a new `AtomicOption` that doesn't contain a value\n-    pub fn empty() -> AtomicOption<T> { AtomicOption { p: Unsafe::new(0) } }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n-        unsafe {\n-            let val = cast::transmute(val);\n-\n-            let p = atomic_swap(&mut *self.p.get(), val, order);\n-            if p as uint == 0 {\n-                None\n-            } else {\n-                Some(cast::transmute(p))\n-            }\n-        }\n-    }\n-\n-    /// Remove the value, leaving the `AtomicOption` empty.\n-    #[inline]\n-    pub fn take(&mut self, order: Ordering) -> Option<~T> {\n-        unsafe { self.swap(cast::transmute(0), order) }\n-    }\n-\n-    /// Replace an empty value with a non-empty value.\n-    ///\n-    /// Succeeds if the option is `None` and returns `None` if so. If\n-    /// the option was already `Some`, returns `Some` of the rejected\n-    /// value.\n-    #[inline]\n-    pub fn fill(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n-        unsafe {\n-            let val = cast::transmute(val);\n-            let expected = cast::transmute(0);\n-            let oldval = atomic_compare_and_swap(&mut *self.p.get(), expected, val, order);\n-            if oldval == expected {\n-                None\n-            } else {\n-                Some(cast::transmute(val))\n-            }\n-        }\n-    }\n-\n-    /// Returns `true` if the `AtomicOption` is empty.\n-    ///\n-    /// Be careful: The caller must have some external method of ensuring the\n-    /// result does not get invalidated by another task after this returns.\n-    #[inline]\n-    pub fn is_empty(&mut self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&*self.p.get(), order) as uint == 0 }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for AtomicOption<T> {\n-    fn drop(&mut self) {\n-        let _ = self.take(SeqCst);\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n-    match order {\n-        Release => intrinsics::atomic_store_rel(dst, val),\n-        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        _       => intrinsics::atomic_store(dst, val)\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_load_acq(dst),\n-        Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        _       => intrinsics::atomic_load(dst)\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-        Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        _       => intrinsics::atomic_xchg(dst, val)\n-    }\n-}\n-\n-/// Returns the old value (like __sync_fetch_and_add).\n-#[inline]\n-pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-        Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        _       => intrinsics::atomic_xadd(dst, val)\n-    }\n-}\n-\n-/// Returns the old value (like __sync_fetch_and_sub).\n-#[inline]\n-pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-        Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        _       => intrinsics::atomic_xsub(dst, val)\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n-        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-        Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        _       => intrinsics::atomic_cxchg(dst, old, new),\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_and_acq(dst, val),\n-        Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        _       => intrinsics::atomic_and(dst, val)\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_nand_acq(dst, val),\n-        Release => intrinsics::atomic_nand_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-        _       => intrinsics::atomic_nand(dst, val)\n-    }\n-}\n-\n-\n-#[inline]\n-pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_or_acq(dst, val),\n-        Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        _       => intrinsics::atomic_or(dst, val)\n-    }\n-}\n-\n-\n-#[inline]\n-pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xor_acq(dst, val),\n-        Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        _       => intrinsics::atomic_xor(dst, val)\n-    }\n-}\n-\n-\n-/// An atomic fence.\n-///\n-/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n-/// atomic operations X and Y, both operating on some atomic object 'M' such\n-/// that A is sequenced before X, Y is synchronized before B and Y observers\n-/// the change to M. This provides a happens-before dependence between A and B.\n-///\n-/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n-/// with a fence.\n-///\n-/// A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n-/// `Release` semantics, participates in the global program order of the other\n-/// `SeqCst` operations and/or fences.\n-///\n-/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n-///\n-/// # Failure\n-///\n-/// Fails if `order` is `Relaxed`\n-#[inline]\n-pub fn fence(order: Ordering) {\n-    unsafe {\n-        match order {\n-            Acquire => intrinsics::atomic_fence_acq(),\n-            Release => intrinsics::atomic_fence_rel(),\n-            AcqRel  => intrinsics::atomic_fence_acqrel(),\n-            SeqCst  => intrinsics::atomic_fence(),\n-            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use option::*;\n-    use super::*;\n-\n-    #[test]\n-    fn bool_() {\n-        let mut a = AtomicBool::new(false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n-\n-        a.store(false, SeqCst);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-    }\n-\n-    #[test]\n-    fn option_empty() {\n-        let mut option: AtomicOption<()> = AtomicOption::empty();\n-        assert!(option.is_empty(SeqCst));\n-    }\n-\n-    #[test]\n-    fn option_swap() {\n-        let mut p = AtomicOption::new(~1);\n-        let a = ~2;\n-\n-        let b = p.swap(a, SeqCst);\n-\n-        assert_eq!(b, Some(~1));\n-        assert_eq!(p.take(SeqCst), Some(~2));\n-    }\n-\n-    #[test]\n-    fn option_take() {\n-        let mut p = AtomicOption::new(~1);\n-\n-        assert_eq!(p.take(SeqCst), Some(~1));\n-        assert_eq!(p.take(SeqCst), None);\n-\n-        let p2 = ~2;\n-        p.swap(p2, SeqCst);\n-\n-        assert_eq!(p.take(SeqCst), Some(~2));\n-    }\n-\n-    #[test]\n-    fn option_fill() {\n-        let mut p = AtomicOption::new(~1);\n-        assert!(p.fill(~2, SeqCst).is_some()); // should fail; shouldn't leak!\n-        assert_eq!(p.take(SeqCst), Some(~1));\n-\n-        assert!(p.fill(~2, SeqCst).is_none()); // shouldn't fail\n-        assert_eq!(p.take(SeqCst), Some(~2));\n-    }\n-\n-    #[test]\n-    fn bool_and() {\n-        let mut a = AtomicBool::new(true);\n-        assert_eq!(a.fetch_and(false, SeqCst),true);\n-        assert_eq!(a.load(SeqCst),false);\n-    }\n-\n-    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n-\n-    #[test]\n-    fn static_init() {\n-        unsafe {\n-            assert!(!S_BOOL.load(SeqCst));\n-            assert!(S_INT.load(SeqCst) == 0);\n-            assert!(S_UINT.load(SeqCst) == 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn different_sizes() {\n-        unsafe {\n-            let mut slot = 0u16;\n-            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n-\n-            let mut slot = 0u8;\n-            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n-\n-            let mut slot = 0u32;\n-            assert_eq!(super::atomic_load(&mut slot, SeqCst), 0);\n-\n-            let mut slot = 0u64;\n-            super::atomic_store(&mut slot, 2, SeqCst);\n-        }\n-    }\n-}\n-"}, {"sha": "3213c538152c676ce8bbfd659e6205b5662a6442", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -16,10 +16,6 @@\n //! other types of concurrent primitives.\n \n pub mod arc;\n-#[cfg(stage0)]\n-#[path = \"atomics_stage0.rs\"]\n-pub mod atomics;\n-#[cfg(not(stage0))]\n pub mod atomics;\n pub mod deque;\n pub mod mpmc_bounded_queue;"}, {"sha": "ae8be25205d41aeaebf503771edf6357216b7929", "filename": "src/libstd/ty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibstd%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fty.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -45,7 +45,6 @@ use kinds::marker;\n ///\n /// **NOTE:** Unsafe<T> fields are public to allow static initializers. It is not recommended\n /// to access its fields directly, `get` should be used instead.\n-#[cfg(not(stage0))]\n #[lang=\"unsafe\"]\n pub struct Unsafe<T> {\n     /// Wrapped value\n@@ -55,16 +54,6 @@ pub struct Unsafe<T> {\n     marker1: marker::InvariantType<T>\n }\n \n-/// Unsafe type for stage0\n-#[cfg(stage0)]\n-pub struct Unsafe<T> {\n-    /// Wrapped value\n-    value: T,\n-\n-    /// Invariance marker\n-    marker1: marker::InvariantType<T>\n-}\n-\n impl<T> Unsafe<T> {\n \n     /// Static constructor"}, {"sha": "0bc3b121a887bb8eab45720448c39f8aa654da9c", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -50,13 +50,10 @@ use sync;\n use sync::{Mutex, RWLock};\n \n use std::cast;\n-use std::kinds::marker;\n+use std::kinds::{Share, marker};\n use std::sync::arc::UnsafeArc;\n use std::task;\n \n-#[cfg(stage0)]\n-use std::kinds::Share;\n-\n /// As sync::condvar, a mechanism for unlock-and-descheduling and\n /// signaling, for use with the Arc types.\n pub struct ArcCondvar<'a> {"}, {"sha": "70874a029ac42aa9e1d1bd306d2d421cf2c7d498", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -20,7 +20,6 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[feature(phase)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n "}, {"sha": "4de17dc598b0ec9dd515492086731cd5563cfbc3", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -28,7 +28,6 @@ This API is completely unstable and subject to change.\n \n #[feature(macro_rules, globs, managed_boxes, default_type_params, phase,\n           quote)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n #[allow(deprecated)];\n \n extern crate serialize;"}, {"sha": "126790bd46ac63de7e7346d184982ba8202debea", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -20,7 +20,6 @@\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n #[feature(macro_rules)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n extern crate collections;\n "}, {"sha": "3338c3a30097ed67de28226ccd49075df0f46508", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -64,10 +64,6 @@ Examples of string representations:\n \n #[feature(default_type_params)];\n \n-// NOTE remove the following two attributes after the next snapshot.\n-#[allow(unrecognized_lint)];\n-#[allow(default_type_param_usage)];\n-\n // test harness access\n #[cfg(test)]\n extern crate test;"}, {"sha": "f7f1c2d6aa378b1bcac361ee1eb4fd0e71996265", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cafb7ed6f671a0102c4df9abad43b747c00f5cdf/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=cafb7ed6f671a0102c4df9abad43b747c00f5cdf", "patch": "@@ -1,3 +1,11 @@\n+S 2014-03-22 94e4e91\n+  freebsd-x86_64 7793127e1b9ad22cb2e020f9bb01f34526cc4656\n+  linux-i386 aa53699d32d7acb86a6447f988c4ac73ac310bab\n+  linux-x86_64 7ca5d5bfeec8d05ee3503bb48e4c5f6d75a6b49c\n+  macos-i386 bc33e8fabe4d95848e91f5648268a6cc974d5468\n+  macos-x86_64 99da3ba5ec8924ccc0ad1fc17e2e04d1c29fccd0\n+  winnt-i386 578102567096d97b353b291076bdfa1e9da62513\n+\n S 2014-03-19 4ca51ae\n   freebsd-x86_64 3059005ca4ee2972bb705313bfb7848e859a20cd\n   linux-i386 8907cd4ce8b8301d70a6bbc0100c955444270c19"}]}