{"sha": "590fdba28468d53dcfc498dc863202b924f89ffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MGZkYmEyODQ2OGQ1M2RjZmM0OThkYzg2MzIwMmI5MjRmODlmZmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-30T18:22:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-30T18:22:03Z"}, "message": "Merge #6415\n\n6415: Upgrade Chalk to 0.36 r=flodiebold a=flodiebold\n\nQuite a few changes, because Chalk got rid of the `ApplicationTy` nesting.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "d90d187602f6a1373f3ee574acf563a5792241d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d90d187602f6a1373f3ee574acf563a5792241d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/590fdba28468d53dcfc498dc863202b924f89ffa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfnFnLCRBK7hj4Ov3rIwAAdHIIAIrG67XDAQQOyfl68dnksj4c\nplRDC/lB0JQ9Hb+LMEdZdOzmOrc50Y0zOZrW1FNxjRl1apCs7l8joFiFmG6gngLQ\nudwmMsr4SujiNr2MZQiCysb6ovFX3u/UwtnYiwCx3LW5wF155r6LpDWPlgNO4WFx\nJ1mkQ6iNoAxdVdU/DX1Dt4OMVnFuJMj3QFXAY2XpcSMNJmQUaKw2lRgaxpSglS+5\nXSy/BCMJ89/X35Ohcq22XMjBNkI9VQsswyMnomxPopC9B0i9mpOmdn5lDzmgrtVA\np/PuAdPibKbU27jhOqqMDHv9kcqDq3IgRDUiYRoVBlMD+7Vv/aQr8ikIWSI4zNE=\n=fvKW\n-----END PGP SIGNATURE-----\n", "payload": "tree d90d187602f6a1373f3ee574acf563a5792241d0\nparent e7c8c600b783bbf12deb952a2e10be23264de953\nparent bca51e35190e47688ccf252c367a7951d36dadad\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604082123 +0000\ncommitter GitHub <noreply@github.com> 1604082123 +0000\n\nMerge #6415\n\n6415: Upgrade Chalk to 0.36 r=flodiebold a=flodiebold\n\nQuite a few changes, because Chalk got rid of the `ApplicationTy` nesting.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/590fdba28468d53dcfc498dc863202b924f89ffa", "html_url": "https://github.com/rust-lang/rust/commit/590fdba28468d53dcfc498dc863202b924f89ffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/590fdba28468d53dcfc498dc863202b924f89ffa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7c8c600b783bbf12deb952a2e10be23264de953", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c8c600b783bbf12deb952a2e10be23264de953", "html_url": "https://github.com/rust-lang/rust/commit/e7c8c600b783bbf12deb952a2e10be23264de953"}, {"sha": "bca51e35190e47688ccf252c367a7951d36dadad", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca51e35190e47688ccf252c367a7951d36dadad", "html_url": "https://github.com/rust-lang/rust/commit/bca51e35190e47688ccf252c367a7951d36dadad"}], "stats": {"total": 517, "additions": 188, "deletions": 329}, "files": [{"sha": "c1354335cd6a7f8a48572f6d6af9991586ce7036", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -168,9 +168,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.34.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e9f986750ecb4df889d0a95d4586bd921889497b33908cc75bb80eadb4c600a\"\n+checksum = \"9f88ce4deae1dace71e49b7611cfae2d5489de3530d6daba5758043c47ac3a10\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -180,19 +180,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.34.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5c352c4649f1408bb3de5d86a248fda78d3d9cd1cbbd9502e7eca1be1e7ac368\"\n+checksum = \"63362c629c2014ab639b04029070763fb8224df136d1363d30e9ece4c8877da3\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.34.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7294bb2ac5446fcb83ec9524b9113f59a8913f174a9c1dea6db60532f17a1579\"\n+checksum = \"5274a882b664121d5827d4f116f5bd8331e0eac3d501ab8038e9d5c5bc5a2689\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -203,9 +203,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.34.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ffbca06963ed6f3d22faed840847a685f02feefa3825c0b94f9b791d03a0ac6f\"\n+checksum = \"cac338a67af52a7f50bb2f8232e730a3518ce432dbe303246acfe525ddd838c7\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "e30ef0e2f6e10fab6842c25aeea7a939b6124fb5", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -22,7 +22,6 @@ debug = 0 # Set this to 1 or 2 to get more useful backtraces in debugger.\n [patch.'crates-io']\n # rowan = { path = \"../rowan\" }\n \n-[patch.'https://github.com/rust-lang/chalk.git']\n # chalk-solve = { path = \"../chalk/chalk-solve\" }\n-# chalk-rust-ir = { path = \"../chalk/chalk-rust-ir\" }\n # chalk-ir = { path = \"../chalk/chalk-ir\" }\n+# chalk-recursive = { path = \"../chalk/chalk-recursive\" }"}, {"sha": "3b822d22333a71d1b6efe02af296d50120e06ebf", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -17,9 +17,9 @@ ena = \"0.14.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1\"\n-chalk-solve = { version = \"0.34\", default-features = false }\n-chalk-ir = \"0.34\"\n-chalk-recursive = \"0.34\"\n+chalk-solve = { version = \"0.36\", default-features = false }\n+chalk-ir = \"0.36\"\n+chalk-recursive = \"0.36\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n hir_def = { path = \"../hir_def\", version = \"0.0.0\" }"}, {"sha": "a6c247f87bdfb352bb9ea2591a97fc9595f54fd9", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{fold::shift::Shift, CanonicalVarKinds, GenericArg, TypeName};\n+use chalk_ir::{fold::shift::Shift, CanonicalVarKinds, GenericArg};\n use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::{salsa::InternKey, CrateId};\n@@ -81,7 +81,10 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n         let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref(&Interner).clone());\n \n-        fn binder_kind(ty: &Ty, binders: &CanonicalVarKinds<Interner>) -> Option<chalk_ir::TyKind> {\n+        fn binder_kind(\n+            ty: &Ty,\n+            binders: &CanonicalVarKinds<Interner>,\n+        ) -> Option<chalk_ir::TyVariableKind> {\n             if let Ty::Bound(bv) = ty {\n                 let binders = binders.as_slice(&Interner);\n                 if bv.debruijn == DebruijnIndex::INNERMOST {\n@@ -95,8 +98,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n         let self_ty_fp = TyFingerprint::for_impl(&ty);\n         let fps: &[TyFingerprint] = match binder_kind(&ty, binders) {\n-            Some(chalk_ir::TyKind::Integer) => &ALL_INT_FPS,\n-            Some(chalk_ir::TyKind::Float) => &ALL_FLOAT_FPS,\n+            Some(chalk_ir::TyVariableKind::Integer) => &ALL_INT_FPS,\n+            Some(chalk_ir::TyVariableKind::Float) => &ALL_FLOAT_FPS,\n             _ => self_ty_fp.as_ref().map(std::slice::from_ref).unwrap_or(&[]),\n         };\n \n@@ -129,12 +132,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n     }\n-    fn impl_provided_for(\n-        &self,\n-        auto_trait_id: TraitId,\n-        application_ty: &chalk_ir::ApplicationTy<Interner>,\n-    ) -> bool {\n-        debug!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, application_ty);\n+    fn impl_provided_for(&self, auto_trait_id: TraitId, kind: &chalk_ir::TyKind<Interner>) -> bool {\n+        debug!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, kind);\n         false // FIXME\n     }\n     fn associated_ty_value(&self, id: AssociatedTyValueId) -> Arc<AssociatedTyValue> {\n@@ -466,7 +465,7 @@ pub(crate) fn struct_datum_query(\n     struct_id: AdtId,\n ) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n-    let type_ctor: TypeCtor = from_chalk(db, TypeName::Adt(struct_id));\n+    let type_ctor = TypeCtor::Adt(from_chalk(db, struct_id));\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n     let num_params = type_ctor.num_ty_params(db);\n     let upstream = type_ctor.krate(db) != Some(krate);"}, {"sha": "f65873872780674318ddec4fafd97d365ffba6ce", "filename": "crates/hir_ty/src/traits/chalk/interner.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -122,13 +122,6 @@ impl chalk_ir::interner::Interner for Interner {\n         tls::with_current_program(|prog| Some(prog?.debug_program_clause_implication(pci, fmt)))\n     }\n \n-    fn debug_application_ty(\n-        application_ty: &chalk_ir::ApplicationTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_application_ty(application_ty, fmt)))\n-    }\n-\n     fn debug_substitution(\n         substitution: &chalk_ir::Substitution<Interner>,\n         fmt: &mut fmt::Formatter<'_>,"}, {"sha": "58c337b40dd04dcbf941db9386b0e9db51df19f9", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 157, "deletions": 199, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -5,7 +5,7 @@\n \n use chalk_ir::{\n     cast::Cast, fold::shift::Shift, interner::HasInterner, LifetimeData, PlaceholderIndex, Scalar,\n-    TypeName, UniverseIndex,\n+    UniverseIndex,\n };\n use chalk_solve::rust_ir;\n \n@@ -32,7 +32,7 @@ impl ToChalk for Ty {\n                 TypeCtor::Array => array_to_chalk(db, apply_ty.parameters),\n                 TypeCtor::FnPtr { num_args: _, is_varargs } => {\n                     let substitution = apply_ty.parameters.to_chalk(db).shifted_in(&Interner);\n-                    chalk_ir::TyData::Function(chalk_ir::FnPointer {\n+                    chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                         num_binders: 0,\n                         sig: chalk_ir::FnSig {\n                             abi: (),\n@@ -43,10 +43,68 @@ impl ToChalk for Ty {\n                     })\n                     .intern(&Interner)\n                 }\n-                _ => {\n-                    let name = apply_ty.ctor.to_chalk(db);\n+                TypeCtor::AssociatedType(type_alias) => {\n+                    let assoc_type = TypeAliasAsAssocType(type_alias);\n+                    let assoc_type_id = assoc_type.to_chalk(db);\n                     let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n+                    chalk_ir::TyKind::AssociatedType(assoc_type_id, substitution).intern(&Interner)\n+                }\n+\n+                TypeCtor::OpaqueType(impl_trait_id) => {\n+                    let id = impl_trait_id.to_chalk(db);\n+                    let substitution = apply_ty.parameters.to_chalk(db);\n+                    chalk_ir::TyKind::OpaqueType(id, substitution).intern(&Interner)\n+                }\n+\n+                TypeCtor::ForeignType(type_alias) => {\n+                    let foreign_type = TypeAliasAsForeignType(type_alias);\n+                    let foreign_type_id = foreign_type.to_chalk(db);\n+                    chalk_ir::TyKind::Foreign(foreign_type_id).intern(&Interner)\n+                }\n+\n+                TypeCtor::Bool => chalk_ir::TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+                TypeCtor::Char => chalk_ir::TyKind::Scalar(Scalar::Char).intern(&Interner),\n+                TypeCtor::Int(int_ty) => {\n+                    chalk_ir::TyKind::Scalar(int_ty_to_chalk(int_ty)).intern(&Interner)\n+                }\n+                TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }) => {\n+                    chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n+                        .intern(&Interner)\n+                }\n+                TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }) => {\n+                    chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n+                        .intern(&Interner)\n+                }\n+\n+                TypeCtor::Tuple { cardinality } => {\n+                    let substitution = apply_ty.parameters.to_chalk(db);\n+                    chalk_ir::TyKind::Tuple(cardinality.into(), substitution).intern(&Interner)\n+                }\n+                TypeCtor::RawPtr(mutability) => {\n+                    let ty = apply_ty.parameters[0].clone().to_chalk(db);\n+                    chalk_ir::TyKind::Raw(mutability.to_chalk(db), ty).intern(&Interner)\n+                }\n+                TypeCtor::Slice => {\n+                    chalk_ir::TyKind::Slice(apply_ty.parameters[0].clone().to_chalk(db))\n+                        .intern(&Interner)\n+                }\n+                TypeCtor::Str => chalk_ir::TyKind::Str.intern(&Interner),\n+                TypeCtor::FnDef(callable_def) => {\n+                    let id = callable_def.to_chalk(db);\n+                    let substitution = apply_ty.parameters.to_chalk(db);\n+                    chalk_ir::TyKind::FnDef(id, substitution).intern(&Interner)\n+                }\n+                TypeCtor::Never => chalk_ir::TyKind::Never.intern(&Interner),\n+\n+                TypeCtor::Closure { def, expr } => {\n+                    let closure_id = db.intern_closure((def, expr));\n+                    let substitution = apply_ty.parameters.to_chalk(db);\n+                    chalk_ir::TyKind::Closure(closure_id.into(), substitution).intern(&Interner)\n+                }\n+\n+                TypeCtor::Adt(adt_id) => {\n+                    let substitution = apply_ty.parameters.to_chalk(db);\n+                    chalk_ir::TyKind::Adt(chalk_ir::AdtId(adt_id), substitution).intern(&Interner)\n                 }\n             },\n             Ty::Projection(proj_ty) => {\n@@ -67,7 +125,7 @@ impl ToChalk for Ty {\n                 }\n                 .to_ty::<Interner>(&Interner)\n             }\n-            Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx).intern(&Interner),\n+            Ty::Bound(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             Ty::Dyn(predicates) => {\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n@@ -78,55 +136,45 @@ impl ToChalk for Ty {\n                     bounds: make_binders(where_clauses, 1),\n                     lifetime: LifetimeData::Static.intern(&Interner),\n                 };\n-                chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n+                chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n             }\n             Ty::Opaque(opaque_ty) => {\n                 let opaque_ty_id = opaque_ty.opaque_ty_id.to_chalk(db);\n                 let substitution = opaque_ty.parameters.to_chalk(db);\n-                chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+                chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id,\n                     substitution,\n                 }))\n                 .intern(&Interner)\n             }\n-            Ty::Unknown => {\n-                let substitution = chalk_ir::Substitution::empty(&Interner);\n-                let name = TypeName::Error;\n-                chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n-            }\n+            Ty::Unknown => chalk_ir::TyKind::Error.intern(&Interner),\n         }\n     }\n     fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n-        match chalk.data(&Interner).clone() {\n-            chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n-                TypeName::Error => Ty::Unknown,\n-                TypeName::Ref(m) => ref_from_chalk(db, m, apply_ty.substitution),\n-                TypeName::Array => array_from_chalk(db, apply_ty.substitution),\n-                _ => {\n-                    let ctor = from_chalk(db, apply_ty.name);\n-                    let parameters = from_chalk(db, apply_ty.substitution);\n-                    Ty::Apply(ApplicationTy { ctor, parameters })\n-                }\n-            },\n-            chalk_ir::TyData::Placeholder(idx) => {\n+        match chalk.data(&Interner).kind.clone() {\n+            chalk_ir::TyKind::Error => Ty::Unknown,\n+            chalk_ir::TyKind::Array(ty, _size) => {\n+                Ty::apply(TypeCtor::Array, Substs::single(from_chalk(db, ty)))\n+            }\n+            chalk_ir::TyKind::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n                 let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n                     crate::salsa::InternId::from(idx.idx),\n                 );\n                 Ty::Placeholder(db.lookup_intern_type_param_id(interned_id))\n             }\n-            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n+            chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n                 let associated_ty =\n                     from_chalk::<TypeAliasAsAssocType, _>(db, proj.associated_ty_id).0;\n                 let parameters = from_chalk(db, proj.substitution);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n+            chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n                 let impl_trait_id = from_chalk(db, opaque_ty.opaque_ty_id);\n                 let parameters = from_chalk(db, opaque_ty.substitution);\n                 Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n             }\n-            chalk_ir::TyData::Function(chalk_ir::FnPointer {\n+            chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                 num_binders,\n                 sig: chalk_ir::FnSig { variadic, .. },\n                 substitution,\n@@ -145,9 +193,9 @@ impl ToChalk for Ty {\n                     parameters,\n                 })\n             }\n-            chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx),\n-            chalk_ir::TyData::InferenceVar(_iv, _kind) => Ty::Unknown,\n-            chalk_ir::TyData::Dyn(where_clauses) => {\n+            chalk_ir::TyKind::BoundVar(idx) => Ty::Bound(idx),\n+            chalk_ir::TyKind::InferenceVar(_iv, _kind) => Ty::Unknown,\n+            chalk_ir::TyKind::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n                 let predicates = where_clauses\n                     .bounds\n@@ -157,10 +205,76 @@ impl ToChalk for Ty {\n                     .collect();\n                 Ty::Dyn(predicates)\n             }\n+\n+            chalk_ir::TyKind::Adt(struct_id, subst) => {\n+                apply_ty_from_chalk(db, TypeCtor::Adt(struct_id.0), subst)\n+            }\n+            chalk_ir::TyKind::AssociatedType(type_id, subst) => apply_ty_from_chalk(\n+                db,\n+                TypeCtor::AssociatedType(from_chalk::<TypeAliasAsAssocType, _>(db, type_id).0),\n+                subst,\n+            ),\n+            chalk_ir::TyKind::OpaqueType(opaque_type_id, subst) => {\n+                apply_ty_from_chalk(db, TypeCtor::OpaqueType(from_chalk(db, opaque_type_id)), subst)\n+            }\n+\n+            chalk_ir::TyKind::Scalar(Scalar::Bool) => Ty::simple(TypeCtor::Bool),\n+            chalk_ir::TyKind::Scalar(Scalar::Char) => Ty::simple(TypeCtor::Char),\n+            chalk_ir::TyKind::Scalar(Scalar::Int(int_ty)) => Ty::simple(TypeCtor::Int(IntTy {\n+                signedness: Signedness::Signed,\n+                bitness: bitness_from_chalk_int(int_ty),\n+            })),\n+            chalk_ir::TyKind::Scalar(Scalar::Uint(uint_ty)) => Ty::simple(TypeCtor::Int(IntTy {\n+                signedness: Signedness::Unsigned,\n+                bitness: bitness_from_chalk_uint(uint_ty),\n+            })),\n+            chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n+                Ty::simple(TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }))\n+            }\n+            chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n+                Ty::simple(TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }))\n+            }\n+            chalk_ir::TyKind::Tuple(cardinality, subst) => {\n+                apply_ty_from_chalk(db, TypeCtor::Tuple { cardinality: cardinality as u16 }, subst)\n+            }\n+            chalk_ir::TyKind::Raw(mutability, ty) => {\n+                Ty::apply_one(TypeCtor::RawPtr(from_chalk(db, mutability)), from_chalk(db, ty))\n+            }\n+            chalk_ir::TyKind::Slice(ty) => Ty::apply_one(TypeCtor::Slice, from_chalk(db, ty)),\n+            chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n+                Ty::apply_one(TypeCtor::Ref(from_chalk(db, mutability)), from_chalk(db, ty))\n+            }\n+            chalk_ir::TyKind::Str => Ty::simple(TypeCtor::Str),\n+            chalk_ir::TyKind::Never => Ty::simple(TypeCtor::Never),\n+\n+            chalk_ir::TyKind::FnDef(fn_def_id, subst) => {\n+                let callable_def = from_chalk(db, fn_def_id);\n+                apply_ty_from_chalk(db, TypeCtor::FnDef(callable_def), subst)\n+            }\n+\n+            chalk_ir::TyKind::Closure(id, subst) => {\n+                let id: crate::db::ClosureId = id.into();\n+                let (def, expr) = db.lookup_intern_closure(id);\n+                apply_ty_from_chalk(db, TypeCtor::Closure { def, expr }, subst)\n+            }\n+\n+            chalk_ir::TyKind::Foreign(foreign_def_id) => Ty::simple(TypeCtor::ForeignType(\n+                from_chalk::<TypeAliasAsForeignType, _>(db, foreign_def_id).0,\n+            )),\n+            chalk_ir::TyKind::Generator(_, _) => unimplemented!(), // FIXME\n+            chalk_ir::TyKind::GeneratorWitness(_, _) => unimplemented!(), // FIXME\n         }\n     }\n }\n \n+fn apply_ty_from_chalk(\n+    db: &dyn HirDatabase,\n+    ctor: TypeCtor,\n+    subst: chalk_ir::Substitution<Interner>,\n+) -> Ty {\n+    Ty::Apply(ApplicationTy { ctor, parameters: from_chalk(db, subst) })\n+}\n+\n /// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n /// fake lifetime here, because Chalks built-in logic may expect it to be there.\n fn ref_to_chalk(\n@@ -170,60 +284,21 @@ fn ref_to_chalk(\n ) -> chalk_ir::Ty<Interner> {\n     let arg = subst[0].clone().to_chalk(db);\n     let lifetime = LifetimeData::Static.intern(&Interner);\n-    chalk_ir::ApplicationTy {\n-        name: TypeName::Ref(mutability.to_chalk(db)),\n-        substitution: chalk_ir::Substitution::from_iter(\n-            &Interner,\n-            vec![lifetime.cast(&Interner), arg.cast(&Interner)],\n-        ),\n-    }\n-    .intern(&Interner)\n-}\n-\n-/// Here we remove the lifetime from the type we got from Chalk.\n-fn ref_from_chalk(\n-    db: &dyn HirDatabase,\n-    mutability: chalk_ir::Mutability,\n-    subst: chalk_ir::Substitution<Interner>,\n-) -> Ty {\n-    let tys = subst\n-        .iter(&Interner)\n-        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n-        .collect();\n-    Ty::apply(TypeCtor::Ref(from_chalk(db, mutability)), Substs(tys))\n+    chalk_ir::TyKind::Ref(mutability.to_chalk(db), lifetime, arg).intern(&Interner)\n }\n \n /// We currently don't model constants, but Chalk does. So, we have to insert a\n /// fake constant here, because Chalks built-in logic may expect it to be there.\n fn array_to_chalk(db: &dyn HirDatabase, subst: Substs) -> chalk_ir::Ty<Interner> {\n     let arg = subst[0].clone().to_chalk(db);\n-    let usize_ty = chalk_ir::ApplicationTy {\n-        name: TypeName::Scalar(Scalar::Uint(chalk_ir::UintTy::Usize)),\n-        substitution: chalk_ir::Substitution::empty(&Interner),\n-    }\n-    .intern(&Interner);\n+    let usize_ty =\n+        chalk_ir::TyKind::Scalar(Scalar::Uint(chalk_ir::UintTy::Usize)).intern(&Interner);\n     let const_ = chalk_ir::ConstData {\n         ty: usize_ty,\n         value: chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: () }),\n     }\n     .intern(&Interner);\n-    chalk_ir::ApplicationTy {\n-        name: TypeName::Array,\n-        substitution: chalk_ir::Substitution::from_iter(\n-            &Interner,\n-            vec![arg.cast(&Interner), const_.cast(&Interner)],\n-        ),\n-    }\n-    .intern(&Interner)\n-}\n-\n-/// Here we remove the const from the type we got from Chalk.\n-fn array_from_chalk(db: &dyn HirDatabase, subst: chalk_ir::Substitution<Interner>) -> Ty {\n-    let tys = subst\n-        .iter(&Interner)\n-        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n-        .collect();\n-    Ty::apply(TypeCtor::Array, Substs(tys))\n+    chalk_ir::TyKind::Array(arg, const_).intern(&Interner)\n }\n \n impl ToChalk for Substs {\n@@ -288,124 +363,6 @@ impl ToChalk for OpaqueTyId {\n     }\n }\n \n-impl ToChalk for TypeCtor {\n-    type Chalk = TypeName<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> TypeName<Interner> {\n-        match self {\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let assoc_type = TypeAliasAsAssocType(type_alias);\n-                let assoc_type_id = assoc_type.to_chalk(db);\n-                TypeName::AssociatedType(assoc_type_id)\n-            }\n-\n-            TypeCtor::OpaqueType(impl_trait_id) => {\n-                let id = impl_trait_id.to_chalk(db);\n-                TypeName::OpaqueType(id)\n-            }\n-\n-            TypeCtor::ForeignType(type_alias) => {\n-                let foreign_type = TypeAliasAsForeignType(type_alias);\n-                let foreign_type_id = foreign_type.to_chalk(db);\n-                TypeName::Foreign(foreign_type_id)\n-            }\n-\n-            TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n-            TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n-            TypeCtor::Int(int_ty) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n-            TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }) => {\n-                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n-            }\n-            TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }) => {\n-                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n-            }\n-\n-            TypeCtor::Tuple { cardinality } => TypeName::Tuple(cardinality.into()),\n-            TypeCtor::RawPtr(mutability) => TypeName::Raw(mutability.to_chalk(db)),\n-            TypeCtor::Slice => TypeName::Slice,\n-            TypeCtor::Array => TypeName::Array,\n-            TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n-            TypeCtor::Str => TypeName::Str,\n-            TypeCtor::FnDef(callable_def) => {\n-                let id = callable_def.to_chalk(db);\n-                TypeName::FnDef(id)\n-            }\n-            TypeCtor::Never => TypeName::Never,\n-\n-            TypeCtor::Closure { def, expr } => {\n-                let closure_id = db.intern_closure((def, expr));\n-                TypeName::Closure(closure_id.into())\n-            }\n-\n-            TypeCtor::Adt(adt_id) => TypeName::Adt(chalk_ir::AdtId(adt_id)),\n-\n-            TypeCtor::FnPtr { .. } => {\n-                // This should not be reached, since Chalk doesn't represent\n-                // function pointers with TypeName\n-                unreachable!()\n-            }\n-        }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, type_name: TypeName<Interner>) -> TypeCtor {\n-        match type_name {\n-            TypeName::Adt(struct_id) => TypeCtor::Adt(struct_id.0),\n-            TypeName::AssociatedType(type_id) => {\n-                TypeCtor::AssociatedType(from_chalk::<TypeAliasAsAssocType, _>(db, type_id).0)\n-            }\n-            TypeName::OpaqueType(opaque_type_id) => {\n-                TypeCtor::OpaqueType(from_chalk(db, opaque_type_id))\n-            }\n-\n-            TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n-            TypeName::Scalar(Scalar::Char) => TypeCtor::Char,\n-            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(IntTy {\n-                signedness: Signedness::Signed,\n-                bitness: bitness_from_chalk_int(int_ty),\n-            }),\n-            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(IntTy {\n-                signedness: Signedness::Unsigned,\n-                bitness: bitness_from_chalk_uint(uint_ty),\n-            }),\n-            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n-                TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 })\n-            }\n-            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n-                TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 })\n-            }\n-            TypeName::Tuple(cardinality) => TypeCtor::Tuple { cardinality: cardinality as u16 },\n-            TypeName::Raw(mutability) => TypeCtor::RawPtr(from_chalk(db, mutability)),\n-            TypeName::Slice => TypeCtor::Slice,\n-            TypeName::Ref(mutability) => TypeCtor::Ref(from_chalk(db, mutability)),\n-            TypeName::Str => TypeCtor::Str,\n-            TypeName::Never => TypeCtor::Never,\n-\n-            TypeName::FnDef(fn_def_id) => {\n-                let callable_def = from_chalk(db, fn_def_id);\n-                TypeCtor::FnDef(callable_def)\n-            }\n-            TypeName::Array => TypeCtor::Array,\n-\n-            TypeName::Closure(id) => {\n-                let id: crate::db::ClosureId = id.into();\n-                let (def, expr) = db.lookup_intern_closure(id);\n-                TypeCtor::Closure { def, expr }\n-            }\n-\n-            TypeName::Foreign(foreign_def_id) => {\n-                TypeCtor::ForeignType(from_chalk::<TypeAliasAsForeignType, _>(db, foreign_def_id).0)\n-            }\n-\n-            TypeName::Error => {\n-                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n-                unreachable!()\n-            }\n-            TypeName::Generator(_) => unimplemented!(), // FIXME\n-            TypeName::GeneratorWitness(_) => unimplemented!(), // FIXME\n-        }\n-    }\n-}\n-\n fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n     use chalk_ir::UintTy;\n \n@@ -677,9 +634,9 @@ where\n             .kinds\n             .iter()\n             .map(|k| match k {\n-                TyKind::General => chalk_ir::TyKind::General,\n-                TyKind::Integer => chalk_ir::TyKind::Integer,\n-                TyKind::Float => chalk_ir::TyKind::Float,\n+                TyKind::General => chalk_ir::TyVariableKind::General,\n+                TyKind::Integer => chalk_ir::TyVariableKind::Integer,\n+                TyKind::Float => chalk_ir::TyVariableKind::Float,\n             })\n             .map(|tk| {\n                 chalk_ir::CanonicalVarKind::new(\n@@ -700,9 +657,9 @@ where\n             .iter(&Interner)\n             .map(|k| match k.kind {\n                 chalk_ir::VariableKind::Ty(tk) => match tk {\n-                    chalk_ir::TyKind::General => TyKind::General,\n-                    chalk_ir::TyKind::Integer => TyKind::Integer,\n-                    chalk_ir::TyKind::Float => TyKind::Float,\n+                    chalk_ir::TyVariableKind::General => TyKind::General,\n+                    chalk_ir::TyVariableKind::Integer => TyKind::Integer,\n+                    chalk_ir::TyVariableKind::Float => TyKind::Float,\n                 },\n                 chalk_ir::VariableKind::Lifetime => panic!(\"unexpected lifetime from Chalk\"),\n                 chalk_ir::VariableKind::Const(_) => panic!(\"unexpected const from Chalk\"),\n@@ -768,7 +725,8 @@ where\n     chalk_ir::Binders::new(\n         chalk_ir::VariableKinds::from_iter(\n             &Interner,\n-            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)).take(num_vars),\n+            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n+                .take(num_vars),\n         ),\n         value,\n     )"}, {"sha": "3c9766550b34e29f497f10af136040001e98ad83", "filename": "crates/hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 9, "deletions": 99, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590fdba28468d53dcfc498dc863202b924f89ffa/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=590fdba28468d53dcfc498dc863202b924f89ffa", "patch": "@@ -1,12 +1,12 @@\n //! Implementation of Chalk debug helper functions using TLS.\n use std::fmt;\n \n-use chalk_ir::{AliasTy, GenericArg, Goal, Goals, Lifetime, ProgramClauseImplication, TypeName};\n+use chalk_ir::{AliasTy, GenericArg, Goal, Goals, Lifetime, ProgramClauseImplication};\n use itertools::Itertools;\n \n use super::{from_chalk, Interner, TypeAliasAsAssocType};\n-use crate::{db::HirDatabase, CallableDefId, TypeCtor};\n-use hir_def::{AdtId, AssocContainerId, DefWithBodyId, Lookup, TypeAliasId};\n+use crate::{db::HirDatabase, CallableDefId};\n+use hir_def::{AdtId, AssocContainerId, Lookup, TypeAliasId};\n \n pub use unsafe_tls::{set_current_program, with_current_program};\n \n@@ -18,94 +18,12 @@ impl DebugContext<'_> {\n         id: super::AdtId,\n         f: &mut fmt::Formatter<'_>,\n     ) -> Result<(), fmt::Error> {\n-        let type_ctor: TypeCtor = from_chalk(self.0, TypeName::Adt(id));\n-        match type_ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice => write!(f, \"slice\")?,\n-            TypeCtor::Array => write!(f, \"array\")?,\n-            TypeCtor::RawPtr(m) => write!(f, \"*{}\", m.as_keyword_for_ptr())?,\n-            TypeCtor::Ref(m) => write!(f, \"&{}\", m.as_keyword_for_ref())?,\n-            TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple { .. } => {\n-                write!(f, \"()\")?;\n-            }\n-            TypeCtor::FnPtr { .. } => {\n-                write!(f, \"fn\")?;\n-            }\n-            TypeCtor::FnDef(def) => {\n-                let name = match def {\n-                    CallableDefId::FunctionId(ff) => self.0.function_data(ff).name.clone(),\n-                    CallableDefId::StructId(s) => self.0.struct_data(s).name.clone(),\n-                    CallableDefId::EnumVariantId(e) => {\n-                        let enum_data = self.0.enum_data(e.parent);\n-                        enum_data.variants[e.local_id].name.clone()\n-                    }\n-                };\n-                match def {\n-                    CallableDefId::FunctionId(_) => write!(f, \"{{fn {}}}\", name)?,\n-                    CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_) => {\n-                        write!(f, \"{{ctor {}}}\", name)?\n-                    }\n-                }\n-            }\n-            TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => self.0.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => self.0.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => self.0.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let trait_ = match type_alias.lookup(self.0.upcast()).container {\n-                    AssocContainerId::TraitId(it) => it,\n-                    _ => panic!(\"not an associated type\"),\n-                };\n-                let trait_name = self.0.trait_data(trait_).name.clone();\n-                let name = self.0.type_alias_data(type_alias).name.clone();\n-                write!(f, \"{}::{}\", trait_name, name)?;\n-            }\n-            TypeCtor::OpaqueType(opaque_ty_id) => match opaque_ty_id {\n-                crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n-                    write!(f, \"{{impl trait {} of {:?}}}\", idx, func)?;\n-                }\n-                crate::OpaqueTyId::AsyncBlockTypeImplTrait(def, idx) => {\n-                    write!(f, \"{{impl trait of async block {} of {:?}}}\", idx.into_raw(), def)?;\n-                }\n-            },\n-            TypeCtor::ForeignType(type_alias) => {\n-                let name = self.0.type_alias_data(type_alias).name.clone();\n-                write!(f, \"{}\", name)?;\n-            }\n-            TypeCtor::Closure { def, expr } => {\n-                write!(f, \"{{closure {:?} in \", expr.into_raw())?;\n-                match def {\n-                    DefWithBodyId::FunctionId(func) => {\n-                        write!(f, \"fn {}\", self.0.function_data(func).name)?\n-                    }\n-                    DefWithBodyId::StaticId(s) => {\n-                        if let Some(name) = self.0.static_data(s).name.as_ref() {\n-                            write!(f, \"body of static {}\", name)?;\n-                        } else {\n-                            write!(f, \"body of unnamed static {:?}\", s)?;\n-                        }\n-                    }\n-                    DefWithBodyId::ConstId(c) => {\n-                        if let Some(name) = self.0.const_data(c).name.as_ref() {\n-                            write!(f, \"body of const {}\", name)?;\n-                        } else {\n-                            write!(f, \"body of unnamed const {:?}\", c)?;\n-                        }\n-                    }\n-                };\n-                write!(f, \"}}\")?;\n-            }\n-        }\n-        Ok(())\n+        let name = match id.0 {\n+            AdtId::StructId(it) => self.0.struct_data(it).name.clone(),\n+            AdtId::UnionId(it) => self.0.union_data(it).name.clone(),\n+            AdtId::EnumId(it) => self.0.enum_data(it).name.clone(),\n+        };\n+        write!(f, \"{}\", name)\n     }\n \n     pub fn debug_trait_id(\n@@ -234,14 +152,6 @@ impl DebugContext<'_> {\n         write!(fmt, \"{:?}\", pci.debug(&Interner))\n     }\n \n-    pub fn debug_application_ty(\n-        &self,\n-        application_ty: &chalk_ir::ApplicationTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", application_ty.debug(&Interner))\n-    }\n-\n     pub fn debug_substitution(\n         &self,\n         substitution: &chalk_ir::Substitution<Interner>,"}]}