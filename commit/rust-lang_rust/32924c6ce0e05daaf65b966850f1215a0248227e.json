{"sha": "32924c6ce0e05daaf65b966850f1215a0248227e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTI0YzZjZTBlMDVkYWFmNjViOTY2ODUwZjEyMTVhMDI0ODIyN2U=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-02-05T02:06:34Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-02-05T02:06:34Z"}, "message": "Few improvement to `utils::conf` module\n\n* Fix a few typos\n* Handle Option<&Path> early\n* Use `env::var_os` when possible", "tree": {"sha": "060bd2749f535f2569b9b82db4da590a1dc54c7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/060bd2749f535f2569b9b82db4da590a1dc54c7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32924c6ce0e05daaf65b966850f1215a0248227e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32924c6ce0e05daaf65b966850f1215a0248227e", "html_url": "https://github.com/rust-lang/rust/commit/32924c6ce0e05daaf65b966850f1215a0248227e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32924c6ce0e05daaf65b966850f1215a0248227e/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d33c603d26f5645808f9e7cdcd2d2c9806cb23c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33c603d26f5645808f9e7cdcd2d2c9806cb23c7", "html_url": "https://github.com/rust-lang/rust/commit/d33c603d26f5645808f9e7cdcd2d2c9806cb23c7"}], "stats": {"total": 197, "additions": 87, "deletions": 110}, "files": [{"sha": "25621374798f73dcea153ff2a733679287277ca3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/32924c6ce0e05daaf65b966850f1215a0248227e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32924c6ce0e05daaf65b966850f1215a0248227e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=32924c6ce0e05daaf65b966850f1215a0248227e", "patch": "@@ -55,8 +55,6 @@ use rustc::session::Session;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_lint::LintId;\n \n-use std::path::Path;\n-\n /// Macro used to declare a Clippy lint.\n ///\n /// Every lint declaration consists of 4 parts:\n@@ -341,42 +339,41 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, conf: &Co\n \n #[doc(hidden)]\n pub fn read_conf(args: &[syntax::ast::NestedMetaItem], sess: &Session) -> Conf {\n+    use std::path::Path;\n     match utils::conf::file_from_args(args) {\n         Ok(file_name) => {\n             // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n             // do not require the file to exist\n-            let file_name = if let Some(file_name) = file_name {\n-                Some(file_name)\n-            } else {\n-                match utils::conf::lookup_conf_file() {\n-                    Ok(path) => path,\n+            let file_name = match file_name {\n+                Some(file_name) => file_name,\n+                None => match utils::conf::lookup_conf_file() {\n+                    Ok(Some(path)) => path,\n+                    Ok(None) => return Conf::default(),\n                     Err(error) => {\n                         sess.struct_err(&format!(\"error finding Clippy's configuration file: {}\", error))\n                             .emit();\n-                        None\n+                        return Conf::default();\n                     },\n-                }\n+                },\n             };\n \n-            let file_name = file_name.map(|file_name| {\n-                if file_name.is_relative() {\n-                    sess.local_crate_source_file\n-                        .as_deref()\n-                        .and_then(Path::parent)\n-                        .unwrap_or_else(|| Path::new(\"\"))\n-                        .join(file_name)\n-                } else {\n-                    file_name\n-                }\n-            });\n+            let file_name = if file_name.is_relative() {\n+                sess.local_crate_source_file\n+                    .as_deref()\n+                    .and_then(Path::parent)\n+                    .unwrap_or_else(|| Path::new(\"\"))\n+                    .join(file_name)\n+            } else {\n+                file_name\n+            };\n \n-            let (conf, errors) = utils::conf::read(file_name.as_ref().map(AsRef::as_ref));\n+            let (conf, errors) = utils::conf::read(&file_name);\n \n             // all conf errors are non-fatal, we just use the default conf in case of error\n             for error in errors {\n                 sess.struct_err(&format!(\n                     \"error reading Clippy's configuration file `{}`: {}\",\n-                    file_name.as_ref().and_then(|p| p.to_str()).unwrap_or(\"\"),\n+                    file_name.display(),\n                     error\n                 ))\n                 .emit();\n@@ -388,7 +385,7 @@ pub fn read_conf(args: &[syntax::ast::NestedMetaItem], sess: &Session) -> Conf {\n             sess.struct_span_err(span, err)\n                 .span_note(span, \"Clippy will use default configuration\")\n                 .emit();\n-            toml::from_str(\"\").expect(\"we never error on empty config files\")\n+            Conf::default()\n         },\n     }\n }"}, {"sha": "241f0657cb1bed74e3d710b550bd36646252dd4b", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 67, "deletions": 87, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/32924c6ce0e05daaf65b966850f1215a0248227e/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32924c6ce0e05daaf65b966850f1215a0248227e/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=32924c6ce0e05daaf65b966850f1215a0248227e", "patch": "@@ -4,22 +4,20 @@\n \n use lazy_static::lazy_static;\n use rustc_span::source_map;\n-use std::default::Default;\n-use std::io::Read;\n+use source_map::Span;\n+use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n-use std::{env, fmt, fs, io, path};\n-use syntax::ast;\n+use std::{env, fmt, fs, io};\n+use syntax::ast::{LitKind, MetaItemKind, NestedMetaItem};\n \n /// Gets the configuration file from arguments.\n-pub fn file_from_args(args: &[ast::NestedMetaItem]) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n-    for arg in args.iter().filter_map(syntax::ast::NestedMetaItem::meta_item) {\n+pub fn file_from_args(args: &[NestedMetaItem]) -> Result<Option<PathBuf>, (&'static str, Span)> {\n+    for arg in args.iter().filter_map(NestedMetaItem::meta_item) {\n         if arg.check_name(sym!(conf_file)) {\n             return match arg.kind {\n-                ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n-                    Err((\"`conf_file` must be a named value\", arg.span))\n-                },\n-                ast::MetaItemKind::NameValue(ref value) => {\n-                    if let ast::LitKind::Str(ref file, _) = value.kind {\n+                MetaItemKind::Word | MetaItemKind::List(_) => Err((\"`conf_file` must be a named value\", arg.span)),\n+                MetaItemKind::NameValue(ref value) => {\n+                    if let LitKind::Str(ref file, _) = value.kind {\n                         Ok(Some(file.to_string().into()))\n                     } else {\n                         Err((\"`conf_file` value must be a string\", value.span))\n@@ -37,15 +35,15 @@ pub fn file_from_args(args: &[ast::NestedMetaItem]) -> Result<Option<path::PathB\n pub enum Error {\n     /// An I/O error.\n     Io(io::Error),\n-    /// Not valid toml or doesn't fit the expected conf format\n+    /// Not valid toml or doesn't fit the expected config format\n     Toml(String),\n }\n \n impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n-        match *self {\n-            Self::Io(ref err) => err.fmt(f),\n-            Self::Toml(ref err) => err.fmt(f),\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Io(err) => err.fmt(f),\n+            Self::Toml(err) => err.fmt(f),\n         }\n     }\n }\n@@ -61,59 +59,61 @@ lazy_static! {\n }\n \n macro_rules! define_Conf {\n-    ($(#[$doc: meta] ($rust_name: ident, $rust_name_str: expr, $default: expr => $($ty: tt)+),)+) => {\n-        pub use self::helpers::Conf;\n+    ($(#[$doc:meta] ($config:ident, $config_str:literal: $Ty:ty, $default:expr),)+) => {\n         mod helpers {\n             use serde::Deserialize;\n             /// Type used to store lint configuration.\n             #[derive(Deserialize)]\n-            #[serde(rename_all=\"kebab-case\", deny_unknown_fields)]\n+            #[serde(rename_all = \"kebab-case\", deny_unknown_fields)]\n             pub struct Conf {\n-                $(#[$doc] #[serde(default=$rust_name_str)] #[serde(with=$rust_name_str)]\n-                          pub $rust_name: define_Conf!(TY $($ty)+),)+\n+                $(\n+                    #[$doc]\n+                    #[serde(default = $config_str)]\n+                    #[serde(with = $config_str)]\n+                    pub $config: $Ty,\n+                )+\n                 #[allow(dead_code)]\n                 #[serde(default)]\n                 third_party: Option<::toml::Value>,\n             }\n+\n             $(\n-                mod $rust_name {\n+                mod $config {\n                     use serde::Deserialize;\n-                    crate fn deserialize<'de, D: serde::Deserializer<'de>>(deserializer: D)\n-                    -> Result<define_Conf!(TY $($ty)+), D::Error> {\n-                        type T = define_Conf!(TY $($ty)+);\n-                        Ok(T::deserialize(deserializer).unwrap_or_else(|e| {\n-                            crate::utils::conf::ERRORS.lock().expect(\"no threading here\")\n-                                                        .push(crate::utils::conf::Error::Toml(e.to_string()));\n-                            super::$rust_name()\n-                        }))\n+                    crate fn deserialize<'de, D: serde::Deserializer<'de>>(deserializer: D) -> Result<$Ty, D::Error> {\n+                        use super::super::{ERRORS, Error};\n+                        Ok(\n+                            <$Ty>::deserialize(deserializer).unwrap_or_else(|e| {\n+                                ERRORS\n+                                    .lock()\n+                                    .expect(\"no threading here\")\n+                                    .push(Error::Toml(e.to_string()));\n+                                super::$config()\n+                            })\n+                        )\n                     }\n                 }\n \n                 #[must_use]\n-                fn $rust_name() -> define_Conf!(TY $($ty)+) {\n-                    define_Conf!(DEFAULT $($ty)+, $default)\n+                fn $config() -> $Ty {\n+                    let x = $default;\n+                    x\n                 }\n             )+\n         }\n     };\n-\n-    // hack to convert tts\n-    (TY $ty: ty) => { $ty };\n-\n-    // provide a nicer syntax to declare the default value of `Vec<String>` variables\n-    (DEFAULT Vec<String>, $e: expr) => { $e.iter().map(|&e| e.to_owned()).collect() };\n-    (DEFAULT $ty: ty, $e: expr) => { $e };\n }\n \n+pub use self::helpers::Conf;\n define_Conf! {\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about\n-    (blacklisted_names, \"blacklisted_names\", [\"foo\", \"bar\", \"baz\", \"quux\"] => Vec<String>),\n+    (blacklisted_names, \"blacklisted_names\": Vec<String>, [\"foo\", \"bar\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n     /// Lint: COGNITIVE_COMPLEXITY. The maximum cognitive complexity a function can have\n-    (cognitive_complexity_threshold, \"cognitive_complexity_threshold\", 25 => u64),\n+    (cognitive_complexity_threshold, \"cognitive_complexity_threshold\": u64, 25),\n     /// DEPRECATED LINT: CYCLOMATIC_COMPLEXITY. Use the Cognitive Complexity lint instead.\n-    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\", None => Option<u64>),\n+    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\": Option<u64>, None),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n-    (doc_valid_idents, \"doc_valid_idents\", [\n+    (doc_valid_idents, \"doc_valid_idents\": Vec<String>, [\n         \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n         \"DirectX\",\n         \"ECMAScript\",\n@@ -129,31 +129,31 @@ define_Conf! {\n         \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\",\n         \"MinGW\",\n         \"CamelCase\",\n-    ] => Vec<String>),\n+    ].iter().map(ToString::to_string).collect()),\n     /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n-    (too_many_arguments_threshold, \"too_many_arguments_threshold\", 7 => u64),\n+    (too_many_arguments_threshold, \"too_many_arguments_threshold\": u64, 7),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n-    (type_complexity_threshold, \"type_complexity_threshold\", 250 => u64),\n+    (type_complexity_threshold, \"type_complexity_threshold\": u64, 250),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n-    (single_char_binding_names_threshold, \"single_char_binding_names_threshold\", 5 => u64),\n+    (single_char_binding_names_threshold, \"single_char_binding_names_threshold\": u64, 5),\n     /// Lint: BOXED_LOCAL. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n-    (too_large_for_stack, \"too_large_for_stack\", 200 => u64),\n+    (too_large_for_stack, \"too_large_for_stack\": u64, 200),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n-    (enum_variant_name_threshold, \"enum_variant_name_threshold\", 3 => u64),\n+    (enum_variant_name_threshold, \"enum_variant_name_threshold\": u64, 3),\n     /// Lint: LARGE_ENUM_VARIANT. The maximum size of a enum's variant to avoid box suggestion\n-    (enum_variant_size_threshold, \"enum_variant_size_threshold\", 200 => u64),\n+    (enum_variant_size_threshold, \"enum_variant_size_threshold\": u64, 200),\n     /// Lint: VERBOSE_BIT_MASK. The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros'\n-    (verbose_bit_mask_threshold, \"verbose_bit_mask_threshold\", 1 => u64),\n+    (verbose_bit_mask_threshold, \"verbose_bit_mask_threshold\": u64, 1),\n     /// Lint: DECIMAL_LITERAL_REPRESENTATION. The lower bound for linting decimal literals\n-    (literal_representation_threshold, \"literal_representation_threshold\", 16384 => u64),\n+    (literal_representation_threshold, \"literal_representation_threshold\": u64, 16384),\n     /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n-    (trivial_copy_size_limit, \"trivial_copy_size_limit\", None => Option<u64>),\n+    (trivial_copy_size_limit, \"trivial_copy_size_limit\": Option<u64>, None),\n     /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n-    (too_many_lines_threshold, \"too_many_lines_threshold\", 100 => u64),\n+    (too_many_lines_threshold, \"too_many_lines_threshold\": u64, 100),\n     /// Lint: LARGE_STACK_ARRAYS. The maximum allowed size for arrays on the stack\n-    (array_size_threshold, \"array_size_threshold\", 512_000 => u64),\n+    (array_size_threshold, \"array_size_threshold\": u64, 512_000),\n     /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n-    (vec_box_size_threshold, \"vec_box_size_threshold\", 4096 => u64),\n+    (vec_box_size_threshold, \"vec_box_size_threshold\": u64, 4096),\n }\n \n impl Default for Conf {\n@@ -164,32 +164,26 @@ impl Default for Conf {\n }\n \n /// Search for the configuration file.\n-pub fn lookup_conf_file() -> io::Result<Option<path::PathBuf>> {\n+pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n     /// Possible filename to search for.\n     const CONFIG_FILE_NAMES: [&str; 2] = [\".clippy.toml\", \"clippy.toml\"];\n \n     // Start looking for a config file in CLIPPY_CONF_DIR, or failing that, CARGO_MANIFEST_DIR.\n     // If neither of those exist, use \".\".\n-    let mut current = path::PathBuf::from(\n-        env::var(\"CLIPPY_CONF_DIR\")\n-            .or_else(|_| env::var(\"CARGO_MANIFEST_DIR\"))\n-            .unwrap_or_else(|_| \".\".to_string()),\n-    );\n+    let mut current = env::var_os(\"CLIPPY_CONF_DIR\")\n+        .or_else(|| env::var_os(\"CARGO_MANIFEST_DIR\"))\n+        .map_or_else(|| PathBuf::from(\".\"), PathBuf::from);\n     loop {\n         for config_file_name in &CONFIG_FILE_NAMES {\n             let config_file = current.join(config_file_name);\n             match fs::metadata(&config_file) {\n                 // Only return if it's a file to handle the unlikely situation of a directory named\n                 // `clippy.toml`.\n-                Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n+                Ok(ref md) if !md.is_dir() => return Ok(Some(config_file)),\n                 // Return the error if it's something other than `NotFound`; otherwise we didn't\n                 // find the project file yet, and continue searching.\n-                Err(e) => {\n-                    if e.kind() != io::ErrorKind::NotFound {\n-                        return Err(e);\n-                    }\n-                },\n-                _ => (),\n+                Err(e) if e.kind() != io::ErrorKind::NotFound => return Err(e),\n+                _ => {},\n             }\n         }\n \n@@ -210,28 +204,14 @@ fn default(errors: Vec<Error>) -> (Conf, Vec<Error>) {\n /// Read the `toml` configuration file.\n ///\n /// In case of error, the function tries to continue as much as possible.\n-pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n-    let path = if let Some(path) = path {\n-        path\n-    } else {\n-        return default(Vec::new());\n-    };\n-\n-    let file = match fs::File::open(path) {\n-        Ok(mut file) => {\n-            let mut buf = String::new();\n-\n-            if let Err(err) = file.read_to_string(&mut buf) {\n-                return default(vec![err.into()]);\n-            }\n-\n-            buf\n-        },\n+pub fn read(path: &Path) -> (Conf, Vec<Error>) {\n+    let content = match fs::read_to_string(path) {\n+        Ok(content) => content,\n         Err(err) => return default(vec![err.into()]),\n     };\n \n     assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n-    match toml::from_str(&file) {\n+    match toml::from_str(&content) {\n         Ok(toml) => {\n             let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n "}]}