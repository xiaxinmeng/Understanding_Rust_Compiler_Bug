{"sha": "5b25fc918a8b91322c28242d3956109001b0f7c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMjVmYzkxOGE4YjkxMzIyYzI4MjQyZDM5NTYxMDkwMDFiMGY3YzQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-22T23:00:28Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-23T00:40:25Z"}, "message": "Parse and typecheck moving out of enums (#2329)", "tree": {"sha": "c02331c20638ff3602959b9c80aaea60e845ea12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02331c20638ff3602959b9c80aaea60e845ea12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b25fc918a8b91322c28242d3956109001b0f7c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b25fc918a8b91322c28242d3956109001b0f7c4", "html_url": "https://github.com/rust-lang/rust/commit/5b25fc918a8b91322c28242d3956109001b0f7c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b25fc918a8b91322c28242d3956109001b0f7c4/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b804ce343a79fec2b08b88740782c1e8c081417", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b804ce343a79fec2b08b88740782c1e8c081417", "html_url": "https://github.com/rust-lang/rust/commit/1b804ce343a79fec2b08b88740782c1e8c081417"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "ae20573802b5423dccb3dd8d86f0249f0c910b4e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -161,6 +161,7 @@ type field_pat = {ident: ident, pat: @pat};\n #[auto_serialize]\n enum binding_mode {\n     bind_by_value,\n+    bind_by_move,\n     bind_by_ref(ast::mutability),\n     bind_by_implicit_ref\n }"}, {"sha": "f81d6de25b47cffca39eba1a1508931599facc25", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -16,7 +16,7 @@ import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n import dvec::dvec;\n import vec::{push};\n import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n-             bind_by_ref, bind_by_implicit_ref, bind_by_value,\n+             bind_by_ref, bind_by_implicit_ref, bind_by_value, bind_by_move,\n              bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n              bound_copy, bound_send, bound_trait, bound_owned, box, by_copy,\n              by_move, by_mutbl_ref, by_ref, by_val, capture_clause,\n@@ -1887,12 +1887,17 @@ struct parser {\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n             } else if self.eat_keyword(~\"copy\") {\n                 pat = self.parse_pat_ident(refutable, bind_by_value);\n+            } else if self.eat_keyword(~\"move\") {\n+                pat = self.parse_pat_ident(refutable, bind_by_move);\n             } else if !is_plain_ident(self.token) {\n                 pat = self.parse_enum_variant(refutable);\n             } else {\n                 let binding_mode;\n+                // XXX: Aren't these two cases deadcode? -- bblum\n                 if self.eat_keyword(~\"copy\") {\n                     binding_mode = bind_by_value;\n+                } else if self.eat_keyword(~\"move\") {\n+                    binding_mode = bind_by_move;\n                 } else if refutable {\n                     // XXX: Should be bind_by_value, but that's not\n                     // backward compatible."}, {"sha": "04f800a72386381a2283cca26555f8ae8e86ba7c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -1442,6 +1442,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n             print_mutability(s, mutbl);\n           }\n           ast::bind_by_implicit_ref |\n+          ast::bind_by_move | // this is totally the wrong thing\n           ast::bind_by_value => {}\n         }\n         print_path(s, path, true);"}, {"sha": "31ef79aa616ea4717472a74b4f719d8d07e34aca", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -412,9 +412,10 @@ impl gather_loan_ctxt {\n             match pat.node {\n               ast::pat_ident(bm, id, o_pat) if !self.pat_is_variant(pat) => {\n                 match bm {\n-                  ast::bind_by_value => {\n+                  ast::bind_by_value | ast::bind_by_move => {\n                     // copying does not borrow anything, so no check\n                     // is required\n+                    // as for move, check::alt ensures it's from an rvalue.\n                   }\n                   ast::bind_by_ref(mutbl) => {\n                     // ref x or ref x @ p --- creates a ptr which must"}, {"sha": "d2d103952f0fadacb5828fcb83e742a1c117db52", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -490,7 +490,7 @@ fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n \n     do pat_bindings(tcx.def_map, pat) |binding_mode, id, span, path| {\n         match binding_mode {\n-          ast::bind_by_ref(_) | ast::bind_by_value => {}\n+          ast::bind_by_ref(_) | ast::bind_by_value | ast::bind_by_move => {}\n           ast::bind_by_implicit_ref => {\n             let pat_ty = ty::node_id_to_type(tcx, id);\n             let kind = ty::type_kind(tcx, pat_ty);"}, {"sha": "7a14e9afe07874338e833d88fc1a84209a7913d8", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -409,6 +409,7 @@ impl &mem_categorization_ctxt {\n           }\n \n           ast::def_binding(vid, ast::bind_by_value) |\n+          ast::def_binding(vid, ast::bind_by_move)  |\n           ast::def_binding(vid, ast::bind_by_ref(_)) => {\n             // by-value/by-ref bindings are local variables\n             @{id:id, span:span,"}, {"sha": "13bbfabd0ca3c00038d51085df237534657d971a", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -474,6 +474,8 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n                                    load_if_immediate(bcx, llval, ty), ty);\n                     bcx.fcx.lllocals.insert(val, local_mem(alloc));\n                     add_clean(bcx, alloc, ty);\n+                } else if mode == ast::bind_by_move {\n+                    fail ~\"can't translate bind_by_move into a pattern guard\";\n                 } else {\n                     bcx.fcx.lllocals.insert(val, local_mem(llval));\n                 }\n@@ -803,6 +805,9 @@ fn make_pattern_bindings(bcx: block, phi_bindings: phi_bindings_list)\n                                         local_mem(allocation));\n                 add_clean(bcx, allocation, ty);\n             }\n+            ast::bind_by_move => {\n+                fail ~\"unimplemented -- bblum\";\n+            }\n         }\n     }\n "}, {"sha": "87817bd2e077ec061407245983d93b1b517c46b7", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -2035,7 +2035,10 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n         map: pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n         alt_region: region,\n         block_region: region,\n-        pat_region: region\n+        pat_region: region,\n+        matching_lvalue: true, // FIXME(#3235) Make this more flexible\n+        has_guard: false,\n+        mut ever_bound_by_ref: false,\n     };\n     alt::check_pat(pcx, local.node.pat, t);\n     return bot;"}, {"sha": "a38e42ff07679a055e4ede298a0e38ff2a79aecc", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b25fc918a8b91322c28242d3956109001b0f7c4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=5b25fc918a8b91322c28242d3956109001b0f7c4", "patch": "@@ -9,6 +9,7 @@ fn check_alt(fcx: @fn_ctxt,\n \n     let pattern_ty = fcx.infcx.next_ty_var();\n     bot = check_expr_with(fcx, discrim, pattern_ty);\n+    let is_lvalue = ty::expr_is_lval(fcx.ccx.method_map, discrim);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -18,7 +19,12 @@ fn check_alt(fcx: @fn_ctxt,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n             alt_region: ty::re_scope(expr.id),\n             block_region: ty::re_scope(arm.body.node.id),\n-            pat_region: ty::re_scope(expr.id)\n+            pat_region: ty::re_scope(expr.id),\n+            // The following three fields determine whether 'move' is allowed.\n+            matching_lvalue: is_lvalue,\n+            has_guard: arm.guard.is_some(),\n+            // Each arm is freshly allowed to decide whether it can 'move'.\n+            mut ever_bound_by_ref: false,\n         };\n \n         for arm.pats.each |p| { check_pat(pcx, p, pattern_ty);}\n@@ -47,7 +53,14 @@ type pat_ctxt = {\n     alt_region: ty::region,\n     block_region: ty::region,\n     /* Equal to either alt_region or block_region. */\n-    pat_region: ty::region\n+    pat_region: ty::region,\n+    /* Moving out is only permitted when matching rvalues. */\n+    matching_lvalue: bool,\n+    /* Moving out is not permitted with guards. */\n+    has_guard: bool,\n+    /* If a pattern binding binds by-reference ever, then binding by-move in\n+     * the same arm is disallowed (no \"ref x @ some(move y)\", etc etc). */\n+    mut ever_bound_by_ref: bool,\n };\n \n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n@@ -161,6 +174,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n \n         match bm {\n           ast::bind_by_ref(mutbl) => {\n+            pcx.ever_bound_by_ref = true;\n             // if the binding is like\n             //    ref x | ref const x | ref mut x\n             // then the type of x is &M T where M is the mutability\n@@ -172,8 +186,32 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             let region_ty = ty::mk_rptr(tcx, region_var, mt);\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n-          ast::bind_by_value | ast::bind_by_implicit_ref => {\n-            // otherwise the type of x is the expected type T\n+          // otherwise the type of x is the expected type T\n+          ast::bind_by_value => {\n+            demand::eqtype(fcx, pat.span, expected, typ);\n+          }\n+          ast::bind_by_move => {\n+            demand::eqtype(fcx, pat.span, expected, typ);\n+            // check legality of moving out of the enum\n+            if sub.is_some() {\n+                tcx.sess.span_err(pat.span,\n+                    ~\"cannot bind by-move with sub-bindings\");\n+            }\n+            if pcx.has_guard {\n+                tcx.sess.span_err(pat.span,\n+                    ~\"cannot bind by-move into a pattern guard\");\n+            }\n+            if pcx.ever_bound_by_ref {\n+                tcx.sess.span_err(pat.span,\n+                    ~\"cannot bind by-move and by-ref in the same pattern\");\n+            }\n+            if pcx.matching_lvalue {\n+                tcx.sess.span_err(pat.span,\n+                    ~\"cannot bind by-move when matching an lvalue\");\n+            }\n+          }\n+          ast::bind_by_implicit_ref => {\n+            pcx.ever_bound_by_ref = true;\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }"}]}