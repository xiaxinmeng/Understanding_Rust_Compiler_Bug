{"sha": "f3c9c216583d396e717e967becb42ece74651bd0", "node_id": "C_kwDOAAsO6NoAKGYzYzljMjE2NTgzZDM5NmU3MTdlOTY3YmVjYjQyZWNlNzQ2NTFiZDA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-16T23:51:23Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-25T03:21:22Z"}, "message": "Prepopulate opaques in canonical input", "tree": {"sha": "fda8da4baee05b6c20256867b63f30cf436ecc1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fda8da4baee05b6c20256867b63f30cf436ecc1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c9c216583d396e717e967becb42ece74651bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c9c216583d396e717e967becb42ece74651bd0", "html_url": "https://github.com/rust-lang/rust/commit/f3c9c216583d396e717e967becb42ece74651bd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c9c216583d396e717e967becb42ece74651bd0/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2d7ffc6353b65ff730dd1e7d8027b3751bf82aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2d7ffc6353b65ff730dd1e7d8027b3751bf82aa", "html_url": "https://github.com/rust-lang/rust/commit/a2d7ffc6353b65ff730dd1e7d8027b3751bf82aa"}], "stats": {"total": 324, "additions": 243, "deletions": 81}, "files": [{"sha": "a149a61ec136e0feb2c15ed7e59e65f66d298773", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -121,6 +121,7 @@ macro_rules! arena_types {\n                 >,\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n+            [] predefined_opaques_in_body: rustc_middle::traits::solve::PredefinedOpaquesData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n             [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n             [] mod_child: rustc_middle::metadata::ModChild,"}, {"sha": "2c5b64a59cdb9f7fc2bccfca3365c2ce50574e4c", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -5,13 +5,13 @@ use rustc_query_system::cache::Cache;\n \n use crate::infer::canonical::{CanonicalVarValues, QueryRegionConstraints};\n use crate::traits::query::NoSolution;\n-use crate::traits::Canonical;\n+use crate::traits::{Canonical, DefiningAnchor};\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable,\n     TypeVisitor,\n };\n \n-pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n+pub type EvaluationCache<'tcx> = Cache<CanonicalInput<'tcx>, QueryResult<'tcx>>;\n \n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n@@ -96,7 +96,31 @@ pub enum MaybeCause {\n     Overflow,\n }\n \n-pub type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct QueryInput<'tcx, T> {\n+    pub goal: Goal<'tcx, T>,\n+    pub anchor: DefiningAnchor,\n+    pub predefined_opaques_in_body: PredefinedOpaques<'tcx>,\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+pub struct PredefinedOpaquesData<'tcx> {\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n+pub struct PredefinedOpaques<'tcx>(pub(crate) Interned<'tcx, PredefinedOpaquesData<'tcx>>);\n+\n+impl<'tcx> std::ops::Deref for PredefinedOpaques<'tcx> {\n+    type Target = PredefinedOpaquesData<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+pub type CanonicalInput<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, QueryInput<'tcx, T>>;\n \n pub type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n \n@@ -165,3 +189,40 @@ impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n         ControlFlow::Continue(())\n     }\n }\n+\n+// FIXME: Having to clone `region_constraints` for folding feels bad and\n+// probably isn't great wrt performance.\n+//\n+// Not sure how to fix this, maybe we should also intern `opaque_types` and\n+// `region_constraints` here or something.\n+impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for PredefinedOpaques<'tcx> {\n+    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        Ok(FallibleTypeFolder::interner(folder).mk_predefined_opaques_in_body(\n+            PredefinedOpaquesData {\n+                opaque_types: self\n+                    .opaque_types\n+                    .iter()\n+                    .map(|opaque| opaque.try_fold_with(folder))\n+                    .collect::<Result<_, F::Error>>()?,\n+            },\n+        ))\n+    }\n+\n+    fn fold_with<F: TypeFolder<TyCtxt<'tcx>>>(self, folder: &mut F) -> Self {\n+        TypeFolder::interner(folder).mk_predefined_opaques_in_body(PredefinedOpaquesData {\n+            opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n+        })\n+    }\n+}\n+\n+impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for PredefinedOpaques<'tcx> {\n+    fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(\n+        &self,\n+        visitor: &mut V,\n+    ) -> std::ops::ControlFlow<V::BreakTy> {\n+        self.opaque_types.visit_with(visitor)\n+    }\n+}"}, {"sha": "2bde55bc4fd31922d411f43e607882e782b374ac", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -21,7 +21,9 @@ use crate::query::{IntoQueryParam, TyCtxtAt};\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve;\n-use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use crate::traits::solve::{\n+    ExternalConstraints, ExternalConstraintsData, PredefinedOpaques, PredefinedOpaquesData,\n+};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n@@ -140,6 +142,7 @@ pub struct CtxtInterners<'tcx> {\n     layout: InternedSet<'tcx, LayoutS>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n     external_constraints: InternedSet<'tcx, ExternalConstraintsData<'tcx>>,\n+    predefined_opaques_in_body: InternedSet<'tcx, PredefinedOpaquesData<'tcx>>,\n     fields: InternedSet<'tcx, List<FieldIdx>>,\n }\n \n@@ -164,6 +167,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             layout: Default::default(),\n             adt_def: Default::default(),\n             external_constraints: Default::default(),\n+            predefined_opaques_in_body: Default::default(),\n             fields: Default::default(),\n         }\n     }\n@@ -1520,6 +1524,8 @@ direct_interners! {\n     adt_def: pub mk_adt_def_from_data(AdtDefData): AdtDef -> AdtDef<'tcx>,\n     external_constraints: pub mk_external_constraints(ExternalConstraintsData<'tcx>):\n         ExternalConstraints -> ExternalConstraints<'tcx>,\n+    predefined_opaques_in_body: pub mk_predefined_opaques_in_body(PredefinedOpaquesData<'tcx>):\n+        PredefinedOpaques -> PredefinedOpaques<'tcx>,\n }\n \n macro_rules! slice_interners {"}, {"sha": "4e06832e65bd1b744c8614037ee1524b4af6a7e8", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -333,8 +333,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n-        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+        let &ty::Alias(_, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n \n@@ -356,8 +355,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                         }),\n                     );\n                     ecx.add_goal(normalizes_to_goal);\n-                    let _ = ecx.try_evaluate_added_goals()?;\n+                    let _ = ecx.try_evaluate_added_goals().inspect_err(|_| {\n+                        debug!(\"self type normalization failed\");\n+                    })?;\n                     let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+                    debug!(?normalized_ty, \"self type normalized\");\n                     // NOTE: Alternatively we could call `evaluate_goal` here and only\n                     // have a `Normalized` candidate. This doesn't work as long as we\n                     // use `CandidateSource` in winnowing."}, {"sha": "bd83666eb1ee510ca240531590daa186590235c7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -9,7 +9,10 @@ use rustc_infer::infer::{\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use rustc_middle::traits::solve::{\n+    CanonicalInput, Certainty, MaybeCause, PredefinedOpaques, PredefinedOpaquesData, QueryResult,\n+};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n@@ -44,6 +47,9 @@ pub struct EvalCtxt<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n \n     pub(super) var_values: CanonicalVarValues<'tcx>,\n+\n+    predefined_opaques_in_body: PredefinedOpaques<'tcx>,\n+\n     /// The highest universe index nameable by the caller.\n     ///\n     /// When we enter a new binder inside of the query we create new universes\n@@ -126,6 +132,11 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         let mut ecx = EvalCtxt {\n             search_graph: &mut search_graph,\n             infcx: self,\n+            // Only relevant when canonicalizing the response,\n+            // which we don't do within this evaluation context.\n+            predefined_opaques_in_body: self\n+                .tcx\n+                .mk_predefined_opaques_in_body(PredefinedOpaquesData::default()),\n             // Only relevant when canonicalizing the response.\n             max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n@@ -162,29 +173,59 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     fn evaluate_canonical_goal(\n         tcx: TyCtxt<'tcx>,\n         search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n+        canonical_input: CanonicalInput<'tcx>,\n     ) -> QueryResult<'tcx> {\n         // Deal with overflow, caching, and coinduction.\n         //\n         // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+        search_graph.with_new_goal(tcx, canonical_input, |search_graph| {\n             let intercrate = match search_graph.solver_mode() {\n                 SolverMode::Normal => false,\n                 SolverMode::Coherence => true,\n             };\n-            let (ref infcx, goal, var_values) = tcx\n+            let (ref infcx, input, var_values) = tcx\n                 .infer_ctxt()\n                 .intercrate(intercrate)\n-                .build_with_canonical(DUMMY_SP, &canonical_goal);\n+                .with_opaque_type_inference(canonical_input.value.anchor)\n+                .build_with_canonical(DUMMY_SP, &canonical_input);\n+\n+            for &(a, b) in &input.predefined_opaques_in_body.opaque_types {\n+                let InferOk { value: (), obligations } = infcx\n+                    .handle_opaque_type(\n+                        tcx.mk_opaque(a.def_id.to_def_id(), a.substs),\n+                        b,\n+                        true,\n+                        &ObligationCause::dummy(),\n+                        input.goal.param_env,\n+                    )\n+                    .expect(\"expected opaque type instantiation to succeed\");\n+                // We're only registering opaques already defined by the caller,\n+                // so we're not responsible for proving that they satisfy their\n+                // item bounds, unless we use them in a normalizes-to goal,\n+                // which is handled in `EvalCtxt::unify_existing_opaque_tys`.\n+                let _ = obligations;\n+            }\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,\n-                max_input_universe: canonical_goal.max_universe,\n+                predefined_opaques_in_body: input.predefined_opaques_in_body,\n+                max_input_universe: canonical_input.max_universe,\n                 search_graph,\n                 nested_goals: NestedGoals::new(),\n                 tainted: Ok(()),\n             };\n-            ecx.compute_goal(goal)\n+\n+            let result = ecx.compute_goal(input.goal);\n+\n+            // When creating a query response we clone the opaque type constraints\n+            // instead of taking them. This would cause an ICE here, since we have\n+            // assertions against dropping an `InferCtxt` without taking opaques.\n+            // FIXME: Once we remove support for the old impl we can remove this.\n+            if input.anchor != DefiningAnchor::Error {\n+                let _ = infcx.take_opaque_types();\n+            }\n+\n+            result\n         })\n     }\n \n@@ -199,7 +240,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n-        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let has_changed = !canonical_response.value.var_values.is_identity()\n+            || !canonical_response.value.external_constraints.opaque_types.is_empty();\n         let (certainty, nested_goals) = self.instantiate_and_apply_query_response(\n             goal.param_env,\n             orig_values,\n@@ -418,6 +460,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let mut ecx = EvalCtxt {\n             infcx: self.infcx,\n             var_values: self.var_values,\n+            predefined_opaques_in_body: self.predefined_opaques_in_body,\n             max_input_universe: self.max_input_universe,\n             search_graph: self.search_graph,\n             nested_goals: self.nested_goals.clone(),\n@@ -682,4 +725,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | rustc_transmute::Answer::IfAny(_) => Err(NoSolution),\n         }\n     }\n+\n+    pub(super) fn handle_opaque_ty(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        let InferOk { value: (), obligations } =\n+            self.infcx.handle_opaque_type(a, b, true, &ObligationCause::dummy(), param_env)?;\n+        self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n+        Ok(())\n+    }\n }"}, {"sha": "8d12c7edfe3b899e87d8750879db881cbb2f41c7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -8,16 +8,19 @@\n /// section of the [rustc-dev-guide][c].\n ///\n /// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n-use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalInput, Certainty, EvalCtxt, Goal};\n use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n use crate::solve::{CanonicalResponse, QueryResult, Response};\n use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData, MaybeCause};\n-use rustc_middle::ty::{self, BoundVar, GenericArgKind};\n+use rustc_middle::traits::solve::{\n+    ExternalConstraints, ExternalConstraintsData, MaybeCause, PredefinedOpaquesData, QueryInput,\n+};\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::ty::{self, BoundVar, GenericArgKind, Ty};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n@@ -28,13 +31,21 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn canonicalize_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n+    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalInput<'tcx>) {\n         let mut orig_values = Default::default();\n         let canonical_goal = Canonicalizer::canonicalize(\n             self.infcx,\n             CanonicalizeMode::Input,\n             &mut orig_values,\n-            goal,\n+            QueryInput {\n+                goal,\n+                anchor: self.infcx.defining_use_anchor,\n+                predefined_opaques_in_body: self.tcx().mk_predefined_opaques_in_body(\n+                    PredefinedOpaquesData {\n+                        opaque_types: self.infcx.clone_opaque_types_for_query_response(),\n+                    },\n+                ),\n+            },\n         );\n         (orig_values, canonical_goal)\n     }\n@@ -138,7 +149,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 region_constraints,\n             )\n         });\n-        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+\n+        let mut opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        // Only return opaque type keys for newly-defined opaques\n+        opaque_types.retain(|(a, _)| {\n+            self.predefined_opaques_in_body.opaque_types.iter().all(|(pa, _)| pa != a)\n+        });\n+\n         Ok(self\n             .tcx()\n             .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n@@ -162,12 +179,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let Response { var_values, external_constraints, certainty } =\n             response.substitute(self.tcx(), &substitution);\n \n-        let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n+        let mut nested_goals =\n+            self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n-        // FIXME: implement external constraints.\n-        let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n+        let ExternalConstraintsData { region_constraints, opaque_types } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n+        nested_goals.extend(self.register_opaque_types(param_env, opaque_types)?);\n \n         Ok((certainty, nested_goals))\n     }\n@@ -287,4 +305,29 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let _ = member_constraint;\n         }\n     }\n+\n+    fn register_opaque_types(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        opaque_types: &[(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)],\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n+        let mut nested_goals = vec![];\n+        for &(a, b) in opaque_types {\n+            nested_goals.extend(\n+                self.infcx\n+                    .handle_opaque_type(\n+                        self.tcx().mk_opaque(a.def_id.to_def_id(), a.substs),\n+                        b,\n+                        true,\n+                        &ObligationCause::dummy(),\n+                        param_env,\n+                    )?\n+                    .into_obligations()\n+                    .into_iter()\n+                    .map(Goal::from),\n+            );\n+        }\n+\n+        Ok(nested_goals)\n+    }\n }"}, {"sha": "7d6e1647cfcb55bfe298ae21ddb23d50d0f4564e", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -1,14 +1,13 @@\n-use rustc_infer::infer::InferOk;\n use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n-use rustc_middle::traits::{ObligationCause, Reveal};\n-use rustc_middle::ty::ProjectionPredicate;\n+use rustc_middle::traits::Reveal;\n+use rustc_middle::ty::{self};\n \n use super::{EvalCtxt, SolverMode};\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn normalize_opaque_type(\n         &mut self,\n-        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let tcx = self.tcx();\n         let opaque_ty = goal.predicate.projection_ty;\n@@ -19,15 +18,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 SolverMode::Normal => self.probe(|ecx| {\n                     // FIXME: Check that the usage is \"defining\" (all free params), otherwise bail.\n                     // FIXME: This should probably just check the anchor directly\n-                    let InferOk { value: (), obligations } = self.infcx.handle_opaque_type(\n-                        expected,\n-                        tcx.mk_opaque(opaque_ty.def_id, opaque_ty.substs),\n-                        true,\n-                        &ObligationCause::dummy(),\n-                        goal.param_env,\n-                    )?;\n-                    // FIXME: Need to fold these to replace the opaque ty with the expected ty.\n-                    ecx.add_goals(obligations.into_iter().map(Into::into));\n+                    let opaque_ty = tcx.mk_opaque(opaque_ty.def_id, opaque_ty.substs);\n+                    ecx.handle_opaque_ty(expected, opaque_ty, goal.param_env)?;\n                     ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }),\n                 SolverMode::Coherence => {"}, {"sha": "7d7dfa2c8377637c1fe4b757383fd62dfd86bab5", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -22,24 +22,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // To only compute normalization once for each projection we only\n-        // normalize if the expected term is an unconstrained inference variable.\n-        //\n-        // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n-        // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n-        // `U` and equate it with `u32`. This means that we don't need a separate\n-        // projection cache in the solver.\n-        if self.term_is_fully_unconstrained(goal) {\n-            match goal.predicate.projection_ty.kind(self.tcx()) {\n-                ty::AliasKind::Projection => {\n+        match goal.predicate.projection_ty.kind(self.tcx()) {\n+            ty::AliasKind::Projection => {\n+                // To only compute normalization once for each projection we only\n+                // normalize if the expected term is an unconstrained inference variable.\n+                //\n+                // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n+                // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n+                // `U` and equate it with `u32`. This means that we don't need a separate\n+                // projection cache in the solver.\n+                if self.term_is_fully_unconstrained(goal) {\n                     let candidates = self.assemble_and_evaluate_candidates(goal);\n                     self.merge_candidates(candidates)\n+                } else {\n+                    self.set_normalizes_to_hack_goal(goal);\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n-                ty::AliasKind::Opaque => self.normalize_opaque_type(goal),\n             }\n-        } else {\n-            self.set_normalizes_to_hack_goal(goal);\n-            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            ty::AliasKind::Opaque => self.normalize_opaque_type(goal),\n+            ty::AliasKind::Inherent => bug!(\"IATs not supported here yet\"),\n         }\n     }\n }"}, {"sha": "56f126e91572f5df39d08c822731706d3967af74", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -11,7 +11,7 @@\n use super::StackDepth;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::IndexVec;\n-use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n+use rustc_middle::traits::solve::{CanonicalInput, QueryResult};\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -34,15 +34,15 @@ pub(super) struct ProvisionalEntry<'tcx> {\n \n     // The goal for this entry. Should always be equal to the corresponding goal\n     // in the lookup table.\n-    pub(super) goal: CanonicalGoal<'tcx>,\n+    pub(super) input: CanonicalInput<'tcx>,\n }\n \n pub(super) struct ProvisionalCache<'tcx> {\n     pub(super) entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n     // FIXME: This is only used to quickly check whether a given goal\n     // is in the cache. We should experiment with using something like\n     // `SsoHashSet` here because in most cases there are only a few entries.\n-    pub(super) lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n+    pub(super) lookup_table: FxHashMap<CanonicalInput<'tcx>, EntryIndex>,\n }\n \n impl<'tcx> ProvisionalCache<'tcx> {"}, {"sha": "19e4b23009a79256c4ef2ee96799124e259ca028", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -8,7 +8,7 @@ use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::IndexVec;\n use rustc_middle::dep_graph::DepKind;\n-use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use rustc_middle::traits::solve::{CanonicalInput, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n@@ -19,7 +19,7 @@ rustc_index::newtype_index! {\n }\n \n struct StackElem<'tcx> {\n-    goal: CanonicalGoal<'tcx>,\n+    input: CanonicalInput<'tcx>,\n     has_been_used: bool,\n }\n \n@@ -77,7 +77,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             }\n \n             // ...or it depends on a goal with a lower depth.\n-            let current_goal = self.stack[stack_depth].goal;\n+            let current_goal = self.stack[stack_depth].input;\n             let entry_index = self.provisional_cache.lookup_table[&current_goal];\n             self.provisional_cache.entries[entry_index].depth != stack_depth\n         } else {\n@@ -92,20 +92,20 @@ impl<'tcx> SearchGraph<'tcx> {\n     fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        goal: CanonicalGoal<'tcx>,\n+        input: CanonicalInput<'tcx>,\n     ) -> Result<(), QueryResult<'tcx>> {\n         // Look at the provisional cache to check for cycles.\n         let cache = &mut self.provisional_cache;\n-        match cache.lookup_table.entry(goal) {\n+        match cache.lookup_table.entry(input) {\n             // No entry, simply push this goal on the stack after dealing with overflow.\n             Entry::Vacant(v) => {\n                 if self.overflow_data.has_overflow(self.stack.len()) {\n-                    return Err(self.deal_with_overflow(tcx, goal));\n+                    return Err(self.deal_with_overflow(tcx, input));\n                 }\n \n-                let depth = self.stack.push(StackElem { goal, has_been_used: false });\n-                let response = super::response_no_constraints(tcx, goal, Certainty::Yes);\n-                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n+                let depth = self.stack.push(StackElem { input, has_been_used: false });\n+                let response = super::response_no_constraints(tcx, input, Certainty::Yes);\n+                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, input });\n                 v.insert(entry_index);\n                 Ok(())\n             }\n@@ -135,13 +135,13 @@ impl<'tcx> SearchGraph<'tcx> {\n                 // the stack is enough.\n                 if self.stack.raw[stack_depth.index()..]\n                     .iter()\n-                    .all(|g| g.goal.value.predicate.is_coinductive(tcx))\n+                    .all(|g| g.input.value.goal.predicate.is_coinductive(tcx))\n                 {\n                     Err(cache.provisional_result(entry_index))\n                 } else {\n                     Err(super::response_no_constraints(\n                         tcx,\n-                        goal,\n+                        input,\n                         Certainty::Maybe(MaybeCause::Overflow),\n                     ))\n                 }\n@@ -161,18 +161,18 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_input), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        actual_goal: CanonicalGoal<'tcx>,\n+        actual_input: CanonicalInput<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n         let stack_elem = self.stack.pop().unwrap();\n-        let StackElem { goal, has_been_used } = stack_elem;\n-        assert_eq!(goal, actual_goal);\n+        let StackElem { input, has_been_used } = stack_elem;\n+        assert_eq!(input, actual_input);\n \n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&input).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         // We eagerly update the response in the cache here. If we have to reevaluate\n         // this goal we use the new response when hitting a cycle, and we definitely\n@@ -194,7 +194,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             cache.entries.truncate(provisional_entry_index.index() + 1);\n \n             // ...and finally push our goal back on the stack and reevaluate it.\n-            self.stack.push(StackElem { goal, has_been_used: false });\n+            self.stack.push(StackElem { input, has_been_used: false });\n             false\n         } else {\n             true\n@@ -204,17 +204,17 @@ impl<'tcx> SearchGraph<'tcx> {\n     pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n+        canonical_input: CanonicalInput<'tcx>,\n         mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if self.should_use_global_cache() {\n-            if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n-                debug!(?canonical_goal, ?result, \"cache hit\");\n+            if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_input, tcx) {\n+                debug!(?canonical_input, ?result, \"cache hit\");\n                 return result;\n             }\n         }\n \n-        match self.try_push_stack(tcx, canonical_goal) {\n+        match self.try_push_stack(tcx, canonical_input) {\n             Ok(()) => {}\n             // Our goal is already on the stack, eager return.\n             Err(response) => return response,\n@@ -226,19 +226,19 @@ impl<'tcx> SearchGraph<'tcx> {\n         let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n             self.repeat_while_none(\n                 |this| {\n-                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let result = this.deal_with_overflow(tcx, canonical_input);\n                     let _ = this.stack.pop().unwrap();\n                     result\n                 },\n                 |this| {\n                     let result = loop_body(this);\n-                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                    this.try_finalize_goal(canonical_input, result).then(|| result)\n                 },\n             )\n         });\n \n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_input).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n@@ -254,13 +254,13 @@ impl<'tcx> SearchGraph<'tcx> {\n             // cycle participants without moving them to the global cache.\n             let other_cycle_participants = provisional_entry_index.index() + 1;\n             for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n-                let actual_index = cache.lookup_table.remove(&entry.goal);\n+                let actual_index = cache.lookup_table.remove(&entry.input);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n             }\n \n             let current_goal = cache.entries.pop().unwrap();\n-            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            let actual_index = cache.lookup_table.remove(&current_goal.input);\n             debug_assert_eq!(Some(provisional_entry_index), actual_index);\n             debug_assert!(current_goal.depth == depth);\n \n@@ -274,7 +274,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             let can_cache = !self.overflow_data.did_overflow() || self.stack.is_empty();\n             if self.should_use_global_cache() && can_cache {\n                 tcx.new_solver_evaluation_cache.insert(\n-                    current_goal.goal,\n+                    current_goal.input,\n                     dep_node,\n                     current_goal.response,\n                 );"}, {"sha": "f5b2753b7973d51e3cdf2a7e52ff323107a67601", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9c216583d396e717e967becb42ece74651bd0/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=f3c9c216583d396e717e967becb42ece74651bd0", "patch": "@@ -16,6 +16,7 @@ fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n+    assert!(!tcx.trait_solver_next());\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs"}]}