{"sha": "2b7dd313685279fce06f86bd739d798792135331", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiN2RkMzEzNjg1Mjc5ZmNlMDZmODZiZDczOWQ3OTg3OTIxMzUzMzE=", "commit": {"author": {"name": "Aleksei Latyshev", "email": "alex_700_95@mail.ru", "date": "2020-10-24T15:06:07Z"}, "committer": {"name": "Aleksei Latyshev", "email": "alex_700_95@mail.ru", "date": "2020-10-27T20:45:58Z"}, "message": "improve MATCH_LIKE_MATCHES_MACRO lint\n\n- add tests\n- refactor match_same_arms lint\n- prioritize match_expr_like_matches_macro over match_same_arms", "tree": {"sha": "750caa045566af7ed2248fe858b20b12406252b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/750caa045566af7ed2248fe858b20b12406252b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b7dd313685279fce06f86bd739d798792135331", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEopQOAF0V9HUfAT+fRv3WL5zBFNsFAl+YhwYACgkQRv3WL5zB\nFNt+hhAAnhMw0hdAEnXLct3NfhPsVq208DkylOWHm4B0bXZKudtcuZ5UkGJ+CVIq\n/YY9EVSZGju7DLaGbXrVi8FpIGUB1lcms65DFi2usaxBB3ygQJ17DhSlDmxDiHWr\nzQvr0mQCEHFiTX2Iu4oFd3x3Uqg3uok2zpP3TdGu70tk8/T0rfWy8R72jgaKAtCv\nXee8WJh1nm/Wa58GdO7ch6W6WgrSA4JFpBr5vWBGA2qLccFhn0i6+5KQTHCXk8FV\nubN2AyyVaxfgYQAcnifQUjyR/PEB7aKCKDTBVTdi8U8L3UZlS9idGjowynnZ8h8K\naYJfHpeKQ1Ho0873e2z+V4eUT1pgzDa79gdYaX8Ztj1920R4gaK3K9mufYyMsm8T\nyp+gz303afIKL1QZ8Vt7dLqoaV/U2EZT0d103TAZ2WFg/nVcFoFAarimSL6rbN77\nOWzovfkhvFo1ALj3Uhl0648QlTkcx/m1pi+lA268T9E/ZrvpDbD1TmPW8TNP8QvI\nFxcOG8n902opPpZo6j9Wt2o0b/DKxVZeXrUl+aV80MY5x3nec2s9HFijo2sXQfwx\nxCd8i5l8UJ3w0YcTMmYSba3dbhydSqTWKvUiWv+ZBQJWgLP3UcsxkCMqblZKDOL2\nFkA6qiZsR/8l8SbNXG/jKMHaKTk2L0VHpUDmX4noV841KbeeoM4=\n=sMkd\n-----END PGP SIGNATURE-----", "payload": "tree 750caa045566af7ed2248fe858b20b12406252b7\nparent 09e70536075fd92506ef985c5e662e1b2be3dd3d\nauthor Aleksei Latyshev <alex_700_95@mail.ru> 1603551967 +0300\ncommitter Aleksei Latyshev <alex_700_95@mail.ru> 1603831558 +0300\n\nimprove MATCH_LIKE_MATCHES_MACRO lint\n\n- add tests\n- refactor match_same_arms lint\n- prioritize match_expr_like_matches_macro over match_same_arms\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b7dd313685279fce06f86bd739d798792135331", "html_url": "https://github.com/rust-lang/rust/commit/2b7dd313685279fce06f86bd739d798792135331", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b7dd313685279fce06f86bd739d798792135331/comments", "author": {"login": "alex-700", "id": 8705888, "node_id": "MDQ6VXNlcjg3MDU4ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/8705888?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alex-700", "html_url": "https://github.com/alex-700", "followers_url": "https://api.github.com/users/alex-700/followers", "following_url": "https://api.github.com/users/alex-700/following{/other_user}", "gists_url": "https://api.github.com/users/alex-700/gists{/gist_id}", "starred_url": "https://api.github.com/users/alex-700/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alex-700/subscriptions", "organizations_url": "https://api.github.com/users/alex-700/orgs", "repos_url": "https://api.github.com/users/alex-700/repos", "events_url": "https://api.github.com/users/alex-700/events{/privacy}", "received_events_url": "https://api.github.com/users/alex-700/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alex-700", "id": 8705888, "node_id": "MDQ6VXNlcjg3MDU4ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/8705888?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alex-700", "html_url": "https://github.com/alex-700", "followers_url": "https://api.github.com/users/alex-700/followers", "following_url": "https://api.github.com/users/alex-700/following{/other_user}", "gists_url": "https://api.github.com/users/alex-700/gists{/gist_id}", "starred_url": "https://api.github.com/users/alex-700/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alex-700/subscriptions", "organizations_url": "https://api.github.com/users/alex-700/orgs", "repos_url": "https://api.github.com/users/alex-700/repos", "events_url": "https://api.github.com/users/alex-700/events{/privacy}", "received_events_url": "https://api.github.com/users/alex-700/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09e70536075fd92506ef985c5e662e1b2be3dd3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/09e70536075fd92506ef985c5e662e1b2be3dd3d", "html_url": "https://github.com/rust-lang/rust/commit/09e70536075fd92506ef985c5e662e1b2be3dd3d"}], "stats": {"total": 675, "additions": 439, "deletions": 236}, "files": [{"sha": "46ce92ea6d782273d7f894a2c9e634913fbd1888", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 4, "deletions": 211, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -1,13 +1,8 @@\n-use crate::utils::{eq_expr_value, in_macro, SpanlessEq, SpanlessHash};\n-use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n+use crate::utils::{eq_expr_value, in_macro, search_same, SpanlessEq, SpanlessHash};\n+use crate::utils::{get_parent_expr, higher, if_sequence, span_lint_and_note};\n+use rustc_hir::{Block, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::Symbol;\n-use std::collections::hash_map::Entry;\n-use std::hash::BuildHasherDefault;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for consecutive `if`s with the same condition.\n@@ -108,48 +103,7 @@ declare_clippy_lint! {\n     \"`if` with the same `then` and `else` blocks\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `match` with identical arm bodies.\n-    ///\n-    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n-    /// are the same on purpose, you can factor them\n-    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-    ///\n-    /// **Known problems:** False positive possible with order dependent `match`\n-    /// (see issue\n-    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => bar(), // <= oops\n-    /// }\n-    /// ```\n-    ///\n-    /// This should probably be\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => baz(), // <= fixed\n-    /// }\n-    /// ```\n-    ///\n-    /// or if the original code was not a typo:\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar | Baz => bar(), // <= shows the intent better\n-    ///     Quz => quz(),\n-    /// }\n-    /// ```\n-    pub MATCH_SAME_ARMS,\n-    pedantic,\n-    \"`match` with identical arm bodies\"\n-}\n-\n-declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE, MATCH_SAME_ARMS]);\n+declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -167,7 +121,6 @@ impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n             lint_same_then_else(cx, &blocks);\n             lint_same_cond(cx, &conds);\n             lint_same_fns_in_if_cond(cx, &conds);\n-            lint_match_arms(cx, expr);\n         }\n     }\n }\n@@ -243,122 +196,6 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     }\n }\n \n-/// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n-        lhs.len() == rhs.len()\n-            && lhs\n-                .iter()\n-                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n-    }\n-\n-    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(&arm.body);\n-            h.finish()\n-        };\n-\n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n-\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n-                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n-                // all patterns should have the same bindings\n-                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n-        };\n-\n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-/// Returns the list of bindings in a pattern.\n-fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n-        match pat.kind {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, pats, _) => {\n-                for pat in pats {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Binding(.., ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.typeck_results().pat_ty(pat));\n-                }\n-                if let Some(ref as_pat) = *as_pat {\n-                    bindings_impl(cx, as_pat, map);\n-                }\n-            },\n-            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Struct(_, fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, &pat.pat, map);\n-                }\n-            },\n-            PatKind::Slice(lhs, ref mid, rhs) => {\n-                for pat in lhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-                if let Some(ref mid) = *mid {\n-                    bindings_impl(cx, mid, map);\n-                }\n-                for pat in rhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n-        }\n-    }\n-\n-    let mut result = FxHashMap::default();\n-    bindings_impl(cx, pat, &mut result);\n-    result\n-}\n-\n fn search_same_sequenced<T, Eq>(exprs: &[T], eq: Eq) -> Option<(&T, &T)>\n where\n     Eq: Fn(&T, &T) -> bool,\n@@ -370,47 +207,3 @@ where\n     }\n     None\n }\n-\n-fn search_common_cases<'a, T, Eq>(exprs: &'a [T], eq: &Eq) -> Option<(&'a T, &'a T)>\n-where\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n-        Some((&exprs[0], &exprs[1]))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n-where\n-    Hash: Fn(&T) -> u64,\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    if let Some(expr) = search_common_cases(&exprs, &eq) {\n-        return vec![expr];\n-    }\n-\n-    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n-\n-    let mut map: FxHashMap<_, Vec<&_>> =\n-        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n-\n-    for expr in exprs {\n-        match map.entry(hash(expr)) {\n-            Entry::Occupied(mut o) => {\n-                for o in o.get() {\n-                    if eq(o, expr) {\n-                        match_expr_list.push((o, expr));\n-                    }\n-                }\n-                o.get_mut().push(expr);\n-            },\n-            Entry::Vacant(v) => {\n-                v.insert(vec![expr]);\n-            },\n-        }\n-    }\n-\n-    match_expr_list\n-}"}, {"sha": "459fdd704439095f8cf858eeec99c764a79141f7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -528,7 +528,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &comparison_chain::COMPARISON_CHAIN,\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n-        &copies::MATCH_SAME_ARMS,\n         &copies::SAME_FUNCTIONS_IN_IF_CONDITION,\n         &copy_iterator::COPY_ITERATOR,\n         &create_dir::CREATE_DIR,\n@@ -659,6 +658,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &matches::MATCH_LIKE_MATCHES_MACRO,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n+        &matches::MATCH_SAME_ARMS,\n         &matches::MATCH_SINGLE_BINDING,\n         &matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n         &matches::MATCH_WILD_ERR_ARM,\n@@ -1204,7 +1204,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::INLINE_ALWAYS),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n-        LintId::of(&copies::MATCH_SAME_ARMS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n         LintId::of(&default_trait_access::DEFAULT_TRAIT_ACCESS),\n@@ -1234,6 +1233,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n+        LintId::of(&matches::MATCH_SAME_ARMS),\n         LintId::of(&matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n         LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH_ELSE),"}, {"sha": "4bdfca1a2921d8e16c8f0571a0f965714fdfe508", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 199, "deletions": 18, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -1,5 +1,4 @@\n use crate::consts::{constant, miri_to_const, Constant};\n-use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n@@ -8,8 +7,10 @@ use crate::utils::{\n     snippet_block, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n     span_lint_and_then,\n };\n+use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n@@ -18,10 +19,12 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::Symbol;\n use std::cmp::Ordering;\n+use std::collections::hash_map::Entry;\n use std::collections::Bound;\n \n declare_clippy_lint! {\n@@ -475,6 +478,47 @@ declare_clippy_lint! {\n     \"a match that could be written with the matches! macro\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match` with identical arm bodies.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// **Known problems:** False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n+    pub MATCH_SAME_ARMS,\n+    pedantic,\n+    \"`match` with identical arm bodies\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     infallible_destructuring_match_linted: bool,\n@@ -495,7 +539,8 @@ impl_lint_pass!(Matches => [\n     INFALLIBLE_DESTRUCTURING_MATCH,\n     REST_PAT_IN_FULLY_BOUND_STRUCTS,\n     REDUNDANT_PATTERN_MATCHING,\n-    MATCH_LIKE_MATCHES_MACRO\n+    MATCH_LIKE_MATCHES_MACRO,\n+    MATCH_SAME_ARMS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -505,7 +550,9 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         }\n \n         redundant_pattern_match::check(cx, expr);\n-        check_match_like_matches(cx, expr);\n+        if !check_match_like_matches(cx, expr) {\n+            lint_match_arms(cx, expr);\n+        }\n \n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n@@ -1063,32 +1110,47 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n }\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n         match match_source {\n             MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n             MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n-            _ => return,\n+            _ => false,\n         }\n+    } else {\n+        false\n     }\n }\n \n /// Lint a `match` or desugared `if let` for replacement by `matches!`\n-fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n+fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) -> bool {\n     if_chain! {\n-        if arms.len() == 2;\n+        if arms.len() >= 2;\n         if cx.typeck_results().expr_ty(expr).is_bool();\n-        if is_wild(&arms[1].pat);\n-        if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n-        if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n-        if first != second;\n+        if let Some((b1_arm, b0_arms)) = arms.split_last();\n+        if let Some(b0) = find_bool_lit(&b0_arms[0].body.kind, desugared);\n+        if let Some(b1) = find_bool_lit(&b1_arm.body.kind, desugared);\n+        if is_wild(&b1_arm.pat);\n+        if b0 != b1;\n+        let if_guard = &b0_arms[0].guard;\n+        if if_guard.is_none() || b0_arms.len() == 1;\n+        if b0_arms[1..].iter()\n+            .all(|arm| {\n+                find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n+                arm.guard.is_none()\n+            });\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-\n-            let pat_and_guard = if let Some(Guard::If(g)) = arms[0].guard {\n-                format!(\"{} if {}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability), snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            let pat = {\n+                use itertools::Itertools as _;\n+                b0_arms.iter()\n+                    .map(|arm| snippet_with_applicability(cx, arm.pat.span, \"..\", &mut applicability))\n+                    .join(\" | \")\n+            };\n+            let pat_and_guard = if let Some(Guard::If(g)) = if_guard {\n+                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n             } else {\n-                format!(\"{}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability))\n+                pat\n             };\n             span_lint_and_sugg(\n                 cx,\n@@ -1098,12 +1160,15 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n                 \"try this\",\n                 format!(\n                     \"{}matches!({}, {})\",\n-                    if first { \"\" } else { \"!\" },\n+                    if b0 { \"\" } else { \"!\" },\n                     snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n                     pat_and_guard,\n                 ),\n                 applicability,\n-            )\n+            );\n+            true\n+        } else {\n+            false\n         }\n     }\n }\n@@ -1657,3 +1722,119 @@ fn test_overlapping() {\n         ],)\n     );\n }\n+\n+/// Implementation of `MATCH_SAME_ARMS`.\n+fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n+    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n+        lhs.len() == rhs.len()\n+            && lhs\n+                .iter()\n+                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n+    }\n+\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+            let mut h = SpanlessHash::new(cx);\n+            h.hash_expr(&arm.body);\n+            h.finish()\n+        };\n+\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+            let min_index = usize::min(lindex, rindex);\n+            let max_index = usize::max(lindex, rindex);\n+\n+            // Arms with a guard are ignored, those can\u2019t always be merged together\n+            // This is also the case for arms in-between each there is an arm with a guard\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n+                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n+                // all patterns should have the same bindings\n+                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+        };\n+\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |diag| {\n+                    diag.span_note(i.body.span, \"same as this\");\n+\n+                    // Note: this does not use `span_suggestion` on purpose:\n+                    // there is no clean way\n+                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                    // makes an even more confusing error message. Also in order not to make up a\n+                    // span for the whole pattern, the suggestion is only shown when there is only\n+                    // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.kind {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        diag.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+/// Returns the list of bindings in a pattern.\n+fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n+    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n+        match pat.kind {\n+            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::TupleStruct(_, pats, _) => {\n+                for pat in pats {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Binding(.., ident, ref as_pat) => {\n+                if let Entry::Vacant(v) = map.entry(ident.name) {\n+                    v.insert(cx.typeck_results().pat_ty(pat));\n+                }\n+                if let Some(ref as_pat) = *as_pat {\n+                    bindings_impl(cx, as_pat, map);\n+                }\n+            },\n+            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Struct(_, fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, &pat.pat, map);\n+                }\n+            },\n+            PatKind::Slice(lhs, ref mid, rhs) => {\n+                for pat in lhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+                if let Some(ref mid) = *mid {\n+                    bindings_impl(cx, mid, map);\n+                }\n+                for pat in rhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n+        }\n+    }\n+\n+    let mut result = FxHashMap::default();\n+    bindings_impl(cx, pat, &mut result);\n+    result\n+}"}, {"sha": "0a8a4a5f9aedbebc8a058ee3535c922afe520109", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -27,11 +27,14 @@ pub use self::diagnostics::*;\n pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n+use std::collections::hash_map::Entry;\n+use std::hash::BuildHasherDefault;\n use std::mem;\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_attr as attr;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -1465,6 +1468,41 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     None\n }\n \n+/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n+/// `hash` must be comformed with `eq`\n+pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n+        return vec![(&exprs[0], &exprs[1])];\n+    }\n+\n+    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n+\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(mut o) => {\n+                for o in o.get() {\n+                    if eq(o, expr) {\n+                        match_expr_list.push((o, expr));\n+                    }\n+                }\n+                o.get_mut().push(expr);\n+            },\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            },\n+        }\n+    }\n+\n+    match_expr_list\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "aba436e5c024b4e615ccdfe33df34929dfb13241", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -1304,7 +1304,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"`match` with identical arm bodies\",\n         deprecation: None,\n-        module: \"copies\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"match_single_binding\","}, {"sha": "7f4ebf566733a6e8df6d300f10a7d919671c982a", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::match_like_matches_macro)]\n-#![allow(unreachable_patterns)]\n+#![allow(unreachable_patterns, dead_code)]\n \n fn main() {\n     let x = Some(5);\n@@ -33,4 +33,70 @@ fn main() {\n         _ => true,\n         None => false,\n     };\n+\n+    enum E {\n+        A(u32),\n+        B(i32),\n+        C,\n+        D,\n+    };\n+    let x = E::A(2);\n+    {\n+        // lint\n+        let _ans = matches!(x, E::A(_) | E::B(_));\n+    }\n+    {\n+        // lint\n+        let _ans = !matches!(x, E::B(_) | E::C);\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => false,\n+            E::C => true,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => true,\n+            E::B(_) => false,\n+            E::C => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) if a < 10 => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) => a == 10,\n+            E::B(_) => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "aee56dd4a5ef474e478dc2a72acdb950368796d2", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::match_like_matches_macro)]\n-#![allow(unreachable_patterns)]\n+#![allow(unreachable_patterns, dead_code)]\n \n fn main() {\n     let x = Some(5);\n@@ -45,4 +45,78 @@ fn main() {\n         _ => true,\n         None => false,\n     };\n+\n+    enum E {\n+        A(u32),\n+        B(i32),\n+        C,\n+        D,\n+    };\n+    let x = E::A(2);\n+    {\n+        // lint\n+        let _ans = match x {\n+            E::A(_) => true,\n+            E::B(_) => true,\n+            _ => false,\n+        };\n+    }\n+    {\n+        // lint\n+        let _ans = match x {\n+            E::B(_) => false,\n+            E::C => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => false,\n+            E::C => true,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => true,\n+            E::B(_) => false,\n+            E::C => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) if a < 10 => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(a) if a < 10 => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(a) => a == 10,\n+            E::B(_) => false,\n+            _ => true,\n+        };\n+    }\n+    {\n+        // no lint\n+        let _ans = match x {\n+            E::A(_) => false,\n+            E::B(_) => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "c52e41c788944e5757c3f26c2f97d500f3dbf92a", "filename": "tests/ui/match_expr_like_matches_macro.stderr", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -48,5 +48,27 @@ error: if let .. else expression looks like `matches!` macro\n LL |     let _zzz = if let Some(5) = x { true } else { false };\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n \n-error: aborting due to 5 previous errors\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:58:20\n+   |\n+LL |           let _ans = match x {\n+   |  ____________________^\n+LL | |             E::A(_) => true,\n+LL | |             E::B(_) => true,\n+LL | |             _ => false,\n+LL | |         };\n+   | |_________^ help: try this: `matches!(x, E::A(_) | E::B(_))`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:66:20\n+   |\n+LL |           let _ans = match x {\n+   |  ____________________^\n+LL | |             E::B(_) => false,\n+LL | |             E::C => false,\n+LL | |             _ => true,\n+LL | |         };\n+   | |_________^ help: try this: `!matches!(x, E::B(_) | E::C)`\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "06d91497242e1f493abf50fad80407e87df18e36", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -119,6 +119,22 @@ fn match_same_arms() {\n             unreachable!();\n         },\n     }\n+\n+    match_expr_like_matches_macro_priority();\n+}\n+\n+fn match_expr_like_matches_macro_priority() {\n+    enum E {\n+        A,\n+        B,\n+        C,\n+    }\n+    let x = E::A;\n+    let _ans = match x {\n+        E::A => false,\n+        E::B => false,\n+        _ => true,\n+    };\n }\n \n fn main() {}"}, {"sha": "fccaf805616b48bc99aae55bcb53d817859b42fe", "filename": "tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b7dd313685279fce06f86bd739d798792135331/tests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.stderr?ref=2b7dd313685279fce06f86bd739d798792135331", "patch": "@@ -141,5 +141,18 @@ LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 7 previous errors\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_same_arms2.rs:133:16\n+   |\n+LL |       let _ans = match x {\n+   |  ________________^\n+LL | |         E::A => false,\n+LL | |         E::B => false,\n+LL | |         _ => true,\n+LL | |     };\n+   | |_____^ help: try this: `!matches!(x, E::A | E::B)`\n+   |\n+   = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n+\n+error: aborting due to 8 previous errors\n "}]}