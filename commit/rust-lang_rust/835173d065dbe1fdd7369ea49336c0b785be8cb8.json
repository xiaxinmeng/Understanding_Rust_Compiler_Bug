{"sha": "835173d065dbe1fdd7369ea49336c0b785be8cb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNTE3M2QwNjVkYmUxZmRkNzM2OWVhNDkzMzZjMGI3ODViZThjYjg=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-12T17:30:53Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "replace trait by a bunch of functions", "tree": {"sha": "e19916b78f4fff145ec59b790c626e2a9f538bbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e19916b78f4fff145ec59b790c626e2a9f538bbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/835173d065dbe1fdd7369ea49336c0b785be8cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/835173d065dbe1fdd7369ea49336c0b785be8cb8", "html_url": "https://github.com/rust-lang/rust/commit/835173d065dbe1fdd7369ea49336c0b785be8cb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/835173d065dbe1fdd7369ea49336c0b785be8cb8/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "html_url": "https://github.com/rust-lang/rust/commit/d26d0ada50fd0063c03e28bc2673f9f63fd23d95"}], "stats": {"total": 557, "additions": 227, "deletions": 330}, "files": [{"sha": "f80d8eb5f1ed991ce36c36e293d25d2c0380045f", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -11,9 +11,8 @@ use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n     name::AsName,\n-    AssocItem, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n-    Module, ModuleDef, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union,\n-    VariantDef,\n+    Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n+    ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -130,61 +129,6 @@ impl FromSource for StructField {\n     }\n }\n \n-impl FromSource for AssocItem {\n-    type Ast = ast::ImplItem;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        macro_rules! def {\n-            ($kind:ident, $ast:ident) => {\n-                $kind::from_source(db, Source { file_id: src.file_id, ast: $ast })\n-                    .and_then(|it| Some(AssocItem::from(it)))\n-            };\n-        }\n-\n-        match src.ast {\n-            ast::ImplItem::FnDef(f) => def!(Function, f),\n-            ast::ImplItem::ConstDef(c) => def!(Const, c),\n-            ast::ImplItem::TypeAliasDef(a) => def!(TypeAlias, a),\n-        }\n-    }\n-}\n-\n-// not fully matched\n-impl FromSource for ModuleDef {\n-    type Ast = ast::ModuleItem;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        macro_rules! def {\n-            ($kind:ident, $ast:ident) => {\n-                $kind::from_source(db, Source { file_id: src.file_id, ast: $ast })\n-                    .and_then(|it| Some(ModuleDef::from(it)))\n-            };\n-        }\n-\n-        match src.ast {\n-            ast::ModuleItem::FnDef(f) => def!(Function, f),\n-            ast::ModuleItem::ConstDef(c) => def!(Const, c),\n-            ast::ModuleItem::TypeAliasDef(a) => def!(TypeAlias, a),\n-            ast::ModuleItem::TraitDef(t) => def!(Trait, t),\n-            ast::ModuleItem::StaticDef(s) => def!(Static, s),\n-            ast::ModuleItem::StructDef(s) => {\n-                let src = Source { file_id: src.file_id, ast: s };\n-                let s = Struct::from_source(db, src)?;\n-                Some(ModuleDef::Adt(s.into()))\n-            }\n-            ast::ModuleItem::EnumDef(e) => {\n-                let src = Source { file_id: src.file_id, ast: e };\n-                let e = Enum::from_source(db, src)?;\n-                Some(ModuleDef::Adt(e.into()))\n-            }\n-            ast::ModuleItem::Module(ref m) if !m.has_semi() => {\n-                let src = Source { file_id: src.file_id, ast: ModuleSource::Module(m.clone()) };\n-                let module = Module::from_definition(db, src)?;\n-                Some(ModuleDef::Module(module))\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n // FIXME: simplify it\n impl ModuleSource {\n     pub fn from_position("}, {"sha": "1b4ad3a597bf6decf783d1acc48f46580708280d", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -57,7 +57,7 @@ pub(crate) fn reference_definition(\n     let name_kind = classify_name_ref(db, file_id, &name_ref).and_then(|d| Some(d.item));\n     match name_kind {\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n-        Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n+        Some(Field(field)) => return Exact(NavigationTarget::from_field(db, field)),\n         Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_assoc_item(db, assoc)),\n         Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n             Some(nav) => return Exact(nav),"}, {"sha": "318708df3df07f15a81b43fc689de5a634326f4e", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -107,7 +107,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n                 let src = it.source(db);\n                 res.extend(hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast))));\n             }\n-            Some(FieldAccess(it)) => {\n+            Some(Field(it)) => {\n                 let src = it.source(db);\n                 if let hir::FieldSource::Named(it) = src.ast {\n                     res.extend(hover_text(it.doc_comment_text(), it.short_label()));"}, {"sha": "3761fd6e760975c78155f6f1e4e0e4f1507896a6", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n mod classify;\n-mod definition;\n+mod name_definition;\n mod rename;\n mod search_scope;\n \n@@ -12,7 +12,7 @@ use crate::{db::RootDatabase, FileId, FilePosition, FileRange, NavigationTarget,\n \n pub(crate) use self::{\n     classify::{classify_name, classify_name_ref},\n-    definition::{Definition, NameKind},\n+    name_definition::{NameDefinition, NameKind},\n     rename::rename,\n };\n \n@@ -63,7 +63,7 @@ pub(crate) fn find_all_refs(\n \n     let declaration = match def.item {\n         NameKind::Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n-        NameKind::FieldAccess(field) => NavigationTarget::from_field(db, field),\n+        NameKind::Field(field) => NavigationTarget::from_field(db, field),\n         NameKind::AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n         NameKind::Def(def) => NavigationTarget::from_def(db, def)?,\n         NameKind::SelfType(ref ty) => match ty.as_adt() {\n@@ -84,7 +84,7 @@ fn find_name<'a>(\n     db: &RootDatabase,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> Option<RangeInfo<(String, Definition)>> {\n+) -> Option<RangeInfo<(String, NameDefinition)>> {\n     if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n         let def = classify_name(db, position.file_id, &name)?;\n         let range = name.syntax().text_range();\n@@ -96,7 +96,7 @@ fn find_name<'a>(\n     Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n }\n \n-fn process_definition(db: &RootDatabase, def: Definition, name: String) -> Vec<FileRange> {\n+fn process_definition(db: &RootDatabase, def: NameDefinition, name: String) -> Vec<FileRange> {\n     let pat = name.as_str();\n     let scope = def.scope(db).scope;\n     let mut refs = vec![];"}, {"sha": "2ba1cf71ce62b11acfad4b623f7c0d628079b6fd", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 111, "deletions": 85, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -1,47 +1,90 @@\n-use hir::{\n-    AssocItem, Either, EnumVariant, FromSource, Module, ModuleDef, ModuleSource, Path,\n-    PathResolution, Source, SourceAnalyzer, StructField,\n-};\n+use hir::{Either, FromSource, Module, ModuleSource, Path, PathResolution, Source, SourceAnalyzer};\n use ra_db::FileId;\n use ra_syntax::{ast, match_ast, AstNode, AstPtr};\n \n-use super::{definition::HasDefinition, Definition, NameKind};\n+use super::{\n+    name_definition::{from_assoc_item, from_module_def, from_pat, from_struct_field},\n+    NameDefinition, NameKind,\n+};\n use crate::db::RootDatabase;\n \n-use hir::{db::AstDatabase, HirFileId};\n-\n pub(crate) fn classify_name(\n     db: &RootDatabase,\n     file_id: FileId,\n     name: &ast::Name,\n-) -> Option<Definition> {\n+) -> Option<NameDefinition> {\n     let parent = name.syntax().parent()?;\n     let file_id = file_id.into();\n \n+    // FIXME: add ast::MacroCall(it)\n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n-                decl_from_pat(db, file_id, AstPtr::new(&it))\n+                from_pat(db, file_id, AstPtr::new(&it))\n             },\n             ast::RecordFieldDef(it) => {\n-                StructField::from_def(db, file_id, it)\n+                let ast = hir::FieldSource::Named(it);\n+                let src = hir::Source { file_id, ast };\n+                let field = hir::StructField::from_source(db, src)?;\n+                Some(from_struct_field(db, field))\n+            },\n+            ast::Module(it) => {\n+                let ast = hir::ModuleSource::Module(it);\n+                let src = hir::Source { file_id, ast };\n+                let def = hir::Module::from_definition(db, src)?;\n+                Some(from_module_def(db, def.into()))\n             },\n-            ast::ImplItem(it) => {\n-                AssocItem::from_def(db, file_id, it.clone()).or_else(|| {\n-                    match it {\n-                        ast::ImplItem::FnDef(f) => ModuleDef::from_def(db, file_id, f.into()),\n-                        ast::ImplItem::ConstDef(c) => ModuleDef::from_def(db, file_id, c.into()),\n-                        ast::ImplItem::TypeAliasDef(a) => ModuleDef::from_def(db, file_id, a.into()),\n-                    }\n-                })\n+            ast::StructDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Struct::from_source(db, src)?;\n+                Some(from_module_def(db, def.into()))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Enum::from_source(db, src)?;\n+                Some(from_module_def(db, def.into()))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Trait::from_source(db, src)?;\n+                Some(from_module_def(db, def.into()))\n+            },\n+            ast::StaticDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Static::from_source(db, src)?;\n+                Some(from_module_def(db, def.into()))\n             },\n             ast::EnumVariant(it) => {\n-                let src = hir::Source { file_id, ast: it.clone() };\n-                let def: ModuleDef = EnumVariant::from_source(db, src)?.into();\n-                Some(def.definition(db))\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::EnumVariant::from_source(db, src)?;\n+                Some(from_module_def(db, def.into()))\n+            },\n+            ast::FnDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Function::from_source(db, src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(db, def.into()))\n+                } else {\n+                    Some(from_module_def(db, def.into()))\n+                }\n+            },\n+            ast::ConstDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Const::from_source(db, src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(db, def.into()))\n+                } else {\n+                    Some(from_module_def(db, def.into()))\n+                }\n             },\n-            ast::ModuleItem(it) => {\n-                ModuleDef::from_def(db, file_id, it)\n+            ast::TypeAliasDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::TypeAlias::from_source(db, src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(db, def.into()))\n+                } else {\n+                    Some(from_module_def(db, def.into()))\n+                }\n             },\n             _ => None,\n         }\n@@ -52,92 +95,75 @@ pub(crate) fn classify_name_ref(\n     db: &RootDatabase,\n     file_id: FileId,\n     name_ref: &ast::NameRef,\n-) -> Option<Definition> {\n-    let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n+) -> Option<NameDefinition> {\n+    use PathResolution::*;\n+\n     let parent = name_ref.syntax().parent()?;\n-    match_ast! {\n-        match parent {\n-            ast::MethodCallExpr(it) => {\n-                return AssocItem::from_ref(db, &analyzer, it);\n-            },\n-            ast::FieldExpr(it) => {\n-                if let Some(field) = analyzer.resolve_field(&it) {\n-                    return Some(field.definition(db));\n-                }\n-            },\n-            ast::RecordField(it) => {\n-                if let Some(record_lit) = it.syntax().ancestors().find_map(ast::RecordLit::cast) {\n-                    let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n-                    let hir_path = Path::from_name_ref(name_ref);\n-                    let hir_name = hir_path.as_ident()?;\n-                    let field = variant_def.field(db, hir_name)?;\n-                    return Some(field.definition(db));\n-                }\n-            },\n-            _ => (),\n+    let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n+\n+    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+        let func = analyzer.resolve_method_call(&method_call)?;\n+        return Some(from_assoc_item(db, func.into()));\n+    }\n+\n+    if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n+        if let Some(field) = analyzer.resolve_field(&field_expr) {\n+            return Some(from_struct_field(db, field));\n+        }\n+    }\n+\n+    if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n+        if let Some(record_lit) = record_field.syntax().ancestors().find_map(ast::RecordLit::cast) {\n+            let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n+            let hir_path = Path::from_name_ref(name_ref);\n+            let hir_name = hir_path.as_ident()?;\n+            let field = variant_def.field(db, hir_name)?;\n+            return Some(from_struct_field(db, field));\n         }\n     }\n \n     let ast = ModuleSource::from_child_node(db, file_id, &parent);\n     let file_id = file_id.into();\n+    // FIXME: find correct container and visibility for each case\n     let container = Module::from_definition(db, Source { file_id, ast })?;\n     let visibility = None;\n \n     if let Some(macro_call) =\n         parent.parent().and_then(|node| node.parent()).and_then(ast::MacroCall::cast)\n     {\n-        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n-            return Some(Definition { item: NameKind::Macro(mac), container, visibility });\n+        if let Some(macro_def) = analyzer.resolve_macro_call(db, &macro_call) {\n+            return Some(NameDefinition {\n+                item: NameKind::Macro(macro_def),\n+                container,\n+                visibility,\n+            });\n         }\n     }\n \n-    // General case, a path or a local:\n     let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(db, &path)?;\n     match resolved {\n-        PathResolution::Def(def) => Some(def.definition(db)),\n-        PathResolution::LocalBinding(Either::A(pat)) => decl_from_pat(db, file_id, pat),\n-        PathResolution::LocalBinding(Either::B(par)) => {\n-            Some(Definition { item: NameKind::SelfParam(par), container, visibility })\n+        Def(def) => Some(from_module_def(db, def)),\n+        AssocItem(item) => Some(from_assoc_item(db, item)),\n+        LocalBinding(Either::A(pat)) => from_pat(db, file_id, pat),\n+        LocalBinding(Either::B(par)) => {\n+            let item = NameKind::SelfParam(par);\n+            Some(NameDefinition { item, container, visibility })\n         }\n-        PathResolution::GenericParam(par) => {\n+        GenericParam(par) => {\n             // FIXME: get generic param def\n-            Some(Definition { item: NameKind::GenericParam(par), container, visibility })\n+            let item = NameKind::GenericParam(par);\n+            Some(NameDefinition { item, container, visibility })\n         }\n-        PathResolution::Macro(def) => {\n-            Some(Definition { item: NameKind::Macro(def), container, visibility })\n+        Macro(def) => {\n+            let item = NameKind::Macro(def);\n+            Some(NameDefinition { item, container, visibility })\n         }\n-        PathResolution::SelfType(impl_block) => {\n+        SelfType(impl_block) => {\n             let ty = impl_block.target_ty(db);\n+            let item = NameKind::SelfType(ty);\n             let container = impl_block.module();\n-            Some(Definition { item: NameKind::SelfType(ty), container, visibility })\n+            Some(NameDefinition { item, container, visibility })\n         }\n-        PathResolution::AssocItem(assoc) => Some(assoc.definition(db)),\n     }\n }\n-\n-fn decl_from_pat(\n-    db: &RootDatabase,\n-    file_id: HirFileId,\n-    pat: AstPtr<ast::BindPat>,\n-) -> Option<Definition> {\n-    let root = db.parse_or_expand(file_id)?;\n-    // FIXME: use match_ast!\n-    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n-        if let Some(it) = ast::FnDef::cast(node.clone()) {\n-            let src = hir::Source { file_id, ast: it };\n-            Some(hir::Function::from_source(db, src)?.into())\n-        } else if let Some(it) = ast::ConstDef::cast(node.clone()) {\n-            let src = hir::Source { file_id, ast: it };\n-            Some(hir::Const::from_source(db, src)?.into())\n-        } else if let Some(it) = ast::StaticDef::cast(node.clone()) {\n-            let src = hir::Source { file_id, ast: it };\n-            Some(hir::Static::from_source(db, src)?.into())\n-        } else {\n-            None\n-        }\n-    })?;\n-    let item = NameKind::Pat((def, pat));\n-    let container = def.module(db);\n-    Some(Definition { item, container, visibility: None })\n-}"}, {"sha": "65b1f8dd77d38075db3ebc56ea75c51c5ef14c9e", "filename": "crates/ra_ide_api/src/references/definition.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fdefinition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fdefinition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fdefinition.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -1,177 +0,0 @@\n-use hir::{\n-    db::AstDatabase, Adt, AssocItem, DefWithBody, FromSource, HasSource, HirFileId, MacroDef,\n-    Module, ModuleDef, SourceAnalyzer, StructField, Ty, VariantDef,\n-};\n-use ra_syntax::{ast, ast::VisibilityOwner, AstNode, AstPtr};\n-\n-use crate::db::RootDatabase;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum NameKind {\n-    Macro(MacroDef),\n-    FieldAccess(StructField),\n-    AssocItem(AssocItem),\n-    Def(ModuleDef),\n-    SelfType(Ty),\n-    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n-    SelfParam(AstPtr<ast::SelfParam>),\n-    GenericParam(u32),\n-}\n-\n-#[derive(PartialEq, Eq)]\n-pub(crate) struct Definition {\n-    pub visibility: Option<ast::Visibility>,\n-    pub container: Module,\n-    pub item: NameKind,\n-}\n-\n-pub(super) trait HasDefinition {\n-    type Def;\n-    type Ref;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition;\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition>;\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition>;\n-}\n-\n-// fn decl_from_pat(\n-//     db: &RootDatabase,\n-//     file_id: HirFileId,\n-//     pat: AstPtr<ast::BindPat>,\n-// ) -> Option<Definition> {\n-//     let root = db.parse_or_expand(file_id)?;\n-//     // FIXME: use match_ast!\n-//     let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n-//         if let Some(it) = ast::FnDef::cast(node.clone()) {\n-//             let src = hir::Source { file_id, ast: it };\n-//             Some(hir::Function::from_source(db, src)?.into())\n-//         } else if let Some(it) = ast::ConstDef::cast(node.clone()) {\n-//             let src = hir::Source { file_id, ast: it };\n-//             Some(hir::Const::from_source(db, src)?.into())\n-//         } else if let Some(it) = ast::StaticDef::cast(node.clone()) {\n-//             let src = hir::Source { file_id, ast: it };\n-//             Some(hir::Static::from_source(db, src)?.into())\n-//         } else {\n-//             None\n-//         }\n-//     })?;\n-//     let item = NameKind::Pat((def, pat));\n-//     let container = def.module(db);\n-//     Some(Definition { item, container, visibility: None })\n-// }\n-\n-impl HasDefinition for StructField {\n-    type Def = ast::RecordFieldDef;\n-    type Ref = ast::FieldExpr;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition {\n-        let item = NameKind::FieldAccess(self);\n-        let parent = self.parent_def(db);\n-        let container = parent.module(db);\n-        let visibility = match parent {\n-            VariantDef::Struct(s) => s.source(db).ast.visibility(),\n-            VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n-        };\n-        Definition { item, container, visibility }\n-    }\n-\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n-        let src = hir::Source { file_id, ast: hir::FieldSource::Named(def) };\n-        let field = StructField::from_source(db, src)?;\n-        Some(field.definition(db))\n-    }\n-\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition> {\n-        let field = analyzer.resolve_field(&refer)?;\n-        Some(field.definition(db))\n-    }\n-}\n-\n-impl HasDefinition for AssocItem {\n-    type Def = ast::ImplItem;\n-    type Ref = ast::MethodCallExpr;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition {\n-        let item = NameKind::AssocItem(self);\n-        let container = self.module(db);\n-        let visibility = match self {\n-            AssocItem::Function(f) => f.source(db).ast.visibility(),\n-            AssocItem::Const(c) => c.source(db).ast.visibility(),\n-            AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n-        };\n-        Definition { item, container, visibility }\n-    }\n-\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n-        if def.syntax().parent().and_then(ast::ItemList::cast).is_none() {\n-            return None;\n-        }\n-        let src = hir::Source { file_id, ast: def };\n-        let item = AssocItem::from_source(db, src)?;\n-        Some(item.definition(db))\n-    }\n-\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition> {\n-        let func: AssocItem = analyzer.resolve_method_call(&refer)?.into();\n-        Some(func.definition(db))\n-    }\n-}\n-\n-impl HasDefinition for ModuleDef {\n-    type Def = ast::ModuleItem;\n-    type Ref = ast::Path;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition {\n-        let (container, visibility) = match self {\n-            ModuleDef::Module(it) => {\n-                let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-                let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n-                (container, visibility)\n-            }\n-            ModuleDef::EnumVariant(it) => {\n-                let container = it.module(db);\n-                let visibility = it.source(db).ast.parent_enum().visibility();\n-                (container, visibility)\n-            }\n-            ModuleDef::Function(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Const(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Static(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Trait(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::BuiltinType(..) => unreachable!(),\n-        };\n-        let item = NameKind::Def(self);\n-        Definition { item, container, visibility }\n-    }\n-\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n-        let src = hir::Source { file_id, ast: def };\n-        let def = ModuleDef::from_source(db, src)?;\n-        Some(def.definition(db))\n-    }\n-\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition> {\n-        None\n-    }\n-}\n-\n-// FIXME: impl HasDefinition for hir::MacroDef"}, {"sha": "19702eba0509f2ffccdf06a20a24dc1be83e9e82", "filename": "crates/ra_ide_api/src/references/name_definition.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -0,0 +1,104 @@\n+use hir::{\n+    db::AstDatabase, Adt, AssocItem, DefWithBody, FromSource, HasSource, HirFileId, MacroDef,\n+    Module, ModuleDef, StructField, Ty, VariantDef,\n+};\n+use ra_syntax::{ast, ast::VisibilityOwner, match_ast, AstNode, AstPtr};\n+\n+use crate::db::RootDatabase;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum NameKind {\n+    Macro(MacroDef),\n+    Field(StructField),\n+    AssocItem(AssocItem),\n+    Def(ModuleDef),\n+    SelfType(Ty),\n+    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n+    SelfParam(AstPtr<ast::SelfParam>),\n+    GenericParam(u32),\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct NameDefinition {\n+    pub visibility: Option<ast::Visibility>,\n+    pub container: Module,\n+    pub item: NameKind,\n+}\n+\n+pub(super) fn from_pat(\n+    db: &RootDatabase,\n+    file_id: HirFileId,\n+    pat: AstPtr<ast::BindPat>,\n+) -> Option<NameDefinition> {\n+    let root = db.parse_or_expand(file_id)?;\n+    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n+        match_ast! {\n+            match node {\n+                ast::FnDef(it) => {\n+                    let src = hir::Source { file_id, ast: it };\n+                    Some(hir::Function::from_source(db, src)?.into())\n+                },\n+                ast::ConstDef(it) => {\n+                    let src = hir::Source { file_id, ast: it };\n+                    Some(hir::Const::from_source(db, src)?.into())\n+                },\n+                ast::StaticDef(it) => {\n+                    let src = hir::Source { file_id, ast: it };\n+                    Some(hir::Static::from_source(db, src)?.into())\n+                },\n+                _ => None,\n+            }\n+        }\n+    })?;\n+    let item = NameKind::Pat((def, pat));\n+    let container = def.module(db);\n+    Some(NameDefinition { item, container, visibility: None })\n+}\n+\n+pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n+    let container = item.module(db);\n+    let visibility = match item {\n+        AssocItem::Function(f) => f.source(db).ast.visibility(),\n+        AssocItem::Const(c) => c.source(db).ast.visibility(),\n+        AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n+    };\n+    let item = NameKind::AssocItem(item);\n+    NameDefinition { item, container, visibility }\n+}\n+\n+pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n+    let item = NameKind::Field(field);\n+    let parent = field.parent_def(db);\n+    let container = parent.module(db);\n+    let visibility = match parent {\n+        VariantDef::Struct(s) => s.source(db).ast.visibility(),\n+        VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n+    };\n+    NameDefinition { item, container, visibility }\n+}\n+\n+pub(super) fn from_module_def(db: &RootDatabase, def: ModuleDef) -> NameDefinition {\n+    let item = NameKind::Def(def);\n+    let (container, visibility) = match def {\n+        ModuleDef::Module(it) => {\n+            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n+            let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n+            (container, visibility)\n+        }\n+        ModuleDef::EnumVariant(it) => {\n+            let container = it.module(db);\n+            let visibility = it.source(db).ast.parent_enum().visibility();\n+            (container, visibility)\n+        }\n+        ModuleDef::Function(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Const(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Static(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Trait(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::BuiltinType(..) => unreachable!(),\n+    };\n+    NameDefinition { item, container, visibility }\n+}"}, {"sha": "346815d31229aca15bc057a3c0c547acb1d4883e", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -4,13 +4,13 @@ use ra_syntax::{AstNode, TextRange};\n \n use crate::db::RootDatabase;\n \n-use super::{Definition, NameKind};\n+use super::{NameDefinition, NameKind};\n \n pub(crate) struct SearchScope {\n     pub scope: Vec<(FileId, Option<TextRange>)>,\n }\n \n-impl Definition {\n+impl NameDefinition {\n     pub fn scope(&self, db: &RootDatabase) -> SearchScope {\n         let module_src = self.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);"}, {"sha": "a27d9f3672391c22b76704098b1310a659c73d84", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835173d065dbe1fdd7369ea49336c0b785be8cb8/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=835173d065dbe1fdd7369ea49336c0b785be8cb8", "patch": "@@ -105,7 +105,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                         classify_name_ref(db, file_id, &name_ref).and_then(|d| Some(d.item));\n                     match name_kind {\n                         Some(Macro(_)) => \"macro\",\n-                        Some(FieldAccess(_)) => \"field\",\n+                        Some(Field(_)) => \"field\",\n                         Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n                         Some(AssocItem(hir::AssocItem::Const(_))) => \"constant\",\n                         Some(AssocItem(hir::AssocItem::TypeAlias(_))) => \"type\","}]}