{"sha": "d7a62124018ce8438caeedca203d39997f130b49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YTYyMTI0MDE4Y2U4NDM4Y2FlZWRjYTIwM2QzOTk5N2YxMzBiNDk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-15T19:14:05Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-16T17:49:14Z"}, "message": "review comments", "tree": {"sha": "1bbf6438d05290a84c4b8114fb99175edbc6eaf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bbf6438d05290a84c4b8114fb99175edbc6eaf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7a62124018ce8438caeedca203d39997f130b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a62124018ce8438caeedca203d39997f130b49", "html_url": "https://github.com/rust-lang/rust/commit/d7a62124018ce8438caeedca203d39997f130b49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7a62124018ce8438caeedca203d39997f130b49/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c305ac31c09fdd5078fa0e69e718b4da10d9e354", "url": "https://api.github.com/repos/rust-lang/rust/commits/c305ac31c09fdd5078fa0e69e718b4da10d9e354", "html_url": "https://github.com/rust-lang/rust/commit/c305ac31c09fdd5078fa0e69e718b4da10d9e354"}], "stats": {"total": 420, "additions": 204, "deletions": 216}, "files": [{"sha": "db3173989ac605e114159989fa5665110fc972c2", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -25,7 +25,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::Visitor;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n@@ -1411,34 +1410,3 @@ pub fn suggest_constraining_type_param(\n     }\n     false\n }\n-\n-/// Collect all the returned expressions within the input expression.\n-/// Used to point at the return spans when we want to suggest some change to them.\n-struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n-\n-impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n-    type Map = rustc::hir::map::Map<'v>;\n-\n-    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<'_, Self::Map> {\n-        hir::intravisit::NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-        match ex.kind {\n-            hir::ExprKind::Ret(Some(ex)) => self.0.push(ex),\n-            _ => {}\n-        }\n-        hir::intravisit::walk_expr(self, ex);\n-    }\n-\n-    fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n-        if body.generator_kind().is_none() {\n-            if let hir::ExprKind::Block(block, None) = body.value.kind {\n-                if let Some(expr) = block.expr {\n-                    self.0.push(expr);\n-                }\n-            }\n-        }\n-        hir::intravisit::walk_body(self, body);\n-    }\n-}"}, {"sha": "7c1b1041c34c381e2e7d27de85359bde3a903d16", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 137, "deletions": 133, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -563,157 +563,159 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n-        if let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, body_id), ..\n+        let (sig, body_id) = if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id),\n+            ..\n         })) = node\n         {\n-            let body = hir.body(*body_id);\n-            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n-            let ty = trait_ref.skip_binder().self_ty();\n-            let is_object_safe;\n-            match ty.kind {\n-                ty::Dynamic(predicates, _) => {\n-                    // The `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n-                    is_object_safe = predicates.principal_def_id().map_or(true, |def_id| {\n-                        !object_safety_violations(self.tcx, def_id).is_empty()\n-                    })\n-                }\n-                // We only want to suggest `impl Trait` to `dyn Trait`s.\n-                // For example, `fn foo() -> str` needs to be filtered out.\n-                _ => return false,\n+            (sig, body_id)\n+        } else {\n+            return false;\n+        };\n+        let body = hir.body(*body_id);\n+        let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+        let ty = trait_ref.skip_binder().self_ty();\n+        let is_object_safe = match ty.kind {\n+            ty::Dynamic(predicates, _) => {\n+                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n+                predicates\n+                    .principal_def_id()\n+                    .map_or(true, |def_id| object_safety_violations(self.tcx, def_id).is_empty())\n             }\n+            // We only want to suggest `impl Trait` to `dyn Trait`s.\n+            // For example, `fn foo() -> str` needs to be filtered out.\n+            _ => return false,\n+        };\n \n-            let ret_ty = if let hir::FunctionRetTy::Return(ret_ty) = sig.decl.output {\n-                ret_ty\n-            } else {\n-                return false;\n-            };\n-\n-            // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n-            // cases like `fn foo() -> (dyn Trait, i32) {}`.\n-            // Recursively look for `TraitObject` types and if there's only one, use that span to\n-            // suggest `impl Trait`.\n-\n-            // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n-            // otherwise suggest using `Box<dyn Trait>` or an enum.\n-            let mut visitor = ReturnsVisitor(vec![]);\n-            visitor.visit_body(&body);\n-\n-            let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+        let ret_ty = if let hir::FunctionRetTy::Return(ret_ty) = sig.decl.output {\n+            ret_ty\n+        } else {\n+            return false;\n+        };\n \n-            let mut all_returns_conform_to_trait = true;\n-            let mut all_returns_have_same_type = true;\n-            let mut last_ty = None;\n-            if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n-                let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n-                let param_env = ty::ParamEnv::empty();\n-                if let ty::Dynamic(predicates, _) = &ty_ret_ty.kind {\n-                    for expr in &visitor.0 {\n-                        if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n-                            all_returns_have_same_type &=\n-                                Some(returned_ty) == last_ty || last_ty.is_none();\n-                            last_ty = Some(returned_ty);\n-                            for predicate in predicates.iter() {\n-                                let pred = predicate.with_self_ty(self.tcx, returned_ty);\n-                                let obl = Obligation::new(cause.clone(), param_env, pred);\n-                                all_returns_conform_to_trait &= self.predicate_may_hold(&obl);\n-                            }\n+        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n+        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n+        // Recursively look for `TraitObject` types and if there's only one, use that span to\n+        // suggest `impl Trait`.\n+\n+        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n+        // otherwise suggest using `Box<dyn Trait>` or an enum.\n+        let mut visitor = ReturnsVisitor(vec![]);\n+        visitor.visit_body(&body);\n+\n+        let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+\n+        let mut all_returns_conform_to_trait = true;\n+        let mut all_returns_have_same_type = true;\n+        let mut last_ty = None;\n+        if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n+            let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n+            let param_env = ty::ParamEnv::empty();\n+            if let ty::Dynamic(predicates, _) = &ty_ret_ty.kind {\n+                for expr in &visitor.0 {\n+                    if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n+                        all_returns_have_same_type &=\n+                            Some(returned_ty) == last_ty || last_ty.is_none();\n+                        last_ty = Some(returned_ty);\n+                        for predicate in predicates.iter() {\n+                            let pred = predicate.with_self_ty(self.tcx, returned_ty);\n+                            let obl = Obligation::new(cause.clone(), param_env, pred);\n+                            all_returns_conform_to_trait &= self.predicate_may_hold(&obl);\n                         }\n                     }\n                 }\n-            } else {\n-                // We still want to verify whether all the return types conform to each other.\n-                for expr in &visitor.0 {\n-                    let returned_ty = tables.node_type_opt(expr.hir_id);\n-                    all_returns_have_same_type &= last_ty == returned_ty || last_ty.is_none();\n-                    last_ty = returned_ty;\n-                }\n             }\n+        } else {\n+            // We still want to verify whether all the return types conform to each other.\n+            for expr in &visitor.0 {\n+                let returned_ty = tables.node_type_opt(expr.hir_id);\n+                all_returns_have_same_type &= last_ty == returned_ty || last_ty.is_none();\n+                last_ty = returned_ty;\n+            }\n+        }\n \n-            let (snippet, last_ty) =\n-                if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n-                    // Verify that we're dealing with a return `dyn Trait`\n-                    ret_ty.span.overlaps(span),\n-                    &ret_ty.kind,\n-                    self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n-                    // If any of the return types does not conform to the trait, then we can't\n-                    // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n-                    all_returns_conform_to_trait,\n-                    last_ty,\n-                ) {\n-                    (snippet, last_ty)\n-                } else {\n-                    return false;\n-                };\n-            err.code(error_code!(E0746));\n-            err.set_primary_message(\"return type cannot have an unboxed trait object\");\n-            err.children.clear();\n-            let impl_trait_msg = \"for information on `impl Trait`, see \\\n-                <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                #returning-types-that-implement-traits>\";\n-            let trait_obj_msg = \"for information on trait objects, see \\\n-                <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n-                #using-trait-objects-that-allow-for-values-of-different-types>\";\n-            let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n-            let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n-            if all_returns_have_same_type {\n-                // Suggest `-> impl Trait`.\n-                err.span_suggestion(\n+        let (snippet, last_ty) =\n+            if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n+                // Verify that we're dealing with a return `dyn Trait`\n+                ret_ty.span.overlaps(span),\n+                &ret_ty.kind,\n+                self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n+                // If any of the return types does not conform to the trait, then we can't\n+                // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n+                all_returns_conform_to_trait,\n+                last_ty,\n+            ) {\n+                (snippet, last_ty)\n+            } else {\n+                return false;\n+            };\n+        err.code(error_code!(E0746));\n+        err.set_primary_message(\"return type cannot have an unboxed trait object\");\n+        err.children.clear();\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+            #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+            #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n+        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n+        if all_returns_have_same_type {\n+            // Suggest `-> impl Trait`.\n+            err.span_suggestion(\n+                ret_ty.span,\n+                &format!(\n+                    \"return `impl {1}` instead, as all return paths are of type `{}`, \\\n+                        which implements `{1}`\",\n+                    last_ty, trait_obj,\n+                ),\n+                format!(\"impl {}\", trait_obj),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(impl_trait_msg);\n+        } else {\n+            if is_object_safe {\n+                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n+                // Get all the return values and collect their span and suggestion.\n+                let mut suggestions = visitor\n+                    .0\n+                    .iter()\n+                    .map(|expr| {\n+                        (\n+                            expr.span,\n+                            format!(\n+                                \"Box::new({})\",\n+                                self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n+                            ),\n+                        )\n+                    })\n+                    .collect::<Vec<_>>();\n+                // Add the suggestion for the return type.\n+                suggestions.push((\n                     ret_ty.span,\n-                    &format!(\n-                        \"return `impl {1}` instead, as all return paths are of type `{}`, \\\n-                         which implements `{1}`\",\n-                        last_ty, trait_obj,\n-                    ),\n-                    format!(\"impl {}\", trait_obj),\n-                    Applicability::MachineApplicable,\n+                    format!(\"Box<{}{}>\", if has_dyn { \"\" } else { \"dyn \" }, snippet),\n+                ));\n+                err.multipart_suggestion(\n+                        \"return a trait object instead\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n                 );\n-                err.note(impl_trait_msg);\n             } else {\n-                if is_object_safe {\n-                    // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n-                    // Get all the return values and collect their span and suggestion.\n-                    let mut suggestions = visitor\n-                        .0\n-                        .iter()\n-                        .map(|expr| {\n-                            (\n-                                expr.span,\n-                                format!(\n-                                    \"Box::new({})\",\n-                                    self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n-                                ),\n-                            )\n-                        })\n-                        .collect::<Vec<_>>();\n-                    // Add the suggestion for the return type.\n-                    suggestions.push((\n-                        ret_ty.span,\n-                        format!(\"Box<{}{}>\", if has_dyn { \"\" } else { \"dyn \" }, snippet),\n-                    ));\n-                    err.multipart_suggestion(\n-                        \"return a trait object instead\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    err.note(&format!(\n-                        \"if trait `{}` was object safe, you could return a trait object\",\n-                        trait_obj,\n-                    ));\n-                }\n                 err.note(&format!(\n-                    \"if all the returned values were of the same type you could use \\\n-                     `impl {}` as the return type\",\n+                    \"if trait `{}` was object safe, you could return a trait object\",\n                     trait_obj,\n                 ));\n-                err.note(impl_trait_msg);\n-                err.note(trait_obj_msg);\n-                err.note(\"you can create a new `enum` with a variant for each returned type\");\n             }\n-            return true;\n+            err.note(trait_obj_msg);\n+            err.note(&format!(\n+                \"if all the returned values were of the same type you could use \\\n+                    `impl {}` as the return type\",\n+                trait_obj,\n+            ));\n+            err.note(impl_trait_msg);\n+            err.note(\"you can create a new `enum` with a variant for each returned type\");\n         }\n-        false\n+        true\n     }\n \n     crate fn point_at_returns_when_relevant(\n@@ -1686,6 +1688,8 @@ pub fn suggest_constraining_type_param(\n     false\n }\n \n+/// Collect all the returned expressions within the input expression.\n+/// Used to point at the return spans when we want to suggest some change to them.\n struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n \n impl<'v> Visitor<'v> for ReturnsVisitor<'v> {"}, {"sha": "2e5da2b038254f7ab45131821d959b34b13d29c0", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -1171,7 +1171,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-impl<'tcx> ObligationCauseCode<'tcx> {\n+impl ObligationCauseCode<'_> {\n     // Return the base obligation, ignoring derived obligations.\n     pub fn peel_derives(&self) -> &Self {\n         let mut base_cause = self;"}, {"sha": "041061f3380c12064f515fbd1359f7d6e86c31b5", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -12,8 +12,8 @@ impl T for S {\n     fn bar(&self) {}\n }\n \n-// Having the trait `T` as return type is invalid because bare traits do not\n-// have a statically known size:\n+// Having the trait `T` as return type is invalid because\n+// bare trait objects do not have a statically known size:\n fn foo() -> dyn T {\n     S(42)\n }\n@@ -32,15 +32,15 @@ If there is a single type involved, you can use [`impl Trait`]:\n #     fn bar(&self) {}\n # }\n // The compiler will select `S(usize)` as the materialized return type of this\n-// function, but callers will only be able to access associated items from `T`.\n+// function, but callers will only know that the return type implements `T`.\n fn foo() -> impl T {\n     S(42)\n }\n ```\n \n If there are multiple types involved, the only way you care to interact with\n-them is through the trait's interface and having to rely on dynamic dispatch is\n-acceptable, then you can use [trait objects] with `Box`, or other container\n+them is through the trait's interface, and having to rely on dynamic dispatch\n+is acceptable, then you can use [trait objects] with `Box`, or other container\n types like `Rc` or `Arc`:\n \n ```"}, {"sha": "768e532fa3b91d81d704b6503d5f75a80169bc23", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -68,7 +68,7 @@ use rustc_error_codes::*;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span;\n+use rustc_span::{self, Span};\n use rustc_span::symbol::sym;\n use rustc_target::spec::abi::Abi;\n use smallvec::{smallvec, SmallVec};\n@@ -1352,39 +1352,48 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             }\n         }\n         if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n-            err.span_label(return_sp, \"expected because this return type...\");\n-            err.span_label( *sp, format!(\n-                \"...is found to be `{}` here\",\n-                fcx.resolve_vars_with_obligations(expected),\n-            ));\n-            err.note(\"to return `impl Trait`, all returned values must be of the same type\");\n-            let snippet = fcx\n-                .tcx\n-                .sess\n-                .source_map()\n-                .span_to_snippet(return_sp)\n-                .unwrap_or_else(|_| \"dyn Trait\".to_string());\n-            let mut snippet_iter = snippet.split_whitespace();\n-            let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n-            if has_impl {\n-                err.help(&format!(\n-                    \"you can instead return a trait object using `Box<dyn {}>`\",\n-                    &snippet[5..]\n-                ));\n-            }\n-            err.help(\"alternatively, create a new `enum` with a variant for each returned type\");\n-            let impl_trait_msg = \"for information on `impl Trait`, see \\\n+            self.add_impl_trait_explanation(&mut err, fcx, expected, *sp, return_sp);\n+        }\n+        err\n+    }\n+\n+    fn add_impl_trait_explanation<'a>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        expected: Ty<'tcx>,\n+        sp: Span,\n+        return_sp: Span,\n+    ) {\n+        err.span_label(return_sp, \"expected because this return type...\");\n+        err.span_label(\n+            sp,\n+            format!(\"...is found to be `{}` here\", fcx.resolve_vars_with_obligations(expected)),\n+        );\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n                 <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n                 #returning-types-that-implement-traits>\";\n-            let trait_obj_msg = \"for information on trait objects, see \\\n+        let trait_obj_msg = \"for information on trait objects, see \\\n                 <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n                 #using-trait-objects-that-allow-for-values-of-different-types>\";\n-            err.note(impl_trait_msg);\n-            if has_impl {\n-                err.note(trait_obj_msg);\n-            }\n+        err.note(\"to return `impl Trait`, all returned values must be of the same type\");\n+        err.note(impl_trait_msg);\n+        let snippet = fcx\n+            .tcx\n+            .sess\n+            .source_map()\n+            .span_to_snippet(return_sp)\n+            .unwrap_or_else(|_| \"dyn Trait\".to_string());\n+        let mut snippet_iter = snippet.split_whitespace();\n+        let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n+        if has_impl {\n+            err.help(&format!(\n+                \"you can instead return a trait object using `Box<dyn {}>`\",\n+                &snippet[5..]\n+            ));\n+            err.note(trait_obj_msg);\n         }\n-        err\n+        err.help(\"alternatively, create a new `enum` with a variant for each returned type\");\n     }\n \n     fn is_return_ty_unsized(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {"}, {"sha": "ac101f8f3ce36dd0f26ad4e1f6fc46b50fca45bd", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -82,11 +82,18 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bal() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: if trait `Trait` was object safe, you could return a trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n    = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n    = note: you can create a new `enum` with a variant for each returned type\n+help: return a trait object instead\n+   |\n+LL | fn bal() -> Box<dyn Trait> {\n+LL |     if true {\n+LL |         return Box::new(Struct);\n+LL |     }\n+LL |     Box::new(42)\n+   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:27:13"}, {"sha": "a399fadbc5db5bf43c72d734c6dd41c5afe0a930", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -11,10 +11,10 @@ LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn Foo>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn Foo>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11"}, {"sha": "9859c73b7b18b58d5e0d5712124c8746bb18e76e", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7a62124018ce8438caeedca203d39997f130b49/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7a62124018ce8438caeedca203d39997f130b49/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=d7a62124018ce8438caeedca203d39997f130b49", "patch": "@@ -11,10 +11,10 @@ LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n@@ -29,10 +29,10 @@ LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:22:9\n@@ -47,10 +47,10 @@ LL |         1u32\n    |         ^^^^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:31:9\n@@ -77,10 +77,10 @@ LL |         _ => 1u32,\n    |              ^^^^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:45:5\n@@ -97,10 +97,10 @@ LL | |     }\n    | |_____^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:59:13\n@@ -115,10 +115,10 @@ LL |             1u32\n    |             ^^^^ expected `i32`, found `u32`\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n-   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error: aborting due to 7 previous errors\n "}]}