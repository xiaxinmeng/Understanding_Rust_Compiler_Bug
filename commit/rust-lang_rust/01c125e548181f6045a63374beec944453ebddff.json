{"sha": "01c125e548181f6045a63374beec944453ebddff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYzEyNWU1NDgxODFmNjA0NWE2MzM3NGJlZWM5NDQ0NTNlYmRkZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2015-03-19T00:36:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2015-03-19T05:05:19Z"}, "message": "libunicode: Partially inline the fast paths in character class checking.", "tree": {"sha": "c6bc24aa86d95668f4545769bdef41506b8ce4bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6bc24aa86d95668f4545769bdef41506b8ce4bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01c125e548181f6045a63374beec944453ebddff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01c125e548181f6045a63374beec944453ebddff", "html_url": "https://github.com/rust-lang/rust/commit/01c125e548181f6045a63374beec944453ebddff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01c125e548181f6045a63374beec944453ebddff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbd16a5b475606f1131cd41529be830ee89e7221", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd16a5b475606f1131cd41529be830ee89e7221", "html_url": "https://github.com/rust-lang/rust/commit/dbd16a5b475606f1131cd41529be830ee89e7221"}], "stats": {"total": 432, "additions": 432, "deletions": 0}, "files": [{"sha": "e24ade58a5224e36f33d440f00d19038b6ad1020", "filename": "src/libunicode/char.rs", "status": "modified", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/01c125e548181f6045a63374beec944453ebddff/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c125e548181f6045a63374beec944453ebddff/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=01c125e548181f6045a63374beec944453ebddff", "patch": "@@ -41,6 +41,426 @@ pub use normalize::{decompose_canonical, decompose_compatible, compose};\n pub use tables::normalization::canonical_combining_class;\n pub use tables::UNICODE_VERSION;\n \n+#[cfg(stage0)]\n+/// Functionality for manipulating `char`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CharExt {\n+    /// Checks if a `char` parses as a numeric digit in the given radix.\n+    ///\n+    /// Compared to `is_numeric()`, this function only recognizes the characters\n+    /// `0-9`, `a-z` and `A-Z`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+    /// otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix > 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert!(c.is_digit(10));\n+    ///\n+    /// assert!('f'.is_digit(16));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_digit(self, radix: u32) -> bool;\n+\n+    /// Converts a character to the corresponding digit.\n+    ///\n+    /// # Return value\n+    ///\n+    /// If `c` is between '0' and '9', the corresponding value between 0 and\n+    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n+    /// none if the character does not refer to a digit in the given radix.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix outside the range [0..36].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert_eq!(c.to_digit(10), Some(1));\n+    ///\n+    /// assert_eq!('f'.to_digit(16), Some(15));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n+\n+    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n+    /// character, as `char`s.\n+    ///\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n+    /// where `NNNN` is the shortest hexadecimal representation of the code\n+    /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\u2764'.escape_unicode() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// u\n+    /// {\n+    /// 2\n+    /// 7\n+    /// 6\n+    /// 4\n+    /// }\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    ///\n+    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn escape_unicode(self) -> EscapeUnicode;\n+\n+    /// Returns an iterator that yields the 'default' ASCII and\n+    /// C++11-like literal escape of a character, as `char`s.\n+    ///\n+    /// The default is chosen with a bias toward producing literals that are\n+    /// legal in a variety of languages, including C++11 and similar C-family\n+    /// languages. The exact rules are:\n+    ///\n+    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+    /// * Single-quote, double-quote and backslash chars are backslash-\n+    ///   escaped.\n+    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n+    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\"'.escape_default() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// \"\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let quote: String = '\"'.escape_default().collect();\n+    ///\n+    /// assert_eq!(quote, \"\\\\\\\"\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn escape_default(self) -> EscapeDefault;\n+\n+    /// Returns the number of bytes this character would need if encoded in\n+    /// UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf8();\n+    ///\n+    /// assert_eq!(n, 2);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn len_utf8(self) -> usize;\n+\n+    /// Returns the number of 16-bit code units this character would need if\n+    /// encoded in UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf16();\n+    ///\n+    /// assert_eq!(n, 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn len_utf16(self) -> usize;\n+\n+    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n+    /// returns the number of bytes written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length four is large enough to\n+    /// encode any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 2];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(2));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n+\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n+    /// then returns the number of `u16`s written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length 2 is large enough to encode\n+    /// any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes one `u16` to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(1));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 0];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n+\n+    /// Returns whether the specified character is considered a Unicode\n+    /// alphabetic code point.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_alphabetic(self) -> bool;\n+\n+    /// Returns whether the specified character satisfies the 'XID_Start'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"mainly needed for compiler internals\")]\n+    fn is_xid_start(self) -> bool;\n+\n+    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"mainly needed for compiler internals\")]\n+    fn is_xid_continue(self) -> bool;\n+\n+    /// Indicates whether a character is in lowercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Lowercase`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_lowercase(self) -> bool;\n+\n+    /// Indicates whether a character is in uppercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Uppercase`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_uppercase(self) -> bool;\n+\n+    /// Indicates whether a character is whitespace.\n+    ///\n+    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_whitespace(self) -> bool;\n+\n+    /// Indicates whether a character is alphanumeric.\n+    ///\n+    /// Alphanumericness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_alphanumeric(self) -> bool;\n+\n+    /// Indicates whether a character is a control code point.\n+    ///\n+    /// Control code points are defined in terms of the Unicode General\n+    /// Category `Cc`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_control(self) -> bool;\n+\n+    /// Indicates whether the character is numeric (Nd, Nl, or No).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_numeric(self) -> bool;\n+\n+    /// Converts a character to its lowercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping. See\n+    /// `to_uppercase()` for references and more information.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// lowercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_lowercase(self) -> ToLowercase;\n+\n+    /// Converts a character to its uppercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping: it maps\n+    /// one Unicode codepoint to its uppercase equivalent according to the\n+    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n+    /// considered here, but the iterator returned will soon support this form\n+    /// of case folding.\n+    ///\n+    /// A full reference can be found here [2].\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// uppercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    ///\n+    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    ///\n+    /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    ///\n+    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_uppercase(self) -> ToUppercase;\n+\n+    /// Returns this character's displayed width in columns, or `None` if it is a\n+    /// control character other than `'\\x00'`.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n+    fn width(self, is_cjk: bool) -> Option<usize>;\n+}\n+\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CharExt for char {\n+    #[inline]\n+    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n+    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n+    fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n+    fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n+    fn len_utf8(self) -> usize { C::len_utf8(self) }\n+    fn len_utf16(self) -> usize { C::len_utf16(self) }\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n+\n+    #[inline]\n+    fn is_alphabetic(self) -> bool {\n+        match self {\n+            'a' ... 'z' | 'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Alphabetic(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n+\n+    #[inline]\n+    fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n+\n+    #[inline]\n+    fn is_lowercase(self) -> bool {\n+        match self {\n+            'a' ... 'z' => true,\n+            c if c > '\\x7f' => derived_property::Lowercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_uppercase(self) -> bool {\n+        match self {\n+            'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Uppercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(self) -> bool {\n+        match self {\n+            ' ' | '\\x09' ... '\\x0d' => true,\n+            c if c > '\\x7f' => property::White_Space(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_alphanumeric(self) -> bool {\n+        self.is_alphabetic() || self.is_numeric()\n+    }\n+\n+    #[inline]\n+    fn is_control(self) -> bool { general_category::Cc(self) }\n+\n+    #[inline]\n+    fn is_numeric(self) -> bool {\n+        match self {\n+            '0' ... '9' => true,\n+            c if c > '\\x7f' => general_category::N(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn to_lowercase(self) -> ToLowercase {\n+        ToLowercase(Some(conversions::to_lower(self)))\n+    }\n+\n+    #[inline]\n+    fn to_uppercase(self) -> ToUppercase {\n+        ToUppercase(Some(conversions::to_upper(self)))\n+    }\n+\n+    #[inline]\n+    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n+}\n+\n /// An iterator over the lowercase mapping of a given character, returned from\n /// the `lowercase` method on characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -90,6 +510,7 @@ impl char {\n     /// assert!('f'.is_digit(16));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n \n     /// Converts a character to the corresponding digit.\n@@ -285,6 +706,7 @@ impl char {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_alphabetic(self) -> bool {\n         match self {\n             'a' ... 'z' | 'A' ... 'Z' => true,\n@@ -301,6 +723,7 @@ impl char {\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n     #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n+    #[inline]\n     pub fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n@@ -311,13 +734,15 @@ impl char {\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n     #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n+    #[inline]\n     pub fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n     /// Indicates whether a character is in lowercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_lowercase(self) -> bool {\n         match self {\n             'a' ... 'z' => true,\n@@ -331,6 +756,7 @@ impl char {\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_uppercase(self) -> bool {\n         match self {\n             'A' ... 'Z' => true,\n@@ -343,6 +769,7 @@ impl char {\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09' ... '\\x0d' => true,\n@@ -356,6 +783,7 @@ impl char {\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_alphanumeric(self) -> bool {\n         self.is_alphabetic() || self.is_numeric()\n     }\n@@ -365,10 +793,12 @@ impl char {\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_control(self) -> bool { general_category::Cc(self) }\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_numeric(self) -> bool {\n         match self {\n             '0' ... '9' => true,\n@@ -388,6 +818,7 @@ impl char {\n     /// lowercase equivalent of the character. If no conversion is possible then\n     /// the input character is returned.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n         ToLowercase(Some(conversions::to_lower(self)))\n     }\n@@ -414,6 +845,7 @@ impl char {\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_uppercase(self) -> ToUppercase {\n         ToUppercase(Some(conversions::to_upper(self)))\n     }"}]}