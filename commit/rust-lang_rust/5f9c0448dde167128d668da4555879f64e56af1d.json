{"sha": "5f9c0448dde167128d668da4555879f64e56af1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmOWMwNDQ4ZGRlMTY3MTI4ZDY2OGRhNDU1NTg3OWY2NGU1NmFmMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-25T18:35:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-25T18:35:41Z"}, "message": "Auto merge of #62119 - Centril:rollup-el20wu0, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #61814 (Fix an ICE with uninhabited consts)\n - #61987 (rustc: produce AST instead of HIR from `hir::lowering::Resolver` methods.)\n - #62055 (Fix error counting)\n - #62078 (Remove built-in derive macros `Send` and `Sync`)\n - #62085 (Add test for issue-38591)\n - #62091 (HirIdification: almost there)\n - #62096 (Implement From<Local> for Place and PlaceBase)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6e99033118ee25fc4064c4b2968f43132ac8f67e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e99033118ee25fc4064c4b2968f43132ac8f67e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f9c0448dde167128d668da4555879f64e56af1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9c0448dde167128d668da4555879f64e56af1d", "html_url": "https://github.com/rust-lang/rust/commit/5f9c0448dde167128d668da4555879f64e56af1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f9c0448dde167128d668da4555879f64e56af1d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303f77ee1d60e1b351ff6478143dd866403c27f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/303f77ee1d60e1b351ff6478143dd866403c27f5", "html_url": "https://github.com/rust-lang/rust/commit/303f77ee1d60e1b351ff6478143dd866403c27f5"}, {"sha": "d406d89b3182f05629dd949932bc10a9db28140e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d406d89b3182f05629dd949932bc10a9db28140e", "html_url": "https://github.com/rust-lang/rust/commit/d406d89b3182f05629dd949932bc10a9db28140e"}], "stats": {"total": 819, "additions": 463, "deletions": 356}, "files": [{"sha": "1b8e2999afe6ae3060a669bafcd482d51cbca856", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -148,11 +148,11 @@ pub struct LoweringContext<'a> {\n \n pub trait Resolver {\n     /// Resolve a path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_hir_path(\n+    fn resolve_ast_path(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n-    ) -> hir::Path;\n+    ) -> Res<NodeId>;\n \n     /// Obtain resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n@@ -167,15 +167,15 @@ pub trait Resolver {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n-    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates a HIR path for `[::crate_root]::b::c::d` and\n+    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates an AST path for `[::crate_root]::b::c::d` and\n     /// resolves it based on `is_value`.\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n         is_value: bool,\n-    ) -> hir::Path;\n+    ) -> (ast::Path, Res<NodeId>);\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -5546,16 +5546,26 @@ impl<'a> LoweringContext<'a> {\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n-        let mut path = self.resolver\n+        let (path, res) = self.resolver\n             .resolve_str_path(span, self.crate_root, components, is_value);\n-        path.segments.last_mut().unwrap().args = params;\n \n-        for seg in path.segments.iter_mut() {\n-            if seg.hir_id.is_some() {\n-                seg.hir_id = Some(self.next_id());\n+        let mut segments: Vec<_> = path.segments.iter().map(|segment| {\n+            let res = self.expect_full_res(segment.id);\n+            hir::PathSegment {\n+                ident: segment.ident,\n+                hir_id: Some(self.lower_node_id(segment.id)),\n+                res: Some(self.lower_res(res)),\n+                infer_args: true,\n+                args: None,\n             }\n+        }).collect();\n+        segments.last_mut().unwrap().args = params;\n+\n+        hir::Path {\n+            span,\n+            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n+            segments: segments.into(),\n         }\n-        path\n     }\n \n     fn ty_path(&mut self, mut hir_id: hir::HirId, span: Span, qpath: hir::QPath) -> hir::Ty {"}, {"sha": "351f5818f7e67d6397648b008c9b33ca3109b53a", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -87,7 +87,7 @@ impl<'a> Code<'a> {\n         match map.get(id) {\n             map::Node::Block(_) => {\n                 //  Use the parent, hopefully an expression node.\n-                Code::from_node(map, map.get_parent_node_by_hir_id(id))\n+                Code::from_node(map, map.get_parent_node(id))\n             }\n             map::Node::Expr(expr) => Some(Code::Expr(expr)),\n             node => FnLikeNode::from_node(node).map(Code::FnLike)"}, {"sha": "3d591c9a1c6bdafb28167b0c04587c4abdc44226", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -292,7 +292,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n-        let node = if let Some(node) = self.find_by_hir_id(hir_id) {\n+        let node = if let Some(node) = self.find(hir_id) {\n             node\n         } else {\n             return None\n@@ -347,7 +347,7 @@ impl<'hir> Map<'hir> {\n                 if variant_data.ctor_hir_id().is_none() {\n                     return None;\n                 }\n-                let ctor_of = match self.find_by_hir_id(self.get_parent_node_by_hir_id(hir_id)) {\n+                let ctor_of = match self.find(self.get_parent_node(hir_id)) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n                     Some(Node::Variant(..)) => def::CtorOf::Variant,\n                     _ => unreachable!(),\n@@ -424,7 +424,7 @@ impl<'hir> Map<'hir> {\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> HirId {\n-        let parent = self.get_parent_node_by_hir_id(hir_id);\n+        let parent = self.get_parent_node(hir_id);\n         assert!(self.lookup(parent).map_or(false, |e| e.is_body_owner(hir_id)));\n         parent\n     }\n@@ -485,7 +485,7 @@ impl<'hir> Map<'hir> {\n         match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n-            Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n+            Node::GenericParam(_) => self.get_parent_node(id),\n             _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n         }\n     }\n@@ -563,7 +563,7 @@ impl<'hir> Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     pub fn get(&self, id: HirId) -> Node<'hir> {\n         // read recorded by `find`\n-        self.find_by_hir_id(id).unwrap_or_else(||\n+        self.find(id).unwrap_or_else(||\n             bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n@@ -595,13 +595,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n-    pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.find_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n+    pub fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n         let result = self.find_entry(hir_id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n                 None\n@@ -615,24 +609,17 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n-    /// Similar to `get_parent`; returns the parent node-ID, or just `hir_id` if there\n-    /// is no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n+    /// Similar to `get_parent`; returns the parent HIR Id, or just `hir_id` if there\n+    /// is no parent. Note that the parent may be `CRATE_HIR_ID`, which is not itself\n     /// present in the map, so passing the return value of `get_parent_node` to\n     /// `get` may in fact panic.\n-    /// This function returns the immediate parent in the AST, whereas `get_parent`\n+    /// This function returns the immediate parent in the HIR, whereas `get_parent`\n     /// returns the enclosing item. Note that this might not be the actual parent\n-    /// node in the AST -- some kinds of nodes are not in the map and these will\n+    /// node in the HIR -- some kinds of nodes are not in the map and these will\n     /// never appear as the parent node. Thus, you can always walk the parent nodes\n-    /// from a node to the root of the AST (unless you get back the same ID here,\n+    /// from a node to the root of the HIR (unless you get back the same ID here,\n     /// which can happen if the ID is not in the map itself or is just weird).\n-    pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n-        let hir_id = self.node_to_hir_id(id);\n-        let parent_hir_id = self.get_parent_node_by_hir_id(hir_id);\n-        self.hir_to_node_id(parent_hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_parent_node_by_hir_id(&self, hir_id: HirId) -> HirId {\n+    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = hir_id.owner;\n             let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n@@ -646,7 +633,7 @@ impl<'hir> Map<'hir> {\n \n     /// Check if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n-    pub fn is_argument(&self, id: NodeId) -> bool {\n+    pub fn is_argument(&self, id: HirId) -> bool {\n         match self.find(id) {\n             Some(Node::Binding(_)) => (),\n             _ => return false,\n@@ -687,7 +674,7 @@ impl<'hir> Map<'hir> {\n     {\n         let mut id = start_id;\n         loop {\n-            let parent_id = self.get_parent_node_by_hir_id(id);\n+            let parent_id = self.get_parent_node(id);\n             if parent_id == CRATE_HIR_ID {\n                 return Ok(CRATE_HIR_ID);\n             }\n@@ -872,28 +859,28 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn expect_item(&self, id: HirId) -> &'hir Item {\n-        match self.find_by_hir_id(id) { // read recorded by `find`\n+        match self.find(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem {\n-        match self.find_by_hir_id(id) {\n+        match self.find(id) {\n             Some(Node::ImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem {\n-        match self.find_by_hir_id(id) {\n+        match self.find(id) {\n             Some(Node::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n-        match self.find_by_hir_id(id) {\n+        match self.find(id) {\n             Some(Node::Item(i)) => {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n@@ -908,21 +895,21 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n-        match self.find_by_hir_id(id) {\n+        match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem {\n-        match self.find_by_hir_id(id) {\n+        match self.find(id) {\n             Some(Node::ForeignItem(item)) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_expr(&self, id: HirId) -> &'hir Expr {\n-        match self.find_by_hir_id(id) { // read recorded by find\n+        match self.find(id) { // read recorded by find\n             Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n@@ -1028,8 +1015,8 @@ impl<'hir> Map<'hir> {\n             Some(Node::Pat(pat)) => pat.span,\n             Some(Node::Arm(arm)) => arm.span,\n             Some(Node::Block(block)) => block.span,\n-            Some(Node::Ctor(..)) => match self.find_by_hir_id(\n-                self.get_parent_node_by_hir_id(hir_id))\n+            Some(Node::Ctor(..)) => match self.find(\n+                self.get_parent_node(hir_id))\n             {\n                 Some(Node::Item(item)) => item.span,\n                 Some(Node::Variant(variant)) => variant.span,\n@@ -1100,7 +1087,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n         // chain, then returns `None`.\n         fn find_first_mod_parent<'a>(map: &'a Map<'_>, mut id: HirId) -> Option<(HirId, Name)> {\n             loop {\n-                if let Node::Item(item) = map.find_by_hir_id(id)? {\n+                if let Node::Item(item) = map.find(id)? {\n                     if item_is_mod(&item) {\n                         return Some((id, item.ident.name))\n                     }\n@@ -1273,7 +1260,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         })\n     };\n \n-    match map.find_by_hir_id(id) {\n+    match map.find(id) {\n         Some(Node::Item(item)) => {\n             let item_str = match item.node {\n                 ItemKind::ExternCrate(..) => \"extern crate\","}, {"sha": "65225163a25a47111160a511f6c8374e2686d92b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir().find_by_hir_id(scope.hir_id(region_scope_tree)) {\n+                let tag = match self.hir().find(scope.hir_id(region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n                     Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n@@ -182,7 +182,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n-        let tag = match self.hir().find_by_hir_id(node) {\n+        let tag = match self.hir().find(node) {\n             Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),"}, {"sha": "9a5c726901fe87ea235f70ba28edd9dac60c6b74", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -171,6 +171,7 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// Track how many errors were reported when this infcx is created.\n     /// If the number of errors increases, that's also a sign (line\n     /// `tained_by_errors`) to avoid reporting certain kinds of errors.\n+    // FIXME(matthewjasper) Merge into `tainted_by_errors_flag`\n     err_count_on_creation: usize,\n \n     /// This flag is true while there is an active snapshot."}, {"sha": "6b6dbd43167fa3fadad4d89583a6a48a770295f6", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -777,7 +777,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                                 .local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n                         let (in_definition_scope, origin) =\n-                            match tcx.hir().find_by_hir_id(opaque_hir_id)\n+                            match tcx.hir().find(opaque_hir_id)\n                         {\n                             Some(Node::Item(item)) => match item.node {\n                                 // Anonymous `impl Trait`"}, {"sha": "e02ee8943603a6372cc113f9687c0d0b5d75cb1e", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -27,7 +27,7 @@ use syntax_pos;\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> bool {\n-    match tcx.hir().find_by_hir_id(hir_id) {\n+    match tcx.hir().find(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find_by_hir_id(id) {\n+            if let Some(node) = self.tcx.hir().find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }"}, {"sha": "7b69fe394fb2c552bc702ecbd588595ccdc7418d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -110,7 +110,7 @@ use std::{fmt, u32};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n@@ -369,7 +369,7 @@ fn visit_fn<'tcx>(\n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir().get_parent_item(id);\n-        if let Some(Node::Item(i)) = ir.tcx.hir().find_by_hir_id(parent) {\n+        if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(sym::automatically_derived)) {\n                 return;\n             }\n@@ -1327,12 +1327,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn access_var(&mut self, hir_id: HirId, nid: NodeId, succ: LiveNode, acc: u32, span: Span)\n+    fn access_var(&mut self, hir_id: HirId, var_hid: HirId, succ: LiveNode, acc: u32, span: Span)\n                   -> LiveNode {\n         let ln = self.live_node(hir_id, span);\n         if acc != 0 {\n             self.init_from_succ(ln, succ);\n-            let var_hid = self.ir.tcx.hir().node_to_hir_id(nid);\n             let var = self.variable(var_hid, span);\n             self.acc(ln, var, acc);\n         }\n@@ -1345,8 +1344,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Res::Local(hid) => {\n                 let upvars = self.ir.tcx.upvars(self.ir.body_owner);\n                 if !upvars.map_or(false, |upvars| upvars.contains_key(&hid)) {\n-                    let nid = self.ir.tcx.hir().hir_to_node_id(hid);\n-                    self.access_var(hir_id, nid, succ, acc, path.span)\n+                    self.access_var(hir_id, hid, succ, acc, path.span)\n                 } else {\n                     succ\n                 }"}, {"sha": "e7253a73bd4180a4469c85d203be2a1c85fc2309", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1526,7 +1526,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.hir().is_argument(tcx.hir().hir_to_node_id(vid)) {\n+                if tcx.hir().is_argument(vid) {\n                     \"argument\"\n                 } else {\n                     \"local variable\""}, {"sha": "d607c35f8762bb746f1f07f00f83835279a15600", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -53,7 +53,7 @@ fn method_might_be_inlined<'tcx>(\n         return true\n     }\n     if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n-        match tcx.hir().find_by_hir_id(impl_hir_id) {\n+        match tcx.hir().find(impl_hir_id) {\n             Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             None => { return false; }\n         };\n \n-        match self.tcx.hir().find_by_hir_id(hir_id) {\n+        match self.tcx.hir().find(hir_id) {\n             Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.hir().find_by_hir_id(search_item) {\n+            if let Some(ref item) = self.tcx.hir().find(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }"}, {"sha": "412346bab257e6b4b7c25906291ed58fe0d649cc", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -662,7 +662,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n                             if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n                                 // Ensure that the parent of the def is an item, not HRTB\n-                                let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                                let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n                                 let krate = self.tcx.hir().forest.krate();\n@@ -1489,7 +1489,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n         if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.hir_id) {\n-            if let Some(parent) = self.tcx.hir().find_by_hir_id(\n+            if let Some(parent) = self.tcx.hir().find(\n                 self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n             {\n                 match parent {\n@@ -2051,7 +2051,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.tcx.hir().get_parent_node_by_hir_id(output.hir_id);\n+        let parent = self.tcx.hir().get_parent_node(output.hir_id);\n         let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {"}, {"sha": "9b1808c585ce7f605b72bea27f06f77266555780", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -2096,6 +2096,18 @@ impl<'tcx> Place<'tcx> {\n     }\n }\n \n+impl From<Local> for Place<'_> {\n+    fn from(local: Local) -> Self {\n+        Place::Base(local.into())\n+    }\n+}\n+\n+impl From<Local> for PlaceBase<'_> {\n+    fn from(local: Local) -> Self {\n+        PlaceBase::Local(local)\n+    }\n+}\n+\n /// A linked list of projections running up the stack; begins with the\n /// innermost projection and extends to the outermost (e.g., `a.b.c`\n /// would have the place `b` with a \"next\" pointer to `b.c`)."}, {"sha": "bb4ef2d7bd4268cf63b027f22559ea6190297970", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -320,8 +320,13 @@ impl Session {\n         self.diagnostic().abort_if_errors();\n     }\n     pub fn compile_status(&self) -> Result<(), ErrorReported> {\n-        compile_result_from_err_count(self.err_count())\n+        if self.has_errors() {\n+            Err(ErrorReported)\n+        } else {\n+            Ok(())\n+        }\n     }\n+    // FIXME(matthewjasper) Remove this method, it should never be needed.\n     pub fn track_errors<F, T>(&self, f: F) -> Result<T, ErrorReported>\n     where\n         F: FnOnce() -> T,\n@@ -1388,11 +1393,3 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n }\n \n pub type CompileResult = Result<(), ErrorReported>;\n-\n-pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n-    if err_count == 0 {\n-        Ok(())\n-    } else {\n-        Err(ErrorReported)\n-    }\n-}"}, {"sha": "f54575ff8fc1dcb87047c2bf8482a55537afec47", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -938,8 +938,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n     ) {\n         if let &ObligationCauseCode::VariableType(hir_id) = code {\n-            let parent_node = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n-            if let Some(Node::Local(ref local)) = self.tcx.hir().find_by_hir_id(parent_node) {\n+            let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -1013,8 +1013,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node_by_hir_id(obligation.cause.body_id);\n-        let node = hir.find_by_hir_id(parent_node);\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n             node: hir::ItemKind::Fn(decl, _, _, body_id),\n             .."}, {"sha": "4710d611d99df0a3b2bc63cfa274aeddc443ff59", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1589,7 +1589,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let hir_id = self.hir()\n             .as_local_hir_id(suitable_region_binding_scope)\n             .unwrap();\n-        let is_impl_item = match self.hir().find_by_hir_id(hir_id) {\n+        let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -2880,7 +2880,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             if lint::maybe_lint_level_root(self, id) {\n                 return id;\n             }\n-            let next = self.hir().get_parent_node_by_hir_id(id);\n+            let next = self.hir().get_parent_node(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }\n@@ -2898,7 +2898,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n                 return pair\n             }\n-            let next = self.hir().get_parent_node_by_hir_id(id);\n+            let next = self.hir().get_parent_node(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }"}, {"sha": "af8dedfc8812e389874fb9bed343766c38520f45", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n use smallvec::SmallVec;\n-use syntax::ast::CRATE_NODE_ID;\n+use rustc::hir::CRATE_HIR_ID;\n use crate::ty::context::TyCtxt;\n use crate::ty::{DefId, DefIdTree};\n \n@@ -33,7 +33,7 @@ impl<'tcx> DefIdForest {\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n-        let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n+        let crate_id = tcx.hir().local_def_id_from_hir_id(CRATE_HIR_ID);\n         DefIdForest::from_id(crate_id)\n     }\n "}, {"sha": "0d96e5ea625da9437b200d81a7fd6690814135a3", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -97,7 +97,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ty_inhabitedness_forest(ty).contains(self, module)\n     }\n \n-    pub fn is_ty_uninhabited_from_all_modules(self, ty: Ty<'tcx>) -> bool {\n+    pub fn is_ty_uninhabited_from_any_module(self, ty: Ty<'tcx>) -> bool {\n         !self.ty_inhabitedness_forest(ty).is_empty()\n     }\n "}, {"sha": "658e4307348db02fd4530156c6ae2530aed3127f", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -47,7 +47,7 @@ pub enum PatternSource<'tcx> {\n /// with a reference to the let\n fn get_pattern_source<'tcx>(tcx: TyCtxt<'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n-    let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n+    let parent = tcx.hir().get_parent_node(pat.hir_id);\n \n     match tcx.hir().get(parent) {\n         Node::Expr(ref e) => {"}, {"sha": "3c7f19f7fbf4fb0d772e3462cacde24be6841a5d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1022,7 +1022,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n \n                 if let ty::ReScope(scope) = *super_scope {\n                     let hir_id = scope.hir_id(&self.region_scope_tree);\n-                    match self.tcx.hir().find_by_hir_id(hir_id) {\n+                    match self.tcx.hir().find(hir_id) {\n                         Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n@@ -1189,7 +1189,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n     }\n \n     fn local_ty(&self, hir_id: hir::HirId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+        let parent = self.tcx.hir().get_parent_node(hir_id);\n         let parent_node = self.tcx.hir().get(parent);\n \n         // The parent node is like a fn\n@@ -1287,7 +1287,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                     },\n                 )) = ty.map(|t| &t.node)\n                 {\n-                    let borrow_expr_id = self.tcx.hir().get_parent_node_by_hir_id(borrowed_hir_id);\n+                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_hir_id);\n                     db.span_suggestion(\n                         self.tcx.hir().span(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\"}, {"sha": "be5d7b09965d439c5a7202ab97b44b5f9e9a6713", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -470,7 +470,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Copy(\n-                            mir::Place::Base(mir::PlaceBase::Local(index))\n+                            mir::Place::from(index)\n                         );\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();"}, {"sha": "d92f3aafa1c7e3dbfdc8f059861843729676f4dd", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -253,10 +253,9 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn;\n \n     /// Computes an user-readable representation of a path, if possible.\n-    fn node_path(&self, id: ast::NodeId) -> Option<String> {\n+    fn node_path(&self, id: hir::HirId) -> Option<String> {\n         self.hir_map().and_then(|map| {\n-            let hir_id = map.node_to_hir_id(id);\n-            map.def_path_from_hir_id(hir_id)\n+            map.def_path_from_hir_id(id)\n         }).map(|path| {\n             path.data\n                 .into_iter()\n@@ -471,8 +470,8 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n         self\n     }\n \n-    fn node_path(&self, id: ast::NodeId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id)))\n+    fn node_path(&self, id: hir::HirId) -> Option<String> {\n+        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id_from_hir_id(id)))\n     }\n }\n \n@@ -631,7 +630,7 @@ fn print_flowgraph<'tcx, W: Write>(\n                 if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n                     break n.body();\n                 }\n-                let parent = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                let parent = tcx.hir().get_parent_node(hir_id);\n                 assert_ne!(hir_id, parent);\n                 hir_id = parent;\n             }\n@@ -834,7 +833,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                         let node = hir_map.get(hir_id);\n                         pp_state.print_node(node)?;\n                         pp_state.s.space()?;\n-                        let path = annotation.node_path(node_id)\n+                        let path = annotation.node_path(hir_id)\n                             .expect(\"-Z unpretty missing node paths\");\n                         pp_state.synth_comment(path)?;\n                         pp_state.s.hardbreak()?;\n@@ -907,11 +906,11 @@ fn print_with_analysis<'tcx>(\n             let nodeid =\n                 nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n                                 suffix (b::c::d)\");\n-            let node = tcx.hir().find(nodeid).unwrap_or_else(|| {\n+            let hir_id = tcx.hir().node_to_hir_id(nodeid);\n+            let node = tcx.hir().find(hir_id).unwrap_or_else(|| {\n                 tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n             });\n \n-            let hir_id = tcx.hir().node_to_hir_id(nodeid);\n             match blocks::Code::from_node(&tcx.hir(), hir_id) {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(tcx.sess);"}, {"sha": "70bd25a9d5772cfdb04714b0d50a93846c2af704", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -307,7 +307,12 @@ pub use diagnostic_builder::DiagnosticBuilder;\n pub struct Handler {\n     pub flags: HandlerFlags,\n \n+    /// The number of errors that have been emitted, including duplicates.\n+    ///\n+    /// This is not necessarily the count that's reported to the user once\n+    /// compilation ends.\n     err_count: AtomicUsize,\n+    deduplicated_err_count: AtomicUsize,\n     emitter: Lock<Box<dyn Emitter + sync::Send>>,\n     continue_after_error: AtomicBool,\n     delayed_span_bugs: Lock<Vec<Diagnostic>>,\n@@ -352,7 +357,7 @@ pub struct HandlerFlags {\n \n impl Drop for Handler {\n     fn drop(&mut self) {\n-        if self.err_count() == 0 {\n+        if !self.has_errors() {\n             let mut bugs = self.delayed_span_bugs.borrow_mut();\n             let has_bugs = !bugs.is_empty();\n             for bug in bugs.drain(..) {\n@@ -407,6 +412,7 @@ impl Handler {\n         Handler {\n             flags,\n             err_count: AtomicUsize::new(0),\n+            deduplicated_err_count: AtomicUsize::new(0),\n             emitter: Lock::new(e),\n             continue_after_error: AtomicBool::new(true),\n             delayed_span_bugs: Lock::new(Vec::new()),\n@@ -428,6 +434,7 @@ impl Handler {\n     pub fn reset_err_count(&self) {\n         // actually frees the underlying memory (which `clear` would not do)\n         *self.emitted_diagnostics.borrow_mut() = Default::default();\n+        self.deduplicated_err_count.store(0, SeqCst);\n         self.err_count.store(0, SeqCst);\n     }\n \n@@ -660,10 +667,10 @@ impl Handler {\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n-        let s = match self.err_count() {\n+        let s = match self.deduplicated_err_count.load(SeqCst) {\n             0 => return,\n             1 => \"aborting due to previous error\".to_string(),\n-            _ => format!(\"aborting due to {} previous errors\", self.err_count())\n+            count => format!(\"aborting due to {} previous errors\", count)\n         };\n         if self.treat_err_as_bug() {\n             return;\n@@ -705,10 +712,9 @@ impl Handler {\n     }\n \n     pub fn abort_if_errors(&self) {\n-        if self.err_count() == 0 {\n-            return;\n+        if self.has_errors() {\n+            FatalError.raise();\n         }\n-        FatalError.raise();\n     }\n     pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n         if lvl == Warning && !self.flags.can_emit_warnings {\n@@ -770,9 +776,12 @@ impl Handler {\n         if self.emitted_diagnostics.borrow_mut().insert(diagnostic_hash) {\n             self.emitter.borrow_mut().emit_diagnostic(db);\n             if db.is_error() {\n-                self.bump_err_count();\n+                self.deduplicated_err_count.fetch_add(1, SeqCst);\n             }\n         }\n+        if db.is_error() {\n+            self.bump_err_count();\n+        }\n     }\n \n     pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {"}, {"sha": "c1b6e3409c9159f1918d9c79088e094b893817e4", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -959,7 +959,7 @@ fn analysis<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Result<()> {\n     // lot of annoying errors in the compile-fail tests (basically,\n     // lint warnings and so on -- kindck used to do this abort, but\n     // kindck is gone now). -nmatsakis\n-    if sess.err_count() > 0 {\n+    if sess.has_errors() {\n         return Err(ErrorReported);\n     }\n "}, {"sha": "12719c3b9d303bc627101f861ce8c53a79b34e4a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -405,7 +405,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n-                    match cx.tcx.hir().find_by_hir_id(hir_id) {\n+                    match cx.tcx.hir().find(hir_id) {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {"}, {"sha": "d0258ca30c507d8b589b59b2e82d1ae346f2248a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -275,7 +275,7 @@ fn lint_int_literal<'a, 'tcx>(\n             return;\n         }\n \n-        let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.node {\n                 if is_range_literal(cx.sess(), par_e)\n@@ -314,7 +314,7 @@ fn lint_uint_literal<'a, 'tcx>(\n         _ => bug!(),\n     };\n     if lit_val < min || lit_val > max {\n-        let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        let parent_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n             match par_e.node {\n                 hir::ExprKind::Cast(..) => {"}, {"sha": "10c9a439bf70f23e12edbb6452262e211f4a88d6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -627,7 +627,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id, is_generator, places\n                 );\n                 if let Some((args_span, var_span)) = self.closure_span(\n-                    *def_id, &Place::Base(PlaceBase::Local(target)), places\n+                    *def_id, &Place::from(target), places\n                 ) {\n                     return ClosureUse {\n                         is_generator,"}, {"sha": "4872440f5bd4ae371b7a7eb37ee87e0498557179", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -620,7 +620,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n-                    (&Place::Base(PlaceBase::Local(local)), span),\n+                    (&Place::from(local), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,"}, {"sha": "92c2e4e01f7608226b84248aad3b57cce985fb43", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find_by_hir_id(upvar_hir_id)\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n                 {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n@@ -633,7 +633,7 @@ fn annotate_struct_field(\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n             let hir_id = tcx.hir().as_local_hir_id(field.did)?;\n-            let node = tcx.hir().find_by_hir_id(hir_id)?;\n+            let node = tcx.hir().find(hir_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {"}, {"sha": "ed88b16253584634bb1db1426144ad06cc4f47a8", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -252,7 +252,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = body.source_info(location).span;\n                 let spans = self\n-                    .move_spans(&Place::Base(PlaceBase::Local(local)), location)\n+                    .move_spans(&Place::from(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 let borrow_location = location;"}, {"sha": "c7b4a403052591d4bdd808731f4fe6194d404f88", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -11,7 +11,7 @@ use crate::borrow_check::path_utils::*;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::ty::TyCtxt;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Body, Place, PlaceBase, Rvalue};\n+use rustc::mir::{BasicBlock, Location, Body, Place, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::TerminatorKind;\n use rustc::mir::{Operand, BorrowKind};\n@@ -124,7 +124,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n-                    &Place::Base(PlaceBase::Local(local)),\n+                    &Place::from(local),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );"}, {"sha": "9409fefb6bde7d5d2d519762b02fb4b7238de059", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -632,7 +632,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 )\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.body, tcx).ty;\n+                let index_ty = Place::from(i).ty(self.body, tcx).ty;\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::from_ty(\n                         span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),"}, {"sha": "207399fbdcf0e6a3a928bdbe92a3c1658c78c708", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             Category::Place | Category::Rvalue(..) => {\n                 let operand = unpack!(block = this.as_temp(block, scope, expr, Mutability::Mut));\n-                block.and(Operand::Move(Place::Base(PlaceBase::Local(operand))))\n+                block.and(Operand::Move(Place::from(operand)))\n             }\n         }\n     }"}, {"sha": "0640c01d255c2b3715e81796591606b49ef2e1d9", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -98,26 +98,26 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     &lt,\n                     Rvalue::BinaryOp(\n                         BinOp::Lt,\n-                        Operand::Copy(Place::Base(PlaceBase::Local(idx))),\n+                        Operand::Copy(Place::from(idx)),\n                         Operand::Copy(len.clone()),\n                     ),\n                 );\n \n                 let msg = BoundsCheck {\n                     len: Operand::Move(len),\n-                    index: Operand::Copy(Place::Base(PlaceBase::Local(idx))),\n+                    index: Operand::Copy(Place::from(idx)),\n                 };\n                 let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n                 success.and(slice.index(idx))\n             }\n-            ExprKind::SelfRef => block.and(Place::Base(PlaceBase::Local(Local::new(1)))),\n+            ExprKind::SelfRef => block.and(Place::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n                 let place = if this.is_bound_var_in_guard(id) {\n                     let index = this.var_local_id(id, RefWithinGuard);\n-                    Place::Base(PlaceBase::Local(index)).deref()\n+                    Place::from(index).deref()\n                 } else {\n                     let index = this.var_local_id(id, OutsideGuard);\n-                    Place::Base(PlaceBase::Local(index))\n+                    Place::from(index)\n                 };\n                 block.and(place)\n             }\n@@ -168,14 +168,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n-                                Place::Base(PlaceBase::Local(temp.clone())),\n+                                Place::from(temp.clone()),\n                                 Variance::Invariant,\n                                 box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );\n                 }\n-                block.and(Place::Base(PlaceBase::Local(temp)))\n+                block.and(Place::from(temp))\n             }\n \n             ExprKind::Array { .. }\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n                 let temp =\n                     unpack!(block = this.as_temp(block, expr.temp_lifetime, expr, mutability));\n-                block.and(Place::Base(PlaceBase::Local(temp)))\n+                block.and(Place::from(temp))\n             }\n         }\n     }"}, {"sha": "73ce2a5dc9b8cafd5926371add8a6a59dde26eed", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -127,24 +127,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.schedule_drop_storage_and_value(\n                         expr_span,\n                         scope,\n-                        &Place::Base(PlaceBase::Local(result)),\n+                        &Place::from(result),\n                         value.ty,\n                     );\n                 }\n \n                 // malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n                 this.cfg\n-                    .push_assign(block, source_info, &Place::Base(PlaceBase::Local(result)), box_);\n+                    .push_assign(block, source_info, &Place::from(result), box_);\n \n                 // initialize the box contents:\n                 unpack!(\n                     block = this.into(\n-                        &Place::Base(PlaceBase::Local(result)).deref(),\n+                        &Place::from(result).deref(),\n                         block, value\n                     )\n                 );\n-                block.and(Rvalue::Use(Operand::Move(Place::Base(PlaceBase::Local(result)))))\n+                block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n             ExprKind::Cast { source } => {\n                 let source = unpack!(block = this.as_operand(block, scope, source));\n@@ -548,7 +548,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         this.cfg.push_assign(\n             block,\n             source_info,\n-            &Place::Base(PlaceBase::Local(temp)),\n+            &Place::from(temp),\n             Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place),\n         );\n \n@@ -559,12 +559,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.schedule_drop_storage_and_value(\n                 upvar_span,\n                 temp_lifetime,\n-                &Place::Base(PlaceBase::Local(temp)),\n+                &Place::from(temp),\n                 upvar_ty,\n             );\n         }\n \n-        block.and(Operand::Move(Place::Base(PlaceBase::Local(temp))))\n+        block.and(Operand::Move(Place::from(temp)))\n     }\n \n     // Helper to get a `-1` value of the appropriate type"}, {"sha": "1b3ebac4a3d4d7222d550245af8cdec887cf084b", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             this.local_decls.push(local_decl)\n         };\n-        let temp_place = &Place::Base(PlaceBase::Local(temp));\n+        let temp_place = &Place::from(temp);\n \n         if !expr_ty.is_never() {\n             this.cfg.push("}, {"sha": "f70ecef0c254a0fd03b964aa1146626e572910ee", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         is_user_variable: None,\n                         is_block_tail: None,\n                     });\n-                    let ptr_temp = Place::Base(PlaceBase::Local(ptr_temp));\n+                    let ptr_temp = Place::from(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n                     this.into(&ptr_temp.deref(), block, val)\n                 } else {"}, {"sha": "4463e7fd4d4a62abcc9f661d364651edcb71202c", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     }\n                     let temp = this.local_decls.push(local_decl);\n-                    let place = Place::Base(PlaceBase::Local(temp));\n+                    let place = Place::from(temp);\n                     debug!(\"created temp {:?} for expr {:?} in block_context: {:?}\",\n                            temp, expr, this.block_context);\n                     place"}, {"sha": "d2e56c4981faa92975454069c5e9648d28f3a94c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -531,7 +531,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 kind: StatementKind::StorageLive(local_id),\n             },\n         );\n-        let place = Place::Base(PlaceBase::Local(local_id));\n+        let place = Place::from(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.schedule_drop(\n             span,\n             region_scope,\n-            &Place::Base(PlaceBase::Local(local_id)),\n+            &Place::from(local_id),\n             var_ty,\n             DropKind::Value,\n         );\n@@ -1478,7 +1478,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_assign(\n                     block,\n                     scrutinee_source_info,\n-                    &Place::Base(PlaceBase::Local(temp)),\n+                    &Place::from(temp),\n                     borrow,\n                 );\n             }\n@@ -1502,7 +1502,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     source_info: guard_end,\n                     kind: StatementKind::FakeRead(\n                         FakeReadCause::ForMatchGuard,\n-                        Place::Base(PlaceBase::Local(temp)),\n+                        Place::from(temp),\n                     ),\n                 });\n             }\n@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // place they refer to can't be modified by the guard.\n             for binding in by_value_bindings.clone() {\n                 let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n-                    let place = Place::Base(PlaceBase::Local(local_id));\n+                    let place = Place::from(local_id);\n                 self.cfg.push(\n                     block,\n                     Statement {"}, {"sha": "56025eeaaa92284765738fb6d7adfc7f2783ff2d", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -16,7 +16,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n-        let place = Place::Base(PlaceBase::Local(temp));\n+        let place = Place::from(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n                place, self.local_decls[temp].ty);\n         place"}, {"sha": "0957dcbf3ea0828c4511bbc046b13936ff87f93c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -552,7 +552,6 @@ where\n         .into_iter()\n         .flatten()\n         .map(|(&var_hir_id, &upvar_id)| {\n-            let var_node_id = tcx_hir.hir_to_node_id(var_hir_id);\n             let capture = hir_tables.upvar_capture(upvar_id);\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -563,7 +562,7 @@ where\n                 by_ref,\n             };\n             let mut mutability = Mutability::Not;\n-            if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n+            if let Some(Node::Binding(pat)) = tcx_hir.find(var_hir_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n@@ -809,7 +808,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         for (index, arg_info) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n-            let place = Place::Base(PlaceBase::Local(local));\n+            let place = Place::from(local);\n             let &ArgInfo(ty, opt_ty_info, pattern, ref self_binding) = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on."}, {"sha": "887ef4b520ea38110c3c4c8a656ceb15f7dfdb07", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n-use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashMap;\n \n use syntax::source_map::{Span, DUMMY_SP};\n@@ -655,19 +654,12 @@ pub fn const_eval_raw_provider<'tcx>(\n         if tcx.is_static(def_id) {\n             // Ensure that if the above error was either `TooGeneric` or `Reported`\n             // an error must be reported.\n-            let reported_err = tcx.sess.track_errors(|| {\n-                err.report_as_error(ecx.tcx,\n-                                    \"could not evaluate static initializer\")\n-            });\n-            match reported_err {\n-                Ok(v) => {\n-                    tcx.sess.delay_span_bug(err.span,\n-                                        &format!(\"static eval failure did not emit an error: {:#?}\",\n-                                        v));\n-                    v\n-                },\n-                Err(ErrorReported) => ErrorHandled::Reported,\n-            }\n+            let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+            tcx.sess.delay_span_bug(\n+                err.span,\n+                &format!(\"static eval failure did not emit an error: {:#?}\", v)\n+            );\n+            v\n         } else if def_id.is_local() {\n             // constant defined in this crate, we can figure out a lint level!\n             match tcx.def_kind(def_id) {"}, {"sha": "a73ec2ed8e06a102ae77350e7b2413e5febe7bb4", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -170,7 +170,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'tcx, F>(\n {\n     let move_data = &ctxt.move_data;\n     for arg in body.args_iter() {\n-        let place = mir::Place::Base(mir::PlaceBase::Local(arg));\n+        let place = mir::Place::from(arg);\n         let lookup_result = move_data.rev_lookup.find(&place);\n         on_lookup_result_bits(tcx, body, move_data,\n                               lookup_result,"}, {"sha": "dcc6ba5ca05cc402756884e8eec7e11eae381765", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, &Place::Base(PlaceBase::Local(local)));\n+                self.kill_borrows_on_place(trans, &Place::from(local));\n             }\n \n             mir::StatementKind::InlineAsm(ref asm) => {"}, {"sha": "f282c276e092694fce45201ba4daaba606b7ebc6", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -33,13 +33,13 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(body),\n                 rev_lookup: MovePathLookup {\n-                    locals: body.local_decls.indices().map(PlaceBase::Local).map(|v| {\n+                    locals: body.local_decls.indices().map(|i| {\n                         Self::new_move_path(\n                             &mut move_paths,\n                             &mut path_map,\n                             &mut init_path_map,\n                             None,\n-                            Place::Base(v),\n+                            Place::from(i),\n                         )\n                     }).collect(),\n                     projections: Default::default(),\n@@ -289,7 +289,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n-                self.gather_move(&Place::Base(PlaceBase::Local(local)));\n+                self.gather_move(&Place::from(local));\n             }\n             StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span,"}, {"sha": "94b4f6e8dd1c5cf26fcb2b8fe2542dd657336aa9", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -909,7 +909,7 @@ fn convert_path_expr<'a, 'tcx>(\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n             let hir_id = cx.tcx.hir().as_local_hir_id(def_id).unwrap();\n-            let item_id = cx.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            let item_id = cx.tcx.hir().get_parent_node(hir_id);\n             let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);\n             let local_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);"}, {"sha": "13baf245d10fbeb865097e86e39419978a0823e3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -355,7 +355,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     let mut locals_iter = body.args_iter();\n                     while let Some(local) = locals_iter.next() {\n                         let dest = self.eval_place(\n-                            &mir::Place::Base(mir::PlaceBase::Local(local))\n+                            &mir::Place::from(local)\n                         )?;\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n@@ -388,12 +388,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                             ));\n                         }\n                     } else {\n-                        let callee_layout =\n-                            self.layout_of_local(self.frame(), mir::RETURN_PLACE, None)?;\n-                        if !callee_layout.abi.is_uninhabited() {\n-                            return err!(FunctionRetMismatch(\n-                                self.tcx.types.never, callee_layout.ty\n-                            ));\n+                        let local = mir::RETURN_PLACE;\n+                        let ty = self.frame().body.local_decls[local].ty;\n+                        if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n+                            return err!(FunctionRetMismatch(self.tcx.types.never, ty));\n                         }\n                     }\n                     Ok(())"}, {"sha": "7987095a33401ee437fb77a1e7db8297beebc7ac", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -213,7 +213,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n-        let dropee_ptr = Place::Base(PlaceBase::Local(Local::new(1+0)));\n+        let dropee_ptr = Place::from(Local::new(1+0));\n         if tcx.sess.opts.debugging_opts.mir_emit_retag {\n             // Function arguments should be retagged, and we make this one raw.\n             body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n@@ -308,7 +308,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, tcx.param_env(def_id), builder.span);\n \n     let dest = Place::RETURN_PLACE;\n-    let src = Place::Base(PlaceBase::Local(Local::new(1+0))).deref();\n+    let src = Place::from(Local::new(1+0)).deref();\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n@@ -412,7 +412,7 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn copy_shim(&mut self) {\n-        let rcvr = Place::Base(PlaceBase::Local(Local::new(1+0))).deref();\n+        let rcvr = Place::from(Local::new(1+0)).deref();\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 Place::RETURN_PLACE,\n@@ -424,9 +424,7 @@ impl CloneShimBuilder<'tcx> {\n \n     fn make_place(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n-        Place::Base(PlaceBase::Local(\n-            self.local_decls.push(temp_decl(mutability, ty, span))\n-        ))\n+        Place::from(self.local_decls.push(temp_decl(mutability, ty, span)))\n     }\n \n     fn make_clone_call(\n@@ -525,7 +523,7 @@ impl CloneShimBuilder<'tcx> {\n         let inits = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(beg)),\n+                    Place::from(beg),\n                     box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n                 )\n             ),\n@@ -543,7 +541,7 @@ impl CloneShimBuilder<'tcx> {\n         //     BB #3;\n         // }\n         // BB #4;\n-        self.loop_header(Place::Base(PlaceBase::Local(beg)),\n+        self.loop_header(Place::from(beg),\n                          end,\n                          BasicBlock::new(2),\n                          BasicBlock::new(4),\n@@ -563,10 +561,10 @@ impl CloneShimBuilder<'tcx> {\n         let statements = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(beg)),\n+                    Place::from(beg),\n                     box Rvalue::BinaryOp(\n                         BinOp::Add,\n-                        Operand::Copy(Place::Base(PlaceBase::Local(beg))),\n+                        Operand::Copy(Place::from(beg)),\n                         Operand::Constant(self.make_usize(1))\n                     )\n                 )\n@@ -586,7 +584,7 @@ impl CloneShimBuilder<'tcx> {\n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let init = self.make_statement(\n             StatementKind::Assign(\n-                Place::Base(PlaceBase::Local(beg)),\n+                Place::from(beg),\n                 box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n             )\n         );\n@@ -597,7 +595,7 @@ impl CloneShimBuilder<'tcx> {\n         //     BB #8;\n         // }\n         // BB #9;\n-        self.loop_header(Place::Base(PlaceBase::Local(beg)), Place::Base(PlaceBase::Local(end)),\n+        self.loop_header(Place::from(beg), Place::from(end),\n                          BasicBlock::new(7), BasicBlock::new(9), true);\n \n         // BB #7 (cleanup)\n@@ -613,10 +611,10 @@ impl CloneShimBuilder<'tcx> {\n         // `goto #6;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::Base(PlaceBase::Local(beg)),\n+                Place::from(beg),\n                 box Rvalue::BinaryOp(\n                     BinOp::Add,\n-                    Operand::Copy(Place::Base(PlaceBase::Local(beg))),\n+                    Operand::Copy(Place::from(beg)),\n                     Operand::Constant(self.make_usize(1))\n                 )\n             )\n@@ -701,7 +699,7 @@ fn build_call_shim<'tcx>(\n     let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n \n     let rcvr_arg = Local::new(1+0);\n-    let rcvr_l = Place::Base(PlaceBase::Local(rcvr_arg));\n+    let rcvr_l = Place::from(rcvr_arg);\n     let mut statements = vec![];\n \n     let rcvr = match rcvr_adjustment {\n@@ -731,11 +729,11 @@ fn build_call_shim<'tcx>(\n             statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(ref_rcvr)),\n+                    Place::from(ref_rcvr),\n                     box Rvalue::Ref(tcx.lifetimes.re_erased, borrow_kind, rcvr_l)\n                 )\n             });\n-            Operand::Move(Place::Base(PlaceBase::Local(ref_rcvr)))\n+            Operand::Move(Place::from(ref_rcvr))\n         }\n     };\n \n@@ -755,12 +753,12 @@ fn build_call_shim<'tcx>(\n \n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n-            let arg_place = Place::Base(PlaceBase::Local(Local::new(1+1)));\n+            let arg_place = Place::from(Local::new(1+1));\n             Operand::Move(arg_place.field(Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n-            Operand::Move(Place::Base(PlaceBase::Local(Local::new(1+i))))\n+            Operand::Move(Place::from(Local::new(1+i)))\n         }));\n     }\n \n@@ -791,7 +789,7 @@ fn build_call_shim<'tcx>(\n     if let Adjustment::RefMut = rcvr_adjustment {\n         // BB #1 - drop for Self\n         block(&mut blocks, vec![], TerminatorKind::Drop {\n-            location: Place::Base(PlaceBase::Local(rcvr_arg)),\n+            location: Place::from(rcvr_arg),\n             target: BasicBlock::new(2),\n             unwind: None\n         }, false);\n@@ -801,7 +799,7 @@ fn build_call_shim<'tcx>(\n     if let Adjustment::RefMut = rcvr_adjustment {\n         // BB #3 - drop if closure panics\n         block(&mut blocks, vec![], TerminatorKind::Drop {\n-            location: Place::Base(PlaceBase::Local(rcvr_arg)),\n+            location: Place::from(rcvr_arg),\n             target: BasicBlock::new(4),\n             unwind: None\n         }, true);\n@@ -881,7 +879,7 @@ pub fn build_adt_ctor<'tcx>(tcx: TyCtxt<'tcx>, ctor_id: DefId) -> &'tcx Body<'tc\n             .iter()\n             .enumerate()\n             .map(|(idx, field_def)| (\n-                Operand::Move(Place::Base(PlaceBase::Local(Local::new(idx + 1)))),\n+                Operand::Move(Place::from(Local::new(idx + 1))),\n                 field_def.ty(tcx, substs),\n             )),\n         AggregateKind::Adt(adt_def, variant_index, substs, None, None),"}, {"sha": "426e16698d74d70a2bd18671cb0b7e69e25d1bc8", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -112,10 +112,10 @@ fn add_move_for_packed_drop<'tcx>(\n \n     patch.add_statement(\n         loc, StatementKind::StorageLive(temp));\n-    patch.add_assign(loc, Place::Base(PlaceBase::Local(temp)),\n+    patch.add_assign(loc, Place::from(temp),\n                      Rvalue::Use(Operand::Move(location.clone())));\n     patch.patch_terminator(loc.block, TerminatorKind::Drop {\n-        location: Place::Base(PlaceBase::Local(temp)),\n+        location: Place::from(temp),\n         target: storage_dead_block,\n         unwind\n     });"}, {"sha": "e01017d7c9bdbe513a8b849116cedace25de0f5f", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -96,7 +96,7 @@ impl MirPass for AddRetag {\n             };\n             // Gather all arguments, skip return value.\n             let places = local_decls.iter_enumerated().skip(1).take(arg_count)\n-                    .map(|(local, _)| Place::Base(PlaceBase::Local(local)))\n+                    .map(|(local, _)| Place::from(local))\n                     .filter(needs_retag)\n                     .collect::<Vec<_>>();\n             // Emit their retags."}, {"sha": "24df3549be48136c9d8a4e481b0c0364765a75c9", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -570,14 +570,14 @@ fn is_enclosed(\n     used_unsafe: &FxHashSet<hir::HirId>,\n     id: hir::HirId,\n ) -> Option<(String, hir::HirId)> {\n-    let parent_id = tcx.hir().get_parent_node_by_hir_id(id);\n+    let parent_id = tcx.hir().get_parent_node(id);\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n-        })) = tcx.hir().find_by_hir_id(parent_id) {\n+        })) = tcx.hir().find(parent_id) {\n             match header.unsafety {\n                 hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n                 hir::Unsafety::Normal => None,"}, {"sha": "ad19b974d7d61caff5eac717b22c5394f75ffa6a", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -326,7 +326,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flag(&mut self, index: MovePathIndex) -> Option<Place<'tcx>> {\n-        self.drop_flags.get(&index).map(|t| Place::Base(PlaceBase::Local(*t)))\n+        self.drop_flags.get(&index).map(|t| Place::from(*t))\n     }\n \n     /// create a patch that elaborates all drops in the input\n@@ -537,7 +537,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n             let span = self.patch.source_info_for_location(self.body, loc).span;\n             let val = self.constant_bool(span, val.value());\n-            self.patch.add_assign(loc, Place::Base(PlaceBase::Local(flag)), val);\n+            self.patch.add_assign(loc, Place::from(flag), val);\n         }\n     }\n \n@@ -546,7 +546,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let span = self.patch.source_info_for_location(self.body, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n-            self.patch.add_assign(loc, Place::Base(PlaceBase::Local(*flag)), false_.clone());\n+            self.patch.add_assign(loc, Place::from(*flag), false_.clone());\n         }\n     }\n "}, {"sha": "7b961e97a10de580f0f7a340055e2409a3f58991", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -200,7 +200,7 @@ impl TransformVisitor<'tcx> {\n \n     // Create a Place referencing a generator struct field\n     fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n-        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let self_place = Place::from(self_arg());\n         let base = self_place.downcast_unnamed(variant_index);\n         let field = Projection {\n             base: base,\n@@ -211,7 +211,7 @@ impl TransformVisitor<'tcx> {\n \n     // Create a statement which changes the discriminant\n     fn set_discr(&self, state_disc: VariantIdx, source_info: SourceInfo) -> Statement<'tcx> {\n-        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let self_place = Place::from(self_arg());\n         Statement {\n             source_info,\n             kind: StatementKind::SetDiscriminant { place: self_place, variant_index: state_disc },\n@@ -222,9 +222,9 @@ impl TransformVisitor<'tcx> {\n     fn get_discr(&self, body: &mut Body<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n         let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, body.span);\n         let local_decls_len = body.local_decls.push(temp_decl);\n-        let temp = Place::Base(PlaceBase::Local(local_decls_len));\n+        let temp = Place::from(local_decls_len);\n \n-        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let self_place = Place::from(self_arg());\n         let assign = Statement {\n             source_info: source_info(body),\n             kind: StatementKind::Assign(temp.clone(), box Rvalue::Discriminant(self_place)),\n@@ -271,7 +271,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         let ret_val = match data.terminator().kind {\n             TerminatorKind::Return => Some((VariantIdx::new(1),\n                 None,\n-                Operand::Move(Place::Base(PlaceBase::Local(self.new_ret_local))),\n+                Operand::Move(Place::from(self.new_ret_local)),\n                 None)),\n             TerminatorKind::Yield { ref value, resume, drop } => Some((VariantIdx::new(0),\n                 Some(resume),\n@@ -840,7 +840,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n         elaborate_drop(\n             &mut elaborator,\n             source_info,\n-            &Place::Base(PlaceBase::Local(gen)),\n+            &Place::from(gen),\n             (),\n             target,\n             unwind,\n@@ -913,7 +913,7 @@ fn create_generator_drop_shim<'tcx>(\n         // Alias tracking must know we changed the type\n         body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n             source_info,\n-            kind: StatementKind::Retag(RetagKind::Raw, Place::Base(PlaceBase::Local(self_arg()))),\n+            kind: StatementKind::Retag(RetagKind::Raw, Place::from(self_arg())),\n         })\n     }\n \n@@ -1031,7 +1031,7 @@ fn insert_clean_drop<'tcx>(body: &mut Body<'tcx>) -> BasicBlock {\n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     let drop_clean = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n-        location: Place::Base(PlaceBase::Local(self_arg())),\n+        location: Place::from(self_arg()),\n         target: return_block,\n         unwind: None,\n     };"}, {"sha": "dc73e58d15c3d28c41e8e4ce73db6d86c03d7940", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -467,7 +467,7 @@ impl Inliner<'tcx> {\n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n                     let tmp = caller_body.local_decls.push(temp);\n-                    let tmp = Place::Base(PlaceBase::Local(tmp));\n+                    let tmp = Place::from(tmp);\n \n                     let stmt = Statement {\n                         source_info: callsite.location,\n@@ -561,7 +561,7 @@ impl Inliner<'tcx> {\n             let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             assert!(args.next().is_none());\n \n-            let tuple = Place::Base(PlaceBase::Local(tuple));\n+            let tuple = Place::from(tuple);\n             let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.sty {\n                 s\n             } else {\n@@ -621,7 +621,7 @@ impl Inliner<'tcx> {\n \n         let stmt = Statement {\n             source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::Base(PlaceBase::Local(arg_tmp)), box arg),\n+            kind: StatementKind::Assign(Place::from(arg_tmp), box arg),\n         };\n         caller_body[callsite.bb].statements.push(stmt);\n         arg_tmp"}, {"sha": "f09a77d486c7e3ceccf2634c3cc42693ea44f856", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -83,13 +83,13 @@ impl Lower128Bit {\n                     block.statements.push(Statement {\n                         source_info: source_info,\n                         kind: StatementKind::Assign(\n-                            Place::Base(PlaceBase::Local(local)),\n+                            Place::from(local),\n                             box Rvalue::Cast(\n                                 CastKind::Misc,\n                                 rhs,\n                                 rhs_override_ty.unwrap())),\n                     });\n-                    rhs = Operand::Move(Place::Base(PlaceBase::Local(local)));\n+                    rhs = Operand::Move(Place::from(local));\n                 }\n \n                 let call_did = check_lang_item_type("}, {"sha": "b1804fb0ab331e06b90c2b61b4c3e820214e7e43", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            kind: StatementKind::Assign(Place::Base(PlaceBase::Local(dest)), box rvalue)\n+            kind: StatementKind::Assign(Place::from(dest), box rvalue)\n         });\n     }\n \n@@ -273,7 +273,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             args,\n                             cleanup: None,\n                             destination: Some(\n-                                (Place::Base(PlaceBase::Local(new_temp)), new_target)\n+                                (Place::from(new_temp), new_target)\n                             ),\n                             from_hir_call,\n                         },"}, {"sha": "6878eceb2a5dbd8a55bf2950dcfb25f325bfd103", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     let temp = self.patch.new_temp(item_ty, self.body.source_info(location).span);\n                     self.patch.add_statement(location, StatementKind::StorageLive(temp));\n                     self.patch.add_assign(location,\n-                                          Place::Base(PlaceBase::Local(temp)),\n+                                          Place::from(temp),\n                                           Rvalue::Use(\n                                               Operand::Move(\n                                                   Place::Projection(box Projection{\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     Rvalue::Aggregate(\n                         box AggregateKind::Array(item_ty),\n                         temps.iter().map(\n-                            |x| Operand::Move(Place::Base(PlaceBase::Local(*x)))\n+                            |x| Operand::Move(Place::from(*x))\n                         ).collect()\n                     )\n                 );"}, {"sha": "dac90d37275b40a0cdb1437a71816c929c9cdb23", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -486,7 +486,7 @@ where\n         // discriminant after it is free-ed, because that\n         // way lies only trouble.\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n-        let discr = Place::Base(PlaceBase::Local(self.new_temp(discr_ty)));\n+        let discr = Place::from(self.new_temp(discr_ty));\n         let discr_rv = Rvalue::Discriminant(self.place.clone());\n         let switch_block = BasicBlockData {\n             statements: vec![self.assign(&discr, discr_rv)],\n@@ -518,11 +518,11 @@ where\n             mutbl: hir::Mutability::MutMutable\n         });\n         let ref_place = self.new_temp(ref_ty);\n-        let unit_temp = Place::Base(PlaceBase::Local(self.new_temp(tcx.mk_unit())));\n+        let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n-                &Place::Base(PlaceBase::Local(ref_place)),\n+                &Place::from(ref_place),\n                 Rvalue::Ref(tcx.lifetimes.re_erased,\n                             BorrowKind::Mut { allow_two_phase_borrow: false },\n                             self.place.clone())\n@@ -531,7 +531,7 @@ where\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n                                                    self.source_info.span),\n-                    args: vec![Operand::Move(Place::Base(PlaceBase::Local(ref_place)))],\n+                    args: vec![Operand::Move(Place::from(ref_place))],\n                     destination: Some((unit_temp, succ)),\n                     cleanup: unwind.into_option(),\n                     from_hir_call: true,\n@@ -576,8 +576,8 @@ where\n             ty: ety,\n             mutbl: hir::Mutability::MutMutable\n         });\n-        let ptr = &Place::Base(PlaceBase::Local(self.new_temp(ref_ty)));\n-        let can_go = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.bool)));\n+        let ptr = &Place::from(self.new_temp(ref_ty));\n+        let can_go = &Place::from(self.new_temp(tcx.types.bool));\n \n         let one = self.constant_usize(1);\n         let (ptr_next, cur_next) = if ptr_based {\n@@ -589,19 +589,19 @@ where\n                     elem: ProjectionElem::Deref,\n                 }))\n              ),\n-             Rvalue::BinaryOp(BinOp::Offset, move_(&Place::Base(PlaceBase::Local(cur))), one))\n+             Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.lifetimes.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n                  self.place.clone().index(cur)),\n-             Rvalue::BinaryOp(BinOp::Add, move_(&Place::Base(PlaceBase::Local(cur))), one))\n+             Rvalue::BinaryOp(BinOp::Add, move_(&Place::from(cur)), one))\n         };\n \n         let drop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(ptr, ptr_next),\n-                self.assign(&Place::Base(PlaceBase::Local(cur)), cur_next)\n+                self.assign(&Place::from(cur), cur_next)\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -615,7 +615,7 @@ where\n         let loop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n-                                                     copy(&Place::Base(PlaceBase::Local(cur))),\n+                                                     copy(&Place::from(cur)),\n                                                      copy(length_or_end)))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n@@ -665,8 +665,8 @@ where\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n-        let elem_size = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n-        let len = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n+        let elem_size = &Place::from(self.new_temp(tcx.types.usize));\n+        let len = &Place::from(self.new_temp(tcx.types.usize));\n \n         static USIZE_SWITCH_ZERO: &[u128] = &[0];\n \n@@ -713,8 +713,7 @@ where\n         let length_or_end = if ptr_based {\n             // FIXME check if we want to make it return a `Place` directly\n             // if all use sites want a `Place::Base` anyway.\n-            let temp = self.new_temp(iter_ty);\n-            Place::Base(PlaceBase::Local(temp))\n+            Place::from(self.new_temp(iter_ty))\n         } else {\n             length.clone()\n         };\n@@ -736,10 +735,10 @@ where\n             unwind,\n             ptr_based);\n \n-        let cur = Place::Base(PlaceBase::Local(cur));\n+        let cur = Place::from(cur);\n         let drop_block_stmts = if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n-            let tmp = Place::Base(PlaceBase::Local(self.new_temp(tmp_ty)));\n+            let tmp = Place::from(self.new_temp(tmp_ty));\n             // tmp = &mut P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n@@ -894,7 +893,7 @@ where\n         unwind: Unwind,\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n-        let unit_temp = Place::Base(PlaceBase::Local(self.new_temp(tcx.mk_unit())));\n+        let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);"}, {"sha": "1d876d7bddb5300b8488ecbf5ae82cff88aac028", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -153,7 +153,7 @@ fn write_graph_label<'tcx, W: Write>(\n         }\n         write!(w,\n                \"{:?}: {}\",\n-               Place::Base(PlaceBase::Local(arg)),\n+               Place::from(arg),\n                escape(&body.local_decls[arg].ty)\n         )?;\n     }\n@@ -171,10 +171,10 @@ fn write_graph_label<'tcx, W: Write>(\n \n         if let Some(name) = decl.name {\n             write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-                   Place::Base(PlaceBase::Local(local)), escape(&decl.ty), name)?;\n+                   Place::from(local), escape(&decl.ty), name)?;\n         } else {\n             write!(w, r#\"{:?}: {};<br align=\"left\"/>\"#,\n-                   Place::Base(PlaceBase::Local(local)), escape(&decl.ty))?;\n+                   Place::from(local), escape(&decl.ty))?;\n         }\n     }\n "}, {"sha": "d66f35f82c66231c0b46718f6987025e347019db", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -601,7 +601,7 @@ fn write_mir_sig(\n             if i != 0 {\n                 write!(w, \", \")?;\n             }\n-            write!(w, \"{:?}: {}\", Place::Base(PlaceBase::Local(arg)), body.local_decls[arg].ty)?;\n+            write!(w, \"{:?}: {}\", Place::from(arg), body.local_decls[arg].ty)?;\n         }\n \n         write!(w, \") -> {}\", body.return_ty())?;"}, {"sha": "ed0a78b46527659bd7aea3eff19f639f50f74681", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 };\n \n                 if loop_id != hir::DUMMY_HIR_ID {\n-                    if let Node::Block(_) = self.hir_map.find_by_hir_id(loop_id).unwrap() {\n+                    if let Node::Block(_) = self.hir_map.find(loop_id).unwrap() {\n                         return\n                     }\n                 }\n@@ -155,7 +155,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 match destination.target_id {\n                     Ok(loop_id) => {\n-                        if let Node::Block(block) = self.hir_map.find_by_hir_id(loop_id).unwrap() {\n+                        if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n                                             \"`continue` pointing to a labeled block\")\n                                 .span_label(e.span,"}, {"sha": "3e98200e5327466e5d7cdf8ea5988cf4c8785f94", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -247,7 +247,7 @@ fn def_id_visibility<'tcx>(\n                     }\n                 }\n                 Node::Ctor(vdata) => {\n-                    let parent_hir_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                    let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n                     match tcx.hir().get(parent_hir_id) {\n                         Node::Variant(..) => {\n                             let parent_did = tcx.hir().local_def_id_from_hir_id(parent_hir_id);\n@@ -784,7 +784,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             if module_id == hir::CRATE_HIR_ID {\n                 break\n             }\n-            module_id = self.tcx.hir().get_parent_node_by_hir_id(module_id);\n+            module_id = self.tcx.hir().get_parent_node(module_id);\n         }\n     }\n }\n@@ -1233,7 +1233,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n-            match self.tcx.hir().find_by_hir_id(hir_id) {\n+            match self.tcx.hir().find(hir_id) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n@@ -1674,7 +1674,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n                     has_old_errors = true;\n                     break;\n                 }\n-                let parent = self.tcx.hir().get_parent_node_by_hir_id(id);\n+                let parent = self.tcx.hir().get_parent_node(id);\n                 if parent == id {\n                     break;\n                 }"}, {"sha": "81adfac0a291aa3647c76a41c9a7107fe00f5f1a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1744,12 +1744,12 @@ impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_hir_path(\n+    fn resolve_ast_path(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n-    ) -> hir::Path {\n-        self.resolve_hir_path_cb(path, is_value,\n+    ) -> Res {\n+        self.resolve_ast_path_cb(path, is_value,\n                                  |resolver, span, error| resolve_error(resolver, span, error))\n     }\n \n@@ -1759,7 +1759,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n         is_value: bool\n-    ) -> hir::Path {\n+    ) -> (ast::Path, Res) {\n         let root = if crate_root.is_some() {\n             kw::PathRoot\n         } else {\n@@ -1777,7 +1777,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             segments,\n         };\n \n-        self.resolve_hir_path(&path, is_value)\n+        let res = self.resolve_ast_path(&path, is_value);\n+        (path, res)\n     }\n \n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n@@ -1803,7 +1804,7 @@ impl<'a> Resolver<'a> {\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occurred.\n     pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n-        -> Result<hir::Path, ()> {\n+        -> Result<(ast::Path, Res), ()> {\n         let mut errored = false;\n \n         let path = if path_str.starts_with(\"::\") {\n@@ -1826,29 +1827,29 @@ impl<'a> Resolver<'a> {\n                     .collect(),\n             }\n         };\n-        let path = self.resolve_hir_path_cb(&path, is_value, |_, _, _| errored = true);\n-        if errored || path.res == def::Res::Err {\n+        let res = self.resolve_ast_path_cb(&path, is_value, |_, _, _| errored = true);\n+        if errored || res == def::Res::Err {\n             Err(())\n         } else {\n-            Ok(path)\n+            Ok((path, res))\n         }\n     }\n \n-    /// Like `resolve_hir_path`, but takes a callback in case there was an error.\n-    fn resolve_hir_path_cb<F>(\n+    /// Like `resolve_ast_path`, but takes a callback in case there was an error.\n+    // FIXME(eddyb) use `Result` or something instead of callbacks.\n+    fn resolve_ast_path_cb<F>(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n         error_callback: F,\n-    ) -> hir::Path\n+    ) -> Res\n         where F: for<'c, 'b> FnOnce(&'c mut Resolver<'_>, Span, ResolutionError<'b>)\n     {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let span = path.span;\n-        let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-        let res = match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n+        match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n                                                                span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 module.res().unwrap(),\n@@ -1869,19 +1870,6 @@ impl<'a> Resolver<'a> {\n                 });\n                 Res::Err\n             }\n-        };\n-\n-        let segments: Vec<_> = segments.iter().map(|seg| {\n-            let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n-            hir_seg.res = Some(self.partial_res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n-                p.base_res().map_id(|_| panic!(\"unexpected node_id\"))\n-            }));\n-            hir_seg\n-        }).collect();\n-        hir::Path {\n-            span,\n-            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n-            segments: segments.into(),\n         }\n     }\n "}, {"sha": "392a46a262f5038c2b59e0dcfebf7c1f137678ef", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1022,6 +1022,12 @@ impl<'a> Resolver<'a> {\n \n     fn suggest_macro_name(&mut self, name: Symbol, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>, span: Span) {\n+        if kind == MacroKind::Derive && (name.as_str() == \"Send\" || name.as_str() == \"Sync\") {\n+            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", name);\n+            err.span_note(span, &msg);\n+            return;\n+        }\n+\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n             find_best_match_for_name("}, {"sha": "19ed9e214073c1618e76294ec9e0ffa424586b95", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -410,7 +410,10 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                             let mut decl_id = None;\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(Node::ImplItem(item)) = self.tcx.hir().find(id) {\n+                            let hir_id = self.tcx.hir().node_to_hir_id(id);\n+                            if let Some(Node::ImplItem(item)) =\n+                                self.tcx.hir().find(hir_id)\n+                            {\n                                 docs = self.docs_for_attrs(&item.attrs);\n                                 attrs = item.attrs.to_vec();\n                             }\n@@ -451,8 +454,9 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     Some(def_id) => {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n+                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n \n-                        if let Some(Node::TraitItem(item)) = self.tcx.hir().find(id) {\n+                        if let Some(Node::TraitItem(item)) = self.tcx.hir().find(hir_id) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -521,7 +525,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let hir_node = match self.tcx.hir().find(sub_ex.id) {\n+                let sub_ex_hir_id = self.tcx.hir().node_to_hir_id(sub_ex.id);\n+                let hir_node = match self.tcx.hir().find(sub_ex_hir_id) {\n                     Some(Node::Expr(expr)) => expr,\n                     _ => {\n                         debug!(\n@@ -621,7 +626,10 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Node::PathSegment(seg) => {\n                 match seg.res {\n                     Some(res) if res != Res::Err => res,\n-                    _ => self.get_path_res(self.tcx.hir().get_parent_node(id)),\n+                    _ => {\n+                        let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+                        self.get_path_res(self.tcx.hir().hir_to_node_id(parent_node))\n+                    },\n                 }\n             }\n "}, {"sha": "8905f475647bab6c92c157a40565516c6f0e702a", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -2,25 +2,19 @@ use rustc::session::Session;\n \n use crate::generated_code;\n \n-use std::cell::Cell;\n-\n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, TokenKind};\n use syntax_pos::*;\n \n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n     pub sess: &'a Session,\n-    // FIXME given that we clone SpanUtils all over the place, this err_count is\n-    // probably useless and any logic relying on it is bogus.\n-    pub err_count: Cell<isize>,\n }\n \n impl<'a> SpanUtils<'a> {\n     pub fn new(sess: &'a Session) -> SpanUtils<'a> {\n         SpanUtils {\n             sess,\n-            err_count: Cell::new(0),\n         }\n     }\n "}, {"sha": "0375ad4a08f26c8e95eba2fbca11a55323d62380", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -2000,7 +2000,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.prohibit_generics(&path.segments);\n \n                 let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-                let item_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n@@ -2190,7 +2190,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Find the name and index of the const parameter by indexing the generics of the\n             // parent item and construct a `ParamConst`.\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-            let item_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            let item_id = tcx.hir().get_parent_node(hir_id);\n             let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n             let index = generics.param_def_id_to_index[&tcx.hir().local_def_id_from_hir_id(hir_id)];"}, {"sha": "b435c99ad01f5f3e097484bb0647c2994cf3deb7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n         if let PatKind::Binding(..) = inner.node {\n-            let parent_id = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n+            let parent_id = tcx.hir().get_parent_node(pat.hir_id);\n             let parent = tcx.hir().get(parent_id);\n             debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, parent);\n             match parent {\n@@ -808,16 +808,16 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         use hir::Node::{Block, Item, Local};\n \n         let hir = self.tcx.hir();\n-        let arm_id = hir.get_parent_node_by_hir_id(hir_id);\n-        let match_id = hir.get_parent_node_by_hir_id(arm_id);\n-        let containing_id = hir.get_parent_node_by_hir_id(match_id);\n+        let arm_id = hir.get_parent_node(hir_id);\n+        let match_id = hir.get_parent_node(arm_id);\n+        let containing_id = hir.get_parent_node(match_id);\n \n         let node = hir.get(containing_id);\n         if let Block(block) = node {\n             // check that the body's parent is an fn\n             let parent = hir.get(\n-                hir.get_parent_node_by_hir_id(\n-                    hir.get_parent_node_by_hir_id(block.hir_id),\n+                hir.get_parent_node(\n+                    hir.get_parent_node(block.hir_id),\n                 ),\n             );\n             if let (Some(expr), Item(hir::Item {"}, {"sha": "e6999f9e3ac8a0aa963e615ac4517c1b3d3e4bdf", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         callee_node: &hir::ExprKind,\n         callee_span: Span,\n     ) {\n-        let hir_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+        let hir_id = self.tcx.hir().get_parent_node(hir_id);\n         let parent_node = self.tcx.hir().get(hir_id);\n         if let (\n             hir::Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, _, _, sp, ..), .. }),"}, {"sha": "4bd2f216224a5f62fb41472974a9c8e01b336fee", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1231,7 +1231,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        let parent_id = fcx.tcx.hir().get_parent_node_by_hir_id(blk_id);\n+                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n                         db = self.report_return_mismatched_types(\n                             cause,\n                             expected,\n@@ -1281,7 +1281,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         // Verify that this is a tail expression of a function, otherwise the\n         // label pointing out the cause for the type coercion will be wrong\n         // as prior return coercions would not be relevant (#57664).\n-        let parent_id = fcx.tcx.hir().get_parent_node_by_hir_id(id);\n+        let parent_id = fcx.tcx.hir().get_parent_node(id);\n         let fn_decl = if let Some((expr, blk_id)) = expression {\n             pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n                 &mut db,"}, {"sha": "c469d3516e2d48a64b361d15c6249dec908cf177", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -236,17 +236,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<(Span, &'static str, String)> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Res::Local(id) = path.res {\n-                let parent = self.tcx.hir().get_parent_node_by_hir_id(id);\n+                let parent = self.tcx.hir().get_parent_node(id);\n                 if let Some(Node::Expr(hir::Expr {\n                     hir_id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n-                })) = self.tcx.hir().find_by_hir_id(parent) {\n-                    let parent = self.tcx.hir().get_parent_node_by_hir_id(*hir_id);\n+                })) = self.tcx.hir().find(parent) {\n+                    let parent = self.tcx.hir().get_parent_node(*hir_id);\n                     if let (Some(Node::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n-                    })), 1) = (self.tcx.hir().find_by_hir_id(parent), decl.inputs.len()) {\n+                    })), 1) = (self.tcx.hir().find(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_type(expr[0].hir_id);\n                         let self_ty = format!(\"{:?}\", self_ty);\n                         let name = path.ident.as_str();\n@@ -276,8 +276,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         sp: Span,\n     ) -> bool {\n         let cm = self.sess().source_map();\n-        let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n-        if let Some(parent) = self.tcx.hir().find_by_hir_id(parent_id) {\n+        let parent_id = self.tcx.hir().get_parent_node(hir_id);\n+        if let Some(parent) = self.tcx.hir().find(parent_id) {\n             // Account for fields\n             if let Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Struct(_, fields, ..), ..\n@@ -421,8 +421,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(hir::Node::Expr(hir::Expr {\n                             node: hir::ExprKind::Assign(left_expr, _),\n                             ..\n-                        })) = self.tcx.hir().find_by_hir_id(\n-                            self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id),\n+                        })) = self.tcx.hir().find(\n+                            self.tcx.hir().get_parent_node(expr.hir_id),\n                         ) {\n                             if mutability == hir::Mutability::MutMutable {\n                                 // Found the following case:\n@@ -551,7 +551,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(hir::Node::Expr(hir::Expr {\n             node: hir::ExprKind::Struct(_, fields, _),\n             ..\n-        })) = self.tcx.hir().find_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id)) {\n+        })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id)) {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n             for field in fields {\n                 if field.expr.hir_id == expr.hir_id && field.is_shorthand {"}, {"sha": "85da3251971430ddbe47228718a5f5c4380bdf4e", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -565,7 +565,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // else an error would have been flagged by the\n                 // `loops` pass for using break with an expression\n                 // where you are not supposed to.\n-                assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+                assert!(expr_opt.is_none() || self.tcx.sess.has_errors());\n             }\n \n             ctxt.may_break = true;\n@@ -577,10 +577,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // this can only happen if the `break` was not\n             // inside a loop at all, which is caught by the\n             // loop-checking pass.\n-            if self.tcx.sess.err_count() == 0 {\n-                self.tcx.sess.delay_span_bug(expr.span,\n-                    \"break was outside loop, but no error was emitted\");\n-            }\n+            self.tcx.sess.delay_span_bug(expr.span,\n+                \"break was outside loop, but no error was emitted\");\n \n             // We still need to assign a type to the inner expression to\n             // prevent the ICE in #43162."}, {"sha": "fa1b07d2dcfcdfdfe4189d1013d44ccc15c2c807", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n                                         let parent_node = self.tcx.hir().get(\n-                                            self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n+                                            self.tcx.hir().get_parent_node(hir_id),\n                                         );\n                                         let msg = format!(\n                                             \"you must specify a type for this binding, like `{}`\",\n@@ -390,7 +390,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 );\n                             } else {\n                                 let call_expr = self.tcx.hir().expect_expr(\n-                                    self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id),\n+                                    self.tcx.hir().get_parent_node(expr.hir_id),\n                                 );\n \n                                 if let Some(span) = call_expr.span.trim_start(item_name.span) {"}, {"sha": "5ae26c4118f0731d605648e9d0bde742c2193a98", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -527,6 +527,8 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// checking this function. On exit, if we find that *more* errors\n     /// have been reported, we will skip regionck and other work that\n     /// expects the types within the function to be consistent.\n+    // FIXME(matthewjasper) This should not exist, and it's not correct\n+    // if type checking is run in parallel.\n     err_count_on_creation: usize,\n \n     ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n@@ -696,11 +698,9 @@ impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n }\n \n-pub fn check_wf_new<'tcx>(tcx: TyCtxt<'tcx>) -> Result<(), ErrorReported> {\n-    tcx.sess.track_errors(|| {\n-        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n-        tcx.hir().krate().par_visit_all_item_likes(&mut visit);\n-    })\n+pub fn check_wf_new<'tcx>(tcx: TyCtxt<'tcx>) {\n+    let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n+    tcx.hir().krate().par_visit_all_item_likes(&mut visit);\n }\n \n fn check_mod_item_types<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n@@ -2147,8 +2147,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self.tcx.sess\n     }\n \n-    pub fn err_count_since_creation(&self) -> usize {\n-        self.tcx.sess.err_count() - self.err_count_on_creation\n+    pub fn errors_reported_since_creation(&self) -> bool {\n+        self.tcx.sess.err_count() > self.err_count_on_creation\n     }\n \n     /// Produces warning on the given node, if the current point in the\n@@ -4278,7 +4278,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n         if let Node::Expr(expr) = self.tcx.hir().get(\n-            self.tcx.hir().get_parent_node_by_hir_id(hir_id))\n+            self.tcx.hir().get_parent_node(hir_id))\n         {\n             if let ExprKind::Call(ref callee, ..) = expr.node {\n                 if callee.hir_id == hir_id {\n@@ -4353,7 +4353,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut contained_in_place = false;\n \n         while let hir::Node::Expr(parent_expr) =\n-            self.tcx.hir().get(self.tcx.hir().get_parent_node_by_hir_id(expr_id))\n+            self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n         {\n             match &parent_expr.node {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n@@ -4394,7 +4394,7 @@ pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, t\n         } else if let ty::Error = leaf_ty.sty {\n             // If there is already another error, do not emit\n             // an error for not using a type Parameter.\n-            assert!(tcx.sess.err_count() > 0);\n+            assert!(tcx.sess.has_errors());\n             return;\n         }\n     }"}, {"sha": "5313e1d0f73a34099c6835c155c8e0133a8ef5b1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // standalone expr (e.g., the `E` in a type like `[u32; E]`).\n         rcx.outlives_environment.save_implied_bounds(id);\n \n-        if self.err_count_since_creation() == 0 {\n+        if !self.errors_reported_since_creation() {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n             rcx.visit_region_obligations(id);\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.param_env,\n         );\n \n-        if self.err_count_since_creation() == 0 {\n+        if !self.errors_reported_since_creation() {\n             // regionck assumes typeck succeeded\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n         }"}, {"sha": "7e781eeec56a98b3a8a0d887fc632e0948f12755", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -95,7 +95,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx>) {\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n             if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n-                if tcx.hir().find_by_hir_id(id).is_none() {\n+                if tcx.hir().find(id).is_none() {\n                     return false;\n                 }\n             }"}, {"sha": "42deeaf31f4279d71ee1e85f9abb866876b63961", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -52,7 +52,7 @@ fn visit_implementation_of_drop<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     } else {\n         // Destructors only work on nominal types.\n         if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_did) {\n-            if let Some(Node::Item(item)) = tcx.hir().find_by_hir_id(impl_hir_id) {\n+            if let Some(Node::Item(item)) = tcx.hir().find(impl_hir_id) {\n                 let span = match item.node {\n                     ItemKind::Impl(.., ref ty, _) => ty.span,\n                     _ => item.span,"}, {"sha": "87e1166b7c041101ae8419b43d475251c8510ec9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1298,7 +1298,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n         }\n \n         Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get(tcx.hir().get_parent_node_by_hir_id(hir_id));\n+            let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n             match parent_node {\n                 Node::Ty(&hir::Ty {\n                     node: hir::TyKind::Array(_, ref constant),"}, {"sha": "182594e768468fa8db0e7987456caed71ea0825e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -182,7 +182,7 @@ fn check_main_fn_ty<'tcx>(tcx: TyCtxt<'tcx>, main_def_id: DefId) {\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir().find_by_hir_id(main_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n@@ -247,7 +247,7 @@ fn check_start_fn_ty<'tcx>(tcx: TyCtxt<'tcx>, start_def_id: DefId) {\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir().find_by_hir_id(start_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n@@ -320,6 +320,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) -> Result<(), ErrorReported> {\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n+    // FIXME(matthewjasper) We shouldn't need to do this.\n     tcx.sess.track_errors(|| {\n         time(tcx.sess, \"type collecting\", || {\n             for &module in tcx.hir().krate().modules.keys() {\n@@ -352,7 +353,9 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) -> Result<(), ErrorReported> {\n         })?;\n     }\n \n-    time(tcx.sess, \"wf checking\", || check::check_wf_new(tcx))?;\n+    tcx.sess.track_errors(|| {\n+        time(tcx.sess, \"wf checking\", || check::check_wf_new(tcx));\n+    })?;\n \n     time(tcx.sess, \"item-types checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {"}, {"sha": "29ee59d12427425d97cb4228822d75c843af843a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -346,7 +346,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         // current architecture.\n         let resolver = abort_on_err(compiler.expansion(), sess).peek().1.clone();\n \n-        if sess.err_count() > 0 {\n+        if sess.has_errors() {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n "}, {"sha": "bb85fe898dabda019f9edc965b5231f57a3b1529", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -71,15 +71,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 })\n             });\n \n-            if let Ok(result) = result {\n+            if let Ok((_, res)) = result {\n+                let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n                 // In case this is a trait item, skip the\n                 // early return and try looking for the trait.\n-                let value = match result.res {\n+                let value = match res {\n                     Res::Def(DefKind::Method, _) | Res::Def(DefKind::AssocConst, _) => true,\n                     Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, result.res),\n+                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, res),\n                     // Not a trait item; just return what we found.\n-                    _ => return Ok((result.res, None))\n+                    _ => return Ok((res, None))\n                 };\n \n                 if value != (ns == ValueNS) {\n@@ -129,10 +130,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n             // FIXME: `with_scope` requires the `NodeId` of a module.\n             let node_id = cx.tcx.hir().hir_to_node_id(id);\n-            let ty = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n+            let (_, ty_res) = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n-            match ty.res {\n+            let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+            match ty_res {\n                 Res::Def(DefKind::Struct, did)\n                 | Res::Def(DefKind::Union, did)\n                 | Res::Def(DefKind::Enum, did)\n@@ -147,7 +149,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n                             _ => return Err(())\n                         };\n-                        Ok((ty.res, Some(format!(\"{}.{}\", out, item_name))))\n+                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n                         match cx.tcx.type_of(did).sty {\n                             ty::Adt(def, _) => {\n@@ -159,7 +161,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                        .iter()\n                                        .find(|item| item.ident.name == item_name)\n                                 } {\n-                                    Ok((ty.res,\n+                                    Ok((ty_res,\n                                         Some(format!(\"{}.{}\",\n                                                      if def.is_enum() {\n                                                          \"variant\"\n@@ -193,7 +195,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             _ => return Err(())\n                         };\n \n-                        Ok((ty.res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n                     } else {\n                         Err(())\n                     }"}, {"sha": "d5b8a00c75b834ad8862ba66c0d4a2adc99eca66", "filename": "src/libsyntax_ext/deriving/bounds.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -6,14 +6,6 @@ use syntax::ast::MetaItem;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax_pos::Span;\n \n-pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt<'_>,\n-                                    span: Span,\n-                                    _: &MetaItem,\n-                                    _: &Annotatable,\n-                                    _: &mut dyn FnMut(Annotatable)) {\n-    cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n-}\n-\n pub fn expand_deriving_copy(cx: &mut ExtCtxt<'_>,\n                             span: Span,\n                             mitem: &MetaItem,"}, {"sha": "aa9913d436cfa81afc3bc77c9f61afaac46b860a", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -111,8 +111,6 @@ derive_traits! {\n \n     \"Default\" => default::expand_deriving_default,\n \n-    \"Send\" => bounds::expand_deriving_unsafe_bound,\n-    \"Sync\" => bounds::expand_deriving_unsafe_bound,\n     \"Copy\" => bounds::expand_deriving_copy,\n \n     // deprecated"}, {"sha": "d66c4f47d03ee79289d4c8e3bf49017f558a0a62", "filename": "src/test/ui/consts/enum-discr-type-err.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -0,0 +1,29 @@\n+// Test that we mark enum discriminant values as having errors, even when the\n+// diagnostic is deduplicated.\n+\n+struct F;\n+struct T;\n+\n+impl F {\n+    const V: i32 = 0;\n+}\n+\n+impl T {\n+    const V: i32 = 0;\n+}\n+\n+macro_rules! mac {\n+    ($( $v: ident = $s: ident,)*) => {\n+        enum E {\n+            $( $v = $s::V, )*\n+            //~^ ERROR mismatched types\n+        }\n+    }\n+}\n+\n+mac! {\n+    A = F,\n+    B = T,\n+}\n+\n+fn main() {}"}, {"sha": "3c4fac7327d401e9ae834e25857c74d5a71440da", "filename": "src/test/ui/consts/enum-discr-type-err.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/enum-discr-type-err.rs:18:21\n+   |\n+LL |               $( $v = $s::V, )*\n+   |                       ^^^^^ expected isize, found i32\n+...\n+LL | / mac! {\n+LL | |     A = F,\n+LL | |     B = T,\n+LL | | }\n+   | |_- in this macro invocation\n+help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |             $( $v = $s::V.try_into().unwrap(), )*\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "21fbbf8cfb5a8d6c8f6654be893d1f9284127bd7", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -0,0 +1,19 @@\n+// compile-fail\n+\n+pub const unsafe fn fake_type<T>() -> T {\n+    hint_unreachable()\n+}\n+\n+pub const unsafe fn hint_unreachable() -> ! {\n+    fake_type() //~ ERROR any use of this value will cause an error\n+}\n+\n+trait Const {\n+    const CONSTANT: i32 = unsafe { fake_type() };\n+}\n+\n+impl <T> Const for T {}\n+\n+pub fn main() -> () {\n+    dbg!(i32::CONSTANT); //~ ERROR erroneous constant used\n+}"}, {"sha": "5c2855437118f5c127861569097735f4dd0cb3fe", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -0,0 +1,24 @@\n+error: any use of this value will cause an error\n+  --> $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |\n+LL |     fake_type()\n+   |     ^^^^^^^^^^^\n+   |     |\n+   |     tried to call a function with return type T passing return place of type !\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `fake_type::<i32>` at $DIR/uninhabited-const-issue-61744.rs:12:36\n+...\n+LL |     const CONSTANT: i32 = unsafe { fake_type() };\n+   |     ---------------------------------------------\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error[E0080]: erroneous constant used\n+  --> $DIR/uninhabited-const-issue-61744.rs:18:10\n+   |\n+LL |     dbg!(i32::CONSTANT);\n+   |          ^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "52659bd11e0808cf090d2fa33fd427a45a881e7a", "filename": "src/test/ui/derives/deriving-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1,9 +1,9 @@\n #[derive(Send)]\n-//~^ ERROR this unsafe trait should be implemented explicitly\n+//~^ ERROR cannot find derive macro `Send` in this scope\n struct Test;\n \n #[derive(Sync)]\n-//~^ ERROR this unsafe trait should be implemented explicitly\n+//~^ ERROR cannot find derive macro `Sync` in this scope\n struct Test1;\n \n pub fn main() {}"}, {"sha": "99976da72da1d5adaeb57940b08ee554f41f3015", "filename": "src/test/ui/derives/deriving-bounds.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1,10 +1,22 @@\n-error: this unsafe trait should be implemented explicitly\n+error: cannot find derive macro `Send` in this scope\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+   |\n+note: unsafe traits like `Send` should be implemented explicitly\n   --> $DIR/deriving-bounds.rs:1:10\n    |\n LL | #[derive(Send)]\n    |          ^^^^\n \n-error: this unsafe trait should be implemented explicitly\n+error: cannot find derive macro `Sync` in this scope\n+  --> $DIR/deriving-bounds.rs:5:10\n+   |\n+LL | #[derive(Sync)]\n+   |          ^^^^\n+   |\n+note: unsafe traits like `Sync` should be implemented explicitly\n   --> $DIR/deriving-bounds.rs:5:10\n    |\n LL | #[derive(Sync)]"}, {"sha": "147fb3fa8cf330bd527e56b9a39da7b557aabb2d", "filename": "src/test/ui/issues/issue-33571.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fissues%2Fissue-33571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fissues%2Fissue-33571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33571.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1,5 +1,5 @@\n #[derive(Clone,\n-         Sync, //~ ERROR this unsafe trait should be implemented explicitly\n+         Sync, //~ ERROR cannot find derive macro `Sync` in this scope\n          Copy)]\n enum Foo {}\n "}, {"sha": "78e7202077498ee7b01967e62d73e5f55fa7563e", "filename": "src/test/ui/issues/issue-33571.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fissues%2Fissue-33571.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fissues%2Fissue-33571.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33571.stderr?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -1,4 +1,10 @@\n-error: this unsafe trait should be implemented explicitly\n+error: cannot find derive macro `Sync` in this scope\n+  --> $DIR/issue-33571.rs:2:10\n+   |\n+LL |          Sync,\n+   |          ^^^^\n+   |\n+note: unsafe traits like `Sync` should be implemented explicitly\n   --> $DIR/issue-33571.rs:2:10\n    |\n LL |          Sync,"}, {"sha": "7aa71f8b9eb9bf0e702d90a96393b3683f5134fc", "filename": "src/test/ui/issues/issue-38591.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fissues%2Fissue-38591.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c0448dde167128d668da4555879f64e56af1d/src%2Ftest%2Fui%2Fissues%2Fissue-38591.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38591.rs?ref=5f9c0448dde167128d668da4555879f64e56af1d", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+\n+struct S<T> {\n+    t : T,\n+    s : Box<S<fn(u : T)>>\n+}\n+\n+fn f(x : S<u32>) {}\n+\n+fn main () {}"}]}