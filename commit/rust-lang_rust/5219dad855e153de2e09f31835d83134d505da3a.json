{"sha": "5219dad855e153de2e09f31835d83134d505da3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMTlkYWQ4NTVlMTUzZGUyZTA5ZjMxODM1ZDgzMTM0ZDUwNWRhM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-08T06:19:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-08T06:19:14Z"}, "message": "Auto merge of #38883 - alexcrichton:android-flaky, r=brson\n\ncompiletest: Fix flaky Android gdb test runs\n\nLocal testing showed that I was able to reproduce an error where debuginfo tests\non Android would fail with \"connection reset by peer\". Further investigation\nturned out that the gdb tests are android with bit of process management:\n\n* First an `adb forward` command is run to ensure that the host's port 5039 is\n  the same as the emulator's.\n* Next an `adb shell` command is run to execute the `gdbserver` executable\n  inside the emulator. This gdb server will attach to port 5039 and listen for\n  remote gdb debugging sessions.\n* Finally, we run `gdb` on the host (not in the emulator) and then connect to\n  this gdb server to send it commands.\n\nThe problem was happening when the host's gdb was failing to connect to the\nremote gdbserver running inside the emulator. The previous test for this was\nthat after `adb shell` executed we'd sleep for a second and then attempt to make\na TCP connection to port 5039. If successful we'd run gdb and on failure we'd\nsleep again.\n\nIt turns out, however, that as soon as we've executed `adb forward` all TCP\nconnections to 5039 will succeed. This means that we would only ever sleep for\nat most one second, and if this wasn't enough time we'd just fail later because\nwe would assume that gdbserver had started but it may not have done so yet.\n\nThis commit fixes these issues by removing the TCP connection to test if\ngdbserver is ready to go. Instead we read the stdout of the process and wait for\nit to print that it's listening at which point we start running gdb. I've found\nthat locally at least I was unable to reproduce the failure after these changes.\n\nCloses #38710", "tree": {"sha": "dc12ccc565157b5bf5f674eda10b33320528842b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc12ccc565157b5bf5f674eda10b33320528842b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5219dad855e153de2e09f31835d83134d505da3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5219dad855e153de2e09f31835d83134d505da3a", "html_url": "https://github.com/rust-lang/rust/commit/5219dad855e153de2e09f31835d83134d505da3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5219dad855e153de2e09f31835d83134d505da3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05768690857636f27e17c825de791491a88784e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/05768690857636f27e17c825de791491a88784e7", "html_url": "https://github.com/rust-lang/rust/commit/05768690857636f27e17c825de791491a88784e7"}, {"sha": "9ced90164ced03af42d6813710b38f1e0c0f2ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ced90164ced03af42d6813710b38f1e0c0f2ecc", "html_url": "https://github.com/rust-lang/rust/commit/9ced90164ced03af42d6813710b38f1e0c0f2ecc"}], "stats": {"total": 81, "additions": 39, "deletions": 42}, "files": [{"sha": "7e4f40af9cea6c37bee97afe8f09d587e05df734", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5219dad855e153de2e09f31835d83134d505da3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5219dad855e153de2e09f31835d83134d505da3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=5219dad855e153de2e09f31835d83134d505da3a", "patch": "@@ -11,6 +11,7 @@\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n+use std::io;\n use std::path::PathBuf;\n use std::process::{Child, Command, ExitStatus, Output, Stdio};\n \n@@ -52,7 +53,7 @@ pub fn run(lib_path: &str,\n            args: &[String],\n            env: Vec<(String, String)>,\n            input: Option<String>)\n-           -> Option<Result> {\n+           -> io::Result<Result> {\n \n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n@@ -64,21 +65,17 @@ pub fn run(lib_path: &str,\n         cmd.env(&key, &val);\n     }\n \n-    match cmd.spawn() {\n-        Ok(mut process) => {\n-            if let Some(input) = input {\n-                process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-            }\n-            let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n-\n-            Some(Result {\n-                status: status,\n-                out: String::from_utf8(stdout).unwrap(),\n-                err: String::from_utf8(stderr).unwrap(),\n-            })\n-        }\n-        Err(..) => None,\n+    let mut process = cmd.spawn()?;\n+    if let Some(input) = input {\n+        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n     }\n+    let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n+\n+    Ok(Result {\n+        status: status,\n+        out: String::from_utf8(stdout).unwrap(),\n+        err: String::from_utf8(stderr).unwrap(),\n+    })\n }\n \n pub fn run_background(lib_path: &str,\n@@ -87,26 +84,21 @@ pub fn run_background(lib_path: &str,\n                       args: &[String],\n                       env: Vec<(String, String)>,\n                       input: Option<String>)\n-                      -> Option<Child> {\n+                      -> io::Result<Child> {\n \n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n-        .stdin(Stdio::piped())\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::piped());\n+       .stdin(Stdio::piped())\n+       .stdout(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n         cmd.env(&key, &val);\n     }\n \n-    match cmd.spawn() {\n-        Ok(mut process) => {\n-            if let Some(input) = input {\n-                process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-            }\n-\n-            Some(process)\n-        }\n-        Err(..) => None,\n+    let mut process = cmd.spawn()?;\n+    if let Some(input) = input {\n+        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n     }\n+\n+    Ok(process)\n }"}, {"sha": "05d6e21e9aaeae3aa3d0fed925393e2923d105ac", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5219dad855e153de2e09f31835d83134d505da3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5219dad855e153de2e09f31835d83134d505da3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=5219dad855e153de2e09f31835d83134d505da3a", "patch": "@@ -21,13 +21,12 @@ use test::TestPaths;\n use uidiff;\n use util::logv;\n \n-use std::env;\n use std::collections::HashSet;\n+use std::env;\n use std::fmt;\n use std::fs::{self, File};\n-use std::io::{self, BufReader};\n use std::io::prelude::*;\n-use std::net::TcpStream;\n+use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, ExitStatus};\n use std::str;\n@@ -506,8 +505,8 @@ actual:\\n\\\n                                  exe_file.to_str().unwrap().to_owned(),\n                                  self.config.adb_test_dir.clone()\n                              ],\n-                             vec![(\"\".to_owned(), \"\".to_owned())],\n-                             Some(\"\".to_owned()))\n+                             Vec::new(),\n+                             None)\n                     .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n \n                 procsrv::run(\"\",\n@@ -518,8 +517,8 @@ actual:\\n\\\n                                  \"tcp:5039\".to_owned(),\n                                  \"tcp:5039\".to_owned()\n                              ],\n-                             vec![(\"\".to_owned(), \"\".to_owned())],\n-                             Some(\"\".to_owned()))\n+                             Vec::new(),\n+                             None)\n                     .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n@@ -539,17 +538,23 @@ actual:\\n\\\n                                                               \"shell\".to_owned(),\n                                                               adb_arg.clone()\n                                                           ],\n-                                                          vec![(\"\".to_owned(),\n-                                                                \"\".to_owned())],\n-                                                          Some(\"\".to_owned()))\n+                                                          Vec::new(),\n+                                                          None)\n                     .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+\n+                // Wait for the gdbserver to print out \"Listening on port ...\"\n+                // at which point we know that it's started and then we can\n+                // execute the debugger below.\n+                let mut stdout = BufReader::new(process.stdout.take().unwrap());\n+                let mut line = String::new();\n                 loop {\n-                    //waiting 1 second for gdbserver start\n-                    ::std::thread::sleep(::std::time::Duration::new(1,0));\n-                    if TcpStream::connect(\"127.0.0.1:5039\").is_ok() {\n+                    line.truncate(0);\n+                    stdout.read_line(&mut line).unwrap();\n+                    if line.starts_with(\"Listening on port 5039\") {\n                         break\n                     }\n                 }\n+                drop(stdout);\n \n                 let debugger_script = self.make_out_name(\"debugger.script\");\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -569,7 +574,7 @@ actual:\\n\\\n                                  &gdb_path,\n                                  None,\n                                  &debugger_opts,\n-                                 vec![(\"\".to_owned(), \"\".to_owned())],\n+                                 Vec::new(),\n                                  None)\n                     .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n                 let cmdline = {"}]}