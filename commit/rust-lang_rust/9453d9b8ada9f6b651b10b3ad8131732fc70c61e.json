{"sha": "9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NTNkOWI4YWRhOWY2YjY1MWIxMGIzYWQ4MTMxNzMyZmM3MGM2MWU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T03:32:00Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T03:32:00Z"}, "message": "rustc: remove ParamSpace from Substs.", "tree": {"sha": "8b4c87ee7e930d9378d1a088982802c01dfdeadf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b4c87ee7e930d9378d1a088982802c01dfdeadf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "html_url": "https://github.com/rust-lang/rust/commit/9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f5e455c2de007a12ed632f84b986369ae43a504", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5e455c2de007a12ed632f84b986369ae43a504", "html_url": "https://github.com/rust-lang/rust/commit/6f5e455c2de007a12ed632f84b986369ae43a504"}], "stats": {"total": 1319, "additions": 462, "deletions": 857}, "files": [{"sha": "2a8594c59a83764c727862b7f3ff38684154d7e4", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -18,7 +18,7 @@ use hir::{self, pat_util, PatKind};\n use hir::intravisit::{self, Visitor};\n \n use middle::privacy;\n-use ty::{self, subst, TyCtxt};\n+use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n-                    match substs.substs.types.get(subst::TypeSpace, 0).sty {\n+                    match substs.substs.types[0].sty {\n                         TyEnum(tyid, _) | TyStruct(tyid, _) => {\n                             self.check_def_id(tyid.did)\n                         }"}, {"sha": "8369a6c39d54d658a825aaa2eb4842e5c9aa06f2", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -24,9 +24,7 @@ use session::Session;\n use hir::def::{Def, DefMap};\n use hir::def_id::DefId;\n use middle::region;\n-use ty::subst;\n use ty;\n-use std::fmt;\n use std::mem::replace;\n use syntax::ast;\n use syntax::parse::token::keywords;\n@@ -41,8 +39,7 @@ use hir::intravisit::{self, Visitor, FnKind};\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n     DefStaticRegion,\n-    DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n-                        /* index */ u32,\n+    DefEarlyBoundRegion(/* index */ u32,\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n@@ -90,10 +87,11 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     labels_in_fn: Vec<(ast::Name, Span)>,\n }\n \n+#[derive(PartialEq, Debug)]\n enum ScopeChain<'a> {\n-    /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n-    /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(subst::ParamSpace, &'a [hir::LifetimeDef], Scope<'a>),\n+    /// EarlyScope(['a, 'b, ...], s) extends s with early-bound\n+    /// lifetimes.\n+    EarlyScope(&'a [hir::LifetimeDef], Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n     LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n@@ -159,8 +157,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n-                    let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n-                    this.with(early_scope, |old_scope, this| {\n+                    this.with(EarlyScope(lifetimes, &ROOT_SCOPE), |old_scope, this| {\n                         this.check_lifetime_defs(old_scope, lifetimes);\n                         intravisit::walk_item(this, item);\n                     });\n@@ -181,11 +178,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         self.with(RootScope, |_, this| {\n             match item.node {\n                 hir::ForeignItemFn(ref decl, ref generics) => {\n-                    this.visit_early_late(item.id,\n-                                          subst::FnSpace,\n-                                          decl,\n-                                          generics,\n-                                          |this| {\n+                    this.visit_early_late(item.id, decl, generics, |this| {\n                         intravisit::walk_foreign_item(this, item);\n                     })\n                 }\n@@ -203,14 +196,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n-                self.visit_early_late(fn_id, subst::FnSpace, decl, generics, |this| {\n+                self.visit_early_late(fn_id,decl, generics, |this| {\n                     this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n             FnKind::Method(_, sig, _, _) => {\n                 self.visit_early_late(\n                     fn_id,\n-                    subst::FnSpace,\n                     decl,\n                     &sig.generics,\n                     |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n@@ -263,7 +255,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n \n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n-                trait_item.id, subst::FnSpace,\n+                trait_item.id,\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n@@ -469,7 +461,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n                 FnScope { s, .. } => { scope = s; }\n                 RootScope => { return; }\n \n-                EarlyScope(_, lifetimes, s) |\n+                EarlyScope(lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     for lifetime_def in lifetimes {\n                         // FIXME (#24278): non-hygienic comparison\n@@ -557,7 +549,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n-                           early_space: subst::ParamSpace,\n                            decl: &hir::FnDecl,\n                            generics: &hir::Generics,\n                            walk: F) where\n@@ -576,7 +567,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n \n         let this = self;\n-        this.with(EarlyScope(early_space, &early, this.scope), move |old_scope, this| {\n+        this.with(EarlyScope(&early, this.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n@@ -606,11 +597,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(space, lifetimes, s) => {\n+                EarlyScope(lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, lifetime_def)) => {\n+                        Some((mut index, lifetime_def)) => {\n+                            // Adjust for nested early scopes, e.g. in methods.\n+                            let mut parent = s;\n+                            while let EarlyScope(lifetimes, s) = *parent {\n+                                index += lifetimes.len() as u32;\n+                                parent = s;\n+                            }\n+                            assert_eq!(*parent, RootScope);\n+\n                             let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(space, index, decl_id);\n+                            let def = DefEarlyBoundRegion(index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -672,7 +671,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(_, lifetimes, s) |\n+                EarlyScope(lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n@@ -768,7 +767,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                EarlyScope(_, lifetimes, s) |\n+                EarlyScope(lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n                         signal_shadowing_problem(\n@@ -963,14 +962,3 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         }\n     }\n }\n-\n-impl<'a> fmt::Debug for ScopeChain<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),\n-            LateScope(defs, _) => write!(fmt, \"LateScope({:?})\", defs),\n-            FnScope { fn_id, body_id, s: _ } => write!(fmt, \"FnScope({:?}, {:?})\", fn_id, body_id),\n-            RootScope => write!(fmt, \"RootScope\"),\n-        }\n-    }\n-}"}, {"sha": "33db0053cda13547a9b33dd3a71cac10f6f958ad", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -31,7 +31,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{Subst, TypeSpace};\n+use ty::subst::Subst;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -232,8 +232,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n-                    if trait_ref.substs.types.get_slice(TypeSpace)[1..].iter()\n-                        .zip(&impl_trait_ref.substs.types.get_slice(TypeSpace)[1..])\n+                    if trait_ref.substs.types[1..].iter()\n+                        .zip(&impl_trait_ref.substs.types[1..])\n                         .all(|(u,v)| self.fuzzy_match_tys(u, v))\n                     {\n                         fuzzy_match_impls.push(def_id);"}, {"sha": "837e33b3e7fc2798e2c27af83265ef52845afa17", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n         // Auto trait obligations on `impl Trait`.\n         if tcx.trait_has_default_impl(predicate.def_id()) {\n             let substs = predicate.skip_binder().trait_ref.substs;\n-            if substs.types.as_full_slice().len() == 1 && substs.regions.is_empty() {\n+            if substs.types.len() == 1 && substs.regions.is_empty() {\n                 if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n                     return true;\n                 }"}, {"sha": "9ea738bd326eb7f18bf75d468433e935cc2c3989", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -36,7 +36,7 @@ use super::util;\n use hir::def_id::DefId;\n use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n-use ty::subst::{Subst, Substs, TypeSpace};\n+use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n@@ -1936,7 +1936,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def, substs) if def.is_phantom_data() => {\n-                substs.types.as_full_slice().to_vec()\n+                substs.types.to_vec()\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n@@ -2585,11 +2585,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitVector::new(substs_a.types.len(TypeSpace));\n+                let mut ty_params = BitVector::new(substs_a.types.len());\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n-                        assert!(p.space == TypeSpace);\n                         ty_params.insert(p.idx as usize);\n                         found = true;\n                     }\n@@ -2602,13 +2601,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let types = substs_a.types.map_enumerated(|(_, i, ty)| {\n+                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n                     if ty_params.contains(i) {\n                         tcx.types.err\n                     } else {\n                         ty\n                     }\n-                });\n+                }).collect();\n                 let substs = Substs::new(tcx, types, substs_a.regions.clone());\n                 for &ty in fields.split_last().unwrap().1 {\n                     if ty.subst(tcx, substs).references_error() {\n@@ -2622,13 +2621,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                let types = substs_a.types.map_enumerated(|(_, i, ty)| {\n+                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n                     if ty_params.contains(i) {\n-                        *substs_b.types.get(TypeSpace, i)\n+                        substs_b.types[i]\n                     } else {\n                         ty\n                     }\n-                });\n+                }).collect();\n                 let substs = Substs::new(tcx, types, substs_a.regions.clone());\n                 let new_struct = tcx.mk_struct(def, substs);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);"}, {"sha": "9acfe2754820c9bea7f6988149bd1821d0261f61", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -44,11 +44,10 @@ pub struct OverlapError {\n /// When we have selected one impl, but are actually using item definitions from\n /// a parent impl providing a default, we need a way to translate between the\n /// type parameters of the two impls. Here the `source_impl` is the one we've\n-/// selected, and `source_substs` is a substitution of its generics (and\n-/// possibly some relevant `FnSpace` variables as well). And `target_node` is\n-/// the impl/trait we're actually going to get the definition from. The resulting\n-/// substitution will map from `target_node`'s generics to `source_impl`'s\n-/// generics as instantiated by `source_subst`.\n+/// selected, and `source_substs` is a substitution of its generics.\n+/// And `target_node` is the impl/trait we're actually going to get the\n+/// definition from. The resulting substitution will map from `target_node`'s\n+/// generics to `source_impl`'s generics as instantiated by `source_subst`.\n ///\n /// For example, consider the following scenario:\n ///"}, {"sha": "3501dd484608786b7a7a3403eae02852a0e9ca18", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -23,7 +23,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n-use ty::subst::{self, Substs};\n+use ty::subst::Substs;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants};\n@@ -1346,18 +1346,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_param(self,\n-                    space: subst::ParamSpace,\n                     index: u32,\n                     name: Name) -> Ty<'tcx> {\n-        self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n+        self.mk_ty(TyParam(ParamTy { idx: index, name: name }))\n     }\n \n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_param(subst::TypeSpace, 0, keywords::SelfType.name())\n+        self.mk_param(0, keywords::SelfType.name())\n     }\n \n     pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        self.mk_param(def.space, def.index, def.name)\n+        self.mk_param(def.index, def.name)\n     }\n \n     pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {"}, {"sha": "c6c37296e9e1242f82ace140e67d388dd8992e9d", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -208,8 +208,8 @@ impl FlagComputation {\n     }\n \n     fn add_substs(&mut self, substs: &Substs) {\n-        self.add_tys(substs.types.as_full_slice());\n-        for &r in substs.regions.as_full_slice() {\n+        self.add_tys(&substs.types);\n+        for &r in &substs.regions {\n             self.add_region(r);\n         }\n     }"}, {"sha": "1f747ddfb295971c13e4a57de31e1fd1ce93ad31", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -28,7 +28,7 @@ use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangIte\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n use ty;\n-use ty::subst::{Subst, Substs, VecPerParamSpace};\n+use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n@@ -426,15 +426,15 @@ pub struct AssociatedType<'tcx> {\n \n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n-    pub types: VecPerParamSpace<Variance>,\n-    pub regions: VecPerParamSpace<Variance>,\n+    pub types: Vec<Variance>,\n+    pub regions: Vec<Variance>,\n }\n \n impl ItemVariances {\n     pub fn empty() -> ItemVariances {\n         ItemVariances {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n+            types: vec![],\n+            regions: vec![],\n         }\n     }\n }\n@@ -723,7 +723,6 @@ pub enum ObjectLifetimeDefault {\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n-    pub space: subst::ParamSpace,\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n@@ -734,15 +733,13 @@ pub struct TypeParameterDef<'tcx> {\n pub struct RegionParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n-    pub space: subst::ParamSpace,\n     pub index: u32,\n     pub bounds: Vec<ty::Region>,\n }\n \n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            space: self.space,\n             index: self.index,\n             name: self.name,\n         })\n@@ -812,7 +809,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n-    /// would be the parameters in the `TypeSpace`.\n+    /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n     /// A predicate created by RFC1592\n@@ -837,9 +834,9 @@ pub enum Predicate<'tcx> {\n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n-    /// No direct syntax. May be thought of as `where T : FnFoo<...>` for some 'TypeSpace'\n-    /// substitutions `...` and T being a closure type.  Satisfied (or refuted) once we know the\n-    /// closure's kind.\n+    /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n+    /// for some substitutions `...` and T being a closure type.\n+    /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureKind),\n }\n \n@@ -975,7 +972,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n-        self.trait_ref.substs.types.as_full_slice()\n+        &self.trait_ref.substs.types\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1117,7 +1114,7 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n         let vec: Vec<_> = match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.0.trait_ref.substs.types.as_full_slice().to_vec()\n+                data.0.trait_ref.input_types().to_vec()\n             }\n             ty::Predicate::Rfc1592(ref data) => {\n                 return data.walk_tys()\n@@ -1132,8 +1129,7 @@ impl<'tcx> Predicate<'tcx> {\n                 vec![]\n             }\n             ty::Predicate::Projection(ref data) => {\n-                let trait_inputs = data.0.projection_ty.trait_ref.substs\n-                                       .types.as_full_slice();\n+                let trait_inputs = data.0.projection_ty.trait_ref.input_types();\n                 trait_inputs.iter()\n                             .cloned()\n                             .chain(Some(data.0.ty))\n@@ -1217,15 +1213,15 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        *self.substs.types.get(subst::TypeSpace, 0)\n+        self.substs.types[0]\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        self.substs.types.as_full_slice()\n+        &self.substs.types\n     }\n }\n "}, {"sha": "abf863f953664258de01fbcbf4f0ba40b8603922", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -146,41 +146,18 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n-    let mut result = Ok(());\n-\n-    let types = a_subst.types.map_enumerated(|(space, i, a_ty)| {\n-        if result.is_err() { return tcx.types.err; }\n-\n-        let b_ty = b_subst.types.get(space, i);\n-        let variance = variances.map_or(ty::Invariant, |v| {\n-            *v.types.get(space, i)\n-        });\n-        match relation.relate_with_variance(variance, a_ty, b_ty) {\n-            Ok(ty) => ty,\n-            Err(e) => {\n-                result = Err(e);\n-                tcx.types.err\n-            }\n-        }\n-    });\n-    result?;\n-\n-    let regions = a_subst.regions.map_enumerated(|(space, i, a_r)| {\n-        if result.is_err() { return ty::ReStatic; }\n-\n-        let b_r = b_subst.regions.get(space, i);\n-        let variance = variances.map_or(ty::Invariant, |v| {\n-            *v.regions.get(space, i)\n-        });\n-        match relation.relate_with_variance(variance, a_r, b_r) {\n-            Ok(r) => r,\n-            Err(e) => {\n-                result = Err(e);\n-                ty::ReStatic\n-            }\n-        }\n-    });\n-    result?;\n+\n+    let types = a_subst.types.iter().enumerate().map(|(i, a_ty)| {\n+        let b_ty = &b_subst.types[i];\n+        let variance = variances.map_or(ty::Invariant, |v| v.types[i]);\n+        relation.relate_with_variance(variance, a_ty, b_ty)\n+    }).collect()?;\n+\n+    let regions = a_subst.regions.iter().enumerate().map(|(i, a_r)| {\n+        let b_r = &b_subst.regions[i];\n+        let variance = variances.map_or(ty::Invariant, |v| v.regions[i]);\n+        relation.relate_with_variance(variance, a_r, b_r)\n+    }).collect()?;\n \n     Ok(Substs::new(tcx, types, regions))\n }\n@@ -433,7 +410,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         }\n \n         (&ty::TyParam(ref a_p), &ty::TyParam(ref b_p))\n-            if a_p.idx == b_p.idx && a_p.space == b_p.space =>\n+            if a_p.idx == b_p.idx =>\n         {\n             Ok(a)\n         }"}, {"sha": "f7c4b9938c2794da4c37b619277b6346dd2dee9a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use infer::type_variable;\n-use ty::subst::{Substs, VecPerParamSpace};\n+use ty::subst::Substs;\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n@@ -450,16 +450,6 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.map(|elem| elem.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.as_full_slice().iter().any(|elem| elem.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitObject {\n@@ -780,7 +770,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n         ty::TypeParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n-            space: self.space,\n             index: self.index,\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n@@ -821,7 +810,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n-            space: self.space,\n             index: self.index,\n             bounds: self.bounds.fold_with(folder),\n         }"}, {"sha": "8aa81cc4743c9a639c598863af8fd956f5986215", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -13,7 +13,7 @@\n use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n-use ty::subst::{self, Substs};\n+use ty::subst::Substs;\n use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n use util::common::ErrorReported;\n \n@@ -304,8 +304,8 @@ pub struct TraitObject<'tcx> {\n ///     T : Foo<U>\n ///\n /// This would be represented by a trait-reference where the def-id is the\n-/// def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n-/// `TypeSpace` and `U` as parameter 1 in the `TypeSpace`.\n+/// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n+/// and `U` as parameter 1.\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n@@ -365,7 +365,7 @@ impl<'tcx> ExistentialTraitRef<'tcx> {\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        self.substs.types.as_full_slice()\n+        &self.substs.types\n     }\n }\n \n@@ -498,34 +498,29 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ParamTy {\n-    pub space: subst::ParamSpace,\n     pub idx: u32,\n     pub name: Name,\n }\n \n impl<'a, 'gcx, 'tcx> ParamTy {\n-    pub fn new(space: subst::ParamSpace,\n-               index: u32,\n-               name: Name)\n-               -> ParamTy {\n-        ParamTy { space: space, idx: index, name: name }\n+    pub fn new(index: u32, name: Name) -> ParamTy {\n+        ParamTy { idx: index, name: name }\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::TypeSpace, 0, keywords::SelfType.name())\n+        ParamTy::new(0, keywords::SelfType.name())\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n-        ParamTy::new(def.space, def.index, def.name)\n+        ParamTy::new(def.index, def.name)\n     }\n \n     pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.mk_param(self.space, self.idx, self.name)\n+        tcx.mk_param(self.idx, self.name)\n     }\n \n     pub fn is_self(&self) -> bool {\n         if self.name == keywords::SelfType.name() {\n-            assert_eq!(self.space, subst::TypeSpace);\n             assert_eq!(self.idx, 0);\n             true\n         } else {\n@@ -682,7 +677,6 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub space: subst::ParamSpace,\n     pub index: u32,\n     pub name: Name,\n }\n@@ -951,9 +945,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_bool(&self) -> bool { self.sty == TyBool }\n \n-    pub fn is_param(&self, space: subst::ParamSpace, index: u32) -> bool {\n+    pub fn is_param(&self, index: u32) -> bool {\n         match self.sty {\n-            ty::TyParam(ref data) => data.space == space && data.idx == index,\n+            ty::TyParam(ref data) => data.idx == index,\n             _ => false,\n         }\n     }\n@@ -1219,19 +1213,19 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             TyTrait(ref obj) => {\n                 let mut v = vec![obj.region_bound];\n-                v.extend_from_slice(obj.principal.skip_binder().substs.regions.as_full_slice());\n+                v.extend_from_slice(&obj.principal.skip_binder().substs.regions);\n                 v\n             }\n             TyEnum(_, substs) |\n             TyStruct(_, substs) |\n             TyAnon(_, substs) => {\n-                substs.regions.as_full_slice().to_vec()\n+                substs.regions.to_vec()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions.as_full_slice().to_vec()\n+                substs.func_substs.regions.to_vec()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions.as_full_slice().to_vec()\n+                data.trait_ref.substs.regions.to_vec()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "e1a19a7b7992ece6edcae09a1b47a11f422cbaea", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 27, "deletions": 270, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -10,70 +10,44 @@\n \n // Type substitutions.\n \n-pub use self::ParamSpace::*;\n-\n use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n \n use serialize::{Encodable, Encoder, Decodable, Decoder};\n-use std::fmt;\n use syntax_pos::{Span, DUMMY_SP};\n \n ///////////////////////////////////////////////////////////////////////////\n \n-/// A substitution mapping type/region parameters to new values. We\n-/// identify each in-scope parameter by an *index* and a *parameter\n-/// space* (which indices where the parameter is defined; see\n-/// `ParamSpace`).\n+/// A substitution mapping type/region parameters to new values.\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Substs<'tcx> {\n-    pub types: VecPerParamSpace<Ty<'tcx>>,\n-    pub regions: VecPerParamSpace<ty::Region>,\n+    pub types: Vec<Ty<'tcx>>,\n+    pub regions: Vec<ty::Region>,\n }\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               t: VecPerParamSpace<Ty<'tcx>>,\n-               r: VecPerParamSpace<ty::Region>)\n+               t: Vec<Ty<'tcx>>,\n+               r: Vec<ty::Region>)\n                -> &'tcx Substs<'tcx>\n     {\n         tcx.mk_substs(Substs { types: t, regions: r })\n     }\n \n-    pub fn new_fn(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                  t: Vec<Ty<'tcx>>,\n-                  r: Vec<ty::Region>)\n-                  -> &'tcx Substs<'tcx>\n-    {\n-        Substs::new(tcx, VecPerParamSpace::new(vec![], t),\n-                    VecPerParamSpace::new(vec![], r))\n-    }\n-\n-    pub fn new_type(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    t: Vec<Ty<'tcx>>,\n-                    r: Vec<ty::Region>)\n-                    -> &'tcx Substs<'tcx>\n-    {\n-        Substs::new(tcx, VecPerParamSpace::new(t, vec![]),\n-                    VecPerParamSpace::new(r, vec![]))\n-    }\n-\n     pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      mut t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n                      s: Ty<'tcx>)\n                     -> &'tcx Substs<'tcx>\n     {\n         t.insert(0, s);\n-        Substs::new(tcx, VecPerParamSpace::new(t, vec![]),\n-                    VecPerParamSpace::new(r, vec![]))\n+        Substs::new(tcx, t, r)\n     }\n \n     pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n-        Substs::new(tcx, VecPerParamSpace::empty(),\n-                    VecPerParamSpace::empty())\n+        Substs::new(tcx, vec![], vec![])\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n@@ -92,14 +66,8 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         let num_regions = defs.parent_regions as usize + defs.regions.len();\n         let num_types = defs.parent_types as usize + defs.types.len();\n         let mut substs = Substs {\n-            regions: VecPerParamSpace {\n-                type_limit: 0,\n-                content: Vec::with_capacity(num_regions)\n-            },\n-            types: VecPerParamSpace {\n-                type_limit: 0,\n-                content: Vec::with_capacity(num_types)\n-            }\n+            regions: Vec::with_capacity(num_regions),\n+            types: Vec::with_capacity(num_types)\n         };\n \n         substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n@@ -121,22 +89,14 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n         for def in &defs.regions {\n             let region = mk_region(def, self);\n-            self.regions.content.push(region);\n-\n-            if def.space == TypeSpace {\n-                self.regions.type_limit += 1;\n-                assert_eq!(self.regions.content.len(), self.regions.type_limit);\n-            }\n+            assert_eq!(def.index as usize, self.regions.len());\n+            self.regions.push(region);\n         }\n \n         for def in &defs.types {\n             let ty = mk_type(def, self);\n-            self.types.content.push(ty);\n-\n-            if def.space == TypeSpace {\n-                self.types.type_limit += 1;\n-                assert_eq!(self.types.content.len(), self.types.type_limit);\n-            }\n+            assert_eq!(def.index as usize, self.types.len());\n+            self.types.push(ty);\n         }\n     }\n \n@@ -145,11 +105,11 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n+        self.types[ty_param_def.index as usize]\n     }\n \n     pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region {\n-        *self.regions.get(def.space, def.index as usize)\n+        self.regions[def.index as usize]\n     }\n \n     /// Transform from substitutions for a child of `source_ancestor`\n@@ -162,14 +122,10 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        assert_eq!(self.types.len(TypeSpace), defs.types.len());\n-        assert_eq!(target_substs.types.len(FnSpace), 0);\n-        assert_eq!(self.regions.len(TypeSpace), defs.regions.len());\n-        assert_eq!(target_substs.regions.len(FnSpace), 0);\n-\n-        let Substs { mut types, mut regions } = target_substs.clone();\n-        types.content.extend(&self.types.as_full_slice()[defs.types.len()..]);\n-        regions.content.extend(&self.regions.as_full_slice()[defs.regions.len()..]);\n+        let regions = target_substs.regions.iter()\n+            .chain(&self.regions[defs.regions.len()..]).cloned().collect();\n+        let types = target_substs.types.iter()\n+            .chain(&self.types[defs.types.len()..]).cloned().collect();\n         Substs::new(tcx, types, regions)\n     }\n }\n@@ -193,200 +149,6 @@ impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// ParamSpace\n-\n-#[derive(PartialOrd, Ord, PartialEq, Eq, Copy,\n-           Clone, Hash, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ParamSpace {\n-    TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n-    FnSpace,    // Type parameters attached to a method or fn\n-}\n-\n-impl ParamSpace {\n-    pub fn all() -> [ParamSpace; 2] {\n-        [TypeSpace, FnSpace]\n-    }\n-\n-    pub fn to_uint(self) -> usize {\n-        match self {\n-            TypeSpace => 0,\n-            FnSpace => 1,\n-        }\n-    }\n-\n-    pub fn from_uint(u: usize) -> ParamSpace {\n-        match u {\n-            0 => TypeSpace,\n-            1 => FnSpace,\n-            _ => bug!(\"Invalid ParamSpace: {}\", u)\n-        }\n-    }\n-}\n-\n-/// Vector of things sorted by param space. Used to keep\n-/// the set of things declared on the type, self, or method\n-/// distinct.\n-#[derive(PartialEq, Eq, Clone, Hash, RustcEncodable, RustcDecodable)]\n-pub struct VecPerParamSpace<T> {\n-    // This was originally represented as a tuple with one Vec<T> for\n-    // each variant of ParamSpace, and that remains the abstraction\n-    // that it provides to its clients.\n-    //\n-    // Here is how the representation corresponds to the abstraction\n-    // i.e. the \"abstraction function\" AF:\n-    //\n-    // AF(self) = (self.content[..self.type_limit],\n-    //             self.content[self.type_limit..])\n-    type_limit: usize,\n-    content: Vec<T>,\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"[{:?};{:?}]\",\n-               self.get_slice(TypeSpace),\n-               self.get_slice(FnSpace))\n-    }\n-}\n-\n-impl<T> VecPerParamSpace<T> {\n-    fn limits(&self, space: ParamSpace) -> (usize, usize) {\n-        match space {\n-            TypeSpace => (0, self.type_limit),\n-            FnSpace => (self.type_limit, self.content.len()),\n-        }\n-    }\n-\n-    pub fn empty() -> VecPerParamSpace<T> {\n-        VecPerParamSpace {\n-            type_limit: 0,\n-            content: Vec::new()\n-        }\n-    }\n-\n-    /// `t` is the type space.\n-    /// `f` is the fn space.\n-    pub fn new(t: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n-        let type_limit = t.len();\n-\n-        let mut content = t;\n-        content.extend(f);\n-\n-        VecPerParamSpace {\n-            type_limit: type_limit,\n-            content: content,\n-        }\n-    }\n-\n-    fn new_internal(content: Vec<T>, type_limit: usize) -> VecPerParamSpace<T> {\n-        VecPerParamSpace {\n-            type_limit: type_limit,\n-            content: content,\n-        }\n-    }\n-\n-    pub fn len(&self, space: ParamSpace) -> usize {\n-        self.get_slice(space).len()\n-    }\n-\n-    pub fn is_empty_in(&self, space: ParamSpace) -> bool {\n-        self.len(space) == 0\n-    }\n-\n-    pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n-        let (start, limit) = self.limits(space);\n-        &self.content[start.. limit]\n-    }\n-\n-    pub fn get<'a>(&'a self, space: ParamSpace, index: usize) -> &'a T {\n-        &self.get_slice(space)[index]\n-    }\n-\n-    pub fn iter_enumerated<'a>(&'a self) -> EnumeratedItems<'a,T> {\n-        EnumeratedItems::new(self)\n-    }\n-\n-    pub fn as_full_slice(&self) -> &[T] {\n-        &self.content\n-    }\n-\n-    pub fn all<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n-        self.as_full_slice().iter().all(pred)\n-    }\n-\n-    pub fn any<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n-        self.as_full_slice().iter().any(pred)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.content.is_empty()\n-    }\n-\n-    pub fn map<U, P>(&self, pred: P) -> VecPerParamSpace<U> where P: FnMut(&T) -> U {\n-        let result = self.as_full_slice().iter().map(pred).collect();\n-        VecPerParamSpace::new_internal(result, self.type_limit)\n-    }\n-\n-    pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n-        P: FnMut((ParamSpace, usize, &T)) -> U,\n-    {\n-        let result = self.iter_enumerated().map(pred).collect();\n-        VecPerParamSpace::new_internal(result, self.type_limit)\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct EnumeratedItems<'a,T:'a> {\n-    vec: &'a VecPerParamSpace<T>,\n-    space_index: usize,\n-    elem_index: usize\n-}\n-\n-impl<'a,T> EnumeratedItems<'a,T> {\n-    fn new(v: &'a VecPerParamSpace<T>) -> EnumeratedItems<'a,T> {\n-        let mut result = EnumeratedItems { vec: v, space_index: 0, elem_index: 0 };\n-        result.adjust_space();\n-        result\n-    }\n-\n-    fn adjust_space(&mut self) {\n-        let spaces = ParamSpace::all();\n-        while\n-            self.space_index < spaces.len() &&\n-            self.elem_index >= self.vec.len(spaces[self.space_index])\n-        {\n-            self.space_index += 1;\n-            self.elem_index = 0;\n-        }\n-    }\n-}\n-\n-impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n-    type Item = (ParamSpace, usize, &'a T);\n-\n-    fn next(&mut self) -> Option<(ParamSpace, usize, &'a T)> {\n-        let spaces = ParamSpace::all();\n-        if self.space_index < spaces.len() {\n-            let space = spaces[self.space_index];\n-            let index = self.elem_index;\n-            let item = self.vec.get(space, index);\n-\n-            self.elem_index += 1;\n-            self.adjust_space();\n-\n-            Some((space, index, item))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.vec.as_full_slice().len();\n-        (size, Some(size))\n-    }\n-}\n-\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -461,7 +223,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match r {\n             ty::ReEarlyBound(data) => {\n-                match self.substs.regions.get_slice(data.space).get(data.index as usize) {\n+                match self.substs.regions.get(data.index as usize) {\n                     Some(&r) => {\n                         self.shift_region_through_binders(r)\n                     }\n@@ -471,10 +233,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n                             span,\n                             \"Region parameter out of range \\\n                              when substituting in region {} (root type={:?}) \\\n-                             (space={:?}, index={})\",\n+                             (index={})\",\n                             data.name,\n                             self.root_ty,\n-                            data.space,\n                             data.index);\n                     }\n                 }\n@@ -517,18 +278,17 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.get_slice(p.space).get(p.idx as usize);\n+        let opt_ty = self.substs.types.get(p.idx as usize);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n                     span,\n-                    \"Type parameter `{:?}` ({:?}/{:?}/{}) out of range \\\n+                    \"Type parameter `{:?}` ({:?}/{}) out of range \\\n                          when substituting (root type={:?}) substs={:?}\",\n                     p,\n                     source_ty,\n-                    p.space,\n                     p.idx,\n                     self.root_ty,\n                     self.substs);\n@@ -606,10 +366,9 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        trait_id: DefId,\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n-        let Substs { mut types, mut regions } = substs.clone();\n         let defs = tcx.lookup_generics(trait_id);\n-        types.content.truncate(defs.types.len());\n-        regions.content.truncate(defs.regions.len());\n+        let regions = substs.regions[..defs.regions.len()].to_vec();\n+        let types = substs.types[..defs.types.len()].to_vec();\n \n         ty::TraitRef {\n             def_id: trait_id,\n@@ -624,8 +383,7 @@ impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n                          -> ty::ExistentialTraitRef<'tcx> {\n         let Substs { mut types, regions } = trait_ref.substs.clone();\n \n-        types.type_limit -= 1;\n-        types.content.remove(0);\n+        types.remove(0);\n \n         ty::ExistentialTraitRef {\n             def_id: trait_ref.def_id,\n@@ -648,8 +406,7 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n         self.map_bound(|trait_ref| {\n             let Substs { mut types, regions } = trait_ref.substs.clone();\n \n-            types.type_limit += 1;\n-            types.content.insert(0, self_ty);\n+            types.insert(0, self_ty);\n \n             ty::TraitRef {\n                 def_id: trait_ref.def_id,"}, {"sha": "51710c13a7deacb9f389d0735be5376747d6784f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -476,7 +476,6 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n                 self.hash(tys.len());\n             }\n             TyParam(p) => {\n-                self.hash(p.space);\n                 self.hash(p.idx);\n                 self.hash(p.name.as_str());\n             }\n@@ -694,8 +693,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         return false;\n                     }\n \n-                    let types_a = substs_a.types.as_full_slice();\n-                    let types_b = substs_b.types.as_full_slice();\n+                    let types_a = &substs_a.types;\n+                    let types_b = &substs_b.types;\n \n                     types_a.iter().zip(types_b).all(|(&a, &b)| same_type(a, b))\n                 }"}, {"sha": "8a9ee45351dfc26c73813eb2835e8e368570f9a9", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -79,7 +79,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.push(mt.ty);\n         }\n         ty::TyProjection(ref data) => {\n-            push_reversed(stack, data.trait_ref.substs.types.as_full_slice());\n+            push_reversed(stack, &data.trait_ref.substs.types);\n         }\n         ty::TyTrait(ref obj) => {\n             push_reversed(stack, obj.principal.input_types());\n@@ -90,17 +90,17 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         ty::TyEnum(_, ref substs) |\n         ty::TyStruct(_, ref substs) |\n         ty::TyAnon(_, ref substs) => {\n-            push_reversed(stack, substs.types.as_full_slice());\n+            push_reversed(stack, &substs.types);\n         }\n         ty::TyClosure(_, ref substs) => {\n-            push_reversed(stack, substs.func_substs.types.as_full_slice());\n+            push_reversed(stack, &substs.func_substs.types);\n             push_reversed(stack, &substs.upvar_tys);\n         }\n         ty::TyTuple(ref ts) => {\n             push_reversed(stack, ts);\n         }\n         ty::TyFnDef(_, substs, ref ft) => {\n-            push_reversed(stack, substs.types.as_full_slice());\n+            push_reversed(stack, &substs.types);\n             push_sig_subtypes(stack, &ft.sig);\n         }\n         ty::TyFnPtr(ref ft) => {"}, {"sha": "54b19362b1d86e43afd1b1c36b5a089f95b374c2", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -261,7 +261,6 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         self.out.extend(\n             trait_ref.substs.types\n-                            .as_full_slice()\n                             .iter()\n                             .filter(|ty| !ty.has_escaping_regions())\n                             .map(|ty| traits::Obligation::new(cause.clone(),"}, {"sha": "02ad8fb7033ed2d50d9900bf2fe2d42864cd9748", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -56,7 +56,7 @@ fn fn_sig(f: &mut fmt::Formatter,\n }\n \n /// Namespace of the path given to parameterized to print.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Ns {\n     Type,\n     Value\n@@ -71,16 +71,43 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     let mut verbose = false;\n     let mut num_supplied_defaults = 0;\n     let mut has_self = false;\n-    let (fn_trait_kind, item_name) = ty::tls::with(|tcx| {\n-        verbose = tcx.sess.verbose();\n+    let mut num_regions = 0;\n+    let mut num_types = 0;\n+    let mut item_name = None;\n+    let fn_trait_kind = ty::tls::with(|tcx| {\n         let mut generics = tcx.lookup_generics(did);\n+        let mut path_def_id = did;\n+        verbose = tcx.sess.verbose();\n+        has_self = generics.has_self;\n+\n         if let Some(def_id) = generics.parent {\n+            // Methods.\n+            assert_eq!(ns, Ns::Value);\n             generics = tcx.lookup_generics(def_id);\n+            num_regions = generics.regions.len();\n+            num_types = generics.types.len();\n+\n+            if has_self {\n+                write!(f, \"<{} as \", substs.types[0])?;\n+            }\n+\n+            item_name = Some(tcx.item_name(did));\n+            path_def_id = def_id;\n+        } else {\n+            if ns == Ns::Value {\n+                // Functions.\n+                assert_eq!(has_self, false);\n+            } else {\n+                // Types and traits.\n+                num_regions = generics.regions.len();\n+                num_types = generics.types.len();\n+            }\n         }\n+\n         if !verbose {\n             if generics.types.last().map_or(false, |def| def.default.is_some()) {\n                 if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = substs.types.get_slice(subst::TypeSpace);\n+                    let tps = &substs.types[..num_types];\n                     for (def, actual) in generics.types.iter().zip(tps).rev() {\n                         if def.default.subst(tcx, substs) != Some(actual) {\n                             break;\n@@ -91,31 +118,13 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             }\n         }\n \n-        has_self = generics.has_self;\n-        if ns == Ns::Value && has_self {\n-            write!(f, \"<{} as \", substs.types.get(subst::TypeSpace, 0))?;\n-        }\n-\n-        let (did, item_name) = if ns == Ns::Value {\n-            // Try to get the impl/trait parent, if this is an\n-            // associated value item (method or constant).\n-            tcx.trait_of_item(did).or_else(|| {\n-                // An impl could be a trait impl or an inherent one.\n-                tcx.impl_of_method(did).map(|impl_def_id| {\n-                    tcx.trait_id_of_impl(impl_def_id)\n-                       .unwrap_or(impl_def_id)\n-                })\n-            }).map_or((did, None), |parent| (parent, Some(tcx.item_name(did))))\n-        } else {\n-            (did, None)\n-        };\n-        write!(f, \"{}\", tcx.item_path_str(did))?;\n-        Ok((tcx.lang_items.fn_trait_kind(did), item_name))\n+        write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n+        Ok(tcx.lang_items.fn_trait_kind(path_def_id))\n     })?;\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.types.get(subst::TypeSpace, 1).sty {\n+        if let TyTuple(ref args) = substs.types[1].sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -158,9 +167,9 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         Ok(())\n     };\n \n-    print_regions(f, \"<\", substs.regions.get_slice(subst::TypeSpace))?;\n+    print_regions(f, \"<\", &substs.regions[..num_regions])?;\n \n-    let tps = substs.types.get_slice(subst::TypeSpace);\n+    let tps = &substs.types[..num_types];\n \n     for &ty in &tps[has_self as usize..tps.len() - num_supplied_defaults] {\n         start_or_continue(f, \"<\", \", \")?;\n@@ -188,10 +197,10 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             write!(f, \"::{}\", item_name)?;\n         }\n \n-        print_regions(f, \"::<\", substs.regions.get_slice(subst::FnSpace))?;\n+        print_regions(f, \"::<\", &substs.regions[num_regions..])?;\n \n         // FIXME: consider being smart with defaults here too\n-        for ty in substs.types.get_slice(subst::FnSpace) {\n+        for ty in &substs.types[num_types..] {\n             start_or_continue(f, \"::<\", \", \")?;\n             write!(f, \"{}\", ty)?;\n         }\n@@ -328,19 +337,19 @@ impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeParameterDef({}, {:?}, {:?}/{})\",\n+        write!(f, \"TypeParameterDef({}, {:?}, {})\",\n                self.name,\n                self.def_id,\n-               self.space, self.index)\n+               self.index)\n     }\n }\n \n impl fmt::Debug for ty::RegionParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {:?}, {:?}/{}, {:?})\",\n+        write!(f, \"RegionParameterDef({}, {:?}, {}, {:?})\",\n                self.name,\n                self.def_id,\n-               self.space, self.index,\n+               self.index,\n                self.bounds)\n     }\n }\n@@ -526,8 +535,7 @@ impl fmt::Debug for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({:?}, {}, {})\",\n-                       data.space,\n+                write!(f, \"ReEarlyBound({}, {})\",\n                        data.index,\n                        data.name)\n             }\n@@ -1011,7 +1019,7 @@ impl fmt::Display for ty::ParamTy {\n \n impl fmt::Debug for ty::ParamTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}/{:?}.{}\", self, self.space, self.idx)\n+        write!(f, \"{}/#{}\", self, self.idx)\n     }\n }\n "}, {"sha": "111646912ade30998060c70694305ce1dcbe5b8f", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -859,7 +859,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-        let substs = Substs::new_fn(tcx, vec![ty], vec![]);\n+        let substs = Substs::new(tcx, vec![ty], vec![]);\n         let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {"}, {"sha": "32d0bbbfdb6b7d8e179542345e71af35580856e2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -20,7 +20,6 @@ use rustc::middle::region::{self, CodeExtent};\n use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n-use rustc::ty::subst;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -276,19 +275,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_tup(vec![ty1, ty2])\n     }\n \n-    pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n+    pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(space, index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self,\n-                          space: subst::ParamSpace,\n                           index: u32,\n                           name: &'static str)\n                           -> ty::Region {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            space: space,\n             index: index,\n             name: name,\n         })\n@@ -674,11 +671,11 @@ fn subst_ty_renumber_bound() {\n \n         // t_source = fn(A)\n         let t_source = {\n-            let t_param = env.t_param(subst::TypeSpace, 0);\n+            let t_param = env.t_param(0);\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = Substs::new_type(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n@@ -709,11 +706,11 @@ fn subst_ty_renumber_some_bounds() {\n \n         // t_source = (A, fn(A))\n         let t_source = {\n-            let t_param = env.t_param(subst::TypeSpace, 0);\n+            let t_param = env.t_param(0);\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = Substs::new_type(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n@@ -755,7 +752,7 @@ fn escaping() {\n         assert!(t_rptr_bound2.has_escaping_regions());\n \n         // t_fn = fn(A)\n-        let t_param = env.t_param(subst::TypeSpace, 0);\n+        let t_param = env.t_param(0);\n         assert!(!t_param.has_escaping_regions());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n         assert!(!t_fn.has_escaping_regions());\n@@ -771,11 +768,11 @@ fn subst_region_renumber_region() {\n \n         // type t_source<'a> = fn(&'a isize)\n         let t_source = {\n-            let re_early = env.re_early_bound(subst::TypeSpace, 0, \"'a\");\n+            let re_early = env.re_early_bound(0, \"'a\");\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = Substs::new_type(env.infcx.tcx, vec![], vec![re_bound1]);\n+        let substs = Substs::new(env.infcx.tcx, vec![], vec![re_bound1]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)"}, {"sha": "c76cf2363923741b12a2db7c2e1421fe2fe61c78", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -20,7 +20,7 @@ use rustc::hir;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::region;\n-use rustc::ty::subst::{self, Substs, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n@@ -128,23 +128,19 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    fn parse_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n-        F: FnMut(&mut TyDecoder<'a, 'tcx>) -> T,\n-    {\n-        let (mut a, mut b) =  (vec![], vec![]);\n-        for r in &mut [&mut a, &mut b] {\n-            assert_eq!(self.next(), '[');\n-            while self.peek() != ']' {\n-                r.push(f(self));\n-            }\n-            assert_eq!(self.next(), ']');\n+    pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n+        let mut regions = vec![];\n+        let mut types = vec![];\n+        assert_eq!(self.next(), '[');\n+        while self.peek() != '|' {\n+            regions.push(self.parse_region());\n         }\n-        VecPerParamSpace::new(a, b)\n-    }\n+        assert_eq!(self.next(), '|');\n+        while self.peek() != ']' {\n+            types.push(self.parse_ty());\n+        }\n+        assert_eq!(self.next(), ']');\n \n-    pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n-        let regions = self.parse_vec_per_param_space(|this| this.parse_region());\n-        let types = self.parse_vec_per_param_space(|this| this.parse_ty());\n         Substs::new(self.tcx, types, regions)\n     }\n \n@@ -155,14 +151,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         let parent_types = self.parse_u32();\n \n         let mut regions = vec![];\n+        let mut types = vec![];\n         assert_eq!(self.next(), '[');\n-        while self.peek() != ']' {\n+        while self.peek() != '|' {\n             regions.push(self.parse_region_param_def());\n         }\n-        assert_eq!(self.next(), ']');\n-\n-        let mut types = vec![];\n-        assert_eq!(self.next(), '[');\n+        assert_eq!(self.next(), '|');\n         while self.peek() != ']' {\n             types.push(self.parse_type_param_def());\n         }\n@@ -225,13 +219,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                let space = self.parse_param_space();\n-                assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    space: space,\n                     index: index,\n                     name: name\n                 })\n@@ -406,10 +397,8 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 assert_eq!(self.next(), '[');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n-                let space = self.parse_param_space();\n-                assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n-                return tcx.mk_param(space, index, name);\n+                return tcx.mk_param(index, name);\n             }\n             '~' => return tcx.mk_box(self.parse_ty()),\n             '*' => return tcx.mk_ptr(self.parse_mt()),\n@@ -552,10 +541,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         m\n     }\n \n-    fn parse_param_space(&mut self) -> subst::ParamSpace {\n-        subst::ParamSpace::from_uint(self.parse_uint())\n-    }\n-\n     fn parse_abi_set(&mut self) -> abi::Abi {\n         assert_eq!(self.next(), '[');\n         let bytes = self.scan(|c| c == ']');\n@@ -656,8 +641,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n-        let space = self.parse_param_space();\n-        assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n         assert_eq!(self.next(), '|');\n         let default_def_id = self.parse_def();\n@@ -667,7 +650,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::TypeParameterDef {\n             name: name,\n             def_id: def_id,\n-            space: space,\n             index: index,\n             default_def_id: default_def_id,\n             default: default,\n@@ -678,8 +660,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n-        let space = self.parse_param_space();\n-        assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n         assert_eq!(self.next(), '|');\n         let mut bounds = vec![];\n@@ -695,7 +675,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::RegionParameterDef {\n             name: name,\n             def_id: def_id,\n-            space: space,\n             index: index,\n             bounds: bounds,\n         }"}, {"sha": "90fd8a0eb2f654f2fa69e25c3b10ab5b426eb831", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -19,8 +19,7 @@ use std::io::prelude::*;\n \n use rustc::hir::def_id::DefId;\n use middle::region;\n-use rustc::ty::subst::{self, Substs, VecPerParamSpace};\n-use rustc::ty::ParamTy;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FnvHashMap;\n \n@@ -163,8 +162,8 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyInfer(_) => {\n             bug!(\"cannot encode inference variable types\");\n         }\n-        ty::TyParam(ParamTy {space, idx, name}) => {\n-            write!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name);\n+        ty::TyParam(p) => {\n+            write!(w, \"p[{}|{}]\", p.idx, p.name);\n         }\n         ty::TyStruct(def, substs) => {\n             write!(w, \"a[{}|\", (cx.ds)(cx.tcx, def.did));\n@@ -249,27 +248,17 @@ fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Cursor<Vec<u8>>,\n-                                           cx: &ctxt<'a, 'tcx>,\n-                                           v: &VecPerParamSpace<T>,\n-                                           mut op: F) where\n-    F: FnMut(&mut Cursor<Vec<u8>>, &ctxt<'a, 'tcx>, &T),\n-{\n-    for &space in &subst::ParamSpace::all() {\n-        write!(w, \"[\");\n-        for t in v.get_slice(space) {\n-            op(w, cx, t);\n-        }\n-        write!(w, \"]\");\n-    }\n-}\n-\n pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                             substs: &Substs<'tcx>) {\n-    enc_vec_per_param_space(w, cx, &substs.regions,\n-                            |w, cx, &r| enc_region(w, cx, r));\n-    enc_vec_per_param_space(w, cx, &substs.types,\n-                            |w, cx, &ty| enc_ty(w, cx, ty));\n+    write!(w, \"[\");\n+    for &r in &substs.regions {\n+        enc_region(w, cx, r);\n+    }\n+    write!(w, \"|\");\n+    for &ty in &substs.types {\n+        enc_ty(w, cx, ty);\n+    }\n+    write!(w, \"]\");\n }\n \n pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n@@ -284,7 +273,7 @@ pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     for r in &generics.regions {\n         enc_region_param_def(w, cx, r)\n     }\n-    write!(w, \"][\");\n+    write!(w, \"|\");\n     for t in &generics.types {\n         enc_type_param_def(w, cx, t);\n     }\n@@ -305,8 +294,7 @@ pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n             write!(w, \"]\");\n         }\n         ty::ReEarlyBound(ref data) => {\n-            write!(w, \"B[{}|{}|{}]\",\n-                   data.space.to_uint(),\n+            write!(w, \"B[{}|{}]\",\n                    data.index,\n                    data.name);\n         }\n@@ -446,18 +434,17 @@ fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBound\n \n fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                 v: &ty::TypeParameterDef<'tcx>) {\n-    write!(w, \"{}:{}|{}|{}|{}|\",\n-             v.name, (cx.ds)(cx.tcx, v.def_id),\n-             v.space.to_uint(), v.index, (cx.ds)(cx.tcx, v.default_def_id));\n+    write!(w, \"{}:{}|{}|{}|\",\n+           v.name, (cx.ds)(cx.tcx, v.def_id),\n+           v.index, (cx.ds)(cx.tcx, v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n                         v: &ty::RegionParameterDef) {\n-    write!(w, \"{}:{}|{}|{}|\",\n-             v.name, (cx.ds)(cx.tcx, v.def_id),\n-             v.space.to_uint(), v.index);\n+    write!(w, \"{}:{}|{}|\",\n+           v.name, (cx.ds)(cx.tcx, v.def_id), v.index);\n     for &r in &v.bounds {\n         write!(w, \"R\");\n         enc_region(w, cx, r);"}, {"sha": "5e4053a82ad8a3ce22a7c6b093733073d08864e5", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -750,7 +750,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-    let substs = Substs::new_fn(tcx, vec![data.item_ty], vec![]);\n+    let substs = Substs::new(tcx, vec![data.item_ty], vec![]);\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,"}, {"sha": "25a1479c289488c43af1001a3b26db4556300efa", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         // and should not matter anyhow.\n         let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n \n-        let hash = get_symbol_hash(scx, &def_path, instance_ty, substs.types.as_full_slice());\n+        let hash = get_symbol_hash(scx, &def_path, instance_ty, &substs.types);\n \n         let mut buffer = SymbolPathBuffer {\n             names: Vec::with_capacity(def_path.data.len())"}, {"sha": "f505efb1ab2f9aa18e994fbc2f2dbfd4d93acecc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -346,7 +346,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // Add the def-index as the second part\n             output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n-            let tps = substs.types.as_full_slice();\n+            let tps = &substs.types;\n             if !tps.is_empty() {\n                 output.push('<');\n "}, {"sha": "1ee000992b9c59cba899c758850ca1c5e47d1126", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -358,7 +358,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          name_to_append_suffix_to: &mut String)\n                                          -> DIArray\n     {\n-        let actual_types = param_substs.types.as_full_slice();\n+        let actual_types = &param_substs.types;\n \n         if actual_types.is_empty() {\n             return create_DIArray(DIB(cx), &[]);"}, {"sha": "2a996ca75a37e78597be98fafdf760ca2f0d291b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -181,7 +181,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         output.push('<');\n \n-        for &type_parameter in substs.types.as_full_slice() {\n+        for &type_parameter in &substs.types {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }"}, {"sha": "ecee4705510595bc991844e1d79b48882acf5122", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -15,7 +15,7 @@ use intrinsics::{self, Intrinsic};\n use libc;\n use llvm;\n use llvm::{ValueRef, TypeKind};\n-use rustc::ty::subst::{FnSpace, Substs};\n+use rustc::ty::subst::Substs;\n use abi::{Abi, FnType};\n use adt;\n use base::*;\n@@ -136,8 +136,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             callee::ArgExprs(arg_exprs) => {\n                 assert_eq!(arg_exprs.len(), 1);\n \n-                let (in_type, out_type) = (*substs.types.get(FnSpace, 0),\n-                                           *substs.types.get(FnSpace, 1));\n+                let (in_type, out_type) = (substs.types[0],\n+                                           substs.types[1]);\n                 let llintype = type_of::type_of(ccx, in_type);\n                 let llouttype = type_of::type_of(ccx, out_type);\n \n@@ -346,12 +346,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Call(bcx, llfn, &[], call_debug_location)\n         }\n         (_, \"size_of\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         (_, \"size_of_val\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_sized(tcx, tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -362,11 +362,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"min_align_of\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n         (_, \"min_align_of_val\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_sized(tcx, tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -376,12 +376,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"pref_align_of\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n         (_, \"drop_in_place\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let ptr = if type_is_sized(tcx, tp_ty) {\n                 llargs[0]\n             } else {\n@@ -395,22 +395,22 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"type_name\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            C_u64(ccx, ccx.tcx().type_id_hash(*substs.types.get(FnSpace, 0)))\n+            C_u64(ccx, ccx.tcx().type_id_hash(substs.types[0]))\n         }\n         (_, \"init_dropped\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_zero_size(ccx, tp_ty) {\n                 drop_done_fill_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }\n         (_, \"init\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_zero_size(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 init_zero_mem(bcx, llresult, tp_ty);\n@@ -422,7 +422,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"needs_drop\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n \n             C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n@@ -441,7 +441,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            false,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -451,7 +451,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            false,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -460,7 +460,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"write_bytes\") => {\n             memset_intrinsic(bcx,\n                              false,\n-                             *substs.types.get(FnSpace, 0),\n+                             substs.types[0],\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n@@ -471,7 +471,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            true,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -481,7 +481,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            true,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -490,14 +490,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_set_memory\") => {\n             memset_intrinsic(bcx,\n                              true,\n-                             *substs.types.get(FnSpace, 0),\n+                             substs.types[0],\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n                              call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let mut ptr = llargs[0];\n             if let Some(ty) = fn_ty.ret.cast {\n                 ptr = PointerCast(bcx, ptr, ty.ptr_to());\n@@ -509,7 +509,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             to_immediate(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n                 VolatileStore(bcx, llargs[1], expr::get_dataptr(bcx, llargs[0]));\n                 VolatileStore(bcx, llargs[2], expr::get_meta(bcx, llargs[0]));\n@@ -609,10 +609,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         },\n \n         (_, \"discriminant_value\") => {\n-            let val_ty = substs.types.get(FnSpace, 0);\n+            let val_ty = substs.types[0];\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n-                    let repr = adt::represent_type(ccx, *val_ty);\n+                    let repr = adt::represent_type(ccx, val_ty);\n                     adt::trans_get_discr(bcx, &repr, llargs[0],\n                                          Some(llret_ty), true)\n                 }\n@@ -663,7 +663,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n                         let val = AtomicCmpXchg(bcx, llargs[0], llargs[1], llargs[2],\n@@ -682,7 +682,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"load\" => {\n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicLoad(bcx, llargs[0], order)\n                     } else {\n@@ -695,7 +695,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"store\" => {\n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicStore(bcx, llargs[1], llargs[0], order);\n                     } else {\n@@ -734,7 +734,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n                     } else {"}, {"sha": "d1837883aaeb032cbb91328b4013d0f344c3cb92", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -180,7 +180,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n impl<'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n-        assert!(substs.regions.as_full_slice().iter().all(|&r| r == ty::ReErased));\n+        assert!(substs.regions.iter().all(|&r| r == ty::ReErased));\n         Instance { def: def_id, substs: substs }\n     }\n     pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {"}, {"sha": "87d0ea0fe81f30d83b20ac75099a7c0ca098d1d9", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -125,7 +125,6 @@ use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n-use rustc::ty::subst;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher, SipHasher};\n use std::sync::Arc;\n@@ -488,7 +487,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // DefId, we use the location of the impl after all.\n \n             if tcx.trait_of_item(instance.def).is_some() {\n-                let self_ty = *instance.substs.types.get(subst::TypeSpace, 0);\n+                let self_ty = instance.substs.types[0];\n                 // This is an implementation of a trait method.\n                 return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n             }"}, {"sha": "580882e31dd603248fba65ca64b4c96eb6dbefc4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -28,7 +28,7 @@ use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::subst::{Substs, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n@@ -560,7 +560,7 @@ fn push_item_name(tcx: TyCtxt,\n }\n \n fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &'tcx VecPerParamSpace<Ty<'tcx>>,\n+                              types: &[Ty<'tcx>],\n                               projections: &[ty::PolyExistentialProjection<'tcx>],\n                               output: &mut String) {\n     if types.is_empty() && projections.is_empty() {\n@@ -569,7 +569,7 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     output.push('<');\n \n-    for &type_parameter in types.as_full_slice() {\n+    for &type_parameter in types {\n         push_unique_type_name(tcx, type_parameter, output);\n         output.push_str(\", \");\n     }"}, {"sha": "6862002ed83b25a448e2319656cb7610d506b6be", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -256,18 +256,13 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n-          let tps = substs.types.as_full_slice();\n-          let name = llvm_type_name(cx, def.did, tps);\n+          let name = llvm_type_name(cx, def.did, &substs.types);\n           adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n-          // Unboxed closures can have substitutions in all spaces\n-          // inherited from their environment, so we use entire\n-          // contents of the VecPerParamSpace to construct the llvm\n-          // name\n           adt::incomplete_type_of(cx, &repr, \"closure\")\n       }\n \n@@ -335,8 +330,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let tps = substs.types.as_full_slice();\n-              let name = llvm_type_name(cx, def.did, tps);\n+              let name = llvm_type_name(cx, def.did, &substs.types);\n               adt::incomplete_type_of(cx, &repr, &name[..])\n           }\n       }"}, {"sha": "f6984f42cab341301d52864b2b6e691d1e5217ac", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -55,7 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{TypeSpace, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -207,9 +207,8 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                                                   issue_32330))\n         }\n \n-        Some(&rl::DefEarlyBoundRegion(space, index, _)) => {\n+        Some(&rl::DefEarlyBoundRegion(index, _)) => {\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                space: space,\n                 index: index,\n                 name: lifetime.name\n             })\n@@ -473,10 +472,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n-            assert_eq!(def.space, TypeSpace);\n             regions[def.index as usize]\n         }, |def, substs| {\n-            assert!(def.space == TypeSpace);\n             let i = def.index as usize;\n \n             // Handle Self first, so we can adjust the index to match the AST.\n@@ -940,8 +937,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // FIXME(#12938): This is a hack until we have full support for DST.\n         if Some(did) == self.tcx().lang_items.owned_box() {\n-            assert_eq!(substs.types.len(TypeSpace), 1);\n-            return self.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n+            assert_eq!(substs.types.len(), 1);\n+            return self.tcx().mk_box(substs.types[0]);\n         }\n \n         decl_ty.subst(self.tcx(), substs)"}, {"sha": "377ca5eaebe302745e97093c011a20cb5ae1571f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -13,7 +13,6 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n-use rustc::ty::subst;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n use syntax::abi::Abi;\n@@ -204,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n+        let arg_param_ty = trait_ref.substs().types[1];\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n         debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n "}, {"sha": "6bcf21563cb98c919e907e2e4f431660f6cb7b86", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -225,7 +225,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n \n         // This is the only tricky bit of the new way we check implementation methods\n-        // We need to build a set of predicates where only the FnSpace bounds\n+        // We need to build a set of predicates where only the method-level bounds\n         // are from the trait and we assume all other bounds from the implementation\n         // to be previously satisfied.\n         //"}, {"sha": "82545d564a20c807f69fd91e3e7b82d4f877cf2b", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer;\n use middle::region;\n-use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use util::nodemap::FnvHashSet;\n@@ -438,7 +438,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n \n         ty::TyStruct(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n-            let ity = *substs.types.get(subst::TypeSpace, 0);\n+            let ity = substs.types[0];\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }"}, {"sha": "b2873bf686578bed51c985eafd2d4a125a7fdab0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -13,7 +13,7 @@\n \n use intrinsics;\n use rustc::infer::TypeOrigin;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n use {CrateCtxt, require_same_types};\n@@ -70,7 +70,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+        ccx.tcx.mk_param(n, name)\n     }\n \n     let tcx = ccx.tcx;\n@@ -316,7 +316,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                                      it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+        ccx.tcx.mk_param(n, name)\n     };\n \n     let tcx = ccx.tcx;"}, {"sha": "9e0b38fd9fe517a163c9cffcdfce403b394f8b31", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -12,7 +12,7 @@ use super::probe;\n \n use check::{FnCtxt, callee};\n use hir::def_id::DefId;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n@@ -328,18 +328,18 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         //\n         // FIXME -- permit users to manually specify lifetimes\n         Substs::for_item(self.tcx, method.def_id, |def, _| {\n-            if def.space != subst::FnSpace {\n-                substs.region_for_def(def)\n+            if let Some(&r) = substs.regions.get(def.index as usize) {\n+                r\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n-            if def.space != subst::FnSpace {\n-                substs.type_for_def(def)\n+            if let Some(&ty) = substs.types.get(def.index as usize) {\n+                ty\n             } else if supplied_method_types.is_empty() {\n                 self.type_var_for_def(self.span, def, cur_substs)\n             } else {\n-                supplied_method_types[def.index as usize]\n+                supplied_method_types[def.index as usize - substs.types.len()]\n             }\n         })\n     }"}, {"sha": "bcb410e1b8d0132b284ce0932e43cec3f366b85b", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -13,7 +13,7 @@\n use check::FnCtxt;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n@@ -191,7 +191,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n-            assert_eq!(def.space, subst::TypeSpace);\n             if def.index == 0 {\n                 self_ty\n             } else if let Some(ref input_types) = opt_input_types {"}, {"sha": "c306463ec1de0795b7352e6a01cf89a90462543c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -16,7 +16,7 @@ use super::suggest;\n use check::{FnCtxt};\n use hir::def_id::DefId;\n use hir::def::Def;\n-use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n@@ -519,9 +519,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        trait_ref.substs,\n                        m);\n                 assert_eq!(m.generics.parent_types as usize,\n-                           trait_ref.substs.types.len(subst::TypeSpace));\n+                           trait_ref.substs.types.len());\n                 assert_eq!(m.generics.parent_regions as usize,\n-                           trait_ref.substs.regions.len(subst::TypeSpace));\n+                           trait_ref.substs.regions.len());\n             }\n \n             // Because this trait derives from a where-clause, it\n@@ -1220,8 +1220,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types.len(subst::FnSpace), 0);\n-        assert_eq!(substs.regions.len(subst::FnSpace), 0);\n+        assert_eq!(substs.types.len(), method.generics.parent_types as usize);\n+        assert_eq!(substs.regions.len(), method.generics.parent_regions as usize);\n \n         if self.mode == Mode::Path {\n             return impl_ty;\n@@ -1236,16 +1236,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n-                if def.space != subst::FnSpace {\n-                    substs.region_for_def(def)\n+                if let Some(&r) = substs.regions.get(def.index as usize) {\n+                    r\n                 } else {\n                     // In general, during probe we erase regions. See\n                     // `impl_self_ty()` for an explanation.\n                     ty::ReErased\n                 }\n             }, |def, cur_substs| {\n-                if def.space != subst::FnSpace {\n-                    substs.type_for_def(def)\n+                if let Some(&ty) = substs.types.get(def.index as usize) {\n+                    ty\n                 } else {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }"}, {"sha": "e573655b8c9847ffd045a7e07110e0e7109c1130", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -88,7 +88,7 @@ use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -1333,7 +1333,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                   .filter_map(|predicate| {\n                                       match *predicate {\n                                           ty::Predicate::Trait(ref data) => {\n-                                              if data.0.self_ty().is_param(def.space, def.index) {\n+                                              if data.0.self_ty().is_param(def.index) {\n                                                   Some(data.to_poly_trait_ref())\n                                               } else {\n                                                   None\n@@ -1887,7 +1887,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Registers obligations that all types appearing in `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n     {\n-        for &ty in substs.types.as_full_slice() {\n+        for &ty in &substs.types {\n             self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n     }\n@@ -4223,20 +4223,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        self.check_path_parameter_count(subst::TypeSpace,\n-                                        span,\n-                                        !require_type_space,\n-                                        &mut type_segment);\n-        self.check_path_parameter_count(subst::FnSpace,\n-                                        span,\n-                                        true,\n-                                        &mut fn_segment);\n+        self.check_path_parameter_count(span, !require_type_space, &mut type_segment);\n+        self.check_path_parameter_count(span, true, &mut fn_segment);\n \n         let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n-            let i = def.index as usize;\n-            let segment = match def.space {\n-                subst::TypeSpace => type_segment,\n-                subst::FnSpace => fn_segment\n+            let mut i = def.index as usize;\n+            let type_regions = match (type_segment, fn_segment) {\n+                (_, Some((_, generics))) => generics.parent_regions as usize,\n+                (Some((_, generics)), None) => generics.regions.len(),\n+                (None, None) => 0\n+            };\n+\n+            let segment = if i < type_regions {\n+                type_segment\n+            } else {\n+                i -= type_regions;\n+                fn_segment\n             };\n             let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n                 Some(&hir::AngleBracketedParameters(ref data)) => &data.lifetimes[..],\n@@ -4251,42 +4253,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }, |def, substs| {\n             let mut i = def.index as usize;\n-            let segment = match def.space {\n-                subst::TypeSpace => {\n-                    // Handle Self first, so we can adjust the index to match the AST.\n-                    match (type_segment, fn_segment) {\n-                        (Some((_, generics)), _) | (_, Some((_, generics))) => {\n-                            if generics.has_self {\n-                                if i == 0 {\n-                                    return opt_self_ty.unwrap_or_else(|| {\n-                                        self.type_var_for_def(span, def, substs)\n-                                    });\n-                                }\n-                                i -= 1;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                    type_segment\n+            let (type_types, has_self) = match (type_segment, fn_segment) {\n+                (_, Some((_, generics))) => {\n+                    (generics.parent_types as usize, generics.has_self)\n                 }\n-                subst::FnSpace => fn_segment\n+                (Some((_, generics)), None) => {\n+                    (generics.types.len(), generics.has_self)\n+                }\n+                (None, None) => (0, false)\n+            };\n+\n+            let can_omit = i >= type_types || !require_type_space;\n+            let segment = if i < type_types {\n+                // Handle Self first, so we can adjust the index to match the AST.\n+                if has_self && i == 0 {\n+                    return opt_self_ty.unwrap_or_else(|| {\n+                        self.type_var_for_def(span, def, substs)\n+                    });\n+                }\n+                i -= has_self as usize;\n+                type_segment\n+            } else {\n+                i -= type_types;\n+                fn_segment\n             };\n             let types = match segment.map(|(s, _)| &s.parameters) {\n                 Some(&hir::AngleBracketedParameters(ref data)) => &data.types[..],\n                 Some(&hir::ParenthesizedParameters(_)) => bug!(),\n                 None => &[]\n             };\n \n-            let can_omit = def.space != subst::TypeSpace || !require_type_space;\n-            let default = if can_omit && types.len() == 0 {\n-                def.default\n-            } else {\n-                None\n-            };\n+            let omitted = can_omit && types.is_empty();\n             if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n                 self.to_ty(ast_ty)\n-            } else if let Some(default) = default {\n+            } else if let (false, Some(default)) = (omitted, def.default) {\n                 // No type parameter provided, but a default exists.\n                 default.subst_spanned(self.tcx, substs, Some(span))\n             } else {\n@@ -4323,10 +4324,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n             let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n-            assert_eq!(substs.types.len(subst::TypeSpace),\n-                       impl_scheme.generics.types.len());\n-            assert_eq!(substs.regions.len(subst::TypeSpace),\n-                       impl_scheme.generics.regions.len());\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n             match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n@@ -4355,7 +4352,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Report errors if the provided parameters are too few or too many.\n     fn check_path_parameter_count(&self,\n-                                  space: subst::ParamSpace,\n                                   span: Span,\n                                   can_omit: bool,\n                                   segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n@@ -4392,7 +4388,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Check provided type parameters.\n         let type_defs = segment.map_or(&[][..], |(_, generics)| {\n-            if space == subst::TypeSpace {\n+            if generics.parent.is_none() {\n                 &generics.types[generics.has_self as usize..]\n             } else {\n                 &generics.types"}, {"sha": "859d5ff0543d01bcf6f56d0c55bd60c0ad7ea620", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -1445,11 +1445,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n \n-        for &region in substs.regions.as_full_slice() {\n+        for &region in &substs.regions {\n             self.sub_regions(origin.clone(), expr_region, region);\n         }\n \n-        for &ty in substs.types.as_full_slice() {\n+        for &ty in &substs.types {\n             let ty = self.resolve_type(ty);\n             self.type_must_outlive(origin.clone(), ty, expr_region);\n         }\n@@ -1575,11 +1575,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if env_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for &component_ty in projection_ty.trait_ref.substs.types.as_full_slice() {\n+            for &component_ty in &projection_ty.trait_ref.substs.types {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n-            for &r in projection_ty.trait_ref.substs.regions.as_full_slice() {\n+            for &r in &projection_ty.trait_ref.substs.regions {\n                 self.sub_regions(origin.clone(), region, r);\n             }\n \n@@ -1597,7 +1597,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n             let unique_bound = env_bounds[0];\n             debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.trait_ref.substs.regions.as_full_slice()\n+            if projection_ty.trait_ref.substs.regions\n                                              .iter()\n                                              .any(|r| env_bounds.contains(r))\n             {"}, {"sha": "7ed4b2bcb1918f3ab01e060395877a339515c8f5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -14,7 +14,6 @@ use CrateCtxt;\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n-use rustc::ty::subst;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n \n@@ -459,19 +458,17 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         let mut constrained_parameters: HashSet<_> =\n             variances.types\n-                     .iter_enumerated()\n-                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n-                     .map(|(_, index, _)| self.param_ty(ast_generics, index))\n+                     .iter().enumerate()\n+                     .filter(|&(_, &variance)| variance != ty::Bivariant)\n+                     .map(|(index, _)| self.param_ty(ast_generics, index))\n                      .map(|p| Parameter::Type(p))\n                      .collect();\n \n         identify_constrained_type_params(ty_predicates.predicates.as_slice(),\n                                          None,\n                                          &mut constrained_parameters);\n \n-        for (space, index, _) in variances.types.iter_enumerated() {\n-            assert_eq!(space, subst::TypeSpace);\n-\n+        for (index, _) in variances.types.iter().enumerate() {\n             let param_ty = self.param_ty(ast_generics, index);\n             if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n                 continue;\n@@ -480,9 +477,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             self.report_bivariance(span, param_ty.name);\n         }\n \n-        for (space, index, &variance) in variances.regions.iter_enumerated() {\n-            assert_eq!(space, subst::TypeSpace);\n-\n+        for (index, &variance) in variances.regions.iter().enumerate() {\n             if variance != ty::Bivariant {\n                 continue;\n             }\n@@ -495,7 +490,6 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn param_ty(&self, ast_generics: &hir::Generics, index: usize) -> ty::ParamTy {\n         ty::ParamTy {\n-            space: subst::TypeSpace,\n             idx: index as u32,\n             name: ast_generics.ty_params[index].name\n         }\n@@ -603,7 +597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n                 let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n-                trait_ref.substs.types.as_full_slice().to_vec()\n+                trait_ref.substs.types.to_vec()\n             }\n \n             None => {"}, {"sha": "cfc1292c34b78af0275585300c5acb9bd5f36d1e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -103,13 +103,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n \n         let free_substs = fcx.parameter_environment.free_substs;\n-        for (space, i, r) in free_substs.regions.iter_enumerated() {\n+        for (i, r) in free_substs.regions.iter().enumerate() {\n             match *r {\n                 ty::ReFree(ty::FreeRegion {\n                     bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n                 }) => {\n                     let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        space: space,\n                         index: i as u32,\n                         name: name,\n                     });"}, {"sha": "4a1e401f9820f7d40948c25feb761b4eaf6b4766", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -17,7 +17,7 @@\n \n use hir::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n-use rustc::ty::subst::{self, Subst};\n+use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n+            let target = trait_ref.substs.types[1];\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n "}, {"sha": "ed406b9379e353fecc9dc5ec006cc520e822ba69", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -65,7 +65,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n-use rustc::ty::subst::{Substs, FnSpace, ParamSpace, TypeSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n@@ -473,10 +473,10 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n         results.extend(self.predicates.iter().filter(|predicate| {\n             match **predicate {\n                 ty::Predicate::Trait(ref data) => {\n-                    data.skip_binder().self_ty().is_param(def.space, def.index)\n+                    data.skip_binder().self_ty().is_param(def.index)\n                 }\n                 ty::Predicate::TypeOutlives(ref data) => {\n-                    data.skip_binder().0.is_param(def.space, def.index)\n+                    data.skip_binder().0.is_param(def.index)\n                 }\n                 ty::Predicate::Rfc1592(..) |\n                 ty::Predicate::Equate(..) |\n@@ -571,7 +571,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n-        ty_generic_predicates(ccx, FnSpace, &sig.generics, ty_generics.parent, vec![], false);\n+        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n \n     let (fty, explicit_self_category) = {\n         let anon_scope = match container {\n@@ -752,7 +752,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty_generics = generics_of_def_id(ccx, def_id);\n             let mut ty_predicates =\n-                ty_generic_predicates(ccx, TypeSpace, generics, None, vec![], false);\n+                ty_generic_predicates(ccx, generics, None, vec![], false);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n@@ -1346,7 +1346,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n \n     // add in the explicit where-clauses\n     let mut trait_predicates =\n-        ty_generic_predicates(ccx, TypeSpace, generics, None, base_predicates, true);\n+        ty_generic_predicates(ccx, generics, None, base_predicates, true);\n \n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n@@ -1419,31 +1419,33 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let mut allow_defaults = false;\n \n         let no_generics = hir::Generics::empty();\n-        let (space, ast_generics) = match node {\n+        let ast_generics = match node {\n             NodeTraitItem(item) => {\n                 match item.node {\n-                    MethodTraitItem(ref sig, _) => (FnSpace, &sig.generics),\n-                    _ => (FnSpace, &no_generics)\n+                    MethodTraitItem(ref sig, _) => &sig.generics,\n+                    _ => &no_generics\n                 }\n             }\n \n             NodeImplItem(item) => {\n                 match item.node {\n-                    ImplItemKind::Method(ref sig, _) => (FnSpace, &sig.generics),\n-                    _ => (FnSpace, &no_generics)\n+                    ImplItemKind::Method(ref sig, _) => &sig.generics,\n+                    _ => &no_generics\n                 }\n             }\n \n             NodeItem(item) => {\n                 match item.node {\n-                    ItemFn(_, _, _, _, ref generics, _) => (FnSpace, generics),\n-                    ItemImpl(_, _, ref generics, _, _, _) => (TypeSpace, generics),\n+                    ItemFn(_, _, _, _, ref generics, _) |\n+                    ItemImpl(_, _, ref generics, _, _, _) => generics,\n+\n                     ItemTy(_, ref generics) |\n                     ItemEnum(_, ref generics) |\n                     ItemStruct(_, ref generics) => {\n                         allow_defaults = true;\n-                        (TypeSpace, generics)\n+                        generics\n                     }\n+\n                     ItemTrait(_, ref generics, _, _) => {\n                         // Add in the self type parameter.\n                         //\n@@ -1454,7 +1456,6 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         let parent = ccx.tcx.map.get_parent(param_id);\n \n                         let def = ty::TypeParameterDef {\n-                            space: TypeSpace,\n                             index: 0,\n                             name: keywords::SelfType.name(),\n                             def_id: tcx.map.local_def_id(param_id),\n@@ -1466,20 +1467,21 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         opt_self = Some(def);\n \n                         allow_defaults = true;\n-                        (TypeSpace, generics)\n+                        generics\n                     }\n-                    _ => (TypeSpace, &no_generics)\n+\n+                    _ => &no_generics\n                 }\n             }\n \n             NodeForeignItem(item) => {\n                 match item.node {\n-                    ForeignItemStatic(..) => (TypeSpace, &no_generics),\n-                    ForeignItemFn(_, ref generics) => (FnSpace, generics)\n+                    ForeignItemStatic(..) => &no_generics,\n+                    ForeignItemFn(_, ref generics) => generics\n                 }\n             }\n \n-            _ => (TypeSpace, &no_generics)\n+            _ => &no_generics\n         };\n \n         let has_self = opt_self.is_some();\n@@ -1491,15 +1493,14 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             assert_eq!(generics.parent_types, 0);\n             assert_eq!(has_self, false);\n             parent_has_self = generics.has_self;\n-            (generics.regions.len(), generics.types.len())\n+            (generics.regions.len() as u32, generics.types.len() as u32)\n         });\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n         let regions = early_lifetimes.iter().enumerate().map(|(i, l)| {\n             ty::RegionParameterDef {\n                 name: l.lifetime.name,\n-                space: space,\n-                index: i as u32,\n+                index: parent_regions + i as u32,\n                 def_id: tcx.map.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n                     ast_region_to_region(tcx, l)\n@@ -1509,8 +1510,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Now create the real type parameters.\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n-            let i = has_self as u32 + i as u32;\n-            get_or_create_type_parameter_def(ccx, ast_generics, space, i, p, allow_defaults)\n+            let i = parent_types + has_self as u32 + i as u32;\n+            get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n         });\n         let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n \n@@ -1631,15 +1632,15 @@ fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n \n     let no_generics = hir::Generics::empty();\n-    let (space, generics) = match it.node {\n-        hir::ItemFn(_, _, _, _, ref generics, _) => (FnSpace, generics),\n+    let generics = match it.node {\n+        hir::ItemFn(_, _, _, _, ref generics, _) |\n         hir::ItemTy(_, ref generics) |\n         hir::ItemEnum(_, ref generics) |\n-        hir::ItemStruct(_, ref generics) => (TypeSpace, generics),\n-        _ => (TypeSpace, &no_generics)\n+        hir::ItemStruct(_, ref generics) => generics,\n+        _ => &no_generics\n     };\n \n-    let predicates = ty_generic_predicates(ccx, space, generics, None, vec![], false);\n+    let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n     let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id,\n                                                                  predicates.clone());\n     assert!(prev_predicates.is_none());\n@@ -1658,12 +1659,12 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     type_scheme_of_def_id(ccx, def_id);\n \n     let no_generics = hir::Generics::empty();\n-    let (space, generics) = match it.node {\n-        hir::ForeignItemFn(_, ref generics) => (FnSpace, generics),\n-        hir::ForeignItemStatic(..) => (TypeSpace, &no_generics)\n+    let generics = match it.node {\n+        hir::ForeignItemFn(_, ref generics) => generics,\n+        hir::ForeignItemStatic(..) => &no_generics\n     };\n \n-    let predicates = ty_generic_predicates(ccx, space, generics, None, vec![], false);\n+    let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n     let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n     assert!(prev_predicates.is_none());\n }\n@@ -1733,14 +1734,20 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n }\n \n fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                  space: ParamSpace,\n                                   ast_generics: &hir::Generics,\n                                   parent: Option<DefId>,\n                                   super_predicates: Vec<ty::Predicate<'tcx>>,\n                                   has_self: bool)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n+    let (parent_regions, parent_types) = parent.map_or((0, 0), |def_id| {\n+        let generics = generics_of_def_id(ccx, def_id);\n+        assert_eq!(generics.parent, None);\n+        assert_eq!(generics.parent_regions, 0);\n+        assert_eq!(generics.parent_types, 0);\n+        (generics.regions.len() as u32, generics.types.len() as u32)\n+    });\n     let ref base_predicates = match parent {\n         Some(def_id) => {\n             assert_eq!(super_predicates, vec![]);\n@@ -1758,8 +1765,8 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n     for (index, param) in ast_generics.ty_params.iter().enumerate() {\n-        let index = has_self as u32 + index as u32;\n-        let param_ty = ty::ParamTy::new(space, index, param.name).to_ty(ccx.tcx);\n+        let index = parent_types + has_self as u32 + index as u32;\n+        let param_ty = ty::ParamTy::new(index, param.name).to_ty(ccx.tcx);\n         let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n                                     param_ty,\n                                     &param.bounds,\n@@ -1774,10 +1781,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     // have to be careful to only iterate over early-bound regions.\n     let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n-        let index = index as u32;\n+        let index = parent_regions + index as u32;\n         let region =\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                space: space,\n                 index: index,\n                 name: param.lifetime.name\n             });\n@@ -1852,7 +1858,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                              ast_generics: &hir::Generics,\n-                                             space: ParamSpace,\n                                              index: u32,\n                                              param: &hir::TyParam,\n                                              allow_defaults: bool)\n@@ -1885,7 +1890,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let def = ty::TypeParameterDef {\n-        space: space,\n         index: index,\n         name: param.name,\n         def_id: ccx.tcx.map.local_def_id(param.id),\n@@ -1900,8 +1904,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n-    debug!(\"get_or_create_type_parameter_def: def for type param: {:?}, {:?}\",\n-           def, space);\n+    debug!(\"get_or_create_type_parameter_def: def for type param: {:?}\", def);\n \n     def\n }\n@@ -2190,9 +2193,10 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         .collect();\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n-        let region = ty::EarlyBoundRegion { space: TypeSpace,\n-                                            index: index as u32,\n-                                            name: lifetime_def.lifetime.name };\n+        let region = ty::EarlyBoundRegion {\n+            index: index as u32,\n+            name: lifetime_def.lifetime.name\n+        };\n         if\n             lifetimes_in_associated_types.contains(&region) && // (*)\n             !input_parameters.contains(&ctp::Parameter::Region(region))"}, {"sha": "536fa629fd611837154ddb733c386f7a09da7af2", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -16,7 +16,7 @@\n use dep_graph::DepTrackingMapConfig;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n-use rustc::ty::subst::{self, ParamSpace, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::ItemVariances;\n use rustc::hir::map as hir_map;\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n+            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n@@ -210,7 +210,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          param_def_id: DefId,\n                          item_def_id: DefId,\n                          kind: ParamKind,\n-                         space: ParamSpace,\n                          index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n@@ -226,8 +225,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // variance already inferred, just look it up.\n             let variances = self.tcx().item_variances(item_def_id);\n             let variance = match kind {\n-                TypeParam => *variances.types.get(space, index),\n-                RegionParam => *variances.regions.get(space, index),\n+                TypeParam => variances.types[index],\n+                RegionParam => variances.regions[index],\n             };\n             self.constant_term(variance)\n         }\n@@ -401,8 +400,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(data.space, subst::TypeSpace);\n                 assert_eq!(generics.parent, None);\n+                assert!((data.idx as usize) < generics.types.len());\n                 let def_id = generics.types[data.idx as usize].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n@@ -450,8 +449,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in type_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, TypeParam, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n@@ -461,8 +459,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in region_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, RegionParam, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n@@ -490,8 +487,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(data.space, subst::TypeSpace);\n                 assert_eq!(generics.parent, None);\n+                assert!((data.index as usize) < generics.regions.len());\n                 let def_id = generics.regions[data.index as usize].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {"}, {"sha": "d3b63119bcb324fad45016f1ea72e4b2ea98eae7", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -16,7 +16,6 @@\n //! inferred is then written into the `variance_map` in the tcx.\n \n use rustc::ty;\n-use rustc::ty::subst;\n use std::rc::Rc;\n \n use super::constraints::*;\n@@ -110,41 +109,27 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         while index < num_inferred {\n             let item_id = inferred_infos[index].item_id;\n \n-            let (mut rt, mut rf) = (vec![], vec![]);\n-            let (mut tt, mut tf) = (vec![], vec![]);\n+            let mut item_variances = ty::ItemVariances::empty();\n \n             while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n-                debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n-                       index, info.index, info.kind, info.space, variance);\n+                debug!(\"Index {} Info {} / {:?} Variance {:?}\",\n+                       index, info.index, info.kind, variance);\n                 match info.kind {\n                     TypeParam => {\n-                        let types = match info.space {\n-                            subst::TypeSpace => &mut tt,\n-                            subst::FnSpace => &mut tf\n-                        };\n-                        assert_eq!(types.len(), info.index);\n-                        types.push(variance);\n+                        assert_eq!(item_variances.types.len(), info.index);\n+                        item_variances.types.push(variance);\n                     }\n                     RegionParam => {\n-                        let regions = match info.space {\n-                            subst::TypeSpace => &mut rt,\n-                            subst::FnSpace => &mut rf\n-                        };\n-                        assert_eq!(regions.len(), info.index);\n-                        regions.push(variance);\n+                        assert_eq!(item_variances.regions.len(), info.index);\n+                        item_variances.regions.push(variance);\n                     }\n                 }\n \n                 index += 1;\n             }\n \n-            let item_variances = ty::ItemVariances {\n-                regions: subst::VecPerParamSpace::new(rt, rf),\n-                types: subst::VecPerParamSpace::new(tt, tf)\n-            };\n-\n             debug!(\"item_id={} item_variances={:?}\",\n                     item_id,\n                     item_variances);"}, {"sha": "d30cbc8f117cf03c98668f4409789aad0e660e91", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -21,7 +21,6 @@\n \n use arena::TypedArena;\n use dep_graph::DepTrackingMapConfig;\n-use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::ItemVariances;\n use std::fmt;\n@@ -86,7 +85,6 @@ pub enum ParamKind {\n pub struct InferredInfo<'a> {\n     pub item_id: ast::NodeId,\n     pub kind: ParamKind,\n-    pub space: ParamSpace,\n     pub index: usize,\n     pub param_id: ast::NodeId,\n     pub term: VarianceTermPtr<'a>,\n@@ -166,15 +164,15 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         for (i, p) in generics.lifetimes.iter().enumerate() {\n             let id = p.lifetime.id;\n-            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n+            self.add_inferred(item_id, RegionParam, i, id);\n         }\n \n         if has_self {\n-            self.add_inferred(item_id, TypeParam, TypeSpace, 0, item_id);\n+            self.add_inferred(item_id, TypeParam, 0, item_id);\n         }\n         for (i, p) in generics.ty_params.iter().enumerate() {\n             let i = has_self as usize + i;\n-            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n+            self.add_inferred(item_id, TypeParam, i, p.id);\n         }\n \n         // If this item has no type or lifetime parameters,\n@@ -197,15 +195,13 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n-                    space: ParamSpace,\n                     index: usize,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n-        let initial_variance = self.pick_initial_variance(item_id, space, index);\n+        let initial_variance = self.pick_initial_variance(item_id, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n-                                                space: space,\n                                                 index: index,\n                                                 param_id: param_id,\n                                                 term: term,\n@@ -216,33 +212,23 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         debug!(\"add_inferred(item_path={}, \\\n                 item_id={}, \\\n                 kind={:?}, \\\n-                space={:?}, \\\n                 index={}, \\\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n                self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n-               item_id, kind, space, index, param_id, inf_index,\n+               item_id, kind, index, param_id, inf_index,\n                initial_variance);\n     }\n \n     fn pick_initial_variance(&self,\n                              item_id: ast::NodeId,\n-                             space: ParamSpace,\n                              index: usize)\n                              -> ty::Variance\n     {\n-        match space {\n-            FnSpace => {\n-                ty::Bivariant\n-            }\n-\n-            TypeSpace => {\n-                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n-                    Some(&(_, ref variances)) => variances[index],\n-                    None => ty::Bivariant\n-                }\n-            }\n+        match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n+            Some(&(_, ref variances)) => variances[index],\n+            None => ty::Bivariant\n         }\n     }\n "}, {"sha": "013433336a1d5396e08f90bf0e37d3c2d2f4e9f9", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -388,8 +388,6 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             }\n             ty::TypeTraitItem(ref assoc_ty) => {\n                 let did = assoc_ty.def_id;\n-                // Not sure the choice of ParamSpace actually matters here,\n-                // because an associated type won't have generics on the LHS\n                 let typedef = clean::Typedef {\n                     type_: assoc_ty.ty.unwrap().clean(cx),\n                     generics: clean::Generics {"}, {"sha": "75d21399f05e69d28f59a2aa35b0d9d6fb12c8e8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n-use rustc::ty::subst::{self, Substs, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty;\n use rustc::middle::stability;\n \n@@ -82,12 +82,6 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n-    fn clean(&self, cx: &DocContext) -> VecPerParamSpace<U> {\n-        self.map(|x| x.clean(cx))\n-    }\n-}\n-\n impl<T: Clean<U>, U> Clean<U> for P<T> {\n     fn clean(&self, cx: &DocContext) -> U {\n         (**self).clean(cx)\n@@ -632,12 +626,8 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n \n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n                         bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n-    let lifetimes = substs.regions.get_slice(subst::TypeSpace)\n-                    .iter()\n-                    .filter_map(|v| v.clean(cx))\n-                    .collect();\n-    let types = substs.types.get_slice(subst::TypeSpace);\n-    let types = types[has_self as usize..].to_vec();\n+    let lifetimes = substs.regions.iter().filter_map(|v| v.clean(cx)).collect();\n+    let types = substs.types[has_self as usize..].to_vec();\n \n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n@@ -731,7 +721,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n-        debug!(\"ty::TraitRef\\n  substs.types(TypeSpace): {:?}\\n\",\n+        debug!(\"ty::TraitRef\\n  substs.types: {:?}\\n\",\n                &self.input_types()[1..]);\n \n         // collect any late bound regions\n@@ -769,9 +759,9 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n-        v.extend(self.regions.as_full_slice().iter().filter_map(|r| r.clean(cx))\n+        v.extend(self.regions.iter().filter_map(|r| r.clean(cx))\n                      .map(RegionBound));\n-        v.extend(self.types.as_full_slice().iter().map(|t| TraitBound(PolyTrait {\n+        v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n         }, hir::TraitBoundModifier::None)));\n@@ -1637,7 +1627,7 @@ impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n     fn fold_lifetime(&mut self, lt: hir::Lifetime) -> hir::Lifetime {\n         let def = self.tcx.named_region_map.defs.get(&lt.id).cloned();\n         match def {\n-            Some(DefEarlyBoundRegion(_, _, node_id)) |\n+            Some(DefEarlyBoundRegion(_, node_id)) |\n             Some(DefLateBoundRegion(_, node_id)) |\n             Some(DefFreeRegion(_, node_id)) => {\n                 if let Some(lt) = self.lt_substs.get(&node_id).cloned() {"}, {"sha": "5539a26d2a1702df997d0457a511c76c9ea8ae67", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -20,12 +20,12 @@ trait Trait<'a> {\n }\n \n #[rustc_variance]\n-struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[+];[]], regions=[[-];[]])\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[+], regions=[-])\n     field: (T, &'a ())\n }\n \n #[rustc_variance]\n-struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[o];[]], regions=[[o];[]])\n+struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[o], regions=[o])\n     field: <T as Trait<'a>>::Type\n }\n "}, {"sha": "2f422bfd38cc7fcb340f3068b8a109e6faf3221e", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -18,7 +18,7 @@ use std::cell::Cell;\n // For better or worse, associated types are invariant, and hence we\n // get an invariant result for `'a`.\n #[rustc_variance]\n-struct Foo<'a> { //~ ERROR regions=[[o];[]]\n+struct Foo<'a> { //~ ERROR regions=[o]\n     x: Box<Fn(i32) -> &'a i32 + 'static>\n }\n "}, {"sha": "99416057b25408341ea5b60582dbaf79de2376b2", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -13,11 +13,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-trait Foo: 'static { //~ ERROR types=[[o];[]]\n+trait Foo: 'static { //~ ERROR types=[o]\n }\n \n #[rustc_variance]\n-trait Bar<T> { //~ ERROR types=[[o, o];[]]\n+trait Bar<T> { //~ ERROR types=[o, o]\n     fn do_it(&self)\n         where T: 'static;\n }"}, {"sha": "78591063de8abc4db2094b6a42a1c1dd63562bd1", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -16,7 +16,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[-, -, -]\n     x: &'a isize,\n     y: &'b [isize],\n     c: &'c str\n@@ -25,7 +25,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[+, +, +]\n     x: extern \"Rust\" fn(&'a isize),\n     y: extern \"Rust\" fn(&'b [isize]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -34,15 +34,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[-, o]\n     x: &'a mut &'b isize,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b:'a> { //~ ERROR regions=[[+, o];[]]\n+struct Test5<'a, 'b:'a> { //~ ERROR regions=[+, o]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -52,22 +52,22 @@ struct Test5<'a, 'b:'a> { //~ ERROR regions=[[+, o];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b:'a> { //~ ERROR regions=[[-, o];[]]\n+struct Test6<'a, 'b:'a> { //~ ERROR regions=[-, o]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[*];[]]\n+struct Test7<'a> { //~ ERROR regions=[*]\n     //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),"}, {"sha": "d8af30da163bf8a735550357ce20257c5d865525", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -15,33 +15,33 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[+, -, o, *]\n     //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[*, o, -, +]\n     //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[o, o, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[o, -, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "150a1aa56fe721e956614328416e07c1b0eff0ca", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -15,48 +15,48 @@\n // influence variance.\n \n #[rustc_variance]\n-trait Getter<T> { //~ ERROR types=[[o, o];[]]\n+trait Getter<T> { //~ ERROR types=[o, o]\n     fn get(&self) -> T;\n }\n \n #[rustc_variance]\n-trait Setter<T> { //~ ERROR types=[[o, o];[]]\n+trait Setter<T> { //~ ERROR types=[o, o]\n     fn get(&self, T);\n }\n \n #[rustc_variance]\n-struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[[+, +];[]]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[+, +]\n     t: T, u: U\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[*, +];[]]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[*, +]\n     //~^ ERROR parameter `U` is never used\n     Foo(T)\n }\n \n #[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[o, o, o];[]]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[o, o, o]\n     fn getter(&self, u: U) -> T;\n }\n \n #[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[o, o];[]]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR types=[o, o]\n }\n \n #[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR types=[[o, o];[]]\n+trait TestTrait3<U> { //~ ERROR types=[o, o]\n     fn getter<T:Getter<U>>(&self);\n }\n \n #[rustc_variance]\n-struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[[*, +];[]]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n-struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[[*, +];[]]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }"}, {"sha": "4244b0e1d8b8b27104150a40cd03449694e724b0", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n trait T { fn foo(&self); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[-];[]]\n+struct TOption<'a> { //~ ERROR regions=[-]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "c47710d6d376d0e2bcdf1354fd62cf2c7411687e", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -14,46 +14,46 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-struct TestImm<A, B> { //~ ERROR types=[[+, +];[]]\n+struct TestImm<A, B> { //~ ERROR types=[+, +]\n     x: A,\n     y: B,\n }\n \n #[rustc_variance]\n-struct TestMut<A, B:'static> { //~ ERROR types=[[+, o];[]]\n+struct TestMut<A, B:'static> { //~ ERROR types=[+, o]\n     x: A,\n     y: &'static mut B,\n }\n \n #[rustc_variance]\n-struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[[+, o];[]]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[+, o]\n     m: TestMut<A, B>\n }\n \n #[rustc_variance]\n-struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[o, o];[]]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[o, o]\n     n: TestMut<A, B>,\n     m: TestMut<B, A>\n }\n \n #[rustc_variance]\n-trait Getter<A> { //~ ERROR types=[[o, o];[]]\n+trait Getter<A> { //~ ERROR types=[o, o]\n     fn get(&self) -> A;\n }\n \n #[rustc_variance]\n-trait Setter<A> { //~ ERROR types=[[o, o];[]]\n+trait Setter<A> { //~ ERROR types=[o, o]\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR types=[[o, o];[]]\n+trait GetterSetter<A> { //~ ERROR types=[o, o]\n     fn get(&self) -> A;\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR types=[[o, o];[]]\n+trait GetterInTypeBound<A> { //~ ERROR types=[o, o]\n     // Here, the use of `A` in the method bound *does* affect\n     // variance.  Think of it as if the method requested a dictionary\n     // for `T:Getter<A>`.  Since this dictionary is an input, it is\n@@ -63,12 +63,12 @@ trait GetterInTypeBound<A> { //~ ERROR types=[[o, o];[]]\n }\n \n #[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR types=[[o, o];[]]\n+trait SetterInTypeBound<A> { //~ ERROR types=[o, o]\n     fn do_it<T:Setter<A>>(&self);\n }\n \n #[rustc_variance]\n-struct TestObject<A, R> { //~ ERROR types=[[o, o];[]]\n+struct TestObject<A, R> { //~ ERROR types=[o, o]\n     n: Box<Setter<A>+Send>,\n     m: Box<Getter<R>+Send>,\n }"}, {"sha": "d5164412358fc4dbba312b0e7dab4858ee6f61d5", "filename": "src/test/compile-fail/variance-types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -17,32 +17,32 @@ use std::cell::Cell;\n // not considered bivariant.\n \n #[rustc_variance]\n-struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[[o, o];[]], regions=[[-];[]]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[o, o], regions=[-]\n     t: &'a mut (A,B)\n }\n \n #[rustc_variance]\n-struct InvariantCell<A> { //~ ERROR types=[[o];[]]\n+struct InvariantCell<A> { //~ ERROR types=[o]\n     t: Cell<A>\n }\n \n #[rustc_variance]\n-struct InvariantIndirect<A> { //~ ERROR types=[[o];[]]\n+struct InvariantIndirect<A> { //~ ERROR types=[o]\n     t: InvariantCell<A>\n }\n \n #[rustc_variance]\n-struct Covariant<A> { //~ ERROR types=[[+];[]]\n+struct Covariant<A> { //~ ERROR types=[+]\n     t: A, u: fn() -> A\n }\n \n #[rustc_variance]\n-struct Contravariant<A> { //~ ERROR types=[[-];[]]\n+struct Contravariant<A> { //~ ERROR types=[-]\n     t: fn(A)\n }\n \n #[rustc_variance]\n-enum Enum<A,B,C> { //~ ERROR types=[[+, -, o];[]]\n+enum Enum<A,B,C> { //~ ERROR types=[+, -, o]\n     Foo(Covariant<A>),\n     Bar(Contravariant<B>),\n     Zed(Covariant<C>,Contravariant<C>)"}, {"sha": "f93447b642a2050b5aa5a98a5d53207624812547", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9453d9b8ada9f6b651b10b3ad8131732fc70c61e/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=9453d9b8ada9f6b651b10b3ad8131732fc70c61e", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n fn main() {\n     let a = 0;\n     {\n@@ -25,7 +27,7 @@ fn main() {\n //         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n //         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n //         tmp2 = var0;                     // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp1 = std::prelude::v1::Some<i32>(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n+//         tmp1 = std::option::Option<i32>::Some(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n //         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:14:17: 14:25\n //         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n //         tmp0 = ();                       // scope 2 at storage_ranges.rs:13:5: 15:6"}]}