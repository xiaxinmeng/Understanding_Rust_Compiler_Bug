{"sha": "1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhN2QwMGE1Mjk1MDNhYzM4YTZiMWFlMjhlOGU3NzllNDM0ZTAyZTA=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-11-11T00:00:53Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-12-19T13:13:36Z"}, "message": "implement edition-specific :pat behavior for 2015/18", "tree": {"sha": "322ac3ba9ec48dc477bb84fea01b6ee0f74f5bf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322ac3ba9ec48dc477bb84fea01b6ee0f74f5bf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "html_url": "https://github.com/rust-lang/rust/commit/1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e461b8137f8f7277147e3ec8ec0b7f0f31d32d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e461b8137f8f7277147e3ec8ec0b7f0f31d32d0b", "html_url": "https://github.com/rust-lang/rust/commit/e461b8137f8f7277147e3ec8ec0b7f0f31d32d0b"}], "stats": {"total": 268, "additions": 193, "deletions": 75}, "files": [{"sha": "3cf2d8f8ac1ef9b39bc62acee45bf98f55cf3d32", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -77,9 +77,9 @@ use TokenTreeOrTokenTreeSlice::*;\n use crate::mbe::{self, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_parse::parser::Parser;\n+use rustc_parse::parser::{OrPatNonterminalMode, Parser};\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::MacroRulesNormalizedIdent;\n+use rustc_span::{edition::Edition, symbol::MacroRulesNormalizedIdent};\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -414,6 +414,18 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     }\n }\n \n+/// In edition 2015/18, `:pat` can only match `pat<no_top_alt>` because otherwise, we have\n+/// breakage. As of edition 2021, `:pat` matches `top_pat`.\n+///\n+/// See <https://github.com/rust-lang/rust/issues/54883> for more info.\n+fn or_pat_mode(edition: Edition) -> OrPatNonterminalMode {\n+    match edition {\n+        Edition::Edition2015 | Edition::Edition2018 => OrPatNonterminalMode::NoTopAlt,\n+        // FIXME(mark-i-m): uncomment this when edition 2021 machinery is added.\n+        // Edition::Edition2021 =>  OrPatNonterminalMode::TopPat,\n+    }\n+}\n+\n /// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n /// produce more items in `next_items`, `eof_items`, and `bb_items`.\n ///\n@@ -553,10 +565,14 @@ fn inner_parse_loop<'root, 'tt>(\n \n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(_, _, kind) => {\n-                    // Built-in nonterminals never start with these tokens,\n-                    // so we can eliminate them from consideration.\n-                    if Parser::nonterminal_may_begin_with(kind, token) {\n+                TokenTree::MetaVarDecl(span, _, kind) => {\n+                    // Built-in nonterminals never start with these tokens, so we can eliminate\n+                    // them from consideration.\n+                    //\n+                    // We use the span of the metavariable declaration to determine any\n+                    // edition-specific matching behavior for non-terminals.\n+                    if Parser::nonterminal_may_begin_with(kind, token, or_pat_mode(span.edition()))\n+                    {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -717,7 +733,10 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let mut item = bb_items.pop().unwrap();\n             if let TokenTree::MetaVarDecl(span, _, kind) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                // We use the span of the metavariable declaration to determine any\n+                // edition-specific matching behavior for non-terminals.\n+                let nt = match parser.to_mut().parse_nonterminal(kind, or_pat_mode(span.edition()))\n+                {\n                     Err(mut err) => {\n                         err.span_label(\n                             span,"}, {"sha": "eed3e9947b2aa3a3b9cff81f7a1f5149983b4694", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -1,4 +1,4 @@\n-use super::pat::{GateOr, PARAM_EXPECTED};\n+use super::pat::{GateOr, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{BlockMode, Parser, PathStyle, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n@@ -1729,7 +1729,7 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_top_pat(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No, RecoverComma::Yes)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n@@ -1792,7 +1792,7 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        let pat = self.parse_top_pat(GateOr::Yes)?;\n+        let pat = self.parse_top_pat(GateOr::Yes, RecoverComma::Yes)?;\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n@@ -1902,7 +1902,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        let pat = self.parse_top_pat(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No, RecoverComma::Yes)?;\n         let guard = if self.eat_keyword(kw::If) {\n             let if_span = self.prev_token.span;\n             let cond = self.parse_expr()?;"}, {"sha": "e19ebb8fd2fbc3bb9d881a8d1fb24f0a3543a9a4", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -12,6 +12,7 @@ mod ty;\n use crate::lexer::UnmatchedBrace;\n pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n+pub use pat::OrPatNonterminalMode;\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;"}, {"sha": "a6b9ac1014e8d23b6af0e81eaeee29adc8b6d616", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -4,14 +4,19 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n+use crate::parser::pat::{GateOr, OrPatNonterminalMode, RecoverComma};\n use crate::parser::{FollowedByType, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n     /// Checks whether a non-terminal may begin with a particular token.\n     ///\n     /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n     /// token. Be conservative (return true) if not sure.\n-    pub fn nonterminal_may_begin_with(kind: NonterminalKind, token: &Token) -> bool {\n+    pub fn nonterminal_may_begin_with(\n+        kind: NonterminalKind,\n+        token: &Token,\n+        or_pat_mode: OrPatNonterminalMode,\n+    ) -> bool {\n         /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n         fn may_be_ident(nt: &token::Nonterminal) -> bool {\n             match *nt {\n@@ -70,6 +75,8 @@ impl<'a> Parser<'a> {\n                 token::ModSep |                     // path\n                 token::Lt |                         // path (UFCS constant)\n                 token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                // leading vert `|` or-pattern\n+                token::BinOp(token::Or) =>  matches!(or_pat_mode, OrPatNonterminalMode::TopPat),\n                 token::Interpolated(ref nt) => may_be_ident(nt),\n                 _ => false,\n             },\n@@ -86,7 +93,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n+    /// Parse a non-terminal (e.g. MBE `:pat` or `:ident`).\n+    pub fn parse_nonterminal(\n+        &mut self,\n+        kind: NonterminalKind,\n+        or_pat_mode: OrPatNonterminalMode,\n+    ) -> PResult<'a, Nonterminal> {\n         // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n         // needs to have them force-captured here.\n         // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n@@ -130,7 +142,12 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             NonterminalKind::Pat => {\n-                let (mut pat, tokens) = self.collect_tokens(|this| this.parse_pat(None))?;\n+                let (mut pat, tokens) = self.collect_tokens(|this| match or_pat_mode {\n+                    OrPatNonterminalMode::TopPat => {\n+                        this.parse_top_pat(GateOr::Yes, RecoverComma::No)\n+                    }\n+                    OrPatNonterminalMode::NoTopAlt => this.parse_pat(None),\n+                })?;\n                 // We have have eaten an NtPat, which could already have tokens\n                 if pat.tokens.is_none() {\n                     pat.tokens = tokens;"}, {"sha": "1da371e0b7294ec34474cf3ba5de7a3da3af12c0", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -26,11 +26,18 @@ pub(super) enum GateOr {\n \n /// Whether or not to recover a `,` when parsing or-patterns.\n #[derive(PartialEq, Copy, Clone)]\n-enum RecoverComma {\n+pub(super) enum RecoverComma {\n     Yes,\n     No,\n }\n \n+/// Used when parsing a non-terminal (see `parse_nonterminal`) to determine if `:pat` should match\n+/// `top_pat` or `pat<no_top_alt>`. See issue <https://github.com/rust-lang/rust/pull/78935>.\n+pub enum OrPatNonterminalMode {\n+    TopPat,\n+    NoTopAlt,\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n     ///\n@@ -43,13 +50,17 @@ impl<'a> Parser<'a> {\n \n     /// Entry point to the main pattern parser.\n     /// Corresponds to `top_pat` in RFC 2535 and allows or-pattern at the top level.\n-    pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {\n+    pub(super) fn parse_top_pat(\n+        &mut self,\n+        gate_or: GateOr,\n+        rc: RecoverComma,\n+    ) -> PResult<'a, P<Pat>> {\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n         let gated_leading_vert = self.eat_or_separator(None) && gate_or == GateOr::Yes;\n         let leading_vert_span = self.prev_token.span;\n \n         // Parse the possibly-or-pattern.\n-        let pat = self.parse_pat_with_or(None, gate_or, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_with_or(None, gate_or, rc)?;\n \n         // If we parsed a leading `|` which should be gated,\n         // and no other gated or-pattern has been parsed thus far,"}, {"sha": "2942747991a1db30da9059dca7977ed84060231c", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -1,7 +1,7 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n use super::diagnostics::{AttemptLocalParseRecovery, Error};\n use super::expr::LhsExpr;\n-use super::pat::GateOr;\n+use super::pat::{GateOr, RecoverComma};\n use super::path::PathStyle;\n use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n use crate::maybe_whole;\n@@ -185,7 +185,7 @@ impl<'a> Parser<'a> {\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_top_pat(GateOr::Yes)?;\n+        let pat = self.parse_top_pat(GateOr::Yes, RecoverComma::Yes)?;\n \n         let (err, ty) = if self.eat(&token::Colon) {\n             // Save the state of the parser before parsing type normally, in case there is a `:`"}, {"sha": "ce2911de986dc03b8bf17eca58abe9cbf21b9d49", "filename": "src/test/ui/macros/macro-pat-follow-2018.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-follow-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-follow-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-follow-2018.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+// edition:2018\n+\n+macro_rules! pat_bar {\n+    ($p:pat | $p2:pat) => {{\n+        match Some(1u8) {\n+            $p | $p2 => {}\n+            _ => {}\n+        }\n+    }};\n+}\n+\n+fn main() {\n+    pat_bar!(Some(1u8) | None);\n+}"}, {"sha": "8e02789fdd8da89d44c46508a5f5fc2886928dd8", "filename": "src/test/ui/macros/macro-pat-follow.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-follow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-follow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-follow.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -3,29 +3,19 @@ macro_rules! pat_in {\n     ($p:pat in $e:expr) => {{\n         let mut iter = $e.into_iter();\n         while let $p = iter.next() {}\n-    }}\n+    }};\n }\n \n macro_rules! pat_if {\n     ($p:pat if $e:expr) => {{\n         match Some(1u8) {\n-            $p if $e => {},\n+            $p if $e => {}\n             _ => {}\n         }\n-    }}\n-}\n-\n-macro_rules! pat_bar {\n-    ($p:pat | $p2:pat) => {{\n-        match Some(1u8) {\n-            $p | $p2 => {},\n-            _ => {}\n-        }\n-    }}\n+    }};\n }\n \n fn main() {\n     pat_in!(Some(_) in 0..10);\n     pat_if!(Some(x) if x > 0);\n-    pat_bar!(Some(1u8) | None);\n }"}, {"sha": "9c3c5dd360e07912754c13c0cac043f7e59b5069", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail-2018.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail-2018.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -0,0 +1,15 @@\n+// Test that :pat doesn't accept top-level or-patterns in edition 2018.\n+\n+// edition:2018\n+\n+#![feature(or_patterns)]\n+\n+fn main() {}\n+\n+// Test the `pat` macro fragment parser:\n+macro_rules! accept_pat {\n+    ($p:pat) => {};\n+}\n+\n+accept_pat!(p | q); //~ ERROR no rules expected the token `|`\n+accept_pat!(|p| q); //~ ERROR no rules expected the token `|`"}, {"sha": "7dbc3087663477117df5946f23e393261927d90a", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail-2018.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail-2018.stderr?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -0,0 +1,20 @@\n+error: no rules expected the token `|`\n+  --> $DIR/or-patterns-syntactic-fail-2018.rs:14:15\n+   |\n+LL | macro_rules! accept_pat {\n+   | ----------------------- when calling this macro\n+...\n+LL | accept_pat!(p | q);\n+   |               ^ no rules expected this token in macro call\n+\n+error: no rules expected the token `|`\n+  --> $DIR/or-patterns-syntactic-fail-2018.rs:15:13\n+   |\n+LL | macro_rules! accept_pat {\n+   | ----------------------- when calling this macro\n+...\n+LL | accept_pat!(|p| q);\n+   |             ^ no rules expected this token in macro call\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "efe90b3e3c60c65e93a6a22ff8c8611f6962823a", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -5,16 +5,6 @@\n \n fn main() {}\n \n-// Test the `pat` macro fragment parser:\n-macro_rules! accept_pat {\n-    ($p:pat) => {}\n-}\n-\n-accept_pat!(p | q); //~ ERROR no rules expected the token `|`\n-accept_pat!(| p | q); //~ ERROR no rules expected the token `|`\n-\n-// Non-macro tests:\n-\n enum E { A, B }\n use E::*;\n "}, {"sha": "989aeb520064568c4951bb7e93221137c29c6d37", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -1,103 +1,85 @@\n error: an or-pattern parameter must be wrapped in parenthesis\n-  --> $DIR/or-patterns-syntactic-fail.rs:27:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:17:13\n    |\n LL |     fn fun1(A | B: E) {}\n    |             ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n \n error: a leading `|` is not allowed in a parameter pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:29:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:19:13\n    |\n LL |     fn fun2(| A | B: E) {}\n    |             ^ help: remove the `|`\n \n error: an or-pattern parameter must be wrapped in parenthesis\n-  --> $DIR/or-patterns-syntactic-fail.rs:29:15\n+  --> $DIR/or-patterns-syntactic-fail.rs:19:15\n    |\n LL |     fn fun2(| A | B: E) {}\n    |               ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:40:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:30:11\n    |\n LL |     let ( | A | B) = E::A;\n    |           ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:41:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:31:11\n    |\n LL |     let ( | A | B,) = (E::B,);\n    |           ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:42:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:32:11\n    |\n LL |     let [ | A | B ] = [E::A];\n    |           ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:43:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:33:13\n    |\n LL |     let TS( | A | B );\n    |             ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:44:17\n+  --> $DIR/or-patterns-syntactic-fail.rs:34:17\n    |\n LL |     let NS { f: | A | B };\n    |                 ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:46:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:36:11\n    |\n LL |     let ( || A | B) = E::A;\n    |           ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:47:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:37:11\n    |\n LL |     let [ || A | B ] = [E::A];\n    |           ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:48:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:38:13\n    |\n LL |     let TS( || A | B );\n    |             ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:49:17\n+  --> $DIR/or-patterns-syntactic-fail.rs:39:17\n    |\n LL |     let NS { f: || A | B };\n    |                 ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n-error: no rules expected the token `|`\n-  --> $DIR/or-patterns-syntactic-fail.rs:13:15\n-   |\n-LL | macro_rules! accept_pat {\n-   | ----------------------- when calling this macro\n-...\n-LL | accept_pat!(p | q);\n-   |               ^ no rules expected this token in macro call\n-\n-error: no rules expected the token `|`\n-  --> $DIR/or-patterns-syntactic-fail.rs:14:13\n-   |\n-LL | macro_rules! accept_pat {\n-   | ----------------------- when calling this macro\n-...\n-LL | accept_pat!(| p | q);\n-   |             ^ no rules expected this token in macro call\n-\n error[E0369]: no implementation for `E | ()`\n-  --> $DIR/or-patterns-syntactic-fail.rs:23:22\n+  --> $DIR/or-patterns-syntactic-fail.rs:13:22\n    |\n LL |     let _ = |A | B: E| ();\n    |                  ----^ -- ()\n@@ -107,7 +89,7 @@ LL |     let _ = |A | B: E| ();\n    = note: an implementation of `std::ops::BitOr` might be missing for `E`\n \n error[E0308]: mismatched types\n-  --> $DIR/or-patterns-syntactic-fail.rs:51:36\n+  --> $DIR/or-patterns-syntactic-fail.rs:41:36\n    |\n LL |     let recovery_witness: String = 0;\n    |                           ------   ^\n@@ -116,7 +98,7 @@ LL |     let recovery_witness: String = 0;\n    |                           |        help: try using a conversion method: `0.to_string()`\n    |                           expected due to this\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 14 previous errors\n \n Some errors have detailed explanations: E0308, E0369.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "f0ce7597aeed1c697fd3ece1c25be83efe287926", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass-2021.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass-2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass-2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass-2021.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -0,0 +1,14 @@\n+// Tests that :pat in macros in edition 2021 allows top-level or-patterns.\n+\n+// run-pass\n+// ignore-test\n+// edition:2021\n+// FIXME(mark-i-m): unignore when 2021 machinery is in place.\n+\n+macro_rules! accept_pat {\n+    ($p:pat) => {};\n+}\n+\n+accept_pat!(p | q);\n+\n+fn main() {}"}, {"sha": "8749407675b375f7447d52a4327f2b150feb18f1", "filename": "src/test/ui/pattern/or-pattern-macro-pat.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2Fpattern%2For-pattern-macro-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7d00a529503ac38a6b1ae28e8e779e434e02e0/src%2Ftest%2Fui%2Fpattern%2For-pattern-macro-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2For-pattern-macro-pat.rs?ref=1a7d00a529503ac38a6b1ae28e8e779e434e02e0", "patch": "@@ -0,0 +1,44 @@\n+// run-pass\n+// edition:2021\n+// ignore-test\n+// FIXME(mark-i-m): enable this test again when 2021 machinery is available\n+\n+#![feature(or_patterns)]\n+\n+use Foo::*;\n+\n+#[derive(Eq, PartialEq, Debug)]\n+enum Foo {\n+    A(u64),\n+    B(u64),\n+    C,\n+    D,\n+}\n+\n+macro_rules! foo {\n+    ($orpat:pat, $val:expr) => {\n+        match $val {\n+            x @ ($orpat) => x, // leading vert would not be allowed in $orpat\n+            _ => B(0xDEADBEEFu64),\n+        }\n+    };\n+}\n+\n+macro_rules! bar {\n+    ($orpat:pat, $val:expr) => {\n+        match $val {\n+            $orpat => 42, // leading vert allowed here\n+            _ => 0xDEADBEEFu64,\n+        }\n+    };\n+}\n+\n+fn main() {\n+    // Test or-pattern.\n+    let y = foo!(A(_)|B(_), A(32));\n+    assert_eq!(y, A(32));\n+\n+    // Leading vert in or-pattern.\n+    let y = bar!(|C| D, C);\n+    assert_eq!(y, 42u64);\n+}"}]}