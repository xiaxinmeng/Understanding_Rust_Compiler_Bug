{"sha": "441e659aa15b98ca6adc428b8c48343202e58a28", "node_id": "C_kwDOAAsO6NoAKDQ0MWU2NTlhYTE1Yjk4Y2E2YWRjNDI4YjhjNDgzNDMyMDJlNThhMjg", "commit": {"author": {"name": "Hongxu Xu", "email": "xuhongxu96@hotmail.com", "date": "2022-07-05T13:48:28Z"}, "committer": {"name": "Hongxu Xu", "email": "xuhongxu96@hotmail.com", "date": "2022-07-05T13:48:28Z"}, "message": "Complete associated type only in trait generic arg\nFix tidy check does not work for marks in multiline", "tree": {"sha": "9d4cb555d8b8890455db494424251276bba4faba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d4cb555d8b8890455db494424251276bba4faba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/441e659aa15b98ca6adc428b8c48343202e58a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/441e659aa15b98ca6adc428b8c48343202e58a28", "html_url": "https://github.com/rust-lang/rust/commit/441e659aa15b98ca6adc428b8c48343202e58a28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/441e659aa15b98ca6adc428b8c48343202e58a28/comments", "author": {"login": "xuhongxu96", "id": 2201482, "node_id": "MDQ6VXNlcjIyMDE0ODI=", "avatar_url": "https://avatars.githubusercontent.com/u/2201482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xuhongxu96", "html_url": "https://github.com/xuhongxu96", "followers_url": "https://api.github.com/users/xuhongxu96/followers", "following_url": "https://api.github.com/users/xuhongxu96/following{/other_user}", "gists_url": "https://api.github.com/users/xuhongxu96/gists{/gist_id}", "starred_url": "https://api.github.com/users/xuhongxu96/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xuhongxu96/subscriptions", "organizations_url": "https://api.github.com/users/xuhongxu96/orgs", "repos_url": "https://api.github.com/users/xuhongxu96/repos", "events_url": "https://api.github.com/users/xuhongxu96/events{/privacy}", "received_events_url": "https://api.github.com/users/xuhongxu96/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xuhongxu96", "id": 2201482, "node_id": "MDQ6VXNlcjIyMDE0ODI=", "avatar_url": "https://avatars.githubusercontent.com/u/2201482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xuhongxu96", "html_url": "https://github.com/xuhongxu96", "followers_url": "https://api.github.com/users/xuhongxu96/followers", "following_url": "https://api.github.com/users/xuhongxu96/following{/other_user}", "gists_url": "https://api.github.com/users/xuhongxu96/gists{/gist_id}", "starred_url": "https://api.github.com/users/xuhongxu96/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xuhongxu96/subscriptions", "organizations_url": "https://api.github.com/users/xuhongxu96/orgs", "repos_url": "https://api.github.com/users/xuhongxu96/repos", "events_url": "https://api.github.com/users/xuhongxu96/events{/privacy}", "received_events_url": "https://api.github.com/users/xuhongxu96/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1a8c0b1534f26d4f04df79cfa11fd309365639b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a8c0b1534f26d4f04df79cfa11fd309365639b", "html_url": "https://github.com/rust-lang/rust/commit/e1a8c0b1534f26d4f04df79cfa11fd309365639b"}], "stats": {"total": 182, "additions": 119, "deletions": 63}, "files": [{"sha": "352708df73c195483b1d4c6199916eaa1de0cef7", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 54, "deletions": 29, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/441e659aa15b98ca6adc428b8c48343202e58a28/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441e659aa15b98ca6adc428b8c48343202e58a28/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=441e659aa15b98ca6adc428b8c48343202e58a28", "patch": "@@ -120,39 +120,64 @@ pub(crate) fn complete_type_path(\n         }\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n-            acc.add_nameref_keywords_with_colon(ctx);\n-            if let TypeLocation::TypeBound = location {\n-                ctx.process_all_names(&mut |name, res| {\n-                    let add_resolution = match res {\n-                        ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n-                        ScopeDef::ModuleDef(\n-                            hir::ModuleDef::Trait(_) | hir::ModuleDef::Module(_),\n-                        ) => true,\n-                        _ => false,\n-                    };\n-                    if add_resolution {\n-                        acc.add_path_resolution(ctx, path_ctx, name, res);\n-                    }\n-                });\n-                return;\n-            }\n-            if let TypeLocation::GenericArgList(Some(arg_list)) = location {\n-                if let Some(path_seg) = arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n-                {\n-                    if path_seg.syntax().ancestors().find_map(ast::TypeBound::cast).is_some() {\n-                        if let Some(hir::PathResolution::Def(hir::ModuleDef::Trait(trait_))) =\n-                            ctx.sema.resolve_path(&path_seg.parent_path())\n-                        {\n-                            trait_.items_with_supertraits(ctx.sema.db).into_iter().for_each(|it| {\n-                                if let hir::AssocItem::TypeAlias(alias) = it {\n-                                    cov_mark::hit!(complete_assoc_type_in_generics_list);\n-                                    acc.add_type_alias_with_eq(ctx, alias)\n+            match location {\n+                TypeLocation::TypeBound => {\n+                    acc.add_nameref_keywords_with_colon(ctx);\n+                    ctx.process_all_names(&mut |name, res| {\n+                        let add_resolution = match res {\n+                            ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n+                                mac.is_fn_like(ctx.db)\n+                            }\n+                            ScopeDef::ModuleDef(\n+                                hir::ModuleDef::Trait(_) | hir::ModuleDef::Module(_),\n+                            ) => true,\n+                            _ => false,\n+                        };\n+                        if add_resolution {\n+                            acc.add_path_resolution(ctx, path_ctx, name, res);\n+                        }\n+                    });\n+                    return;\n+                }\n+                TypeLocation::GenericArgList(Some(arg_list)) => {\n+                    match arg_list.generic_args().next() {\n+                        Some(ast::GenericArg::AssocTypeArg(_)) => {}\n+                        _ => {\n+                            if let Some(path_seg) =\n+                                arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n+                            {\n+                                if path_seg\n+                                    .syntax()\n+                                    .ancestors()\n+                                    .find_map(ast::TypeBound::cast)\n+                                    .is_some()\n+                                {\n+                                    if let Some(hir::PathResolution::Def(hir::ModuleDef::Trait(\n+                                        trait_,\n+                                    ))) = ctx.sema.resolve_path(&path_seg.parent_path())\n+                                    {\n+                                        trait_\n+                                            .items_with_supertraits(ctx.sema.db)\n+                                            .into_iter()\n+                                            .for_each(|it| {\n+                                                if let hir::AssocItem::TypeAlias(alias) = it {\n+                                                    cov_mark::hit!(\n+                                                        complete_assoc_type_in_generics_list\n+                                                    );\n+                                                    acc.add_type_alias_with_eq(ctx, alias);\n+                                                }\n+                                            });\n+                                        return; // only AssocTypeArgs make sense\n+                                    }\n                                 }\n-                            });\n+                            }\n                         }\n                     }\n                 }\n-            }\n+                _ => {}\n+            };\n+\n+            acc.add_nameref_keywords_with_colon(ctx);\n             ctx.process_all_names(&mut |name, def| {\n                 if scope_def_applicable(def) {\n                     acc.add_path_resolution(ctx, path_ctx, name, def);"}, {"sha": "b30d4cceb89fd9976f8e990c160367967dd046cb", "filename": "crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/441e659aa15b98ca6adc428b8c48343202e58a28/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441e659aa15b98ca6adc428b8c48343202e58a28/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=441e659aa15b98ca6adc428b8c48343202e58a28", "patch": "@@ -380,25 +380,8 @@ trait Trait2: Trait1 {\n fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n \"#,\n         expect![[r#\"\n-            ct CONST\n-            cp CONST_PARAM\n-            en Enum\n-            ma makro!(\u2026)            macro_rules! makro\n-            md module\n-            st Record\n-            st Tuple\n-            st Unit\n-            tt Trait\n-            tt Trait1\n-            tt Trait2\n             ta Foo =  (as Trait2)   type Foo\n             ta Super =  (as Trait1) type Super\n-            tp T\n-            un Union\n-            bt u32\n-            kw crate::\n-            kw self::\n-            kw super::\n         \"#]],\n     );\n     check(\n@@ -472,3 +455,48 @@ fn func(_: Enum::$0) {}\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn completes_associated_type_only() {\n+    check(\n+        r#\"\n+trait MyTrait {\n+    type Item;\n+};\n+\n+fn f(t: impl MyTrait<I$0\n+\"#,\n+        expect![[r#\"\n+            ta Item =  (as MyTrait) type Item\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_types_after_associated_type() {\n+    check(\n+        r#\"\n+trait MyTrait {\n+    type Item;\n+};\n+\n+fn f(t: impl MyTrait<Item = $0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+}"}, {"sha": "12be7947fe0a4de673c5f91545cb8d47d93fddeb", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/441e659aa15b98ca6adc428b8c48343202e58a28/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441e659aa15b98ca6adc428b8c48343202e58a28/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=441e659aa15b98ca6adc428b8c48343202e58a28", "patch": "@@ -471,17 +471,9 @@ struct TidyMarks {\n \n impl TidyMarks {\n     fn visit(&mut self, _path: &Path, text: &str) {\n-        for line in text.lines() {\n-            if let Some(mark) = find_mark(line, \"hit\") {\n-                self.hits.insert(mark.to_string());\n-            }\n-            if let Some(mark) = find_mark(line, \"check\") {\n-                self.checks.insert(mark.to_string());\n-            }\n-            if let Some(mark) = find_mark(line, \"check_count\") {\n-                self.checks.insert(mark.to_string());\n-            }\n-        }\n+        find_marks(&mut self.hits, text, \"hit\");\n+        find_marks(&mut self.checks, text, \"check\");\n+        find_marks(&mut self.checks, text, \"check_count\");\n     }\n \n     fn finish(self) {\n@@ -506,10 +498,21 @@ fn stable_hash(text: &str) -> u64 {\n     hasher.finish()\n }\n \n-fn find_mark<'a>(text: &'a str, mark: &'static str) -> Option<&'a str> {\n-    let idx = text.find(mark)?;\n-    let text = text[idx + mark.len()..].strip_prefix(\"!(\")?;\n-    let idx = text.find(|c: char| !(c.is_alphanumeric() || c == '_'))?;\n-    let text = &text[..idx];\n-    Some(text)\n+fn find_marks(set: &mut HashSet<String>, text: &str, mark: &str) {\n+    let mut text = text;\n+    let mut prev_text = \"\";\n+    while text != prev_text {\n+        prev_text = text;\n+        if let Some(idx) = text.find(mark) {\n+            text = &text[idx + mark.len()..];\n+            if let Some(stripped_text) = text.strip_prefix(\"!(\") {\n+                text = stripped_text.trim_start();\n+                if let Some(idx2) = text.find(|c: char| !(c.is_alphanumeric() || c == '_')) {\n+                    let mark_text = &text[..idx2];\n+                    set.insert(mark_text.to_string());\n+                    text = &text[idx2..];\n+                }\n+            }\n+        }\n+    }\n }"}]}