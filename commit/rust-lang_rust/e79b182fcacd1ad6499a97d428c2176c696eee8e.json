{"sha": "e79b182fcacd1ad6499a97d428c2176c696eee8e", "node_id": "C_kwDOAAsO6NoAKGU3OWIxODJmY2FjZDFhZDY0OTlhOTdkNDI4YzIxNzZjNjk2ZWVlOGU", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-21T12:00:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-21T12:00:22Z"}, "message": "Rollup merge of #108896 - BoxyUwU:new_solver_add_goal_fn, r=lcnr\n\nnew solver: make all goal evaluation able to be automatically rerun\n\nIt is generally wrong to call `evaluate_goal` multiple times or `evaluate_goal` and `evaluate_all` for the same `QueryResult` without correctly handling rerunning the goals when inference makes progress. Not doing so will result in the assertion in `evaluate_goal` firing because rerunning the goal will lead to a more accurate `QueryResult`.\n\nCurrently there are lots of places that get this wrong and generally it is complex and error prone to handle correctly everywhere. This PR introduces a way to add goals to the `EvalCtxt` and then run all the added goals in a loop so that `evaluate_goal`/`evaluate_all` is not necessary to call manually.\n\nThere are a few complications for making everything work \"right\":\n1. the `normalizes-to` hack that replaces the rhs with an unconstrained infer var requires special casing in the new `try_evaluate_added_goals` function similar to how `evaluate_goal`'s assertion special cases that hack.\n\n2. `assemble_candidates_after_normalizing_self_ty`'s normalization step needs to be reran for each candidate otherwise the found candidates will potentially get a more accurate `QueryResult` when rerunning the projection/trait goal which can effect the `QueryResult` of the projection/trait goal.\nThis is implemented via `EvalCtxt::probe`'s closure's `EvalCtxt` inheriting the added goals of the `EvalCtxt` that `probe` is called on, allowing us to add goals in a probe, and then enter a nested probe for each candidate and evaluate added goals which include the normalization step's goals.\n\nI made `make_canonical_response` evaluate added goals so that it will be hard to mess up the impl of the solver by forgetting to evaluate added goals. Right now the only way to mess this up would be to call `response_no_constraints` (which from the name is obviously weird).\n\nThe visibility of `evaluate_goal` means that it can be called from various `compute_x_goal` or candidate assembly functions, this is generally wrong and we should never call `evaluate_goal` manually, instead we should be calling `add_goal`/`add_goals`. This is solved by moving `evaluate_goal` `evaluate_canonical_goal` and `compute_goal` into `eval_ctxt`'s module and making them private so they cannot be called from elsewhere, forcing people to call `add_goal/s` and `evaluate_added_goals_and_make_canonical_resposne`/`try_evaluate_added_goals`\n\n---\n\nOther changes:\n- removed the `&& false` that was introduced to the assertion in `evaluate_goal` in #108839\n- remove a `!self.did_overflow()` requirement in `search_graph.is_empty()` which causes goals that overflow to ICE\n- made `EvalCtxt::eq` take `&mut self` and add all the nested goals via `add_goals` instead of returning them as 99% of call sites just immediately called `EvalCtxt::add_goals` manually.\n\nr? `````@lcnr`````", "tree": {"sha": "79df85ac3b31609009ce4e8e5f90cbab34168893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79df85ac3b31609009ce4e8e5f90cbab34168893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e79b182fcacd1ad6499a97d428c2176c696eee8e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkGZxWCRBK7hj4Ov3rIwAAhlcIAJQoo00g6qmkhocQEiQA41rS\nWrBy6RpVtfteFC6aQtDFPSNHOwLtHigP03onY1SNuaY8mCs2YdtiogMFQsZpXceV\neR+WxIjjixXK36VRG/Ldpakv3MPDHMZ2ZDvA3AbR/veU83zc2/WvIfFpvJXqtlKR\nF/A4rUoSQmlX0NBrjKx9sTEbWCAXrwImpCv18JucnM9NHgg2leQV3DEOy7Vjh8bz\nBkmy4lsPw/qncSoyK6vkkrrWcEohNXIYUNJeSC02wYdI3D75INSTBR8aw5TIzmr2\n3g8xwyo9b6w43fU1PeHp2Lb/0P8tZE4F7LooAbUSCpUTIorF67BYNhNEpBUFWhQ=\n=0If1\n-----END PGP SIGNATURE-----\n", "payload": "tree 79df85ac3b31609009ce4e8e5f90cbab34168893\nparent 0ef4da126a79f98139a4ddccd7ac368e14f625c0\nparent b85bc19705c68372c1554b13ec4bf5dd5797753f\nauthor nils <48135649+Nilstrieb@users.noreply.github.com> 1679400022 +0100\ncommitter GitHub <noreply@github.com> 1679400022 +0100\n\nRollup merge of #108896 - BoxyUwU:new_solver_add_goal_fn, r=lcnr\n\nnew solver: make all goal evaluation able to be automatically rerun\n\nIt is generally wrong to call `evaluate_goal` multiple times or `evaluate_goal` and `evaluate_all` for the same `QueryResult` without correctly handling rerunning the goals when inference makes progress. Not doing so will result in the assertion in `evaluate_goal` firing because rerunning the goal will lead to a more accurate `QueryResult`.\n\nCurrently there are lots of places that get this wrong and generally it is complex and error prone to handle correctly everywhere. This PR introduces a way to add goals to the `EvalCtxt` and then run all the added goals in a loop so that `evaluate_goal`/`evaluate_all` is not necessary to call manually.\n\nThere are a few complications for making everything work \"right\":\n1. the `normalizes-to` hack that replaces the rhs with an unconstrained infer var requires special casing in the new `try_evaluate_added_goals` function similar to how `evaluate_goal`'s assertion special cases that hack.\n\n2. `assemble_candidates_after_normalizing_self_ty`'s normalization step needs to be reran for each candidate otherwise the found candidates will potentially get a more accurate `QueryResult` when rerunning the projection/trait goal which can effect the `QueryResult` of the projection/trait goal.\nThis is implemented via `EvalCtxt::probe`'s closure's `EvalCtxt` inheriting the added goals of the `EvalCtxt` that `probe` is called on, allowing us to add goals in a probe, and then enter a nested probe for each candidate and evaluate added goals which include the normalization step's goals.\n\nI made `make_canonical_response` evaluate added goals so that it will be hard to mess up the impl of the solver by forgetting to evaluate added goals. Right now the only way to mess this up would be to call `response_no_constraints` (which from the name is obviously weird).\n\nThe visibility of `evaluate_goal` means that it can be called from various `compute_x_goal` or candidate assembly functions, this is generally wrong and we should never call `evaluate_goal` manually, instead we should be calling `add_goal`/`add_goals`. This is solved by moving `evaluate_goal` `evaluate_canonical_goal` and `compute_goal` into `eval_ctxt`'s module and making them private so they cannot be called from elsewhere, forcing people to call `add_goal/s` and `evaluate_added_goals_and_make_canonical_resposne`/`try_evaluate_added_goals`\n\n---\n\nOther changes:\n- removed the `&& false` that was introduced to the assertion in `evaluate_goal` in #108839\n- remove a `!self.did_overflow()` requirement in `search_graph.is_empty()` which causes goals that overflow to ICE\n- made `EvalCtxt::eq` take `&mut self` and add all the nested goals via `add_goals` instead of returning them as 99% of call sites just immediately called `EvalCtxt::add_goals` manually.\n\nr? `````@lcnr`````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e79b182fcacd1ad6499a97d428c2176c696eee8e", "html_url": "https://github.com/rust-lang/rust/commit/e79b182fcacd1ad6499a97d428c2176c696eee8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e79b182fcacd1ad6499a97d428c2176c696eee8e/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef4da126a79f98139a4ddccd7ac368e14f625c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef4da126a79f98139a4ddccd7ac368e14f625c0", "html_url": "https://github.com/rust-lang/rust/commit/0ef4da126a79f98139a4ddccd7ac368e14f625c0"}, {"sha": "b85bc19705c68372c1554b13ec4bf5dd5797753f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85bc19705c68372c1554b13ec4bf5dd5797753f", "html_url": "https://github.com/rust-lang/rust/commit/b85bc19705c68372c1554b13ec4bf5dd5797753f"}], "stats": {"total": 974, "additions": 531, "deletions": 443}, "files": [{"sha": "76cde1a669225247c8d2077e6f988a7b0facb7a9", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -224,7 +224,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if goal.predicate.self_ty().is_ty_var() {\n             return vec![Candidate {\n                 source: CandidateSource::BuiltinImpl,\n-                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n+                result: self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap(),\n             }];\n         }\n \n@@ -261,37 +263,26 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.probe(|this| {\n-            let normalized_ty = this.next_ty_infer();\n+\n+        self.probe(|ecx| {\n+            let normalized_ty = ecx.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match this.evaluate_goal(normalizes_to_goal) {\n-                Ok((_, certainty)) => certainty,\n-                Err(NoSolution) => return,\n-            };\n-            let normalized_ty = this.resolve_vars_if_possible(normalized_ty);\n-\n-            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in winnowing.\n-            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates = this.assemble_and_evaluate_candidates(goal);\n-            for mut normalized_candidate in normalized_candidates {\n-                normalized_candidate.result =\n-                    normalized_candidate.result.unchecked_map(|mut response| {\n-                        // FIXME: This currently hides overflow in the normalization step of the self type\n-                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n-                        // we treat it as non-fatal anyways.\n-                        response.certainty = response.certainty.unify_and(normalization_certainty);\n-                        response\n-                    });\n-                candidates.push(normalized_candidate);\n+            ecx.add_goal(normalizes_to_goal);\n+            if let Ok(_) = ecx.try_evaluate_added_goals() {\n+                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+\n+                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+                // This doesn't work as long as we use `CandidateSource` in winnowing.\n+                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n             }\n-        })\n+        });\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n@@ -516,7 +507,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 } else {\n                     Certainty::AMBIGUOUS\n                 };\n-                return self.make_canonical_response(certainty);\n+                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n             }\n         }\n \n@@ -538,14 +529,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n             if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // We assemble all candidates inside of a probe so by\n                 // making a new canonical response here our result will\n                 // have no constraints.\n-                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+                candidate.result = self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap();\n             }\n         }\n "}, {"sha": "9d45e78ebab044b9d2d12e11ae2333cc1dafaf64", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -48,7 +48,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// - `external_constraints`: additional constraints which aren't expressable\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+    pub(super) fn evaluate_added_goals_and_make_canonical_response(\n+        &mut self,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let goals_certainty = self.try_evaluate_added_goals()?;\n+        let certainty = certainty.unify_and(goals_certainty);\n+\n         let external_constraints = self.compute_external_query_constraints()?;\n \n         let response = Response { var_values: self.var_values, external_constraints, certainty };\n@@ -209,7 +215,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n             // some point. We can figure out how to deal with this once we actually have\n             // an ICE.\n-            let nested_goals = self.eq(param_env, orig, response)?;\n+            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n             assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n         }\n "}, {"sha": "9541292235795a2d8a4b7e9b72adeefe217fbe79", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 334, "deletions": 7, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -2,8 +2,11 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{\n+    DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n+};\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::{\n@@ -13,8 +16,8 @@ use rustc_middle::ty::{\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n-use super::search_graph::SearchGraph;\n-use super::Goal;\n+use super::search_graph::{self, OverflowHandler};\n+use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n@@ -33,14 +36,305 @@ pub struct EvalCtxt<'a, 'tcx> {\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n \n-    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    pub in_projection_eq_hack: bool,\n+    pub(super) nested_goals: NestedGoals<'tcx>,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(super) enum IsNormalizesToHack {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct NestedGoals<'tcx> {\n+    pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+}\n+\n+impl NestedGoals<'_> {\n+    pub(super) fn new() -> Self {\n+        Self { normalizes_to_hack_goal: None, goals: Vec::new() }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.normalizes_to_hack_goal.is_none() && self.goals.is_empty()\n+    }\n+}\n+\n+pub trait InferCtxtEvalExt<'tcx> {\n+    /// Evaluates a goal from **outside** of the trait solver.\n+    ///\n+    /// Using this while inside of the solver is wrong as it uses a new\n+    /// search graph which would break cycle detection.\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution>;\n+}\n+\n+impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+\n+        let mut ecx = EvalCtxt {\n+            search_graph: &mut search_graph,\n+            infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n+            var_values: CanonicalVarValues::dummy(),\n+            nested_goals: NestedGoals::new(),\n+        };\n+        let result = ecx.evaluate_goal(IsNormalizesToHack::No, goal);\n+\n+        assert!(\n+            ecx.nested_goals.is_empty(),\n+            \"root `EvalCtxt` should not have any goals added to it\"\n+        );\n+\n+        assert!(search_graph.is_empty());\n+        result\n+    }\n+}\n+\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    /// The entry point of the solver.\n+    ///\n+    /// This function deals with (coinductive) cycles, overflow, and caching\n+    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n+    /// logic of the solver.\n+    ///\n+    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n+    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n+    /// outside of it.\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        // Deal with overflow, caching, and coinduction.\n+        //\n+        // The actual solver logic happens in `ecx.compute_goal`.\n+        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                nested_goals: NestedGoals::new(),\n+            };\n+            ecx.compute_goal(goal)\n+        })\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        is_normalizes_to_hack: IsNormalizesToHack,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions)\n+            && has_changed\n+            && is_normalizes_to_hack == IsNormalizesToHack::No\n+            && !self.search_graph.in_cycle()\n+        {\n+            debug!(\"rerunning goal to check result is stable\");\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            if !canonical_response.value.var_values.is_identity() {\n+                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+            }\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n+    }\n+\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n+                }\n+                ty::PredicateKind::Subtype(predicate) => {\n+                    self.compute_subtype_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    self.compute_object_safe_goal(trait_def_id)\n+                }\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n+                }\n+                ty::PredicateKind::Ambiguous => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                }\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                }\n+                ty::PredicateKind::AliasEq(lhs, rhs) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n+                }\n+            }\n+        } else {\n+            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            self.add_goal(goal);\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n+    }\n+\n+    // Recursively evaluates all the goals added to this `EvalCtxt` to completion, returning\n+    // the certainty of all the goals.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn try_evaluate_added_goals(&mut self) -> Result<Certainty, NoSolution> {\n+        let mut goals = core::mem::replace(&mut self.nested_goals, NestedGoals::new());\n+        let mut new_goals = NestedGoals::new();\n+\n+        let response = self.repeat_while_none(\n+            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n+            |this| {\n+                let mut has_changed = Err(Certainty::Yes);\n+\n+                if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n+                    let (_, certainty) = match this.evaluate_goal(\n+                        IsNormalizesToHack::Yes,\n+                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    ) {\n+                        Ok(r) => r,\n+                        Err(NoSolution) => return Some(Err(NoSolution)),\n+                    };\n+\n+                    if goal.predicate.projection_ty\n+                        != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n+                    {\n+                        has_changed = Ok(())\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            let goal = this.resolve_vars_if_possible(goal);\n+\n+                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n+                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n+                            // regardless of the rhs.\n+                            //\n+                            // However it is important not to unconditionally replace the rhs with a new infer var\n+                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n+                            // and never propagate any constraints on the new var back to the original var.\n+                            let term = this\n+                                .term_is_fully_unconstrained(goal)\n+                                .then_some(goal.predicate.term)\n+                                .unwrap_or_else(|| {\n+                                    this.next_term_infer_of_kind(goal.predicate.term)\n+                                });\n+                            let projection_pred = ty::ProjectionPredicate {\n+                                term,\n+                                projection_ty: goal.predicate.projection_ty,\n+                            };\n+                            new_goals.normalizes_to_hack_goal =\n+                                Some(goal.with(this.tcx(), projection_pred));\n+\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                for nested_goal in goals.goals.drain(..) {\n+                    let (changed, certainty) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                            Ok(result) => result,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+\n+                    if changed {\n+                        has_changed = Ok(());\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            new_goals.goals.push(nested_goal);\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                core::mem::swap(&mut new_goals, &mut goals);\n+                match has_changed {\n+                    Ok(()) => None,\n+                    Err(certainty) => Some(Ok(certainty)),\n+                }\n+            },\n+        );\n+\n+        self.nested_goals = goals;\n+        response\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n-        self.infcx.probe(|_| f(self))\n+        let mut ecx = EvalCtxt {\n+            infcx: self.infcx,\n+            var_values: self.var_values,\n+            max_input_universe: self.max_input_universe,\n+            search_graph: self.search_graph,\n+            nested_goals: self.nested_goals.clone(),\n+        };\n+        self.infcx.probe(|_| f(&mut ecx))\n     }\n \n     pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -61,6 +355,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         )\n     }\n \n+    /// Returns a ty infer or a const infer depending on whether `kind` is a `Ty` or `Const`.\n+    /// If `kind` is an integer inference variable this will still return a ty infer var.\n+    pub(super) fn next_term_infer_of_kind(&self, kind: ty::Term<'tcx>) -> ty::Term<'tcx> {\n+        match kind.unpack() {\n+            ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n+            ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n+        }\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe\n@@ -137,6 +440,30 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self, param_env), ret)]\n     pub(super) fn eq<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n+    }\n+\n+    /// Equates two values returning the nested goals without adding them\n+    /// to the nested goals of the `EvalCtxt`.\n+    ///\n+    /// If possible, try using `eq` instead which automatically handles nested\n+    /// goals correctly.\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn eq_and_get_goals<T: ToTrace<'tcx>>(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         lhs: T,"}, {"sha": "606c2eaa510518b07595dbd6460773efcc155236", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 49, "deletions": 241, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -15,23 +15,19 @@\n \n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n-use std::mem;\n-\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, MaybeCause, QueryResult, Response,\n+    Goal, QueryResult, Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n-use rustc_span::DUMMY_SP;\n \n-use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n@@ -42,7 +38,7 @@ mod project_goals;\n mod search_graph;\n mod trait_goals;\n \n-pub use eval_ctxt::EvalCtxt;\n+pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n trait CanonicalResponseExt {\n@@ -57,180 +53,18 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-pub trait InferCtxtEvalExt<'tcx> {\n-    /// Evaluates a goal from **outside** of the trait solver.\n-    ///\n-    /// Using this while inside of the solver is wrong as it uses a new\n-    /// search graph which would break cycle detection.\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n-}\n-\n-impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n-\n-        let result = EvalCtxt {\n-            search_graph: &mut search_graph,\n-            infcx: self,\n-            // Only relevant when canonicalizing the response.\n-            max_input_universe: ty::UniverseIndex::ROOT,\n-            var_values: CanonicalVarValues::dummy(),\n-            in_projection_eq_hack: false,\n-        }\n-        .evaluate_goal(goal);\n-\n-        assert!(search_graph.is_empty());\n-        result\n-    }\n-}\n-\n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n-    /// The entry point of the solver.\n-    ///\n-    /// This function deals with (coinductive) cycles, overflow, and caching\n-    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n-    /// logic of the solver.\n-    ///\n-    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n-    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n-    /// outside of it.\n-    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n-    fn evaluate_canonical_goal(\n-        tcx: TyCtxt<'tcx>,\n-        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        // Deal with overflow, caching, and coinduction.\n-        //\n-        // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n-            let (ref infcx, goal, var_values) =\n-                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt {\n-                infcx,\n-                var_values,\n-                max_input_universe: canonical_goal.max_universe,\n-                search_graph,\n-                in_projection_eq_hack: false,\n-            };\n-            ecx.compute_goal(goal)\n-        })\n-    }\n-\n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-        let canonical_response =\n-            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-\n-        let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n-            goal.param_env,\n-            orig_values,\n-            canonical_response,\n-        )?;\n-\n-        // Check that rerunning this query with its inference constraints applied\n-        // doesn't result in new inference constraints and has the same result.\n-        //\n-        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n-        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n-        // could constrain `U` to `u32` which would cause this check to result in a\n-        // solver cycle.\n-        if cfg!(debug_assertions)\n-            && has_changed\n-            && !self.in_projection_eq_hack\n-            && !self.search_graph.in_cycle()\n-            && false\n-        {\n-            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-            let canonical_response =\n-                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n-            }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n-        }\n-\n-        Ok((has_changed, certainty))\n-    }\n-\n-    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n-        let Goal { param_env, predicate } = goal;\n-        let kind = predicate.kind();\n-        if let Some(kind) = kind.no_bound_vars() {\n-            match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n-                    self.compute_trait_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n-                    self.compute_projection_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n-                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n-                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n-                }\n-                ty::PredicateKind::Subtype(predicate) => {\n-                    self.compute_subtype_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Coerce(predicate) => {\n-                    self.compute_coerce_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n-                    .compute_closure_kind_goal(Goal {\n-                        param_env,\n-                        predicate: (def_id, substs, kind),\n-                    }),\n-                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                    self.compute_object_safe_goal(trait_def_id)\n-                }\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n-                }\n-                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n-                // FIXME: implement these predicates :)\n-                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n-                    self.make_canonical_response(Certainty::Yes)\n-                }\n-                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n-                }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n-                }\n-            }\n-        } else {\n-            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n-            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(goal)?;\n-            self.make_canonical_response(certainty)\n-        }\n-    }\n-\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_type_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n         self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_region_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n@@ -239,9 +73,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             &ObligationCause::dummy(),\n             ty::Binder::dummy(goal.predicate),\n         );\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_coerce_goal(\n         &mut self,\n         goal: Goal<'tcx, CoercePredicate<'tcx>>,\n@@ -256,25 +91,26 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_subtype_goal(\n         &mut self,\n         goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n             // FIXME: Do we want to register a subtype relation between these vars?\n             // That won't actually reflect in the query response, so it seems moot.\n-            self.make_canonical_response(Certainty::AMBIGUOUS)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|pred| pred.into()).collect(),\n-            )\n+            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_closure_kind_goal(\n         &mut self,\n         goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n@@ -283,23 +119,25 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n \n         let Some(found_kind) = found_kind else {\n-            return self.make_canonical_response(Certainty::AMBIGUOUS);\n+            return self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         };\n         if found_kind.extends(expected_kind) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_object_safe_goal(&mut self, trait_def_id: DefId) -> QueryResult<'tcx> {\n         if self.tcx().check_is_object_safe(trait_def_id) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_well_formed_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n@@ -309,10 +147,11 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             goal.param_env,\n             goal.predicate,\n         ) {\n-            Some(obligations) => self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|o| o.into()).collect(),\n-            ),\n-            None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+            Some(obligations) => {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),\n         }\n     }\n \n@@ -326,14 +165,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n             let r = ecx.probe(|ecx| {\n-                let (_, certainty) = ecx.evaluate_goal(goal.with(\n+                ecx.add_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n                         projection_ty: alias,\n                         term: other,\n                     }),\n-                ))?;\n-                ecx.make_canonical_response(certainty)\n+                ));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             });\n             debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n             r\n@@ -360,10 +199,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 // Evaluate all 3 potential candidates for the alias' being equal\n                 candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n                 candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|this| {\n+                candidates.push(self.probe(|ecx| {\n                     debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    let nested_goals = this.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    this.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }));\n \n                 debug!(?candidates);\n@@ -379,62 +218,31 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n     ) -> QueryResult<'tcx> {\n         let (ct, ty) = goal.predicate;\n-        let nested_goals = self.eq(goal.param_env, ct.ty(), ty)?;\n-        self.evaluate_all_and_make_canonical_response(nested_goals)\n+        self.eq(goal.param_env, ct.ty(), ty)?;\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n-    // Recursively evaluates a list of goals to completion, returning the certainty\n-    // of all of the goals.\n-    fn evaluate_all(\n-        &mut self,\n-        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> Result<Certainty, NoSolution> {\n-        let mut new_goals = Vec::new();\n-        self.repeat_while_none(\n-            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n-            |this| {\n-                let mut has_changed = Err(Certainty::Yes);\n-                for goal in goals.drain(..) {\n-                    let (changed, certainty) = match this.evaluate_goal(goal) {\n-                        Ok(result) => result,\n-                        Err(NoSolution) => return Some(Err(NoSolution)),\n-                    };\n-\n-                    if changed {\n-                        has_changed = Ok(());\n-                    }\n-\n-                    match certainty {\n-                        Certainty::Yes => {}\n-                        Certainty::Maybe(_) => {\n-                            new_goals.push(goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n-                        }\n-                    }\n-                }\n-\n-                match has_changed {\n-                    Ok(()) => {\n-                        mem::swap(&mut new_goals, &mut goals);\n-                        None\n-                    }\n-                    Err(certainty) => Some(Ok(certainty)),\n-                }\n-            },\n-        )\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn set_normalizes_to_hack_goal(&mut self, goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>) {\n+        assert!(\n+            self.nested_goals.normalizes_to_hack_goal.is_none(),\n+            \"attempted to set the projection eq hack goal when one already exists\"\n+        );\n+        self.nested_goals.normalizes_to_hack_goal = Some(goal);\n     }\n \n-    // Recursively evaluates a list of goals to completion, making a query response.\n-    //\n-    // This is just a convenient way of calling [`EvalCtxt::evaluate_all`],\n-    // then [`EvalCtxt::make_canonical_response`].\n-    fn evaluate_all_and_make_canonical_response(\n-        &mut self,\n-        goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx> {\n-        self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn add_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) {\n+        self.nested_goals.goals.push(goal);\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, goals))]\n+    fn add_goals(&mut self, goals: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>) {\n+        let current_len = self.nested_goals.goals.len();\n+        self.nested_goals.goals.extend(goals);\n+        debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n     fn try_merge_responses(\n@@ -466,7 +274,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         });\n         // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n         // responses and use that for the constraints of this ambiguous response.\n-        let response = self.make_canonical_response(certainty);\n+        let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n         if let Ok(response) = &response {\n             assert!(response.has_no_inference_or_external_constraints());\n         }"}, {"sha": "93d77c39f9580a37e1fc85cabbd9a83a6ed5f0a6", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 55, "deletions": 96, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -20,6 +20,7 @@ use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -36,53 +37,17 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n-            let unconstrained_rhs = match predicate.term.unpack() {\n-                ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n-                ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n-            };\n-            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n+            let unconstrained_predicate = ProjectionPredicate {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n-            });\n-            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n-                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n-            })?;\n-\n-            let nested_eq_goals = self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n-            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n-            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n-        }\n-    }\n-\n-    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        self.in_projection_eq_hack = true;\n-        let result = f(self);\n-        self.in_projection_eq_hack = false;\n-        result\n-    }\n-\n-    /// After normalizing the projection to `normalized_alias` with the given\n-    /// `normalization_certainty`, constrain the inference variable `term` to it\n-    /// and return a query response.\n-    fn eq_term_and_make_canonical_response(\n-        &mut self,\n-        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n-        normalization_certainty: Certainty,\n-        normalized_alias: impl Into<ty::Term<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        // The term of our goal should be fully unconstrained, so this should never fail.\n-        //\n-        // It can however be ambiguous when the `normalized_alias` contains a projection.\n-        let nested_goals = self\n-            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n-            .expect(\"failed to unify with unconstrained term\");\n-\n-        let unify_certainty =\n-            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+            };\n \n-        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n+            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n+            self.try_evaluate_added_goals()?;\n+            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n     }\n }\n \n@@ -111,19 +76,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n-                nested_goals.extend(requirements);\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -139,36 +99,31 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n             ecx.probe(|ecx| {\n+                let tcx = ecx.tcx();\n+\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n \n-                let tcx = ecx.tcx();\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.projection_ty.trait_ref(tcx),\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -195,16 +150,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals = ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-\n-            nested_goals.extend(where_clause_bounds);\n-            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n+            ecx.add_goals(where_clause_bounds);\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -216,7 +170,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -263,7 +217,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n+            ecx.eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -308,14 +263,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-        structural_traits::extract_tupled_inputs_and_output_from_callable(\n-            tcx,\n-            goal.predicate.self_ty(),\n-            goal_kind,\n-        )? else {\n-        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-    };\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                tcx,\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )? {\n+                Some(tupled_inputs_and_output) => tupled_inputs_and_output,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -380,26 +339,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let (_, is_sized_certainty) =\n-                        ecx.evaluate_goal(goal.with(tcx, sized_predicate))?;\n-                    return ecx.eq_term_and_make_canonical_response(\n-                        goal,\n-                        is_sized_certainty,\n-                        tcx.types.unit,\n-                    );\n+                    ecx.add_goal(goal.with(tcx, sized_predicate));\n+                    ecx.eq(goal.param_env, goal.predicate.term, tcx.types.unit.into())?;\n+                    return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n                     match def.non_enum_variant().fields.last() {\n                         None => tcx.types.unit,\n                         Some(field_def) => {\n                             let self_ty = field_def.ty(tcx, substs);\n-                            let new_goal = goal.with(\n+                            ecx.add_goal(goal.with(\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                            );\n-                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                            return ecx.make_canonical_response(certainty);\n+                            ));\n+                            return ecx\n+                                .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                         }\n                     }\n                 }\n@@ -408,12 +363,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty::Tuple(elements) => match elements.last() {\n                     None => tcx.types.unit,\n                     Some(&self_ty) => {\n-                        let new_goal = goal.with(\n+                        ecx.add_goal(goal.with(\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                        );\n-                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                        return ecx.make_canonical_response(certainty);\n+                        ));\n+                        return ecx\n+                            .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                     }\n                 },\n \n@@ -426,7 +381,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n+            ecx.eq(goal.param_env, goal.predicate.term, metadata_ty.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -522,7 +478,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n-        ecx.probe(|ecx| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+        ecx.probe(|ecx| {\n+            ecx.eq(goal.param_env, goal.predicate.term, discriminant.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n     }\n }\n "}, {"sha": "83d77a69c0020e950d7dc24dbb3091fb884f178a", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -39,9 +39,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     }\n \n     pub(super) fn is_empty(&self) -> bool {\n-        self.stack.is_empty()\n-            && self.provisional_cache.is_empty()\n-            && !self.overflow_data.did_overflow()\n+        self.stack.is_empty() && self.provisional_cache.is_empty()\n     }\n \n     /// Whether we're currently in a cycle. This should only be used"}, {"sha": "8ab55c79fc4502ec41a12c8b9bbdbb9df14cb374", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 63, "deletions": 66, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -47,16 +47,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals =\n-                ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-            nested_goals.extend(where_clause_bounds);\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.add_goals(where_clause_bounds);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -73,13 +72,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                nested_goals.extend(requirements);\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -98,7 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n@@ -108,18 +107,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.trait_ref,\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -166,9 +164,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let nested_obligations = tcx\n                 .predicates_of(goal.predicate.def_id())\n                 .instantiate(tcx, goal.predicate.trait_ref.substs);\n-            ecx.evaluate_all_and_make_canonical_response(\n-                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n-            )\n+            ecx.add_goals(nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)));\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -197,7 +194,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.self_ty().has_non_region_infer() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n         let tcx = ecx.tcx();\n@@ -209,7 +206,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             && layout.layout.align().abi == usize_layout.align().abi\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -221,14 +218,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n                 tcx,\n                 goal.predicate.self_ty(),\n                 goal_kind,\n-            )? else {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-        };\n+            )? {\n+                Some(a) => a,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -247,7 +248,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -257,7 +258,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_future_candidate(\n@@ -277,7 +278,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // Async generator unconditionally implement `Future`\n         // Technically, we need to check that the future output type is Sized,\n         // but that's already proven by the generator being WF.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_generator_candidate(\n@@ -317,7 +318,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let a_ty = goal.predicate.self_ty();\n         let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n         if b_ty.is_ty_var() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n         ecx.probe(|ecx| {\n             match (a_ty.kind(), b_ty.kind()) {\n@@ -326,7 +327,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Dyn upcasting is handled separately, since due to upcasting,\n                     // when there are two supertraits that differ by substs, we\n                     // may return more than one query response.\n-                    return Err(NoSolution);\n+                    Err(NoSolution)\n                 }\n                 // `T` -> `dyn Trait` unsizing\n                 (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n@@ -341,29 +342,26 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n                         return Err(NoSolution);\n                     };\n-                    let nested_goals: Vec<_> = data\n-                        .iter()\n-                        // Check that the type implements all of the predicates of the def-id.\n-                        // (i.e. the principal, all of the associated types match, and any auto traits)\n-                        .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n-                        .chain([\n-                            // The type must be Sized to be unsized.\n-                            goal.with(\n-                                tcx,\n-                                ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n-                            ),\n-                            // The type must outlive the lifetime of the `dyn` we're unsizing into.\n-                            goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n-                        ])\n-                        .collect();\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    // Check that the type implements all of the predicates of the def-id.\n+                    // (i.e. the principal, all of the associated types match, and any auto traits)\n+                    ecx.add_goals(\n+                        data.iter().map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty))),\n+                    );\n+                    // The type must be Sized to be unsized.\n+                    ecx.add_goal(\n+                        goal.with(tcx, ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty]))),\n+                    );\n+                    // The type must outlive the lifetime of the `dyn` we're unsizing into.\n+                    ecx.add_goal(\n+                        goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n+                    );\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // `[T; n]` -> `[T]` unsizing\n                 (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n                     // We just require that the element type stays the same\n-                    let nested_goals = ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n                 (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n@@ -397,15 +395,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n                     // types.\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n-                    nested_goals.push(goal.with(\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [a_tail_ty, b_tail_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Tuple unsizing `(.., T)` -> `(.., U)` where `T: Unsize<U>`\n                 (&ty::Tuple(a_tys), &ty::Tuple(b_tys))\n@@ -417,17 +414,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Substitute just the tail field of B., and require that they're equal.\n                     let unsized_a_ty =\n                         tcx.mk_tup_from_iter(a_rest_tys.iter().chain([b_last_ty]).copied());\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal.\n-                    nested_goals.push(goal.with(\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [*a_last_ty, *b_last_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 _ => Err(NoSolution),\n             }\n@@ -477,12 +473,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n \n                 // We also require that A's lifetime outlives B's lifetime.\n-                let mut nested_obligations = ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n-                nested_obligations.push(\n+                ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                ecx.add_goal(\n                     goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         };\n \n@@ -516,7 +511,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         // `DiscriminantKind` is automatically implemented for every type.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n@@ -530,21 +525,23 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         constituent_tys: impl Fn(&EvalCtxt<'_, 'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.probe(|this| {\n-            this.evaluate_all_and_make_canonical_response(\n-                constituent_tys(this, goal.predicate.self_ty())?\n+        self.probe(|ecx| {\n+            ecx.add_goals(\n+                constituent_tys(ecx, goal.predicate.self_ty())?\n                     .into_iter()\n                     .map(|ty| {\n                         goal.with(\n-                            this.tcx(),\n-                            ty::Binder::dummy(goal.predicate.with_self_ty(this.tcx(), ty)),\n+                            ecx.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(ecx.tcx(), ty)),\n                         )\n                     })\n-                    .collect(),\n-            )\n+                    .collect::<Vec<_>>(),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,"}, {"sha": "871e7c2cc5ac139d62caaa4188d0093460f36f7c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79b182fcacd1ad6499a97d428c2176c696eee8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=e79b182fcacd1ad6499a97d428c2176c696eee8e", "patch": "@@ -333,7 +333,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'_, 'tcx> {\n             // FIXME: Technically this folder could be fallible?\n             let nested = self\n                 .ecx\n-                .eq(self.param_env, alias_ty, proj.projection_ty)\n+                .eq_and_get_goals(self.param_env, alias_ty, proj.projection_ty)\n                 .expect(\"expected to be able to unify goal projection with dyn's projection\");\n             // FIXME: Technically we could register these too..\n             assert!(nested.is_empty(), \"did not expect unification to have any nested goals\");"}]}