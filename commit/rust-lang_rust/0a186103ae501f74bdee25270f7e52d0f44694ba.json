{"sha": "0a186103ae501f74bdee25270f7e52d0f44694ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMTg2MTAzYWU1MDFmNzRiZGVlMjUyNzBmN2U1MmQwZjQ0Njk0YmE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-07T19:46:14Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:14:34Z"}, "message": "Move range exhaustiveness check to IntRange::intersection\n\nOnly IntRange should need to worry about range exhaustiveness really.", "tree": {"sha": "59e2c4d64e41185be687704365ebaa3cc59d105e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59e2c4d64e41185be687704365ebaa3cc59d105e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a186103ae501f74bdee25270f7e52d0f44694ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a186103ae501f74bdee25270f7e52d0f44694ba", "html_url": "https://github.com/rust-lang/rust/commit/0a186103ae501f74bdee25270f7e52d0f44694ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a186103ae501f74bdee25270f7e52d0f44694ba/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81db2ee902566dfe8d1324f7849ea202028f68fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/81db2ee902566dfe8d1324f7849ea202028f68fd", "html_url": "https://github.com/rust-lang/rust/commit/81db2ee902566dfe8d1324f7849ea202028f68fd"}], "stats": {"total": 50, "additions": 14, "deletions": 36}, "files": [{"sha": "a8404940be81d9a0c298eced91cfffca3cde0427", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a186103ae501f74bdee25270f7e52d0f44694ba/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a186103ae501f74bdee25270f7e52d0f44694ba/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=0a186103ae501f74bdee25270f7e52d0f44694ba", "patch": "@@ -630,17 +630,6 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    // Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n-    // constructor is a range or constant with an integer type.\n-    fn is_range_and_should_match_exhaustively(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        let ty = match self {\n-            ConstantValue(value, _) => value.ty,\n-            ConstantRange(_, _, ty, _, _) => ty,\n-            _ => return false,\n-        };\n-        IntRange::should_treat_range_exhaustively(tcx, ty)\n-    }\n-\n     fn is_integral_range(&self) -> bool {\n         let ty = match self {\n             ConstantValue(value, _) => value.ty,\n@@ -1468,24 +1457,23 @@ impl<'tcx> IntRange<'tcx> {\n         remaining_ranges\n     }\n \n-    fn intersection(&self, other: &Self) -> Option<Self> {\n+    fn intersection(&self, tcx: TyCtxt<'tcx>, other: &Self) -> Option<Self> {\n         let ty = self.ty;\n         let (lo, hi) = (*self.range.start(), *self.range.end());\n         let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n-        if lo <= other_hi && other_lo <= hi {\n-            let span = other.span;\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n+        if Self::should_treat_range_exhaustively(tcx, ty) {\n+            if lo <= other_hi && other_lo <= hi {\n+                let span = other.span;\n+                Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n+            } else {\n+                None\n+            }\n         } else {\n-            None\n+            // If the range sould not be treated exhaustively, fallback to checking for inclusion.\n+            if other_lo <= lo && hi <= other_hi { Some(self.clone()) } else { None }\n         }\n     }\n \n-    fn is_subrange(&self, other: &Self) -> bool {\n-        let (lo, hi) = (*self.range.start(), *self.range.end());\n-        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n-        other_lo <= lo && hi <= other_hi\n-    }\n-\n     fn suspicious_intersection(&self, other: &Self) -> bool {\n         // `false` in the following cases:\n         // 1     ----      // 1  ----------   // 1 ----        // 1       ----\n@@ -1913,7 +1901,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            ConstantRange(..) if ctor.is_range_and_should_match_exhaustively(tcx) => {\n+            ConstantRange(..) if IntRange::should_treat_range_exhaustively(tcx, ty) => {\n                 // We only care about finding all the subranges within the range of the constructor\n                 // range. Anything else is irrelevant, because it is guaranteed to result in\n                 // `NotUseful`, which is the default case anyway, and can be ignored.\n@@ -1951,7 +1939,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))\n                     })\n                     .flat_map(|(range, row_len)| {\n-                        let intersection = ctor_range.intersection(&range);\n+                        let intersection = ctor_range.intersection(tcx, &range);\n                         let should_lint = ctor_range.suspicious_intersection(&range);\n                         if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n                             // FIXME: for now, only check for overlapping ranges on simple range\n@@ -2309,12 +2297,12 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n-            if constructor.is_range_and_should_match_exhaustively(cx.tcx) {\n+            if constructor.is_integral_range() {\n                 match (\n                     IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n                     IntRange::from_pat(cx.tcx, cx.param_env, pat),\n                 ) {\n-                    (Some(ctor), Some(pat)) => ctor.intersection(&pat).map(|_| {\n+                    (Some(ctor), Some(pat)) => ctor.intersection(cx.tcx, &pat).map(|_| {\n                         // Constructor splitting should ensure that all intersections we encounter\n                         // are actually inclusions.\n                         let (pat_lo, pat_hi) = pat.range.into_inner();\n@@ -2324,16 +2312,6 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n                     }),\n                     _ => None,\n                 }\n-            } else if constructor.is_integral_range() {\n-                // If we have an integer range that should not be matched exhaustively, fallback to\n-                // checking for inclusion.\n-                match (\n-                    IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n-                    IntRange::from_pat(cx.tcx, cx.param_env, pat),\n-                ) {\n-                    (Some(ctor), Some(pat)) if ctor.is_subrange(&pat) => Some(PatStack::default()),\n-                    _ => None,\n-                }\n             } else {\n                 // Fallback for non-ranges and ranges that involve\n                 // floating-point numbers, which are not conveniently handled"}]}