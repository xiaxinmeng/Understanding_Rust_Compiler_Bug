{"sha": "d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4Y2Y4YmE1ZjdlNDE1NDkxM2VhYjNiZTEzZmQxY2MwYjNlMDY5MDY=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-08T22:35:55Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T19:07:37Z"}, "message": "introduce PredicateAtom", "tree": {"sha": "8e093ee89a15a1252ba76ebc041861210ee74325", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e093ee89a15a1252ba76ebc041861210ee74325"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "html_url": "https://github.com/rust-lang/rust/commit/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52af82bdb9bdf2ee481fee82c63993807f771119", "url": "https://api.github.com/repos/rust-lang/rust/commits/52af82bdb9bdf2ee481fee82c63993807f771119", "html_url": "https://github.com/rust-lang/rust/commit/52af82bdb9bdf2ee481fee82c63993807f771119"}], "stats": {"total": 1637, "additions": 795, "deletions": 842}, "files": [{"sha": "8406eb9bc175bd7519e8f55d7e6762ebbfb4a6c3", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -530,11 +530,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n             let predicate = match k1.unpack() {\n                 GenericArgKind::Lifetime(r1) => {\n-                    ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                    ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n                         .to_predicate(self.tcx)\n                 }\n                 GenericArgKind::Type(t1) => {\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n+                    ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n                         .to_predicate(self.tcx)\n                 }\n                 GenericArgKind::Const(..) => {\n@@ -665,7 +665,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n+            predicate: ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n                 .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });"}, {"sha": "5b4d91de3ca92afd3edb38cdb141fbd49338786a", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -308,7 +308,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n+                ty::PredicateAtom::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -400,9 +400,9 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::PredicateKind::ConstEquate(a, b)\n+            ty::PredicateAtom::ConstEquate(a, b)\n         } else {\n-            ty::PredicateKind::ConstEquate(b, a)\n+            ty::PredicateAtom::ConstEquate(b, a)\n         };\n         self.obligations.push(Obligation::new(\n             self.trace.cause.clone(),"}, {"sha": "6009d4e65793b06dfbcc25b2c72b13745e51b2a1", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -6,23 +6,29 @@ pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty;\n+use rustc_middle::ty::fold::TypeFoldable;\n \n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");\n-    param_env.caller_bounds().into_iter().filter_map(move |predicate| match predicate.kind() {\n-        ty::PredicateKind::Projection(..)\n-        | ty::PredicateKind::Trait(..)\n-        | ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::WellFormed(..)\n-        | ty::PredicateKind::ObjectSafe(..)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::TypeOutlives(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => None,\n-        ty::PredicateKind::RegionOutlives(ref data) => data\n-            .no_bound_vars()\n-            .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n-    })\n+    param_env\n+        .caller_bounds()\n+        .into_iter()\n+        .map(ty::Predicate::skip_binders)\n+        .filter(TypeFoldable::has_escaping_bound_vars)\n+        .filter_map(move |atom| match atom {\n+            ty::PredicateAtom::Projection(..)\n+            | ty::PredicateAtom::Trait(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::TypeOutlives(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => None,\n+            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n+                Some(OutlivesBound::RegionSubRegion(r_b, r_a))\n+            }\n+        })\n }"}, {"sha": "4f860c77d6541c068e31aface4ae6da3e056761b", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -100,7 +100,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::PredicateKind::Subtype(ty::SubtypePredicate {\n+                    ty::PredicateAtom::Subtype(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,"}, {"sha": "93fc7f1f3b8a7e97b49ff7f4b3f35afda7a953a4", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -15,16 +15,7 @@ pub fn anonymize_predicate<'tcx>(\n             let new = ty::PredicateKind::ForAll(tcx.anonymize_late_bound_regions(binder));\n             tcx.reuse_or_mk_predicate(pred, new)\n         }\n-        ty::PredicateKind::Trait(_, _)\n-        | ty::PredicateKind::RegionOutlives(_)\n-        | ty::PredicateKind::TypeOutlives(_)\n-        | ty::PredicateKind::Projection(_)\n-        | ty::PredicateKind::WellFormed(_)\n-        | ty::PredicateKind::ObjectSafe(_)\n-        | ty::PredicateKind::ClosureKind(_, _, _)\n-        | ty::PredicateKind::Subtype(_)\n-        | ty::PredicateKind::ConstEvaluatable(_, _)\n-        | ty::PredicateKind::ConstEquate(_, _) => pred,\n+        ty::PredicateKind::Atom(_) => pred,\n     }\n }\n \n@@ -137,11 +128,8 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n-        match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::ForAll(_) => {\n-                bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n-            }\n-            ty::PredicateKind::Trait(data, _) => {\n+        match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -162,36 +150,36 @@ impl Elaborator<'tcx> {\n \n                 self.stack.extend(obligations);\n             }\n-            ty::PredicateKind::WellFormed(..) => {\n+            ty::PredicateAtom::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::PredicateKind::ObjectSafe(..) => {\n+            ty::PredicateAtom::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::PredicateKind::Subtype(..) => {\n+            ty::PredicateAtom::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::PredicateKind::Projection(..) => {\n+            ty::PredicateAtom::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::PredicateKind::ClosureKind(..) => {\n+            ty::PredicateAtom::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::PredicateKind::ConstEvaluatable(..) => {\n+            ty::PredicateAtom::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::PredicateKind::ConstEquate(..) => {\n+            ty::PredicateAtom::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateKind::RegionOutlives(..) => {\n+            ty::PredicateAtom::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -221,15 +209,15 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                                    Some(ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n                                         r, r_min,\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                                Some(ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(\n                                     ty, r_min,\n                                 )))\n                             }"}, {"sha": "d67be44e4f0c5d97d3ca7abd2af8ef99ba63baec", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1202,15 +1202,15 @@ declare_lint_pass!(\n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::PredicateKind::*;\n+        use rustc_middle::ty::PredicateAtom::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n                 // We don't actually look inside of the predicate,\n                 // so it is safe to skip this binder here.\n-                let predicate_kind_name = match predicate.ignore_quantifiers().skip_binder().kind() {\n+                let predicate_kind_name = match predicate.skip_binders() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1225,7 +1225,6 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Subtype(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) => continue,\n-                    ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate)\n                 };\n                 if predicate.is_global() {\n                     cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n@@ -1500,8 +1499,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.ignore_quantifiers().skip_binder().kind() {\n-                &ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n+            .filter_map(|(pred, _)| match pred.skip_binders() {\n+                ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n                     ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n                     _ => None,\n                 },\n@@ -1516,8 +1515,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.ignore_quantifiers().skip_binder().kind() {\n-                &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+            .filter_map(|(pred, _)| match pred.skip_binders() {\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n                     a.is_param(index).then_some(b)\n                 }\n                 _ => None,"}, {"sha": "dcb44ab64449840b526466a7771040bebba06922", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -147,8 +147,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n-                            predicate.ignore_quantifiers().skip_binder().kind()\n+                        if let ty::PredicateAtom::Trait(ref poly_trait_predicate, _) =\n+                            predicate.skip_binders()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "7452089658feba4afb3016a275398835e97bfe0f", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -208,46 +208,48 @@ impl FlagComputation {\n \n     fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n         match kind {\n-            ty::PredicateKind::Trait(trait_pred, _constness) => {\n-                self.add_substs(trait_pred.trait_ref.substs);\n-            }\n-            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n-                self.add_region(a);\n-                self.add_region(b);\n-            }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n-                self.add_ty(ty);\n-                self.add_region(region);\n-            }\n-            ty::PredicateKind::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n-                self.add_ty(a);\n-                self.add_ty(b);\n-            }\n-            &ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n-                self.add_projection_ty(projection_ty);\n-                self.add_ty(ty);\n-            }\n-            ty::PredicateKind::WellFormed(arg) => {\n-                self.add_substs(slice::from_ref(arg));\n-            }\n-            ty::PredicateKind::ObjectSafe(_def_id) => {}\n-            ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n-                self.add_substs(substs);\n-            }\n-            ty::PredicateKind::ConstEvaluatable(_def_id, substs) => {\n-                self.add_substs(substs);\n-            }\n-            ty::PredicateKind::ConstEquate(expected, found) => {\n-                self.add_const(expected);\n-                self.add_const(found);\n-            }\n             ty::PredicateKind::ForAll(binder) => {\n                 let mut computation = FlagComputation::new();\n \n                 computation.add_predicate(binder.skip_binder());\n \n                 self.add_bound_computation(computation);\n             }\n+            &ty::PredicateKind::Atom(atom) => match atom {\n+                ty::PredicateAtom::Trait(trait_pred, _constness) => {\n+                    self.add_substs(trait_pred.trait_ref.substs);\n+                }\n+                ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    self.add_region(a);\n+                    self.add_region(b);\n+                }\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+                    self.add_ty(ty);\n+                    self.add_region(region);\n+                }\n+                ty::PredicateAtom::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n+                    self.add_ty(a);\n+                    self.add_ty(b);\n+                }\n+                ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+                    self.add_projection_ty(projection_ty);\n+                    self.add_ty(ty);\n+                }\n+                ty::PredicateAtom::WellFormed(arg) => {\n+                    self.add_substs(slice::from_ref(&arg));\n+                }\n+                ty::PredicateAtom::ObjectSafe(_def_id) => {}\n+                ty::PredicateAtom::ClosureKind(_def_id, substs, _kind) => {\n+                    self.add_substs(substs);\n+                }\n+                ty::PredicateAtom::ConstEvaluatable(_def_id, substs) => {\n+                    self.add_substs(substs);\n+                }\n+                ty::PredicateAtom::ConstEquate(expected, found) => {\n+                    self.add_const(expected);\n+                    self.add_const(found);\n+                }\n+            },\n         }\n     }\n "}, {"sha": "0ff475fb288a6fa24c75e10d2dca11ffd7fff41a", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1018,7 +1018,7 @@ crate struct PredicateInner<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateInner<'_>, 40);\n+static_assert_size!(PredicateInner<'_>, 48);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -1049,46 +1049,35 @@ impl<'tcx> Predicate<'tcx> {\n         &self.inner.kind\n     }\n \n-    /// Skips `PredicateKind::ForAll`.\n-    pub fn ignore_quantifiers(self) -> Binder<Predicate<'tcx>> {\n+    /// Returns the inner `PredicateAtom`.\n+    ///\n+    /// Note that this method panics in case this predicate has unbound variables.\n+    pub fn skip_binders(self) -> PredicateAtom<'tcx> {\n         match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder,\n-            ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::Trait(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::RegionOutlives(..) => Binder::dummy(self),\n+            &PredicateKind::ForAll(binder) => binder.skip_binder().skip_binders(),\n+            &ty::PredicateKind::Atom(atom) => atom,\n         }\n     }\n \n-    /// Skips `PredicateKind::ForAll`, while allowing for unbound variables.\n-    ///\n-    /// This method requires the `TyCtxt` as it has to shift the unbound variables\n-    /// outwards.\n+    /// Returns the inner `PredicateAtom`.\n     ///\n-    /// Do not use this method if you may end up just skipping the binder, as this\n-    /// would leave the unbound variables at an incorrect binding level.\n-    pub fn ignore_quantifiers_with_unbound_vars(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Binder<Predicate<'tcx>> {\n+    /// Note that this method does not check if predicate has unbound variables,\n+    /// rebinding the returned atom potentially causes the previously bound variables\n+    /// to end up at the wrong binding level.\n+    pub fn skip_binders_unchecked(self) -> PredicateAtom<'tcx> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder.skip_binder().skip_binders(),\n+            &ty::PredicateKind::Atom(atom) => atom,\n+        }\n+    }\n+\n+    pub fn bound_atom(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n         match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder,\n-            ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::Trait(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::RegionOutlives(..) => Binder::wrap_nonbinding(tcx, self),\n+            &PredicateKind::ForAll(binder) => binder.map_bound(|inner| match inner.kind() {\n+                ty::PredicateKind::ForAll(_) => bug!(\"unexpect forall\"),\n+                &ty::PredicateKind::Atom(atom) => atom,\n+            }),\n+            &ty::PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),\n         }\n     }\n \n@@ -1124,6 +1113,15 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {\n+    /// `for<'a>: ...`\n+    ForAll(Binder<Predicate<'tcx>>),\n+\n+    Atom(PredicateAtom<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable, TypeFoldable)]\n+pub enum PredicateAtom<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -1162,9 +1160,6 @@ pub enum PredicateKind<'tcx> {\n \n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n-\n-    /// `for<'a>: ...`\n-    ForAll(Binder<Predicate<'tcx>>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1252,9 +1247,13 @@ impl<'tcx> Predicate<'tcx> {\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n         let substs = trait_ref.skip_binder().substs;\n-        let pred = self.ignore_quantifiers().skip_binder();\n+        let pred = self.skip_binders();\n         let new = pred.subst(tcx, substs);\n-        if new != pred { new.potentially_quantified(tcx, PredicateKind::ForAll) } else { self }\n+        if new != pred {\n+            new.to_predicate(tcx).potentially_quantified(tcx, PredicateKind::ForAll)\n+        } else {\n+            self\n+        }\n     }\n }\n \n@@ -1379,9 +1378,16 @@ impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n     }\n }\n \n+impl ToPredicate<'tcx> for PredicateAtom<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        tcx.mk_predicate(ty::PredicateKind::Atom(*self))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n+        ty::PredicateAtom::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n             .to_predicate(tcx)\n     }\n }\n@@ -1399,94 +1405,88 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         if let Some(pred) = self.value.no_bound_vars() {\n-            ty::PredicateKind::Trait(pred, self.constness)\n+            ty::PredicateAtom::Trait(pred, self.constness).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n                 self.value.map_bound(|pred| {\n-                    ty::PredicateKind::Trait(pred, self.constness).to_predicate(tcx)\n+                    ty::PredicateAtom::Trait(pred, self.constness).to_predicate(tcx)\n                 }),\n             )\n+            .to_predicate(tcx)\n         }\n-        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         if let Some(outlives) = self.no_bound_vars() {\n-            PredicateKind::RegionOutlives(outlives)\n+            PredicateAtom::RegionOutlives(outlives).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n                 self.map_bound(|outlives| {\n-                    PredicateKind::RegionOutlives(outlives).to_predicate(tcx)\n+                    PredicateAtom::RegionOutlives(outlives).to_predicate(tcx)\n                 }),\n             )\n+            .to_predicate(tcx)\n         }\n-        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         if let Some(outlives) = self.no_bound_vars() {\n-            PredicateKind::TypeOutlives(outlives)\n+            PredicateAtom::TypeOutlives(outlives).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n-                self.map_bound(|outlives| PredicateKind::TypeOutlives(outlives).to_predicate(tcx)),\n+                self.map_bound(|outlives| PredicateAtom::TypeOutlives(outlives).to_predicate(tcx)),\n             )\n+            .to_predicate(tcx)\n         }\n-        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         if let Some(proj) = self.no_bound_vars() {\n-            PredicateKind::Projection(proj)\n+            PredicateAtom::Projection(proj).to_predicate(tcx)\n         } else {\n             ty::PredicateKind::ForAll(\n-                self.map_bound(|proj| PredicateKind::Projection(proj).to_predicate(tcx)),\n+                self.map_bound(|proj| PredicateAtom::Projection(proj).to_predicate(tcx)),\n             )\n+            .to_predicate(tcx)\n         }\n-        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(self) -> Option<PolyTraitRef<'tcx>> {\n-        self.ignore_quantifiers()\n-            .map_bound(|pred| match pred.kind() {\n-                &PredicateKind::Trait(ref t, _) => Some(t.trait_ref),\n-                PredicateKind::Projection(..)\n-                | PredicateKind::Subtype(..)\n-                | PredicateKind::RegionOutlives(..)\n-                | PredicateKind::WellFormed(..)\n-                | PredicateKind::ObjectSafe(..)\n-                | PredicateKind::ClosureKind(..)\n-                | PredicateKind::TypeOutlives(..)\n-                | PredicateKind::ConstEvaluatable(..)\n-                | PredicateKind::ConstEquate(..) => None,\n-                PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n-            })\n-            .transpose()\n+        match self.skip_binders() {\n+            PredicateAtom::Trait(t, _) => Some(ty::Binder::bind(t.trait_ref)),\n+            PredicateAtom::Projection(..)\n+            | PredicateAtom::Subtype(..)\n+            | PredicateAtom::RegionOutlives(..)\n+            | PredicateAtom::WellFormed(..)\n+            | PredicateAtom::ObjectSafe(..)\n+            | PredicateAtom::ClosureKind(..)\n+            | PredicateAtom::TypeOutlives(..)\n+            | PredicateAtom::ConstEvaluatable(..)\n+            | PredicateAtom::ConstEquate(..) => None,\n+        }\n     }\n \n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        self.ignore_quantifiers()\n-            .map_bound(|pred| match pred.kind() {\n-                &PredicateKind::TypeOutlives(data) => Some(data),\n-                PredicateKind::Trait(..)\n-                | PredicateKind::Projection(..)\n-                | PredicateKind::Subtype(..)\n-                | PredicateKind::RegionOutlives(..)\n-                | PredicateKind::WellFormed(..)\n-                | PredicateKind::ObjectSafe(..)\n-                | PredicateKind::ClosureKind(..)\n-                | PredicateKind::ConstEvaluatable(..)\n-                | PredicateKind::ConstEquate(..) => None,\n-                PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n-            })\n-            .transpose()\n+        match self.skip_binders() {\n+            PredicateAtom::TypeOutlives(data) => Some(ty::Binder::bind(data)),\n+            PredicateAtom::Trait(..)\n+            | PredicateAtom::Projection(..)\n+            | PredicateAtom::Subtype(..)\n+            | PredicateAtom::RegionOutlives(..)\n+            | PredicateAtom::WellFormed(..)\n+            | PredicateAtom::ObjectSafe(..)\n+            | PredicateAtom::ClosureKind(..)\n+            | PredicateAtom::ConstEvaluatable(..)\n+            | PredicateAtom::ConstEquate(..) => None,\n+        }\n     }\n }\n "}, {"sha": "b0de57e15cc12ac53df4fbe6fdd09e7b97f5de70", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -576,10 +576,8 @@ pub trait PrettyPrinter<'tcx>:\n                         // may contain unbound variables. We therefore do this manually.\n                         //\n                         // FIXME(lcnr): Find out why exactly this is the case :)\n-                        if let ty::PredicateKind::Trait(pred, _) = predicate\n-                            .ignore_quantifiers_with_unbound_vars(self.tcx())\n-                            .skip_binder()\n-                            .kind()\n+                        if let ty::PredicateAtom::Trait(pred, _) =\n+                            predicate.bound_atom(self.tcx()).skip_binder()\n                         {\n                             let trait_ref = ty::Binder::bind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n@@ -2015,38 +2013,40 @@ define_print_and_forward_display! {\n \n     ty::Predicate<'tcx> {\n         match self.kind() {\n-            &ty::PredicateKind::Trait(ref data, constness) => {\n-                if let hir::Constness::Const = constness {\n-                    p!(write(\"const \"));\n+            &ty::PredicateKind::Atom(atom) => match atom {\n+                ty::PredicateAtom::Trait(ref data, constness) => {\n+                    if let hir::Constness::Const = constness {\n+                        p!(write(\"const \"));\n+                    }\n+                    p!(print(data))\n+                }\n+                ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n+                ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n+                ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n+                ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n+                ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                    p!(write(\"the trait `\"),\n+                    print_def_path(trait_def_id, &[]),\n+                    write(\"` is object-safe\"))\n+                }\n+                ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+                    p!(write(\"the closure `\"),\n+                    print_value_path(closure_def_id, &[]),\n+                    write(\"` implements the trait `{}`\", kind))\n+                }\n+                ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n+                    p!(write(\"the constant `\"),\n+                    print_value_path(def.did, substs),\n+                    write(\"` can be evaluated\"))\n+                }\n+                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                    p!(write(\"the constant `\"),\n+                    print(c1),\n+                    write(\"` equals `\"),\n+                    print(c2),\n+                    write(\"`\"))\n                 }\n-                p!(print(data))\n-            }\n-            ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                p!(write(\"the trait `\"),\n-                   print_def_path(trait_def_id, &[]),\n-                   write(\"` is object-safe\"))\n-            }\n-            &ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                p!(write(\"the closure `\"),\n-                   print_value_path(closure_def_id, &[]),\n-                   write(\"` implements the trait `{}`\", kind))\n-            }\n-            &ty::PredicateKind::ConstEvaluatable(def, substs) => {\n-                p!(write(\"the constant `\"),\n-                   print_value_path(def.did, substs),\n-                   write(\"` can be evaluated\"))\n-            }\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n-                p!(write(\"the constant `\"),\n-                   print(c1),\n-                   write(\"` equals `\"),\n-                   print(c2),\n-                   write(\"`\"))\n             }\n             ty::PredicateKind::ForAll(binder) => {\n                 p!(print(binder))"}, {"sha": "cfe076e12070267024cc1046aed8f3b85cbac3c4", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -226,28 +226,36 @@ impl fmt::Debug for ty::Predicate<'tcx> {\n impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::PredicateKind::Trait(ref a, constness) => {\n+            ty::PredicateKind::ForAll(binder) => write!(f, \"ForAll({:?})\", binder),\n+            ty::PredicateKind::Atom(atom) => write!(f, \"{:?}\", atom),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::PredicateAtom<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::PredicateAtom::Trait(ref a, constness) => {\n                 if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)\n             }\n-            ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n-            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+            ty::PredicateAtom::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::Projection(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)\n             }\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n-            ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n-            ty::PredicateKind::ForAll(binder) => write!(f, \"ForAll({:?})\", binder),\n+            ty::PredicateAtom::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n         }\n     }\n }\n@@ -479,36 +487,45 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::PredicateKind::Trait(ref data, constness) => {\n-                tcx.lift(data).map(|data| ty::PredicateKind::Trait(data, constness))\n+            ty::PredicateKind::ForAll(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::ForAll)\n+            }\n+            ty::PredicateKind::Atom(ref atom) => tcx.lift(atom).map(ty::PredicateKind::Atom),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n+    type Lifted = ty::PredicateAtom<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::PredicateAtom::Trait(ref data, constness) => {\n+                tcx.lift(data).map(|data| ty::PredicateAtom::Trait(data, constness))\n             }\n-            ty::PredicateKind::Subtype(ref data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n-            ty::PredicateKind::RegionOutlives(ref data) => {\n-                tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n+            ty::PredicateAtom::Subtype(ref data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n+            ty::PredicateAtom::RegionOutlives(ref data) => {\n+                tcx.lift(data).map(ty::PredicateAtom::RegionOutlives)\n             }\n-            ty::PredicateKind::TypeOutlives(ref data) => {\n-                tcx.lift(data).map(ty::PredicateKind::TypeOutlives)\n+            ty::PredicateAtom::TypeOutlives(ref data) => {\n+                tcx.lift(data).map(ty::PredicateAtom::TypeOutlives)\n             }\n-            ty::PredicateKind::Projection(ref data) => {\n-                tcx.lift(data).map(ty::PredicateKind::Projection)\n+            ty::PredicateAtom::Projection(ref data) => {\n+                tcx.lift(data).map(ty::PredicateAtom::Projection)\n             }\n-            ty::PredicateKind::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateKind::WellFormed),\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateAtom::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateAtom::WellFormed),\n+            ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 tcx.lift(&closure_substs).map(|closure_substs| {\n-                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n+                    ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n-            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n-            }\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                Some(ty::PredicateAtom::ObjectSafe(trait_def_id))\n             }\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n+            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n             }\n-            ty::PredicateKind::ForAll(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::ForAll)\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n             }\n         }\n     }"}, {"sha": "a0d99ac33c04ee1a226b24fe7bb66100ae341f27", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -589,8 +589,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n-                            predicate.ignore_quantifiers().skip_binder().kind()\n+                        if let ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n+                            predicate.skip_binders()\n                         {\n                             if let ty::RegionKind::ReStatic = r {\n                                 found = true;"}, {"sha": "bc5c144cd742c42fb81df884d39f33f1896f97cf", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n+                        ty::PredicateAtom::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1273,7 +1273,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n+                        ty::PredicateAtom::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1617,7 +1617,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateAtom::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -2702,7 +2702,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::PredicateKind::Trait(\n+            Some(ty::PredicateAtom::Trait(\n                 ty::TraitPredicate { trait_ref },\n                 hir::Constness::NotConst,\n             )),"}, {"sha": "de7d7f27186f2b4f59a772db0dd7b3fcc7ad096f", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -24,24 +24,23 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate.ignore_quantifiers().skip_binder().kind() {\n-                ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n-                ty::PredicateKind::RegionOutlives(_)\n-                | ty::PredicateKind::TypeOutlives(_)\n-                | ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::Projection(_)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => continue,\n-                ty::PredicateKind::ObjectSafe(_) => {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::RegionOutlives(_)\n+                | ty::PredicateAtom::TypeOutlives(_)\n+                | ty::PredicateAtom::WellFormed(_)\n+                | ty::PredicateAtom::Projection(_)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => continue,\n+                ty::PredicateAtom::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n                 }\n-                ty::PredicateKind::ClosureKind(..) => {\n+                ty::PredicateAtom::ClosureKind(..) => {\n                     bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n-                ty::PredicateKind::Subtype(_) => {\n+                ty::PredicateAtom::Subtype(_) => {\n                     bug!(\"subtype predicate on function: {:#?}\", predicate)\n                 }\n-                &ty::PredicateKind::Trait(pred, constness) => {\n+                ty::PredicateAtom::Trait(pred, constness) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }"}, {"sha": "9c5fb4ce73450198d6ac4de1c29acc0b811da637", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -85,23 +85,18 @@ where\n     }\n \n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n-        match predicate.kind() {\n-            &ty::PredicateKind::ForAll(pred) => {\n-                // This visitor does not care about bound regions as we only\n-                // look at `DefId`s.\n-                self.visit_predicate(pred.skip_binder())\n-            }\n-            &ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n+        match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n-            &ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+            ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 ty.visit_with(self)\n                     || self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n             }\n-            &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n             }\n-            ty::PredicateKind::RegionOutlives(..) => false,\n+            ty::PredicateAtom::RegionOutlives(..) => false,\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }"}, {"sha": "b84ad93341e8186f773a51d7e94501d8da3cb7a5", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1154,9 +1154,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds.predicates {\n-            if let ty::PredicateKind::Projection(projection) =\n-                predicate.ignore_quantifiers().skip_binder().kind()\n-            {\n+            if let ty::PredicateAtom::Projection(projection) = predicate.skip_binders() {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n@@ -1254,18 +1252,17 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => None,\n-                ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", obligation),\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n+            match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Projection(..)\n+                | ty::PredicateAtom::Trait(..)\n+                | ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => None,\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a"}, {"sha": "6fe67509660bc33e413080dfd465e8f28d1f9cbc", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -415,12 +415,10 @@ impl AutoTraitFinder<'tcx> {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             if let (\n-                ty::PredicateKind::Trait(new_trait, _),\n-                ty::PredicateKind::Trait(old_trait, _),\n-            ) = (\n-                new_pred.ignore_quantifiers().skip_binder().kind(),\n-                old_pred.ignore_quantifiers().skip_binder().kind(),\n-            ) {\n+                ty::PredicateAtom::Trait(new_trait, _),\n+                ty::PredicateAtom::Trait(old_trait, _),\n+            ) = (new_pred.skip_binders(), old_pred.skip_binders())\n+            {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.trait_ref.substs;\n                     let old_substs = old_trait.trait_ref.substs;\n@@ -639,8 +637,8 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n \n-            match predicate.ignore_quantifiers().skip_binder().kind() {\n-                &ty::PredicateKind::Trait(p, _) => {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(p, _) => {\n                     if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n@@ -649,7 +647,7 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                     predicates.push_back(ty::Binder::bind(p));\n                 }\n-                &ty::PredicateKind::Projection(p) => {\n+                ty::PredicateAtom::Projection(p) => {\n                     let p = ty::Binder::bind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n@@ -775,13 +773,13 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                &ty::PredicateKind::RegionOutlives(binder) => {\n+                ty::PredicateAtom::RegionOutlives(binder) => {\n                     let binder = ty::Binder::bind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                &ty::PredicateKind::TypeOutlives(binder) => {\n+                ty::PredicateAtom::TypeOutlives(binder) => {\n                     let binder = ty::Binder::bind(binder);\n                     match (\n                         binder.no_bound_vars(),"}, {"sha": "951e0b2202666748ec2590f5c886ef2e16256375", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -256,11 +256,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                    ty::PredicateKind::ForAll(_) => {\n-                        bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n-                    }\n-                    &ty::PredicateKind::Trait(trait_predicate, _) => {\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n                         let trait_predicate = ty::Binder::bind(trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n@@ -525,14 +522,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err\n                     }\n \n-                    ty::PredicateKind::Subtype(predicate) => {\n+                    ty::PredicateAtom::Subtype(predicate) => {\n                         // Errors for Subtype predicates show up as\n                         // `FulfillmentErrorCode::CodeSubtypeError`,\n                         // not selection error.\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    &ty::PredicateKind::RegionOutlives(predicate) => {\n+                    ty::PredicateAtom::RegionOutlives(predicate) => {\n                         let predicate = ty::Binder::bind(predicate);\n                         let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n@@ -549,7 +546,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::Projection(..) | ty::PredicateKind::TypeOutlives(..) => {\n+                    ty::PredicateAtom::Projection(..) | ty::PredicateAtom::TypeOutlives(..) => {\n                         let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -560,12 +557,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n                         report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n-                    &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                    ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n                         let closure_span =\n                             self.tcx.sess.source_map().guess_head_span(\n@@ -624,7 +621,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return;\n                     }\n \n-                    ty::PredicateKind::WellFormed(ty) => {\n+                    ty::PredicateAtom::WellFormed(ty) => {\n                         if !self.tcx.sess.opts.debugging_opts.chalk {\n                             // WF predicates cannot themselves make\n                             // errors. They can only block due to\n@@ -642,7 +639,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    ty::PredicateKind::ConstEvaluatable(..) => {\n+                    ty::PredicateAtom::ConstEvaluatable(..) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -653,7 +650,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::ConstEquate(..) => {\n+                    ty::PredicateAtom::ConstEquate(..) => {\n                         // Errors for `ConstEquate` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -1090,11 +1087,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n-        let (cond, error) = match (\n-            cond.ignore_quantifiers().skip_binder().kind(),\n-            error.ignore_quantifiers().skip_binder().kind(),\n-        ) {\n-            (ty::PredicateKind::Trait(..), &ty::PredicateKind::Trait(error, _)) => {\n+        let (cond, error) = match (cond.skip_binders(), error.skip_binders()) {\n+            (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n                 (cond, ty::Binder::bind(error))\n             }\n             _ => {\n@@ -1104,9 +1098,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            if let &ty::PredicateKind::Trait(implication, _) =\n-                obligation.predicate.ignore_quantifiers().skip_binder().kind()\n-            {\n+            if let ty::PredicateAtom::Trait(implication, _) = obligation.predicate.skip_binders() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = ty::Binder::bind(implication).to_poly_trait_ref();\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1186,9 +1178,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let &ty::PredicateKind::Projection(data) =\n-                predicate.ignore_quantifiers().skip_binder().kind()\n-            {\n+            if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n@@ -1480,8 +1470,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.ignore_quantifiers().skip_binder().kind() {\n-            &ty::PredicateKind::Trait(data, _) => {\n+        let mut err = match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(data, _) => {\n                 let trait_ref = ty::Binder::bind(data.trait_ref);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n@@ -1580,7 +1570,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::PredicateKind::WellFormed(arg) => {\n+            ty::PredicateAtom::WellFormed(arg) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if arg.references_error() || self.tcx.sess.has_errors() {\n@@ -1600,17 +1590,17 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::Subtype(data) => {\n+            ty::PredicateAtom::Subtype(data) => {\n                 if data.references_error() || self.tcx.sess.has_errors() {\n                     // no need to overload user in such cases\n                     return;\n                 }\n-                let &SubtypePredicate { a_is_expected: _, a, b } = data;\n+                let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n             }\n-            &ty::PredicateKind::Projection(data) => {\n+            ty::PredicateAtom::Projection(data) => {\n                 let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 let ty = data.ty;\n@@ -1733,16 +1723,14 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        let (pred, item_def_id, span) = match (\n-            obligation.predicate.ignore_quantifiers().skip_binder().kind(),\n-            obligation.cause.code.peel_derives(),\n-        ) {\n-            (\n-                ty::PredicateKind::Trait(pred, _),\n-                &ObligationCauseCode::BindingObligation(item_def_id, span),\n-            ) => (pred, item_def_id, span),\n-            _ => return,\n-        };\n+        let (pred, item_def_id, span) =\n+            match (obligation.predicate.skip_binders(), obligation.cause.code.peel_derives()) {\n+                (\n+                    ty::PredicateAtom::Trait(pred, _),\n+                    &ObligationCauseCode::BindingObligation(item_def_id, span),\n+                ) => (pred, item_def_id, span),\n+                _ => return,\n+            };\n \n         let node = match (\n             self.tcx.hir().get_if_local(item_def_id),"}, {"sha": "200de47244e4f8d4c367f1badf660d6c7b3d33b5", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1299,11 +1299,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // the type. The last generator (`outer_generator` below) has information about where the\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n-        let (mut trait_ref, mut target_ty) =\n-            match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                ty::PredicateKind::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n-                _ => (None, None),\n-            };\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n+            _ => (None, None),\n+        };\n         let mut generator = None;\n         let mut outer_generator = None;\n         let mut next_code = Some(&obligation.cause.code);"}, {"sha": "0f6f362490604c73a4ef519bfe3d96cfc71f342f", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 155, "deletions": 149, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -320,154 +320,157 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         match obligation.predicate.kind() {\n             ty::PredicateKind::ForAll(binder) => match binder.skip_binder().kind() {\n+                ty::PredicateKind::ForAll(_) => bug!(\"unexpected forall\"),\n                 // Evaluation will discard candidates using the leak check.\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n-                ty::PredicateKind::Trait(trait_ref, _constness) => {\n-                    let trait_obligation = obligation.with(Binder::bind(*trait_ref));\n+                &ty::PredicateKind::Atom(atom) => match atom {\n+                    ty::PredicateAtom::Trait(trait_ref, _constness) => {\n+                        let trait_obligation = obligation.with(Binder::bind(trait_ref));\n+\n+                        self.process_trait_obligation(\n+                            obligation,\n+                            trait_obligation,\n+                            &mut pending_obligation.stalled_on,\n+                        )\n+                    }\n+                    ty::PredicateAtom::Projection(projection) => {\n+                        let project_obligation = obligation.with(Binder::bind(projection));\n+\n+                        self.process_projection_obligation(\n+                            project_obligation,\n+                            &mut pending_obligation.stalled_on,\n+                        )\n+                    }\n+                    ty::PredicateAtom::RegionOutlives(_)\n+                    | ty::PredicateAtom::TypeOutlives(_)\n+                    | ty::PredicateAtom::WellFormed(_)\n+                    | ty::PredicateAtom::ObjectSafe(_)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::Subtype(_)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => {\n+                        let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n+                        ProcessResult::Changed(mk_pending(vec![obligation.with(pred)]))\n+                    }\n+                },\n+            },\n+            &ty::PredicateKind::Atom(atom) => match atom {\n+                ty::PredicateAtom::Trait(ref data, _) => {\n+                    let trait_obligation = obligation.with(Binder::dummy(*data));\n \n                     self.process_trait_obligation(\n                         obligation,\n                         trait_obligation,\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                ty::PredicateKind::Projection(projection) => {\n-                    let project_obligation = obligation.with(Binder::bind(*projection));\n-\n-                    self.process_projection_obligation(\n-                        project_obligation,\n-                        &mut pending_obligation.stalled_on,\n-                    )\n-                }\n-                ty::PredicateKind::RegionOutlives(_)\n-                | ty::PredicateKind::TypeOutlives(_)\n-                | ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::ObjectSafe(_)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::Subtype(_)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::ForAll(_) => {\n-                    let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n-                    ProcessResult::Changed(mk_pending(vec![obligation.with(pred)]))\n-                }\n-            },\n-            ty::PredicateKind::Trait(ref data, _) => {\n-                let trait_obligation = obligation.with(Binder::dummy(*data));\n-\n-                self.process_trait_obligation(\n-                    obligation,\n-                    trait_obligation,\n-                    &mut pending_obligation.stalled_on,\n-                )\n-            }\n \n-            &ty::PredicateKind::RegionOutlives(data) => {\n-                match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n-                    Ok(()) => ProcessResult::Changed(vec![]),\n-                    Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                ty::PredicateAtom::RegionOutlives(data) => {\n+                    match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n+                        Ok(()) => ProcessResult::Changed(vec![]),\n+                        Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                    }\n                 }\n-            }\n \n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n-                if self.register_region_obligations {\n-                    self.selcx.infcx().register_region_obligation_with_cause(\n-                        t_a,\n-                        r_b,\n-                        &obligation.cause,\n-                    );\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n+                    if self.register_region_obligations {\n+                        self.selcx.infcx().register_region_obligation_with_cause(\n+                            t_a,\n+                            r_b,\n+                            &obligation.cause,\n+                        );\n+                    }\n+                    ProcessResult::Changed(vec![])\n                 }\n-                ProcessResult::Changed(vec![])\n-            }\n \n-            ty::PredicateKind::Projection(ref data) => {\n-                let project_obligation = obligation.with(Binder::dummy(*data));\n+                ty::PredicateAtom::Projection(ref data) => {\n+                    let project_obligation = obligation.with(Binder::dummy(*data));\n \n-                self.process_projection_obligation(\n-                    project_obligation,\n-                    &mut pending_obligation.stalled_on,\n-                )\n-            }\n+                    self.process_projection_obligation(\n+                        project_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n+                }\n \n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                if !self.selcx.tcx().is_object_safe(trait_def_id) {\n-                    ProcessResult::Error(CodeSelectionError(Unimplemented))\n-                } else {\n-                    ProcessResult::Changed(vec![])\n+                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                    if !self.selcx.tcx().is_object_safe(trait_def_id) {\n+                        ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                    } else {\n+                        ProcessResult::Changed(vec![])\n+                    }\n                 }\n-            }\n \n-            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n-                match self.selcx.infcx().closure_kind(closure_substs) {\n-                    Some(closure_kind) => {\n-                        if closure_kind.extends(kind) {\n-                            ProcessResult::Changed(vec![])\n-                        } else {\n-                            ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n+                    match self.selcx.infcx().closure_kind(closure_substs) {\n+                        Some(closure_kind) => {\n+                            if closure_kind.extends(kind) {\n+                                ProcessResult::Changed(vec![])\n+                            } else {\n+                                ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                            }\n                         }\n+                        None => ProcessResult::Unchanged,\n                     }\n-                    None => ProcessResult::Unchanged,\n                 }\n-            }\n \n-            &ty::PredicateKind::WellFormed(arg) => {\n-                match wf::obligations(\n-                    self.selcx.infcx(),\n-                    obligation.param_env,\n-                    obligation.cause.body_id,\n-                    arg,\n-                    obligation.cause.span,\n-                ) {\n-                    None => {\n-                        pending_obligation.stalled_on =\n-                            vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];\n-                        ProcessResult::Unchanged\n+                ty::PredicateAtom::WellFormed(arg) => {\n+                    match wf::obligations(\n+                        self.selcx.infcx(),\n+                        obligation.param_env,\n+                        obligation.cause.body_id,\n+                        arg,\n+                        obligation.cause.span,\n+                    ) {\n+                        None => {\n+                            pending_obligation.stalled_on =\n+                                vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];\n+                            ProcessResult::Unchanged\n+                        }\n+                        Some(os) => ProcessResult::Changed(mk_pending(os)),\n                     }\n-                    Some(os) => ProcessResult::Changed(mk_pending(os)),\n                 }\n-            }\n \n-            &ty::PredicateKind::Subtype(subtype) => {\n-                match self.selcx.infcx().subtype_predicate(\n-                    &obligation.cause,\n-                    obligation.param_env,\n-                    Binder::dummy(subtype),\n-                ) {\n-                    None => {\n-                        // None means that both are unresolved.\n-                        pending_obligation.stalled_on = vec![\n-                            TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),\n-                            TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),\n-                        ];\n-                        ProcessResult::Unchanged\n-                    }\n-                    Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n-                    Some(Err(err)) => {\n-                        let expected_found =\n-                            ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);\n-                        ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n-                            expected_found,\n-                            err,\n-                        ))\n+                ty::PredicateAtom::Subtype(subtype) => {\n+                    match self.selcx.infcx().subtype_predicate(\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                        Binder::dummy(subtype),\n+                    ) {\n+                        None => {\n+                            // None means that both are unresolved.\n+                            pending_obligation.stalled_on = vec![\n+                                TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),\n+                                TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),\n+                            ];\n+                            ProcessResult::Unchanged\n+                        }\n+                        Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                        Some(Err(err)) => {\n+                            let expected_found =\n+                                ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);\n+                            ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n+                                expected_found,\n+                                err,\n+                            ))\n+                        }\n                     }\n                 }\n-            }\n \n-            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-                match self.selcx.infcx().const_eval_resolve(\n-                    obligation.param_env,\n-                    def_id,\n-                    substs,\n-                    None,\n-                    Some(obligation.cause.span),\n-                ) {\n-                    Ok(_) => ProcessResult::Changed(vec![]),\n-                    Err(err) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err))),\n+                ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                    match self.selcx.infcx().const_eval_resolve(\n+                        obligation.param_env,\n+                        def_id,\n+                        substs,\n+                        None,\n+                        Some(obligation.cause.span),\n+                    ) {\n+                        Ok(_) => ProcessResult::Changed(vec![]),\n+                        Err(err) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err))),\n+                    }\n                 }\n-            }\n \n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n                 debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n \n                 let stalled_on = &mut pending_obligation.stalled_on;\n@@ -491,43 +494,46 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                                 );\n                                 Err(ErrorHandled::TooGeneric)\n                             }\n-                            Err(err) => Err(err),\n+                        } else {\n+                            Ok(c)\n                         }\n-                    } else {\n-                        Ok(c)\n-                    }\n-                };\n-\n-                match (evaluate(c1), evaluate(c2)) {\n-                    (Ok(c1), Ok(c2)) => {\n-                        match self\n-                            .selcx\n-                            .infcx()\n-                            .at(&obligation.cause, obligation.param_env)\n-                            .eq(c1, c2)\n-                        {\n-                            Ok(_) => ProcessResult::Changed(vec![]),\n-                            Err(err) => {\n-                                ProcessResult::Error(FulfillmentErrorCode::CodeConstEquateError(\n-                                    ExpectedFound::new(true, c1, c2),\n-                                    err,\n-                                ))\n+                    };\n+\n+                    match (evaluate(c1), evaluate(c2)) {\n+                        (Ok(c1), Ok(c2)) => {\n+                            match self\n+                                .selcx\n+                                .infcx()\n+                                .at(&obligation.cause, obligation.param_env)\n+                                .eq(c1, c2)\n+                            {\n+                                Ok(_) => ProcessResult::Changed(vec![]),\n+                                Err(err) => ProcessResult::Error(\n+                                    FulfillmentErrorCode::CodeConstEquateError(\n+                                        ExpectedFound::new(true, c1, c2),\n+                                        err,\n+                                    ),\n+                                ),\n                             }\n                         }\n-                    }\n-                    (Err(ErrorHandled::Reported(ErrorReported)), _)\n-                    | (_, Err(ErrorHandled::Reported(ErrorReported))) => ProcessResult::Error(\n-                        CodeSelectionError(ConstEvalFailure(ErrorHandled::Reported(ErrorReported))),\n-                    ),\n-                    (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => span_bug!(\n-                        obligation.cause.span(self.selcx.tcx()),\n-                        \"ConstEquate: const_eval_resolve returned an unexpected error\"\n-                    ),\n-                    (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n-                        ProcessResult::Unchanged\n+                        (Err(ErrorHandled::Reported(ErrorReported)), _)\n+                        | (_, Err(ErrorHandled::Reported(ErrorReported))) => {\n+                            ProcessResult::Error(CodeSelectionError(ConstEvalFailure(\n+                                ErrorHandled::Reported(ErrorReported),\n+                            )))\n+                        }\n+                        (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => {\n+                            span_bug!(\n+                                obligation.cause.span(self.selcx.tcx()),\n+                                \"ConstEquate: const_eval_resolve returned an unexpected error\"\n+                            )\n+                        }\n+                        (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n+                            ProcessResult::Unchanged\n+                        }\n                     }\n                 }\n-            }\n+            },\n         }\n     }\n "}, {"sha": "afa48c2f76cf8a0fb79b77e4a6a246518c7e68a1", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -328,8 +328,8 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::TypeOutlives(..) => true,\n+        .drain_filter(|predicate| match predicate.skip_binders() {\n+            ty::PredicateAtom::TypeOutlives(..) => true,\n             _ => false,\n         })\n         .collect();"}, {"sha": "c003e4f8068738ce725d8861838f1199530602a9", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -245,12 +245,12 @@ fn predicates_reference_self(\n         .iter()\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n-            match predicate.ignore_quantifiers().skip_binder().kind() {\n-                ty::PredicateKind::Trait(ref data, _) => {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n                     if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n                 }\n-                ty::PredicateKind::Projection(ref data) => {\n+                ty::PredicateAtom::Projection(ref data) => {\n                     // And similarly for projections. This should be redundant with\n                     // the previous check because any projection should have a\n                     // matching `Trait` predicate with the same inputs, but we do\n@@ -269,15 +269,14 @@ fn predicates_reference_self(\n                         None\n                     }\n                 }\n-                ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::TypeOutlives(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => None,\n-                ty::PredicateKind::ForAll(..) => bug!(\"unexpected predicate: {:?}\", predicate),\n+                ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => None,\n             }\n         })\n         .collect()\n@@ -299,22 +298,19 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::Trait(ref trait_pred, _) => {\n+        match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(ref trait_pred, _) => {\n                 trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n-            ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::RegionOutlives(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => false,\n-            ty::PredicateKind::ForAll(_) => {\n-                bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n-            }\n+            ty::PredicateAtom::Projection(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::RegionOutlives(..)\n+            | ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::TypeOutlives(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => false,\n         }\n     })\n }"}, {"sha": "717b7e2fe574f05c7da7942b98e5d4fa0b4dd034", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -665,7 +665,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n         .obligations\n         .iter()\n         .filter(|obligation| {\n-            match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n+            match obligation.predicate.skip_binders() {\n                 // We found a `T: Foo<X = U>` predicate, let's check\n                 // if `U` references any unresolved type\n                 // variables. In principle, we only care if this\n@@ -675,7 +675,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n                 // indirect obligations (e.g., we project to `?0`,\n                 // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                 // ?0>`).\n-                &ty::PredicateKind::Projection(data) => {\n+                ty::PredicateAtom::Projection(data) => {\n                     infcx.unresolved_type_vars(&ty::Binder::bind(data.ty)).is_some()\n                 }\n \n@@ -933,9 +933,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let &ty::PredicateKind::Projection(data) =\n-            predicate.ignore_quantifiers().skip_binder().kind()\n-        {\n+        if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n             let data = ty::Binder::bind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n@@ -1227,15 +1225,13 @@ fn confirm_object_candidate<'cx, 'tcx>(\n         // select only those projections that are actually projecting an\n         // item with the correct name\n \n-        let env_predicates = env_predicates.filter_map(|o| {\n-            match o.predicate.ignore_quantifiers().skip_binder().kind() {\n-                &ty::PredicateKind::Projection(data)\n-                    if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n-                {\n-                    Some(ty::Binder::bind(data))\n-                }\n-                _ => None,\n+        let env_predicates = env_predicates.filter_map(|o| match o.predicate.skip_binders() {\n+            ty::PredicateAtom::Projection(data)\n+                if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n+            {\n+                Some(ty::Binder::bind(data))\n             }\n+            _ => None,\n         });\n \n         // select those with a relevant trait-ref"}, {"sha": "93ddcb6855400b5cb95571d8d136df5143d483a1", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -15,9 +15,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateKind::Trait(trait_ref, _) =\n-            key.value.predicate.ignore_quantifiers().skip_binder().kind()\n-        {\n+        if let ty::PredicateAtom::Trait(trait_ref, _) = key.value.predicate.skip_binders() {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.self_ty().is_trivially_sized(tcx) {"}, {"sha": "a04636af5796a0d96b5ce4b036119344c344d6bd", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -532,7 +532,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n+                ty::PredicateAtom::ClosureKind(closure_def_id, substs, kind)\n                     .to_predicate(self.tcx()),\n             ));\n         }"}, {"sha": "4123f2938261c6478e92a14e79a8d425fff26ac8", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -408,18 +408,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::ForAll(_) => {\n-                bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n-            }\n-            &ty::PredicateKind::Trait(t, _) => {\n+        match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(t, _) => {\n                 let t = ty::Binder::bind(t);\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            &ty::PredicateKind::Subtype(p) => {\n+            ty::PredicateAtom::Subtype(p) => {\n                 let p = ty::Binder::bind(p);\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n@@ -435,7 +432,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n+            ty::PredicateAtom::WellFormed(arg) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n@@ -449,20 +446,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 None => Ok(EvaluatedToAmbig),\n             },\n \n-            ty::PredicateKind::TypeOutlives(..) | ty::PredicateKind::RegionOutlives(..) => {\n+            ty::PredicateAtom::TypeOutlives(..) | ty::PredicateAtom::RegionOutlives(..) => {\n                 // We do not consider region relationships when evaluating trait matches.\n                 Ok(EvaluatedToOkModuloRegions)\n             }\n \n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n                     Ok(EvaluatedToOk)\n                 } else {\n                     Ok(EvaluatedToErr)\n                 }\n             }\n \n-            &ty::PredicateKind::Projection(data) => {\n+            ty::PredicateAtom::Projection(data) => {\n                 let data = ty::Binder::bind(data);\n                 let project_obligation = obligation.with(data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n@@ -484,7 +481,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n+            ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n                 match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -497,7 +494,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n                 match self.tcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -511,7 +508,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n                 debug!(\"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\", c1, c2);\n \n                 let evaluate = |c: &'tcx ty::Const<'tcx>| {\n@@ -792,8 +789,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n+        let result = match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n@@ -1301,9 +1298,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let matching_bound = predicates.iter().find_map(|bound| {\n-            if let ty::PredicateKind::Trait(pred, _) =\n-                bound.ignore_quantifiers().skip_binder().kind()\n-            {\n+            if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n                 let bound = ty::Binder::bind(pred.trait_ref);\n                 if self.infcx.probe(|_| {\n                     self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref)"}, {"sha": "0ca69c0f76e7a273b865e4ea8c2ff2e2292edb2f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -98,38 +98,40 @@ pub fn predicate_obligations<'a, 'tcx>(\n             // It's ok to skip the binder here because wf code is prepared for it\n             return predicate_obligations(infcx, param_env, body_id, binder.skip_binder(), span);\n         }\n-        ty::PredicateKind::Trait(t, _) => {\n-            wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n-        }\n-        ty::PredicateKind::RegionOutlives(..) => {}\n-        &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n-            wf.compute(ty.into());\n-        }\n-        ty::PredicateKind::Projection(t) => {\n-            wf.compute_projection(t.projection_ty);\n-            wf.compute(t.ty.into());\n-        }\n-        &ty::PredicateKind::WellFormed(arg) => {\n-            wf.compute(arg);\n-        }\n-        ty::PredicateKind::ObjectSafe(_) => {}\n-        ty::PredicateKind::ClosureKind(..) => {}\n-        &ty::PredicateKind::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n-            wf.compute(a.into());\n-            wf.compute(b.into());\n-        }\n-        &ty::PredicateKind::ConstEvaluatable(def, substs) => {\n-            let obligations = wf.nominal_obligations(def.did, substs);\n-            wf.out.extend(obligations);\n-\n-            for arg in substs.iter() {\n+        &ty::PredicateKind::Atom(atom) => match atom {\n+            ty::PredicateAtom::Trait(t, _) => {\n+                wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n+            }\n+            ty::PredicateAtom::RegionOutlives(..) => {}\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                wf.compute(ty.into());\n+            }\n+            ty::PredicateAtom::Projection(t) => {\n+                wf.compute_projection(t.projection_ty);\n+                wf.compute(t.ty.into());\n+            }\n+            ty::PredicateAtom::WellFormed(arg) => {\n                 wf.compute(arg);\n             }\n-        }\n-        &ty::PredicateKind::ConstEquate(c1, c2) => {\n-            wf.compute(c1.into());\n-            wf.compute(c2.into());\n-        }\n+            ty::PredicateAtom::ObjectSafe(_) => {}\n+            ty::PredicateAtom::ClosureKind(..) => {}\n+            ty::PredicateAtom::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n+                wf.compute(a.into());\n+                wf.compute(b.into());\n+            }\n+            ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n+                let obligations = wf.nominal_obligations(def.did, substs);\n+                wf.out.extend(obligations);\n+\n+                for arg in substs.iter() {\n+                    wf.compute(arg);\n+                }\n+            }\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                wf.compute(c1.into());\n+                wf.compute(c2.into());\n+            }\n+        },\n     }\n \n     wf.normalize()\n@@ -196,8 +198,8 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n         };\n \n     // It is fine to skip the binder as we don't care about regions here.\n-    match pred.ignore_quantifiers().skip_binder().kind() {\n-        ty::PredicateKind::Projection(proj) => {\n+    match pred.skip_binders() {\n+        ty::PredicateAtom::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being implemented,\n             // but rather from a \"second order\" obligation, where an associated type has a\n             // projection coming from another associated type. See\n@@ -212,7 +214,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 }\n             }\n         }\n-        ty::PredicateKind::Trait(pred, _) => {\n+        ty::PredicateAtom::Trait(pred, _) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n@@ -317,7 +319,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     traits::Obligation::new(\n                         new_cause,\n                         param_env,\n-                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n+                        ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n                     )\n                 }),\n         );\n@@ -374,7 +376,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             let obligations = self.nominal_obligations(def.did, substs);\n                             self.out.extend(obligations);\n \n-                            let predicate = ty::PredicateKind::ConstEvaluatable(def, substs)\n+                            let predicate = ty::PredicateAtom::ConstEvaluatable(def, substs)\n                                 .to_predicate(self.tcx());\n                             let cause = self.cause(traits::MiscObligation);\n                             self.out.push(traits::Obligation::new(\n@@ -396,7 +398,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 self.out.push(traits::Obligation::new(\n                                     cause,\n                                     self.param_env,\n-                                    ty::PredicateKind::WellFormed(resolved_constant.into())\n+                                    ty::PredicateAtom::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n                                 ));\n                             }\n@@ -482,7 +484,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(rty, r))\n+                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(rty, r))\n                                 .to_predicate(self.tcx()),\n                         ));\n                     }\n@@ -573,7 +575,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             traits::Obligation::new(\n                                 cause.clone(),\n                                 param_env,\n-                                ty::PredicateKind::ObjectSafe(did).to_predicate(tcx),\n+                                ty::PredicateAtom::ObjectSafe(did).to_predicate(tcx),\n                             )\n                         }));\n                     }\n@@ -599,7 +601,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()),\n+                            ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result."}, {"sha": "75785076d9ac1cd92d114d3fef82b720353e62b0", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -79,13 +79,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n                 // FIXME(chalk): forall\n-                match predicate\n-                    .ignore_quantifiers_with_unbound_vars(interner.tcx)\n-                    .skip_binder()\n-                    .kind()\n-                {\n-                    ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n-                    &ty::PredicateKind::Trait(predicate, _) => {\n+                match predicate.bound_atom(interner.tcx).skip_binder() {\n+                    ty::PredicateAtom::Trait(predicate, _) => {\n                         let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, &predicate);\n@@ -106,7 +101,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    &ty::PredicateKind::RegionOutlives(predicate) => {\n+                    ty::PredicateAtom::RegionOutlives(predicate) => {\n                         let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, &predicate);\n@@ -131,8 +126,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                         )\n                     }\n                     // FIXME(chalk): need to add TypeOutlives\n-                    ty::PredicateKind::TypeOutlives(_) => None,\n-                    &ty::PredicateKind::Projection(predicate) => {\n+                    ty::PredicateAtom::TypeOutlives(_) => None,\n+                    ty::PredicateAtom::Projection(predicate) => {\n                         let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, &predicate);\n@@ -153,12 +148,12 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    ty::PredicateKind::WellFormed(..)\n-                    | ty::PredicateKind::ObjectSafe(..)\n-                    | ty::PredicateKind::ClosureKind(..)\n-                    | ty::PredicateKind::Subtype(..)\n-                    | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..) => {\n+                    ty::PredicateAtom::WellFormed(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => {\n                         bug!(\"unexpected predicate {}\", predicate)\n                     }\n                 }\n@@ -191,12 +186,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n         // FIXME(chalk): forall\n-        match self.ignore_quantifiers_with_unbound_vars(interner.tcx).skip_binder().kind() {\n-            ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n-            &ty::PredicateKind::Trait(predicate, _) => {\n+        match self.bound_atom(interner.tcx).skip_binder() {\n+            ty::PredicateAtom::Trait(predicate, _) => {\n                 ty::Binder::bind(predicate).lower_into(interner)\n             }\n-            &ty::PredicateKind::RegionOutlives(predicate) => {\n+            ty::PredicateAtom::RegionOutlives(predicate) => {\n                 let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &predicate);\n@@ -216,13 +210,13 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 )\n             }\n             // FIXME(chalk): TypeOutlives\n-            ty::PredicateKind::TypeOutlives(_predicate) => {\n+            ty::PredicateAtom::TypeOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            &ty::PredicateKind::Projection(predicate) => {\n+            ty::PredicateAtom::Projection(predicate) => {\n                 ty::Binder::bind(predicate).lower_into(interner)\n             }\n-            ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+            ty::PredicateAtom::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n                     // `FromEnv`. However, when we \"lower\" Params, we don't update\n@@ -252,18 +246,18 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n \n-            ty::PredicateKind::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n-                chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(*t)),\n+            ty::PredicateAtom::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n+                chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(t)),\n             ),\n \n             // FIXME(chalk): other predicates\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n-            ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => {\n+            ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n         }\n@@ -561,9 +555,8 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n         // FIXME(chalk): forall\n-        match self.ignore_quantifiers_with_unbound_vars(interner.tcx).skip_binder().kind() {\n-            ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n-            &ty::PredicateKind::Trait(predicate, _) => {\n+        match self.bound_atom(interner.tcx).skip_binder() {\n+            ty::PredicateAtom::Trait(predicate, _) => {\n                 let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &predicate);\n@@ -573,7 +566,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            &ty::PredicateKind::RegionOutlives(predicate) => {\n+            ty::PredicateAtom::RegionOutlives(predicate) => {\n                 let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &predicate);\n@@ -586,15 +579,15 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                     }),\n                 ))\n             }\n-            ty::PredicateKind::TypeOutlives(_predicate) => None,\n-            ty::PredicateKind::Projection(_predicate) => None,\n-            ty::PredicateKind::WellFormed(_ty) => None,\n-\n-            ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n+            ty::PredicateAtom::TypeOutlives(_predicate) => None,\n+            ty::PredicateAtom::Projection(_predicate) => None,\n+            ty::PredicateAtom::WellFormed(_ty) => None,\n+\n+            ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n         }\n     }\n }"}, {"sha": "de3096eac9b193df599036065968bbcfe796ac73", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -95,29 +95,31 @@ fn compute_implied_outlives_bounds<'tcx>(\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind() {\n-                ty::PredicateKind::ForAll(..) => vec![],\n-                ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => vec![],\n-                &ty::PredicateKind::WellFormed(arg) => {\n-                    wf_args.push(arg);\n-                    vec![]\n-                }\n+                &ty::PredicateKind::ForAll(..) => vec![],\n+                &ty::PredicateKind::Atom(atom) => match atom {\n+                    ty::PredicateAtom::Trait(..)\n+                    | ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::Projection(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => vec![],\n+                    ty::PredicateAtom::WellFormed(arg) => {\n+                        wf_args.push(arg);\n+                        vec![]\n+                    }\n \n-                &ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                    vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n-                }\n+                    ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n+                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                    }\n \n-                &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                    let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n-                    let mut components = smallvec![];\n-                    tcx.push_outlives_components(ty_a, &mut components);\n-                    implied_bounds_from_components(r_b, components)\n-                }\n+                    ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                        let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n+                        let mut components = smallvec![];\n+                        tcx.push_outlives_components(ty_a, &mut components);\n+                        implied_bounds_from_components(r_b, components)\n+                    }\n+                },\n             }\n         }));\n     }"}, {"sha": "83aee31a39f3c223ae6af037ac29ebda5cacc3b2", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -40,16 +40,15 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n }\n \n fn not_outlives_predicate(p: &ty::Predicate<'tcx>) -> bool {\n-    match p.ignore_quantifiers().skip_binder().kind() {\n-        ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n-        ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", p),\n-        ty::PredicateKind::Trait(..)\n-        | ty::PredicateKind::Projection(..)\n-        | ty::PredicateKind::WellFormed(..)\n-        | ty::PredicateKind::ObjectSafe(..)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => true,\n+    match p.skip_binders() {\n+        ty::PredicateAtom::RegionOutlives(..) | ty::PredicateAtom::TypeOutlives(..) => false,\n+        ty::PredicateAtom::Trait(..)\n+        | ty::PredicateAtom::Projection(..)\n+        | ty::PredicateAtom::WellFormed(..)\n+        | ty::PredicateAtom::ObjectSafe(..)\n+        | ty::PredicateAtom::ClosureKind(..)\n+        | ty::PredicateAtom::Subtype(..)\n+        | ty::PredicateAtom::ConstEvaluatable(..)\n+        | ty::PredicateAtom::ConstEquate(..) => true,\n     }\n }"}, {"sha": "139ed6dcd350c8b616b936b0599f8fbbab049dd9", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -140,7 +140,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n             self.prove_predicate(\n-                ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n+                ty::PredicateAtom::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n             );\n         }\n \n@@ -155,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n+        self.prove_predicate(ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "7f954dacf3e893c4a3b96bf9a9d0c2ad6c74fce0", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -392,22 +392,22 @@ fn associated_type_projection_predicates(\n \n     let predicates = item_predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;\n-        match pred.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::Trait(tr, _) => {\n+        match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(tr, _) => {\n                 if let ty::Projection(p) = tr.self_ty().kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::Projection(proj) => {\n+            ty::PredicateAtom::Projection(proj) => {\n                 if let ty::Projection(p) = proj.projection_ty.self_ty().kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::TypeOutlives(outlives) => {\n+            ty::PredicateAtom::TypeOutlives(outlives) => {\n                 if let ty::Projection(p) = outlives.0.kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n@@ -443,23 +443,23 @@ fn opaque_type_projection_predicates(\n \n     let filtered_predicates = predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;\n-        match pred.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::Trait(tr, _) => {\n+        match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(tr, _) => {\n                 if let ty::Opaque(opaque_def_id, opaque_substs) = tr.self_ty().kind {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::Projection(proj) => {\n+            ty::PredicateAtom::Projection(proj) => {\n                 if let ty::Opaque(opaque_def_id, opaque_substs) = proj.projection_ty.self_ty().kind\n                 {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::TypeOutlives(outlives) => {\n+            ty::PredicateAtom::TypeOutlives(outlives) => {\n                 if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.0.kind {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n@@ -470,7 +470,7 @@ fn opaque_type_projection_predicates(\n                 }\n             }\n             // These can come from elaborating other predicates\n-            ty::PredicateKind::RegionOutlives(_) => return None,\n+            ty::PredicateAtom::RegionOutlives(_) => return None,\n             _ => {}\n         }\n         tcx.sess.delay_span_bug("}, {"sha": "79d2f104a525fe32b2a796e046b0a982ae4e293a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1706,8 +1706,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                    &ty::PredicateKind::Trait(pred, _) => {\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Trait(pred, _) => {\n                         let pred = ty::Binder::bind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n@@ -1716,7 +1716,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    &ty::PredicateKind::Projection(pred) => {\n+                    ty::PredicateAtom::Projection(pred) => {\n                         let pred = ty::Binder::bind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that."}, {"sha": "255f611cfa3572c2f5aca33850d0b608afb36e39", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -206,8 +206,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let &ty::PredicateKind::Projection(proj_predicate) =\n-                    obligation.predicate.ignore_quantifiers().skip_binder().kind()\n+                if let ty::PredicateAtom::Projection(proj_predicate) =\n+                    obligation.predicate.skip_binders()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n@@ -631,8 +631,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let &ty::PredicateKind::Projection(proj_predicate) =\n-                obligation.predicate.ignore_quantifiers().skip_binder().kind()\n+            if let ty::PredicateAtom::Projection(proj_predicate) =\n+                obligation.predicate.skip_binders()\n             {\n                 self.deduce_future_output_from_projection(\n                     obligation.cause.span,"}, {"sha": "c7e9b97e2dbde3565f4af38b03a9bb5827edc8fb", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -582,8 +582,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                &ty::PredicateKind::Trait(trait_pred, _)\n+            let trait_pred = match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n                     if unsize_did == trait_pred.def_id() {"}, {"sha": "88c47b38ccc40b4e3ade7e772416e6304abd54f0", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -226,14 +226,11 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (\n-                predicate.ignore_quantifiers().skip_binder().kind(),\n-                p.ignore_quantifiers().skip_binder().kind(),\n-            ) {\n-                (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n+            match (predicate.skip_binders(), p.skip_binders()) {\n+                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n                     relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n                 }\n-                (&ty::PredicateKind::Projection(a), &ty::PredicateKind::Projection(b)) => {\n+                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n                     relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n                 }\n                 _ => predicate == p,"}, {"sha": "41e37ee9752521cd91c6ee644175b7fe536a94e0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -448,24 +448,21 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n-            .filter_map(|obligation| {\n-                match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                    ty::PredicateKind::Trait(trait_pred, _)\n-                        if trait_pred.def_id() == sized_def_id =>\n-                    {\n-                        let span =\n-                            predicates\n-                                .predicates\n-                                .iter()\n-                                .zip(predicates.spans.iter())\n-                                .find_map(|(p, span)| {\n-                                    if *p == obligation.predicate { Some(*span) } else { None }\n-                                })\n-                                .unwrap_or(rustc_span::DUMMY_SP);\n-                        Some((trait_pred, span))\n-                    }\n-                    _ => None,\n+            .filter_map(|obligation| match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n+                    let span = predicates\n+                        .predicates\n+                        .iter()\n+                        .zip(predicates.spans.iter())\n+                        .find_map(\n+                            |(p, span)| {\n+                                if *p == obligation.predicate { Some(*span) } else { None }\n+                            },\n+                        )\n+                        .unwrap_or(rustc_span::DUMMY_SP);\n+                    Some((trait_pred, span))\n                 }\n+                _ => None,\n             })\n             .find_map(|(trait_pred, span)| match trait_pred.self_ty().kind {\n                 ty::Dynamic(..) => Some(span),"}, {"sha": "c9a4df0317abcd2eb9b95a12247da93e045d239f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(method_ty.into()).to_predicate(tcx),\n+            ty::PredicateAtom::WellFormed(method_ty.into()).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "e569d1c443a6975641748bc3e976a2775121a569", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -798,24 +798,23 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n-        let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| match predicate\n-            .kind()\n+        let bounds = self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(|predicate| match predicate\n         {\n-            ty::PredicateKind::Trait(ref trait_predicate, _) => {\n-                match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n-                    ty::Param(ref p) if *p == param_ty => Some(trait_predicate.to_poly_trait_ref()),\n+            ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                match trait_predicate.trait_ref.self_ty().kind {\n+                    ty::Param(ref p) if *p == param_ty => Some(ty::Binder::bind(trait_predicate.trait_ref)),\n                     _ => None,\n                 }\n             }\n-            ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::RegionOutlives(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => None,\n+            ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::Projection(..)\n+            | ty::PredicateAtom::RegionOutlives(..)\n+            | ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::TypeOutlives(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => None,\n         });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {"}, {"sha": "07cc8332b84cfebb2ccf8bd972d735427324bf5d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -576,10 +576,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // this is kind of ugly.\n                         |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) = (\n-                                &self_ty.kind,\n-                                parent_pred.ignore_quantifiers().skip_binder().kind(),\n-                            ) {\n+                            if let (ty::Param(_), ty::PredicateAtom::Trait(p, _)) =\n+                                (&self_ty.kind, parent_pred.skip_binders())\n+                            {\n                                 if let ty::Adt(def, _) = p.trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n                                         self.tcx.hir().get(self.tcx.hir().as_local_hir_id(def_id))\n@@ -631,8 +630,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.ignore_quantifiers().skip_binder().kind() {\n-                            &ty::PredicateKind::Projection(pred) => {\n+                        match pred.skip_binders() {\n+                            ty::PredicateAtom::Projection(pred) => {\n                                 let pred = ty::Binder::bind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n@@ -651,7 +650,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n-                            &ty::PredicateKind::Trait(poly_trait_ref, _) => {\n+                            ty::PredicateAtom::Trait(poly_trait_ref, _) => {\n                                 let poly_trait_ref = ty::Binder::bind(poly_trait_ref);\n                                 let p = poly_trait_ref.skip_binder().trait_ref;\n                                 let self_ty = p.self_ty();\n@@ -959,11 +958,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 unsatisfied_predicates.iter().all(|(p, _)| {\n-                    match p.ignore_quantifiers().skip_binder().kind() {\n+                    match p.skip_binders() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them.\n-                        ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n-                        ty::PredicateKind::Projection(p) => {\n+                        ty::PredicateAtom::Trait(t, _) => t.def_id() == info.def_id,\n+                        ty::PredicateAtom::Projection(p) => {\n                             p.projection_ty.item_def_id == info.def_id\n                         }\n                         _ => false,"}, {"sha": "61520e292365037c98038db79828a1c4026c8da4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -2400,8 +2400,8 @@ fn bounds_from_generic_predicates<'tcx>(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.ignore_quantifiers().skip_binder().kind() {\n-            ty::PredicateKind::Trait(trait_predicate, _) => {\n+        match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n@@ -2410,7 +2410,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                     entry.push(trait_predicate.def_id());\n                 }\n             }\n-            ty::PredicateKind::Projection(projection_pred) => {\n+            ty::PredicateAtom::Projection(projection_pred) => {\n                 projections.push(ty::Binder::bind(projection_pred));\n             }\n             _ => {}\n@@ -2938,9 +2938,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n-                    match predicate.kind() {\n-                        ty::PredicateKind::Trait(ref data, _)\n-                            if data.skip_binder().self_ty().is_param(index) =>\n+                    match predicate.skip_binders() {\n+                        ty::PredicateAtom::Trait(data, _)\n+                            if data.self_ty().is_param(index) =>\n                         {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n@@ -3612,7 +3612,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(arg).to_predicate(self.tcx),\n+            ty::PredicateAtom::WellFormed(arg).to_predicate(self.tcx),\n         ));\n     }\n \n@@ -3894,23 +3894,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .pending_obligations()\n             .into_iter()\n             .filter_map(move |obligation| {\n-                match obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n-                    ty::PredicateKind::ForAll(_) => {\n-                        bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n-                    }\n-                    &ty::PredicateKind::Projection(data) => {\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Projection(data) => {\n                         Some((ty::Binder::bind(data).to_poly_trait_ref(self.tcx), obligation))\n                     }\n-                    &ty::PredicateKind::Trait(data, _) => {\n+                    ty::PredicateAtom::Trait(data, _) => {\n                         Some((ty::Binder::bind(data).to_poly_trait_ref(), obligation))\n                     }\n-                    ty::PredicateKind::Subtype(..) => None,\n-                    ty::PredicateKind::RegionOutlives(..) => None,\n-                    ty::PredicateKind::TypeOutlives(..) => None,\n-                    ty::PredicateKind::WellFormed(..) => None,\n-                    ty::PredicateKind::ObjectSafe(..) => None,\n-                    ty::PredicateKind::ConstEvaluatable(..) => None,\n-                    ty::PredicateKind::ConstEquate(..) => None,\n+                    ty::PredicateAtom::Subtype(..) => None,\n+                    ty::PredicateAtom::RegionOutlives(..) => None,\n+                    ty::PredicateAtom::TypeOutlives(..) => None,\n+                    ty::PredicateAtom::WellFormed(..) => None,\n+                    ty::PredicateAtom::ObjectSafe(..) => None,\n+                    ty::PredicateAtom::ConstEvaluatable(..) => None,\n+                    ty::PredicateAtom::ConstEquate(..) => None,\n                     // N.B., this predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where\n                     // `ClosureType` represents some `Closure`. It can't\n@@ -3919,7 +3916,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // this closure yet; this is exactly why the other\n                     // code is looking for a self type of a unresolved\n                     // inference variable.\n-                    ty::PredicateKind::ClosureKind(..) => None,\n+                    ty::PredicateAtom::ClosureKind(..) => None,\n                 }\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n@@ -4249,8 +4246,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::PredicateKind::Trait(predicate, _) =\n-                error.obligation.predicate.ignore_quantifiers().skip_binder().kind()\n+            if let ty::PredicateAtom::Trait(predicate, _) =\n+                error.obligation.predicate.skip_binders()\n             {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n@@ -4298,8 +4295,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate, _) =\n-                            error.obligation.predicate.ignore_quantifiers().skip_binder().kind()\n+                        if let ty::PredicateAtom::Trait(predicate, _) =\n+                            error.obligation.predicate.skip_binders()\n                         {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n@@ -5372,7 +5369,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     item_def_id,\n                 };\n \n-                let predicate = ty::PredicateKind::Projection(ty::ProjectionPredicate {\n+                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n                     projection_ty,\n                     ty: expected,\n                 })"}, {"sha": "50d9a1ebd2c249d6671862e9af6a37cfc726e959", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -429,7 +429,7 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::PredicateKind::ConstEvaluatable(\n+                    ty::PredicateAtom::ConstEvaluatable(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n                     )"}, {"sha": "d906c5c05c019eadef5e1e8f87c2ceaebd8d0cb1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -552,8 +552,8 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate.ignore_quantifiers().skip_binder().kind() {\n-                ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n+            .filter(|(predicate, _)| match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(data, _) => data.self_ty().is_param(index),\n                 _ => false,\n             }),\n     );\n@@ -1004,7 +1004,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred.ignore_quantifiers().skip_binder().kind() {\n+        if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1960,7 +1960,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             predicates.push((\n-                                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region))\n+                                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region))\n                                     .to_predicate(tcx)\n                                     .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n@@ -1979,7 +1979,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n                         .to_predicate(icx.tcx);\n \n                     (pred.potentially_quantified(icx.tcx, ty::PredicateKind::ForAll), span)\n@@ -2110,7 +2110,7 @@ fn predicates_from_bound<'tcx>(\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n+            let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n                 .to_predicate(astconv.tcx())\n                 .potentially_quantified(astconv.tcx(), ty::PredicateKind::ForAll);\n             vec![(pred, lifetime.span)]"}, {"sha": "7c80315ee194d52c5cf0f183f2918c79a182e8a6", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -182,9 +182,7 @@ pub fn setup_constraining_predicates<'tcx>(\n         for j in i..predicates.len() {\n             // Note that we don't have to care about binders here,\n             // as the impl trait ref never contains any late-bound regions.\n-            if let ty::PredicateKind::Projection(projection) =\n-                predicates[j].0.ignore_quantifiers().skip_binder().kind()\n-            {\n+            if let ty::PredicateAtom::Projection(projection) = predicates[j].0.skip_binders() {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very\n                 // trait."}, {"sha": "8257c6ce92547b8d51378a9797845c1a6b8a3385", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -198,9 +198,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateKind::Projection(proj) =\n-            predicate.ignore_quantifiers().skip_binder().kind()\n-        {\n+        if let ty::PredicateAtom::Projection(proj) = predicate.skip_binders() {\n             let projection_ty = proj.projection_ty;\n             let projected_ty = proj.ty;\n \n@@ -361,13 +359,13 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate.ignore_quantifiers().skip_binder().kind() {\n+    match predicate.skip_binders() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateAtom::Trait(pred, hir::Constness::NotConst) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -394,20 +392,19 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate.ignore_quantifiers().skip_binder().kind() {\n-        ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n-        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n+    match predicate.skip_binders() {\n+        ty::PredicateAtom::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }\n-        ty::PredicateKind::Trait(_, hir::Constness::Const)\n-        | ty::PredicateKind::RegionOutlives(_)\n-        | ty::PredicateKind::TypeOutlives(_)\n-        | ty::PredicateKind::Projection(_)\n-        | ty::PredicateKind::WellFormed(_)\n-        | ty::PredicateKind::Subtype(_)\n-        | ty::PredicateKind::ObjectSafe(_)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => None,\n+        ty::PredicateAtom::Trait(_, hir::Constness::Const)\n+        | ty::PredicateAtom::RegionOutlives(_)\n+        | ty::PredicateAtom::TypeOutlives(_)\n+        | ty::PredicateAtom::Projection(_)\n+        | ty::PredicateAtom::WellFormed(_)\n+        | ty::PredicateAtom::Subtype(_)\n+        | ty::PredicateAtom::ObjectSafe(_)\n+        | ty::PredicateAtom::ClosureKind(..)\n+        | ty::PredicateAtom::ConstEvaluatable(..)\n+        | ty::PredicateAtom::ConstEquate(..) => None,\n     }\n }"}, {"sha": "135960a4c111414dc1f0d2e187e9890e83d16089", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -29,10 +29,8 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate.ignore_quantifiers().skip_binder().kind() {\n-                    ty::PredicateKind::ForAll(_) => bug!(\"unepected predicate: {:?}\", predicate),\n-\n-                    ty::PredicateKind::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {\n+                match predicate.skip_binders() {\n+                    ty::PredicateAtom::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {\n                         insert_outlives_predicate(\n                             tcx,\n                             (*ty).into(),\n@@ -42,7 +40,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(OutlivesPredicate(ref reg1, ref reg2)) => {\n+                    ty::PredicateAtom::RegionOutlives(OutlivesPredicate(ref reg1, ref reg2)) => {\n                         insert_outlives_predicate(\n                             tcx,\n                             (*reg1).into(),\n@@ -52,14 +50,14 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::Trait(..)\n-                    | ty::PredicateKind::Projection(..)\n-                    | ty::PredicateKind::WellFormed(..)\n-                    | ty::PredicateKind::ObjectSafe(..)\n-                    | ty::PredicateKind::ClosureKind(..)\n-                    | ty::PredicateKind::Subtype(..)\n-                    | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..) => (),\n+                    ty::PredicateAtom::Trait(..)\n+                    | ty::PredicateAtom::Projection(..)\n+                    | ty::PredicateAtom::WellFormed(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => (),\n                 }\n             }\n "}, {"sha": "823a0235b176dd45527465a1720afce2c472ec2c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -31,8 +31,12 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|(out_pred, _)| match out_pred.kind() {\n-                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n-                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::Atom(ty::PredicateAtom::RegionOutlives(p)) => {\n+                                p.to_string()\n+                            }\n+                            ty::PredicateKind::Atom(ty::PredicateAtom::TypeOutlives(p)) => {\n+                                p.to_string()\n+                            }\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -85,13 +89,13 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n+                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n                                 .to_predicate(tcx)\n                                 .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n                                 region1, region2,\n                             ))\n                             .to_predicate(tcx)"}, {"sha": "98d8f100b27d9187bdd4504857186d4e35c6bf80", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -315,11 +315,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let regions = match pred.ignore_quantifiers().skip_binder().kind() {\n-            &ty::PredicateKind::Trait(poly_trait_pred, _) => {\n+        let regions = match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(poly_trait_pred, _) => {\n                 tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_trait_pred))\n             }\n-            &ty::PredicateKind::Projection(poly_proj_pred) => {\n+            ty::PredicateAtom::Projection(poly_proj_pred) => {\n                 tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_proj_pred))\n             }\n             _ => return FxHashSet::default(),\n@@ -465,8 +465,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .iter()\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n-                    || match p.ignore_quantifiers().skip_binder().kind() {\n-                        ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n+                    || match p.skip_binders() {\n+                        ty::PredicateAtom::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "728453deecff6fa4b77f4126c5cbcaedd78d21a9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -480,19 +480,18 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        match self.ignore_quantifiers().skip_binder().kind() {\n-            &ty::PredicateKind::Trait(pred, _) => Some(ty::Binder::bind(pred).clean(cx)),\n-            &ty::PredicateKind::Subtype(pred) => Some(ty::Binder::bind(pred).clean(cx)),\n-            &ty::PredicateKind::RegionOutlives(pred) => ty::Binder::bind(pred).clean(cx),\n-            &ty::PredicateKind::TypeOutlives(pred) => ty::Binder::bind(pred).clean(cx),\n-            &ty::PredicateKind::Projection(pred) => Some(ty::Binder::bind(pred).clean(cx)),\n+        match self.skip_binders() {\n+            ty::PredicateAtom::Trait(pred, _) => Some(ty::Binder::bind(pred).clean(cx)),\n+            ty::PredicateAtom::Subtype(pred) => Some(ty::Binder::bind(pred).clean(cx)),\n+            ty::PredicateAtom::RegionOutlives(pred) => ty::Binder::bind(pred).clean(cx),\n+            ty::PredicateAtom::TypeOutlives(pred) => ty::Binder::bind(pred).clean(cx),\n+            ty::PredicateAtom::Projection(pred) => Some(ty::Binder::bind(pred).clean(cx)),\n \n-            ty::PredicateKind::ForAll(_) => panic!(\"unexpected predicate: {:?}\", self),\n-            ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => panic!(\"not user writable\"),\n+            ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -755,18 +754,18 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .flat_map(|(p, _)| {\n                 let mut projection = None;\n                 let param_idx = (|| {\n-                    match p.ignore_quantifiers().skip_binder().kind() {\n-                        &ty::PredicateKind::Trait(pred, _constness) => {\n+                    match p.skip_binders() {\n+                        ty::PredicateAtom::Trait(pred, _constness) => {\n                             if let ty::Param(param) = pred.self_ty().kind {\n                                 return Some(param.index);\n                             }\n                         }\n-                        &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                        ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n                             if let ty::Param(param) = ty.kind {\n                                 return Some(param.index);\n                             }\n                         }\n-                        &ty::PredicateKind::Projection(p) => {\n+                        ty::PredicateAtom::Projection(p) => {\n                             if let ty::Param(param) = p.projection_ty.self_ty().kind {\n                                 projection = Some(ty::Binder::bind(p));\n                                 return Some(param.index);\n@@ -1663,15 +1662,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|predicate| {\n                         // Note: The substs of opaque types can contain unbound variables,\n                         // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n-                        let trait_ref = match predicate\n-                            .ignore_quantifiers_with_unbound_vars(cx.tcx)\n-                            .skip_binder()\n-                            .kind()\n-                        {\n-                            ty::PredicateKind::Trait(tr, _constness) => {\n+                        let trait_ref = match predicate.bound_atom(cx.tcx).skip_binder() {\n+                            ty::PredicateAtom::Trait(tr, _constness) => {\n                                 ty::Binder::bind(tr.trait_ref)\n                             }\n-                            ty::PredicateKind::TypeOutlives(pred) => {\n+                            ty::PredicateAtom::TypeOutlives(pred) => {\n                                 if let Some(r) = pred.1.clean(cx) {\n                                     regions.push(GenericBound::Outlives(r));\n                                 }\n@@ -1691,10 +1686,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n-                                if let ty::PredicateKind::Projection(proj) = pred\n-                                    .ignore_quantifiers_with_unbound_vars(cx.tcx)\n-                                    .skip_binder()\n-                                    .kind()\n+                                // We never rebind `proj`, so `skip_binders_unchecked` is safe here.\n+                                if let ty::PredicateAtom::Projection(proj) =\n+                                    pred.skip_binders_unchecked()\n                                 {\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == trait_ref.skip_binder()"}, {"sha": "0f995a60c22fd06d0247391a850ad588524251ef", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -141,9 +141,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::PredicateKind::Trait(pred, _) =\n-                pred.ignore_quantifiers().skip_binder().kind()\n-            {\n+            if let ty::PredicateAtom::Trait(pred, _) = pred.skip_binders() {\n                 if pred.trait_ref.self_ty() == self_ty { Some(pred.def_id()) } else { None }\n             } else {\n                 None"}, {"sha": "0fdb5b8c2a48e9a6217c96f58dec7808be398e1b", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Opaque, PredicateKind::Trait};\n+use rustc_middle::ty::{Opaque, PredicateAtom::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n                                     infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate.ignore_quantifiers().skip_binder().kind() {\n+                                    if let Trait(trait_pred, _) = obligation.predicate.skip_binders() {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n                                             trait_pred.self_ty(),"}, {"sha": "2c70183d87666d7aa0ac5ea93fc94d4406c7579d", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1559,7 +1559,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let ty::Opaque(def_id, _) = ret_ty.kind {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n-                    if let ty::PredicateKind::Projection(projection_predicate) = predicate.ignore_quantifiers().skip_binder().kind() {\n+                    if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n                         // walk the associated type and check for Self\n                         if contains_self_ty(projection_predicate.ty) {\n                             return;"}, {"sha": "095778777449831305e59398bda6ce891da4de73", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n-                if let ty::PredicateKind::Trait(pred, _) = obligation.predicate.kind() {\n+                if let ty::PredicateKind::Atom(ty::PredicateAtom::Trait(pred, _)) = obligation.predicate.kind() {\n                     if pred.def_id() == sized_trait {\n                         return None;\n                     }"}, {"sha": "655b1133cf74f14430d2a2a3415a70a53cfde184", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d8cf8ba5f7e4154913eab3be13fd1cc0b3e06906", "patch": "@@ -1263,7 +1263,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.predicates_of(*def_id).predicates {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.ignore_quantifiers().skip_binder().kind() {\n+                if let ty::PredicateAtom::Trait(trait_predicate, _) = predicate.skip_binders() {\n                     if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }"}]}