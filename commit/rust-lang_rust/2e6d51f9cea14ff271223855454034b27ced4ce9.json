{"sha": "2e6d51f9cea14ff271223855454034b27ced4ce9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNmQ1MWY5Y2VhMTRmZjI3MTIyMzg1NTQ1NDAzNGIyN2NlZDRjZTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-02T09:13:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-06T04:38:48Z"}, "message": "std::rt: Use AtomicUint instead of intrinsics in comm", "tree": {"sha": "85da9650070524b79d812a4ae8470b82d3fe43d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85da9650070524b79d812a4ae8470b82d3fe43d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e6d51f9cea14ff271223855454034b27ced4ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6d51f9cea14ff271223855454034b27ced4ce9", "html_url": "https://github.com/rust-lang/rust/commit/2e6d51f9cea14ff271223855454034b27ced4ce9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e6d51f9cea14ff271223855454034b27ced4ce9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2bedb1b868a634885df9f8a277bec1915c98fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2bedb1b868a634885df9f8a277bec1915c98fc2", "html_url": "https://github.com/rust-lang/rust/commit/e2bedb1b868a634885df9f8a277bec1915c98fc2"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "7f93dae00b7c6d57a8bc6cabee2eba7f6d2f968b", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e6d51f9cea14ff271223855454034b27ced4ce9/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6d51f9cea14ff271223855454034b27ced4ce9/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=2e6d51f9cea14ff271223855454034b27ced4ce9", "patch": "@@ -22,7 +22,7 @@ use ops::Drop;\n use kinds::Owned;\n use rt::sched::{Scheduler, Coroutine};\n use rt::local::Local;\n-use unstable::intrinsics::{atomic_xchg, atomic_load};\n+use unstable::atomics::{AtomicUint, SeqCst};\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n@@ -34,14 +34,14 @@ use cell::Cell;\n /// * 2 - both endpoints are alive\n /// * 1 - either the sender or the receiver is dead, determined by context\n /// * <ptr> - A pointer to a blocked Task that can be transmuted to ~Task\n-type State = int;\n+type State = uint;\n \n static STATE_BOTH: State = 2;\n static STATE_ONE: State = 1;\n \n /// The heap-allocated structure shared between two endpoints.\n struct Packet<T> {\n-    state: State,\n+    state: AtomicUint,\n     payload: Option<T>,\n }\n \n@@ -70,7 +70,7 @@ pub struct PortOneHack<T> {\n \n pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n     let packet: ~Packet<T> = ~Packet {\n-        state: STATE_BOTH,\n+        state: AtomicUint::new(STATE_BOTH),\n         payload: None\n     };\n \n@@ -114,7 +114,7 @@ impl<T> ChanOne<T> {\n             // reordering of the payload write. This also issues an\n             // acquire barrier that keeps the subsequent access of the\n             // ~Task pointer from being reordered.\n-            let oldstate = atomic_xchg(&mut (*packet).state, STATE_ONE);\n+            let oldstate = (*packet).state.swap(STATE_ONE, SeqCst);\n             match oldstate {\n                 STATE_BOTH => {\n                     // Port is not waiting yet. Nothing to do\n@@ -175,7 +175,7 @@ impl<T> PortOne<T> {\n                 // of the payload. Also issues a release barrier to prevent reordering\n                 // of any previous writes to the task structure.\n                 let task_as_state: State = cast::transmute(task);\n-                let oldstate = atomic_xchg(&mut (*packet).state, task_as_state);\n+                let oldstate = (*packet).state.swap(task_as_state, SeqCst);\n                 match oldstate {\n                     STATE_BOTH => {\n                         // Data has not been sent. Now we're blocked.\n@@ -227,7 +227,7 @@ impl<T> Peekable<T> for PortOne<T> {\n     fn peek(&self) -> bool {\n         unsafe {\n             let packet: *mut Packet<T> = self.inner.packet();\n-            let oldstate = atomic_load(&mut (*packet).state);\n+            let oldstate = (*packet).state.load(SeqCst);\n             match oldstate {\n                 STATE_BOTH => false,\n                 STATE_ONE => (*packet).payload.is_some(),\n@@ -244,7 +244,7 @@ impl<T> Drop for ChanOneHack<T> {\n \n         unsafe {\n             let this = cast::transmute_mut(self);\n-            let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n+            let oldstate = (*this.packet()).state.swap(STATE_ONE, SeqCst);\n             match oldstate {\n                 STATE_BOTH => {\n                     // Port still active. It will destroy the Packet.\n@@ -271,7 +271,7 @@ impl<T> Drop for PortOneHack<T> {\n \n         unsafe {\n             let this = cast::transmute_mut(self);\n-            let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n+            let oldstate = (*this.packet()).state.swap(STATE_ONE, SeqCst);\n             match oldstate {\n                 STATE_BOTH => {\n                     // Chan still active. It will destroy the packet."}]}