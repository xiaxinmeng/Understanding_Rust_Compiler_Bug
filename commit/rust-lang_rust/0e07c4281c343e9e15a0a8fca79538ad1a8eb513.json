{"sha": "0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMDdjNDI4MWMzNDNlOWUxNWEwYThmY2E3OTUzOGFkMWE4ZWI1MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-09T17:19:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-09T17:19:56Z"}, "message": "Auto merge of #54762 - RalfJung:miri-validate, r=oli-obk\n\nPrepare miri engine for enforcing validity invariant during execution\n\nIn particular, make recursive checking of references optional, and add a `const_mode` parameter that says whether `usize` is allowed to contain a pointer. Also refactor validation a bit to be type-driven at the \"leafs\" (primitive types), and separately validate scalar layout to catch `NonNull` violations (which it did not properly validate before).\n\nFixes https://github.com/rust-lang/rust/issues/53826\nAlso fixes https://github.com/rust-lang/rust/issues/54751\n\nr? @oli-obk", "tree": {"sha": "a85d262a0e07a888acd31611f18884a750ef90b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a85d262a0e07a888acd31611f18884a750ef90b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "html_url": "https://github.com/rust-lang/rust/commit/0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1643a8968753226dab7ab3c9fee826f097550f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1643a8968753226dab7ab3c9fee826f097550f2", "html_url": "https://github.com/rust-lang/rust/commit/e1643a8968753226dab7ab3c9fee826f097550f2"}, {"sha": "fe96f8235ca4929652950d62341d3de83527de71", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe96f8235ca4929652950d62341d3de83527de71", "html_url": "https://github.com/rust-lang/rust/commit/fe96f8235ca4929652950d62341d3de83527de71"}], "stats": {"total": 985, "additions": 634, "deletions": 351}, "files": [{"sha": "e83b514c69190bc49827df4b6043c7fae021c961", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -560,6 +560,10 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher)\n             },\n+            FunctionRetMismatch(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n             NoMirFor(ref s) => s.hash_stable(hcx, hasher),\n             UnterminatedCString(ptr) => ptr.hash_stable(hcx, hasher),\n             PointerOutOfBounds {"}, {"sha": "fe466e247c91749b8f5a2f6dc1b5be7ead80b362", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -186,6 +186,7 @@ pub enum EvalErrorKind<'tcx, O> {\n \n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n+    FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionArgCountMismatch,\n     NoMirFor(String),\n     UnterminatedCString(Pointer),\n@@ -294,7 +295,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n         use self::EvalErrorKind::*;\n         match *self {\n             MachineError(ref inner) => inner,\n-            FunctionAbiMismatch(..) | FunctionArgMismatch(..) | FunctionArgCountMismatch =>\n+            FunctionAbiMismatch(..) | FunctionArgMismatch(..) | FunctionRetMismatch(..)\n+            | FunctionArgCountMismatch =>\n                 \"tried to call a function through a function pointer of incompatible type\",\n             InvalidMemoryAccess =>\n                 \"tried to access memory through an invalid pointer\",\n@@ -470,6 +472,10 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                 write!(f, \"tried to call a function with argument of type {:?} \\\n                            passing data of type {:?}\",\n                     callee_ty, caller_ty),\n+            FunctionRetMismatch(caller_ty, callee_ty) =>\n+                write!(f, \"tried to call a function with return type {:?} \\\n+                           passing return place of type {:?}\",\n+                    callee_ty, caller_ty),\n             FunctionArgCountMismatch =>\n                 write!(f, \"tried to call a function with incorrect number of arguments\"),\n             BoundsCheck { ref len, ref index } =>"}, {"sha": "3f62883c6a57b549cead28b2fcc35ec7532e7177", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -492,6 +492,10 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n                 tcx.lift(&a)?,\n                 tcx.lift(&b)?,\n             ),\n+            FunctionRetMismatch(a, b) => FunctionRetMismatch(\n+                tcx.lift(&a)?,\n+                tcx.lift(&b)?,\n+            ),\n             FunctionArgCountMismatch => FunctionArgCountMismatch,\n             NoMirFor(ref s) => NoMirFor(s.clone()),\n             UnterminatedCString(ptr) => UnterminatedCString(ptr),"}, {"sha": "d18edf22dc10c29c3a1902a088134497c6a5063d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -1558,15 +1558,13 @@ fn validate_const<'a, 'tcx>(\n     let ecx = ::rustc_mir::const_eval::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n         let op = ecx.const_to_op(constant)?;\n-        let mut todo = vec![(op, Vec::new())];\n-        let mut seen = FxHashSet();\n-        seen.insert(op);\n-        while let Some((op, mut path)) = todo.pop() {\n+        let mut ref_tracking = ::rustc_mir::interpret::RefTracking::new(op);\n+        while let Some((op, mut path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n                 op,\n                 &mut path,\n-                &mut seen,\n-                &mut todo,\n+                Some(&mut ref_tracking),\n+                /* const_mode */ true,\n             )?;\n         }\n         Ok(())"}, {"sha": "0c669b9ec31a798012e8ac2790ebf7d03686ac47", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -274,6 +274,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     type MemoryKinds = !;\n \n     const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n+    const ENFORCE_VALIDITY: bool = false; // for now, we don't\n \n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,"}, {"sha": "e15a721731e8744b3f14001abefacc1b64b89e9e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -231,6 +231,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     /// Mark a storage as live, killing the previous content and returning it.\n     /// Remember to deallocate that!\n     pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n+        assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n         let layout = self.layout_of_local(self.cur_frame(), local)?;\n@@ -242,6 +243,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     /// Returns the old value of the local.\n     /// Remember to deallocate that!\n     pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n+        assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n         mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n@@ -446,6 +448,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             let dummy =\n                 LocalValue::Live(Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)));\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n+            // Return place is handled specially by the `eval_place` functions, and the\n+            // entry in `locals` should never be used. Make it dead, to be sure.\n+            locals[mir::RETURN_PLACE] = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them"}, {"sha": "f90a7efce47b373fb4250397d673fdbaf5dd4ac1", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -33,6 +33,9 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// The memory kind to use for mutated statics -- or None if those are not supported.\n     const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// Whether to enforce the validity invariant\n+    const ENFORCE_VALIDITY: bool;\n+\n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n     fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;"}, {"sha": "5437c8ababc27642f753c42adb32a71250867f7d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -19,7 +19,7 @@\n use std::collections::VecDeque;\n use std::ptr;\n \n-use rustc::ty::{self, Instance, query::TyCtxtAt};\n+use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, ConstValue, GlobalId,\n                             EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n@@ -235,7 +235,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n             Scalar::Ptr(ptr) => {\n-                let (size, align) = self.get_size_and_align(ptr.alloc_id)?;\n+                let (size, align) = self.get_size_and_align(ptr.alloc_id);\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n                 if ptr.offset > size {\n@@ -284,7 +284,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// If you want to check bounds before doing a memory access, be sure to\n     /// check the pointer one past the end of your access, then everything will\n     /// work out exactly.\n-    pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds_ptr(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset.bytes() > allocation_size {\n@@ -296,6 +296,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         Ok(())\n     }\n+\n+    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    #[inline(always)]\n+    pub fn check_bounds(&self, ptr: Pointer, size: Size, access: bool) -> EvalResult<'tcx> {\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds_ptr(ptr.offset(size, &*self)?, access)\n+    }\n }\n \n /// Allocation accessors\n@@ -352,19 +359,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_size_and_align(&self, id: AllocId) -> EvalResult<'tcx, (Size, Align)> {\n-        Ok(match self.get(id) {\n-            Ok(alloc) => (Size::from_bytes(alloc.bytes.len() as u64), alloc.align),\n-            Err(err) => match err.kind {\n-                EvalErrorKind::DanglingPointerDeref =>\n-                    // This should be in the dead allocation map\n-                    *self.dead_alloc_map.get(&id).expect(\n-                        \"allocation missing in dead_alloc_map\"\n-                    ),\n-                // E.g. a function ptr allocation\n-                _ => return Err(err)\n+    pub fn get_size_and_align(&self, id: AllocId) -> (Size, Align) {\n+        if let Ok(alloc) = self.get(id) {\n+            return (Size::from_bytes(alloc.bytes.len() as u64), alloc.align);\n+        }\n+        // Could also be a fn ptr or extern static\n+        match self.tcx.alloc_map.lock().get(id) {\n+            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1, 1).unwrap()),\n+            Some(AllocType::Static(did)) => {\n+                // The only way `get` couldn\u00c4t have worked here is if this is an extern static\n+                assert!(self.tcx.is_foreign_item(did));\n+                // Use size and align of the type\n+                let ty = self.tcx.type_of(did);\n+                let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                (layout.size, layout.align)\n             }\n-        })\n+            _ => {\n+                // Must be a deallocated pointer\n+                *self.dead_alloc_map.get(&id).expect(\n+                    \"allocation missing in dead_alloc_map\"\n+                )\n+            }\n+        }\n     }\n \n     pub fn get_mut(\n@@ -524,8 +540,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n+        self.check_bounds(ptr, size, true)?;\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -569,8 +584,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, &self)?, true)?;\n+        self.check_bounds(ptr, size, true)?;\n \n         self.mark_definedness(ptr, size, true)?;\n         self.clear_relocations(ptr, size)?;"}, {"sha": "9e0efaa9c78ef6208c0eb1daf16b1394e6ff01be", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -35,3 +35,5 @@ pub use self::memory::{Memory, MemoryKind};\n pub use self::machine::Machine;\n \n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n+\n+pub use self::validity::RefTracking;"}, {"sha": "b75ceb61febb7c41337f29adb1ded33e3664745f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -131,6 +131,18 @@ impl MemPlace {\n }\n \n impl<'tcx> MPlaceTy<'tcx> {\n+    /// Produces a MemPlace that works for ZST but nothing else\n+    #[inline]\n+    pub fn dangling(layout: TyLayout<'tcx>, cx: impl HasDataLayout) -> Self {\n+        MPlaceTy {\n+            mplace: MemPlace::from_scalar_ptr(\n+                Scalar::from_uint(layout.align.abi(), cx.pointer_size()),\n+                layout.align\n+            ),\n+            layout\n+        }\n+    }\n+\n     #[inline]\n     fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align), layout }\n@@ -555,6 +567,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n+        // Check that the value actually is okay for that type\n+        if M::ENFORCE_VALIDITY {\n+            // Something changed somewhere, better make sure it matches the type!\n+            let op = OpTy { op: Operand::Immediate(src_val), layout: dest.layout };\n+            self.validate_operand(op, &mut vec![], None, /*const_mode*/false)?;\n+        }\n+\n         // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n@@ -576,7 +595,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         self.write_value_to_mplace(src_val, dest)\n     }\n \n-    /// Write a value to memory\n+    /// Write a value to memory. This does NOT do validation, so you better had already\n+    /// done that before calling this!\n     fn write_value_to_mplace(\n         &mut self,\n         value: Value,\n@@ -640,12 +660,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}\", *dest, *src);\n-        let (dest_ptr, dest_align) = self.force_allocation(dest)?.to_scalar_ptr_align();\n+        let dest = self.force_allocation(dest)?;\n+        let (dest_ptr, dest_align) = dest.to_scalar_ptr_align();\n         self.memory.copy(\n             src_ptr, src_align,\n             dest_ptr, dest_align,\n             src.layout.size, false\n-        )\n+        )?;\n+        if M::ENFORCE_VALIDITY {\n+            // Something changed somewhere, better make sure it matches the type!\n+            self.validate_operand(dest.into(), &mut vec![], None, /*const_mode*/false)?;\n+        }\n+        Ok(())\n     }\n \n     /// Make sure that a place is in memory, and return where it is.\n@@ -668,6 +694,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         // that has different alignment than the outer field.\n                         let local_layout = self.layout_of_local(frame, local)?;\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n+                        // We don't have to validate as we can assume the local\n+                        // was already valid for its type.\n                         self.write_value_to_mplace(value, ptr)?;\n                         let mplace = ptr.mplace;\n                         // Update the local"}, {"sha": "862f61df227be2b103f18d15a621c544cb54137a", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -287,7 +287,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n                 let return_place = match dest {\n                     Some(place) => *place,\n-                    None => Place::null(&self),\n+                    None => Place::null(&self), // any access will error. good!\n                 };\n                 self.push_stack_frame(\n                     instance,\n@@ -373,6 +373,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         trace!(\"Caller has too many args over\");\n                         return err!(FunctionArgCountMismatch);\n                     }\n+                    // Don't forget to check the return type!\n+                    if let Some(caller_ret) = dest {\n+                        let callee_ret = self.eval_place(&mir::Place::Local(mir::RETURN_PLACE))?;\n+                        if !Self::check_argument_compat(caller_ret.layout, callee_ret.layout) {\n+                            return err!(FunctionRetMismatch(\n+                                caller_ret.layout.ty, callee_ret.layout.ty\n+                            ));\n+                        }\n+                    } else {\n+                        // FIXME: The caller thinks this function cannot return. How do\n+                        // we verify that the callee agrees?\n+                        // On the plus side, the the callee ever writes to its return place,\n+                        // that will be detected as UB (because we set that to NULL above).\n+                    }\n                     Ok(())\n                 })();\n                 match res {"}, {"sha": "f481238bd5ba7406a9aac1ebef313a0186b02e51", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 340, "deletions": 266, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -11,18 +11,18 @@\n use std::fmt::Write;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size, Primitive};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, Size, Align, TyLayout};\n+use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, EvalErrorKind, PointerArithmetic\n+    Scalar, AllocType, EvalResult, EvalErrorKind\n };\n \n use super::{\n-    OpTy, Machine, EvalContext, ScalarMaybeUndef\n+    ValTy, OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n };\n \n-macro_rules! validation_failure{\n+macro_rules! validation_failure {\n     ($what:expr, $where:expr, $details:expr) => {{\n         let where_ = path_format($where);\n         let where_ = if where_.is_empty() {\n@@ -49,6 +49,22 @@ macro_rules! validation_failure{\n     }};\n }\n \n+macro_rules! try_validation {\n+    ($e:expr, $what:expr, $where:expr, $details:expr) => {{\n+        match $e {\n+            Ok(x) => x,\n+            Err(_) => return validation_failure!($what, $where, $details),\n+        }\n+    }};\n+\n+    ($e:expr, $what:expr, $where:expr) => {{\n+        match $e {\n+            Ok(x) => x,\n+            Err(_) => return validation_failure!($what, $where),\n+        }\n+    }}\n+}\n+\n /// We want to show a nice path to the invalid field for diagnotsics,\n /// but avoid string operations in the happy case where no error happens.\n /// So we track a `Vec<PathElem>` where `PathElem` contains all the data we\n@@ -63,6 +79,23 @@ pub enum PathElem {\n     Tag,\n }\n \n+/// State for tracking recursive validation of references\n+pub struct RefTracking<'tcx> {\n+    pub seen: FxHashSet<(OpTy<'tcx>)>,\n+    pub todo: Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n+}\n+\n+impl<'tcx> RefTracking<'tcx> {\n+    pub fn new(op: OpTy<'tcx>) -> Self {\n+        let mut ref_tracking = RefTracking {\n+            seen: FxHashSet(),\n+            todo: vec![(op, Vec::new())],\n+        };\n+        ref_tracking.seen.insert(op);\n+        ref_tracking\n+    }\n+}\n+\n // Adding a Deref and making a copy of the path to be put into the queue\n // always go together.  This one does it with only new allocation.\n fn path_clone_and_deref(path: &Vec<PathElem>) -> Vec<PathElem> {\n@@ -95,133 +128,251 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     out\n }\n \n+fn scalar_format(value: ScalarMaybeUndef) -> String {\n+    match value {\n+        ScalarMaybeUndef::Undef =>\n+            \"uninitialized bytes\".to_owned(),\n+        ScalarMaybeUndef::Scalar(Scalar::Ptr(_)) =>\n+            \"a pointer\".to_owned(),\n+        ScalarMaybeUndef::Scalar(Scalar::Bits { bits, .. }) =>\n+            bits.to_string(),\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    fn validate_scalar(\n+    /// Make sure that `value` is valid for `ty`, *assuming* `ty` is a primitive type.\n+    fn validate_primitive_type(\n         &self,\n-        value: ScalarMaybeUndef,\n-        size: Size,\n-        scalar: &layout::Scalar,\n+        value: ValTy<'tcx>,\n         path: &Vec<PathElem>,\n-        ty: Ty,\n+        ref_tracking: Option<&mut RefTracking<'tcx>>,\n+        const_mode: bool,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n-        let (lo, hi) = scalar.valid_range.clone().into_inner();\n-\n-        let value = match value {\n-            ScalarMaybeUndef::Scalar(scalar) => scalar,\n-            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n-        };\n-\n-        let bits = match value {\n-            Scalar::Bits { bits, size: value_size } => {\n-                assert_eq!(value_size as u64, size.bytes());\n-                bits\n+        // Go over all the primitive types\n+        let ty = value.layout.ty;\n+        match ty.sty {\n+            ty::Bool => {\n+                let value = value.to_scalar_or_undef();\n+                try_validation!(value.to_bool(),\n+                    scalar_format(value), path, \"a boolean\");\n             },\n-            Scalar::Ptr(_) => {\n-                match ty.sty {\n-                    ty::Bool |\n-                    ty::Char |\n-                    ty::Float(_) |\n-                    ty::Int(_) |\n-                    ty::Uint(_) => {\n-                        return validation_failure!(\n-                                \"a pointer\",\n-                                path,\n-                                format!(\"the type {}\", ty.sty)\n-                            );\n+            ty::Char => {\n+                let value = value.to_scalar_or_undef();\n+                try_validation!(value.to_char(),\n+                    scalar_format(value), path, \"a valid unicode codepoint\");\n+            },\n+            ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n+                let size = value.layout.size;\n+                let value = value.to_scalar_or_undef();\n+                if const_mode {\n+                    // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n+                    try_validation!(value.to_bits(size),\n+                        scalar_format(value), path, \"initialized plain bits\");\n+                } else {\n+                    // At run-time, for now, we accept *anything* for these types, including\n+                    // undef. We should fix that, but let's start low.\n+                }\n+            }\n+            _ if ty.is_box() || ty.is_region_ptr() || ty.is_unsafe_ptr() => {\n+                // Handle fat pointers. We also check fat raw pointers,\n+                // their metadata must be valid!\n+                // This also checks that the ptr itself is initialized, which\n+                // seems reasonable even for raw pointers.\n+                let place = try_validation!(self.ref_to_mplace(value),\n+                    \"undefined data in pointer\", path);\n+                // Check metadata early, for better diagnostics\n+                if place.layout.is_unsized() {\n+                    let tail = self.tcx.struct_tail(place.layout.ty);\n+                    match tail.sty {\n+                        ty::Dynamic(..) => {\n+                            let vtable = try_validation!(place.extra.unwrap().to_ptr(),\n+                                \"non-pointer vtable in fat pointer\", path);\n+                            try_validation!(self.read_drop_type_from_vtable(vtable),\n+                                \"invalid drop fn in vtable\", path);\n+                            try_validation!(self.read_size_and_align_from_vtable(vtable),\n+                                \"invalid size or align in vtable\", path);\n+                            // FIXME: More checks for the vtable.\n+                        }\n+                        ty::Slice(..) | ty::Str => {\n+                            try_validation!(place.extra.unwrap().to_usize(self),\n+                                \"non-integer slice length in fat pointer\", path);\n+                        }\n+                        ty::Foreign(..) => {\n+                            // Unsized, but not fat.\n+                        }\n+                        _ =>\n+                            bug!(\"Unexpected unsized type tail: {:?}\", tail),\n+                    }\n+                }\n+                // for safe ptrs, also check the ptr values itself\n+                if !ty.is_unsafe_ptr() {\n+                    // Make sure this is non-NULL and aligned\n+                    let (size, align) = self.size_and_align_of(place.extra, place.layout)?;\n+                    match self.memory.check_align(place.ptr, align) {\n+                        Ok(_) => {},\n+                        Err(err) => match err.kind {\n+                            EvalErrorKind::InvalidNullPointerUsage =>\n+                                return validation_failure!(\"NULL reference\", path),\n+                            EvalErrorKind::AlignmentCheckFailed { .. } =>\n+                                return validation_failure!(\"unaligned reference\", path),\n+                            _ =>\n+                                return validation_failure!(\n+                                    \"dangling (deallocated) reference\", path\n+                                ),\n+                        }\n+                    }\n+                    // non-ZST also have to be dereferencable\n+                    if size != Size::ZERO {\n+                        let ptr = try_validation!(place.ptr.to_ptr(),\n+                            \"integer pointer in non-ZST reference\", path);\n+                        if const_mode {\n+                            // Skip validation entirely for some external statics\n+                            let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                            if let Some(AllocType::Static(did)) = alloc_kind {\n+                                // `extern static` cannot be validated as they have no body.\n+                                // FIXME: Statics from other crates are also skipped.\n+                                // They might be checked at a different type, but for now we\n+                                // want to avoid recursing too deeply.  This is not sound!\n+                                if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                    return Ok(());\n+                                }\n+                            }\n+                        }\n+                        try_validation!(self.memory.check_bounds(ptr, size, false),\n+                            \"dangling (not entirely in bounds) reference\", path);\n+                    }\n+                    if let Some(ref_tracking) = ref_tracking {\n+                        // Check if we have encountered this pointer+layout combination\n+                        // before.  Proceed recursively even for integer pointers, no\n+                        // reason to skip them! They are (recursively) valid for some ZST,\n+                        // but not for others (e.g. `!` is a ZST).\n+                        let op = place.into();\n+                        if ref_tracking.seen.insert(op) {\n+                            trace!(\"Recursing below ptr {:#?}\", *op);\n+                            ref_tracking.todo.push((op, path_clone_and_deref(path)));\n+                        }\n                     }\n-                    ty::RawPtr(_) |\n-                    ty::Ref(_, _, _) |\n-                    ty::FnPtr(_) => {}\n-                    _ => { unreachable!(); }\n                 }\n+            }\n+            ty::FnPtr(_sig) => {\n+                let value = value.to_scalar_or_undef();\n+                let ptr = try_validation!(value.to_ptr(),\n+                    scalar_format(value), path, \"a pointer\");\n+                let _fn = try_validation!(self.memory.get_fn(ptr),\n+                    scalar_format(value), path, \"a function pointer\");\n+                // FIXME: Check if the signature matches\n+            }\n+            // This should be all the primitive types\n+            ty::Never => bug!(\"Uninhabited type should have been catched earlier\"),\n+            _ => bug!(\"Unexpected primitive type {}\", value.layout.ty)\n+        }\n+        Ok(())\n+    }\n \n-                let ptr_size = self.pointer_size();\n-                let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n-                return if lo > hi {\n-                    if lo - hi == 1 {\n-                        // no gap, all values are ok\n-                        Ok(())\n-                    } else if hi < ptr_max || lo > 1 {\n-                        let max = u128::max_value() >> (128 - size.bits());\n-                        validation_failure!(\n-                            \"pointer\",\n-                            path,\n-                            format!(\"something in the range {:?} or {:?}\", 0..=lo, hi..=max)\n-                        )\n-                    } else {\n-                        Ok(())\n+    /// Make sure that `value` matches the\n+    fn validate_scalar_layout(\n+        &self,\n+        value: ScalarMaybeUndef,\n+        size: Size,\n+        path: &Vec<PathElem>,\n+        layout: &layout::Scalar,\n+    ) -> EvalResult<'tcx> {\n+        let (lo, hi) = layout.valid_range.clone().into_inner();\n+        let max_hi = u128::max_value() >> (128 - size.bits()); // as big as the size fits\n+        assert!(hi <= max_hi);\n+        if lo == 0 && hi == max_hi {\n+            // Nothing to check\n+            return Ok(());\n+        }\n+        // At least one value is excluded. Get the bits.\n+        let value = try_validation!(value.not_undef(),\n+            scalar_format(value), path, format!(\"something in the range {:?}\", layout.valid_range));\n+        let bits = match value {\n+            Scalar::Ptr(ptr) => {\n+                if lo == 1 && hi == max_hi {\n+                    // only NULL is not allowed.\n+                    // We can call `check_align` to check non-NULL-ness, but have to also look\n+                    // for function pointers.\n+                    let non_null =\n+                        self.memory.check_align(\n+                            Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n+                        ).is_ok() ||\n+                        self.memory.get_fn(ptr).is_ok();\n+                    if !non_null {\n+                        // could be NULL\n+                        return validation_failure!(\"a potentially NULL pointer\", path);\n                     }\n-                } else if hi < ptr_max || lo > 1 {\n-                    validation_failure!(\n-                        \"pointer\",\n-                        path,\n-                        format!(\"something in the range {:?}\", scalar.valid_range)\n-                    )\n+                    return Ok(());\n                 } else {\n-                    Ok(())\n-                };\n-            },\n-        };\n-\n-        // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n-        // has no special checks for chars\n-        match ty.sty {\n-            ty::Char => {\n-                debug_assert_eq!(size.bytes(), 4);\n-                if ::std::char::from_u32(bits as u32).is_none() {\n+                    // Conservatively, we reject, because the pointer *could* have this\n+                    // value.\n                     return validation_failure!(\n-                        \"character\",\n+                        \"a pointer\",\n                         path,\n-                        \"a valid unicode codepoint\"\n+                        format!(\n+                            \"something that cannot possibly be outside the (wrapping) range {:?}\",\n+                            layout.valid_range\n+                        )\n                     );\n                 }\n             }\n-            _ => {},\n-        }\n-\n+            Scalar::Bits { bits, size: value_size } => {\n+                assert_eq!(value_size as u64, size.bytes());\n+                bits\n+            }\n+        };\n+        // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n         use std::ops::RangeInclusive;\n         let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n         if lo > hi {\n-            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n+            // wrapping around\n+            if in_range(0..=hi) || in_range(lo..=max_hi) {\n                 Ok(())\n             } else {\n                 validation_failure!(\n                     bits,\n                     path,\n-                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n+                    format!(\"something in the range {:?} or {:?}\", 0..=hi, lo..=max_hi)\n                 )\n             }\n         } else {\n-            if in_range(scalar.valid_range.clone()) {\n+            if in_range(layout.valid_range.clone()) {\n                 Ok(())\n             } else {\n                 validation_failure!(\n                     bits,\n                     path,\n-                    format!(\"something in the range {:?}\", scalar.valid_range)\n+                    if hi == max_hi {\n+                        format!(\"something greater or equal to {}\", lo)\n+                    } else {\n+                        format!(\"something in the range {:?}\", layout.valid_range)\n+                    }\n                 )\n             }\n         }\n     }\n \n-    /// This function checks the data at `op`.\n+    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n+    /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     /// The `path` may be pushed to, but the part that is present when the function\n     /// starts must not be changed!\n+    ///\n+    /// `ref_tracking` can be None to avoid recursive checking below references.\n+    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n+    /// validation (e.g., pointer values are fine in integers at runtime).\n     pub fn validate_operand(\n         &self,\n         dest: OpTy<'tcx>,\n         path: &mut Vec<PathElem>,\n-        seen: &mut FxHashSet<(OpTy<'tcx>)>,\n-        todo: &mut Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n+        mut ref_tracking: Option<&mut RefTracking<'tcx>>,\n+        const_mode: bool,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"validate_operand: {:?}, {:#?}\", *dest, dest.layout);\n+        trace!(\"validate_operand: {:?}, {:?}\", *dest, dest.layout.ty);\n \n-        // Find the right variant.  We have to handle this as a prelude, not via\n-        // proper recursion with the new inner layout, to be able to later nicely\n-        // print the field names of the enum field that is being accessed.\n-        let (variant, dest) = match dest.layout.variants {\n+        // If this is a multi-variant layout, we have find the right one and proceed with that.\n+        // (No good reasoning to make this recursion, but it is equivalent to that.)\n+        let dest = match dest.layout.variants {\n             layout::Variants::NicheFilling { .. } |\n             layout::Variants::Tagged { .. } => {\n                 let variant = match self.read_discriminant(dest) {\n@@ -237,124 +388,104 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             ),\n                     }\n                 };\n-                let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n                 path.push(PathElem::Field(dest.layout.ty\n                                           .ty_adt_def()\n                                           .unwrap()\n                                           .variants[variant].name));\n+                // Proceed with this variant\n+                let dest = self.operand_downcast(dest, variant)?;\n                 trace!(\"variant layout: {:#?}\", dest.layout);\n-                (variant, inner_dest)\n+                dest\n             },\n-            layout::Variants::Single { index } => {\n-                // Pre-processing for trait objects: Treat them at their real type.\n-                // (We do not do this for slices and strings: For slices it is not needed,\n-                // `mplace_array_fields` does the right thing, and for strings there is no\n-                // real type that would show the actual length.)\n-                let dest = match dest.layout.ty.sty {\n-                    ty::Dynamic(..) => {\n-                        let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n-                        match self.unpack_dyn_trait(dest) {\n-                            Ok(res) => res.1.into(),\n-                            Err(_) =>\n-                                return validation_failure!(\n-                                    \"invalid vtable in fat pointer\", path\n-                                ),\n-                        }\n-                    }\n-                    _ => dest\n-                };\n-                (index, dest)\n-            }\n+            layout::Variants::Single { .. } => dest,\n         };\n \n-        // Remember the length, in case we need to truncate\n-        let path_len = path.len();\n+        // First thing, find the real type:\n+        // If it is a trait object, switch to the actual type that was used to create it.\n+        let dest = match dest.layout.ty.sty {\n+            ty::Dynamic(..) => {\n+                let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n+                self.unpack_dyn_trait(dest)?.1.into()\n+            },\n+            _ => dest\n+        };\n \n-        // Validate all fields\n-        match dest.layout.fields {\n-            // primitives are unions with zero fields\n-            // We still check `layout.fields`, not `layout.abi`, because `layout.abi`\n-            // is `Scalar` for newtypes around scalars, but we want to descend through the\n-            // fields to get a proper `path`.\n-            layout::FieldPlacement::Union(0) => {\n-                match dest.layout.abi {\n-                    // nothing to do, whatever the pointer points to, it is never going to be read\n-                    layout::Abi::Uninhabited =>\n-                        return validation_failure!(\"a value of an uninhabited type\", path),\n-                    // check that the scalar is a valid pointer or that its bit range matches the\n-                    // expectation.\n-                    layout::Abi::Scalar(ref scalar_layout) => {\n-                        let size = scalar_layout.value.size(self);\n-                        let value = match self.read_value(dest) {\n-                            Ok(val) => val,\n-                            Err(err) => match err.kind {\n-                                EvalErrorKind::PointerOutOfBounds { .. } |\n-                                EvalErrorKind::ReadUndefBytes(_) =>\n-                                    return validation_failure!(\n-                                        \"uninitialized or out-of-bounds memory\", path\n-                                    ),\n-                                _ =>\n-                                    return validation_failure!(\n-                                        \"unrepresentable data\", path\n-                                    ),\n-                            }\n-                        };\n-                        let scalar = value.to_scalar_or_undef();\n-                        self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n-                        if scalar_layout.value == Primitive::Pointer {\n-                            // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n-                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                                if let Some(AllocType::Static(did)) = alloc_kind {\n-                                    // statics from other crates are already checked.\n-                                    // extern statics cannot be validated as they have no body.\n-                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                                        return Ok(());\n-                                    }\n-                                }\n-                                if value.layout.ty.builtin_deref(false).is_some() {\n-                                    let ptr_op = self.ref_to_mplace(value)?.into();\n-                                    // we have not encountered this pointer+layout combination\n-                                    // before.\n-                                    if seen.insert(ptr_op) {\n-                                        trace!(\"Recursing below ptr {:#?}\", *value);\n-                                        todo.push((ptr_op, path_clone_and_deref(path)));\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    },\n-                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n-                }\n+        // If this is a scalar, validate the scalar layout.\n+        // Things can be aggregates and have scalar layout at the same time, and that\n+        // is very relevant for `NonNull` and similar structs: We need to validate them\n+        // at their scalar layout *before* descending into their fields.\n+        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n+        // scalars, we do the same check on every \"level\" (e.g. first we check\n+        // MyNewtype and then the scalar in there).\n+        match dest.layout.abi {\n+            layout::Abi::Uninhabited =>\n+                return validation_failure!(\"a value of an uninhabited type\", path),\n+            layout::Abi::Scalar(ref layout) => {\n+                let value = try_validation!(self.read_scalar(dest),\n+                            \"uninitialized or unrepresentable data\", path);\n+                self.validate_scalar_layout(value, dest.layout.size, &path, layout)?;\n             }\n-            layout::FieldPlacement::Union(_) => {\n+            // FIXME: Should we do something for ScalarPair? Vector?\n+            _ => {}\n+        }\n+\n+        // Check primitive types.  We do this after checking the scalar layout,\n+        // just to have that done as well.  Primitives can have varying layout,\n+        // so we check them separately and before aggregate handling.\n+        // It is CRITICAL that we get this check right, or we might be\n+        // validating the wrong thing!\n+        let primitive = match dest.layout.fields {\n+            // Primitives appear as Union with 0 fields -- except for fat pointers.\n+            layout::FieldPlacement::Union(0) => true,\n+            _ => dest.layout.ty.builtin_deref(true).is_some(),\n+        };\n+        if primitive {\n+            let value = try_validation!(self.read_value(dest),\n+                \"uninitialized or unrepresentable data\", path);\n+            return self.validate_primitive_type(\n+                value,\n+                &path,\n+                ref_tracking,\n+                const_mode,\n+            );\n+        }\n+\n+        // Validate all fields of compound data structures\n+        let path_len = path.len(); // Remember the length, in case we need to truncate\n+        match dest.layout.fields {\n+            layout::FieldPlacement::Union(..) => {\n                 // We can't check unions, their bits are allowed to be anything.\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n-            layout::FieldPlacement::Array { stride, .. } if !dest.layout.is_zst() => {\n-                let dest = dest.to_mem_place(); // non-ZST array/slice/str cannot be immediate\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                // Go look at all the fields\n+                for i in 0..offsets.len() {\n+                    let field = self.operand_field(dest, i as u64)?;\n+                    path.push(self.aggregate_field_path_elem(dest.layout, i));\n+                    self.validate_operand(\n+                        field,\n+                        path,\n+                        ref_tracking.as_mut().map(|r| &mut **r),\n+                        const_mode,\n+                    )?;\n+                    path.truncate(path_len);\n+                }\n+            }\n+            layout::FieldPlacement::Array { stride, .. } => {\n+                let dest = if dest.layout.is_zst() {\n+                    // it's a ZST, the memory content cannot matter\n+                    MPlaceTy::dangling(dest.layout, self)\n+                } else {\n+                    // non-ZST array/slice/str cannot be immediate\n+                    dest.to_mem_place()\n+                };\n                 match dest.layout.ty.sty {\n                     // Special handling for strings to verify UTF-8\n                     ty::Str => {\n-                        match self.read_str(dest) {\n-                            Ok(_) => {},\n-                            Err(err) => match err.kind {\n-                                EvalErrorKind::PointerOutOfBounds { .. } |\n-                                EvalErrorKind::ReadUndefBytes(_) =>\n-                                    // The error here looks slightly different than it does\n-                                    // for slices, because we do not report the index into the\n-                                    // str at which we are OOB.\n-                                    return validation_failure!(\n-                                        \"uninitialized or out-of-bounds memory\", path\n-                                    ),\n-                                _ =>\n-                                    return validation_failure!(\n-                                        \"non-UTF-8 data in str\", path\n-                                    ),\n-                            }\n-                        }\n+                        try_validation!(self.read_str(dest),\n+                            \"uninitialized or non-UTF-8 data in str\", path);\n                     }\n                     // Special handling for arrays/slices of builtin integer types\n                     ty::Array(tys, ..) | ty::Slice(tys) if {\n@@ -390,18 +521,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                                             \"undefined bytes\", path\n                                         )\n                                     },\n-                                    EvalErrorKind::PointerOutOfBounds { allocation_size, .. } => {\n-                                        // If the array access is out-of-bounds, the first\n-                                        // undefined access is the after the end of the array.\n-                                        let i = (allocation_size.bytes() * ty_size) as usize;\n-                                        path.push(PathElem::ArrayElem(i));\n-                                    },\n-                                    _ => (),\n+                                    // Other errors shouldn't be possible\n+                                    _ => return Err(err),\n                                 }\n-\n-                                return validation_failure!(\n-                                    \"uninitialized or out-of-bounds memory\", path\n-                                )\n                             }\n                         }\n                     },\n@@ -411,99 +533,51 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n                             let field = field?;\n                             path.push(PathElem::ArrayElem(i));\n-                            self.validate_operand(field.into(), path, seen, todo)?;\n+                            self.validate_operand(\n+                                field.into(),\n+                                path,\n+                                ref_tracking.as_mut().map(|r| &mut **r),\n+                                const_mode,\n+                            )?;\n                             path.truncate(path_len);\n                         }\n                     }\n                 }\n             },\n-            layout::FieldPlacement::Array { .. } => {\n-                // An empty array.  Nothing to do.\n-            }\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // Fat pointers are treated like pointers, not aggregates.\n-                if dest.layout.ty.builtin_deref(true).is_some() {\n-                    // This is a fat pointer.\n-                    let ptr = match self.read_value(dest.into())\n-                        .and_then(|val| self.ref_to_mplace(val))\n-                    {\n-                        Ok(ptr) => ptr,\n-                        Err(_) =>\n-                            return validation_failure!(\n-                                \"undefined location or metadata in fat pointer\", path\n-                            ),\n-                    };\n-                    // check metadata early, for better diagnostics\n-                    match self.tcx.struct_tail(ptr.layout.ty).sty {\n-                        ty::Dynamic(..) => {\n-                            match ptr.extra.unwrap().to_ptr() {\n-                                Ok(_) => {},\n-                                Err(_) =>\n-                                    return validation_failure!(\n-                                        \"non-pointer vtable in fat pointer\", path\n-                                    ),\n-                            }\n-                            // FIXME: More checks for the vtable.\n-                        }\n-                        ty::Slice(..) | ty::Str => {\n-                            match ptr.extra.unwrap().to_usize(self) {\n-                                Ok(_) => {},\n-                                Err(_) =>\n-                                    return validation_failure!(\n-                                        \"non-integer slice length in fat pointer\", path\n-                                    ),\n-                            }\n-                        }\n-                        _ =>\n-                            bug!(\"Unexpected unsized type tail: {:?}\",\n-                                self.tcx.struct_tail(ptr.layout.ty)\n-                            ),\n-                    }\n-                    // for safe ptrs, recursively check it\n-                    if !dest.layout.ty.is_unsafe_ptr() {\n-                        let ptr = ptr.into();\n-                        if seen.insert(ptr) {\n-                            trace!(\"Recursing below fat ptr {:?}\", ptr);\n-                            todo.push((ptr, path_clone_and_deref(path)));\n-                        }\n-                    }\n-                } else {\n-                    // Not a pointer, perform regular aggregate handling below\n-                    for i in 0..offsets.len() {\n-                        let field = self.operand_field(dest, i as u64)?;\n-                        path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                        self.validate_operand(field, path, seen, todo)?;\n-                        path.truncate(path_len);\n-                    }\n-                }\n-            }\n         }\n         Ok(())\n     }\n \n-    fn aggregate_field_path_elem(&self, ty: Ty<'tcx>, variant: usize, field: usize) -> PathElem {\n-        match ty.sty {\n+    fn aggregate_field_path_elem(&self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n+        match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n-                PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n+                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n+                    PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n+                } else {\n+                    // The closure is not local, so we cannot get the name\n+                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n+                }\n             }\n \n             // tuples\n             ty::Tuple(_) => PathElem::TupleElem(field),\n \n             // enums\n             ty::Adt(def, ..) if def.is_enum() => {\n-                let variant = &def.variants[variant];\n+                let variant = match layout.variants {\n+                    layout::Variants::Single { index } => &def.variants[index],\n+                    _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n+                };\n                 PathElem::Field(variant.fields[field].ident.name)\n             }\n \n             // other ADTs\n             ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n \n             // nothing else has an aggregate layout\n-            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", ty),\n+            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n         }\n     }\n }"}, {"sha": "626baf207eebc0aa4871168e4a0a98fb0a6dbccc", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -154,6 +154,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     // FIXME: figure out the rules and start linting\n                     | FunctionAbiMismatch(..)\n                     | FunctionArgMismatch(..)\n+                    | FunctionRetMismatch(..)\n                     | FunctionArgCountMismatch\n                     // fine at runtime, might be a register address or sth\n                     | ReadBytesAsPointer"}, {"sha": "7be9345b6b423c8a87f12d9c6be030488f0ca5cc", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -2,7 +2,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:24:5\n    |\n LL |     const I32_REF_USIZE_UNION: usize = unsafe { Nonsense { int_32_ref: &3 }.u };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type usize\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -36,7 +36,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:36:5\n    |\n LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uint_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type u64\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -74,7 +74,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:51:5\n    |\n LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type i64\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -96,7 +96,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:60:5\n    |\n LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.float_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type f64\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -144,7 +144,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:78:5\n    |\n LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type u64\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -184,7 +184,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:93:5\n    |\n LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type i64\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -208,7 +208,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/const-pointer-values-in-various-types.rs:102:5\n    |\n LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected the type f64\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "477e7119ba93735f0cf4203fc4f3a945408f2596", "filename": "src/test/ui/consts/const-eval/transmute-const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -14,6 +14,5 @@ use std::mem;\n \n static FOO: bool = unsafe { mem::transmute(3u8) };\n //~^ ERROR this static likely exhibits undefined behavior\n-//~^^ type validation failed: encountered 3, but expected something in the range 0..=1\n \n fn main() {}"}, {"sha": "243343c94b065b0131dc4b30f4f9ff24916d2cca", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -18,7 +18,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:45:1\n    |\n LL | const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered character at .Some.0.1, but expected a valid unicode codepoint\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .Some.0.1, but expected something in the range 0..=1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "2b07eee3ccb465aa448d4ae023d3c683b018df58", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_transmute)]\n+\n+use std::mem;\n+use std::ptr::NonNull;\n+use std::num::{NonZeroU8, NonZeroUsize};\n+\n+const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {}"}, {"sha": "8d1ca885b5aba9fe4797ecbe0261d2bff1741c29", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -0,0 +1,27 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-nonnull.rs:17:1\n+   |\n+LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-nonnull.rs:20:1\n+   |\n+LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-nonnull.rs:22:1\n+   |\n+LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "7ee13f20dd2d90c87cd6749f987d698286a9a3a4", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_transmute)]\n+\n+use std::mem;\n+\n+const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {}"}, {"sha": "9907c780d2ccba674935f4dd3c457cbf8fe2a2d1", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -0,0 +1,35 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-ref.rs:15:1\n+   |\n+LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-ref.rs:18:1\n+   |\n+LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-ref.rs:21:1\n+   |\n+LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-ref.rs:24:1\n+   |\n+LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered integer pointer in non-ZST reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "99305beee52814c58bd999e3d005d93fa5cab671", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -8,15 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-union Foo {\n-    a: u8,\n-    b: Bar,\n-}\n+#![feature(const_transmute)]\n+\n+use std::mem;\n \n #[derive(Copy, Clone)]\n enum Bar {}\n \n-const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b};\n+const BAD_BAD_BAD: Bar = unsafe { mem::transmute(()) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const BAD_BAD_ARRAY: [Bar; 1] = unsafe { mem::transmute(()) };\n //~^ ERROR this constant likely exhibits undefined behavior\n \n fn main() {"}, {"sha": "136d5f29199467a284a8ae9b000a68399691ad03", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -1,11 +1,27 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/ub-uninhabit.rs:19:1\n+  --> $DIR/ub-uninhabit.rs:18:1\n    |\n-LL | const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+LL | const BAD_BAD_BAD: Bar = unsafe { mem::transmute(()) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to previous error\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-uninhabit.rs:21:1\n+   |\n+LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-uninhabit.rs:24:1\n+   |\n+LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { mem::transmute(()) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at [0]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "aaff2f233815baa590fe58d774232e3ccecc46e9", "filename": "src/test/ui/consts/const-eval/ub-usize-in-ref.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1643a8968753226dab7ab3c9fee826f097550f2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1643a8968753226dab7ab3c9fee826f097550f2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.rs?ref=e1643a8968753226dab7ab3c9fee826f097550f2", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-pass\n-\n-union Foo {\n-    a: &'static u8,\n-    b: usize,\n-}\n-\n-// This might point to an invalid address, but that's the user's problem\n-const USIZE_AS_STATIC_REF: &'static u8 = unsafe { Foo { b: 1337 }.a};\n-\n-fn main() {\n-}"}, {"sha": "4484dd6a14740f12cf06feb11faa1b2361e96e3d", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -13,7 +13,7 @@ LL | / const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibi\n LL | |     a: 42,\n LL | |     b: unsafe { UNION.field3 },\n LL | | };\n-   | |__^ type validation failed: encountered undefined bytes at .b\n+   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "0c42d28eb00f49d148cd8fcb5929a932b2e06539", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "previous_filename": "src/test/ui/union-ub-fat-ptr.rs"}, {"sha": "c4632ffe30974afccebc505d716d5bcbb5435db7", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -2,7 +2,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:87:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling (not entirely in bounds) reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -26,7 +26,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:99:1\n    |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>[1]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling (not entirely in bounds) reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -42,15 +42,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:106:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:109:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -98,15 +98,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:132:1\n    |\n LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:135:1\n    |\n LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>.0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n ", "previous_filename": "src/test/ui/union-ub-fat-ptr.stderr"}, {"sha": "86b3bdaa6b79ec82d41cb0e9a8b9208501dd6b5b", "filename": "src/test/ui/consts/const-eval/union-ub.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -41,5 +41,4 @@ const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n const BAD_UNION: Foo = unsafe { Bar { u8: 42 }.foo };\n \n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "a195e12defcea59b66d69b38df25e907c3000465", "filename": "src/test/ui/consts/const-eval/valid-const.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalid-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalid-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalid-const.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -0,0 +1,18 @@\n+// compile-pass\n+\n+// Some constants that *are* valid\n+#![feature(const_transmute)]\n+\n+use std::mem;\n+use std::ptr::NonNull;\n+use std::num::{NonZeroU8, NonZeroUsize};\n+\n+const NON_NULL_PTR1: NonNull<u8> = unsafe { mem::transmute(1usize) };\n+const NON_NULL_PTR2: NonNull<u8> = unsafe { mem::transmute(&0) };\n+\n+const NON_NULL_U8: NonZeroU8 = unsafe { mem::transmute(1u8) };\n+const NON_NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(1usize) };\n+\n+const UNIT: () = ();\n+\n+fn main() {}"}, {"sha": "857db50edbbc166f3971cb611b3674291251f33c", "filename": "src/test/ui/issues/issue-14227.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fissues%2Fissue-14227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fissues%2Fissue-14227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14227.rs?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -11,9 +11,9 @@\n #![allow(safe_extern_statics, warnings)]\n \n extern {\n-    pub static symbol: ();\n+    pub static symbol: u32;\n }\n-static CRASH: () = symbol;\n+static CRASH: u32 = symbol;\n //~^ ERROR could not evaluate static initializer\n //~| tried to read from foreign (extern) static\n "}, {"sha": "dc6c72d8a725620a92b6d0935565f5908683ca0d", "filename": "src/test/ui/issues/issue-14227.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fissues%2Fissue-14227.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e07c4281c343e9e15a0a8fca79538ad1a8eb513/src%2Ftest%2Fui%2Fissues%2Fissue-14227.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14227.stderr?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -1,8 +1,8 @@\n error[E0080]: could not evaluate static initializer\n-  --> $DIR/issue-14227.rs:16:20\n+  --> $DIR/issue-14227.rs:16:21\n    |\n-LL | static CRASH: () = symbol;\n-   |                    ^^^^^^ tried to read from foreign (extern) static\n+LL | static CRASH: u32 = symbol;\n+   |                     ^^^^^^ tried to read from foreign (extern) static\n \n error: aborting due to previous error\n "}, {"sha": "cc275c63a90d4bea394e76607b2e10611eb1be36", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=0e07c4281c343e9e15a0a8fca79538ad1a8eb513", "patch": "@@ -1 +1 @@\n-Subproject commit e8f6973e2d40ab39e30cdbe0cf8e77a72c867d4f\n+Subproject commit cc275c63a90d4bea394e76607b2e10611eb1be36"}]}