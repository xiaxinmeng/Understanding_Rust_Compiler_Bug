{"sha": "a3b5ca7b6d8a1aa42544f5bb1b854f357678e612", "node_id": "C_kwDOAAsO6NoAKGEzYjVjYTdiNmQ4YTFhYTQyNTQ0ZjViYjFiODU0ZjM1NzY3OGU2MTI", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-09-18T23:53:41Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-05T22:56:19Z"}, "message": "Allow inferring generic arguments for associated methods", "tree": {"sha": "6a340bac6e934405f3a0d81236db5ab341a58528", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a340bac6e934405f3a0d81236db5ab341a58528"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3b5ca7b6d8a1aa42544f5bb1b854f357678e612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b5ca7b6d8a1aa42544f5bb1b854f357678e612", "html_url": "https://github.com/rust-lang/rust/commit/a3b5ca7b6d8a1aa42544f5bb1b854f357678e612", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3b5ca7b6d8a1aa42544f5bb1b854f357678e612/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87de9bd1088ec0f1a2e8893a517cde2005a546a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/87de9bd1088ec0f1a2e8893a517cde2005a546a0", "html_url": "https://github.com/rust-lang/rust/commit/87de9bd1088ec0f1a2e8893a517cde2005a546a0"}], "stats": {"total": 62, "additions": 40, "deletions": 22}, "files": [{"sha": "85c003ff605c3473f3e7841b1d5185b13c2ec280", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a3b5ca7b6d8a1aa42544f5bb1b854f357678e612/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b5ca7b6d8a1aa42544f5bb1b854f357678e612/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=a3b5ca7b6d8a1aa42544f5bb1b854f357678e612", "patch": "@@ -14,7 +14,11 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{\n+    type_variable::{TypeVariableOrigin, TypeVariableOriginKind},\n+    RegionVariableOrigin,\n+};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n@@ -392,7 +396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let (ty_str, placeholders) = if let Some(CandidateSource::Impl(impl_did)) =\n+                    let ty_str = if let Some(CandidateSource::Impl(impl_did)) =\n                     static_candidates.get(0)\n                     {\n                         // When the \"method\" is resolved through dereferencing, we really want the\n@@ -401,36 +405,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let ty = tcx.at(span).type_of(*impl_did);\n                         match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n                             (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n-                                // If there are any inferred arguments, (`{integer}`), we shouldn't mark\n-                                // this as machine-applicable.\n-                                let placeholders = substs\n-                                    .iter()\n-                                    .filter_map(|arg| {\n-                                        if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                            Some(ty)\n-                                        } else {\n-                                            None\n-                                        }\n+                                // If there are any inferred arguments, (`{integer}`), we should replace\n+                                // them with underscores to allow the compiler to infer them\n+                                let substs = substs\n+                                    .into_iter()\n+                                    .filter(|arg| !arg.is_suggestable(tcx, true))\n+                                    .map(|arg| match arg.unpack() {\n+                                        GenericArgKind::Lifetime(_) => self\n+                                            .next_region_var(RegionVariableOrigin::MiscVariable(\n+                                                rustc_span::DUMMY_SP,\n+                                            ))\n+                                            .into(),\n+                                        GenericArgKind::Type(_) => self\n+                                            .next_ty_var(TypeVariableOrigin {\n+                                                span: rustc_span::DUMMY_SP,\n+                                                kind: TypeVariableOriginKind::MiscVariable,\n+                                            })\n+                                            .into(),\n+                                        GenericArgKind::Const(arg) => self\n+                                            .next_const_var(\n+                                                arg.ty(),\n+                                                ConstVariableOrigin {\n+                                                    span: rustc_span::DUMMY_SP,\n+                                                    kind: ConstVariableOriginKind::MiscVariable,\n+                                                },\n+                                            )\n+                                            .into(),\n                                     })\n-                                    .any(|ty| matches!(ty.kind(), ty::Infer(_)));\n-                                // Use `actual` as it will have more `substs` filled in.\n-                                (self.ty_to_value_string(actual.peel_refs()), placeholders)\n+                                    .collect::<Vec<_>>();\n+                                format!(\n+                                    \"{}\",\n+                                    ty::Instance::new(def_actual.did(), tcx.intern_substs(&substs))\n+                                )\n                             }\n-                            _ => (self.ty_to_value_string(ty.peel_refs()), true),\n+                            _ => self.ty_to_value_string(ty.peel_refs()),\n                         }\n                     } else {\n-                        (self.ty_to_value_string(actual.peel_refs()), true)\n-                    };\n-                    let applicability = match placeholders {\n-                        true => Applicability::HasPlaceholders,\n-                        false => Applicability::MachineApplicable,\n+                        self.ty_to_value_string(actual.peel_refs())\n                     };\n                     if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n                             expr.span.to(span),\n                             \"use associated function syntax instead\",\n                             format!(\"{}::{}\", ty_str, item_name),\n-                            applicability,\n+                            Applicability::MachineApplicable,\n                         );\n                     } else {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));"}]}