{"sha": "f4399063fc2a3bd6e34bee185abfb6b56c4236a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0Mzk5MDYzZmMyYTNiZDZlMzRiZWUxODVhYmZiNmI1NmM0MjM2YTc=", "commit": {"author": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-11-03T08:37:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-05T20:04:34Z"}, "message": "str.rs: Added functions loop_chars, loop_chars_sub, char_len_range, byte_len_range.", "tree": {"sha": "9012594eaebb9dee4000acedb8cc701ea48717c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9012594eaebb9dee4000acedb8cc701ea48717c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4399063fc2a3bd6e34bee185abfb6b56c4236a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4399063fc2a3bd6e34bee185abfb6b56c4236a7", "html_url": "https://github.com/rust-lang/rust/commit/f4399063fc2a3bd6e34bee185abfb6b56c4236a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4399063fc2a3bd6e34bee185abfb6b56c4236a7/comments", "author": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0278f5315be8410d8fa93d83cb0de0ea0af1ed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0278f5315be8410d8fa93d83cb0de0ea0af1ed4", "html_url": "https://github.com/rust-lang/rust/commit/b0278f5315be8410d8fa93d83cb0de0ea0af1ed4"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "fc995f2f8f6a47184658d16bd96e6f2e9b431d93", "filename": "src/lib/str.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f4399063fc2a3bd6e34bee185abfb6b56c4236a7/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4399063fc2a3bd6e34bee185abfb6b56c4236a7/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=f4399063fc2a3bd6e34bee185abfb6b56c4236a7", "patch": "@@ -4,14 +4,16 @@ Module: str\n String manipulation.\n */\n \n-export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len, index,\n+export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n+       byte_len_range, index,\n        rindex, find, starts_with, ends_with, substr, slice, split, concat,\n        connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n        unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars,\n-       to_chars, char_len, char_at, bytes, is_ascii, shift_byte, pop_byte,\n+       to_chars, char_len, char_len_range, char_at, bytes, is_ascii,\n+       shift_byte, pop_byte,\n        unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n        str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n-       contains, iter_chars;\n+       contains, iter_chars, loop_chars, loop_chars_sub;\n \n native \"c-stack-cdecl\" mod rustrt {\n     fn rust_str_push(&s: str, ch: u8);\n@@ -136,6 +138,23 @@ fn byte_len(s: str) -> uint unsafe {\n     ret vlen - 1u;\n }\n \n+/*\n+Function byte_len_range\n+\n+As byte_len but for a substring\n+*/\n+fn byte_len_range(s: str, byte_offset: uint, char_len: uint) -> uint {\n+    let i = byte_offset;\n+    let chars = 0u;\n+    while chars < char_len {\n+        let chsize = utf8_char_width(s[i]);\n+        assert (chsize > 0u);\n+        i += chsize;\n+        chars += 1u;\n+    }\n+    ret i - byte_offset;\n+}\n+\n /*\n Function: bytes\n \n@@ -314,22 +333,57 @@ fn iter_chars(s: str, it: block(char)) {\n     }\n }\n \n+/*\n+ Function: loop_chars\n+\n+ As `iter_chars` but may be interrupted\n+*/\n+fn loop_chars(s: str, it: block(char) -> bool) -> bool{\n+    ret loop_chars_sub(s, 0u, byte_len(s), it);\n+}\n+\n+/*\n+ Function: loop_chars_sub\n+\n+ As `loop_chars` but on a substring\n+*/\n+fn loop_chars_sub(s: str, byte_offset: uint, byte_len: uint,\n+              it: block(char) -> bool) -> bool {\n+   let i = byte_offset;\n+   let result = true;\n+   while i < byte_len {\n+      let {ch, next} = char_range_at(s, i);\n+      if !it(ch) {result = false; break;}\n+      i = next;\n+   }\n+   ret result;\n+}\n+\n+\n /*\n Function: char_len\n \n Count the number of unicode characters in a string\n */\n fn char_len(s: str) -> uint {\n-    let i = 0u;\n-    let len = 0u;\n-    let total = byte_len(s);\n-    while i < total {\n+    ret char_len_range(s, 0u, byte_len(s));\n+}\n+\n+/*\n+Function: char_len_range\n+\n+As char_len but for a slice of a string\n+*/\n+fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n+    let i     = byte_start;\n+    let len   = 0u;\n+    while i < byte_len {\n         let chsize = utf8_char_width(s[i]);\n         assert (chsize > 0u);\n         len += 1u;\n         i += chsize;\n     }\n-    assert (i == total);\n+    assert (i == byte_len);\n     ret len;\n }\n \n@@ -818,3 +872,4 @@ unsafe fn str_from_cstr(cstr: sbuf) -> str {\n     }\n     ret res;\n }\n+"}]}