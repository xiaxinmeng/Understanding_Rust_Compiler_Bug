{"sha": "c25703ccb860e039aedd9454d38f5c0dc7635a77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNTcwM2NjYjg2MGUwMzlhZWRkOTQ1NGQzOGY1YzBkYzc2MzVhNzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T00:05:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T00:05:13Z"}, "message": "librustc: De-export front, borrowck, and typeck/check. rs=deexporting", "tree": {"sha": "16df0d713d2633a9a21f99d18ef842cab8bb16ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16df0d713d2633a9a21f99d18ef842cab8bb16ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c25703ccb860e039aedd9454d38f5c0dc7635a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c25703ccb860e039aedd9454d38f5c0dc7635a77", "html_url": "https://github.com/rust-lang/rust/commit/c25703ccb860e039aedd9454d38f5c0dc7635a77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c25703ccb860e039aedd9454d38f5c0dc7635a77/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ea2628ca907e83cba63cc19d29a995c848a3434", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea2628ca907e83cba63cc19d29a995c848a3434", "html_url": "https://github.com/rust-lang/rust/commit/2ea2628ca907e83cba63cc19d29a995c848a3434"}], "stats": {"total": 506, "additions": 202, "deletions": 304}, "files": [{"sha": "02e964ac3d35940c0c47785274b4c1b2bfdf5160", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -12,8 +12,6 @@\n // and injected into each crate the compiler builds. Keep it small.\n \n mod intrinsic {\n-    #[legacy_exports];\n-\n     pub use intrinsic::rusti::visit_tydesc;\n \n     // FIXME (#3727): remove this when the interface has settled and the\n@@ -30,7 +28,7 @@ mod intrinsic {\n         // Remaining fields not listed\n     };\n \n-    trait TyVisitor {\n+    pub trait TyVisitor {\n         fn visit_bot(&self) -> bool;\n         fn visit_nil(&self) -> bool;\n         fn visit_bool(&self) -> bool;\n@@ -125,9 +123,8 @@ mod intrinsic {\n     }\n \n     #[abi = \"rust-intrinsic\"]\n-    extern mod rusti {\n-        #[legacy_exports];\n-        fn get_tydesc<T>() -> *();\n-        fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor);\n+    pub extern mod rusti {\n+        pub fn get_tydesc<T>() -> *();\n+        pub fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor);\n     }\n }"}, {"sha": "8e4d17e6ebadbbb5a4accb4d81c3a382ccf1252e", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -193,8 +193,6 @@ fn add_test_module(cx: test_ctxt, +m: ast::_mod) -> ast::_mod {\n We're going to be building a module that looks more or less like:\n \n mod __test {\n-    #[legacy_exports];\n-\n   fn main(args: ~[str]) -> int {\n     std::test::test_main(args, tests())\n   }"}, {"sha": "b1c306fbd91c840f52d6dcf696a8792f51fbbfac", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -19,11 +19,11 @@\n \n use core::prelude::*;\n \n-use middle::borrowck::{Loan, bckerr, borrowck_ctxt, cmt, inherent_mutability};\n+use middle::borrowck::{Loan, bckerr, borrowck_ctxt, inherent_mutability};\n use middle::borrowck::{req_maps, root_map_key, save_and_restore};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n use middle::mem_categorization::{cat_local, cat_rvalue, cat_self};\n-use middle::mem_categorization::{cat_special, gc_ptr, loan_path, lp_arg};\n+use middle::mem_categorization::{cat_special, cmt, gc_ptr, loan_path, lp_arg};\n use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty;\n@@ -41,8 +41,6 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-export check_loans;\n-\n enum check_loan_ctxt = @{\n     bccx: borrowck_ctxt,\n     req_maps: req_maps,\n@@ -65,9 +63,9 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n-fn check_loans(bccx: borrowck_ctxt,\n-               req_maps: req_maps,\n-               crate: @ast::crate) {\n+pub fn check_loans(bccx: borrowck_ctxt,\n+                   req_maps: req_maps,\n+                   crate: @ast::crate) {\n     let clcx = check_loan_ctxt(@{bccx: bccx,\n                                  req_maps: req_maps,\n                                  reported: HashMap(),"}, {"sha": "a0119a19b9a9d70f7686f5ec173bc825f3807a29", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -40,8 +40,6 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-export gather_loans;\n-\n /// Context used while gathering loans:\n ///\n /// - `bccx`: the the borrow check context\n@@ -76,7 +74,7 @@ enum gather_loan_ctxt = @{bccx: borrowck_ctxt,\n                           mut root_ub: ast::node_id,\n                           mut ignore_adjustments: LinearSet<ast::node_id>};\n \n-fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n+pub fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n     let glcx = gather_loan_ctxt(@{bccx: bccx,\n                                   req_maps: {req_loan_map: HashMap(),\n                                              pure_map: HashMap()},"}, {"sha": "be12ae9dff4d2ccd431b67eef4edc712c2383168", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -43,22 +43,20 @@ XXX --- much more needed, don't have time to write this all up now\n \n use core::prelude::*;\n \n-use middle::borrowck::{Loan, bckerr, bckres, borrowck_ctxt, cmt, err_mutbl};\n+use middle::borrowck::{Loan, bckerr, bckres, borrowck_ctxt, err_mutbl};\n use middle::borrowck::{err_out_of_scope};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n-use middle::mem_categorization::{cat_special, cat_stack_upvar, comp_field};\n-use middle::mem_categorization::{comp_index, comp_variant, gc_ptr};\n-use middle::mem_categorization::{region_ptr};\n+use middle::mem_categorization::{cat_special, cat_stack_upvar, cmt};\n+use middle::mem_categorization::{comp_field, comp_index, comp_variant};\n+use middle::mem_categorization::{gc_ptr, region_ptr};\n use middle::ty;\n use util::common::indenter;\n \n use core::result::{Err, Ok, Result};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-export public_methods;\n-\n impl borrowck_ctxt {\n     fn loan(cmt: cmt,\n             scope_region: ty::Region,"}, {"sha": "9f9d5f20b6904c91e3923b57fc94e84446453bc4", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 37, "deletions": 86, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -224,8 +224,6 @@ Borrowck results in two maps.\n   given a memory location and not used as immediates.\n  */\n \n-#[legacy_exports];\n-\n use core::prelude::*;\n \n use middle::liveness;\n@@ -251,20 +249,16 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-#[legacy_exports]\n pub mod check_loans;\n-#[legacy_exports]\n pub mod gather_loans;\n-#[legacy_exports]\n pub mod loan;\n-#[legacy_exports]\n pub mod preserve;\n \n-fn check_crate(tcx: ty::ctxt,\n-               method_map: typeck::method_map,\n-               last_use_map: liveness::last_use_map,\n-               crate: @ast::crate)\n-            -> (root_map, mutbl_map, write_guard_map) {\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n+                   last_use_map: liveness::last_use_map,\n+                   crate: @ast::crate)\n+                -> (root_map, mutbl_map, write_guard_map) {\n \n     let bccx = borrowck_ctxt_(@{tcx: tcx,\n                                 method_map: method_map,\n@@ -308,26 +302,26 @@ fn check_crate(tcx: ty::ctxt,\n // ----------------------------------------------------------------------\n // Type definitions\n \n-type borrowck_ctxt_ = {tcx: ty::ctxt,\n-                       method_map: typeck::method_map,\n-                       last_use_map: liveness::last_use_map,\n-                       root_map: root_map,\n-                       mutbl_map: mutbl_map,\n-                       write_guard_map: write_guard_map,\n-                       stmt_map: stmt_set,\n-\n-                       // Statistics:\n-                       mut loaned_paths_same: uint,\n-                       mut loaned_paths_imm: uint,\n-                       mut stable_paths: uint,\n-                       mut req_pure_paths: uint,\n-                       mut guaranteed_paths: uint};\n-\n-enum borrowck_ctxt {\n+pub type borrowck_ctxt_ = {tcx: ty::ctxt,\n+                           method_map: typeck::method_map,\n+                           last_use_map: liveness::last_use_map,\n+                           root_map: root_map,\n+                           mutbl_map: mutbl_map,\n+                           write_guard_map: write_guard_map,\n+                           stmt_map: stmt_set,\n+\n+                           // Statistics:\n+                           mut loaned_paths_same: uint,\n+                           mut loaned_paths_imm: uint,\n+                           mut stable_paths: uint,\n+                           mut req_pure_paths: uint,\n+                           mut guaranteed_paths: uint};\n+\n+pub enum borrowck_ctxt {\n     borrowck_ctxt_(@borrowck_ctxt_)\n }\n \n-struct RootInfo {\n+pub struct RootInfo {\n     scope: ast::node_id,\n     // This will be true if we need to freeze this box at runtime. This will\n     // result in a call to `borrow_as_imm()` and `return_to_mut()`.\n@@ -337,29 +331,30 @@ struct RootInfo {\n // a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n // the box needs to be kept live to the id of the scope for which they\n // must stay live.\n-type root_map = HashMap<root_map_key, RootInfo>;\n+pub type root_map = HashMap<root_map_key, RootInfo>;\n \n // the keys to the root map combine the `id` of the expression with\n // the number of types that it is autodereferenced.  So, for example,\n // if you have an expression `x.f` and x has type ~@T, we could add an\n // entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n // to refer to the deref of the unique pointer, and so on.\n #[deriving_eq]\n-struct root_map_key {\n+pub struct root_map_key {\n     id: ast::node_id,\n     derefs: uint\n }\n \n // set of ids of local vars / formal arguments that are modified / moved.\n // this is used in trans for optimization purposes.\n-type mutbl_map = HashMap<ast::node_id, ()>;\n+pub type mutbl_map = HashMap<ast::node_id, ()>;\n \n // A set containing IDs of expressions of gc'd type that need to have a write\n // guard.\n-type write_guard_map = HashMap<root_map_key, ()>;\n+pub type write_guard_map = HashMap<root_map_key, ()>;\n \n-// Errors that can occur\"]\n-enum bckerr_code {\n+// Errors that can occur\n+#[deriving_eq]\n+pub enum bckerr_code {\n     err_mut_uniq,\n     err_mut_variant,\n     err_root_not_permitted,\n@@ -368,61 +363,16 @@ enum bckerr_code {\n     err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n }\n \n-impl bckerr_code : cmp::Eq {\n-    pure fn eq(&self, other: &bckerr_code) -> bool {\n-        match (*self) {\n-            err_mut_uniq => {\n-                match (*other) {\n-                    err_mut_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            err_mut_variant => {\n-                match (*other) {\n-                    err_mut_variant => true,\n-                    _ => false\n-                }\n-            }\n-            err_root_not_permitted => {\n-                match (*other) {\n-                    err_root_not_permitted => true,\n-                    _ => false\n-                }\n-            }\n-            err_mutbl(e0a) => {\n-                match (*other) {\n-                    err_mutbl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_root_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_root_scope(e0b, e1b) =>\n-                        e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &bckerr_code) -> bool { !(*self).eq(other) }\n-}\n-\n // Combination of an error code and the categorization of the expression\n // that caused it\n #[deriving_eq]\n-struct bckerr {\n+pub struct bckerr {\n     cmt: cmt,\n     code: bckerr_code\n }\n \n // shorthand for something that fails with `bckerr` or succeeds with `T`\n-type bckres<T> = Result<T, bckerr>;\n+pub type bckres<T> = Result<T, bckerr>;\n \n /// a complete record of a loan that was granted\n pub struct Loan {lp: @loan_path, cmt: cmt, mutbl: ast::mutability}\n@@ -438,7 +388,8 @@ pub type req_maps = {\n     pure_map: HashMap<ast::node_id, bckerr>\n };\n \n-fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n+pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n+                                  f: fn() -> U) -> U {\n     let old_save_and_restore_t = *save_and_restore_t;\n     let u = f();\n     *save_and_restore_t = old_save_and_restore_t;\n@@ -447,20 +398,20 @@ fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n \n /// Creates and returns a new root_map\n \n-impl root_map_key : to_bytes::IterBytes {\n+pub impl root_map_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }\n \n-fn root_map() -> root_map {\n+pub fn root_map() -> root_map {\n     return HashMap();\n }\n \n // ___________________________________________________________________________\n // Misc\n \n-impl borrowck_ctxt {\n+pub impl borrowck_ctxt {\n     fn is_subregion_of(r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n     }\n@@ -632,7 +583,7 @@ impl borrowck_ctxt {\n // assuming it is embedded in an immutable context.  In general, the\n // mutability can be \"overridden\" if the component is embedded in a\n // mutable structure.\n-fn inherent_mutability(ck: comp_kind) -> mutability {\n+pub fn inherent_mutability(ck: comp_kind) -> mutability {\n     match ck {\n       comp_tuple | comp_anon_field | comp_variant(_) => m_imm,\n       comp_field(_, m) | comp_index(_, m)            => m"}, {"sha": "048fd7b623c30986e7920eb2a7e37ee6f8ec19d2", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -16,22 +16,21 @@\n use core::prelude::*;\n \n use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, borrowck_ctxt};\n-use middle::borrowck::{cmt, err_mut_uniq, err_mut_variant};\n+use middle::borrowck::{err_mut_uniq, err_mut_variant};\n use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n use middle::borrowck::{err_root_not_permitted, root_map_key};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n use middle::mem_categorization::{cat_discr, cat_local, cat_self, cat_special};\n-use middle::mem_categorization::{cat_stack_upvar, comp_field, comp_index};\n-use middle::mem_categorization::{comp_variant, gc_ptr, region_ptr};\n+use middle::mem_categorization::{cat_stack_upvar, cmt, comp_field};\n+use middle::mem_categorization::{comp_index, comp_variant, gc_ptr};\n+use middle::mem_categorization::{region_ptr};\n use middle::ty;\n use util::common::indenter;\n \n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-export public_methods, preserve_condition, pc_ok, pc_if_pure;\n-\n-enum preserve_condition {\n+pub enum preserve_condition {\n     pc_ok,\n     pc_if_pure(bckerr)\n }"}, {"sha": "38788ac0d8df828c3c959829e0c63763f00bc8e0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -27,10 +27,10 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust;\n \n-fn check_match(fcx: @fn_ctxt,\n-               expr: @ast::expr,\n-               discrim: @ast::expr,\n-               arms: ~[ast::arm]) -> bool {\n+pub fn check_match(fcx: @fn_ctxt,\n+                   expr: @ast::expr,\n+                   discrim: @ast::expr,\n+                   arms: ~[ast::arm]) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let mut bot;\n \n@@ -68,15 +68,15 @@ fn check_match(fcx: @fn_ctxt,\n     return bot;\n }\n \n-struct pat_ctxt {\n+pub struct pat_ctxt {\n     fcx: @fn_ctxt,\n     map: PatIdMap,\n     match_region: ty::Region, // Region for the match as a whole\n     block_region: ty::Region, // Region for the block of the arm\n }\n \n-fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n-                     +subpats: Option<~[@ast::pat]>, expected: ty::t) {\n+pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n+                         +subpats: Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -197,14 +197,14 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n /// `substitutions` are the type substitutions applied to this struct type\n /// (e.g. K,V in HashMap<K,V>).\n /// `etc` is true if the pattern said '...' and false otherwise.\n-fn check_struct_pat_fields(pcx: pat_ctxt,\n-                           span: span,\n-                           path: @ast::path,\n-                           fields: ~[ast::field_pat],\n-                           class_fields: ~[ty::field_ty],\n-                           class_id: ast::def_id,\n-                           substitutions: &ty::substs,\n-                           etc: bool) {\n+pub fn check_struct_pat_fields(pcx: pat_ctxt,\n+                               span: span,\n+                               path: @ast::path,\n+                               fields: ~[ast::field_pat],\n+                               class_fields: ~[ty::field_ty],\n+                               class_id: ast::def_id,\n+                               substitutions: &ty::substs,\n+                               etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the class fields.\n@@ -249,10 +249,10 @@ fn check_struct_pat_fields(pcx: pat_ctxt,\n     }\n }\n \n-fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n-                    expected: ty::t, path: @ast::path,\n-                    +fields: ~[ast::field_pat], etc: bool,\n-                    class_id: ast::def_id, substitutions: &ty::substs) {\n+pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n+                        expected: ty::t, path: @ast::path,\n+                        +fields: ~[ast::field_pat], etc: bool,\n+                        class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -287,15 +287,15 @@ fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n                             substitutions, etc);\n }\n \n-fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n-                                      pat_id: ast::node_id,\n-                                      span: span,\n-                                      expected: ty::t,\n-                                      path: @ast::path,\n-                                      +fields: ~[ast::field_pat],\n-                                      etc: bool,\n-                                      enum_id: ast::def_id,\n-                                      substitutions: &ty::substs) {\n+pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n+                                          pat_id: ast::node_id,\n+                                          span: span,\n+                                          expected: ty::t,\n+                                          path: @ast::path,\n+                                          +fields: ~[ast::field_pat],\n+                                          etc: bool,\n+                                          enum_id: ast::def_id,\n+                                          substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -325,7 +325,7 @@ fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n "}, {"sha": "0bb63de00bd55bbe91a5e24b3866c6efcc807cb2", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -20,16 +20,16 @@ use syntax::codemap::span;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-fn suptype(fcx: @fn_ctxt, sp: span,\n-           expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: @fn_ctxt, sp: span,\n+               expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-fn suptype_with_fn(fcx: @fn_ctxt,\n-                   sp: span,\n-                   expected: ty::t, actual: ty::t,\n-                   handle_err: fn(span, ty::t, ty::t, &ty::type_err)) {\n+pub fn suptype_with_fn(fcx: @fn_ctxt,\n+                       sp: span,\n+                       expected: ty::t, actual: ty::t,\n+                       handle_err: fn(span, ty::t, ty::t, &ty::type_err)) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), false, sp,\n                           actual, expected) {\n@@ -40,7 +40,7 @@ fn suptype_with_fn(fcx: @fn_ctxt,\n     }\n }\n \n-fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, sp, actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -50,10 +50,10 @@ fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-fn coerce(fcx: @fn_ctxt,\n-          sp: span,\n-          expected: ty::t,\n-          expr: @ast::expr) {\n+pub fn coerce(fcx: @fn_ctxt,\n+              sp: span,\n+              expected: ty::t,\n+              expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "4f3ca9950cc267544c6f0b5737d4e7334bf7a85a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -111,7 +111,7 @@ use syntax::ast_map::node_id_to_str;\n use syntax::ast_util::dummy_sp;\n use syntax::codemap::span;\n \n-fn lookup(\n+pub fn lookup(\n     fcx: @fn_ctxt,\n \n     // In a call `a.b::<X, Y, ...>(...)`:\n@@ -142,7 +142,7 @@ fn lookup(\n     return move mme;\n }\n \n-struct LookupContext {\n+pub struct LookupContext {\n     fcx: @fn_ctxt,\n     expr: @ast::expr,\n     self_expr: @ast::expr,\n@@ -157,8 +157,9 @@ struct LookupContext {\n \n /**\n  * A potential method that might be called, assuming the receiver\n- * is of a suitable type. */\n-struct Candidate {\n+ * is of a suitable type.\n+ */\n+pub struct Candidate {\n     rcvr_ty: ty::t,\n     rcvr_substs: ty::substs,\n     explicit_self: ast::self_ty_,\n@@ -175,12 +176,12 @@ struct Candidate {\n  * How the self type should be transformed according to the form of explicit\n  * self provided by the method.\n  */\n-enum TransformTypeFlag {\n+pub enum TransformTypeFlag {\n     TransformTypeNormally,\n     TransformTypeForObject,\n }\n \n-impl LookupContext {\n+pub impl LookupContext {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n                self.ty_to_str(self_ty),\n@@ -1253,12 +1254,12 @@ impl LookupContext {\n     }\n }\n \n-fn transform_self_type_for_method(tcx: ty::ctxt,\n-                                  self_region: Option<ty::Region>,\n-                                  impl_ty: ty::t,\n-                                  self_type: ast::self_ty_,\n-                                  flag: TransformTypeFlag)\n-                               -> ty::t {\n+pub fn transform_self_type_for_method(tcx: ty::ctxt,\n+                                      self_region: Option<ty::Region>,\n+                                      impl_ty: ty::t,\n+                                      self_type: ast::self_ty_,\n+                                      flag: TransformTypeFlag)\n+                                   -> ty::t {\n     match self_type {\n       sty_static => {\n         tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n@@ -1291,6 +1292,6 @@ fn transform_self_type_for_method(tcx: ty::ctxt,\n     }\n }\n \n-fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n+pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n     match self_type { sty_value => by_copy, _ => by_ref }\n }"}, {"sha": "8ca9af3cd2340dc42c59b55348f5d2b02d4f7743", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -131,45 +131,15 @@ use syntax::print::pprust;\n use syntax::visit;\n use syntax;\n \n-export _match;\n-export vtable;\n-export writeback;\n-export regionmanip;\n-export regionck;\n-export demand;\n-export method;\n-export fn_ctxt;\n-export impl_self_ty;\n-export DerefArgs;\n-export DontDerefArgs;\n-export DoDerefArgs;\n-export check_item_types;\n-export check_block;\n-export check_expr_has_type;\n-export fn_ctxt;\n-export lookup_def;\n-export structure_of;\n-export self_info;\n-export structurally_resolved_type;\n-export instantiate_path;\n-export valid_range_bounds;\n-\n-#[legacy_exports]\n pub mod _match;\n-#[legacy_exports]\n pub mod vtable;\n-#[legacy_exports]\n pub mod writeback;\n-#[legacy_exports]\n pub mod regionmanip;\n-#[legacy_exports]\n pub mod regionck;\n-#[legacy_exports]\n pub mod demand;\n-#[legacy_exports]\n pub mod method;\n \n-type self_info = {\n+pub type self_info = {\n     self_ty: ty::t,\n     self_id: ast::node_id,\n     def_id: ast::def_id,\n@@ -264,7 +234,7 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n     }\n }\n \n-fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n+pub fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     let visit = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()\n@@ -984,12 +954,12 @@ fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n-fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n+pub fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n     -> bool {\n     const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n }\n \n-fn check_expr_has_type(\n+pub fn check_expr_has_type(\n     fcx: @fn_ctxt, expr: @ast::expr,\n     expected: ty::t) -> bool\n {\n@@ -2630,7 +2600,7 @@ fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     return bot;\n }\n \n-fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n+pub fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n@@ -2831,7 +2801,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n+pub fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n@@ -2901,12 +2871,12 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-fn instantiate_path(fcx: @fn_ctxt,\n-                    pth: @ast::path,\n-                    tpt: ty_param_bounds_and_ty,\n-                    span: span,\n-                    node_id: ast::node_id,\n-                    region_lb: ty::Region) {\n+pub fn instantiate_path(fcx: @fn_ctxt,\n+                        pth: @ast::path,\n+                        tpt: ty_param_bounds_and_ty,\n+                        span: span,\n+                        node_id: ast::node_id,\n+                        region_lb: ty::Region) {\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = vec::len(*tpt.bounds);\n@@ -2961,7 +2931,8 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n+pub fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t)\n+                               -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => return t_s,\n         _ => {\n@@ -2974,7 +2945,7 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n }\n \n // Returns the one-level-deep structure of the given type.\n-fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n+pub fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n     /*bad*/copy ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n "}, {"sha": "abc79c8af0e58d777836a5dc68f4b936858bc189", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -49,10 +49,10 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-enum rcx { rcx_({fcx: @fn_ctxt, mut errors_reported: uint}) }\n-type rvt = visit::vt<@rcx>;\n+pub enum rcx { rcx_({fcx: @fn_ctxt, mut errors_reported: uint}) }\n+pub type rvt = visit::vt<@rcx>;\n \n-fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n+pub fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         def_local(node_id, _) | def_arg(node_id, _, _) |\n@@ -72,7 +72,7 @@ fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n     }\n }\n \n-impl @rcx {\n+pub impl @rcx {\n     fn resolve_type(unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n@@ -115,22 +115,22 @@ impl @rcx {\n     }\n }\n \n-fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n+pub fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n     let v = regionck_visitor();\n     (v.visit_expr)(e, @(move rcx), v);\n     fcx.infcx().resolve_regions();\n }\n \n-fn regionck_fn(fcx: @fn_ctxt,\n-               blk: ast::blk) {\n+pub fn regionck_fn(fcx: @fn_ctxt,\n+                   blk: ast::blk) {\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n     let v = regionck_visitor();\n     (v.visit_block)(blk, @(move rcx), v);\n     fcx.infcx().resolve_regions();\n }\n \n-fn regionck_visitor() -> rvt {\n+pub fn regionck_visitor() -> rvt {\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n                                   visit_stmt: visit_stmt,\n                                   visit_expr: visit_expr,\n@@ -139,11 +139,11 @@ fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-fn visit_item(_item: @ast::item, &&_rcx: @rcx, _v: rvt) {\n+pub fn visit_item(_item: @ast::item, &&_rcx: @rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n+pub fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n     // Check to make sure that the regions in all local variables are\n     // within scope.\n     //\n@@ -174,11 +174,11 @@ fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n     }\n }\n \n-fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n+pub fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n+pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n@@ -295,11 +295,11 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     visit::visit_expr(expr, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, &&rcx: @rcx, v: rvt) {\n+pub fn visit_stmt(s: @ast::stmt, &&rcx: @rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n-fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n+pub fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     /*!\n      *\n      * checks the type of the node `id` and reports an error if it\n@@ -318,10 +318,7 @@ fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n }\n \n-fn constrain_auto_ref(\n-    rcx: @rcx,\n-    expr: @ast::expr)\n-{\n+pub fn constrain_auto_ref(rcx: @rcx, expr: @ast::expr) {\n     /*!\n      *\n      * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n@@ -365,11 +362,10 @@ fn constrain_auto_ref(\n     }\n }\n \n-fn constrain_free_variables(\n+pub fn constrain_free_variables(\n     rcx: @rcx,\n     region: ty::Region,\n-    expr: @ast::expr)\n-{\n+    expr: @ast::expr) {\n     /*!\n      *\n      * Make sure that all free variables referenced inside the closure\n@@ -402,12 +398,11 @@ fn constrain_free_variables(\n     }\n }\n \n-fn constrain_regions_in_type_of_node(\n+pub fn constrain_regions_in_type_of_node(\n     rcx: @rcx,\n     id: ast::node_id,\n     encl_region: ty::Region,\n-    span: span) -> bool\n-{\n+    span: span) -> bool {\n     let tcx = rcx.fcx.tcx();\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n@@ -420,12 +415,11 @@ fn constrain_regions_in_type_of_node(\n     constrain_regions_in_type(rcx, encl_region, span, ty)\n }\n \n-fn constrain_regions_in_type(\n+pub fn constrain_regions_in_type(\n     rcx: @rcx,\n     encl_region: ty::Region,\n     span: span,\n-    ty: ty::t) -> bool\n-{\n+    ty: ty::t) -> bool {\n     /*!\n      *\n      * Requires that any regions which appear in `ty` must be\n@@ -481,7 +475,7 @@ fn constrain_regions_in_type(\n     }\n }\n \n-mod guarantor {\n+pub mod guarantor {\n     /*!\n      *\n      * The routines in this module are aiming to deal with the case\n@@ -923,12 +917,11 @@ mod guarantor {\n \n }\n \n-fn infallibly_mk_subr(rcx: @rcx,\n-                      a_is_expected: bool,\n-                      span: span,\n-                      a: ty::Region,\n-                      b: ty::Region)\n-{\n+pub fn infallibly_mk_subr(rcx: @rcx,\n+                          a_is_expected: bool,\n+                         span: span,\n+                         a: ty::Region,\n+                         b: ty::Region) {\n     /*!\n      *\n      * Constrains `a` to be a subregion of `b`.  In many cases, we\n@@ -947,4 +940,4 @@ fn infallibly_mk_subr(rcx: @rcx,\n                      a, b, e));\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2e652f90b8c107a1bff00d0fac43336455dffc01", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -32,8 +32,7 @@ pub fn replace_bound_regions_in_fn_ty(\n     self_info: Option<self_info>,\n     fn_ty: &ty::FnTy,\n     mapf: fn(ty::bound_region) -> ty::Region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy}\n-{\n+    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy} {\n     let {isr, self_info, fn_sig} =\n         replace_bound_regions_in_fn_sig(\n             tcx, isr, self_info, &fn_ty.sig, mapf);\n@@ -49,8 +48,7 @@ pub fn replace_bound_regions_in_fn_sig(\n     self_info: Option<self_info>,\n     fn_sig: &ty::FnSig,\n     mapf: fn(ty::bound_region) -> ty::Region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_sig: ty::FnSig}\n-{\n+    {isr: isr_alist, self_info: Option<self_info>, fn_sig: ty::FnSig} {\n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n     let self_ty = self_info.map(|s| s.self_ty);"}, {"sha": "3548125a39eccbd7ee533b1819b0ed8ae2a3e938", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -55,37 +55,36 @@ use syntax::visit;\n /// Location info records the span and ID of the expression or item that is\n /// responsible for this vtable instantiation. (This may not be an expression\n /// if the vtable instantiation is being performed as part of \"deriving\".)\n-struct LocationInfo {\n+pub struct LocationInfo {\n     span: span,\n     id: ast::node_id\n }\n \n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n-struct VtableContext {\n+pub struct VtableContext {\n     ccx: @crate_ctxt,\n     infcx: @infer::InferCtxt\n }\n \n-impl VtableContext {\n+pub impl VtableContext {\n     fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n }\n \n-fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n+pub fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         bs.any(|b| {\n             match b { &ty::bound_trait(_) => true, _ => false }\n         })\n     })\n }\n \n-fn lookup_vtables(vcx: &VtableContext,\n-                  location_info: &LocationInfo,\n-                  bounds: @~[ty::param_bounds],\n-                  substs: &ty::substs,\n-                  allow_unsafe: bool,\n-                  is_early: bool) -> vtable_res\n-{\n+pub fn lookup_vtables(vcx: &VtableContext,\n+                      location_info: &LocationInfo,\n+                      bounds: @~[ty::param_bounds],\n+                      substs: &ty::substs,\n+                      allow_unsafe: bool,\n+                      is_early: bool) -> vtable_res {\n     debug!(\"lookup_vtables(location_info=%?,\n             # bounds=%?, \\\n             substs=%s\",\n@@ -140,9 +139,9 @@ fn lookup_vtables(vcx: &VtableContext,\n     @result\n }\n \n-fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                id: ast::def_id, +substs: ty::substs,\n-                is_early: bool) -> Option<ty::substs> {\n+pub fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n+                    id: ast::def_id, +substs: ty::substs,\n+                    is_early: bool) -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n@@ -154,20 +153,20 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     }\n }\n \n-fn relate_trait_tys(vcx: &VtableContext, location_info: &LocationInfo,\n-                    exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n+pub fn relate_trait_tys(vcx: &VtableContext, location_info: &LocationInfo,\n+                        exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n     demand_suptype(vcx, location_info.span, exp_trait_ty, act_trait_ty)\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`\n-fn lookup_vtable(vcx: &VtableContext,\n-                 location_info: &LocationInfo,\n-                 ty: ty::t,\n-                 trait_ty: ty::t,\n-                 allow_unsafe: bool,\n-                 is_early: bool)\n-    -> Option<vtable_origin> {\n+pub fn lookup_vtable(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     ty: ty::t,\n+                     trait_ty: ty::t,\n+                     allow_unsafe: bool,\n+                     is_early: bool)\n+                  -> Option<vtable_origin> {\n     debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n            vcx.infcx.ty_to_str(ty), vcx.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n@@ -446,11 +445,10 @@ fn lookup_vtable(vcx: &VtableContext,\n     return None;\n }\n \n-fn fixup_ty(vcx: &VtableContext,\n-            location_info: &LocationInfo,\n-            ty: ty::t,\n-            is_early: bool) -> Option<ty::t>\n-{\n+pub fn fixup_ty(vcx: &VtableContext,\n+                location_info: &LocationInfo,\n+                ty: ty::t,\n+                is_early: bool) -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n@@ -469,7 +467,7 @@ fn fixup_ty(vcx: &VtableContext,\n \n // Version of demand::suptype() that takes a vtable context instead of a\n // function context.\n-fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n+pub fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n     // NB: Order of actual, expected is reversed.\n     match infer::mk_subty(vcx.infcx, false, sp, a, e) {\n         result::Ok(()) => {} // Ok.\n@@ -479,12 +477,12 @@ fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n     }\n }\n \n-fn connect_trait_tps(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n-                     impl_tys: ~[ty::t],\n-                     trait_tys: ~[ty::t],\n-                     impl_did: ast::def_id,\n-                     vstore: ty::vstore) {\n+pub fn connect_trait_tps(vcx: &VtableContext,\n+                         location_info: &LocationInfo,\n+                         impl_tys: ~[ty::t],\n+                         trait_tys: ~[ty::t],\n+                         impl_did: ast::def_id,\n+                         vstore: ty::vstore) {\n     let tcx = vcx.tcx();\n \n     // XXX: This should work for multiple traits.\n@@ -503,21 +501,21 @@ fn connect_trait_tps(vcx: &VtableContext,\n     }\n }\n \n-fn insert_vtables(ccx: @crate_ctxt, callee_id: ast::node_id,\n-                  vtables: vtable_res) {\n+pub fn insert_vtables(ccx: @crate_ctxt, callee_id: ast::node_id,\n+                      vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n            callee_id, vtables.map(|v| v.to_str(ccx.tcx)));\n     ccx.vtable_map.insert(callee_id, vtables);\n }\n \n-fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n+pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n     LocationInfo {\n         span: expr.span,\n         id: expr.id\n     }\n }\n \n-fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n+pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let _indent = indenter();\n@@ -710,14 +708,16 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     }\n }\n \n-fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n+pub fn resolve_expr(ex: @ast::expr,\n+                    &&fcx: @fn_ctxt,\n+                    v: visit::vt<@fn_ctxt>) {\n     early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);\n }\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n+pub fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n     visit::visit_block(bl, fcx, visit::mk_vt(@visit::Visitor {\n         visit_expr: resolve_expr,\n         visit_item: fn@(_i: @ast::item, &&_e: @fn_ctxt,"}, {"sha": "a72dfc0a934c1b5eaac30fc128e636977c842cfe", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25703ccb860e039aedd9454d38f5c0dc7635a77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=c25703ccb860e039aedd9454d38f5c0dc7635a77", "patch": "@@ -34,12 +34,8 @@ use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n \n-export resolve_type_vars_in_fn;\n-export resolve_type_vars_in_expr;\n-\n fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n-    -> Option<ty::t>\n-{\n+    -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n         Ok(new_type) => return Some(new_type),\n@@ -251,17 +247,17 @@ fn mk_visitor() -> visit::vt<wb_ctxt> {\n                                   .. *visit::default_visitor()})\n }\n \n-fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n     (visit.visit_expr)(e, wbcx, visit);\n     return wbcx.success;\n }\n \n-fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n-                           decl: &ast::fn_decl,\n-                           blk: ast::blk,\n-                           self_info: Option<self_info>) -> bool {\n+pub fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n+                               decl: &ast::fn_decl,\n+                               blk: ast::blk,\n+                               self_info: Option<self_info>) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, wbcx, visit);"}]}