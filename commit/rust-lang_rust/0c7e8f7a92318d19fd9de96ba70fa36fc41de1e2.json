{"sha": "0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjN2U4ZjdhOTIzMThkMTlmZDlkZTk2YmE3MGZhMzZmYzQxZGUxZTI=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-10T05:05:14Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T17:26:48Z"}, "message": "path2: Remove some API functions\n\nDelete the following API functions:\n- set_dirname()\n- with_dirname()\n- set_filestem()\n- with_filestem()\n- add_extension()\n- file_path()\n\nAlso change pop() to return a boolean instead of an owned copy of the\nold filename.", "tree": {"sha": "3a195ee3aca8116b1ff582cb60b8dcc703ba7456", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a195ee3aca8116b1ff582cb60b8dcc703ba7456"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "html_url": "https://github.com/rust-lang/rust/commit/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bab7eb20dff32294c65fa28cece552481c40cf0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bab7eb20dff32294c65fa28cece552481c40cf0b", "html_url": "https://github.com/rust-lang/rust/commit/bab7eb20dff32294c65fa28cece552481c40cf0b"}], "stats": {"total": 744, "additions": 101, "deletions": 643}, "files": [{"sha": "efe681ce830a0ae394bb6a1ecff19a84cfd64ed2", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -164,7 +164,7 @@ fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n       Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.file_path()\n+            testfile.filename().map_move(|s| Path::new(s))\n         } else {\n             None\n         }"}, {"sha": "9c6edb8d566bf5c831a1d054a6ce64f5a624a101", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -662,7 +662,12 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n \n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    f.add_extension(os::EXE_EXTENSION);\n+    if !os::EXE_SUFFIX.is_empty() {\n+        match f.filename().map_move(|s| s + os::EXE_SUFFIX.as_bytes()) {\n+            Some(v) => f.set_filename(v),\n+            None => ()\n+        }\n+    }\n     f\n }\n \n@@ -747,7 +752,10 @@ fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n \n fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    f.add_extension(\"libaux\");\n+    match f.filename().map_move(|s| s + bytes!(\".libaux\")) {\n+        Some(v) => f.set_filename(v),\n+        None => ()\n+    }\n     f\n }\n "}, {"sha": "8f42614707886c553888a524970c4e17c174916f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -24,7 +24,7 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n pub type pick<'self> = &'self fn(path: &Path) -> FileMatch;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n-    if path.file_path() == Some(file) {\n+    if path.filename() == Some(file.as_vec()) {\n         Some(path.clone())\n     } else {\n         None\n@@ -206,11 +206,10 @@ pub fn rust_path() -> ~[Path] {\n         env_rust_path.push(cwd.clone());\n     }\n     loop {\n-        let f = cwd.pop();\n-        if f.is_none() || bytes!(\"..\") == f.unwrap() {\n-            break;\n+        if { let f = cwd.filename(); f.is_none() || f.unwrap() == bytes!(\"..\") } {\n+            break\n         }\n-        cwd.push(\".rust\");\n+        cwd.set_filename(\".rust\");\n         if !env_rust_path.contains(&cwd) && os::path_exists(&cwd) {\n             env_rust_path.push(cwd.clone());\n         }"}, {"sha": "69c3f6e0f1c831faed011d4cde94ffc33917d263", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -449,8 +449,8 @@ pub fn user_set_rust_path() -> bool {\n \n /// Append the version string onto the end of the path's filename\n pub fn versionize(p: &Path, v: &Version) -> Path {\n-    let q = p.file_path().expect(\"path is a directory\");\n-    let mut q = q.as_vec().to_owned();\n+    let q = p.filename().expect(\"path is a directory\");\n+    let mut q = q.to_owned();\n     q.push('-' as u8);\n     let vs = v.to_str();\n     q.push_all(vs.as_bytes());"}, {"sha": "8701365d321e05e589d7a093ad912baeb1a6a8f5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -693,8 +693,9 @@ pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n     if path_is_dir(p) {\n         return true;\n     }\n-    let mut p_ = p.clone();\n-    if p_.pop().is_some() {\n+    if p.filename().is_some() {\n+        let mut p_ = p.clone();\n+        p_.pop();\n         if !mkdir_recursive(&p_, mode) {\n             return false;\n         }"}, {"sha": "08a29f6552a2d9c93b8922b338cfc87e4e056993", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 152, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -268,23 +268,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         self.extension().and_then(str::from_utf8_slice_opt)\n     }\n \n-    /// Replaces the directory portion of the path with the given byte vector or string.\n-    /// If `self` represents the root of the filesystem hierarchy, the last path component\n-    /// of the argument becomes the filename.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the dirname contains a NUL.\n-    #[inline]\n-    fn set_dirname<T: BytesContainer>(&mut self, dirname: T) {\n-        if contains_nul(dirname.container_as_bytes()) {\n-            let dirname = self::null_byte::cond.raise(dirname.container_into_owned_bytes());\n-            assert!(!contains_nul(dirname));\n-            unsafe { self.set_dirname_unchecked(dirname) }\n-        } else {\n-            unsafe { self.set_dirname_unchecked(dirname) }\n-        }\n-    }\n     /// Replaces the filename portion of the path with the given byte vector or string.\n     /// If the replacement name is [], this is equivalent to popping the path.\n     ///\n@@ -301,53 +284,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             unsafe { self.set_filename_unchecked(filename) }\n         }\n     }\n-    /// Replaces the filestem with the given byte vector or string.\n-    /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n-    /// to `set_filename`. Otherwise, if the argument is [] or \"\", the extension (including\n-    /// the preceding '.') becomes the new filename.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the filestem contains a NUL.\n-    fn set_filestem<T: BytesContainer>(&mut self, filestem: T) {\n-        // borrowck is being a pain here\n-        enum Value<T> {\n-            Checked(T),\n-            Unchecked(~[u8])\n-        }\n-        let val = {\n-            match self.filename() {\n-                None => Checked(filestem),\n-                Some(name) => {\n-                    let dot = '.' as u8;\n-                    match name.rposition_elem(&dot) {\n-                        None | Some(0) => Checked(filestem),\n-                        Some(idx) => {\n-                            let mut v;\n-                            if contains_nul(filestem.container_as_bytes()) {\n-                                let filestem = filestem.container_into_owned_bytes();\n-                                let filestem = self::null_byte::cond.raise(filestem);\n-                                assert!(!contains_nul(filestem));\n-                                v = filestem;\n-                                let n = v.len();\n-                                v.reserve(n + name.len() - idx);\n-                            } else {\n-                                let filestem = filestem.container_as_bytes();\n-                                v = vec::with_capacity(filestem.len() + name.len() - idx);\n-                                v.push_all(filestem);\n-                            }\n-                            v.push_all(name.slice_from(idx));\n-                            Unchecked(v)\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-        match val {\n-            Checked(v)  => self.set_filename(v),\n-            Unchecked(v) => unsafe { self.set_filename_unchecked(v) }\n-        }\n-    }\n     /// Replaces the extension with the given byte vector or string.\n     /// If there is no extension in `self`, this adds one.\n     /// If the argument is [] or \"\", this removes the extension.\n@@ -417,61 +353,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             Some(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n-    /// Adds the given extension (as a byte vector or string) to the file.\n-    /// This does not remove any existing extension.\n-    /// `foo.bar`.add_extension(`baz`) becomes `foo.bar.baz`.\n-    /// If `self` has no filename, this is a no-op.\n-    /// If the argument is [] or \"\", this is a no-op.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the extension contains a NUL.\n-    fn add_extension<T: BytesContainer>(&mut self, extension: T) {\n-        if extension.container_as_bytes().is_empty() { return; }\n-        // appease borrowck\n-        let val = {\n-            match self.filename() {\n-                None => None,\n-                Some(name) => {\n-                    let mut v;\n-                    if contains_nul(extension.container_as_bytes()) {\n-                        let ext = extension.container_into_owned_bytes();\n-                        let extension = self::null_byte::cond.raise(ext);\n-                        assert!(!contains_nul(extension));\n-                        v = vec::with_capacity(name.len() + 1 + extension.len());\n-                        v.push_all(name);\n-                        v.push('.' as u8);\n-                        v.push_all(extension);\n-                    } else {\n-                        let extension = extension.container_as_bytes();\n-                        v = vec::with_capacity(name.len() + 1 + extension.len());\n-                        v.push_all(name);\n-                        v.push('.' as u8);\n-                        v.push_all(extension);\n-                    }\n-                    Some(v)\n-                }\n-            }\n-        };\n-        match val {\n-            None => (),\n-            Some(v) => unsafe { self.set_filename_unchecked(v) }\n-        }\n-    }\n \n-    /// Returns a new Path constructed by replacing the dirname with the given\n-    /// byte vector or string.\n-    /// See `set_dirname` for details.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the dirname contains a NUL.\n-    #[inline]\n-    fn with_dirname<T: BytesContainer>(&self, dirname: T) -> Self {\n-        let mut p = self.clone();\n-        p.set_dirname(dirname);\n-        p\n-    }\n     /// Returns a new Path constructed by replacing the filename with the given\n     /// byte vector or string.\n     /// See `set_filename` for details.\n@@ -485,19 +367,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.set_filename(filename);\n         p\n     }\n-    /// Returns a new Path constructed by setting the filestem to the given\n-    /// byte vector or string.\n-    /// See `set_filestem` for details.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the filestem contains a NUL.\n-    #[inline]\n-    fn with_filestem<T: BytesContainer>(&self, filestem: T) -> Self {\n-        let mut p = self.clone();\n-        p.set_filestem(filestem);\n-        p\n-    }\n     /// Returns a new Path constructed by setting the extension to the given\n     /// byte vector or string.\n     /// See `set_extension` for details.\n@@ -518,12 +387,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         // self.dirname() returns a NUL-free vector\n         unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n     }\n-    /// Returns the file component of `self`, as a relative Path.\n-    /// If `self` represents the root of the filesystem hierarchy, returns None.\n-    fn file_path(&self) -> Option<Self> {\n-        // self.filename() returns a NUL-free vector\n-        self.filename().map_move(|v| unsafe { GenericPathUnsafe::new_unchecked(v) })\n-    }\n \n     /// Returns a Path that represents the filesystem root that `self` is rooted in.\n     ///\n@@ -561,16 +424,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             }\n         }\n     }\n-    /// Pops the last path component off of `self` and returns it.\n-    /// If `self` represents the root of the file hierarchy, None is returned.\n-    fn pop(&mut self) -> Option<~[u8]>;\n-    /// Pops the last path component off of `self` and returns it as a string, if possible.\n-    /// `self` will still be modified even if None is returned.\n-    /// See `pop` for details.\n-    #[inline]\n-    fn pop_str(&mut self) -> Option<~str> {\n-        self.pop().and_then(|v| str::from_utf8_owned_opt(v))\n-    }\n+    /// Removes the last path component from the receiver.\n+    /// Returns `true` if the receiver was modified, or `false` if it already\n+    /// represented the root of the file hierarchy.\n+    fn pop(&mut self) -> bool;\n \n     /// Returns a new Path constructed by joining `self` with the given path\n     /// (as a byte vector or string).\n@@ -658,11 +515,6 @@ pub trait GenericPathUnsafe {\n     /// The resulting Path will always be normalized.\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;\n \n-    /// Replaces the directory portion of the path without checking for null\n-    /// bytes.\n-    /// See `set_dirname` for details.\n-    unsafe fn set_dirname_unchecked<T: BytesContainer>(&mut self, dirname: T);\n-\n     /// Replaces the filename portion of the path without checking for null\n     /// bytes.\n     /// See `set_filename` for details."}, {"sha": "a7c89cb6029dffd319b5e44929a3a15215ad213f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 27, "deletions": 218, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -20,7 +20,6 @@ use option::{Option, None, Some};\n use str;\n use str::Str;\n use to_bytes::IterBytes;\n-use util;\n use vec;\n use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector};\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -122,39 +121,6 @@ impl GenericPathUnsafe for Path {\n         Path{ repr: path, sepidx: idx }\n     }\n \n-    unsafe fn set_dirname_unchecked<T: BytesContainer>(&mut self, dirname: T) {\n-        let dirname = dirname.container_as_bytes();\n-        match self.sepidx {\n-            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => {\n-                self.repr = Path::normalize(dirname);\n-            }\n-            None => {\n-                let mut v = vec::with_capacity(dirname.len() + self.repr.len() + 1);\n-                v.push_all(dirname);\n-                v.push(sep_byte);\n-                v.push_all(self.repr);\n-                self.repr = Path::normalize(v);\n-            }\n-            Some(0) if self.repr.len() == 1 && self.repr[0] == sep_byte => {\n-                self.repr = Path::normalize(dirname);\n-            }\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n-                self.repr = Path::normalize(dirname);\n-            }\n-            Some(idx) if dirname.is_empty() => {\n-                let v = Path::normalize(self.repr.slice_from(idx+1));\n-                self.repr = v;\n-            }\n-            Some(idx) => {\n-                let mut v = vec::with_capacity(dirname.len() + self.repr.len() - idx);\n-                v.push_all(dirname);\n-                v.push_all(self.repr.slice_from(idx));\n-                self.repr = Path::normalize(v);\n-            }\n-        }\n-        self.sepidx = self.repr.rposition_elem(&sep_byte);\n-    }\n-\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n@@ -236,25 +202,23 @@ impl GenericPath for Path {\n         }\n     }\n \n-    fn pop(&mut self) -> Option<~[u8]> {\n+    fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr => None,\n+            None if bytes!(\".\") == self.repr => false,\n             None => {\n-                let mut v = ~['.' as u8];\n-                util::swap(&mut v, &mut self.repr);\n+                self.repr = ~['.' as u8];\n                 self.sepidx = None;\n-                Some(v)\n+                true\n             }\n-            Some(0) if bytes!(\"/\") == self.repr => None,\n+            Some(0) if bytes!(\"/\") == self.repr => false,\n             Some(idx) => {\n-                let v = self.repr.slice_from(idx+1).to_owned();\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n                 self.sepidx = self.repr.rposition_elem(&sep_byte);\n-                Some(v)\n+                true\n             }\n         }\n     }\n@@ -692,17 +656,6 @@ mod tests {\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/foo\"));\n \n-        handled = false;\n-        do cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"null/\", 0, \"/byte\"));\n-            (b!(\"null/byte\").to_owned())\n-        }).inside {\n-            p.set_dirname(b!(\"null/\", 0, \"/byte\"));\n-        };\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"null/byte/foo\"));\n-\n         handled = false;\n         do cond.trap(|v| {\n             handled = true;\n@@ -712,7 +665,7 @@ mod tests {\n             p.push(b!(\"f\", 0, \"o\"));\n         };\n         assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"null/byte/foo/foo\"));\n+        assert_eq!(p.as_vec(), b!(\"/foo/foo\"));\n     }\n \n     #[test]\n@@ -749,15 +702,6 @@ mod tests {\n             };\n         })\n \n-        t!(~\"set_dirname w/nul\" => {\n-            let mut p = Path::new(b!(\"foo/bar\"));\n-            do cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside {\n-                p.set_dirname(b!(\"foo\", 0))\n-            };\n-        })\n-\n         t!(~\"push w/nul\" => {\n             let mut p = Path::new(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n@@ -1006,46 +950,35 @@ mod tests {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::new($path);\n-                    let file = p.pop_str();\n+                    let result = p.pop();\n                     assert_eq!(p.as_str(), Some($left));\n-                    assert_eq!(file.map(|s| s.as_slice()), $right);\n+                    assert_eq!(result, $right);\n                 }\n             );\n-            (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n+            (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n                 {\n                     let mut p = Path::new(b!($($path),+));\n-                    let file = p.pop();\n+                    let result = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n-                }\n-            );\n-            (v: [$($path:expr),+], [$($left:expr),+], None) => (\n-                {\n-                    let mut p = Path::new(b!($($path),+));\n-                    let file = p.pop();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(file, None);\n+                    assert_eq!(result, $right);\n                 }\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [\"a/b\"], Some(\"c\"));\n-        t!(v: [\"a\"], [\".\"], Some(\"a\"));\n-        t!(v: [\".\"], [\".\"], None);\n-        t!(v: [\"/a\"], [\"/\"], Some(\"a\"));\n-        t!(v: [\"/\"], [\"/\"], None);\n-        t!(v: [\"a/b/c\", 0x80], [\"a/b\"], Some(\"c\", 0x80));\n-        t!(v: [\"a/b\", 0x80, \"/c\"], [\"a/b\", 0x80], Some(\"c\"));\n-        t!(v: [0xff], [\".\"], Some(0xff));\n-        t!(v: [\"/\", 0xff], [\"/\"], Some(0xff));\n-        t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n-        t!(s: \"a\", \".\", Some(\"a\"));\n-        t!(s: \".\", \".\", None);\n-        t!(s: \"/a\", \"/\", Some(\"a\"));\n-        t!(s: \"/\", \"/\", None);\n-\n-        assert_eq!(Path::new(b!(\"foo/bar\", 0x80)).pop_str(), None);\n-        assert_eq!(Path::new(b!(\"foo\", 0x80, \"/bar\")).pop_str(), Some(~\"bar\"));\n+        t!(v: [\"a/b/c\"], [\"a/b\"], true);\n+        t!(v: [\"a\"], [\".\"], true);\n+        t!(v: [\".\"], [\".\"], false);\n+        t!(v: [\"/a\"], [\"/\"], true);\n+        t!(v: [\"/\"], [\"/\"], false);\n+        t!(v: [\"a/b/c\", 0x80], [\"a/b\"], true);\n+        t!(v: [\"a/b\", 0x80, \"/c\"], [\"a/b\", 0x80], true);\n+        t!(v: [0xff], [\".\"], true);\n+        t!(v: [\"/\", 0xff], [\"/\"], true);\n+        t!(s: \"a/b/c\", \"a/b\", true);\n+        t!(s: \"a\", \".\", true);\n+        t!(s: \".\", \".\", false);\n+        t!(s: \"/a\", \"/\", true);\n+        t!(s: \"/\", \"/\", false);\n     }\n \n     #[test]\n@@ -1124,27 +1057,6 @@ mod tests {\n     fn test_with_helpers() {\n         let empty: &[u8] = [];\n \n-        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n-        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n-        t!(v: Path::new(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n-        t!(v: Path::new(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n-              b!(\"/\", 0xcd, \"/\", 0x80));\n-        t!(s: Path::new(\"a/b/c\").with_dirname(\"d\"), \"d/c\");\n-        t!(s: Path::new(\"a/b/c\").with_dirname(\"d/e\"), \"d/e/c\");\n-        t!(s: Path::new(\"a/b/c\").with_dirname(\"\"), \"c\");\n-        t!(s: Path::new(\"a/b/c\").with_dirname(\"/\"), \"/c\");\n-        t!(s: Path::new(\"a/b/c\").with_dirname(\".\"), \"c\");\n-        t!(s: Path::new(\"a/b/c\").with_dirname(\"..\"), \"../c\");\n-        t!(s: Path::new(\"/\").with_dirname(\"foo\"), \"foo\");\n-        t!(s: Path::new(\"/\").with_dirname(\"\"), \".\");\n-        t!(s: Path::new(\"/foo\").with_dirname(\"bar\"), \"bar/foo\");\n-        t!(s: Path::new(\"..\").with_dirname(\"foo\"), \"foo\");\n-        t!(s: Path::new(\"../..\").with_dirname(\"foo\"), \"foo\");\n-        t!(s: Path::new(\"..\").with_dirname(\"\"), \".\");\n-        t!(s: Path::new(\"../..\").with_dirname(\"\"), \".\");\n-        t!(s: Path::new(\"foo\").with_dirname(\"..\"), \"../foo\");\n-        t!(s: Path::new(\"foo\").with_dirname(\"../..\"), \"../../foo\");\n-\n         t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n         t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n         t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n@@ -1169,34 +1081,6 @@ mod tests {\n         t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n         t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n \n-        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n-              b!(\"hi/\", 0xff, \".txt\"));\n-        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n-              b!(\"hi/\", 0xff, \".txt\", 0x80));\n-        t!(v: Path::new(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n-        t!(v: Path::new(b!(\"hi\", 0x80, \"/there\")).with_filestem(empty), b!(\"hi\", 0x80));\n-        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"here\"), \"hi/here.txt\");\n-        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"\"), \"hi/.txt\");\n-        t!(s: Path::new(\"hi/there.txt\").with_filestem(\".\"), \"hi/..txt\");\n-        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"..\"), \"hi/...txt\");\n-        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"/\"), \"hi/.txt\");\n-        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"foo/bar\"), \"hi/foo/bar.txt\");\n-        t!(s: Path::new(\"hi/there.foo.txt\").with_filestem(\"here\"), \"hi/here.txt\");\n-        t!(s: Path::new(\"hi/there\").with_filestem(\"here\"), \"hi/here\");\n-        t!(s: Path::new(\"hi/there\").with_filestem(\"\"), \"hi\");\n-        t!(s: Path::new(\"hi\").with_filestem(\"\"), \".\");\n-        t!(s: Path::new(\"/hi\").with_filestem(\"\"), \"/\");\n-        t!(s: Path::new(\"hi/there\").with_filestem(\"..\"), \".\");\n-        t!(s: Path::new(\"hi/there\").with_filestem(\".\"), \"hi\");\n-        t!(s: Path::new(\"hi/there.\").with_filestem(\"foo\"), \"hi/foo.\");\n-        t!(s: Path::new(\"hi/there.\").with_filestem(\"\"), \"hi\");\n-        t!(s: Path::new(\"hi/there.\").with_filestem(\".\"), \".\");\n-        t!(s: Path::new(\"hi/there.\").with_filestem(\"..\"), \"hi/...\");\n-        t!(s: Path::new(\"/\").with_filestem(\"foo\"), \"/foo\");\n-        t!(s: Path::new(\".\").with_filestem(\"foo\"), \"foo\");\n-        t!(s: Path::new(\"hi/there..\").with_filestem(\"here\"), \"hi/here.\");\n-        t!(s: Path::new(\"hi/there..\").with_filestem(\"\"), \"hi\");\n-\n         t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n               b!(\"hi/there\", 0x80, \".exe\"));\n         t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n@@ -1245,17 +1129,6 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d\"));\n-        t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d/e\"));\n-        t!(v: b!(\"a/\", 0x80, \"/c\"), set_dirname, with_dirname, b!(0xff));\n-        t!(s: \"a/b/c\", set_dirname, with_dirname, \"d\");\n-        t!(s: \"a/b/c\", set_dirname, with_dirname, \"d/e\");\n-        t!(s: \"/\", set_dirname, with_dirname, \"foo\");\n-        t!(s: \"/foo\", set_dirname, with_dirname, \"bar\");\n-        t!(s: \"a/b/c\", set_dirname, with_dirname, \"\");\n-        t!(s: \"../..\", set_dirname, with_dirname, \"x\");\n-        t!(s: \"foo\", set_dirname, with_dirname, \"../..\");\n-\n         t!(v: b!(\"a/b/c\"), set_filename, with_filename, b!(\"d\"));\n         t!(v: b!(\"/\"), set_filename, with_filename, b!(\"foo\"));\n         t!(v: b!(0x80), set_filename, with_filename, b!(0xff));\n@@ -1265,14 +1138,6 @@ mod tests {\n         t!(s: \"a/b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b!(\"hi/there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), set_filestem, with_filestem, b!(\"here\", 0xff));\n-        t!(s: \"hi/there.txt\", set_filestem, with_filestem, \"here\");\n-        t!(s: \"hi/there.\", set_filestem, with_filestem, \"here\");\n-        t!(s: \"hi/there\", set_filestem, with_filestem, \"here\");\n-        t!(s: \"hi/there.txt\", set_filestem, with_filestem, \"\");\n-        t!(s: \"hi/there\", set_filestem, with_filestem, \"\");\n-\n         t!(v: b!(\"hi/there.txt\"), set_extension, with_extension, b!(\"exe\"));\n         t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), set_extension, with_extension, b!(\"exe\", 0xff));\n         t!(s: \"hi/there.txt\", set_extension, with_extension, \"exe\");\n@@ -1283,36 +1148,6 @@ mod tests {\n         t!(s: \".\", set_extension, with_extension, \"txt\");\n     }\n \n-    #[test]\n-    fn test_add_extension() {\n-        macro_rules! t(\n-            (s: $path:expr, $ext:expr, $exp:expr) => (\n-                {\n-                    let mut path = Path::new($path);\n-                    path.add_extension($ext);\n-                    assert_eq!(path.as_str(), Some($exp));\n-                }\n-            );\n-            (v: $path:expr, $ext:expr, $exp:expr) => (\n-                {\n-                    let mut path = Path::new($path);\n-                    path.add_extension($ext);\n-                    assert_eq!(path.as_vec(), $exp);\n-                }\n-            )\n-        )\n-\n-        t!(s: \"hi/there.txt\", \"foo\", \"hi/there.txt.foo\");\n-        t!(s: \"hi/there.\", \"foo\", \"hi/there..foo\");\n-        t!(s: \"hi/there\", \".foo\", \"hi/there..foo\");\n-        t!(s: \"hi/there.txt\", \"\", \"hi/there.txt\");\n-        t!(v: b!(\"hi/there.txt\"), b!(\"foo\"), b!(\"hi/there.txt.foo\"));\n-        t!(v: b!(\"hi/there\"), b!(\"bar\"), b!(\"hi/there.bar\"));\n-        t!(v: b!(\"/\"), b!(\"foo\"), b!(\"/\"));\n-        t!(v: b!(\".\"), b!(\"foo\"), b!(\".\"));\n-        t!(v: b!(\"hi/there.\", 0x80, \"foo\"), b!(0xff), b!(\"hi/there.\", 0x80, \"foo.\", 0xff));\n-    }\n-\n     #[test]\n     fn test_getters() {\n         macro_rules! t(\n@@ -1372,7 +1207,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_dir_file_path() {\n+    fn test_dir_path() {\n         t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n         t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n         t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n@@ -1381,32 +1216,6 @@ mod tests {\n         t!(s: Path::new(\"/\").dir_path(), \"/\");\n         t!(s: Path::new(\"..\").dir_path(), \"..\");\n         t!(s: Path::new(\"../..\").dir_path(), \"../..\");\n-\n-        macro_rules! t(\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let left = path.and_then_ref(|p| p.as_str());\n-                    assert_eq!(left, $exp);\n-                }\n-            );\n-            (v: $path:expr, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let left = path.map(|p| p.as_vec());\n-                    assert_eq!(left, $exp);\n-                }\n-            )\n-        )\n-\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n-        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n-        t!(s: Path::new(\"hi/there\").file_path(), Some(\"there\"));\n-        t!(s: Path::new(\"hi\").file_path(), Some(\"hi\"));\n-        t!(s: Path::new(\".\").file_path(), None);\n-        t!(s: Path::new(\"/\").file_path(), None);\n-        t!(s: Path::new(\"..\").file_path(), None);\n-        t!(s: Path::new(\"../..\").file_path(), None);\n     }\n \n     #[test]"}, {"sha": "77232196f7856d45ff59da25ffc85b210faf74c8", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 50, "deletions": 261, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0c7e8f7a92318d19fd9de96ba70fa36fc41de1e2", "patch": "@@ -20,7 +20,6 @@ use option::{Option, Some, None};\n use str;\n use str::{CharSplitIterator, OwnedStr, Str, StrVector};\n use to_bytes::IterBytes;\n-use util;\n use vec::Vector;\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n@@ -174,49 +173,6 @@ impl GenericPathUnsafe for Path {\n         ret\n     }\n \n-    /// See `GenericPathUnsafe::set_dirname_unchecked`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n-    unsafe fn set_dirname_unchecked<T: BytesContainer>(&mut self, dirname: T) {\n-        let dirname = dirname.container_as_str();\n-        match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr || \"..\" == self.repr => {\n-                self.update_normalized(dirname);\n-            }\n-            None => {\n-                let mut s = str::with_capacity(dirname.len() + self.repr.len() + 1);\n-                s.push_str(dirname);\n-                s.push_char(sep);\n-                s.push_str(self.repr);\n-                self.update_normalized(s);\n-            }\n-            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n-                self.update_normalized(dirname);\n-            }\n-            Some((_,idxa,end)) if dirname.is_empty() => {\n-                let (prefix, path) = Path::normalize_(self.repr.slice(idxa,end));\n-                self.repr = path;\n-                self.prefix = prefix;\n-                self.update_sepidx();\n-            }\n-            Some((idxb,idxa,end)) => {\n-                let idx = if dirname.ends_with(\"\\\\\") { idxa }\n-                else {\n-                    let prefix = parse_prefix(dirname);\n-                    if prefix == Some(DiskPrefix) && prefix_len(prefix) == dirname.len() {\n-                        idxa\n-                    } else { idxb }\n-                };\n-                let mut s = str::with_capacity(dirname.len() + end - idx);\n-                s.push_str(dirname);\n-                s.push_str(self.repr.slice(idx,end));\n-                self.update_normalized(s);\n-            }\n-        }\n-    }\n-\n     /// See `GenericPathUnsafe::set_filename_unchecekd`.\n     ///\n     /// # Failure\n@@ -452,28 +408,18 @@ impl GenericPath for Path {\n         unsafe { GenericPathUnsafe::new_unchecked(self.dirname_str().unwrap()) }\n     }\n \n-    fn file_path(&self) -> Option<Path> {\n-        self.filename_str().map_move(|s| unsafe { GenericPathUnsafe::new_unchecked(s) })\n-    }\n-\n     #[inline]\n-    fn pop(&mut self) -> Option<~[u8]> {\n-        self.pop_str().map_move(|s| s.into_bytes())\n-    }\n-\n-    fn pop_str(&mut self) -> Option<~str> {\n+    fn pop(&mut self) -> bool {\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr => None,\n+            None if \".\" == self.repr => false,\n             None => {\n-                let mut s = ~\".\";\n-                util::swap(&mut s, &mut self.repr);\n+                self.repr = ~\".\";\n                 self.sepidx = None;\n-                Some(s)\n+                true\n             }\n-            Some((idxb,idxa,end)) if idxb == idxa && idxb == end => None,\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => None,\n-            Some((idxb,idxa,end)) => {\n-                let s = self.repr.slice(idxa, end).to_owned();\n+            Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => false,\n+            Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n                         let plen = self.prefix_len();\n@@ -483,7 +429,7 @@ impl GenericPath for Path {\n                 };\n                 self.repr.truncate(trunc);\n                 self.update_sepidx();\n-                Some(s)\n+                true\n             }\n         }\n     }\n@@ -1401,17 +1347,6 @@ mod tests {\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\foo\"));\n \n-        handled = false;\n-        do cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"null\\\\\", 0, \"\\\\byte\"));\n-            (b!(\"null\\\\byte\").to_owned())\n-        }).inside {\n-            p.set_dirname(b!(\"null\\\\\", 0, \"\\\\byte\"));\n-        };\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"null\\\\byte\\\\foo\"));\n-\n         handled = false;\n         do cond.trap(|v| {\n             handled = true;\n@@ -1421,7 +1356,7 @@ mod tests {\n             p.push(b!(\"f\", 0, \"o\"));\n         };\n         assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"null\\\\byte\\\\foo\\\\foo\"));\n+        assert_eq!(p.as_vec(), b!(\"\\\\foo\\\\foo\"));\n     }\n \n     #[test]\n@@ -1458,15 +1393,6 @@ mod tests {\n             };\n         })\n \n-        t!(~\"set_dirname w\\\\nul\" => {\n-            let mut p = Path::new(b!(\"foo\\\\bar\"));\n-            do cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside {\n-                p.set_dirname(b!(\"foo\", 0))\n-            };\n-        })\n-\n         t!(~\"push w\\\\nul\" => {\n             let mut p = Path::new(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n@@ -1770,69 +1696,58 @@ mod tests {\n                 {\n                     let pstr = $path;\n                     let mut p = Path::new(pstr);\n-                    let file = p.pop_str();\n+                    let result = p.pop();\n                     let left = $left;\n                     assert!(p.as_str() == Some(left),\n                         \"`{}`.pop() failed; expected remainder `{}`, found `{}`\",\n                         pstr, left, p.as_str().unwrap());\n-                    let right = $right;\n-                    let res = file.map(|s| s.as_slice());\n-                    assert!(res == right, \"`{}`.pop() failed; expected `{:?}`, found `{:?}`\",\n-                            pstr, right, res);\n-                }\n-            );\n-            (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n-                {\n-                    let mut p = Path::new(b!($($path),+));\n-                    let file = p.pop();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n+                    assert_eq!(result, $right);\n                 }\n             );\n-            (v: [$($path:expr),+], [$($left:expr),+], None) => (\n+            (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n                 {\n                     let mut p = Path::new(b!($($path),+));\n-                    let file = p.pop();\n+                    let result = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(file, None);\n+                    assert_eq!(result, $right);\n                 }\n             )\n         )\n \n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n-        t!(s: \"a\", \".\", Some(\"a\"));\n-        t!(s: \".\", \".\", None);\n-        t!(s: \"\\\\a\", \"\\\\\", Some(\"a\"));\n-        t!(s: \"\\\\\", \"\\\\\", None);\n-        t!(v: [\"a\\\\b\\\\c\"], [\"a\\\\b\"], Some(\"c\"));\n-        t!(v: [\"a\"], [\".\"], Some(\"a\"));\n-        t!(v: [\".\"], [\".\"], None);\n-        t!(v: [\"\\\\a\"], [\"\\\\\"], Some(\"a\"));\n-        t!(v: [\"\\\\\"], [\"\\\\\"], None);\n-\n-        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", Some(\"b\"));\n-        t!(s: \"C:\\\\a\", \"C:\\\\\", Some(\"a\"));\n-        t!(s: \"C:\\\\\", \"C:\\\\\", None);\n-        t!(s: \"C:a\\\\b\", \"C:a\", Some(\"b\"));\n-        t!(s: \"C:a\", \"C:\", Some(\"a\"));\n-        t!(s: \"C:\", \"C:\", None);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\", Some(\"a\"));\n-        t!(s: \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", None);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", None);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", Some(\"a\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", None);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", Some(\"a\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", None);\n-        t!(s: \"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", None);\n-\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\", Some(\"b\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", true);\n+        t!(s: \"a\", \".\", true);\n+        t!(s: \".\", \".\", false);\n+        t!(s: \"\\\\a\", \"\\\\\", true);\n+        t!(s: \"\\\\\", \"\\\\\", false);\n+        t!(v: [\"a\\\\b\\\\c\"], [\"a\\\\b\"], true);\n+        t!(v: [\"a\"], [\".\"], true);\n+        t!(v: [\".\"], [\".\"], false);\n+        t!(v: [\"\\\\a\"], [\"\\\\\"], true);\n+        t!(v: [\"\\\\\"], [\"\\\\\"], false);\n+\n+        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n+        t!(s: \"C:\\\\a\", \"C:\\\\\", true);\n+        t!(s: \"C:\\\\\", \"C:\\\\\", false);\n+        t!(s: \"C:a\\\\b\", \"C:a\", true);\n+        t!(s: \"C:a\", \"C:\", true);\n+        t!(s: \"C:\", \"C:\", false);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", true);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\", true);\n+        t!(s: \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", false);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\", true);\n+        t!(s: \"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", true);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n+        t!(s: \"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\", true);\n+        t!(s: \"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n+\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\", true);\n     }\n \n     #[test]\n@@ -1934,48 +1849,6 @@ mod tests {\n                 }\n             )\n         )\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \"d\", \"d\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \"d\\\\e\", \"d\\\\e\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \"\", \"c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \"\\\\\", \"\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \"/\", \"\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \".\", \"c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname, \"..\", \"..\\\\c\");\n-        t!(s: \"\\\\\", with_dirname, \"foo\", \"foo\");\n-        t!(s: \"\\\\\", with_dirname, \"\", \".\");\n-        t!(s: \"\\\\foo\", with_dirname, \"bar\", \"bar\\\\foo\");\n-        t!(s: \"..\", with_dirname, \"foo\", \"foo\");\n-        t!(s: \"..\\\\..\", with_dirname, \"foo\", \"foo\");\n-        t!(s: \"..\", with_dirname, \"\", \".\");\n-        t!(s: \"..\\\\..\", with_dirname, \"\", \".\");\n-        t!(s: \".\", with_dirname, \"foo\", \"foo\");\n-        t!(s: \"foo\", with_dirname, \"..\", \"..\\\\foo\");\n-        t!(s: \"foo\", with_dirname, \"..\\\\..\", \"..\\\\..\\\\foo\");\n-        t!(s: \"C:\\\\a\\\\b\", with_dirname, \"foo\", \"foo\\\\b\");\n-        t!(s: \"foo\", with_dirname, \"C:\\\\a\\\\b\", \"C:\\\\a\\\\b\\\\foo\");\n-        t!(s: \"C:a\\\\b\", with_dirname, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\b\");\n-        t!(s: \"a\", with_dirname, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\a\");\n-        t!(s: \"a\\\\b\", with_dirname, \"\\\\\\\\?\\\\\", \"\\\\\\\\?\\\\b\");\n-        t!(s: \"a\\\\b\", with_dirname, \"C:\", \"C:b\");\n-        t!(s: \"a\\\\b\", with_dirname, \"C:\\\\\", \"C:\\\\b\");\n-        t!(s: \"a\\\\b\", with_dirname, \"C:/\", \"C:\\\\b\");\n-        t!(s: \"C:\\\\\", with_dirname, \"foo\", \"foo\");\n-        t!(s: \"C:\", with_dirname, \"foo\", \"foo\");\n-        t!(s: \".\", with_dirname, \"C:\\\\\", \"C:\\\\\");\n-        t!(s: \".\", with_dirname, \"C:/\", \"C:\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_dirname, \"C:\\\\\", \"C:\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_dirname, \"bar\", \"bar\");\n-        t!(s: \"foo\\\\bar\", with_dirname, \"\\\\\\\\?\\\\C:\\\\baz\", \"\\\\\\\\?\\\\C:\\\\baz\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\foo\", with_dirname, \"C:\\\\bar\", \"C:\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\a\\\\foo\", with_dirname, \"C:\\\\bar\", \"C:\\\\bar\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\a\\\\foo/bar\", with_dirname, \"C:\\\\baz\", \"C:\\\\baz\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\", with_dirname, \"a\", \"a\\\\baz\");\n-        t!(s: \"foo\\\\bar\", with_dirname, \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\",\n-              \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", with_dirname, \"bar\", \"bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname, \"baz\", \"baz\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname, \"baz\\\\\", \"baz\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname, \"baz/\", \"baz\\\\bar\");\n \n         t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n         t!(s: \".\", with_filename, \"foo\", \"foo\");\n@@ -2028,29 +1901,6 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\", with_filename, \"bar\", \"\\\\\\\\.\\\\foo\\\\bar\");\n         t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename, \"..\", \"\\\\\\\\.\\\\foo\\\\..\");\n \n-        t!(s: \"hi\\\\there.txt\", with_filestem, \"here\", \"hi\\\\here.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem, \"\", \"hi\\\\.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem, \".\", \"hi\\\\..txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem, \"..\", \"hi\\\\...txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem, \"\\\\\", \"hi\\\\.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem, \"foo\\\\bar\", \"hi\\\\foo\\\\bar.txt\");\n-        t!(s: \"hi\\\\there.foo.txt\", with_filestem, \"here\", \"hi\\\\here.txt\");\n-        t!(s: \"hi\\\\there\", with_filestem, \"here\", \"hi\\\\here\");\n-        t!(s: \"hi\\\\there\", with_filestem, \"\", \"hi\");\n-        t!(s: \"hi\", with_filestem, \"\", \".\");\n-        t!(s: \"\\\\hi\", with_filestem, \"\", \"\\\\\");\n-        t!(s: \"hi\\\\there\", with_filestem, \"..\", \".\");\n-        t!(s: \"hi\\\\there\", with_filestem, \".\", \"hi\");\n-        t!(s: \"hi\\\\there.\", with_filestem, \"foo\", \"hi\\\\foo.\");\n-        t!(s: \"hi\\\\there.\", with_filestem, \"\", \"hi\");\n-        t!(s: \"hi\\\\there.\", with_filestem, \".\", \".\");\n-        t!(s: \"hi\\\\there.\", with_filestem, \"..\", \"hi\\\\...\");\n-        t!(s: \"\\\\\", with_filestem, \"foo\", \"\\\\foo\");\n-        t!(s: \".\", with_filestem, \"foo\", \"foo\");\n-        t!(s: \"hi\\\\there..\", with_filestem, \"here\", \"hi\\\\here.\");\n-        t!(s: \"hi\\\\there..\", with_filestem, \"\", \"hi\");\n-        // filestem setter calls filename setter internally, no need for extended tests\n-\n         t!(s: \"hi\\\\there.txt\", with_extension, \"exe\", \"hi\\\\there.exe\");\n         t!(s: \"hi\\\\there.txt\", with_extension, \"\", \"hi\\\\there\");\n         t!(s: \"hi\\\\there.txt\", with_extension, \".\", \"hi\\\\there..\");\n@@ -2093,16 +1943,6 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), set_dirname, with_dirname, b!(\"d\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), set_dirname, with_dirname, b!(\"d\\\\e\"));\n-        t!(s: \"a\\\\b\\\\c\", set_dirname, with_dirname, \"d\");\n-        t!(s: \"a\\\\b\\\\c\", set_dirname, with_dirname, \"d\\\\e\");\n-        t!(s: \"\\\\\", set_dirname, with_dirname, \"foo\");\n-        t!(s: \"\\\\foo\", set_dirname, with_dirname, \"bar\");\n-        t!(s: \"a\\\\b\\\\c\", set_dirname, with_dirname, \"\");\n-        t!(s: \"..\\\\..\", set_dirname, with_dirname, \"x\");\n-        t!(s: \"foo\", set_dirname, with_dirname, \"..\\\\..\");\n-\n         t!(v: b!(\"a\\\\b\\\\c\"), set_filename, with_filename, b!(\"d\"));\n         t!(v: b!(\"\\\\\"), set_filename, with_filename, b!(\"foo\"));\n         t!(s: \"a\\\\b\\\\c\", set_filename, with_filename, \"d\");\n@@ -2111,13 +1951,6 @@ mod tests {\n         t!(s: \"a\\\\b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b!(\"hi\\\\there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n-        t!(s: \"hi\\\\there.txt\", set_filestem, with_filestem, \"here\");\n-        t!(s: \"hi\\\\there.\", set_filestem, with_filestem, \"here\");\n-        t!(s: \"hi\\\\there\", set_filestem, with_filestem, \"here\");\n-        t!(s: \"hi\\\\there.txt\", set_filestem, with_filestem, \"\");\n-        t!(s: \"hi\\\\there\", set_filestem, with_filestem, \"\");\n-\n         t!(v: b!(\"hi\\\\there.txt\"), set_extension, with_extension, b!(\"exe\"));\n         t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi\\\\there.\", set_extension, with_extension, \"txt\");\n@@ -2130,33 +1963,6 @@ mod tests {\n         // will suffice. No need for the full set of prefix tests.\n     }\n \n-    #[test]\n-    fn test_add_extension() {\n-        macro_rules! t(\n-            (s: $path:expr, $ext:expr, $exp:expr) => (\n-                {\n-                    let mut path = Path::new($path);\n-                    path.add_extension($ext);\n-                    assert_eq!(path.as_str(), Some($exp));\n-                }\n-            );\n-            (v: $path:expr, $ext:expr, $exp:expr) => (\n-                {\n-                    let mut path = Path::new($path);\n-                    path.add_extension($ext);\n-                    assert_eq!(path.as_vec(), $exp);\n-                }\n-            )\n-        )\n-\n-        t!(v: b!(\"hi\\\\there.txt\"), b!(\"foo\"), b!(\"hi\\\\there.txt.foo\"));\n-        t!(v: b!(\"hi\\\\there\"), b!(\"bar\"), b!(\"hi\\\\there.bar\"));\n-        t!(v: b!(\"\\\\\"), b!(\"foo\"), b!(\"\\\\\"));\n-        t!(v: b!(\".\"), b!(\"foo\"), b!(\".\"));\n-        t!(s: \"hi\\\\there.\", \"foo\", \"hi\\\\there..foo\");\n-        t!(s: \"hi\\\\there.txt\", \"\", \"hi\\\\there.txt\");\n-    }\n-\n     #[test]\n     fn test_getters() {\n         macro_rules! t(\n@@ -2211,32 +2017,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_dir_file_path() {\n+    fn test_dir_path() {\n         t!(s: Path::new(\"hi\\\\there\").dir_path(), \"hi\");\n         t!(s: Path::new(\"hi\").dir_path(), \".\");\n         t!(s: Path::new(\"\\\\hi\").dir_path(), \"\\\\\");\n         t!(s: Path::new(\"\\\\\").dir_path(), \"\\\\\");\n         t!(s: Path::new(\"..\").dir_path(), \"..\");\n         t!(s: Path::new(\"..\\\\..\").dir_path(), \"..\\\\..\");\n \n-        macro_rules! t(\n-            ($path:expr, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let left = path.and_then_ref(|p| p.as_str());\n-                    assert_eq!(left, $exp);\n-                }\n-            );\n-        )\n-\n-        t!(Path::new(\"hi\\\\there\").file_path(), Some(\"there\"));\n-        t!(Path::new(\"hi\").file_path(), Some(\"hi\"));\n-        t!(Path::new(\".\").file_path(), None);\n-        t!(Path::new(\"\\\\\").file_path(), None);\n-        t!(Path::new(\"..\").file_path(), None);\n-        t!(Path::new(\"..\\\\..\").file_path(), None);\n-\n-        // dir_path and file_path are just dirname and filename interpreted as paths.\n+        // dir_path is just dirname interpreted as a path.\n         // No need for extended tests\n     }\n "}]}