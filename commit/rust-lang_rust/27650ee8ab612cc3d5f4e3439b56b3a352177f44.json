{"sha": "27650ee8ab612cc3d5f4e3439b56b3a352177f44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NjUwZWU4YWI2MTJjYzNkNWY0ZTM0MzliNTZiM2EzNTIxNzdmNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-11T16:40:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-11T16:40:52Z"}, "message": "Auto merge of #40454 - djzin:fast-swap, r=sfackler\n\nspeed up mem::swap\n\nI would have thought that the mem::swap code didn't need an intermediate variable precisely because the pointers are guaranteed never to alias. And.. it doesn't! It seems that llvm will also auto-vectorize this case for large structs, but alas it doesn't seem to have all the aliasing info it needs and so will add redundant checks (and even not bother with autovectorizing for small types). Looks like a lot of performance could still be gained here, so this might be a good test case for future optimizer improvements.\n\nHere are the current benchmarks for the simd version of mem::swap; the timings are in cycles (code below) measured with 10 iterations. The timings for sizes > 32 which are not a multiple of 8 tend to be ever so slightly faster in the old code, but not always. For large struct sizes (> 1024) the new code shows a marked improvement.\n\n\\* = latest commit\n\u2020 = subtracted from other measurements\n\n| arr_length\t| noop<sup>\u2020</sup>\t| rust_stdlib\t| simd_u64x4\\*\t| simd_u64x8\n|------------------|------------|-------------------|-------------------|-------------------\n8|80|90|90|90\n16|72|177|177|177\n24|32|76|76|76\n32|68|188|112|188\n40|32|80|60|80\n48|32|84|56|84\n56|32|108|72|108\n64|32|108|72|76\n72|80|350|220|230\n80|80|350|220|230\n88|80|420|270|270\n96|80|420|270|270\n104|80|500|320|320\n112|80|490|320|320\n120|72|528|342|342\n128|48|360|234|234\n136|72|987|387|387\n144|80|1070|420|420\n152|64|856|376|376\n160|68|804|400|400\n168|80|1060|520|520\n176|80|1070|520|520\n184|32|464|228|228\n192|32|504|228|228\n200|32|440|248|248\n208|72|987|573|573\n216|80|1464|220|220\n224|48|852|450|450\n232|72|1182|666|666\n240|32|428|288|288\n248|32|428|308|308\n256|80|860|770|770\n264|80|1130|820|820\n272|80|1340|820|820\n280|80|1220|870|870\n288|72|1227|804|804\n296|72|1356|849|849", "tree": {"sha": "13b864b90327aeef3566d97974b870ed7633cc8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13b864b90327aeef3566d97974b870ed7633cc8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27650ee8ab612cc3d5f4e3439b56b3a352177f44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27650ee8ab612cc3d5f4e3439b56b3a352177f44", "html_url": "https://github.com/rust-lang/rust/commit/27650ee8ab612cc3d5f4e3439b56b3a352177f44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27650ee8ab612cc3d5f4e3439b56b3a352177f44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a2dd41c5fed11f649079e34c4444f5e18a75cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a2dd41c5fed11f649079e34c4444f5e18a75cd", "html_url": "https://github.com/rust-lang/rust/commit/07a2dd41c5fed11f649079e34c4444f5e18a75cd"}, {"sha": "83f1f118e56320667c04a522e05f09a9f4abb6ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f1f118e56320667c04a522e05f09a9f4abb6ff", "html_url": "https://github.com/rust-lang/rust/commit/83f1f118e56320667c04a522e05f09a9f4abb6ff"}], "stats": {"total": 67, "additions": 54, "deletions": 13}, "files": [{"sha": "3924034fea22d92e2212c9b23832f528b35ae384", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/27650ee8ab612cc3d5f4e3439b56b3a352177f44/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27650ee8ab612cc3d5f4e3439b56b3a352177f44/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=27650ee8ab612cc3d5f4e3439b56b3a352177f44", "patch": "@@ -109,7 +109,7 @@ pub use intrinsics::transmute;\n /// [`Clone`][clone]. You need the value's destructor to run only once,\n /// because a double `free` is undefined behavior.\n ///\n-/// An example is the definition of [`mem::swap`][swap] in this module:\n+/// An example is a possible implementation of [`mem::swap`][swap]:\n ///\n /// ```\n /// use std::mem;\n@@ -499,18 +499,59 @@ pub unsafe fn uninitialized<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n-        // Give ourselves some scratch space to work with\n-        let mut t: T = uninitialized();\n-\n-        // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping(&*x, &mut t, 1);\n-        ptr::copy_nonoverlapping(&*y, x, 1);\n-        ptr::copy_nonoverlapping(&t, y, 1);\n-\n-        // y and t now point to the same thing, but we need to completely\n-        // forget `t` because we do not want to run the destructor for `T`\n-        // on its value, which is still owned somewhere outside this function.\n-        forget(t);\n+        // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n+        // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n+        // Haswell E processors. LLVM is more able to optimize if we give a struct a\n+        // #[repr(simd)], even if we don't actually use this struct directly.\n+        //\n+        // FIXME repr(simd) broken on emscripten\n+        #[cfg_attr(not(target_os = \"emscripten\"), repr(simd))]\n+        struct Block(u64, u64, u64, u64);\n+        struct UnalignedBlock(u64, u64, u64, u64);\n+\n+        let block_size = size_of::<Block>();\n+\n+        // Get raw pointers to the bytes of x & y for easier manipulation\n+        let x = x as *mut T as *mut u8;\n+        let y = y as *mut T as *mut u8;\n+\n+        // Loop through x & y, copying them `Block` at a time\n+        // The optimizer should unroll the loop fully for most types\n+        // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n+        let len = size_of::<T>();\n+        let mut i = 0;\n+        while i + block_size <= len {\n+            // Create some uninitialized memory as scratch space\n+            // Declaring `t` here avoids aligning the stack when this loop is unused\n+            let mut t: Block = uninitialized();\n+            let t = &mut t as *mut _ as *mut u8;\n+            let x = x.offset(i as isize);\n+            let y = y.offset(i as isize);\n+\n+            // Swap a block of bytes of x & y, using t as a temporary buffer\n+            // This should be optimized into efficient SIMD operations where available\n+            ptr::copy_nonoverlapping(x, t, block_size);\n+            ptr::copy_nonoverlapping(y, x, block_size);\n+            ptr::copy_nonoverlapping(t, y, block_size);\n+            i += block_size;\n+        }\n+\n+\n+        if i < len {\n+            // Swap any remaining bytes, using aligned types to copy\n+            // where appropriate (this information is lost by conversion\n+            // to *mut u8, so restore it manually here)\n+            let mut t: UnalignedBlock = uninitialized();\n+            let rem = len - i;\n+\n+            let t = &mut t as *mut _ as *mut u8;\n+            let x = x.offset(i as isize);\n+            let y = y.offset(i as isize);\n+\n+            ptr::copy_nonoverlapping(x, t, rem);\n+            ptr::copy_nonoverlapping(y, x, rem);\n+            ptr::copy_nonoverlapping(t, y, rem);\n+        }\n     }\n }\n "}]}