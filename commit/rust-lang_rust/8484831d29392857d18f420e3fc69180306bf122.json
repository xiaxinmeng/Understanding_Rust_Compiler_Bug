{"sha": "8484831d29392857d18f420e3fc69180306bf122", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODQ4MzFkMjkzOTI4NTdkMThmNDIwZTNmYzY5MTgwMzA2YmYxMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-06T07:16:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-06T07:16:41Z"}, "message": "Auto merge of #30884 - durka:inclusive-ranges, r=aturon\n\nThis PR implements [RFC 1192](https://github.com/rust-lang/rfcs/blob/master/text/1192-inclusive-ranges.md), which is triple-dot syntax for inclusive range expressions. The new stuff is behind two feature gates (one for the syntax and one for the std::ops types). This replaces the deprecated functionality in std::iter. Along the way I simplified the desugaring for all ranges.\n\nThis is my first contribution to rust which changes more than one character outside of a test or comment, so please review carefully! Some of the individual commit messages have more of my notes. Also thanks for putting up with my dumb questions in #rust-internals.\n\n- For implementing `std::ops::RangeInclusive`, I took @Stebalien's suggestion from https://github.com/rust-lang/rfcs/pull/1192#issuecomment-137864421. It seemed to me to make the implementation easier and increase type safety. If that stands, the RFC should be amended to avoid confusion.\n- I also kind of like @glaebhoerl's [idea](https://github.com/rust-lang/rfcs/pull/1254#issuecomment-147815299), which is unified inclusive/exclusive range syntax something like `x>..=y`. We can experiment with this while everything is behind a feature gate.\n- There are a couple of FIXMEs left (see the last commit). I didn't know what to do about `RangeArgument` and I haven't added `Index` impls yet. Those should be discussed/finished before merging.\n\ncc @Gankro since you [complained](https://www.reddit.com/r/rust/comments/3xkfro/what_happened_to_inclusive_ranges/cy5j0yq)\ncc #27777 #30877 rust-lang/rust#1192 rust-lang/rfcs#1254\nrelevant to #28237 (tracking issue)", "tree": {"sha": "f6e519c31cf318e88ce8fae02b7ee8e2a0c43b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6e519c31cf318e88ce8fae02b7ee8e2a0c43b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8484831d29392857d18f420e3fc69180306bf122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8484831d29392857d18f420e3fc69180306bf122", "html_url": "https://github.com/rust-lang/rust/commit/8484831d29392857d18f420e3fc69180306bf122", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8484831d29392857d18f420e3fc69180306bf122/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45f0ce71c19d8da081714dc917f11a8cc02d15be", "url": "https://api.github.com/repos/rust-lang/rust/commits/45f0ce71c19d8da081714dc917f11a8cc02d15be", "html_url": "https://github.com/rust-lang/rust/commit/45f0ce71c19d8da081714dc917f11a8cc02d15be"}, {"sha": "430b3e19606cf76288a383b89428107756d4aa61", "url": "https://api.github.com/repos/rust-lang/rust/commits/430b3e19606cf76288a383b89428107756d4aa61", "html_url": "https://github.com/rust-lang/rust/commit/430b3e19606cf76288a383b89428107756d4aa61"}], "stats": {"total": 1373, "additions": 983, "deletions": 390}, "files": [{"sha": "c174d2d6bacb6e4c1a916f02c0f86775d0413cde", "filename": "src/doc/book/iterators.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Fdoc%2Fbook%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Fdoc%2Fbook%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fiterators.md?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -14,6 +14,11 @@ Now that you know more Rust, we can talk in detail about how this works.\n Ranges (the `0..10`) are 'iterators'. An iterator is something that we can\n call the `.next()` method on repeatedly, and it gives us a sequence of things.\n \n+(By the way, a range with two dots like `0..10` is inclusive on the left (so it\n+starts at 0) and exclusive on the right (so it ends at 9). A mathematician\n+would write \"[0, 10)\". To get a range that goes all the way up to 10 you can\n+write `0...10`.)\n+\n Like this:\n \n ```rust"}, {"sha": "53f38cd77e4a433e6be43af2f3b7a05aad6b3b78", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -66,7 +66,8 @@\n * `..` (`..`, `expr..`, `..expr`, `expr..expr`): right-exclusive range literal.\n * `..` (`..expr`): struct literal update syntax.  See [Structs (Update syntax)].\n * `..` (`variant(x, ..)`, `struct_type { x, .. }`): \"and the rest\" pattern binding.  See [Patterns (Ignoring bindings)].\n-* `...` (`expr ... expr`): inclusive range pattern.  See [Patterns (Ranges)].\n+* `...` (`...expr`, `expr...expr`) *in an expression*: inclusive range expression. See [Iterators].\n+* `...` (`expr...expr`) *in a pattern*: inclusive range pattern.  See [Patterns (Ranges)].\n * `/` (`expr / expr`): arithmetic division.  Overloadable (`Div`).\n * `/=` (`var /= expr`): arithmetic division & assignment.\n * `:` (`pat: type`, `ident: type`): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].\n@@ -205,6 +206,7 @@\n [Functions (Early Returns)]: functions.html#early-returns\n [Functions]: functions.html\n [Generics]: generics.html\n+[Iterators]: iterators.html\n [Lifetimes]: lifetimes.html\n [Loops (`for`)]: loops.html#for\n [Loops (`loop`)]: loops.html#loop"}, {"sha": "c2b22ef3e72c24fdb5a4a20bd4faf9ed08456a9f", "filename": "src/doc/reference.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -2277,6 +2277,10 @@ The currently implemented features of the reference compiler are:\n                     `#[derive_Foo] #[derive_Bar]`, which can be user-defined syntax\n                     extensions.\n \n+* `inclusive_range_syntax` - Allows use of the `a...b` and `...b` syntax for inclusive ranges.\n+\n+* `inclusive_range` - Allows use of the types that represent desugared inclusive ranges.\n+\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n@@ -2747,6 +2751,25 @@ let y = 0..10;\n assert_eq!(x, y);\n ```\n \n+Similarly, the `...` operator will construct an object of one of the\n+`std::ops::RangeInclusive` variants.\n+\n+```\n+# #![feature(inclusive_range_syntax)]\n+1...2;   // std::ops::RangeInclusive\n+...4;    // std::ops::RangeToInclusive\n+```\n+\n+The following expressions are equivalent.\n+\n+```\n+# #![feature(inclusive_range_syntax, inclusive_range)]\n+let x = std::ops::RangeInclusive::NonEmpty {start: 0, end: 10};\n+let y = 0...10;\n+\n+assert_eq!(x, y);\n+```\n+\n ### Unary operator expressions\n \n Rust defines the following unary operators. They are all written as prefix operators,"}, {"sha": "922e1b0fc5d6dd3cd31634a8799bb7a334a4b726", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -40,7 +40,7 @@\n #![feature(fmt_internals)]\n #![feature(fmt_radix)]\n #![feature(heap_api)]\n-#![feature(iter_arith)]\n+#![feature(inclusive_range)]\n #![feature(iter_arith)]\n #![feature(lang_items)]\n #![feature(nonzero)]"}, {"sha": "4e39191b472ee8f6a85ec7ea67a21fbc0745c6d7", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -35,6 +35,7 @@ pub trait RangeArgument<T> {\n     }\n }\n \n+// FIXME add inclusive ranges to RangeArgument\n \n impl<T> RangeArgument<T> for RangeFull {}\n "}, {"sha": "cae6520bdb28683a2e5f6d436758d896b298c741", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -59,7 +59,7 @@ use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n use core::mem;\n-use core::ops::{self, Add};\n+use core::ops::{self, Add, Index, IndexMut};\n use core::ptr;\n use core::slice;\n use core::str::pattern::Pattern;\n@@ -1606,6 +1606,24 @@ impl ops::Index<ops::RangeFull> for String {\n         unsafe { str::from_utf8_unchecked(&self.vec) }\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::Index<ops::RangeInclusive<usize>> for String {\n+    type Output = str;\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n+        Index::index(&**self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::Index<ops::RangeToInclusive<usize>> for String {\n+    type Output = str;\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n+        Index::index(&**self, index)\n+    }\n+}\n \n #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n impl ops::IndexMut<ops::Range<usize>> for String {\n@@ -1635,6 +1653,20 @@ impl ops::IndexMut<ops::RangeFull> for String {\n         unsafe { mem::transmute(&mut *self.vec) }\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {"}, {"sha": "934a9f3d614527c74e771047b8afed5614d16e8b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1226,6 +1226,24 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n@@ -1255,6 +1273,20 @@ impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {"}, {"sha": "377a8b6a05f5e348856352e67512e641c83a3362", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 214, "deletions": 93, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -306,7 +306,7 @@ use default::Default;\n use marker;\n use mem;\n use num::{Zero, One};\n-use ops::{self, Add, Sub, FnMut, Mul, RangeFrom};\n+use ops::{self, Add, Sub, FnMut, Mul};\n use option::Option::{self, Some, None};\n use marker::Sized;\n use usize;\n@@ -4297,7 +4297,7 @@ step_impl_no_between!(u64 i64);\n ///\n /// The resulting iterator handles overflow by stopping. The `A`\n /// parameter is the type being iterated over, while `R` is the range\n-/// type (usually one of `std::ops::{Range, RangeFrom}`.\n+/// type (usually one of `std::ops::{Range, RangeFrom, RangeInclusive}`.\n #[derive(Clone)]\n #[unstable(feature = \"step_by\", reason = \"recent addition\",\n            issue = \"27741\")]\n@@ -4306,7 +4306,7 @@ pub struct StepBy<A, R> {\n     range: R,\n }\n \n-impl<A: Step> RangeFrom<A> {\n+impl<A: Step> ops::RangeFrom<A> {\n     /// Creates an iterator starting at the same point, but stepping by\n     /// the given amount at each iteration.\n     ///\n@@ -4366,8 +4366,44 @@ impl<A: Step> ops::Range<A> {\n     }\n }\n \n+impl<A: Step> ops::RangeInclusive<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(step_by, inclusive_range_syntax)]\n+    ///\n+    /// for i in (0...10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// 10\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n+impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n     A: Clone,\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n@@ -4386,95 +4422,6 @@ impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n     }\n }\n \n-/// An iterator over the range [start, stop]\n-#[derive(Clone)]\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-pub struct RangeInclusive<A> {\n-    range: ops::Range<A>,\n-    done: bool,\n-}\n-\n-/// Returns an iterator over the range [start, stop].\n-#[inline]\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n-    where A: Step + One + Clone\n-{\n-    RangeInclusive {\n-        range: start..stop,\n-        done: false,\n-    }\n-}\n-\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-impl<A> Iterator for RangeInclusive<A> where\n-    A: PartialEq + Step + One + Clone,\n-    for<'a> &'a A: Add<&'a A, Output = A>\n-{\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        self.range.next().or_else(|| {\n-            if !self.done && self.range.start == self.range.end {\n-                self.done = true;\n-                Some(self.range.end.clone())\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lo, hi) = self.range.size_hint();\n-        if self.done {\n-            (lo, hi)\n-        } else {\n-            let lo = lo.saturating_add(1);\n-            let hi = hi.and_then(|x| x.checked_add(1));\n-            (lo, hi)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-impl<A> DoubleEndedIterator for RangeInclusive<A> where\n-    A: PartialEq + Step + One + Clone,\n-    for<'a> &'a A: Add<&'a A, Output = A>,\n-    for<'a> &'a A: Sub<Output=A>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        if self.range.end > self.range.start {\n-            let result = self.range.end.clone();\n-            self.range.end = &self.range.end - &A::one();\n-            Some(result)\n-        } else if !self.done && self.range.start == self.range.end {\n-            self.done = true;\n-            Some(self.range.end.clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n@@ -4512,10 +4459,83 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\",\n+           reason = \"recently added, follows RFC\",\n+           issue = \"28237\")]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self.range, so borrows of start and end need to end early\n+\n+        let (finishing, n) = match self.range {\n+            Empty { .. } => return None, // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                let zero = A::zero();\n+                let rev = self.step_by < zero;\n+\n+                // march start towards (maybe past!) end and yield the old value\n+                if (rev && start >= end) ||\n+                   (!rev && start <= end)\n+                {\n+                    match start.step(&self.step_by) {\n+                        Some(mut n) => {\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        },\n+                        None => {\n+                            let mut n = end.clone();\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        }\n+                    }\n+                } else {\n+                    // found range in inconsistent state (start at or past end), so become empty\n+                    (Some(mem::replace(end, zero)), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if we've reached the end\n+        if let Some(end) = finishing {\n+            self.range = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match self.range {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start,\n+                                          end,\n+                                          &self.step_by) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None       => (0, None)\n+                }\n+        }\n+    }\n+}\n+\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl ExactSizeIterator for ops::Range<$t> { }\n+\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n     )*)\n }\n \n@@ -4579,6 +4599,107 @@ impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self, so borrows of self.start and self.end need to end early\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => (None, None), // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                if start == end {\n+                    (Some(mem::replace(end, A::one())), Some(mem::replace(start, A::one())))\n+                } else if start < end {\n+                    let one = A::one();\n+                    let mut n = &*start + &one;\n+                    mem::swap(&mut n, start);\n+\n+                    // if the iterator is done iterating, it will change from NonEmpty to Empty\n+                    // to avoid unnecessary drops or clones, we'll reuse either start or end\n+                    // (they are equal now, so it doesn't matter which)\n+                    // to pull out end, we need to swap something back in -- use the previously\n+                    // created A::one() as a dummy value\n+\n+                    (if n == *end { Some(mem::replace(end, one)) } else { None },\n+                    // ^ are we done yet?\n+                    Some(n)) // < the value to output\n+                } else {\n+                    (Some(mem::replace(start, A::one())), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if this is the last value\n+        if let Some(end) = finishing {\n+            *self = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match *self {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start, end, &A::one()) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None => (0, None),\n+                }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>,\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // see Iterator::next for comments\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => return None,\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                if start == end {\n+                    (Some(mem::replace(start, A::one())), Some(mem::replace(end, A::one())))\n+                } else if start < end {\n+                    let one = A::one();\n+                    let mut n = &*end - &one;\n+                    mem::swap(&mut n, end);\n+\n+                    (if n == *start { Some(mem::replace(start, one)) } else { None },\n+                     Some(n))\n+                } else {\n+                    (Some(mem::replace(end, A::one())), None)\n+                }\n+            }\n+        };\n+\n+        if let Some(start) = finishing {\n+            *self = Empty { at: start };\n+        }\n+\n+        n\n+    }\n+}\n+\n /// An iterator that repeats an element endlessly.\n ///\n /// This `struct` is created by the [`repeat()`] function. See its documentation for more."}, {"sha": "a6dbec6c39dab83a20263cf24a92ed6392a3daa1", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 92, "deletions": 5, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -67,8 +67,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use marker::{Sized, Unsize};\n+use cmp::PartialOrd;\n use fmt;\n+use convert::From;\n+use marker::{Sized, Unsize};\n+use num::One;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n@@ -1445,7 +1448,7 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang = \"range_full\"]\n+#[cfg_attr(stage0, lang = \"range_full\")] // FIXME remove attribute after next snapshot\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n \n@@ -1458,7 +1461,7 @@ impl fmt::Debug for RangeFull {\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Clone, PartialEq, Eq)]\n-#[lang = \"range\"]\n+#[cfg_attr(stage0, lang = \"range\")] // FIXME remove attribute after next snapshot\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -1478,7 +1481,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n \n /// A range which is only bounded below.\n #[derive(Clone, PartialEq, Eq)]\n-#[lang = \"range_from\"]\n+#[cfg_attr(stage0, lang = \"range_from\")] // FIXME remove attribute after next snapshot\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -1495,7 +1498,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n \n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang = \"range_to\"]\n+#[cfg_attr(stage0, lang = \"range_to\")] // FIXME remove attribute after next snapshot\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n@@ -1510,6 +1513,90 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n+/// An inclusive range which is bounded at both ends.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub enum RangeInclusive<Idx> {\n+    /// Empty range (iteration has finished)\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    Empty {\n+        /// The point at which iteration finished\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        at: Idx\n+    },\n+    /// Non-empty range (iteration will yield value(s))\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    NonEmpty {\n+        /// The lower bound of the range (inclusive).\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        start: Idx,\n+        /// The upper bound of the range (inclusive).\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        end: Idx,\n+    },\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use self::RangeInclusive::*;\n+\n+        match *self {\n+            Empty { ref at } => write!(fmt, \"[empty range @ {:?}]\", at),\n+            NonEmpty { ref start, ref end } => write!(fmt, \"{:?}...{:?}\", start, end),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: PartialOrd + One + Sub<Output=Idx>> From<Range<Idx>> for RangeInclusive<Idx> {\n+    fn from(range: Range<Idx>) -> RangeInclusive<Idx> {\n+        use self::RangeInclusive::*;\n+\n+        if range.start < range.end {\n+            NonEmpty {\n+                start: range.start,\n+                end: range.end - Idx::one() // can't underflow because end > start >= MIN\n+            }\n+        } else {\n+            Empty {\n+                at: range.start\n+            }\n+        }\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeToInclusive<Idx> {\n+    /// The upper bound of the range (inclusive)\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"...{:?}\", self.end)\n+    }\n+}\n+\n+// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n+// because underflow would be possible with (..0).into()\n+\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations, like `*v`.\n ///"}, {"sha": "8acd0c8f2cf066a1ba20513d24163561e705c3bd", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -533,6 +533,8 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n+// FIXME implement indexing with inclusive ranges\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n@@ -558,7 +560,7 @@ impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n \n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        self.index(ops::Range{ start: 0, end: index.end })\n+        self.index(0 .. index.end)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -567,7 +569,7 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n \n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        self.index(ops::Range{ start: index.start, end: self.len() })\n+        self.index(index.start .. self.len())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -580,6 +582,32 @@ impl<T> ops::Index<RangeFull> for [T] {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeInclusive<usize>> for [T] {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n+        match index {\n+            ops::RangeInclusive::Empty { .. } => &[],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                panic!(\"attempted to index slice up to maximum usize\"),\n+            ops::RangeInclusive::NonEmpty { start, end } =>\n+                self.index(start .. end+1)\n+        }\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n+        // SNAP 4d3eebf change this to `0...index.end`\n+        self.index(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n@@ -601,15 +629,15 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(ops::Range{ start: 0, end: index.end })\n+        self.index_mut(0 .. index.end)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n-        self.index_mut(ops::Range{ start: index.start, end: len })\n+        self.index_mut(index.start .. len)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -620,6 +648,27 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for [T] {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n+        match index {\n+            ops::RangeInclusive::Empty { .. } => &mut [],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                panic!(\"attempted to index slice up to maximum usize\"),\n+            ops::RangeInclusive::NonEmpty { start, end } =>\n+                self.index_mut(start .. end+1)\n+        }\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for [T] {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n+        // SNAP 4d3eebf change this to `0...index.end`\n+        self.index_mut(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+    }\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common traits"}, {"sha": "458318c5250a2760bdf4aafbcaa8463041f98311", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1460,6 +1460,62 @@ mod traits {\n             self\n         }\n     }\n+\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::Index<ops::RangeInclusive<usize>> for str {\n+        type Output = str;\n+\n+        #[inline]\n+        fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n+            match index {\n+                ops::RangeInclusive::Empty { .. } => \"\",\n+                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                    panic!(\"attempted to index slice up to maximum usize\"),\n+                ops::RangeInclusive::NonEmpty { start, end } =>\n+                    self.index(start .. end+1)\n+            }\n+        }\n+    }\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::Index<ops::RangeToInclusive<usize>> for str {\n+        type Output = str;\n+\n+        #[inline]\n+        fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n+            // SNAP 4d3eebf change this to `0...index.end`\n+            self.index(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+        }\n+    }\n+\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n+            match index {\n+                ops::RangeInclusive::Empty { .. } => &mut self[0..0], // `&mut \"\"` doesn't work\n+                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                    panic!(\"attempted to index str up to maximum usize\"),\n+                    ops::RangeInclusive::NonEmpty { start, end } =>\n+                        self.index_mut(start .. end+1)\n+            }\n+        }\n+    }\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n+            // SNAP 4d3eebf change this to `0...index.end`\n+            self.index_mut(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+        }\n+    }\n }\n \n /// Methods for string slices"}, {"sha": "1fb27261c4dbf6de87a6e577443a9b7c825366e8", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -317,12 +317,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprRange(ref start, ref end) => {\n-                let fields = start.as_ref().map(|e| &**e).into_iter()\n-                    .chain(end.as_ref().map(|e| &**e));\n-                self.straightline(expr, pred, fields)\n-            }\n-\n             hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }"}, {"sha": "5ddea6917435edb54fb8f9c5c777cb287f885c36", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -398,11 +398,6 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            hir::ExprRange(ref start, ref end) => {\n-                start.as_ref().map(|e| self.consume_expr(&e));\n-                end.as_ref().map(|e| self.consume_expr(&e));\n-            }\n-\n             hir::ExprCall(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &callee);\n                 self.consume_exprs(args);"}, {"sha": "8d407d0aa44739e22d3b091d55f8955fa8e4e377", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -302,10 +302,6 @@ lets_do_this! {\n     ShrAssignTraitLangItem,          \"shr_assign\",              shr_assign_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n-    RangeStructLangItem,             \"range\",                   range_struct;\n-    RangeFromStructLangItem,         \"range_from\",              range_from_struct;\n-    RangeToStructLangItem,           \"range_to\",                range_to_struct;\n-    RangeFullStructLangItem,         \"range_full\",              range_full_struct;\n \n     UnsafeCellTypeLangItem,          \"unsafe_cell\",             unsafe_cell_type;\n "}, {"sha": "5abfd2b7d2c5bb9759cef661e4d9a724b52927fd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -498,7 +498,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n-      hir::ExprRange(..) | hir::ExprType(..) => {\n+      hir::ExprType(..) => {\n           intravisit::walk_expr(ir, expr);\n       }\n     }\n@@ -1154,11 +1154,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&l, r_succ)\n           }\n \n-          hir::ExprRange(ref e1, ref e2) => {\n-            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&e, succ));\n-            e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&e, succ))\n-          }\n-\n           hir::ExprBox(ref e) |\n           hir::ExprAddrOf(_, ref e) |\n           hir::ExprCast(ref e, _) |\n@@ -1446,7 +1441,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n-      hir::ExprRange(..) | hir::ExprType(..) => {\n+      hir::ExprType(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n     }"}, {"sha": "ab894a55b44fef934e53d815ba4f83e9b55107f8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -526,7 +526,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           hir::ExprAddrOf(..) | hir::ExprCall(..) |\n           hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n           hir::ExprClosure(..) | hir::ExprRet(..) |\n-          hir::ExprUnary(..) | hir::ExprRange(..) |\n+          hir::ExprUnary(..) |\n           hir::ExprMethodCall(..) | hir::ExprCast(..) |\n           hir::ExprVec(..) | hir::ExprTup(..) | hir::ExprIf(..) |\n           hir::ExprBinary(..) | hir::ExprWhile(..) |"}, {"sha": "042007f5fef059d72c9884bf8c26f916e25973d8", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -2008,7 +2008,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             hir::ExprCall(..) |\n             hir::ExprMethodCall(..) |\n             hir::ExprStruct(..) |\n-            hir::ExprRange(..) |\n             hir::ExprTup(..) |\n             hir::ExprIf(..) |\n             hir::ExprMatch(..) |"}, {"sha": "b01b80b813399048d30ff41b2313d7113f198af1", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -243,7 +243,6 @@ mod svh_visitor {\n         SawExprAssign,\n         SawExprAssignOp(hir::BinOp_),\n         SawExprIndex,\n-        SawExprRange,\n         SawExprPath(Option<usize>),\n         SawExprAddrOf(hir::Mutability),\n         SawExprRet,\n@@ -275,7 +274,6 @@ mod svh_visitor {\n             ExprField(_, name)       => SawExprField(name.node.as_str()),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n-            ExprRange(..)            => SawExprRange,\n             ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n             ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),"}, {"sha": "beedb3d70b69917e93b62cda7e41cb506c938cdb", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1090,10 +1090,6 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprRange(e1, e2) => {\n-                ExprRange(e1.map(|x| folder.fold_expr(x)),\n-                          e2.map(|x| folder.fold_expr(x)))\n-            }\n             ExprPath(qself, path) => {\n                 let qself = qself.map(|QSelf { ty, position }| {\n                     QSelf {"}, {"sha": "44e7fa05073a1d195e194f48aef64db783ce6fc1", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -776,8 +776,6 @@ pub enum Expr_ {\n     ExprTupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n-    /// A range (`1..2`, `1..`, or `..2`)\n-    ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>."}, {"sha": "d71e392f521e7795cf44f64029bcd1454dc14950", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -784,10 +784,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprRange(ref start, ref end) => {\n-            walk_list!(visitor, visit_expr, start);\n-            walk_list!(visitor, visit_expr, end);\n-        }\n         ExprPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);"}, {"sha": "acc7c6164b54ab9a3d0ed36443e7a07f7da2152a", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 94, "deletions": 3, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -65,6 +65,7 @@ use hir;\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n+use std::iter;\n use syntax::ast::*;\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ext::mtwt;\n@@ -1217,9 +1218,79 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n-            ExprKind::Range(ref e1, ref e2) => {\n-                hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n-                               e2.as_ref().map(|x| lower_expr(lctx, x)))\n+            ExprKind::Range(ref e1, ref e2, lims) => {\n+                fn make_struct(lctx: &LoweringContext,\n+                               ast_expr: &Expr,\n+                               path: &[&str],\n+                               fields: &[(&str, &P<Expr>)]) -> P<hir::Expr> {\n+                    let strs = std_path(lctx, &iter::once(&\"ops\")\n+                                                    .chain(path)\n+                                                    .map(|s| *s)\n+                                                    .collect::<Vec<_>>());\n+\n+                    let structpath = path_global(ast_expr.span, strs);\n+\n+                    let hir_expr = if fields.len() == 0 {\n+                        expr_path(lctx,\n+                                  structpath,\n+                                  ast_expr.attrs.clone())\n+                    } else {\n+                        expr_struct(lctx,\n+                                    ast_expr.span,\n+                                    structpath,\n+                                    fields.into_iter().map(|&(s, e)| {\n+                                        field(token::intern(s),\n+                                              signal_block_expr(lctx,\n+                                                                hir_vec![],\n+                                                                lower_expr(lctx, &**e),\n+                                                                e.span,\n+                                                                hir::PopUnstableBlock,\n+                                                                None),\n+                                              ast_expr.span)\n+                                    }).collect(),\n+                                    None,\n+                                    ast_expr.attrs.clone())\n+                    };\n+\n+                    signal_block_expr(lctx,\n+                                      hir_vec![],\n+                                      hir_expr,\n+                                      ast_expr.span,\n+                                      hir::PushUnstableBlock,\n+                                      None)\n+                }\n+\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    use syntax::ast::RangeLimits::*;\n+\n+                    match (e1, e2, lims) {\n+                        (&None,         &None,         HalfOpen) =>\n+                            make_struct(lctx, e, &[\"RangeFull\"],\n+                                                 &[]),\n+\n+                        (&Some(ref e1), &None,         HalfOpen) =>\n+                            make_struct(lctx, e, &[\"RangeFrom\"],\n+                                                 &[(\"start\", e1)]),\n+\n+                        (&None,         &Some(ref e2), HalfOpen) =>\n+                            make_struct(lctx, e, &[\"RangeTo\"],\n+                                                 &[(\"end\", e2)]),\n+\n+                        (&Some(ref e1), &Some(ref e2), HalfOpen) =>\n+                            make_struct(lctx, e, &[\"Range\"],\n+                                                 &[(\"start\", e1), (\"end\", e2)]),\n+\n+                        (&None,         &Some(ref e2), Closed)   =>\n+                            make_struct(lctx, e, &[\"RangeToInclusive\"],\n+                                                 &[(\"end\", e2)]),\n+\n+                        (&Some(ref e1), &Some(ref e2), Closed)   =>\n+                            make_struct(lctx, e, &[\"RangeInclusive\", \"NonEmpty\"],\n+                                                 &[(\"start\", e1), (\"end\", e2)]),\n+\n+                        _ => panic!(\"impossible range in AST\"),\n+                    }\n+                });\n             }\n             ExprKind::Path(ref qself, ref path) => {\n                 let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n@@ -1627,6 +1698,17 @@ fn arm(pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     }\n }\n \n+fn field(name: Name, expr: P<hir::Expr>, span: Span) -> hir::Field {\n+    hir::Field {\n+        name: Spanned {\n+            node: name,\n+            span: span,\n+        },\n+        span: span,\n+        expr: expr,\n+    }\n+}\n+\n fn expr_break(lctx: &LoweringContext, span: Span,\n               attrs: ThinAttributes) -> P<hir::Expr> {\n     expr(lctx, span, hir::ExprBreak(None), attrs)\n@@ -1676,6 +1758,15 @@ fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: hir::HirVec<P<hir::Expr>>\n     expr(lctx, sp, hir::ExprTup(exprs), attrs)\n }\n \n+fn expr_struct(lctx: &LoweringContext,\n+               sp: Span,\n+               path: hir::Path,\n+               fields: hir::HirVec<hir::Field>,\n+               e: Option<P<hir::Expr>>,\n+               attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs)\n+}\n+\n fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_,\n         attrs: ThinAttributes) -> P<hir::Expr> {\n     P(hir::Expr {"}, {"sha": "143dfce09b6029f1ee20cd12a22f22797edb7b9b", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1449,15 +1449,6 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            hir::ExprRange(ref start, ref end) => {\n-                if let &Some(ref e) = start {\n-                    try!(self.print_expr(&e));\n-                }\n-                try!(word(&mut self.s, \"..\"));\n-                if let &Some(ref e) = end {\n-                    try!(self.print_expr(&e));\n-                }\n-            }\n             hir::ExprPath(None, ref path) => {\n                 try!(self.print_path(path, true, 0))\n             }"}, {"sha": "cb54cadfcd16b4c6c7267b8d026ade1f59e5e9ce", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -22,7 +22,6 @@ use rustc::middle::ty::{self, VariantDef, Ty};\n use rustc::mir::repr::*;\n use rustc_front::hir;\n use rustc_front::util as hir_util;\n-use syntax::parse::token;\n use syntax::ptr::P;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -324,38 +323,6 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 }\n             }\n \n-            hir::ExprRange(ref start, ref end) => {\n-                let range_ty = cx.tcx.expr_ty(self);\n-                let (adt_def, substs) = match range_ty.sty {\n-                    ty::TyStruct(adt_def, substs) => (adt_def, substs),\n-                    _ => {\n-                        cx.tcx.sess.span_bug(self.span, \"unexpanded ast\");\n-                    }\n-                };\n-\n-                let field_expr_ref = |s: &'tcx P<hir::Expr>, name: &str| {\n-                    let name = token::intern(name);\n-                    let index = adt_def.variants[0].index_of_field_named(name).unwrap();\n-                    FieldExprRef { name: Field::new(index), expr: s.to_ref() }\n-                };\n-\n-                let start_field = start.as_ref()\n-                                       .into_iter()\n-                                       .map(|s| field_expr_ref(s, \"start\"));\n-\n-                let end_field = end.as_ref()\n-                                   .into_iter()\n-                                   .map(|e| field_expr_ref(e, \"end\"));\n-\n-                ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    variant_index: 0,\n-                    substs: substs,\n-                    fields: start_field.chain(end_field).collect(),\n-                    base: None,\n-                }\n-            }\n-\n             hir::ExprPath(..) => {\n                 convert_path_expr(cx, self)\n             }"}, {"sha": "810712bb0cf18fa3e9e07c81e2473d3b349076b8", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -747,9 +747,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprAgain(_) |\n         hir::ExprRet(_) |\n \n-        // Miscellaneous expressions that could be implemented.\n-        hir::ExprRange(..) |\n-\n         // Expressions with side-effects.\n         hir::ExprAssign(..) |\n         hir::ExprAssignOp(..) |"}, {"sha": "4ba103c0c0d08c7991aa24c9ec8a135407f43736", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -346,11 +346,6 @@ fn walk_expr(cx: &CrateContext,\n             walk_expr(cx, &rhs, scope_stack, scope_map);\n         }\n \n-        hir::ExprRange(ref start, ref end) => {\n-            start.as_ref().map(|e| walk_expr(cx, &e, scope_stack, scope_map));\n-            end.as_ref().map(|e| walk_expr(cx, &e, scope_stack, scope_map));\n-        }\n-\n         hir::ExprVec(ref init_expressions) |\n         hir::ExprTup(ref init_expressions) => {\n             for ie in init_expressions {"}, {"sha": "e3e53607829e6aead4ceebf7c3114675d501f55f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -86,7 +86,6 @@ use rustc_front::hir;\n use syntax::{ast, codemap};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n-use syntax::parse::token;\n use std::mem;\n \n // Destinations\n@@ -1059,7 +1058,6 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n-    let tcx = bcx.tcx();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n@@ -1088,59 +1086,6 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          node_id_type(bcx, expr.id),\n                          dest)\n         }\n-        hir::ExprRange(ref start, ref end) => {\n-            // FIXME it is just not right that we are synthesising ast nodes in\n-            // trans. Shudder.\n-            fn make_field(field_name: &str, expr: P<hir::Expr>) -> hir::Field {\n-                hir::Field {\n-                    name: codemap::dummy_spanned(token::intern(field_name)),\n-                    expr: expr,\n-                    span: codemap::DUMMY_SP,\n-                }\n-            }\n-\n-            // A range just desugars into a struct.\n-            // Note that the type of the start and end may not be the same, but\n-            // they should only differ in their lifetime, which should not matter\n-            // in trans.\n-            let (did, fields, ty_params) = match (start, end) {\n-                (&Some(ref start), &Some(ref end)) => {\n-                    // Desugar to Range\n-                    let fields = vec![make_field(\"start\", start.clone()),\n-                                      make_field(\"end\", end.clone())];\n-                    (tcx.lang_items.range_struct(), fields, vec![node_id_type(bcx, start.id)])\n-                }\n-                (&Some(ref start), &None) => {\n-                    // Desugar to RangeFrom\n-                    let fields = vec![make_field(\"start\", start.clone())];\n-                    (tcx.lang_items.range_from_struct(), fields, vec![node_id_type(bcx, start.id)])\n-                }\n-                (&None, &Some(ref end)) => {\n-                    // Desugar to RangeTo\n-                    let fields = vec![make_field(\"end\", end.clone())];\n-                    (tcx.lang_items.range_to_struct(), fields, vec![node_id_type(bcx, end.id)])\n-                }\n-                _ => {\n-                    // Desugar to RangeFull\n-                    (tcx.lang_items.range_full_struct(), vec![], vec![])\n-                }\n-            };\n-\n-            if let Some(did) = did {\n-                let substs = Substs::new_type(ty_params, vec![]);\n-                trans_struct(bcx,\n-                             &fields,\n-                             None,\n-                             expr.span,\n-                             expr.id,\n-                             tcx.mk_struct(tcx.lookup_adt_def(did),\n-                                           tcx.mk_substs(substs)),\n-                             dest)\n-            } else {\n-                tcx.sess.span_bug(expr.span,\n-                                  \"No lang item for ranges (how did we get this far?)\")\n-            }\n-        }\n         hir::ExprTup(ref args) => {\n             let numbered_fields: Vec<(usize, &hir::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n@@ -2625,7 +2570,6 @@ fn expr_kind(tcx: &TyCtxt, expr: &hir::Expr) -> ExprKind {\n         hir::ExprCall(..) |\n         hir::ExprMethodCall(..) |\n         hir::ExprStruct(..) |\n-        hir::ExprRange(..) |\n         hir::ExprTup(..) |\n         hir::ExprIf(..) |\n         hir::ExprMatch(..) |"}, {"sha": "eee3d23283107f809f8bb1a8fd1e848e6dd383ce", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -3673,87 +3673,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               }\n           }\n        }\n-       hir::ExprRange(ref start, ref end) => {\n-          let t_start = start.as_ref().map(|e| {\n-            check_expr(fcx, &e);\n-            fcx.expr_ty(&e)\n-          });\n-          let t_end = end.as_ref().map(|e| {\n-            check_expr(fcx, &e);\n-            fcx.expr_ty(&e)\n-          });\n-\n-          let idx_type = match (t_start, t_end) {\n-              (Some(ty), None) | (None, Some(ty)) => {\n-                  Some(ty)\n-              }\n-              (Some(t_start), Some(t_end)) if (t_start.references_error() ||\n-                                               t_end.references_error()) => {\n-                  Some(fcx.tcx().types.err)\n-              }\n-              (Some(t_start), Some(t_end)) => {\n-                  Some(infer::common_supertype(fcx.infcx(),\n-                                               TypeOrigin::RangeExpression(expr.span),\n-                                               true,\n-                                               t_start,\n-                                               t_end))\n-              }\n-              _ => None\n-          };\n-\n-          // Note that we don't check the type of start/end satisfy any\n-          // bounds because right now the range structs do not have any. If we add\n-          // some bounds, then we'll need to check `t_start` against them here.\n-\n-          let range_type = match idx_type {\n-            Some(idx_type) if idx_type.references_error() => {\n-                fcx.tcx().types.err\n-            }\n-            Some(idx_type) => {\n-                // Find the did from the appropriate lang item.\n-                let did = match (start, end) {\n-                    (&Some(_), &Some(_)) => tcx.lang_items.range_struct(),\n-                    (&Some(_), &None) => tcx.lang_items.range_from_struct(),\n-                    (&None, &Some(_)) => tcx.lang_items.range_to_struct(),\n-                    (&None, &None) => {\n-                        tcx.sess.span_bug(expr.span, \"full range should be dealt with above\")\n-                    }\n-                };\n-\n-                if let Some(did) = did {\n-                    let def = tcx.lookup_adt_def(did);\n-                    let predicates = tcx.lookup_predicates(did);\n-                    let substs = Substs::new_type(vec![idx_type], vec![]);\n-                    let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n-                    fcx.add_obligations_for_parameters(\n-                        traits::ObligationCause::new(expr.span,\n-                                                     fcx.body_id,\n-                                                     traits::ItemObligation(did)),\n-                        &bounds);\n-\n-                    tcx.mk_struct(def, tcx.mk_substs(substs))\n-                } else {\n-                    span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n-                    fcx.tcx().types.err\n-                }\n-            }\n-            None => {\n-                // Neither start nor end => RangeFull\n-                if let Some(did) = tcx.lang_items.range_full_struct() {\n-                    tcx.mk_struct(\n-                        tcx.lookup_adt_def(did),\n-                        tcx.mk_substs(Substs::empty())\n-                    )\n-                } else {\n-                    span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n-                    fcx.tcx().types.err\n-                }\n-            }\n-          };\n-\n-          fcx.write_ty(id, range_type);\n-       }\n-\n     }\n \n     debug!(\"type of expr({}) {} is...\", expr.id,"}, {"sha": "01f7d6b456582cd4ff4cdc8016c57ebebf91c1bc", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -3643,8 +3643,8 @@ register_diagnostics! {\n //  E0233,\n //  E0234,\n //  E0235, // structure constructor specifies a structure of type but\n-    E0236, // no lang item for range syntax\n-    E0237, // no lang item for range syntax\n+//  E0236, // no lang item for range syntax\n+//  E0237, // no lang item for range syntax\n     E0238, // parenthesized parameters may only be used with a trait\n //  E0239, // `next` method of `Iterator` trait has unexpected type\n //  E0240,"}, {"sha": "fa07b0f761b4e035c65e4be23f141188964fd60f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -232,6 +232,7 @@\n #![feature(fnbox)]\n #![feature(heap_api)]\n #![feature(hashmap_hasher)]\n+#![feature(inclusive_range)]\n #![feature(int_error_internals)]\n #![feature(into_cow)]\n #![feature(lang_items)]\n@@ -246,7 +247,6 @@\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n-#![feature(range_inclusive)]\n #![feature(raw)]\n #![feature(repr_simd)]\n #![feature(reflect_marker)]"}, {"sha": "0dbfb2c7be65470ee70d7a0f22d771bfd6f0071a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -886,6 +886,15 @@ impl fmt::Debug for Expr {\n     }\n }\n \n+/// Limit types of a range (inclusive or exclusive)\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum RangeLimits {\n+    /// Inclusive at the beginning, exclusive at the end\n+    HalfOpen,\n+    /// Inclusive at the beginning and end\n+    Closed,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n@@ -974,8 +983,8 @@ pub enum ExprKind {\n     TupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     Index(P<Expr>, P<Expr>),\n-    /// A range (`1..2`, `1..`, or `..2`)\n-    Range(Option<P<Expr>>, Option<P<Expr>>),\n+    /// A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)\n+    Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>."}, {"sha": "2302548914223c21ddd9091b83c9fa1b918dae19", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -241,7 +241,10 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"cfg_target_thread_local\", \"1.7.0\", Some(29594), Active),\n \n     // rustc internal\n-    (\"abi_vectorcall\", \"1.7.0\", None, Active)\n+    (\"abi_vectorcall\", \"1.7.0\", None, Active),\n+\n+    // a...b and ...b\n+    (\"inclusive_range_syntax\", \"1.7.0\", Some(28237), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -549,6 +552,7 @@ pub struct Features {\n     pub allow_placement_in: bool,\n     pub allow_box: bool,\n     pub allow_pushpop_unsafe: bool,\n+    pub allow_inclusive_range: bool,\n     pub simd_ffi: bool,\n     pub unmarked_api: bool,\n     /// spans of #![feature] attrs for stable language features. for error reporting\n@@ -583,6 +587,7 @@ impl Features {\n             allow_placement_in: false,\n             allow_box: false,\n             allow_pushpop_unsafe: false,\n+            allow_inclusive_range: false,\n             simd_ffi: false,\n             unmarked_api: false,\n             declared_stable_lang_features: Vec::new(),\n@@ -991,6 +996,11 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 self.gate_feature(\"type_ascription\", e.span,\n                                   \"type ascription is experimental\");\n             }\n+            ast::ExprKind::Range(_, _, ast::RangeLimits::Closed) => {\n+                self.gate_feature(\"inclusive_range_syntax\",\n+                                  e.span,\n+                                  \"inclusive range syntax is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -1177,6 +1187,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         allow_placement_in: cx.has_feature(\"placement_in_syntax\"),\n         allow_box: cx.has_feature(\"box_syntax\"),\n         allow_pushpop_unsafe: cx.has_feature(\"pushpop_unsafe\"),\n+        allow_inclusive_range: cx.has_feature(\"inclusive_range_syntax\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n         unmarked_api: cx.has_feature(\"unmarked_api\"),\n         declared_stable_lang_features: accepted_features,"}, {"sha": "591c1295d66412746f56666c518b54af33b89441", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1273,9 +1273,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Index(el, er) => {\n                 ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprKind::Range(e1, e2) => {\n+            ExprKind::Range(e1, e2, lim) => {\n                 ExprKind::Range(e1.map(|x| folder.fold_expr(x)),\n-                          e2.map(|x| folder.fold_expr(x)))\n+                                e2.map(|x| folder.fold_expr(x)),\n+                                lim)\n             }\n             ExprKind::Path(qself, path) => {\n                 let qself = qself.map(|QSelf { ty, position }| {"}, {"sha": "d9714cc1e25e0630ee71c51253f8063e8ca94e41", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -20,7 +20,7 @@ use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n use ast::{Decl, DeclKind};\n use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n-use ast::{Expr, ExprKind};\n+use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::{Ident, ImplItem, Item, ItemKind};\n@@ -2059,9 +2059,10 @@ impl<'a> Parser<'a> {\n \n     pub fn mk_range(&mut self,\n                     start: Option<P<Expr>>,\n-                    end: Option<P<Expr>>)\n+                    end: Option<P<Expr>>,\n+                    limits: RangeLimits)\n                     -> ast::ExprKind {\n-        ExprKind::Range(start, end)\n+        ExprKind::Range(start, end, limits)\n     }\n \n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n@@ -2899,7 +2900,7 @@ impl<'a> Parser<'a> {\n                 LhsExpr::AttributesParsed(attrs) => Some(attrs),\n                 _ => None,\n             };\n-            if self.token == token::DotDot {\n+            if self.token == token::DotDot || self.token == token::DotDotDot {\n                 return self.parse_prefix_range_expr(attrs);\n             } else {\n                 try!(self.parse_prefix_expr(attrs))\n@@ -2945,32 +2946,32 @@ impl<'a> Parser<'a> {\n                                    ExprKind::Type(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n-                    // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n-                    // it to the Fixity::None code.\n-                    //\n-                    // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n-                    // handled with `parse_prefix_range_expr` call above.\n-                    let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                        let rhs = self.parse_assoc_expr_with(op.precedence() + 1,\n-                                                             LhsExpr::NotYetParsed);\n-                        match rhs {\n-                            Ok(e) => Some(e),\n-                            Err(mut e) => {\n-                                e.cancel();\n-                                None\n-                            }\n+                // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n+                // it to the Fixity::None code.\n+                //\n+                // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n+                // handled with `parse_prefix_range_expr` call above.\n+                let rhs = if self.is_at_start_of_range_notation_rhs() {\n+                    let rhs = self.parse_assoc_expr_with(op.precedence() + 1,\n+                                                         LhsExpr::NotYetParsed);\n+                    match rhs {\n+                        Ok(e) => Some(e),\n+                        Err(mut e) => {\n+                            e.cancel();\n+                            None\n                         }\n-                    } else {\n-                        None\n-                    };\n-                    let (lhs_span, rhs_span) = (lhs_span, if let Some(ref x) = rhs {\n-                        x.span\n-                    } else {\n-                        cur_op_span\n-                    });\n-                    let r = self.mk_range(Some(lhs), rhs);\n-                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n-                    break\n+                    }\n+                } else {\n+                    None\n+                };\n+                let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                    x.span\n+                } else {\n+                    cur_op_span\n+                });\n+                let r = self.mk_range(Some(lhs), rhs, RangeLimits::HalfOpen);\n+                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n+                break\n             }\n \n             let rhs = try!(match op.fixity() {\n@@ -2986,8 +2987,8 @@ impl<'a> Parser<'a> {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n-                // We currently have no non-associative operators that are not handled above by\n-                // the special cases. The code is here only for future convenience.\n+                // the only operator handled here is `...` (the other non-associative operators are\n+                // special-cased above)\n                 Fixity::None => self.with_res(\n                     restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n                     |this| {\n@@ -3028,6 +3029,11 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }\n+                AssocOp::DotDotDot => {\n+                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let r = self.mk_range(Some(lhs), Some(rhs), RangeLimits::Closed);\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, r, None)\n+                }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot => {\n                     self.bug(\"As, Colon or DotDot branch reached\")\n                 }\n@@ -3059,18 +3065,19 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse prefix-forms of range notation: `..expr` and `..`\n+    /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinAttributes>)\n                                -> PResult<'a, P<Expr>> {\n-        debug_assert!(self.token == token::DotDot);\n+        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n+        let tok = self.token.clone();\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-            // RHS must be parsed with more associativity than DotDot.\n-            let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n+            // RHS must be parsed with more associativity than the dots.\n+            let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n             Some(try!(self.parse_assoc_expr_with(next_prec,\n                                                  LhsExpr::NotYetParsed)\n             .map(|x|{\n@@ -3080,7 +3087,13 @@ impl<'a> Parser<'a> {\n          } else {\n             None\n         };\n-        let r = self.mk_range(None, opt_end);\n+        let r = self.mk_range(None,\n+                              opt_end,\n+                              if tok == token::DotDot {\n+                                  RangeLimits::HalfOpen\n+                              } else {\n+                                  RangeLimits::Closed\n+                              });\n         Ok(self.mk_expr(lo, hi, r, attrs))\n     }\n "}, {"sha": "294cbf358954f32124bdc1eb9c8524d9a8e00809", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -196,7 +196,7 @@ impl Token {\n             BinOp(Or)                   => true, // in lambda syntax\n             OrOr                        => true, // in lambda syntax\n             AndAnd                      => true, // double borrow\n-            DotDot                      => true, // range notation\n+            DotDot | DotDotDot          => true, // range notation\n             ModSep                      => true,\n             Interpolated(NtExpr(..))    => true,\n             Interpolated(NtIdent(..))   => true,"}, {"sha": "55c1af44cab856aa197d8b9bdd75baa2690e3fc5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -2163,11 +2163,15 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::ExprKind::Range(ref start, ref end) => {\n+            ast::ExprKind::Range(ref start, ref end, limits) => {\n                 if let &Some(ref e) = start {\n                     try!(self.print_expr(&e));\n                 }\n-                try!(word(&mut self.s, \"..\"));\n+                if limits == ast::RangeLimits::HalfOpen {\n+                    try!(word(&mut self.s, \"..\"));\n+                } else {\n+                    try!(word(&mut self.s, \"...\"));\n+                }\n                 if let &Some(ref e) = end {\n                     try!(self.print_expr(&e));\n                 }"}, {"sha": "df4eb1c9ed7d8053ac5382f817c502e42d4d608c", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -61,6 +61,8 @@ pub enum AssocOp {\n     As,\n     /// `..` range\n     DotDot,\n+    /// `...` range\n+    DotDotDot,\n     /// `:`\n     Colon,\n }\n@@ -102,6 +104,7 @@ impl AssocOp {\n             Token::AndAnd => Some(LAnd),\n             Token::OrOr => Some(LOr),\n             Token::DotDot => Some(DotDot),\n+            Token::DotDotDot => Some(DotDotDot),\n             Token::Colon => Some(Colon),\n             _ if t.is_keyword(keywords::As) => Some(As),\n             _ => None\n@@ -147,7 +150,7 @@ impl AssocOp {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => 7,\n             LAnd => 6,\n             LOr => 5,\n-            DotDot => 4,\n+            DotDot | DotDotDot => 4,\n             Inplace => 3,\n             Assign | AssignOp(_) => 2,\n         }\n@@ -162,7 +165,7 @@ impl AssocOp {\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n             BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n             LAnd | LOr | Colon => Fixity::Left,\n-            DotDot => Fixity::None\n+            DotDot | DotDotDot => Fixity::None\n         }\n     }\n \n@@ -171,7 +174,8 @@ impl AssocOp {\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n-            ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | Colon => false\n+            ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr |\n+            DotDot | DotDotDot | Colon => false\n         }\n     }\n \n@@ -181,7 +185,7 @@ impl AssocOp {\n             Assign | AssignOp(_) | Inplace => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n             Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd |\n-            LOr | DotDot | Colon => false\n+            LOr | DotDot | DotDotDot | Colon => false\n         }\n     }\n \n@@ -206,7 +210,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Inplace | Assign | AssignOp(_) | As | DotDot | Colon => None\n+            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotDot | Colon => None\n         }\n     }\n }"}, {"sha": "73ad488e55c931d1e6e4a87d695a76cc541a3e0b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -763,7 +763,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprKind::Range(ref start, ref end) => {\n+        ExprKind::Range(ref start, ref end, _) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }"}, {"sha": "e4ab5829f41686042a00313f2ad9b3b5561e13e5", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -13,7 +13,7 @@\n pub fn main() {\n     // Mixed types.\n     let _ = 0u32..10i32;\n-    //~^ ERROR start and end of range have incompatible types\n+    //~^ ERROR mismatched types\n \n     // Bool => does not implement iterator.\n     for i in false..true {}"}, {"sha": "94967693ecf912d65d9c9db1b00b83bf83202d4c", "filename": "src/test/compile-fail/range-2.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-2.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,8 +12,10 @@\n \n pub fn main() {\n     let r = {\n-        &42..&42\n-        //~^ ERROR borrowed value does not live long enough\n-        //~^^ ERROR borrowed value does not live long enough\n+        let a = 42;\n+        let b = 42;\n+        &a..&b\n+        //~^ ERROR `a` does not live long enough\n+        //~^^ ERROR `b` does not live long enough\n     };\n }"}, {"sha": "deac152ec85bcf087d8d92511d1a3afc6fd630d5", "filename": "src/test/compile-fail/range_inclusive_gate.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that #![feature(inclusive_range)] is required.\n+\n+#![feature(inclusive_range_syntax)]\n+// #![feature(inclusive_range)]\n+\n+pub fn main() {\n+    let _: std::ops::RangeInclusive<_> = { use std::intrinsics; 1 } ... { use std::intrinsics; 2 };\n+    //~^ ERROR use of unstable library feature 'inclusive_range'\n+    //~^^ ERROR core_intrinsics\n+    //~^^^ ERROR core_intrinsics\n+    //~^^^^ WARN unused_imports\n+    //~^^^^^ WARN unused_imports\n+}\n+\n+"}, {"sha": "5fd6f1834e02dd3be0dc252f890e8fd01570d724", "filename": "src/test/parse-fail/range_inclusive.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that inclusive ranges with no end point don't parse.\n+\n+#![feature(inclusive_range_syntax, inclusive_range)]\n+\n+pub fn main() {\n+    for _ in 1... {}\n+} //~ ERROR expected one of\n+"}, {"sha": "021b6dd3e260f79e7ea7e728588acc8a63adbaf7", "filename": "src/test/parse-fail/range_inclusive_gate.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that #![feature(inclusive_range_syntax)] is required.\n+\n+// #![feature(inclusive_range_syntax, inclusive_range)]\n+\n+macro_rules! m {\n+    () => { for _ in 1...10 {} } //~ ERROR inclusive range syntax is experimental\n+}\n+\n+#[cfg(nope)]\n+fn f() {}\n+#[cfg(not(nope))]\n+fn f() {\n+    for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+}\n+\n+#[cfg(nope)]\n+macro_rules! n { () => {} }\n+#[cfg(not(nope))]\n+macro_rules! n {\n+    () => { for _ in 1...10 {} } //~ ERROR inclusive range syntax is experimental\n+}\n+\n+macro_rules! o {\n+    () => {{\n+        #[cfg(nope)]\n+        fn g() {}\n+        #[cfg(not(nope))]\n+        fn g() {\n+            for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+        }\n+\n+        g();\n+    }}\n+}\n+\n+#[cfg(nope)]\n+macro_rules! p { () => {} }\n+#[cfg(not(nope))]\n+macro_rules! p {\n+    () => {{\n+        #[cfg(nope)]\n+        fn h() {}\n+        #[cfg(not(nope))]\n+        fn h() {\n+            for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+        }\n+\n+        h();\n+    }}\n+}\n+\n+pub fn main() {\n+    for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in ...10 {} //~ ERROR inclusive range syntax is experimental\n+\n+    f(); // not allowed in cfg'ed functions\n+\n+    m!(); // not allowed in macros\n+    n!(); // not allowed in cfg'ed macros\n+    o!(); // not allowed in macros that output cfgs\n+    p!(); // not allowed in cfg'ed macros that output cfgs\n+}\n+\n+"}, {"sha": "4c249bbe1f73e338b90d88a775e7b9227f205a3d", "filename": "src/test/run-pass/range.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Frun-pass%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Frun-pass%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -44,6 +44,7 @@ pub fn main() {\n     let _ = 0_usize..4+4-3;\n     let _ = 0..foo();\n \n+    let _ = { &42..&100 }; // references to literals are OK\n     let _ = ..42_usize;\n \n     // Test we can use two different types with a common supertype."}, {"sha": "07233a43b88e29308b81c84ad0ecba3ca52e9ee9", "filename": "src/test/run-pass/range_inclusive.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test inclusive range syntax.\n+\n+#![feature(inclusive_range_syntax, inclusive_range, step_by)]\n+\n+use std::ops::{RangeInclusive, RangeToInclusive};\n+\n+fn foo() -> isize { 42 }\n+\n+// Test that range syntax works in return statements\n+fn return_range_to() -> RangeToInclusive<i32> { return ...1; }\n+\n+pub fn main() {\n+    let mut count = 0;\n+    for i in 0_usize...10 {\n+        assert!(i >= 0 && i <= 10);\n+        count += i;\n+    }\n+    assert_eq!(count, 55);\n+\n+    let mut count = 0;\n+    let mut range = 0_usize...10;\n+    for i in range {\n+        assert!(i >= 0 && i <= 10);\n+        count += i;\n+    }\n+    assert_eq!(count, 55);\n+\n+    let mut count = 0;\n+    for i in (0_usize...10).step_by(2) {\n+        assert!(i >= 0 && i <= 10 && i % 2 == 0);\n+        count += i;\n+    }\n+    assert_eq!(count, 30);\n+\n+    let _ = 0_usize...4+4-3;\n+    let _ = 0...foo();\n+\n+    let _ = { &42...&100 }; // references to literals are OK\n+    let _ = ...42_usize;\n+\n+    // Test we can use two different types with a common supertype.\n+    let x = &42;\n+    {\n+        let y = 42;\n+        let _ = x...&y;\n+    }\n+\n+    // test collection indexing\n+    let vec = (0...10).collect::<Vec<_>>();\n+    let slice: &[_] = &*vec;\n+    let string = String::from(\"hello world\");\n+    let stir = \"hello world\";\n+\n+    assert_eq!(&vec[3...6], &[3, 4, 5, 6]);\n+    assert_eq!(&vec[ ...6], &[0, 1, 2, 3, 4, 5, 6]);\n+\n+    assert_eq!(&slice[3...6], &[3, 4, 5, 6]);\n+    assert_eq!(&slice[ ...6], &[0, 1, 2, 3, 4, 5, 6]);\n+\n+    assert_eq!(&string[3...6], \"lo w\");\n+    assert_eq!(&string[ ...6], \"hello w\");\n+\n+    assert_eq!(&stir[3...6], \"lo w\");\n+    assert_eq!(&stir[ ...6], \"hello w\");\n+\n+    // test the size hints and emptying\n+    let mut long = 0...255u8;\n+    let mut short = 42...42;\n+    assert_eq!(long.size_hint(), (256, Some(256)));\n+    assert_eq!(short.size_hint(), (1, Some(1)));\n+    long.next();\n+    short.next();\n+    assert_eq!(long.size_hint(), (255, Some(255)));\n+    assert_eq!(short.size_hint(), (0, Some(0)));\n+    assert_eq!(short, RangeInclusive::Empty { at: 42 });\n+\n+    assert_eq!(long.len(), 255);\n+    assert_eq!(short.len(), 0);\n+\n+    // test iterating backwards\n+    assert_eq!(long.next_back(), Some(255));\n+    assert_eq!(long.next_back(), Some(254));\n+    assert_eq!(long.next_back(), Some(253));\n+    assert_eq!(long.next(), Some(1));\n+    assert_eq!(long.next(), Some(2));\n+    assert_eq!(long.next_back(), Some(252));\n+    for i in 3...251 {\n+        assert_eq!(long.next(), Some(i));\n+    }\n+    assert_eq!(long, RangeInclusive::Empty { at: 251 });\n+\n+    // check underflow\n+    let mut narrow = 1...0;\n+    assert_eq!(narrow.next_back(), None);\n+    assert_eq!(narrow, RangeInclusive::Empty { at: 0 });\n+    let mut zero = 0u8...0;\n+    assert_eq!(zero.next_back(), Some(0));\n+    assert_eq!(zero.next_back(), None);\n+    assert_eq!(zero, RangeInclusive::Empty { at: 0 });\n+    let mut high = 255u8...255;\n+    assert_eq!(high.next_back(), Some(255));\n+    assert_eq!(high.next_back(), None);\n+    assert_eq!(high, RangeInclusive::Empty { at: 255 });\n+\n+    // what happens if you have a nonsense range?\n+    let mut nonsense = 10...5;\n+    assert_eq!(nonsense.next(), None);\n+    assert_eq!(nonsense, RangeInclusive::Empty { at: 10 });\n+\n+    // conversion\n+    assert_eq!(0...9, (0..10).into());\n+    assert_eq!(0...0, (0..1).into());\n+    assert_eq!(RangeInclusive::Empty { at: 1 }, (1..0).into());\n+\n+    // output\n+    assert_eq!(format!(\"{:?}\", 0...10), \"0...10\");\n+    assert_eq!(format!(\"{:?}\", ...10), \"...10\");\n+    assert_eq!(format!(\"{:?}\", long), \"[empty range @ 251]\");\n+}"}, {"sha": "5e0ec19d6b3253d69dcb54ec43887fa70f397844", "filename": "src/test/run-pass/range_inclusive_gate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Frun-pass%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484831d29392857d18f420e3fc69180306bf122/src%2Ftest%2Frun-pass%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive_gate.rs?ref=8484831d29392857d18f420e3fc69180306bf122", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you only need the syntax gate if you don't mention the structs.\n+\n+#![feature(inclusive_range_syntax)]\n+\n+fn main() {\n+    let mut count = 0;\n+    for i in 0_usize...10 {\n+        assert!(i >= 0 && i <= 10);\n+        count += i;\n+    }\n+    assert_eq!(count, 55);\n+}\n+"}]}