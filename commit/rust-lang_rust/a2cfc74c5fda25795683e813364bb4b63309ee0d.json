{"sha": "a2cfc74c5fda25795683e813364bb4b63309ee0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyY2ZjNzRjNWZkYTI1Nzk1NjgzZTgxMzM2NGJiNGI2MzMwOWVlMGQ=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-07T20:51:46Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-07T20:51:46Z"}, "message": "Simplify array::IntoIter\n\n- Initialization can use `transmute_copy` to do the bitwise copy.\n- `as_slice` can use `get_unchecked` and `MaybeUninit::slice_get_ref`,\n  and `as_mut_slice` can do similar.\n- `next` and `next_back` can use the corresponding `Range` methods.\n- `Clone` doesn't need any unsafety, and we can dynamically update the\n  new range to get partial drops if `T::clone` panics.", "tree": {"sha": "647d7672a4b91b466659293aee3293d80c12e572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/647d7672a4b91b466659293aee3293d80c12e572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2cfc74c5fda25795683e813364bb4b63309ee0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2cfc74c5fda25795683e813364bb4b63309ee0d", "html_url": "https://github.com/rust-lang/rust/commit/a2cfc74c5fda25795683e813364bb4b63309ee0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2cfc74c5fda25795683e813364bb4b63309ee0d/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d4342347b71313258a46e506ee0a258f365185c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4342347b71313258a46e506ee0a258f365185c", "html_url": "https://github.com/rust-lang/rust/commit/4d4342347b71313258a46e506ee0a258f365185c"}], "stats": {"total": 144, "additions": 55, "deletions": 89}, "files": [{"sha": "919070aadf972123ce3ca83cdc72ac9fbf80e69b", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 55, "deletions": 89, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a2cfc74c5fda25795683e813364bb4b63309ee0d/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cfc74c5fda25795683e813364bb4b63309ee0d/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=a2cfc74c5fda25795683e813364bb4b63309ee0d", "patch": "@@ -56,69 +56,55 @@ impl<T, const N: usize> IntoIter<T, N> {\n \n         // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n         // works with const generics:\n-        //     `mem::transmute::<[T; {N}], [MaybeUninit<T>; {N}]>(array)`\n+        //     `mem::transmute::<[T; N], [MaybeUninit<T>; N]>(array)`\n         //\n-        // Until then, we do it manually here. We first create a bitwise copy\n-        // but cast the pointer so that it is treated as a different type. Then\n-        // we forget `array` so that it is not dropped.\n-        let data = unsafe {\n-            let data = ptr::read(&array as *const [T; N] as *const [MaybeUninit<T>; N]);\n+        // Until then, we can use `mem::transmute_copy` to create a bitwise copy\n+        // as a different type, then forget `array` so that it is not dropped.\n+        unsafe {\n+            let iter = Self { data: mem::transmute_copy(&array), alive: 0..N };\n             mem::forget(array);\n-            data\n-        };\n-\n-        Self { data, alive: 0..N }\n+            iter\n+        }\n     }\n \n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n     fn as_slice(&self) -> &[T] {\n-        let slice = &self.data[self.alive.clone()];\n-        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n-        // the size and alignment of `T`. Furthermore, we know that all\n-        // elements within `alive` are properly initialized.\n-        unsafe { mem::transmute::<&[MaybeUninit<T>], &[T]>(slice) }\n+        // SAFETY: We know that all elements within `alive` are properly initialized.\n+        unsafe {\n+            let slice = self.data.get_unchecked(self.alive.clone());\n+            MaybeUninit::slice_get_ref(slice)\n+        }\n     }\n \n     /// Returns a mutable slice of all elements that have not been yielded yet.\n     fn as_mut_slice(&mut self) -> &mut [T] {\n-        // This transmute is safe, same as in `as_slice` above.\n-        let slice = &mut self.data[self.alive.clone()];\n-        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n-        // the size and alignment of `T`. Furthermore, we know that all\n-        // elements within `alive` are properly initialized.\n-        unsafe { mem::transmute::<&mut [MaybeUninit<T>], &mut [T]>(slice) }\n+        // SAFETY: We know that all elements within `alive` are properly initialized.\n+        unsafe {\n+            let slice = self.data.get_unchecked_mut(self.alive.clone());\n+            MaybeUninit::slice_get_mut(slice)\n+        }\n     }\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> Iterator for IntoIter<T, N> {\n     type Item = T;\n     fn next(&mut self) -> Option<Self::Item> {\n-        if self.alive.start == self.alive.end {\n-            return None;\n-        }\n-\n-        // Bump start index.\n+        // Get the next index from the front.\n         //\n-        // From the check above we know that `alive.start != alive.end`.\n-        // Combine this with the invariant `alive.start <= alive.end`, we know\n-        // that `alive.start < alive.end`. Increasing `alive.start` by 1\n-        // maintains the invariant regarding `alive`. However, due to this\n-        // change, for a short time, the alive zone is not `data[alive]`\n-        // anymore, but `data[idx..alive.end]`.\n-        let idx = self.alive.start;\n-        self.alive.start += 1;\n-\n-        // Read the element from the array.\n-        // SAFETY: This is safe: `idx` is an index\n-        // into the \"alive\" region of the array. Reading this element means\n-        // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n-        // `idx` was the start of the alive-zone, the alive zone is now\n-        // `data[alive]` again, restoring all invariants.\n-        let out = unsafe { self.data.get_unchecked(idx).read() };\n-\n-        Some(out)\n+        // Increasing `alive.start` by 1 maintains the invariant regarding\n+        // `alive`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[idx..alive.end]`.\n+        self.alive.next().map(|idx| {\n+            // Read the element from the array.\n+            // SAFETY: `idx` is an index into the former \"alive\" region of the\n+            // array. Reading this element means that `data[idx]` is regarded as\n+            // dead now (i.e. do not touch). As `idx` was the start of the\n+            // alive-zone, the alive zone is now `data[alive]` again, restoring\n+            // all invariants.\n+            unsafe { self.data.get_unchecked(idx).read() }\n+        })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -138,33 +124,20 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.alive.start == self.alive.end {\n-            return None;\n-        }\n-\n-        // Decrease end index.\n+        // Get the next index from the back.\n         //\n-        // From the check above we know that `alive.start != alive.end`.\n-        // Combine this with the invariant `alive.start <= alive.end`, we know\n-        // that `alive.start < alive.end`. As `alive.start` cannot be negative,\n-        // `alive.end` is at least 1, meaning that we can safely decrement it\n-        // by one. This also maintains the invariant `alive.start <=\n-        // alive.end`. However, due to this change, for a short time, the alive\n-        // zone is not `data[alive]` anymore, but `data[alive.start..alive.end\n-        // + 1]`.\n-        self.alive.end -= 1;\n-\n-        // Read the element from the array.\n-        // SAFETY: This is safe: `alive.end` is an\n-        // index into the \"alive\" region of the array. Compare the previous\n-        // comment that states that the alive region is\n-        // `data[alive.start..alive.end + 1]`. Reading this element means that\n-        // `data[alive.end]` is regarded as dead now (i.e. do not touch). As\n-        // `alive.end` was the end of the alive-zone, the alive zone is now\n-        // `data[alive]` again, restoring all invariants.\n-        let out = unsafe { self.data.get_unchecked(self.alive.end).read() };\n-\n-        Some(out)\n+        // Decreasing `alive.end` by 1 maintains the invariant regarding\n+        // `alive`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[alive.start..=idx]`.\n+        self.alive.next_back().map(|idx| {\n+            // Read the element from the array.\n+            // SAFETY: `idx` is an index into the former \"alive\" region of the\n+            // array. Reading this element means that `data[idx]` is regarded as\n+            // dead now (i.e. do not touch). As `idx` was the end of the\n+            // alive-zone, the alive zone is now `data[alive]` again, restoring\n+            // all invariants.\n+            unsafe { self.data.get_unchecked(idx).read() }\n+        })\n     }\n }\n \n@@ -203,26 +176,19 @@ unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> {}\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T: Clone, const N: usize> Clone for IntoIter<T, N> {\n     fn clone(&self) -> Self {\n-        // SAFETY: each point of unsafety is documented inside the unsafe block\n-        unsafe {\n-            // This creates a new uninitialized array. Note that the `assume_init`\n-            // refers to the array, not the individual elements. And it is Ok if\n-            // the array is in an uninitialized state as all elements may be\n-            // uninitialized (all bit patterns are valid). Compare the\n-            // `MaybeUninit` docs for more information.\n-            let mut new_data: [MaybeUninit<T>; N] = MaybeUninit::uninit().assume_init();\n-\n-            // Clone all alive elements.\n-            for idx in self.alive.clone() {\n-                // The element at `idx` in the old array is alive, so we can\n-                // safely call `get_ref()`. We then clone it, and write the\n-                // clone into the new array.\n-                let clone = self.data.get_unchecked(idx).get_ref().clone();\n-                new_data.get_unchecked_mut(idx).write(clone);\n-            }\n-\n-            Self { data: new_data, alive: self.alive.clone() }\n+        // Note, we don't really need to match the exact same alive range, so\n+        // we can just clone into offset 0 regardless of where `self` is.\n+        let mut new = Self { data: MaybeUninit::uninit_array(), alive: 0..0 };\n+\n+        // Clone all alive elements.\n+        for (src, dst) in self.as_slice().iter().zip(&mut new.data) {\n+            // Write a clone into the new array, then update its alive range.\n+            // If cloning panics, we'll correctly drop the previous items.\n+            dst.write(src.clone());\n+            new.alive.end += 1;\n         }\n+\n+        new\n     }\n }\n "}]}