{"sha": "e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MmZjYjk1OGNkODlkMTFkYmU4ZjQ5M2NmYWMwYTFmY2E0YjFiYjE=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-19T20:03:52Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-20T02:09:32Z"}, "message": "Implement unimplemented const binops", "tree": {"sha": "8cb4abcab9623b2c419744888e8e6153ee55adc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cb4abcab9623b2c419744888e8e6153ee55adc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "html_url": "https://github.com/rust-lang/rust/commit/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7396f7f004667610455557e7872330b59fafc79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7396f7f004667610455557e7872330b59fafc79a", "html_url": "https://github.com/rust-lang/rust/commit/7396f7f004667610455557e7872330b59fafc79a"}], "stats": {"total": 177, "additions": 165, "deletions": 12}, "files": [{"sha": "cdc128c6eeb6119e788f936a3438005e8394ec97", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "patch": "@@ -220,6 +220,7 @@ pub mod llvm {\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n     use super::{ValueRef};\n+    use super::{IntPredicate, RealPredicate};\n \n     use core::libc::{c_char, c_int, c_longlong, c_uint, c_ulonglong};\n \n@@ -451,6 +452,10 @@ pub mod llvm {\n         /* all zeroes */\n         #[fast_ffi]\n         pub unsafe fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n+        pub unsafe fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n+        pub unsafe fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n         /* only for int/vector */\n         #[fast_ffi]\n         pub unsafe fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;"}, {"sha": "6df523976f2b0a08237e28b658c07010b9ba3356", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n use back::abi;\n-use lib::llvm::{llvm, SetLinkage, PrivateLinkage,\n-                ValueRef, TypeRef, Bool, True, False};\n+use lib::llvm::{llvm, SetLinkage, PrivateLinkage, ValueRef, TypeRef, Bool, True, False};\n+use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n+    RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n+\n use metadata::csearch;\n use middle::const_eval;\n use middle::trans::adt;\n@@ -280,8 +282,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 else if signed { llvm::LLVMConstSRem(te1, te2) }\n                 else           { llvm::LLVMConstURem(te1, te2) }\n               }\n-              ast::and    |\n-              ast::or     => cx.sess.span_unimpl(e.span, \"binop logic\"),\n+              ast::and    => llvm::LLVMConstAnd(te1, te2),\n+              ast::or     => llvm::LLVMConstOr(te1, te2),\n               ast::bitxor => llvm::LLVMConstXor(te1, te2),\n               ast::bitand => llvm::LLVMConstAnd(te1, te2),\n               ast::bitor  => llvm::LLVMConstOr(te1, te2),\n@@ -290,14 +292,44 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n-              ast::eq     |\n-              ast::lt     |\n-              ast::le     |\n-              ast::ne     |\n-              ast::ge     |\n-              ast::gt     => cx.sess.span_unimpl(e.span, \"binop comparator\")\n-            }\n-          }\n+              ast::eq     => {\n+                  if is_float { llvm::LLVMConstFCmp(RealOEQ, te1, te2) }\n+                  else        { llvm::LLVMConstICmp(IntEQ, te1, te2)   }\n+              },\n+              ast::lt     => {\n+                  if is_float { llvm::LLVMConstFCmp(RealOLT, te1, te2) }\n+                  else        {\n+                      if signed { llvm::LLVMConstICmp(IntSLT, te1, te2) }\n+                      else      { llvm::LLVMConstICmp(IntULT, te1, te2) }\n+                  }\n+              },\n+              ast::le     => {\n+                  if is_float { llvm::LLVMConstFCmp(RealOLE, te1, te2) }\n+                  else        {\n+                      if signed { llvm::LLVMConstICmp(IntSLE, te1, te2) }\n+                      else      { llvm::LLVMConstICmp(IntULE, te1, te2) }\n+                  }\n+              },\n+              ast::ne     => {\n+                  if is_float { llvm::LLVMConstFCmp(RealONE, te1, te2) }\n+                  else        { llvm::LLVMConstICmp(IntNE, te1, te2) }\n+              },\n+              ast::ge     => {\n+                  if is_float { llvm::LLVMConstFCmp(RealOGE, te1, te2) }\n+                  else        {\n+                      if signed { llvm::LLVMConstICmp(IntSGE, te1, te2) }\n+                      else      { llvm::LLVMConstICmp(IntUGE, te1, te2) }\n+                  }\n+              },\n+              ast::gt     => {\n+                  if is_float { llvm::LLVMConstFCmp(RealOGT, te1, te2) }\n+                  else        {\n+                      if signed { llvm::LLVMConstICmp(IntSGT, te1, te2) }\n+                      else      { llvm::LLVMConstICmp(IntUGT, te1, te2) }\n+                  }\n+              },\n+            };\n+          },\n           ast::expr_unary(u, e) => {\n             let te = const_expr(cx, e);\n             let ty = ty::expr_ty(cx.tcx, e);"}, {"sha": "507f68dc3a1468c2c38ae7377f3d4f6084bd88e8", "filename": "src/test/run-pass/const-binops.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=e42fcb958cd89d11dbe8f493cfac0a1fca4b1bb1", "patch": "@@ -0,0 +1,116 @@\n+static a: int = -4 + 3;\n+static a2: uint = 3 + 3;\n+static b: float = 3.0 + 2.7;\n+\n+static c: int = 3 - 4;\n+static d: uint = 3 - 3;\n+static e: float = 3.0 - 2.7;\n+\n+static e2: int = -3 * 3;\n+static f: uint = 3 * 3;\n+static g: float = 3.3 * 3.3;\n+\n+static h: int = 3 / -1;\n+static i: uint = 3 / 3;\n+static j: float = 3.3 / 3.3;\n+\n+static n: bool = true && false;\n+\n+static o: bool = true || false;\n+\n+static p: int = 3 & 1;\n+static q: uint = 1 & 3;\n+\n+static r: int = 3 | 1;\n+static s: uint = 1 | 3;\n+\n+static t: int = 3 ^ 1;\n+static u: uint = 1 ^ 3;\n+\n+static v: int = 1 << 3;\n+\n+// NOTE: better shr coverage\n+static w: int = 1024 >> 4;\n+static x: uint = 1024 >> 4;\n+\n+static y: bool = 1 == 1;\n+static z: bool = 1.0 == 1.0;\n+\n+static aa: bool = 1 <= 2;\n+static ab: bool = -1 <= 2;\n+static ac: bool = 1.0 <= 2;\n+\n+static ad: bool = 1 < 2;\n+static ae: bool = -1 < 2;\n+static af: bool = 1.0 < 2;\n+\n+static ag: bool = 1 != 2;\n+static ah: bool = -1 != 2;\n+static ai: bool = 1.0 != 2;\n+\n+static aj: bool = 2 >= 1;\n+static ak: bool = 2 >= -2;\n+static al: bool = 1.0 >= -2;\n+\n+static am: bool = 2 > 1;\n+static an: bool = 2 > -2;\n+static ao: bool = 1.0 > -2;\n+\n+fn main() {\n+    assert_eq!(a, -1);\n+    assert_eq!(a2, 6);\n+    assert_approx_eq!(b, 5.7);\n+\n+    assert_eq!(c, -1);\n+    assert_eq!(d, 0);\n+    assert_approx_eq!(e, -0.3);\n+\n+    assert_eq!(e2, -9);\n+    assert_eq!(f, 9);\n+    assert_approx_eq!(g, 10.89);\n+\n+    assert_eq!(h, -3);\n+    assert_eq!(i, 1);\n+    assert_approx_eq!(j, 1.0);\n+\n+    assert_eq!(n, false);\n+\n+    assert_eq!(o, true);\n+\n+    assert_eq!(p, 1);\n+    assert_eq!(q, 1);\n+\n+    assert_eq!(r, 3);\n+    assert_eq!(s, 3);\n+\n+    assert_eq!(t, 2);\n+    assert_eq!(u, 2);\n+\n+    assert_eq!(v, 8);\n+\n+    assert_eq!(w, 64);\n+    assert_eq!(x, 64);\n+\n+    assert_eq!(y, true);\n+    assert_eq!(z, true);\n+\n+    assert_eq!(aa, true);\n+    assert_eq!(ab, true);\n+    assert_eq!(ac, true);\n+\n+    assert_eq!(ad, true);\n+    assert_eq!(ae, true);\n+    assert_eq!(af, true);\n+\n+    assert_eq!(ag, true);\n+    assert_eq!(ah, true);\n+    assert_eq!(ai, true);\n+\n+    assert_eq!(aj, true);\n+    assert_eq!(ak, true);\n+    assert_eq!(al, true);\n+\n+    assert_eq!(am, true);\n+    assert_eq!(an, true);\n+    assert_eq!(ao, true);\n+}"}]}