{"sha": "1028120c40018763de11a81d0bf9bc981622d0ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjgxMjBjNDAwMTg3NjNkZTExYTgxZDBiZjliYzk4MTYyMmQwYWU=", "commit": {"author": {"name": "Austin Bonander", "email": "austin.bonander@gmail.com", "date": "2014-08-21T09:25:24Z"}, "committer": {"name": "Austin Bonander", "email": "austin.bonander@gmail.com", "date": "2014-08-21T18:04:03Z"}, "message": "Parameterize indent in PrettyEncoder", "tree": {"sha": "ed0144226f65a5d2826495fb41495d413cb71a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed0144226f65a5d2826495fb41495d413cb71a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1028120c40018763de11a81d0bf9bc981622d0ae", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1028120c40018763de11a81d0bf9bc981622d0ae", "html_url": "https://github.com/rust-lang/rust/commit/1028120c40018763de11a81d0bf9bc981622d0ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1028120c40018763de11a81d0bf9bc981622d0ae/comments", "author": {"login": "abonander", "id": 3198595, "node_id": "MDQ6VXNlcjMxOTg1OTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3198595?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonander", "html_url": "https://github.com/abonander", "followers_url": "https://api.github.com/users/abonander/followers", "following_url": "https://api.github.com/users/abonander/following{/other_user}", "gists_url": "https://api.github.com/users/abonander/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonander/subscriptions", "organizations_url": "https://api.github.com/users/abonander/orgs", "repos_url": "https://api.github.com/users/abonander/repos", "events_url": "https://api.github.com/users/abonander/events{/privacy}", "received_events_url": "https://api.github.com/users/abonander/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abonander", "id": 3198595, "node_id": "MDQ6VXNlcjMxOTg1OTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3198595?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonander", "html_url": "https://github.com/abonander", "followers_url": "https://api.github.com/users/abonander/followers", "following_url": "https://api.github.com/users/abonander/following{/other_user}", "gists_url": "https://api.github.com/users/abonander/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonander/subscriptions", "organizations_url": "https://api.github.com/users/abonander/orgs", "repos_url": "https://api.github.com/users/abonander/repos", "events_url": "https://api.github.com/users/abonander/events{/privacy}", "received_events_url": "https://api.github.com/users/abonander/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20b3313c8c14a8f7ee29215734b26f79b4f2b2a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/20b3313c8c14a8f7ee29215734b26f79b4f2b2a4", "html_url": "https://github.com/rust-lang/rust/commit/20b3313c8c14a8f7ee29215734b26f79b4f2b2a4"}], "stats": {"total": 103, "additions": 85, "deletions": 18}, "files": [{"sha": "cfc915c7d0ae0849c1f56ba203a741d2de7296d0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 85, "deletions": 18, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1028120c40018763de11a81d0bf9bc981622d0ae/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1028120c40018763de11a81d0bf9bc981622d0ae/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1028120c40018763de11a81d0bf9bc981622d0ae", "patch": "@@ -595,13 +595,23 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n /// compact data\n pub struct PrettyEncoder<'a> {\n     writer: &'a mut io::Writer,\n+    curr_indent: uint,\n     indent: uint,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n     pub fn new<'a>(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder { writer: writer, indent: 0 }\n+        PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n+    }\n+\n+    /// Set the number of spaces to indent for each level.\n+    /// This is safe to set during encoding.\n+    pub fn set_indent<'a>(&mut self, indent: uint) {\n+        // self.indent very well could be 0 so we need to use checked division.\n+        let level = self.curr_indent.checked_div(&self.indent).unwrap_or(0);\n+        self.indent = indent;\n+        self.curr_indent = level * self.indent;\n     }\n }\n \n@@ -656,15 +666,15 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(write!(self.writer, \"[\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             try!(escape_str(self.writer, name));\n             try!(write!(self.writer, \",\\n\"));\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"]\")\n         }\n     }\n@@ -675,7 +685,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         f(self)\n     }\n \n@@ -703,11 +713,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.writer, \"{{}}\")\n         } else {\n             try!(write!(self.writer, \"{{\"));\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"}}\")\n         }\n     }\n@@ -721,7 +731,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         try!(escape_str(self.writer, name));\n         try!(write!(self.writer, \": \"));\n         f(self)\n@@ -765,11 +775,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.writer, \"[]\")\n         } else {\n             try!(write!(self.writer, \"[\"));\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"]\")\n         }\n     }\n@@ -782,7 +792,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         f(self)\n     }\n \n@@ -793,11 +803,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.writer, \"{{}}\")\n         } else {\n             try!(write!(self.writer, \"{{\"));\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"}}\")\n         }\n     }\n@@ -810,7 +820,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n@@ -3197,6 +3207,63 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_prettyencoder_indent_level_param() {\n+        use std::str::from_utf8;\n+        use std::io::MemWriter;\n+        use std::collections::TreeMap;\n+\n+        let mut tree = TreeMap::new();\n+\n+        tree.insert(\"hello\".into_string(), String(\"guten tag\".into_string()));\n+        tree.insert(\"goodbye\".into_string(), String(\"sayonara\".into_string()));\n+\n+        let json = List(\n+            // The following layout below should look a lot like\n+            // the pretty-printed JSON (indent * x)\n+            vec!\n+            ( // 0x\n+                String(\"greetings\".into_string()), // 1x\n+                Object(tree), // 1x + 2x + 2x + 1x\n+            ) // 0x\n+            // End JSON list (7 lines)\n+        );\n+\n+        // Helper function for counting indents\n+        fn indents(source: &str) -> uint {\n+            let trimmed = source.trim_left_chars(' ');\n+            source.len() - trimmed.len()\n+        }\n+\n+        // Test up to 4 spaces of indents (more?)\n+        for i in range(0, 4u) {\n+            let mut writer = MemWriter::new();\n+            {\n+                let ref mut encoder = PrettyEncoder::new(&mut writer);\n+                encoder.set_indent(i);\n+                json.encode(encoder).unwrap();\n+            }\n+\n+            let bytes = writer.unwrap();\n+            let printed = from_utf8(bytes.as_slice()).unwrap();\n+\n+            // Check for indents at each line\n+            let lines: Vec<&str> = printed.lines().collect();\n+            assert_eq!(lines.len(), 7); // JSON should be 7 lines\n+\n+            assert_eq!(indents(lines[0]), 0 * i); // [\n+            assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n+            assert_eq!(indents(lines[2]), 1 * i); //   {\n+            assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n+            assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n+            assert_eq!(indents(lines[5]), 1 * i); //   },\n+            assert_eq!(indents(lines[6]), 0 * i); // ]\n+\n+            // Finally, test that the pretty-printed JSON is valid\n+            from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n+        }\n+    }\n+\n     #[test]\n     fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n         use std::collections::HashMap;"}]}