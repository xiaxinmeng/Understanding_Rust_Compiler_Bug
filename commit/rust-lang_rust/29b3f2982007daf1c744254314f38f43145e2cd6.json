{"sha": "29b3f2982007daf1c744254314f38f43145e2cd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YjNmMjk4MjAwN2RhZjFjNzQ0MjU0MzE0ZjM4ZjQzMTQ1ZTJjZDY=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-06T22:06:32Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-08T22:14:46Z"}, "message": "test harness cleanup", "tree": {"sha": "341ace2f2c792cbdf383be85da1cfcd82268d627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/341ace2f2c792cbdf383be85da1cfcd82268d627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29b3f2982007daf1c744254314f38f43145e2cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29b3f2982007daf1c744254314f38f43145e2cd6", "html_url": "https://github.com/rust-lang/rust/commit/29b3f2982007daf1c744254314f38f43145e2cd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29b3f2982007daf1c744254314f38f43145e2cd6/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f94f823b0e6a89b4a210cb077f94919bfc7a118", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f94f823b0e6a89b4a210cb077f94919bfc7a118", "html_url": "https://github.com/rust-lang/rust/commit/9f94f823b0e6a89b4a210cb077f94919bfc7a118"}], "stats": {"total": 47, "additions": 20, "deletions": 27}, "files": [{"sha": "764e60364e1223e49776512be42a4eeb92beb577", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/29b3f2982007daf1c744254314f38f43145e2cd6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b3f2982007daf1c744254314f38f43145e2cd6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=29b3f2982007daf1c744254314f38f43145e2cd6", "patch": "@@ -1454,27 +1454,36 @@ mod test {\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n+                let print_hygiene_debug_info = || {\n+                    // good lord, you can't make a path with 0 segments, can you?\n+                    let final_varref_ident = match varref.segments.last() {\n+                        Some(pathsegment) => pathsegment.identifier,\n+                        None => fail!(\"varref with 0 path segments?\")\n+                    };\n+                    let varref_name = mtwt::resolve(final_varref_ident);\n+                    let varref_idents : Vec<ast::Ident>\n+                        = varref.segments.iter().map(|s| s.identifier)\n+                        .collect();\n+                    println!(\"varref #{}: {}, resolves to {}\",idx, varref_idents, varref_name);\n+                    let string = token::get_ident(final_varref_ident);\n+                    println!(\"varref's first segment's string: \\\"{}\\\"\", string.get());\n+                    println!(\"binding #{}: {}, resolves to {}\",\n+                             binding_idx, *bindings.get(binding_idx), binding_name);\n+                    mtwt::with_sctable(|x| mtwt::display_sctable(x));\n+                };\n                 if shouldmatch.contains(&idx) {\n                     // it should be a path of length 1, and it should\n                     // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt::resolve(varref.segments\n-                                                          .get(0)\n-                                                          .identifier);\n+                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n                     let varref_marks = mtwt::marksof(varref.segments\n                                                            .get(0)\n                                                            .identifier\n                                                            .ctxt,\n                                                      invalid_name);\n                     if !(varref_name==binding_name) {\n-                        let varref_idents : Vec<ast::Ident>\n-                            = varref.segments.iter().map(|s|\n-                                                         s.identifier)\n-                            .collect();\n                         println!(\"uh oh, should match but doesn't:\");\n-                        println!(\"varref #{}: {}\",idx, varref_idents);\n-                        println!(\"binding #{}: {}\", binding_idx, *bindings.get(binding_idx));\n-                        mtwt::with_sctable(|x| mtwt::display_sctable(x));\n+                        print_hygiene_debug_info();\n                     }\n                     assert_eq!(varref_name,binding_name);\n                     if bound_ident_check {\n@@ -1488,27 +1497,11 @@ mod test {\n                         && (varref_name == binding_name);\n                     // temp debugging:\n                     if fail {\n-                        let varref_idents : Vec<ast::Ident>\n-                            = varref.segments.iter().map(|s|\n-                                                         s.identifier)\n-                            .collect();\n                         println!(\"failure on test {}\",test_idx);\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        println!(\"varref #{}: {}, resolves to {}\",idx, varref_idents,\n-                                 varref_name);\n-                        // good lord, you can't make a path with 0 segments, can you?\n-                        let string = token::get_ident(varref.segments\n-                                                            .get(0)\n-                                                            .identifier);\n-                        println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n-                                 varref.segments.get(0).identifier.name,\n-                                 string.get());\n-                        println!(\"binding #{}: {}, resolves to {}\",\n-                                 binding_idx, *bindings.get(binding_idx),\n-                                 binding_name);\n-                        mtwt::with_sctable(|x| mtwt::display_sctable(x));\n+                        print_hygiene_debug_info();\n                     }\n                     assert!(!fail);\n                 }"}]}