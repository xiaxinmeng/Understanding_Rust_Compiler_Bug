{"sha": "030c666cc1bc4830eac2f845b114f7c514f6e201", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMGM2NjZjYzFiYzQ4MzBlYWMyZjg0NWIxMTRmN2M1MTRmNmUyMDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-30T05:15:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-17T04:49:16Z"}, "message": "Re-implement lint with less emphasis on item ids\n\nThis way it's much easier to add lints throughout compilation correctly, and\nfunctions on impls can alter the way lints are emitted.", "tree": {"sha": "77c046779e1dbd535bd68a12106d9071415cd776", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77c046779e1dbd535bd68a12106d9071415cd776"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/030c666cc1bc4830eac2f845b114f7c514f6e201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/030c666cc1bc4830eac2f845b114f7c514f6e201", "html_url": "https://github.com/rust-lang/rust/commit/030c666cc1bc4830eac2f845b114f7c514f6e201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/030c666cc1bc4830eac2f845b114f7c514f6e201/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77c98f081509733af957af6ed7b0b277e5f57871", "url": "https://api.github.com/repos/rust-lang/rust/commits/77c98f081509733af957af6ed7b0b277e5f57871", "html_url": "https://github.com/rust-lang/rust/commit/77c98f081509733af957af6ed7b0b277e5f57871"}], "stats": {"total": 1102, "additions": 502, "deletions": 600}, "files": [{"sha": "d9912813cf930317ed4af384b2c27a4400892fbc", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -17,7 +17,6 @@ use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n use old_iter::BaseIter;\n-use hash::Hash;\n use old_iter;\n use option::{None, Option, Some};\n use rand::RngUtil;"}, {"sha": "92d3a451559f36dd9255397bbb647d651f5a45d0", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -171,7 +171,6 @@ pub mod write {\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n     use back::link::{output_type_object};\n-    use back::link::output_type;\n     use driver::session::Session;\n     use driver::session;\n     use lib::llvm::llvm;"}, {"sha": "99ffa8cc94aa345c05aa41667da7d91d9fef46b9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -22,6 +22,7 @@ use middle;\n use util::common::time;\n use util::ppaux;\n \n+use core::hashmap::HashMap;\n use core::int;\n use core::io;\n use core::os;\n@@ -200,9 +201,6 @@ pub fn compile_rest(sess: Session,\n     crate = time(time_passes, ~\"core injection\", ||\n         front::core_inject::maybe_inject_libcore_ref(sess, crate));\n \n-    time(time_passes, ~\"building lint settings table\", ||\n-        lint::build_settings_crate(sess, crate));\n-\n     let ast_map = time(time_passes, ~\"ast indexing\", ||\n             syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n@@ -709,7 +707,6 @@ pub fn build_session_(sopts: @session::options,\n         &sopts.maybe_sysroot,\n         sopts.target_triple,\n         /*bad*/copy sopts.addl_lib_search_paths);\n-    let lint_settings = lint::mk_lint_settings();\n     @Session_ {\n         targ_cfg: target_cfg,\n         opts: sopts,\n@@ -723,7 +720,7 @@ pub fn build_session_(sopts: @session::options,\n         filesearch: filesearch,\n         building_library: @mut false,\n         working_dir: os::getcwd(),\n-        lint_settings: lint_settings\n+        lints: @mut HashMap::new(),\n     }\n }\n "}, {"sha": "790c24369dfd3f84f6da14dfa6da1a38856cf5e3", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -26,6 +26,8 @@ use syntax::{ast, codemap};\n use syntax::abi;\n use syntax;\n \n+use core::hashmap::HashMap;\n+\n #[deriving(Eq)]\n pub enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n \n@@ -170,7 +172,7 @@ pub struct Session_ {\n     filesearch: @filesearch::FileSearch,\n     building_library: @mut bool,\n     working_dir: Path,\n-    lint_settings: lint::LintSettings\n+    lints: @mut HashMap<ast::node_id, ~[(lint::lint, codemap::span, ~str)]>,\n }\n \n pub type Session = @Session_;\n@@ -230,15 +232,12 @@ pub impl Session_ {\n           }\n         }\n     }\n-    fn span_lint(@self, lint_mode: lint::lint,\n-                 expr_id: ast::node_id,\n-                 item_id: ast::node_id,\n-                 span: span,\n-                 msg: &str) {\n-        let level = lint::get_lint_settings_level(\n-            self.lint_settings, lint_mode, expr_id, item_id);\n-        let msg = fmt!(\"%s [-W %s]\", msg, lint::get_lint_name(lint_mode));\n-        self.span_lint_level(level, span, msg);\n+    fn add_lint(@self, lint: lint::lint, id: ast::node_id, sp: span, msg: ~str) {\n+        match self.lints.find_mut(&id) {\n+            Some(arr) => { arr.push((lint, sp, msg)); return; }\n+            None => {}\n+        }\n+        self.lints.insert(id, ~[(lint, sp, msg)]);\n     }\n     fn next_node_id(@self) -> ast::node_id {\n         return syntax::parse::next_node_id(self.parse_sess);"}, {"sha": "5c8ea75440c7a218a7dd18a4e52a63e15fc85e76", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 350, "deletions": 366, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use driver::session::Session;\n use driver::session;\n use middle::ty;\n use middle::pat_util;\n@@ -19,7 +18,7 @@ use std::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::{ast, visit};\n+use syntax::{ast, visit, ast_util};\n \n /**\n  * A 'lint' check is a kind of miscellaneous constraint that a user _might_\n@@ -86,7 +85,13 @@ struct LintSpec {\n     default: level\n }\n \n-pub type LintDict = @HashMap<~str, LintSpec>;\n+pub type LintDict = HashMap<~str, LintSpec>;\n+\n+enum AttributedNode<'self> {\n+    Item(@ast::item),\n+    Method(&'self ast::method),\n+    Crate(@ast::crate),\n+}\n \n static lint_table: &'static [(&'static str, LintSpec)] = &[\n     (\"ctypes\",\n@@ -225,7 +230,7 @@ pub fn get_lint_dict() -> LintDict {\n     for lint_table.each|&(k, v)| {\n         map.insert(k.to_str(), v);\n     }\n-    return @map;\n+    return map;\n }\n \n pub fn get_lint_name(lint_mode: lint) -> ~str {\n@@ -237,260 +242,199 @@ pub fn get_lint_name(lint_mode: lint) -> ~str {\n     fail!();\n }\n // This is a highly not-optimal set of data structure decisions.\n-type LintModes = @mut SmallIntMap<level>;\n-type LintModeMap = @mut HashMap<ast::node_id, LintModes>;\n-\n-// settings_map maps node ids of items with non-default lint settings\n-// to their settings; default_settings contains the settings for everything\n-// not in the map.\n-pub struct LintSettings {\n-    default_settings: LintModes,\n-    settings_map: LintModeMap\n-}\n-\n-pub fn mk_lint_settings() -> LintSettings {\n-    LintSettings {\n-        default_settings: @mut SmallIntMap::new(),\n-        settings_map: @mut HashMap::new()\n-    }\n-}\n-\n-pub fn get_lint_level(modes: LintModes, lint: lint) -> level {\n-    match modes.find(&(lint as uint)) {\n-      Some(&c) => c,\n-      None => allow\n-    }\n-}\n-\n-pub fn get_lint_settings_level(settings: LintSettings,\n-                               lint_mode: lint,\n-                               _expr_id: ast::node_id,\n-                               item_id: ast::node_id)\n-                            -> level {\n-    match settings.settings_map.find(&item_id) {\n-      Some(&modes) => get_lint_level(modes, lint_mode),\n-      None => get_lint_level(settings.default_settings, lint_mode)\n-    }\n-}\n-\n-// This is kind of unfortunate. It should be somewhere else, or we should use\n-// a persistent data structure...\n-fn clone_lint_modes(modes: LintModes) -> LintModes {\n-    @mut (copy *modes)\n-}\n+type LintModes = SmallIntMap<level>;\n+type LintModeMap = HashMap<ast::node_id, LintModes>;\n \n struct Context {\n-    dict: LintDict,\n+    // All known lint modes (string versions)\n+    dict: @LintDict,\n+    // Current levels of each lint warning\n     curr: LintModes,\n-    is_default: bool,\n-    sess: Session\n+    // context we're checking in (used to access fields like sess)\n+    tcx: ty::ctxt,\n+    // When recursing into an attributed node of the ast which modifies lint\n+    // levels, this stack keeps track of the previous lint levels of whatever\n+    // was modified.\n+    lint_stack: ~[(lint, level)],\n }\n \n-pub impl Context {\n+impl Context {\n     fn get_level(&self, lint: lint) -> level {\n-        get_lint_level(self.curr, lint)\n+        match self.curr.find(&(lint as uint)) {\n+          Some(&c) => c,\n+          None => allow\n+        }\n     }\n \n-    fn set_level(&self, lint: lint, level: level) {\n+    fn set_level(&mut self, lint: lint, level: level) {\n         if level == allow {\n             self.curr.remove(&(lint as uint));\n         } else {\n             self.curr.insert(lint as uint, level);\n         }\n     }\n \n-    fn span_lint(&self, level: level, span: span, msg: ~str) {\n-        self.sess.span_lint_level(level, span, msg);\n+    fn span_lint(&self, lint: lint, span: span, msg: &str) {\n+        self.tcx.sess.span_lint_level(self.get_level(lint), span, msg);\n     }\n \n     /**\n      * Merge the lints specified by any lint attributes into the\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(&self, attrs: ~[ast::attribute], f: &fn(Context)) {\n-\n-        let mut new_ctxt = *self;\n-        let mut triples = ~[];\n-\n-        for [allow, warn, deny, forbid].each |level| {\n-            let level_name = level_to_str(*level);\n-            let metas =\n-                attr::attr_metas(attr::find_attrs_by_name(attrs, level_name));\n-            for metas.each |meta| {\n-                match meta.node {\n-                  ast::meta_list(_, ref metas) => {\n-                    for metas.each |meta| {\n-                        match meta.node {\n-                          ast::meta_word(ref lintname) => {\n-                            triples.push((*meta,\n-                                          *level,\n-                                          /*bad*/copy *lintname));\n-                          }\n-                          _ => {\n-                            self.sess.span_err(\n-                                meta.span,\n-                                \"malformed lint attribute\");\n-                          }\n-                        }\n-                    }\n-                  }\n-                  _  => {\n-                    self.sess.span_err(meta.span,\n-                                       \"malformed lint attribute\");\n-                  }\n-                }\n-            }\n-        }\n-\n+    fn with_lint_attrs(@mut self, attrs: &[ast::attribute], f: &fn()) {\n+        // Parse all of the lint attributes, and then add them all to the\n+        // current dictionary of lint information. Along the way, keep a history\n+        // of what we changed so we can roll everything back after invoking the\n+        // specified closure\n+        let triples = extract_lints(self.tcx.sess, attrs);\n+        let mut pushed = 0u;\n         for triples.each |triple| {\n             // FIXME(#3874): it would be nicer to write this...\n             // let (meta, level, lintname) = /*bad*/copy *pair;\n             let (meta, level, lintname) = match *triple {\n                 (ref meta, level, lintname) => (meta, level, lintname)\n             };\n \n-            match self.dict.find(lintname) {\n+            let lint = match self.dict.find(lintname) {\n               None => {\n                 self.span_lint(\n-                    new_ctxt.get_level(unrecognized_lint),\n+                    unrecognized_lint,\n                     meta.span,\n                     fmt!(\"unknown `%s` attribute: `%s`\",\n                          level_to_str(level), *lintname));\n+                loop\n               }\n-              Some(lint) => {\n-\n-                if new_ctxt.get_level(lint.lint) == forbid &&\n-                    level != forbid {\n-                    self.span_lint(\n-                        forbid,\n-                        meta.span,\n-                        fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n-                             level_to_str(level),\n-                             *lintname, *lintname));\n-                }\n-\n-                // we do multiple unneeded copies of the\n-                // map if many attributes are set, but\n-                // this shouldn't actually be a problem...\n+              Some(lint) => { lint.lint }\n+            };\n \n-                let c = clone_lint_modes(new_ctxt.curr);\n-                new_ctxt = Context {\n-                    is_default: false,\n-                    curr: c,\n-                    .. new_ctxt\n-                };\n-                new_ctxt.set_level(lint.lint, level);\n-              }\n+            let now = self.get_level(lint);\n+            if now == forbid && level != forbid {\n+                self.tcx.sess.span_err(meta.span,\n+                    fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n+                         level_to_str(level),\n+                         *lintname, *lintname));\n+                loop\n             }\n-        }\n-        f(new_ctxt);\n-    }\n-}\n-\n \n-fn build_settings_item(i: @ast::item, cx: Context, v: visit::vt<Context>) {\n-    do cx.with_lint_attrs(/*bad*/copy i.attrs) |cx| {\n-        if !cx.is_default {\n-            cx.sess.lint_settings.settings_map.insert(i.id, cx.curr);\n+            self.lint_stack.push((lint, now));\n+            pushed += 1;\n+            self.set_level(lint, level);\n         }\n-        visit::visit_item(i, cx, v);\n-    }\n-}\n \n-pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n-    let cx = Context {\n-        dict: get_lint_dict(),\n-        curr: @mut SmallIntMap::new(),\n-        is_default: true,\n-        sess: sess\n-    };\n-\n-    // Install defaults.\n-    for cx.dict.each_value |&spec| {\n-        cx.set_level(spec.lint, spec.default);\n-    }\n+        f();\n \n-    // Install command-line options, overriding defaults.\n-    for sess.opts.lint_opts.each |pair| {\n-        let (lint,level) = *pair;\n-        cx.set_level(lint, level);\n+        // rollback\n+        for pushed.times {\n+            let (lint, level) = self.lint_stack.pop();\n+            self.set_level(lint, level);\n+        }\n     }\n \n-    do cx.with_lint_attrs(/*bad*/copy crate.node.attrs) |cx| {\n-        // Copy out the default settings\n-        for cx.curr.each |&k, &v| {\n-            sess.lint_settings.default_settings.insert(k, v);\n+    fn process(&self, n: AttributedNode, v: @visit::SimpleVisitor) {\n+        self.process_visitor(n, visit::mk_simple_visitor(v));\n+    }\n+\n+    fn process_visitor(&self, n: AttributedNode, v: visit::vt<()>) {\n+        let v = item_stopping_visitor(v);\n+        match n {\n+            Item(it) => visit::visit_item(it, (), v),\n+            Crate(c) => visit::visit_crate(c, (), v),\n+            // Can't use visit::visit_method_helper because the\n+            // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n+            // to be a no-op, so manually invoke visit_fn.\n+            Method(m) => visit::visit_fn(&visit::fk_method(copy m.ident,\n+                                                           &m.generics,\n+                                                           m),\n+                                         &m.decl,\n+                                         &m.body,\n+                                         m.span,\n+                                         m.id,\n+                                         (),\n+                                         v)\n         }\n-\n-        let cx = Context {\n-            is_default: true,\n-            .. cx\n-        };\n-\n-        let visit = visit::mk_vt(@visit::Visitor {\n-            visit_item: build_settings_item,\n-            .. *visit::default_visitor()\n-        });\n-        visit::visit_crate(crate, cx, visit);\n     }\n-\n-    sess.abort_if_errors();\n }\n \n-fn check_item(i: @ast::item, cx: ty::ctxt) {\n-    check_item_ctypes(cx, i);\n-    check_item_while_true(cx, i);\n-    check_item_path_statement(cx, i);\n-    check_item_non_camel_case_types(cx, i);\n-    check_item_heap(cx, i);\n-    check_item_type_limits(cx, i);\n-    check_item_default_methods(cx, i);\n-    check_item_unused_unsafe(cx, i);\n-    check_item_unused_mut(cx, i);\n+pub fn extract_lints(sess: session::Session,\n+                     attrs: &[ast::attribute])\n+                            -> ~[(@ast::meta_item, level, @~str)]\n+{\n+    let mut triples = ~[];\n+    for [allow, warn, deny, forbid].each |&level| {\n+        let level_name = level_to_str(level);\n+        let metas =\n+            attr::attr_metas(attr::find_attrs_by_name(attrs, level_name));\n+        for metas.each |meta| {\n+            match meta.node {\n+              ast::meta_list(_, ref metas) => {\n+                for metas.each |meta| {\n+                    match meta.node {\n+                      ast::meta_word(lintname) => {\n+                        triples.push((*meta,\n+                                      level,\n+                                      lintname));\n+                      }\n+                      _ => {\n+                        sess.span_err(meta.span, ~\"malformed lint attribute\");\n+                      }\n+                    }\n+                }\n+              }\n+              _  => {\n+                sess.span_err(meta.span, ~\"malformed lint attribute\");\n+              }\n+            }\n+        }\n+    }\n+    return triples;\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n // This is used to make the simple visitors used for the lint passes\n // not traverse into subitems, since that is handled by the outer\n // lint visitor.\n-fn item_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n-    visit::mk_vt(@visit::Visitor {visit_item: |_i, _e, _v| { },\n-        .. **(ty_stopping_visitor(v))})\n+fn item_stopping_visitor<E: Copy>(v: visit::vt<E>) -> visit::vt<E> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_item: |_i, _e, _v| { },\n+        visit_fn: |fk, fd, b, s, id, e, v| {\n+            match *fk {\n+                visit::fk_method(*) => {}\n+                _ => visit::visit_fn(fk, fd, b, s, id, e, v)\n+            }\n+        },\n+    .. **(ty_stopping_visitor(v))})\n }\n \n fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n     visit::mk_vt(@visit::Visitor {visit_ty: |_t, _e, _v| { },.. **v})\n }\n \n-fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_expr: |e: @ast::expr| {\n-                match e.node {\n-                    ast::expr_while(cond, _) => {\n-                        match cond.node {\n-                            ast::expr_lit(@codemap::spanned {\n-                                node: ast::lit_bool(true), _}) =>\n-                            {\n-                                cx.sess.span_lint(\n-                                    while_true, e.id, it.id,\n-                                    e.span,\n-                                    \"denote infinite loops \\\n-                                     with loop { ... }\");\n-                            }\n-                            _ => ()\n+fn check_item_while_true(cx: @mut Context, n: AttributedNode) {\n+    cx.process(n, @visit::SimpleVisitor {\n+        visit_expr: |e: @ast::expr| {\n+            match e.node {\n+                ast::expr_while(cond, _) => {\n+                    match cond.node {\n+                        ast::expr_lit(@codemap::spanned {\n+                            node: ast::lit_bool(true), _}) =>\n+                        {\n+                            cx.span_lint(while_true, e.span,\n+                                         \"denote infinite loops with \\\n+                                          loop { ... }\");\n                         }\n+                        _ => ()\n                     }\n-                    _ => ()\n                 }\n-            },\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n+                _ => ()\n+            }\n+        },\n+        .. *visit::default_simple_visitor()\n+    });\n }\n \n-fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n+fn check_item_type_limits(cx: @mut Context, n: AttributedNode) {\n     fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n@@ -534,7 +478,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    fn check_limits(cx: ty::ctxt, binop: ast::binop, l: &ast::expr,\n+    fn check_limits(cx: @mut Context, binop: ast::binop, l: &ast::expr,\n                     r: &ast::expr) -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n             (&ast::expr_lit(_), _) => (l, r, true),\n@@ -543,12 +487,12 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         };\n         // Normalize the binop so that the literal is always on the RHS in\n         // the comparison\n-        let norm_binop = if (swap) {\n+        let norm_binop = if swap {\n             rev_binop(binop)\n         } else {\n             binop\n         };\n-        match ty::get(ty::expr_ty(cx, @/*bad*/copy *expr)).sty {\n+        match ty::get(ty::expr_ty(cx.tcx, @/*bad*/copy *expr)).sty {\n             ty::ty_int(int_ty) => {\n                 let (min, max) = int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n@@ -592,36 +536,29 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n             ast::expr_binary(ref binop, @ref l, @ref r) => {\n                 if is_comparison(*binop)\n                     && !check_limits(cx, *binop, l, r) {\n-                    cx.sess.span_lint(\n-                        type_limits, e.id, it.id, e.span,\n-                        \"comparison is useless due to type limits\");\n+                    cx.span_lint(type_limits, e.span,\n+                                 \"comparison is useless due to type limits\");\n                 }\n             }\n             _ => ()\n         }\n     };\n \n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_expr: visit_expr,\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n+    cx.process(n, @visit::SimpleVisitor {\n+        visit_expr: visit_expr,\n+        .. *visit::default_simple_visitor()\n+    });\n }\n \n-fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n+fn check_item_default_methods(cx: @mut Context, item: @ast::item) {\n     match item.node {\n         ast::item_trait(_, _, ref methods) => {\n             for methods.each |method| {\n                 match *method {\n                     ast::required(*) => {}\n                     ast::provided(*) => {\n-                        cx.sess.span_lint(\n-                            default_methods,\n-                            item.id,\n-                            item.id,\n-                            item.span,\n-                            \"default methods are experimental\");\n+                        cx.span_lint(default_methods, item.span,\n+                                     \"default methods are experimental\");\n                     }\n                 }\n             }\n@@ -630,25 +567,21 @@ fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n-fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n-    fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n-                        decl: &ast::fn_decl) {\n+fn check_item_ctypes(cx: @mut Context, it: @ast::item) {\n+\n+    fn check_foreign_fn(cx: @mut Context, decl: &ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n-                match cx.def_map.get_copy(&id) {\n+                match cx.tcx.def_map.get_copy(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n-                    cx.sess.span_lint(\n-                        ctypes, id, fn_id,\n-                        ty.span,\n+                    cx.span_lint(ctypes, ty.span,\n                         \"found rust type `int` in foreign module, while \\\n                          libc::c_int or libc::c_long should be used\");\n                   }\n                   ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n-                    cx.sess.span_lint(\n-                        ctypes, id, fn_id,\n-                        ty.span,\n+                    cx.span_lint(ctypes, ty.span,\n                         \"found rust type `uint` in foreign module, while \\\n                          libc::c_uint or libc::c_ulong should be used\");\n                   }\n@@ -665,7 +598,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         for nmod.items.each |ni| {\n             match ni.node {\n               ast::foreign_item_fn(ref decl, _, _) => {\n-                check_foreign_fn(cx, it.id, decl);\n+                check_foreign_fn(cx, decl);\n               }\n               // FIXME #4622: Not implemented.\n               ast::foreign_item_const(*) => {}\n@@ -676,106 +609,96 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n-fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n-\n-    fn check_type_for_lint(cx: ty::ctxt, lint: lint,\n-                           node: ast::node_id,\n-                           item: ast::node_id,\n-                           span: span, ty: ty::t) {\n-\n-        if get_lint_settings_level(cx.sess.lint_settings,\n-                                   lint, node, item) != allow {\n-            let mut n_box = 0;\n-            let mut n_uniq = 0;\n-            ty::fold_ty(cx, ty, |t| {\n-                match ty::get(t).sty {\n-                  ty::ty_box(_) => n_box += 1,\n-                  ty::ty_uniq(_) => n_uniq += 1,\n-                  _ => ()\n-                };\n-                t\n-            });\n+fn check_item_heap(cx: @mut Context, n: AttributedNode) {\n \n-            if (n_uniq > 0 && lint != managed_heap_memory) {\n-                let s = ty_to_str(cx, ty);\n-                let m = ~\"type uses owned (~ type) pointers: \" + s;\n-                cx.sess.span_lint(lint, node, item, span, m);\n-            }\n+    fn check_type_for_lint(cx: @mut Context, lint: lint, span: span, ty: ty::t) {\n+        if cx.get_level(lint) == allow { return }\n \n-            if (n_box > 0 && lint != owned_heap_memory) {\n-                let s = ty_to_str(cx, ty);\n-                let m = ~\"type uses managed (@ type) pointers: \" + s;\n-                cx.sess.span_lint(lint, node, item, span, m);\n-            }\n+        let mut n_box = 0;\n+        let mut n_uniq = 0;\n+        ty::fold_ty(cx.tcx, ty, |t| {\n+            match ty::get(t).sty {\n+              ty::ty_box(_) => n_box += 1,\n+              ty::ty_uniq(_) => n_uniq += 1,\n+              _ => ()\n+            };\n+            t\n+        });\n+\n+        if n_uniq > 0 && lint != managed_heap_memory {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = ~\"type uses owned (~ type) pointers: \" + s;\n+            cx.span_lint(lint, span, m);\n         }\n-    }\n \n-    fn check_type(cx: ty::ctxt,\n-                  node: ast::node_id,\n-                  item: ast::node_id,\n-                  span: span, ty: ty::t) {\n-            for [managed_heap_memory,\n-                 owned_heap_memory,\n-                 heap_memory].each |lint| {\n-                check_type_for_lint(cx, *lint, node, item, span, ty);\n-            }\n+        if n_box > 0 && lint != owned_heap_memory {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = ~\"type uses managed (@ type) pointers: \" + s;\n+            cx.span_lint(lint, span, m);\n+        }\n     }\n \n-    match it.node {\n-      ast::item_fn(*) |\n-      ast::item_ty(*) |\n-      ast::item_enum(*) |\n-      ast::item_struct(*) => check_type(cx, it.id, it.id, it.span,\n-                                       ty::node_id_to_type(cx, it.id)),\n-      _ => ()\n+    fn check_type(cx: @mut Context, span: span, ty: ty::t) {\n+        for [managed_heap_memory, owned_heap_memory, heap_memory].each |lint| {\n+            check_type_for_lint(cx, *lint, span, ty);\n+        }\n     }\n \n-    // If it's a struct, we also have to check the fields' types\n-    match it.node {\n-        ast::item_struct(struct_def, _) => {\n-            for struct_def.fields.each |struct_field| {\n-                check_type(cx, struct_field.node.id, it.id,\n-                           struct_field.span,\n-                           ty::node_id_to_type(cx, struct_field.node.id));\n+    match n {\n+        Item(it) => {\n+            match it.node {\n+              ast::item_fn(*) |\n+              ast::item_ty(*) |\n+              ast::item_enum(*) |\n+              ast::item_struct(*) => check_type(cx, it.span,\n+                                                ty::node_id_to_type(cx.tcx,\n+                                                                    it.id)),\n+              _ => ()\n+            }\n+\n+            // If it's a struct, we also have to check the fields' types\n+            match it.node {\n+                ast::item_struct(struct_def, _) => {\n+                    for struct_def.fields.each |struct_field| {\n+                        check_type(cx, struct_field.span,\n+                                   ty::node_id_to_type(cx.tcx,\n+                                                       struct_field.node.id));\n+                    }\n+                }\n+                _ => ()\n             }\n         }\n         _ => ()\n     }\n \n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_expr: |e: @ast::expr| {\n-                let ty = ty::expr_ty(cx, e);\n-                check_type(cx, e.id, it.id, e.span, ty);\n-            },\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n+    cx.process(n, @visit::SimpleVisitor {\n+        visit_expr: |e| {\n+            let ty = ty::expr_ty(cx.tcx, e);\n+            check_type(cx, e.span, ty);\n+        },\n+        .. *visit::default_simple_visitor()\n+    });\n }\n \n-fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_stmt: |s: @ast::stmt| {\n-                match s.node {\n-                    ast::stmt_semi(\n-                        @ast::expr { id: id, node: ast::expr_path(_), _ },\n-                        _\n-                    ) => {\n-                        cx.sess.span_lint(\n-                            path_statement, id, it.id,\n-                            s.span,\n-                            \"path statement with no effect\");\n-                    }\n-                    _ => ()\n+fn check_item_path_statement(cx: @mut Context, n: AttributedNode) {\n+    cx.process(n, @visit::SimpleVisitor {\n+        visit_stmt: |s| {\n+            match s.node {\n+                ast::stmt_semi(\n+                    @ast::expr { node: ast::expr_path(_), _ },\n+                    _\n+                ) => {\n+                    cx.span_lint(path_statement, s.span,\n+                                 \"path statement with no effect\");\n                 }\n-            },\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n+                _ => ()\n+            }\n+        },\n+        .. *visit::default_simple_visitor()\n+    });\n }\n \n-fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n+fn check_item_non_camel_case_types(cx: @mut Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n@@ -799,61 +722,54 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    fn check_case(cx: ty::ctxt, ident: ast::ident,\n-                  expr_id: ast::node_id, item_id: ast::node_id,\n-                  span: span) {\n-        if !is_camel_case(cx, ident) {\n-            cx.sess.span_lint(\n-                non_camel_case_types, expr_id, item_id, span,\n-                \"type, variant, or trait should have \\\n-                 a camel case identifier\");\n+    fn check_case(cx: @mut Context, ident: ast::ident, span: span) {\n+        if !is_camel_case(cx.tcx, ident) {\n+            cx.span_lint(non_camel_case_types, span,\n+                         \"type, variant, or trait should have \\\n+                          a camel case identifier\");\n         }\n     }\n \n     match it.node {\n         ast::item_ty(*) | ast::item_struct(*) |\n         ast::item_trait(*) => {\n-            check_case(cx, it.ident, it.id, it.id, it.span)\n+            check_case(cx, it.ident, it.span)\n         }\n         ast::item_enum(ref enum_definition, _) => {\n-            check_case(cx, it.ident, it.id, it.id, it.span);\n+            check_case(cx, it.ident, it.span);\n             for enum_definition.variants.each |variant| {\n-                check_case(cx, variant.node.name,\n-                           variant.node.id, it.id, variant.span);\n+                check_case(cx, variant.node.name, variant.span);\n             }\n         }\n         _ => ()\n     }\n }\n \n-fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n+fn check_item_unused_unsafe(cx: @mut Context, n: AttributedNode) {\n     let visit_expr: @fn(@ast::expr) = |e| {\n         match e.node {\n             ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n-                if !cx.used_unsafe.contains(&blk.node.id) {\n-                    cx.sess.span_lint(unused_unsafe, blk.node.id, it.id,\n-                                      blk.span,\n-                                      \"unnecessary `unsafe` block\");\n+                if !cx.tcx.used_unsafe.contains(&blk.node.id) {\n+                    cx.span_lint(unused_unsafe, blk.span,\n+                                 \"unnecessary `unsafe` block\");\n                 }\n             }\n             _ => ()\n         }\n     };\n \n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_expr: visit_expr,\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n+    cx.process(n, @visit::SimpleVisitor {\n+        visit_expr: visit_expr,\n+        .. *visit::default_simple_visitor()\n+    });\n }\n \n-fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n+fn check_item_unused_mut(cx: @mut Context, n: AttributedNode) {\n     let check_pat: @fn(@ast::pat) = |p| {\n         let mut used = false;\n         let mut bindings = 0;\n-        do pat_util::pat_bindings(tcx.def_map, p) |_, id, _, _| {\n-            used = used || tcx.used_mut_nodes.contains(&id);\n+        do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n+            used = used || cx.tcx.used_mut_nodes.contains(&id);\n             bindings += 1;\n         }\n         if !used {\n@@ -862,7 +778,7 @@ fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n             } else {\n                 \"variables do not need to be mutable\"\n             };\n-            tcx.sess.span_lint(unused_mut, p.id, it.id, p.span, msg);\n+            cx.span_lint(unused_mut, p.span, msg);\n         }\n     };\n \n@@ -874,45 +790,113 @@ fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n         }\n     };\n \n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_local: |l| {\n-                if l.node.is_mutbl {\n-                    check_pat(l.node.pat);\n-                }\n-            },\n-            visit_fn: |_, fd, _, _, _| visit_fn_decl(fd),\n-            visit_ty_method: |tm| visit_fn_decl(&tm.decl),\n-            visit_struct_method: |sm| visit_fn_decl(&sm.decl),\n-            visit_trait_method: |tm| {\n-                match *tm {\n-                    ast::required(ref tm) => visit_fn_decl(&tm.decl),\n-                    ast::provided(m) => visit_fn_decl(&m.decl),\n+    cx.process(n, @visit::SimpleVisitor {\n+        visit_local: |l| {\n+            if l.node.is_mutbl {\n+                check_pat(l.node.pat);\n+            }\n+        },\n+        visit_fn: |_, fd, _, _, _| visit_fn_decl(fd),\n+        visit_ty_method: |tm| visit_fn_decl(&tm.decl),\n+        visit_struct_method: |sm| visit_fn_decl(&sm.decl),\n+        visit_trait_method: |tm| {\n+            match *tm {\n+                ast::required(ref tm) => visit_fn_decl(&tm.decl),\n+                ast::provided(m) => visit_fn_decl(&m.decl),\n+            }\n+        },\n+        .. *visit::default_simple_visitor()\n+    });\n+}\n+\n+fn check_item_session_lints(cx: @mut Context, n: AttributedNode) {\n+    cx.process_visitor(n, ast_util::id_visitor(|id| {\n+        match cx.tcx.sess.lints.pop(&id) {\n+            None => {},\n+            Some(l) => {\n+                info!(\"id %?\", id);\n+                do vec::consume(l) |_, (lint, span, msg)| {\n+                    cx.span_lint(lint, span, msg)\n                 }\n-            },\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n+            }\n+        }\n+    }));\n }\n \n-fn check_fn(_: ty::ctxt,\n-            fk: &visit::fn_kind,\n-            _: &ast::fn_decl,\n-            _: &ast::blk,\n-            _: span,\n-            id: ast::node_id) {\n-    debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n+fn check_attributed_node(cx: @mut Context, n: AttributedNode) {\n+    check_item_while_true(cx, n);\n+    check_item_path_statement(cx, n);\n+    check_item_heap(cx, n);\n+    check_item_type_limits(cx, n);\n+    check_item_unused_unsafe(cx, n);\n+    check_item_unused_mut(cx, n);\n+    check_item_session_lints(cx, n);\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n-    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_item: |it|\n-            check_item(it, tcx),\n-        visit_fn: |fk, decl, body, span, id|\n-            check_fn(tcx, fk, decl, body, span, id),\n-        .. *visit::default_simple_visitor()\n-    });\n-    visit::visit_crate(crate, (), v);\n+    let cx = @mut Context {\n+        dict: @get_lint_dict(),\n+        curr: SmallIntMap::new(),\n+        tcx: tcx,\n+        lint_stack: ~[],\n+    };\n+\n+    // Install defaults.\n+    for cx.dict.each_value |spec| {\n+        cx.set_level(spec.lint, spec.default);\n+    }\n+\n+    // Install command-line options, overriding defaults.\n+    for tcx.sess.opts.lint_opts.each |&(lint, level)| {\n+        cx.set_level(lint, level);\n+    }\n+\n+    // type inference doesn't like this being declared below, we need to tell it\n+    // what the type of this first function is...\n+    let visit_item:\n+        @fn(@ast::item, @mut Context, visit::vt<@mut Context>) =\n+    |it, cx, vt| {\n+        do cx.with_lint_attrs(it.attrs) {\n+            check_item_ctypes(cx, it);\n+            check_item_non_camel_case_types(cx, it);\n+            check_item_default_methods(cx, it);\n+            check_item_heap(cx, it);\n+\n+            check_attributed_node(cx, Item(it));\n+            visit::visit_item(it, cx, vt);\n+        }\n+    };\n \n+    do cx.with_lint_attrs(crate.node.attrs) {\n+        check_item_session_lints(cx, Crate(crate));\n+\n+        visit::visit_crate(crate, cx, visit::mk_vt(@visit::Visitor {\n+            visit_item: visit_item,\n+            visit_fn: |fk, decl, body, span, id, cx, vt| {\n+                match *fk {\n+                    visit::fk_method(_, _, m) => {\n+                        do cx.with_lint_attrs(m.attrs) {\n+                            check_attributed_node(cx, Method(m));\n+                            visit::visit_fn(fk, decl, body, span, id, cx, vt);\n+                        }\n+                    }\n+                    _ => {\n+                        visit::visit_fn(fk, decl, body, span, id, cx, vt);\n+                    }\n+                }\n+            },\n+            .. *visit::default_visitor()\n+        }));\n+    }\n+\n+    for tcx.sess.lints.each |_, v| {\n+        for v.each |t| {\n+            match *t {\n+                (lint, span, ref msg) =>\n+                    tcx.sess.span_bug(span, fmt!(\"unprocessed lint %?: %s\",\n+                                                 lint, *msg))\n+            }\n+        }\n+    }\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "711e39152775537ebb24c9fe5afd8eee9f81be2e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -153,15 +153,13 @@ pub fn check_crate(tcx: ty::ctxt,\n         visit_local: visit_local,\n         visit_expr: visit_expr,\n         visit_arm: visit_arm,\n-        visit_item: visit_item,\n         .. *visit::default_visitor()\n     });\n \n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    variable_moves_map,\n-                                   capture_map,\n-                                   0);\n+                                   capture_map);\n     visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n }\n@@ -240,15 +238,12 @@ struct IrMaps {\n     capture_info_map: HashMap<node_id, @~[CaptureInfo]>,\n     var_kinds: ~[VarKind],\n     lnks: ~[LiveNodeKind],\n-\n-    cur_item: node_id,\n }\n \n fn IrMaps(tcx: ty::ctxt,\n           method_map: typeck::method_map,\n           variable_moves_map: moves::VariableMovesMap,\n-          capture_map: moves::CaptureMap,\n-          cur_item: node_id)\n+          capture_map: moves::CaptureMap)\n        -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n@@ -262,7 +257,6 @@ fn IrMaps(tcx: ty::ctxt,\n         capture_info_map: HashMap::new(),\n         var_kinds: ~[],\n         lnks: ~[],\n-        cur_item: cur_item,\n     }\n }\n \n@@ -341,13 +335,6 @@ pub impl IrMaps {\n     }\n }\n \n-fn visit_item(item: @item, this: @mut IrMaps, v: vt<@mut IrMaps>) {\n-    let old_cur_item = this.cur_item;\n-    this.cur_item = item.id;\n-    visit::visit_item(item, this, v);\n-    this.cur_item = old_cur_item;\n-}\n-\n fn visit_fn(fk: &visit::fn_kind,\n             decl: &fn_decl,\n             body: &blk,\n@@ -362,8 +349,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     let fn_maps = @mut IrMaps(this.tcx,\n                               this.method_map,\n                               this.variable_moves_map,\n-                              this.capture_map,\n-                              this.cur_item);\n+                              this.capture_map);\n \n     unsafe {\n         debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n@@ -1802,13 +1788,11 @@ pub impl Liveness {\n                 };\n \n                 if is_assigned {\n-                    self.tcx.sess.span_lint(unused_variable, id,\n-                        self.ir.cur_item, sp,\n+                    self.tcx.sess.add_lint(unused_variable, id, sp,\n                         fmt!(\"variable `%s` is assigned to, \\\n                                   but never used\", **name));\n                 } else {\n-                    self.tcx.sess.span_lint(unused_variable, id,\n-                        self.ir.cur_item, sp,\n+                    self.tcx.sess.add_lint(unused_variable, id, sp,\n                         fmt!(\"unused variable: `%s`\", **name));\n                 }\n             }\n@@ -1821,8 +1805,7 @@ pub impl Liveness {\n                               ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {\n-                self.tcx.sess.span_lint(dead_assignment, id,\n-                    self.ir.cur_item, sp,\n+                self.tcx.sess.add_lint(dead_assignment, id, sp,\n                     fmt!(\"value assigned to `%s` is never read\", **name));\n             }\n         }"}, {"sha": "a7e590e359c4dd05d7c3173bc8c930fc7891dba6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 78, "deletions": 171, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -16,47 +16,10 @@ use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n-use middle::lint::{allow, level, unused_imports};\n-use middle::lint::{get_lint_level, get_lint_settings_level};\n+use middle::lint::unused_imports;\n use middle::pat_util::pat_bindings;\n \n-use syntax::ast::{TyParamBound, ty_closure};\n-use syntax::ast::{RegionTyParamBound, TraitTyParamBound, _mod, add, arm};\n-use syntax::ast::{binding_mode, bitand, bitor, bitxor, blk};\n-use syntax::ast::{bind_infer, bind_by_ref, bind_by_copy};\n-use syntax::ast::{crate, decl_item, def, def_arg, def_binding};\n-use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n-use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n-use syntax::ast::{def_self_ty, def_static_method, def_struct, def_ty};\n-use syntax::ast::{def_ty_param, def_typaram_binder, def_trait};\n-use syntax::ast::{def_upvar, def_use, def_variant, explicit_self_, expr, expr_assign_op};\n-use syntax::ast::{expr_binary, expr_break, expr_field};\n-use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n-use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n-use syntax::ast::{expr, expr_again, expr_assign_op};\n-use syntax::ast::{expr_index, expr_loop};\n-use syntax::ast::{expr_path, expr_self, expr_struct, expr_unary, fn_decl};\n-use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n-use syntax::ast::Generics;\n-use syntax::ast::{gt, ident, inherited, item, item_struct};\n-use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n-use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n-use syntax::ast::{local, local_crate, lt, method, mul};\n-use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n-use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n-use syntax::ast::{prim_ty, private, provided};\n-use syntax::ast::{public, required, rem, shl, shr, stmt_decl};\n-use syntax::ast::{struct_field, struct_variant_kind};\n-use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n-use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n-use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, TyParam, ty_path};\n-use syntax::ast::{ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8, ty_uint};\n-use syntax::ast::unnamed_field;\n-use syntax::ast::{variant, view_item, view_item_extern_mod};\n-use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n-use syntax::ast::{view_path_simple, anonymous, named, not};\n-use syntax::ast::{unsafe_fn};\n+use syntax::ast::*;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n@@ -66,6 +29,7 @@ use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{span, dummy_sp, BytePos};\n+use syntax::visit::{mk_simple_visitor, default_simple_visitor, SimpleVisitor};\n use syntax::visit::{default_visitor, mk_vt, Visitor, visit_block};\n use syntax::visit::{visit_crate, visit_expr, visit_expr_opt};\n use syntax::visit::{visit_foreign_item, visit_item};\n@@ -346,18 +310,21 @@ pub struct ImportDirective {\n     module_path: ~[ident],\n     subclass: @ImportDirectiveSubclass,\n     span: span,\n+    id: node_id,\n }\n \n pub fn ImportDirective(privacy: Privacy,\n                        module_path: ~[ident],\n                        subclass: @ImportDirectiveSubclass,\n-                       span: span)\n+                       span: span,\n+                       id: node_id)\n                     -> ImportDirective {\n     ImportDirective {\n         privacy: privacy,\n         module_path: module_path,\n         subclass: subclass,\n-        span: span\n+        span: span,\n+        id: id\n     }\n }\n \n@@ -381,7 +348,7 @@ pub struct ImportResolution {\n     /// The privacy of this `use` directive (whether it's `use` or\n     /// `pub use`.\n     privacy: Privacy,\n-    span: span,\n+    id: node_id,\n \n     // The number of outstanding references to this name. When this reaches\n     // zero, outside modules can count on the targets being correct. Before\n@@ -393,21 +360,16 @@ pub struct ImportResolution {\n     value_target: Option<Target>,\n     /// The type that this `use` directive names, if there is one.\n     type_target: Option<Target>,\n-\n-    /// There exists one state per import statement\n-    state: @mut ImportState,\n }\n \n pub fn ImportResolution(privacy: Privacy,\n-                        span: span,\n-                        state: @mut ImportState) -> ImportResolution {\n+                        id: node_id) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n-        span: span,\n+        id: id,\n         outstanding_references: 0,\n         value_target: None,\n         type_target: None,\n-        state: state,\n     }\n }\n \n@@ -420,15 +382,6 @@ pub impl ImportResolution {\n     }\n }\n \n-pub struct ImportState {\n-    used: bool,\n-    warned: bool\n-}\n-\n-pub fn ImportState() -> ImportState {\n-    ImportState{ used: false, warned: false }\n-}\n-\n /// The link from a module up to its nearest parent node.\n pub enum ParentLink {\n     NoParentLink,\n@@ -805,6 +758,7 @@ pub fn Resolver(session: Session,\n         def_map: @mut HashMap::new(),\n         export_map2: @mut HashMap::new(),\n         trait_map: HashMap::new(),\n+        used_imports: HashSet::new(),\n \n         intr: session.intr()\n     };\n@@ -862,6 +816,8 @@ pub struct Resolver {\n     def_map: DefMap,\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n+\n+    used_imports: HashSet<node_id>,\n }\n \n pub impl Resolver {\n@@ -879,7 +835,7 @@ pub impl Resolver {\n         self.resolve_crate();\n         self.session.abort_if_errors();\n \n-        self.check_for_unused_imports_if_necessary();\n+        self.check_for_unused_imports();\n     }\n \n     //\n@@ -1424,15 +1380,16 @@ pub impl Resolver {\n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n-                        view_path_simple(binding, full_path, _) => {\n+                        view_path_simple(binding, full_path, id) => {\n                             let source_ident = *full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n                             self.build_import_directive(privacy,\n                                                         module_,\n                                                         module_path,\n                                                         subclass,\n-                                                        view_path.span);\n+                                                        view_path.span,\n+                                                        id);\n                         }\n                         view_path_list(_, ref source_idents, _) => {\n                             for source_idents.each |source_ident| {\n@@ -1442,15 +1399,17 @@ pub impl Resolver {\n                                                             module_,\n                                                             copy module_path,\n                                                             subclass,\n-                                                            source_ident.span);\n+                                                            source_ident.span,\n+                                                            source_ident.node.id);\n                             }\n                         }\n-                        view_path_glob(_, _) => {\n+                        view_path_glob(_, id) => {\n                             self.build_import_directive(privacy,\n                                                         module_,\n                                                         module_path,\n                                                         @GlobImport,\n-                                                        view_path.span);\n+                                                        view_path.span,\n+                                                        id);\n                         }\n                     }\n                 }\n@@ -1575,10 +1534,7 @@ pub impl Resolver {\n                     // avoid creating cycles in the\n                     // module graph.\n \n-                    let resolution =\n-                        @mut ImportResolution(Public,\n-                                              dummy_sp(),\n-                                              @mut ImportState());\n+                    let resolution = @mut ImportResolution(Public, 0);\n                     resolution.outstanding_references = 0;\n \n                     match existing_module.parent_link {\n@@ -1840,9 +1796,10 @@ pub impl Resolver {\n                               module_: @mut Module,\n                               module_path: ~[ident],\n                               subclass: @ImportDirectiveSubclass,\n-                              span: span) {\n+                              span: span,\n+                              id: node_id) {\n         let directive = @ImportDirective(privacy, module_path,\n-                                         subclass, span);\n+                                         subclass, span, id);\n         module_.imports.push(directive);\n \n         // Bump the reference count on the name. Or, if this is a glob, set\n@@ -1864,16 +1821,7 @@ pub impl Resolver {\n                     }\n                     None => {\n                         debug!(\"(building import directive) creating new\");\n-                        let state = @mut ImportState();\n-                        let resolution = @mut ImportResolution(privacy,\n-                                                               span,\n-                                                               state);\n-                        let name = self.idents_to_str(directive.module_path);\n-                        // Don't warn about unused intrinsics because they're\n-                        // automatically appended to all files\n-                        if name == ~\"intrinsic::rusti\" {\n-                            resolution.state.warned = true;\n-                        }\n+                        let resolution = @mut ImportResolution(privacy, id);\n                         resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target, resolution);\n                     }\n@@ -2069,13 +2017,12 @@ pub impl Resolver {\n                                                        import_directive.span);\n                     }\n                     GlobImport => {\n-                        let span = import_directive.span;\n                         let privacy = import_directive.privacy;\n                         resolution_result =\n                             self.resolve_glob_import(privacy,\n                                                      module_,\n                                                      containing_module,\n-                                                     span);\n+                                                     import_directive.id);\n                     }\n                 }\n             }\n@@ -2202,7 +2149,8 @@ pub impl Resolver {\n                             if import_resolution.outstanding_references\n                                 == 0 => {\n \n-                        fn get_binding(import_resolution:\n+                        fn get_binding(this: @mut Resolver,\n+                                       import_resolution:\n                                           @mut ImportResolution,\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n@@ -2219,7 +2167,7 @@ pub impl Resolver {\n                                     return UnboundResult;\n                                 }\n                                 Some(target) => {\n-                                    import_resolution.state.used = true;\n+                                    this.used_imports.insert(import_resolution.id);\n                                     return BoundResult(target.target_module,\n                                                     target.bindings);\n                                 }\n@@ -2229,11 +2177,11 @@ pub impl Resolver {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n                         if value_result.is_unknown() {\n-                            value_result = get_binding(*import_resolution,\n+                            value_result = get_binding(self, *import_resolution,\n                                                        ValueNS);\n                         }\n                         if type_result.is_unknown() {\n-                            type_result = get_binding(*import_resolution,\n+                            type_result = get_binding(self, *import_resolution,\n                                                       TypeNS);\n                         }\n                     }\n@@ -2358,13 +2306,12 @@ pub impl Resolver {\n                            privacy: Privacy,\n                            module_: @mut Module,\n                            containing_module: @mut Module,\n-                           span: span)\n+                           id: node_id)\n                         -> ResolveResult<()> {\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n         // node.\n         debug!(\"(resolving glob import) resolving %? glob import\", privacy);\n-        let state = @mut ImportState();\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n@@ -2390,9 +2337,7 @@ pub impl Resolver {\n                 None if target_import_resolution.privacy == Public => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n-                        @mut ImportResolution(privacy,\n-                                              target_import_resolution.span,\n-                                              state);\n+                        @mut ImportResolution(privacy, id);\n                     new_import_resolution.value_target =\n                         copy target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n@@ -2434,9 +2379,7 @@ pub impl Resolver {\n             match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @mut ImportResolution(privacy,\n-                                                                   span,\n-                                                                   state);\n+                    dest_import_resolution = @mut ImportResolution(privacy, id);\n                     module_.import_resolutions.insert\n                         (ident, dest_import_resolution);\n                 }\n@@ -2714,7 +2657,7 @@ pub impl Resolver {\n                     Some(target) => {\n                         debug!(\"(resolving item in lexical scope) using \\\n                                 import resolution\");\n-                        import_resolution.state.used = true;\n+                        self.used_imports.insert(import_resolution.id);\n                         return Success(copy target);\n                     }\n                 }\n@@ -2985,7 +2928,7 @@ pub impl Resolver {\n                             import_resolution.privacy == Public => {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n-                        import_resolution.state.used = true;\n+                        self.used_imports.insert(import_resolution.id);\n                         return Success(copy target);\n                     }\n                     Some(_) => {\n@@ -4466,7 +4409,7 @@ pub impl Resolver {\n                                     namespace)) {\n                             (Some(def), Some(Public)) => {\n                                 // Found it.\n-                                import_resolution.state.used = true;\n+                                self.used_imports.insert(import_resolution.id);\n                                 return ImportNameDefinition(def);\n                             }\n                             (Some(_), _) | (None, _) => {\n@@ -5046,8 +4989,8 @@ pub impl Resolver {\n                                             &mut found_traits,\n                                             trait_def_id, name);\n                                         if added {\n-                                            import_resolution.state.used =\n-                                                true;\n+                                            self.used_imports.insert(\n+                                                import_resolution.id);\n                                         }\n                                     }\n                                     _ => {\n@@ -5145,86 +5088,50 @@ pub impl Resolver {\n     // resolve data structures.\n     //\n \n-    fn unused_import_lint_level(@mut self, m: @mut Module) -> level {\n-        let settings = self.session.lint_settings;\n-        match m.def_id {\n-            Some(def) => get_lint_settings_level(settings, unused_imports,\n-                                                 def.node, def.node),\n-            None => get_lint_level(settings.default_settings, unused_imports)\n-        }\n+    fn check_for_unused_imports(@mut self) {\n+        let vt = mk_simple_visitor(@SimpleVisitor {\n+            visit_view_item: |vi| self.check_for_item_unused_imports(vi),\n+            .. *default_simple_visitor()\n+        });\n+        visit_crate(self.crate, (), vt);\n     }\n \n-    fn check_for_unused_imports_if_necessary(@mut self) {\n-        if self.unused_import_lint_level(self.current_module) == allow {\n-            return;\n-        }\n-\n-        let root_module = self.graph_root.get_module();\n-        self.check_for_unused_imports_in_module_subtree(root_module);\n-    }\n-\n-    fn check_for_unused_imports_in_module_subtree(@mut self,\n-                                                  module_: @mut Module) {\n-        // If this isn't a local crate, then bail out. We don't need to check\n-        // for unused imports in external crates.\n-\n-        match module_.def_id {\n-            Some(def_id) if def_id.crate == local_crate => {\n-                // OK. Continue.\n-            }\n-            None => {\n-                // Check for unused imports in the root module.\n-            }\n-            Some(_) => {\n-                // Bail out.\n-                debug!(\"(checking for unused imports in module subtree) not \\\n-                        checking for unused imports for `%s`\",\n-                       self.module_to_str(module_));\n-                return;\n-            }\n-        }\n-\n-        self.check_for_unused_imports_in_module(module_);\n+    fn check_for_item_unused_imports(&mut self, vi: @view_item) {\n+        // Ignore public import statements because there's no way to be sure\n+        // whether they're used or not. Also ignore imports with a dummy span\n+        // because this means that they were generated in some fashion by the\n+        // compiler and we don't need to consider them.\n+        if vi.vis == public { return }\n+        if vi.span == dummy_sp() { return }\n+\n+        match vi.node {\n+            view_item_extern_mod(*) => {} // ignore\n+            view_item_use(ref path) => {\n+                for path.each |p| {\n+                    match p.node {\n+                        view_path_simple(_, _, id) | view_path_glob(_, id) => {\n+                            if !self.used_imports.contains(&id) {\n+                                self.session.add_lint(unused_imports,\n+                                                      id, vi.span,\n+                                                      ~\"unused import\");\n+                            }\n+                        }\n \n-        for module_.children.each_value |&child_name_bindings| {\n-            match (*child_name_bindings).get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.check_for_unused_imports_in_module_subtree\n-                        (child_module);\n+                        view_path_list(_, ref list, _) => {\n+                            for list.each |i| {\n+                                if !self.used_imports.contains(&i.node.id) {\n+                                    self.session.add_lint(unused_imports,\n+                                                          i.node.id, i.span,\n+                                                          ~\"unused import\");\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }\n-\n-        for module_.anonymous_children.each_value |&child_module| {\n-            self.check_for_unused_imports_in_module_subtree(child_module);\n-        }\n-    }\n-\n-    fn check_for_unused_imports_in_module(@mut self, module_: @mut Module) {\n-        for module_.import_resolutions.each_value |&import_resolution| {\n-            // Ignore dummy spans for things like automatically injected\n-            // imports for the prelude, and also don't warn about the same\n-            // import statement being unused more than once. Furthermore, if\n-            // the import is public, then we can't be sure whether it's unused\n-            // or not so don't warn about it.\n-            if !import_resolution.state.used &&\n-                    !import_resolution.state.warned &&\n-                    import_resolution.span != dummy_sp() &&\n-                    import_resolution.privacy != Public {\n-                import_resolution.state.warned = true;\n-                let span = import_resolution.span;\n-                self.session.span_lint_level(\n-                    self.unused_import_lint_level(module_),\n-                    span,\n-                    ~\"unused import\");\n-            }\n-        }\n     }\n \n-\n     //\n     // Diagnostics\n     //"}, {"sha": "0c3ec9797da7b1c5739acf772eb6c22018e22a0d", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -17,8 +17,7 @@ use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n-use middle::lint::{allow, level, unused_imports};\n-use middle::lint::{get_lint_level, get_lint_settings_level};\n+use middle::lint::{allow, level, warn};\n use middle::pat_util::pat_bindings;\n \n use syntax::ast::{RegionTyParamBound, TraitTyParamBound, _mod, add, arm};\n@@ -5168,14 +5167,7 @@ pub impl Resolver {\n     // resolve data structures.\n     //\n \n-    fn unused_import_lint_level(@mut self, m: @mut Module) -> level {\n-        let settings = self.session.lint_settings;\n-        match m.def_id {\n-            Some(def) => get_lint_settings_level(settings, unused_imports,\n-                                                 def.node, def.node),\n-            None => get_lint_level(settings.default_settings, unused_imports)\n-        }\n-    }\n+    fn unused_import_lint_level(@mut self, _: @mut Module) -> level { warn }\n \n     fn check_for_unused_imports_if_necessary(@mut self) {\n         if self.unused_import_lint_level(self.current_module) == allow {"}, {"sha": "d4a67d61d94b677a6b34feb1249dabf55315d52a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -412,7 +412,12 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n                       match vp.node {\n                           view_path_simple(_, _, id) => vfn(id),\n                           view_path_glob(_, id) => vfn(id),\n-                          view_path_list(_, _, id) => vfn(id)\n+                          view_path_list(_, ref paths, id) => {\n+                              vfn(id);\n+                              for paths.each |p| {\n+                                  vfn(p.node.id);\n+                              }\n+                          }\n                       }\n                   }\n               }"}, {"sha": "624e0495e59506c2b9ec4afbf97baab796119233", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -196,14 +196,15 @@ pub fn mk_global_struct_e(cx: @ext_ctxt,\n }\n pub fn mk_glob_use(cx: @ext_ctxt,\n                    sp: span,\n+                   vis: ast::visibility,\n                    path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n     };\n     @ast::view_item { node: ast::view_item_use(~[glob]),\n                       attrs: ~[],\n-                      vis: ast::private,\n+                      vis: vis,\n                       span: sp }\n }\n pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,"}, {"sha": "fc673c4422f1ddea828a9a0a5a5a8d5b328f7a8b", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -41,7 +41,6 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, span, dummy_spanned};\n \n-    use print::pprust;\n     use print::pprust::{item_to_str, ty_to_str};\n \n     pub trait ToTokens {\n@@ -678,10 +677,11 @@ fn expand_tts(cx: @ext_ctxt,\n     // We want to emit a block expression that does a sequence of 'use's to\n     // import the runtime module, followed by a tt-building expression.\n \n-    let uses = ~[ build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n-                                                           ~\"ext\",\n-                                                           ~\"quote\",\n-                                                           ~\"rt\"])) ];\n+    let uses = ~[ build::mk_glob_use(cx, sp, ast::public,\n+                                     ids_ext(cx, ~[~\"syntax\",\n+                                                   ~\"ext\",\n+                                                   ~\"quote\",\n+                                                   ~\"rt\"])) ];\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //"}, {"sha": "3cc0495206d98e52417f45607c4f5cc31dd35229", "filename": "src/test/compile-fail/lint-impl-fn.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-impl-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-impl-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-impl-fn.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(while_true)];\n+\n+struct A(int);\n+\n+impl A {\n+    fn foo(&self) { while true {} }\n+\n+    #[deny(while_true)]\n+    fn bar(&self) { while true {} } //~ ERROR: infinite loops\n+}\n+\n+#[deny(while_true)]\n+mod foo {\n+    struct B(int);\n+\n+    impl B {\n+        fn foo(&self) { while true {} } //~ ERROR: infinite loops\n+\n+        #[allow(while_true)]\n+        fn bar(&self) { while true {} }\n+    }\n+}\n+\n+#[deny(while_true)]\n+fn main() {\n+    while true {} //~ ERROR: infinite loops\n+}"}, {"sha": "f3b0a1f73f93352c0f1e61d716507843954e3549", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "previous_filename": "src/test/compile-fail/unused-imports-warn.rs"}, {"sha": "d1223cd889307ca4aeb5d45badf7ac5facf968ba", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "previous_filename": "src/test/compile-fail/unused-mut-variables.rs"}, {"sha": "465e5548f679c9a2bb8fc3552751725615c42891", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "previous_filename": "src/test/compile-fail/unused-unsafe.rs"}, {"sha": "2ab3cb4568ac5ab98121cc28950a10de4c24f217", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030c666cc1bc4830eac2f845b114f7c514f6e201/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=030c666cc1bc4830eac2f845b114f7c514f6e201", "patch": "@@ -8,23 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deny(dead_assignment)];\n+\n fn f1(x: &mut int) {\n     *x = 1; // no error\n }\n \n fn f2() {\n-    let mut x = 3; //~ WARNING value assigned to `x` is never read\n+    let mut x = 3; //~ ERROR: value assigned to `x` is never read\n     x = 4;\n     copy x;\n }\n \n fn f3() {\n     let mut x = 3;\n     copy x;\n-    x = 4; //~ WARNING value assigned to `x` is never read\n+    x = 4; //~ ERROR: value assigned to `x` is never read\n }\n \n-fn main() { // leave this in here just to trigger compile-fail:\n-    let x: int;\n-    copy x; //~ ERROR use of possibly uninitialized variable: `x`\n-}\n+fn main() {}"}]}