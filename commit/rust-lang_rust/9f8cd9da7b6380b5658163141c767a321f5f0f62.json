{"sha": "9f8cd9da7b6380b5658163141c767a321f5f0f62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOGNkOWRhN2I2MzgwYjU2NTgxNjMxNDFjNzY3YTMyMWY1ZjBmNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-15T03:47:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-15T03:47:55Z"}, "message": "Auto merge of #61825 - Centril:tauv-infer-fix, r=petrochenkov\n\ntype_alias_enum_variants: fix #61801; allow a path pattern to infer\n\nFix #61801.\n\nGiven a type-relative path pattern referring to an enum variant through a type alias, allow inferring the generic argument applied in the expectation set by the scrutinee of a `match` expression.\n\nSimilar issues may exist for `let` statements but I don't know how to test for that since `PhantomData<T>` is necessary...)\n\nThe gist of the problem here was that `resolve_ty_and_res_ufcs` was called twice which is apparently no good... It is possible that this PR is papering over some deeper problem, but that is beyond my knowledge of the compiler.\n\nr? @petrochenkov\ncc @eddyb @alexreg\ncc https://github.com/rust-lang/rust/pull/61682\ncc https://github.com/rust-lang/rust/issues/49683", "tree": {"sha": "45a2ed6d8654f6b100a0a08d821b1932d3c40a70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45a2ed6d8654f6b100a0a08d821b1932d3c40a70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f8cd9da7b6380b5658163141c767a321f5f0f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8cd9da7b6380b5658163141c767a321f5f0f62", "html_url": "https://github.com/rust-lang/rust/commit/9f8cd9da7b6380b5658163141c767a321f5f0f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f8cd9da7b6380b5658163141c767a321f5f0f62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "html_url": "https://github.com/rust-lang/rust/commit/9606f6fa64926a84d82e3c62dbdc57f5c10f756d"}, {"sha": "065151f8b2c31d9e4ddd34aaf8d3263a997f5cfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/065151f8b2c31d9e4ddd34aaf8d3263a997f5cfe", "html_url": "https://github.com/rust-lang/rust/commit/065151f8b2c31d9e4ddd34aaf8d3263a997f5cfe"}], "stats": {"total": 43, "additions": 38, "deletions": 5}, "files": [{"sha": "f74dbe30d3c56a34e03e3a62f857fabb2f7ca34d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f8cd9da7b6380b5658163141c767a321f5f0f62/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8cd9da7b6380b5658163141c767a321f5f0f62/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9f8cd9da7b6380b5658163141c767a321f5f0f62", "patch": "@@ -50,6 +50,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n+        let mut path_resolution = None;\n         let is_non_ref_pat = match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n@@ -65,8 +66,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             PatKind::Path(ref qpath) => {\n-                let (def, _, _) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-                match def {\n+                let resolution = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+                path_resolution = Some(resolution);\n+                match resolution.0 {\n                     Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n                     _ => true,\n                 }\n@@ -294,7 +296,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n             }\n             PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, qpath, expected)\n+                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n             }\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n@@ -1054,13 +1056,14 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     fn check_pat_path(\n         &self,\n         pat: &hir::Pat,\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n         qpath: &hir::QPath,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n-        // Resolve the path and check the definition for errors.\n-        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        // We have already resolved the path.\n+        let (res, opt_ty, segments) = path_resolution;\n         match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();"}, {"sha": "21be61acb0c61cbbea3f4965fda79dc08793c561", "filename": "src/test/ui/type-alias-enum-variants/issue-61801-path-pattern-can-infer.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f8cd9da7b6380b5658163141c767a321f5f0f62/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fissue-61801-path-pattern-can-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8cd9da7b6380b5658163141c767a321f5f0f62/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fissue-61801-path-pattern-can-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fissue-61801-path-pattern-can-infer.rs?ref=9f8cd9da7b6380b5658163141c767a321f5f0f62", "patch": "@@ -0,0 +1,30 @@\n+// In this regression test we check that a path pattern referring to a unit variant\n+// through a type alias is successful in inferring the generic argument.\n+\n+// compile-pass\n+\n+#![feature(type_alias_enum_variants)]\n+\n+enum Opt<T> {\n+    N,\n+    S(T),\n+}\n+\n+type OptAlias<T> = Opt<T>;\n+\n+fn f1(x: OptAlias<u8>) {\n+    match x {\n+        OptAlias::N // We previously failed to infer `T` to `u8`.\n+            => (),\n+        _ => (),\n+    }\n+\n+    match x {\n+        <\n+            OptAlias<_> // And we failed to infer this type also.\n+        >::N => (),\n+        _ => (),\n+    }\n+}\n+\n+fn main() {}"}]}