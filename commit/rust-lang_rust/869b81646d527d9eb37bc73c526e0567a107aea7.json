{"sha": "869b81646d527d9eb37bc73c526e0567a107aea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OWI4MTY0NmQ1MjdkOWViMzdiYzczYzUyNmUwNTY3YTEwN2FlYTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-16T23:13:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-16T23:13:41Z"}, "message": "syntax: Rename parse_ty -> parse_ty_no_plus, parse_ty_sum -> parse_ty", "tree": {"sha": "7c7df1a3ecee091206e56d2c2709765b41452fb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c7df1a3ecee091206e56d2c2709765b41452fb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/869b81646d527d9eb37bc73c526e0567a107aea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/869b81646d527d9eb37bc73c526e0567a107aea7", "html_url": "https://github.com/rust-lang/rust/commit/869b81646d527d9eb37bc73c526e0567a107aea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/869b81646d527d9eb37bc73c526e0567a107aea7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03620dba25328ee8cc7316cf6d9bad2d0a118ba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/03620dba25328ee8cc7316cf6d9bad2d0a118ba1", "html_url": "https://github.com/rust-lang/rust/commit/03620dba25328ee8cc7316cf6d9bad2d0a118ba1"}], "stats": {"total": 84, "additions": 44, "deletions": 40}, "files": [{"sha": "26e731e1a5ecb9283262d143ffaf0015a720ff33", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=869b81646d527d9eb37bc73c526e0567a107aea7", "patch": "@@ -540,7 +540,7 @@ impl<'a> Parser<'a> {\n             }\n             ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n             ExpansionKind::OptExpr => Expansion::OptExpr(Some(self.parse_expr()?)),\n-            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n+            ExpansionKind::Ty => Expansion::Ty(self.parse_ty_no_plus()?),\n             ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n         })\n     }"}, {"sha": "c0cbda4ba12269d76e097f59205ccba24302c35d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=869b81646d527d9eb37bc73c526e0567a107aea7", "patch": "@@ -388,7 +388,7 @@ pub fn parse_arm_panic(parser: &mut Parser) -> Arm {\n }\n \n pub fn parse_ty_panic(parser: &mut Parser) -> P<Ty> {\n-    panictry!(parser.parse_ty())\n+    panictry!(parser.parse_ty_no_plus())\n }\n \n pub fn parse_stmt_panic(parser: &mut Parser) -> Option<Stmt> {"}, {"sha": "87c8f3efb6355a6e33e35c7a99fb45d8cae9a387", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=869b81646d527d9eb37bc73c526e0567a107aea7", "patch": "@@ -522,7 +522,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         },\n         \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n-        \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n+        \"ty\" => token::NtTy(panictry!(p.parse_ty_no_plus())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n             token::Ident(sn) => {"}, {"sha": "60ad6a76f4d28d242c2647c68145d1efe44f8d7c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869b81646d527d9eb37bc73c526e0567a107aea7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=869b81646d527d9eb37bc73c526e0567a107aea7", "patch": "@@ -1128,7 +1128,7 @@ impl<'a> Parser<'a> {\n                 self.expect_keyword(keywords::Const)?;\n             let ident = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n-            let ty = self.parse_ty_sum()?;\n+            let ty = self.parse_ty()?;\n             let default = if self.check(&token::Eq) {\n                 self.bump();\n                 let expr = self.parse_expr()?;\n@@ -1244,24 +1244,24 @@ impl<'a> Parser<'a> {\n     /// Parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> PResult<'a, MutTy> {\n         let mutbl = self.parse_mutability()?;\n-        let t = self.parse_ty()?;\n+        let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n-            Ok(FunctionRetTy::Ty(self.parse_ty()?))\n+            Ok(FunctionRetTy::Ty(self.parse_ty_no_plus()?))\n         } else {\n             let pos = self.span.lo;\n             Ok(FunctionRetTy::Default(mk_sp(pos, pos)))\n         }\n     }\n \n-    /// Parse a type in a context where `T1+T2` is allowed.\n-    pub fn parse_ty_sum(&mut self) -> PResult<'a, P<Ty>> {\n+    /// Parse a type.\n+    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n         let lo = self.span.lo;\n-        let lhs = self.parse_ty()?;\n+        let lhs = self.parse_ty_no_plus()?;\n \n         if !self.eat(&token::BinOp(token::Plus)) {\n             return Ok(lhs);\n@@ -1331,8 +1331,12 @@ impl<'a> Parser<'a> {\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp}))\n     }\n \n-    /// Parse a type.\n-    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n+    /// Parse a type in restricted contexts where `+` is not permitted.\n+    /// Example 1: `&'a TYPE`\n+    ///     `+` is prohibited to maintain operator priority (P(+) < P(&)).\n+    /// Example 2: `value1 as TYPE + value2`\n+    ///     `+` is prohibited to avoid interactions with expression grammar.\n+    pub fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span.lo;\n@@ -1346,7 +1350,7 @@ impl<'a> Parser<'a> {\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty_sum()?);\n+                ts.push(self.parse_ty()?);\n                 if self.check(&token::Comma) {\n                     last_comma = true;\n                     self.bump();\n@@ -1371,7 +1375,7 @@ impl<'a> Parser<'a> {\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n             self.expect(&token::OpenDelim(token::Bracket))?;\n-            let t = self.parse_ty_sum()?;\n+            let t = self.parse_ty()?;\n \n             // Parse the `; e` in `[ i32; e ]`\n             // where `e` is a const expression\n@@ -1452,7 +1456,7 @@ impl<'a> Parser<'a> {\n                            `*mut T` or `*const T` as appropriate)\");\n             Mutability::Immutable\n         };\n-        let t = self.parse_ty()?;\n+        let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n@@ -1499,7 +1503,7 @@ impl<'a> Parser<'a> {\n             })\n         };\n \n-        let t = self.parse_ty_sum()?;\n+        let t = self.parse_ty()?;\n \n         Ok(Arg {\n             ty: t,\n@@ -1517,7 +1521,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n         let pat = self.parse_pat()?;\n         let t = if self.eat(&token::Colon) {\n-            self.parse_ty_sum()?\n+            self.parse_ty()?\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1658,7 +1662,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_qualified_path(&mut self, mode: PathStyle)\n                                 -> PResult<'a, (QSelf, ast::Path)> {\n         let span = self.prev_span;\n-        let self_type = self.parse_ty_sum()?;\n+        let self_type = self.parse_ty()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n             self.parse_path(PathStyle::Type)?\n         } else {\n@@ -1768,10 +1772,10 @@ impl<'a> Parser<'a> {\n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n                     SeqSep::trailing_allowed(token::Comma),\n-                    |p| p.parse_ty_sum())?;\n+                    |p| p.parse_ty())?;\n \n                 let output_ty = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty()?)\n+                    Some(self.parse_ty_no_plus()?)\n                 } else {\n                     None\n                 };\n@@ -2981,12 +2985,12 @@ impl<'a> Parser<'a> {\n             }\n             // Special cases:\n             if op == AssocOp::As {\n-                let rhs = self.parse_ty()?;\n+                let rhs = self.parse_ty_no_plus()?;\n                 let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n                 lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n-                let rhs = self.parse_ty()?;\n+                let rhs = self.parse_ty_no_plus()?;\n                 let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n                 lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n@@ -3754,7 +3758,7 @@ impl<'a> Parser<'a> {\n \n         let mut ty = None;\n         if self.eat(&token::Colon) {\n-            ty = Some(self.parse_ty_sum()?);\n+            ty = Some(self.parse_ty()?);\n         }\n         let init = self.parse_initializer()?;\n         Ok(P(ast::Local {\n@@ -3775,7 +3779,7 @@ impl<'a> Parser<'a> {\n                          -> PResult<'a, StructField> {\n         let name = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         Ok(StructField {\n             span: mk_sp(lo, self.prev_span.hi),\n             ident: Some(name),\n@@ -4250,7 +4254,7 @@ impl<'a> Parser<'a> {\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n-            Some(self.parse_ty_sum()?)\n+            Some(self.parse_ty()?)\n         } else {\n             None\n         };\n@@ -4345,7 +4349,7 @@ impl<'a> Parser<'a> {\n             let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n \n             let span_hi = self.span.hi;\n-            let span_hi = match self.parse_ty() {\n+            let span_hi = match self.parse_ty_no_plus() {\n                 Ok(..) => self.span.hi,\n                 Err(ref mut err) => {\n                     self.cancel(err);\n@@ -4368,7 +4372,7 @@ impl<'a> Parser<'a> {\n                 if p.look_ahead(1, |t| t == &token::Eq) {\n                     Ok(None)\n                 } else {\n-                    Ok(Some(p.parse_ty_sum()?))\n+                    Ok(Some(p.parse_ty()?))\n                 }\n             }\n         )?;\n@@ -4386,7 +4390,7 @@ impl<'a> Parser<'a> {\n                 let lo = p.span.lo;\n                 let ident = p.parse_ident()?;\n                 p.expect(&token::Eq)?;\n-                let ty = p.parse_ty()?;\n+                let ty = p.parse_ty_no_plus()?;\n                 let hi = ty.span.hi;\n                 let span = mk_sp(lo, hi);\n                 return Ok(TypeBinding{id: ast::DUMMY_NODE_ID,\n@@ -4484,7 +4488,7 @@ impl<'a> Parser<'a> {\n                         vec![]\n                     };\n \n-                    let bounded_ty = self.parse_ty()?;\n+                    let bounded_ty = self.parse_ty_no_plus()?;\n \n                     if self.eat(&token::Colon) {\n                         let bounds = self.parse_ty_param_bounds()?;\n@@ -4507,7 +4511,7 @@ impl<'a> Parser<'a> {\n \n                         parsed_something = true;\n                     } else if self.eat(&token::Eq) {\n-                        // let ty = try!(self.parse_ty());\n+                        // let ty = try!(self.parse_ty_no_plus());\n                         let hi = self.prev_span.hi;\n                         let span = mk_sp(lo, hi);\n                         // where_clause.predicates.push(\n@@ -4679,7 +4683,7 @@ impl<'a> Parser<'a> {\n                     // self: TYPE\n                     let eself_ident = expect_ident(self);\n                     if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty_sum()?;\n+                        let ty = self.parse_ty()?;\n                         (SelfKind::Explicit(ty, Mutability::Immutable), eself_ident)\n                     } else {\n                         (SelfKind::Value(Mutability::Immutable), eself_ident)\n@@ -4691,7 +4695,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n                     if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty_sum()?;\n+                        let ty = self.parse_ty()?;\n                         (SelfKind::Explicit(ty, Mutability::Mutable), eself_ident)\n                     } else {\n                         (SelfKind::Value(Mutability::Mutable), eself_ident)\n@@ -4848,14 +4852,14 @@ impl<'a> Parser<'a> {\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let name = self.parse_ident()?;\n             self.expect(&token::Eq)?;\n-            let typ = self.parse_ty_sum()?;\n+            let typ = self.parse_ty()?;\n             self.expect(&token::Semi)?;\n             (name, ast::ImplItemKind::Type(typ))\n         } else if self.is_const_item() {\n             self.expect_keyword(keywords::Const)?;\n             let name = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n-            let typ = self.parse_ty_sum()?;\n+            let typ = self.parse_ty()?;\n             self.expect(&token::Eq)?;\n             let expr = self.parse_expr()?;\n             self.expect(&token::Semi)?;\n@@ -4979,7 +4983,7 @@ impl<'a> Parser<'a> {\n         };\n \n         // Parse the trait.\n-        let mut ty = self.parse_ty_sum()?;\n+        let mut ty = self.parse_ty()?;\n \n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n@@ -5020,7 +5024,7 @@ impl<'a> Parser<'a> {\n              ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n-                ty = self.parse_ty_sum()?;\n+                ty = self.parse_ty()?;\n             }\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -5172,15 +5176,15 @@ impl<'a> Parser<'a> {\n                 let mut vis = p.parse_visibility(false)?;\n                 let ty_is_interpolated =\n                     p.token.is_interpolated() || p.look_ahead(1, |t| t.is_interpolated());\n-                let mut ty = p.parse_ty_sum()?;\n+                let mut ty = p.parse_ty()?;\n \n                 // Handle `pub(path) type`, in which `vis` will be `pub` and `ty` will be `(path)`.\n                 if vis == Visibility::Public && !ty_is_interpolated &&\n                    p.token != token::Comma && p.token != token::CloseDelim(token::Paren) {\n                     ty = if let TyKind::Paren(ref path_ty) = ty.node {\n                         if let TyKind::Path(None, ref path) = path_ty.node {\n                             vis = Visibility::Restricted { path: P(path.clone()), id: path_ty.id };\n-                            Some(p.parse_ty_sum()?)\n+                            Some(p.parse_ty()?)\n                         } else {\n                             None\n                         }\n@@ -5298,7 +5302,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n         let id = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         self.expect(&token::Eq)?;\n         let e = self.parse_expr()?;\n         self.expect(&token::Semi)?;\n@@ -5539,7 +5543,7 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         let hi = self.span.hi;\n         self.expect(&token::Semi)?;\n         Ok(ForeignItem {\n@@ -5628,7 +5632,7 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics()?;\n         tps.where_clause = self.parse_where_clause()?;\n         self.expect(&token::Eq)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         self.expect(&token::Semi)?;\n         Ok((ident, ItemKind::Ty(ty, tps), None))\n     }"}]}