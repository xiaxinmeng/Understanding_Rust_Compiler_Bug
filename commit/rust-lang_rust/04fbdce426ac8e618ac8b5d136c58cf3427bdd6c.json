{"sha": "04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZmJkY2U0MjZhYzhlNjE4YWM4YjVkMTM2YzU4Y2YzNDI3YmRkNmM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T14:37:50Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T17:12:06Z"}, "message": "Unify check_mismatches and check_types", "tree": {"sha": "da6096bc68eb33c405c56ac7a9f4f60c235891e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da6096bc68eb33c405c56ac7a9f4f60c235891e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "html_url": "https://github.com/rust-lang/rust/commit/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679bb21633d6bbbf04b4cba5cb70f73cc5f5de19", "url": "https://api.github.com/repos/rust-lang/rust/commits/679bb21633d6bbbf04b4cba5cb70f73cc5f5de19", "html_url": "https://github.com/rust-lang/rust/commit/679bb21633d6bbbf04b4cba5cb70f73cc5f5de19"}], "stats": {"total": 733, "additions": 353, "deletions": 380}, "files": [{"sha": "b99a03492b9ecefd54f274a3429d4a5d28776f32", "filename": "crates/hir_ty/src/test_db.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -86,16 +86,20 @@ impl FileLoader for TestDB {\n }\n \n impl TestDB {\n-    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+    pub(crate) fn module_for_file_opt(&self, file_id: FileId) -> Option<ModuleId> {\n         for &krate in self.relevant_crates(file_id).iter() {\n             let crate_def_map = self.crate_def_map(krate);\n             for (local_id, data) in crate_def_map.modules() {\n                 if data.origin.file_id() == Some(file_id) {\n-                    return crate_def_map.module_id(local_id);\n+                    return Some(crate_def_map.module_id(local_id));\n                 }\n             }\n         }\n-        panic!(\"Can't find module for file\")\n+        None\n+    }\n+\n+    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+        self.module_for_file_opt(file_id).unwrap()\n     }\n \n     pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {"}, {"sha": "c4f981b44366999b2f786daf211f51f1147bcaa1", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 109, "deletions": 42, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -59,14 +59,16 @@ fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n }\n \n fn check_types(ra_fixture: &str) {\n-    check_types_impl(ra_fixture, false)\n+    check_impl(ra_fixture, false, true)\n }\n \n fn check_types_source_code(ra_fixture: &str) {\n+    // TODO\n     check_types_impl(ra_fixture, true)\n }\n \n fn check_types_impl(ra_fixture: &str, display_source: bool) {\n+    // TODO\n     let _tracing = setup_tracing();\n     let db = TestDB::with_files(ra_fixture);\n     let mut checked_one = false;\n@@ -88,22 +90,47 @@ fn check_types_impl(ra_fixture: &str, display_source: bool) {\n }\n \n fn check_no_mismatches(ra_fixture: &str) {\n-    check_mismatches_impl(ra_fixture, true)\n+    check_impl(ra_fixture, true, false)\n }\n \n-#[allow(unused)]\n-fn check_mismatches(ra_fixture: &str) {\n-    check_mismatches_impl(ra_fixture, false)\n+fn check(ra_fixture: &str) {\n+    check_impl(ra_fixture, false, false)\n }\n \n-fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n+fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool) {\n     let _tracing = setup_tracing();\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-    let module = db.module_for_file(file_id);\n-    let def_map = module.def_map(&db);\n+    let (db, files) = TestDB::with_many_files(ra_fixture);\n+\n+    let mut had_annotations = false;\n+    let mut mismatches = HashMap::new();\n+    let mut types = HashMap::new();\n+    for (file_id, annotations) in db.extract_annotations() {\n+        for (range, expected) in annotations {\n+            let file_range = FileRange { file_id, range };\n+            if only_types {\n+                types.insert(file_range, expected);\n+            } else if expected.starts_with(\"type: \") {\n+                types.insert(file_range, expected.trim_start_matches(\"type: \").to_string());\n+            } else if expected.starts_with(\"expected\") {\n+                mismatches.insert(file_range, expected);\n+            } else {\n+                panic!(\"unexpected annotation: {}\", expected);\n+            }\n+            had_annotations = true;\n+        }\n+    }\n+    assert!(had_annotations || allow_none, \"no `//^` annotations found\");\n \n     let mut defs: Vec<DefWithBodyId> = Vec::new();\n-    visit_module(&db, &def_map, module.local_id, &mut |it| defs.push(it));\n+    for file_id in files {\n+        let module = db.module_for_file_opt(file_id);\n+        let module = match module {\n+            Some(m) => m,\n+            None => continue,\n+        };\n+        let def_map = module.def_map(&db);\n+        visit_module(&db, &def_map, module.local_id, &mut |it| defs.push(it));\n+    }\n     defs.sort_by_key(|def| match def {\n         DefWithBodyId::FunctionId(it) => {\n             let loc = it.lookup(&db);\n@@ -118,25 +145,46 @@ fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n             loc.source(&db).value.syntax().text_range().start()\n         }\n     });\n-    let mut mismatches = HashMap::new();\n-    let mut push_mismatch = |src_ptr: InFile<SyntaxNode>, mismatch: TypeMismatch| {\n-        let range = src_ptr.value.text_range();\n-        if src_ptr.file_id.call_node(&db).is_some() {\n-            panic!(\"type mismatch in macro expansion\");\n-        }\n-        let file_range = FileRange { file_id: src_ptr.file_id.original_file(&db), range };\n-        let actual = format!(\n-            \"expected {}, got {}\",\n-            mismatch.expected.display_test(&db),\n-            mismatch.actual.display_test(&db)\n-        );\n-        mismatches.insert(file_range, actual);\n-    };\n+    let mut unexpected_type_mismatches = String::new();\n     for def in defs {\n         let (_body, body_source_map) = db.body_with_source_map(def);\n         let inference_result = db.infer(def);\n+\n+        for (pat, ty) in inference_result.type_of_pat.iter() {\n+            let node = match body_source_map.pat_syntax(pat) {\n+                Ok(sp) => {\n+                    let root = db.parse_or_expand(sp.file_id).unwrap();\n+                    sp.map(|ptr| {\n+                        ptr.either(\n+                            |it| it.to_node(&root).syntax().clone(),\n+                            |it| it.to_node(&root).syntax().clone(),\n+                        )\n+                    })\n+                }\n+                Err(SyntheticSyntax) => continue,\n+            };\n+            let range = node.as_ref().original_file_range(&db);\n+            if let Some(annotation) = types.remove(&range) {\n+                assert_eq!(ty.display_test(&db).to_string(), annotation);\n+            }\n+        }\n+\n+        for (expr, ty) in inference_result.type_of_expr.iter() {\n+            let node = match body_source_map.expr_syntax(expr) {\n+                Ok(sp) => {\n+                    let root = db.parse_or_expand(sp.file_id).unwrap();\n+                    sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n+                }\n+                Err(SyntheticSyntax) => continue,\n+            };\n+            let range = node.as_ref().original_file_range(&db);\n+            if let Some(annotation) = types.remove(&range) {\n+                assert_eq!(ty.display_test(&db).to_string(), annotation);\n+            }\n+        }\n+\n         for (pat, mismatch) in inference_result.pat_type_mismatches() {\n-            let syntax_ptr = match body_source_map.pat_syntax(pat) {\n+            let node = match body_source_map.pat_syntax(pat) {\n                 Ok(sp) => {\n                     let root = db.parse_or_expand(sp.file_id).unwrap();\n                     sp.map(|ptr| {\n@@ -148,7 +196,17 @@ fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n                 }\n                 Err(SyntheticSyntax) => continue,\n             };\n-            push_mismatch(syntax_ptr, mismatch.clone());\n+            let range = node.as_ref().original_file_range(&db);\n+            let actual = format!(\n+                \"expected {}, got {}\",\n+                mismatch.expected.display_test(&db),\n+                mismatch.actual.display_test(&db)\n+            );\n+            if let Some(annotation) = mismatches.remove(&range) {\n+                assert_eq!(actual, annotation);\n+            } else {\n+                format_to!(unexpected_type_mismatches, \"{:?}: {}\\n\", range.range, actual);\n+            }\n         }\n         for (expr, mismatch) in inference_result.expr_type_mismatches() {\n             let node = match body_source_map.expr_syntax(expr) {\n@@ -158,28 +216,37 @@ fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n                 }\n                 Err(SyntheticSyntax) => continue,\n             };\n-            push_mismatch(node, mismatch.clone());\n-        }\n-    }\n-    let mut checked_one = false;\n-    for (file_id, annotations) in db.extract_annotations() {\n-        for (range, expected) in annotations {\n-            let file_range = FileRange { file_id, range };\n-            if let Some(mismatch) = mismatches.remove(&file_range) {\n-                assert_eq!(mismatch, expected);\n+            let range = node.as_ref().original_file_range(&db);\n+            let actual = format!(\n+                \"expected {}, got {}\",\n+                mismatch.expected.display_test(&db),\n+                mismatch.actual.display_test(&db)\n+            );\n+            if let Some(annotation) = mismatches.remove(&range) {\n+                assert_eq!(actual, annotation);\n             } else {\n-                assert!(false, \"Expected mismatch not encountered: {}\\n\", expected);\n+                format_to!(unexpected_type_mismatches, \"{:?}: {}\\n\", range.range, actual);\n             }\n-            checked_one = true;\n         }\n     }\n+\n     let mut buf = String::new();\n-    for (range, mismatch) in mismatches {\n-        format_to!(buf, \"{:?}: {}\\n\", range.range, mismatch,);\n+    if !unexpected_type_mismatches.is_empty() {\n+        format_to!(buf, \"Unexpected type mismatches:\\n{}\", unexpected_type_mismatches);\n     }\n-    assert!(buf.is_empty(), \"Unexpected type mismatches:\\n{}\", buf);\n-\n-    assert!(checked_one || allow_none, \"no `//^` annotations found\");\n+    if !mismatches.is_empty() {\n+        format_to!(buf, \"Unchecked mismatch annotations:\\n\");\n+        for m in mismatches {\n+            format_to!(buf, \"{:?}: {}\\n\", m.0.range, m.1);\n+        }\n+    }\n+    if !types.is_empty() {\n+        format_to!(buf, \"Unchecked type annotations:\\n\");\n+        for t in types {\n+            format_to!(buf, \"{:?}: type {}\\n\", t.0.range, t.1);\n+        }\n+    }\n+    assert!(buf.is_empty(), \"{}\", buf);\n }\n \n fn type_at_range(db: &TestDB, pos: FileRange) -> Ty {"}, {"sha": "24ce5bccad0fca253861cb36f04ea587ad080554", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -842,9 +842,9 @@ fn infer_two_closures_lub() {\n fn foo(c: i32) {\n     let add = |a: i32, b: i32| a + b;\n     let sub = |a, b| a - b;\n-            //^ |i32, i32| -> i32\n+            //^^^^^^^^^^^^ |i32, i32| -> i32\n     if c > 42 { add } else { sub };\n-  //^ fn(i32, i32) -> i32\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fn(i32, i32) -> i32\n }\n         \"#,\n     )"}, {"sha": "6c3d46caf086bd047129003542873924a69d144e", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -435,11 +435,11 @@ fn processes_impls_generated_by_macros() {\n macro_rules! m {\n     ($ident:ident) => (impl Trait for $ident {})\n }\n-trait Trait { fn foo(self) -> u128 {} }\n+trait Trait { fn foo(self) -> u128 { 0 } }\n struct S;\n m!(S);\n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -457,7 +457,7 @@ impl S {\n }\n \n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -479,7 +479,7 @@ impl S {\n }\n \n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -743,7 +743,7 @@ include!(\"foo.rs\");\n \n fn main() {\n     bar();\n-}     //^ u32\n+} //^^^^^ u32\n \n //- /foo.rs\n fn bar() -> u32 {0}\n@@ -781,7 +781,7 @@ include!(\"f/foo.rs\");\n \n fn main() {\n     bar::bar();\n-}          //^ u32\n+} //^^^^^^^^^^ u32\n \n //- /f/foo.rs\n pub mod bar;\n@@ -879,7 +879,7 @@ include!(concat!(\"f\", \"oo.rs\"));\n \n fn main() {\n     bar();\n-}     //^ u32\n+} //^^^^^ u32\n \n //- /foo.rs\n fn bar() -> u32 {0}\n@@ -905,7 +905,7 @@ include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"));\n \n fn main() {\n     bar();\n-}     //^ {unknown}\n+} //^^^^^ {unknown}\n \n //- /foo.rs\n fn bar() -> u32 {0}\n@@ -923,7 +923,7 @@ macro_rules! include {() => {}}\n include!(\"main.rs\");\n \n fn main() {\n-            0\n+    0;\n } //^ i32\n \"#,\n     );\n@@ -979,7 +979,7 @@ fn infer_derive_clone_simple() {\n struct S;\n fn test() {\n     S.clone();\n-}         //^ S\n+} //^^^^^^^^^ S\n \n //- /lib.rs crate:core\n pub mod prelude {\n@@ -1028,7 +1028,7 @@ pub struct S;\n use core::S;\n fn test() {\n     S.clone();\n-}         //^ S\n+} //^^^^^^^^^ S\n \"#,\n     );\n }\n@@ -1044,7 +1044,8 @@ struct S;\n struct Wrapper<T>(T);\n struct NonClone;\n fn test() {\n-    (Wrapper(S).clone(), Wrapper(NonClone).clone());\n+    let x = (Wrapper(S).clone(), Wrapper(NonClone).clone());\n+    x;\n   //^ (Wrapper<S>, {unknown})\n }\n \n@@ -1079,7 +1080,7 @@ struct S{}\n \n fn test() {\n     S{};\n-}   //^ S\n+} //^^^ S\n \"#,\n     );\n }"}, {"sha": "3f7a37295e4f54f129015dd6d530a61a9e40d32d", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 114, "deletions": 150, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -257,7 +257,7 @@ fn test() {\n mod foo {\n     struct S;\n     impl S {\n-        fn thing() -> i128 {}\n+        fn thing() -> i128 { 0 }\n     }\n }\n \"#,\n@@ -267,164 +267,128 @@ mod foo {\n #[test]\n fn infer_trait_method_simple() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait1 {\n-            fn method(&self) -> u32;\n-        }\n-        struct S1;\n-        impl Trait1 for S1 {}\n-        trait Trait2 {\n-            fn method(&self) -> i128;\n-        }\n-        struct S2;\n-        impl Trait2 for S2 {}\n-        fn test() {\n-            S1.method(); // -> u32\n-            S2.method(); // -> i128\n-        }\n+trait Trait1 {\n+    fn method(&self) -> u32;\n+}\n+struct S1;\n+impl Trait1 for S1 {}\n+trait Trait2 {\n+    fn method(&self) -> i128;\n+}\n+struct S2;\n+impl Trait2 for S2 {}\n+fn test() {\n+    S1.method();\n+  //^^^^^^^^^^^ u32\n+    S2.method(); // -> i128\n+  //^^^^^^^^^^^ i128\n+}\n         \"#,\n-        expect![[r#\"\n-            30..34 'self': &Self\n-            109..113 'self': &Self\n-            169..227 '{     ...i128 }': ()\n-            175..177 'S1': S1\n-            175..186 'S1.method()': u32\n-            202..204 'S2': S2\n-            202..213 'S2.method()': i128\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_scoped() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        struct S;\n-        mod foo {\n-            pub trait Trait1 {\n-                fn method(&self) -> u32;\n-            }\n-            impl Trait1 for super::S {}\n-        }\n-        mod bar {\n-            pub trait Trait2 {\n-                fn method(&self) -> i128;\n-            }\n-            impl Trait2 for super::S {}\n-        }\n+struct S;\n+mod foo {\n+    pub trait Trait1 {\n+        fn method(&self) -> u32;\n+    }\n+    impl Trait1 for super::S {}\n+}\n+mod bar {\n+    pub trait Trait2 {\n+        fn method(&self) -> i128;\n+    }\n+    impl Trait2 for super::S {}\n+}\n \n-        mod foo_test {\n-            use super::S;\n-            use super::foo::Trait1;\n-            fn test() {\n-                S.method(); // -> u32\n-            }\n-        }\n+mod foo_test {\n+    use super::S;\n+    use super::foo::Trait1;\n+    fn test() {\n+        S.method();\n+      //^^^^^^^^^^ u32\n+    }\n+}\n \n-        mod bar_test {\n-            use super::S;\n-            use super::bar::Trait2;\n-            fn test() {\n-                S.method(); // -> i128\n-            }\n-        }\n+mod bar_test {\n+    use super::S;\n+    use super::bar::Trait2;\n+    fn test() {\n+        S.method();\n+      //^^^^^^^^^^ i128\n+    }\n+}\n         \"#,\n-        expect![[r#\"\n-            62..66 'self': &Self\n-            168..172 'self': &Self\n-            299..336 '{     ...     }': ()\n-            309..310 'S': S\n-            309..319 'S.method()': u32\n-            415..453 '{     ...     }': ()\n-            425..426 'S': S\n-            425..435 'S.method()': i128\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_1() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait<T> {\n-            fn method(&self) -> T;\n-        }\n-        struct S;\n-        impl Trait<u32> for S {}\n-        fn test() {\n-            S.method();\n-        }\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+fn test() {\n+    S.method();\n+  //^^^^^^^^^^ u32\n+}\n         \"#,\n-        expect![[r#\"\n-            32..36 'self': &Self\n-            91..110 '{     ...d(); }': ()\n-            97..98 'S': S\n-            97..107 'S.method()': u32\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_more_params() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait<T1, T2, T3> {\n-            fn method1(&self) -> (T1, T2, T3);\n-            fn method2(&self) -> (T3, T2, T1);\n-        }\n-        struct S1;\n-        impl Trait<u8, u16, u32> for S1 {}\n-        struct S2;\n-        impl<T> Trait<i8, i16, T> for S2 {}\n-        fn test() {\n-            S1.method1(); // u8, u16, u32\n-            S1.method2(); // u32, u16, u8\n-            S2.method1(); // i8, i16, {unknown}\n-            S2.method2(); // {unknown}, i16, i8\n-        }\n+trait Trait<T1, T2, T3> {\n+    fn method1(&self) -> (T1, T2, T3);\n+    fn method2(&self) -> (T3, T2, T1);\n+}\n+struct S1;\n+impl Trait<u8, u16, u32> for S1 {}\n+struct S2;\n+impl<T> Trait<i8, i16, T> for S2 {}\n+fn test() {\n+    S1.method1();\n+  //^^^^^^^^^^^^ (u8, u16, u32)\n+    S1.method2();\n+  //^^^^^^^^^^^^ (u32, u16, u8)\n+    S2.method1();\n+  //^^^^^^^^^^^^ (i8, i16, {unknown})\n+    S2.method2();\n+  //^^^^^^^^^^^^ ({unknown}, i16, i8)\n+}\n         \"#,\n-        expect![[r#\"\n-            42..46 'self': &Self\n-            81..85 'self': &Self\n-            209..360 '{     ..., i8 }': ()\n-            215..217 'S1': S1\n-            215..227 'S1.method1()': (u8, u16, u32)\n-            249..251 'S1': S1\n-            249..261 'S1.method2()': (u32, u16, u8)\n-            283..285 'S2': S2\n-            283..295 'S2.method1()': (i8, i16, {unknown})\n-            323..325 'S2': S2\n-            323..335 'S2.method2()': ({unknown}, i16, i8)\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_2() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait<T> {\n-            fn method(&self) -> T;\n-        }\n-        struct S<T>(T);\n-        impl<U> Trait<U> for S<U> {}\n-        fn test() {\n-            S(1u32).method();\n-        }\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn test() {\n+    S(1u32).method();\n+  //^^^^^^^^^^^^^^^^ u32\n+}\n         \"#,\n-        expect![[r#\"\n-            32..36 'self': &Self\n-            101..126 '{     ...d(); }': ()\n-            107..108 'S': S<u32>(u32) -> S<u32>\n-            107..114 'S(1u32)': S<u32>\n-            107..123 'S(1u32...thod()': u32\n-            109..113 '1u32': u32\n-        \"#]],\n     );\n }\n \n@@ -685,10 +649,10 @@ fn method_resolution_unify_impl_self_type() {\n     check_types(\n         r#\"\n struct S<T>;\n-impl S<u32> { fn foo(&self) -> u8 {} }\n-impl S<i32> { fn foo(&self) -> i8 {} }\n+impl S<u32> { fn foo(&self) -> u8 { 0 } }\n+impl S<i32> { fn foo(&self) -> i8 { 0 } }\n fn test() { (S::<u32>.foo(), S::<i32>.foo()); }\n-          //^ (u8, i8)\n+          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (u8, i8)\n \"#,\n     );\n }\n@@ -702,7 +666,7 @@ struct S;\n impl S { fn foo(&self) -> i8 { 0 } }\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -716,7 +680,7 @@ struct S;\n impl Clone for S {}\n impl Clone for &S {}\n fn test() { (S.clone(), (&S).clone(), (&&S).clone()); }\n-          //^ (S, S, &S)\n+          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (S, S, &S)\n \"#,\n     );\n }\n@@ -730,7 +694,7 @@ struct S;\n impl S { fn foo(self) -> i8 { 0 } }\n impl Trait for &S { fn foo(self) -> u128 { 0 } }\n fn test() { (&S).foo(); }\n-                   //^ u128\n+          //^^^^^^^^^^ u128\n \"#,\n     );\n }\n@@ -744,7 +708,7 @@ struct S;\n impl S { fn foo(self) -> i8 { 0 } }\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n fn test() { S.foo(); }\n-                //^ i8\n+          //^^^^^^^ i8\n \"#,\n     );\n }\n@@ -758,7 +722,7 @@ struct S;\n impl S { fn foo(&self) -> i8 { 0 } }\n impl Trait for &S { fn foo(self) -> u128 { 0 } }\n fn test() { S.foo(); }\n-                //^ i8\n+          //^^^^^^^ i8\n \"#,\n     );\n }\n@@ -771,7 +735,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n fn test() { (&S).foo(); }\n-                   //^ u128\n+          //^^^^^^^^^^ u128\n \"#,\n     );\n }\n@@ -784,7 +748,7 @@ fn method_resolution_unsize_array() {\n fn test() {\n     let a = [1, 2, 3];\n     a.len();\n-}       //^ usize\n+} //^^^^^^^ usize\n \"#,\n     );\n }\n@@ -799,7 +763,7 @@ impl Clone for S {}\n \n fn test() {\n     S.clone();\n-          //^ S\n+  //^^^^^^^^^ S\n }\n \n //- /lib.rs crate:core\n@@ -823,7 +787,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T> Trait for T where T: UnknownTrait {}\n fn test() { (&S).foo(); }\n-                   //^ u128\n+          //^^^^^^^^^^ u128\n \"#,\n     );\n }\n@@ -841,7 +805,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T> Trait for T where T: Clone {}\n fn test() { (&S).foo(); }\n-                   //^ {unknown}\n+          //^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -856,7 +820,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T: Clone> Trait for T {}\n fn test() { (&S).foo(); }\n-                   //^ {unknown}\n+          //^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -871,7 +835,7 @@ struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -887,7 +851,7 @@ struct S2;\n impl From<S2> for S1 {}\n impl<T, U> Into<U> for T where U: From<T> {}\n fn test() { S2.into(); }\n-                  //^ {unknown}\n+          //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -903,7 +867,7 @@ struct S2;\n impl From<S2> for S1 {}\n impl<T, U: From<T>> Into<U> for T {}\n fn test() { S2.into(); }\n-                  //^ {unknown}\n+          //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -933,7 +897,7 @@ fn main() {\n     let a = Wrapper::<Foo<f32>>::new(1.0);\n     let b = Wrapper::<Bar<f32>>::new(1.0);\n     (a, b);\n-  //^ (Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\n+  //^^^^^^ (Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\n }\n \"#,\n     );\n@@ -947,7 +911,7 @@ fn method_resolution_encountering_fn_type() {\n fn foo() {}\n trait FnOnce { fn call(self); }\n fn test() { foo.call(); }\n-                   //^ {unknown}\n+          //^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -1013,7 +977,7 @@ where\n     Wrapper<T>: a::Foo,\n {\n     t.foo();\n-}       //^ {unknown}\n+} //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -1030,7 +994,7 @@ impl A<i32> {\n \n fn main() {\n     A::from(3);\n-}          //^ A<i32>\n+} //^^^^^^^^^^ A<i32>\n \"#,\n     );\n }\n@@ -1058,7 +1022,7 @@ trait FnX {}\n impl<B, C> Trait for S<B, C> where C: FnX, B: SendX {}\n \n fn test() { (S {}).method(); }\n-                        //^ ()\n+          //^^^^^^^^^^^^^^^ ()\n \"#,\n     );\n }\n@@ -1143,8 +1107,8 @@ impl<T> Slice<T> {\n \n fn main() {\n     let foo: Slice<u32>;\n-    (foo.into_vec()); // we don't actually support arbitrary self types, but we shouldn't crash at least\n-} //^ {unknown}\n+    foo.into_vec(); // we shouldn't crash on this at least\n+} //^^^^^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -1165,7 +1129,7 @@ impl dyn Foo + '_ {\n fn main() {\n     let f = &42u32 as &dyn Foo;\n     f.dyn_foo();\n-  // ^u32\n+ // ^^^^^^^^^^^ u32\n }\n \"#,\n     );\n@@ -1376,11 +1340,11 @@ pub trait IntoIterator {\n \n impl<T> IntoIterator for [T; 1] {\n     type Out = T;\n-    fn into_iter(self) -> Self::Out {}\n+    fn into_iter(self) -> Self::Out { loop {} }\n }\n impl<'a, T> IntoIterator for &'a [T] {\n     type Out = &'a T;\n-    fn into_iter(self) -> Self::Out {}\n+    fn into_iter(self) -> Self::Out { loop {} }\n }\n     \"#,\n     );"}, {"sha": "47aa30d2e38c8e2dea7b60ef5ef8f5c4f78c4f2a", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches, check_mismatches, check_types};\n+use super::{check, check_infer, check_infer_with_mismatches, check_types};\n \n #[test]\n fn infer_pattern() {\n@@ -518,7 +518,7 @@ fn infer_generics_in_patterns() {\n \n #[test]\n fn infer_const_pattern() {\n-    check_mismatches(\n+    check(\n         r#\"\n enum Option<T> { None }\n use Option::None;"}, {"sha": "8c5e8954c4f8765e83bed7d24ef9ff24dc1daa2b", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_types};\n+use super::{check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn bug_484() {\n@@ -422,20 +422,20 @@ fn issue_2683_chars_impl() {\n pub struct Chars<'a> {}\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> {}\n+    fn next(&mut self) -> Option<char> { loop {} }\n }\n \n fn test() {\n     let chars: Chars<'_>;\n     (chars.next(), chars.nth(1));\n-} //^ (Option<char>, Option<char>)\n+} //^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (Option<char>, Option<char>)\n \"#,\n     );\n }\n \n #[test]\n fn issue_3642_bad_macro_stackover() {\n-    check_types(\n+    check_no_mismatches(\n         r#\"\n #[macro_export]\n macro_rules! match_ast {\n@@ -452,7 +452,6 @@ macro_rules! match_ast {\n \n fn main() {\n     let anchor = match_ast! {\n-       //^ ()\n         match parent {\n             as => {},\n             _ => return None\n@@ -956,7 +955,7 @@ trait IterTrait<'a, T: 'a>: Iterator<Item = &'a T> {\n \n fn clone_iter<T>(s: Iter<T>) {\n     s.inner.clone_box();\n-    //^^^^^^^^^^^^^^^^^^^ ()\n+  //^^^^^^^^^^^^^^^^^^^ ()\n }\n \"#,\n     )"}, {"sha": "b4bcc6d953ec9936c2327a06452e08c4e5badf35", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -60,7 +60,7 @@ enum Nat { Succ(Self), Demo(Nat), Zero }\n fn test() {\n     let foo: Nat = Nat::Zero;\n     if let Nat::Succ(x) = foo {\n-        x\n+        x;\n     } //^ Nat\n }\n \"#,\n@@ -138,7 +138,7 @@ enum Option<T> { Some(T), None }\n fn test() {\n     let foo: Option<f32> = None;\n     while let Option::Some(x) = foo {\n-        x\n+        x;\n     } //^ f32\n }\n \"#,\n@@ -1745,7 +1745,7 @@ impl i32 { fn foo(&self) -> Foo { Foo } }\n fn main() {\n     let x: i32 = i32;\n     x.foo();\n-        //^ Foo\n+  //^^^^^^^ Foo\n }\"#,\n     );\n }\n@@ -1763,7 +1763,7 @@ fn main() {\n     fn inner() {}\n     let x: i32 = i32;\n     x.foo();\n-        //^ Foo\n+  //^^^^^^^ Foo\n }\"#,\n     );\n }\n@@ -1781,7 +1781,7 @@ fn foo() -> &'static str { \"\" }\n \n fn main() {\n     foo();\n-      //^ &str\n+  //^^^^^ &str\n }\"#,\n     );\n }\n@@ -1799,7 +1799,7 @@ fn foo() -> &'static str { \"\" }\n \n fn main() {\n     str::foo();\n-           //^ u32\n+  //^^^^^^^^^^ u32\n }\"#,\n     );\n }\n@@ -1825,9 +1825,9 @@ mod d {\n \n fn main() {\n     d::foo();\n-         //^ u8\n+  //^^^^^^^^ u8\n     d::foo{a:0};\n-           //^ u8\n+  //^^^^^^^^^^^ foo\n }\"#,\n     );\n }\n@@ -2677,7 +2677,7 @@ fn prelude_2015() {\n //- /main.rs edition:2015 crate:main deps:core\n fn f() {\n     Rust;\n-     //^ Rust\n+  //^^^^ Rust\n }\n \n //- /core.rs crate:core"}, {"sha": "a0ddad570d006b22adbf154940cd385544729029", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 91, "deletions": 153, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "patch": "@@ -1,6 +1,7 @@\n+use cov_mark::check;\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches, check_types};\n+use super::{check, check_infer, check_infer_with_mismatches, check_types};\n \n #[test]\n fn infer_await() {\n@@ -285,107 +286,70 @@ mod ops {\n \n #[test]\n fn infer_from_bound_1() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Trait<T> {}\n struct S<T>(T);\n impl<U> Trait<U> for S<U> {}\n fn foo<T: Trait<u32>>(t: T) {}\n fn test() {\n     let s = S(unknown);\n+           // ^^^^^^^ u32\n     foo(s);\n }\"#,\n-        expect![[r#\"\n-            85..86 't': T\n-            91..93 '{}': ()\n-            104..143 '{     ...(s); }': ()\n-            114..115 's': S<u32>\n-            118..119 'S': S<u32>(u32) -> S<u32>\n-            118..128 'S(unknown)': S<u32>\n-            120..127 'unknown': u32\n-            134..137 'foo': fn foo<S<u32>>(S<u32>)\n-            134..140 'foo(s)': ()\n-            138..139 's': S<u32>\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_from_bound_2() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Trait<T> {}\n struct S<T>(T);\n impl<U> Trait<U> for S<U> {}\n-fn foo<U, T: Trait<U>>(t: T) -> U {}\n+fn foo<U, T: Trait<U>>(t: T) -> U { loop {} }\n fn test() {\n     let s = S(unknown);\n+           // ^^^^^^^ u32\n     let x: u32 = foo(s);\n }\"#,\n-        expect![[r#\"\n-            86..87 't': T\n-            97..99 '{}': ()\n-            110..162 '{     ...(s); }': ()\n-            120..121 's': S<u32>\n-            124..125 'S': S<u32>(u32) -> S<u32>\n-            124..134 'S(unknown)': S<u32>\n-            126..133 'unknown': u32\n-            144..145 'x': u32\n-            153..156 'foo': fn foo<u32, S<u32>>(S<u32>) -> u32\n-            153..159 'foo(s)': u32\n-            157..158 's': S<u32>\n-        \"#]],\n     );\n }\n \n #[test]\n fn trait_default_method_self_bound_implements_trait() {\n     cov_mark::check!(trait_self_implements_self);\n-    check_infer(\n+    check(\n         r#\"\n trait Trait {\n     fn foo(&self) -> i64;\n-    fn bar(&self) -> {\n-        let x = self.foo();\n+    fn bar(&self) -> () {\n+        self.foo();\n+     // ^^^^^^^^^^ type: i64\n     }\n }\"#,\n-        expect![[r#\"\n-            26..30 'self': &Self\n-            52..56 'self': &Self\n-            61..96 '{     ...     }': ()\n-            75..76 'x': i64\n-            79..83 'self': &Self\n-            79..89 'self.foo()': i64\n-        \"#]],\n     );\n }\n \n #[test]\n fn trait_default_method_self_bound_implements_super_trait() {\n-    check_infer(\n+    check(\n         r#\"\n trait SuperTrait {\n     fn foo(&self) -> i64;\n }\n trait Trait: SuperTrait {\n-    fn bar(&self) -> {\n-        let x = self.foo();\n+    fn bar(&self) -> () {\n+        self.foo();\n+     // ^^^^^^^^^^ type: i64\n     }\n }\"#,\n-        expect![[r#\"\n-            31..35 'self': &Self\n-            85..89 'self': &Self\n-            94..129 '{     ...     }': ()\n-            108..109 'x': i64\n-            112..116 'self': &Self\n-            112..122 'self.foo()': i64\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_project_associated_type() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Iterable {\n     type Item;\n@@ -394,89 +358,62 @@ struct S;\n impl Iterable for S { type Item = u32; }\n fn test<T: Iterable>() {\n     let x: <S as Iterable>::Item = 1;\n-    let y: <T as Iterable>::Item = no_matter;\n-    let z: T::Item = no_matter;\n-    let a: <T>::Item = no_matter;\n+                                // ^ u32\n+    let y: <T as Iterable>::Item = u;\n+                                // ^ Iterable::Item<T>\n+    let z: T::Item = u;\n+                  // ^ Iterable::Item<T>\n+    let a: <T>::Item = u;\n+                    // ^ Iterable::Item<T>\n }\"#,\n-        expect![[r#\"\n-            108..261 '{     ...ter; }': ()\n-            118..119 'x': u32\n-            145..146 '1': u32\n-            156..157 'y': Iterable::Item<T>\n-            183..192 'no_matter': Iterable::Item<T>\n-            202..203 'z': Iterable::Item<T>\n-            215..224 'no_matter': Iterable::Item<T>\n-            234..235 'a': Iterable::Item<T>\n-            249..258 'no_matter': Iterable::Item<T>\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_return_associated_type() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Iterable {\n     type Item;\n }\n struct S;\n impl Iterable for S { type Item = u32; }\n-fn foo1<T: Iterable>(t: T) -> T::Item {}\n-fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n-fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n+fn foo1<T: Iterable>(t: T) -> T::Item { loop {} }\n+fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item { loop {} }\n+fn foo3<T: Iterable>(t: T) -> <T>::Item { loop {} }\n fn test() {\n-    let x = foo1(S);\n-    let y = foo2(S);\n-    let z = foo3(S);\n+    foo1(S);\n+ // ^^^^^^^ u32\n+    foo2(S);\n+ // ^^^^^^^ u32\n+    foo3(S);\n+ // ^^^^^^^ u32\n }\"#,\n-        expect![[r#\"\n-            106..107 't': T\n-            123..125 '{}': ()\n-            147..148 't': T\n-            178..180 '{}': ()\n-            202..203 't': T\n-            221..223 '{}': ()\n-            234..300 '{     ...(S); }': ()\n-            244..245 'x': u32\n-            248..252 'foo1': fn foo1<S>(S) -> <S as Iterable>::Item\n-            248..255 'foo1(S)': u32\n-            253..254 'S': S\n-            265..266 'y': u32\n-            269..273 'foo2': fn foo2<S>(S) -> <S as Iterable>::Item\n-            269..276 'foo2(S)': u32\n-            274..275 'S': S\n-            286..287 'z': u32\n-            290..294 'foo3': fn foo3<S>(S) -> <S as Iterable>::Item\n-            290..297 'foo3(S)': u32\n-            295..296 'S': S\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_type_bound() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Iterable {\n     type Item;\n }\n fn test<T: Iterable<Item=u32>>() {\n     let y: T::Item = unknown;\n+                  // ^^^^^^^ u32\n }\"#,\n-        expect![[r#\"\n-            67..100 '{     ...own; }': ()\n-            77..78 'y': u32\n-            90..97 'unknown': u32\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_const_body() {\n+    // FIXME make check_types work with other bodies\n     check_infer(\n         r#\"\n const A: u32 = 1 + 1;\n-static B: u64 = { let x = 1; x };\"#,\n+static B: u64 = { let x = 1; x };\n+\"#,\n         expect![[r#\"\n             15..16 '1': u32\n             15..20 '1 + 1': u32\n@@ -637,12 +574,12 @@ impl<T> core::ops::Deref for Arc<T> {\n \n struct S;\n impl S {\n-    fn foo(&self) -> u128 {}\n+    fn foo(&self) -> u128 { 0 }\n }\n \n fn test(s: Arc<S>) {\n     (*s, s.foo());\n-} //^ (S, u128)\n+} //^^^^^^^^^^^^^ (S, u128)\n \"#,\n     );\n }\n@@ -653,7 +590,7 @@ fn deref_trait_with_inference_var() {\n         r#\"\n //- minicore: deref\n struct Arc<T>;\n-fn new_arc<T>() -> Arc<T> {}\n+fn new_arc<T>() -> Arc<T> { Arc }\n impl<T> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n@@ -663,8 +600,8 @@ fn foo(a: Arc<S>) {}\n \n fn test() {\n     let a = new_arc();\n-    let b = (*a);\n-          //^ S\n+    let b = *a;\n+          //^^ S\n     foo(a);\n }\n \"#,\n@@ -684,7 +621,7 @@ impl core::ops::Deref for S {\n \n fn test(s: S) {\n     s.foo();\n-}       //^ {unknown}\n+} //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -701,12 +638,12 @@ impl<T: ?Sized> core::ops::Deref for Arc<T> {\n \n struct S;\n impl S {\n-    fn foo(&self) -> u128 {}\n+    fn foo(&self) -> u128 { 0 }\n }\n \n fn test(s: Arc<S>) {\n     (*s, s.foo());\n-} //^ (S, u128)\n+} //^^^^^^^^^^^^^ (S, u128)\n \"#,\n     );\n }\n@@ -720,11 +657,11 @@ struct S;\n trait Trait<T> {}\n impl Trait<u32> for S {}\n \n-fn foo<T: Trait<U>, U>(t: T) -> U {}\n+fn foo<T: Trait<U>, U>(t: T) -> U { loop {} }\n \n fn test(s: S) {\n-    (foo(s));\n-} //^ u32\n+    foo(s);\n+} //^^^^^^ u32\n \"#,\n     );\n }\n@@ -741,12 +678,12 @@ impl Trait<isize> for S {}\n \n struct O;\n impl O {\n-    fn foo<T: Trait<U>, U>(&self, t: T) -> U {}\n+    fn foo<T: Trait<U>, U>(&self, t: T) -> U { loop {} }\n }\n \n fn test() {\n     O.foo(S);\n-}      //^ isize\n+} //^^^^^^^^ isize\n \"#,\n     );\n }\n@@ -761,12 +698,12 @@ trait Trait<T> {}\n impl Trait<i64> for S {}\n \n impl S {\n-    fn foo<U>(&self) -> U where Self: Trait<U> {}\n+    fn foo<U>(&self) -> U where Self: Trait<U> { loop {} }\n }\n \n fn test() {\n     S.foo();\n-}       //^ i64\n+} //^^^^^^^ i64\n \"#,\n     );\n }\n@@ -782,12 +719,12 @@ impl Trait<&str> for S {}\n \n struct O<T>;\n impl<U, T: Trait<U>> O<T> {\n-    fn foo(&self) -> U {}\n+    fn foo(&self) -> U { loop {} }\n }\n \n fn test(o: O<S>) {\n     o.foo();\n-}       //^ &str\n+} //^^^^^^^ &str\n \"#,\n     );\n }\n@@ -802,7 +739,7 @@ struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n fn test<T: Clone>(t: T) { t.foo(); }\n-                             //^ u128\n+                        //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -818,7 +755,7 @@ struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n fn test<T>(t: T) { t.foo(); }\n-                       //^ {unknown}\n+                 //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -831,7 +768,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S {}\n fn test<T: Trait>(t: T) { t.foo(); }\n-                              //^ u128\n+                        //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -844,7 +781,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S {}\n fn test<T>(t: T) { t.foo(); }\n-                       //^ {unknown}\n+                 //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -858,8 +795,8 @@ trait Trait {}\n impl<T> core::ops::Deref for T where T: Trait {\n     type Target = i128;\n }\n-fn test<T: Trait>(t: T) { (*t); }\n-                        //^ i128\n+fn test<T: Trait>(t: T) { *t; }\n+                        //^^ i128\n \"#,\n     );\n }\n@@ -1380,12 +1317,12 @@ fn error_bound_chalk() {\n     check_types(\n         r#\"\n trait Trait {\n-    fn foo(&self) -> u32 {}\n+    fn foo(&self) -> u32 { 0 }\n }\n \n fn test(x: (impl Trait + UnknownTrait)) {\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -1476,7 +1413,7 @@ trait Clone {\n fn api_walkthrough() {\n     for node in foo() {\n         node.clone();\n-    }            //^ {unknown}\n+    } //^^^^^^^^^^^^ {unknown}\n }\n \"#,\n     );\n@@ -1513,13 +1450,13 @@ fn where_clause_trait_in_scope_for_method_resolution() {\n         r#\"\n mod foo {\n     trait Trait {\n-        fn foo(&self) -> u32 {}\n+        fn foo(&self) -> u32 { 0 }\n     }\n }\n \n fn test<T: foo::Trait>(x: T) {\n     x.foo();\n-}      //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -1982,7 +1919,7 @@ fn fn_item_fn_trait() {\n //- minicore: fn\n struct S;\n \n-fn foo() -> S {}\n+fn foo() -> S { S }\n \n fn takes_closure<U, F: FnOnce() -> U>(f: F) -> U { f() }\n \n@@ -2009,7 +1946,7 @@ trait Trait2 {\n fn test<T: Trait>() where T::Item: Trait2 {\n     let x: T::Item = no_matter;\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2029,7 +1966,7 @@ trait Trait2 {\n fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n     let x: T::Item = no_matter;\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2092,7 +2029,7 @@ impl Trait for S {\n \n fn test() {\n     S.f();\n-}     //^ u32\n+} //^^^^^ u32\n \"#,\n     );\n }\n@@ -2120,7 +2057,7 @@ where\n \n fn foo<I: Interner>(interner: &I, t: Ty<I>) {\n     fold(interner, t);\n-}     //^ Ty<I>\n+} //^^^^^^^^^^^^^^^^^ Ty<I>\n \"#,\n     );\n }\n@@ -2139,7 +2076,7 @@ impl Trait<Self> for S {}\n \n fn test() {\n     S.foo();\n-}       //^ ()\n+} //^^^^^^^ ()\n \"#,\n     );\n }\n@@ -2158,7 +2095,7 @@ impl Trait for S<Self> {}\n \n fn test() {\n     S.foo();\n-}       //^ {unknown}\n+} //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -2176,7 +2113,7 @@ trait Trait2<T> {}\n \n fn test<T: Trait>() where T: Trait2<T::Item> {\n     let x: T::Item = no_matter;\n-}                       //^ {unknown}\n+}                  //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -2193,7 +2130,7 @@ trait Trait<T> {\n \n fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n     let x: T::Item = no_matter;\n-}                   //^ {unknown}\n+}                  //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -2211,7 +2148,7 @@ trait Trait {\n \n fn test<T>() where T: Trait<OtherItem = T::Item> {\n     let x: T::Item = no_matter;\n-}                   //^ Trait::Item<T>\n+}                  //^^^^^^^^^ Trait::Item<T>\n \"#,\n     );\n }\n@@ -2243,7 +2180,7 @@ fn test<T>(t: T) where T: UnificationStoreMut {\n     t.push(x);\n     let y: Key<T>;\n     (x, y);\n-}      //^ (UnificationStoreBase::Key<T>, UnificationStoreBase::Key<T>)\n+} //^^^^^^ (UnificationStoreBase::Key<T>, UnificationStoreBase::Key<T>)\n \"#,\n     );\n }\n@@ -2268,7 +2205,7 @@ impl<T: Iterator> Iterator for S<T> {\n fn test<I: Iterator<Item: OtherTrait<u32>>>() {\n     let x: <S<I> as Iterator>::Item;\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2470,7 +2407,7 @@ impl<T: Trait> Trait for S<T> {\n fn test<T: Trait>() {\n     let y: <S<T> as Trait>::Item = no_matter;\n     y.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2490,7 +2427,7 @@ trait Trait {\n \n fn test(x: Box<dyn Trait>) {\n     x.foo();\n-}       //^ ()\n+} //^^^^^^^ ()\n \"#,\n     );\n }\n@@ -2509,7 +2446,7 @@ impl ToOwned for str {\n }\n fn test() {\n     \"foo\".to_owned();\n-}               //^ String\n+} //^^^^^^^^^^^^^^^^ String\n \"#,\n     );\n }\n@@ -2649,7 +2586,7 @@ impl<T:A> B for T {\n \n fn main() {\n     Bar::foo();\n-}          //^ Foo\n+} //^^^^^^^^^^ Foo\n \"#,\n     );\n }\n@@ -3002,7 +2939,7 @@ fn test() {\n     S.get(1);\n   //^^^^^^^^ u128\n     S.get(1.);\n-  //^^^^^^^^ f32\n+  //^^^^^^^^^ f32\n }\n         \"#,\n     );\n@@ -3477,14 +3414,12 @@ trait Convert {\n     fn new() -> Self;\n }\n impl Convert for u32 {\n-    fn new() -> Self {\n-        0\n-    }\n+    fn new() -> Self { 0 }\n }\n \n async fn get_accounts() -> Result<u32, ()> {\n     let ret = Fooey.collect();\n-    //                      ^ u32\n+    //        ^^^^^^^^^^^^^^^ u32\n     Ok(ret)\n }\n \"#,\n@@ -3493,6 +3428,7 @@ async fn get_accounts() -> Result<u32, ()> {\n \n #[test]\n fn local_impl_1() {\n+    check!(block_local_impls);\n     check_types(\n         r#\"\n trait Trait<T> {\n@@ -3502,7 +3438,7 @@ trait Trait<T> {\n fn test() {\n     struct S;\n     impl Trait<u32> for S {\n-        fn foo(&self) { 0 }\n+        fn foo(&self) -> u32 { 0 }\n     }\n \n     S.foo();\n@@ -3514,6 +3450,7 @@ fn test() {\n \n #[test]\n fn local_impl_2() {\n+    check!(block_local_impls);\n     check_types(\n         r#\"\n struct S;\n@@ -3523,7 +3460,7 @@ fn test() {\n         fn foo(&self) -> T;\n     }\n     impl Trait<u32> for S {\n-        fn foo(&self) { 0 }\n+        fn foo(&self) -> u32 { 0 }\n     }\n \n     S.foo();\n@@ -3535,6 +3472,7 @@ fn test() {\n \n #[test]\n fn local_impl_3() {\n+    check!(block_local_impls);\n     check_types(\n         r#\"\n trait Trait<T> {\n@@ -3547,7 +3485,7 @@ fn test() {\n         struct S2;\n \n         impl Trait<S1> for S2 {\n-            fn foo(&self) { S1 }\n+            fn foo(&self) -> S1 { S1 }\n         }\n \n         S2.foo();"}]}