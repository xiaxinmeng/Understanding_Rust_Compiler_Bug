{"sha": "d38f36e5af9d58ba4b2d234bfad2f7ec8b444674", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOGYzNmU1YWY5ZDU4YmE0YjJkMjM0YmZhZDJmN2VjOGI0NDQ2NzQ=", "commit": {"author": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-07T06:59:49Z"}, "committer": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-09T16:36:24Z"}, "message": "generate method assist uses existing impl blocks", "tree": {"sha": "633aed52db78e107ba7d9d56f0dc063071adc964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/633aed52db78e107ba7d9d56f0dc063071adc964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d38f36e5af9d58ba4b2d234bfad2f7ec8b444674", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d38f36e5af9d58ba4b2d234bfad2f7ec8b444674", "html_url": "https://github.com/rust-lang/rust/commit/d38f36e5af9d58ba4b2d234bfad2f7ec8b444674", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d38f36e5af9d58ba4b2d234bfad2f7ec8b444674/comments", "author": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99570f32d863504946bde3151eb02b7ca97f9399", "url": "https://api.github.com/repos/rust-lang/rust/commits/99570f32d863504946bde3151eb02b7ca97f9399", "html_url": "https://github.com/rust-lang/rust/commit/99570f32d863504946bde3151eb02b7ca97f9399"}], "stats": {"total": 83, "additions": 61, "deletions": 22}, "files": [{"sha": "eb698086496ea14f2363762d49dcef107beca3a4", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 61, "deletions": 22, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d38f36e5af9d58ba4b2d234bfad2f7ec8b444674/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38f36e5af9d58ba4b2d234bfad2f7ec8b444674/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=d38f36e5af9d58ba4b2d234bfad2f7ec8b444674", "patch": "@@ -1,4 +1,4 @@\n-use hir::{HirDisplay, TypeInfo};\n+use hir::{HasSource, HirDisplay, InFile, Module, TypeInfo};\n use ide_db::{base_db::FileId, helpers::SnippetCap};\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::to_lower_snake_case;\n@@ -13,7 +13,7 @@ use syntax::{\n \n use crate::{\n     utils::useless_type_special_case,\n-    utils::{render_snippet, Cursor},\n+    utils::{find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n@@ -103,10 +103,22 @@ pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Optio\n pub(crate) fn generate_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let fn_name: ast::NameRef = ctx.find_node_at_offset()?;\n     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n-    let module = ctx.sema.scope(call.syntax()).module();\n-    let ty = ctx.sema.type_of_expr(&call.receiver()?)?.as_adt()?;\n-\n-    let function_builder = FunctionBuilder::from_method_call(ctx, &call, &fn_name, module)?;\n+    let ty = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references().as_adt()?;\n+\n+    let (impl_, file) = match ty {\n+        hir::Adt::Struct(strukt) => get_impl(strukt.source(ctx.sema.db)?.syntax(), &fn_name, ctx),\n+        hir::Adt::Enum(en) => get_impl(en.source(ctx.sema.db)?.syntax(), &fn_name, ctx),\n+        hir::Adt::Union(union) => get_impl(union.source(ctx.sema.db)?.syntax(), &fn_name, ctx),\n+    }?;\n+\n+    let function_builder = FunctionBuilder::from_method_call(\n+        ctx,\n+        &call,\n+        &fn_name,\n+        &impl_,\n+        file,\n+        ty.module(ctx.sema.db),\n+    )?;\n     let target = call.syntax().text_range();\n \n     acc.add(\n@@ -116,11 +128,10 @@ pub(crate) fn generate_method(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         |builder| {\n             let function_template = function_builder.render();\n             builder.edit_file(function_template.file);\n-            let new_fn = format!(\n-                \"impl {} {{{}}}\",\n-                ty.name(ctx.sema.db),\n-                function_template.to_string(ctx.config.snippet_cap)\n-            );\n+            let mut new_fn = function_template.to_string(ctx.config.snippet_cap);\n+            if impl_.is_none() {\n+                new_fn = format!(\"\\nimpl {} {{\\n   {}\\n}}\", ty.name(ctx.sema.db), new_fn,);\n+            }\n             match ctx.config.snippet_cap {\n                 Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n                 None => builder.insert(function_template.insert_offset, new_fn),\n@@ -129,6 +140,18 @@ pub(crate) fn generate_method(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     )\n }\n \n+fn get_impl(\n+    adt: InFile<&SyntaxNode>,\n+    fn_name: &ast::NameRef,\n+    ctx: &AssistContext,\n+) -> Option<(Option<ast::Impl>, FileId)> {\n+    let file = adt.file_id.original_file(ctx.sema.db);\n+    let adt = adt.value;\n+    let adt = ast::Adt::cast(adt.clone())?;\n+    let r = find_struct_impl(ctx, &adt, fn_name.text().as_str())?;\n+    Some((r, file))\n+}\n+\n struct FunctionTemplate {\n     insert_offset: TextSize,\n     leading_ws: String,\n@@ -235,20 +258,24 @@ impl FunctionBuilder {\n         ctx: &AssistContext,\n         call: &ast::MethodCallExpr,\n         name: &ast::NameRef,\n-        target_module: Option<hir::Module>,\n+        impl_: &Option<ast::Impl>,\n+        file: FileId,\n+        target_module: Module,\n     ) -> Option<Self> {\n-        let mut file = ctx.frange.file_id;\n-        let target = match &target_module {\n-            Some(target_module) => {\n-                let module_source = target_module.definition_source(ctx.db());\n-                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n-                file = in_file;\n-                target\n+        // let mut file = ctx.frange.file_id;\n+        // let target_module = ctx.sema.scope(call.syntax()).module()?;\n+        let target = match impl_ {\n+            Some(impl_) => next_space_for_fn_in_impl(&impl_)?,\n+            None => {\n+                next_space_for_fn_in_module(\n+                    ctx.sema.db,\n+                    &target_module.definition_source(ctx.sema.db),\n+                )?\n+                .1\n             }\n-            None => next_space_for_fn_after_call_site(FuncExpr::Method(call))?,\n         };\n+\n         let needs_pub = false;\n-        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = make::name(&name.text());\n         let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Method(call))?;\n \n@@ -268,7 +295,11 @@ impl FunctionBuilder {\n         // type, but that the current state of their code doesn't allow that return type\n         // to be accurately inferred.\n         let (ret_ty, should_render_snippet) = {\n-            match ctx.sema.type_of_expr(&ast::Expr::MethodCallExpr(call.clone())) {\n+            match ctx\n+                .sema\n+                .type_of_expr(&ast::Expr::MethodCallExpr(call.clone()))\n+                .map(TypeInfo::original)\n+            {\n                 Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n                 Some(ty) => {\n                     let rendered = ty.display_source_code(ctx.db(), target_module.into());\n@@ -525,6 +556,14 @@ fn next_space_for_fn_in_module(\n     Some((file, assist_item))\n }\n \n+fn next_space_for_fn_in_impl(impl_: &ast::Impl) -> Option<GeneratedFunctionTarget> {\n+    if let Some(last_item) = impl_.assoc_item_list().and_then(|it| it.assoc_items().last()) {\n+        Some(GeneratedFunctionTarget::BehindItem(last_item.syntax().clone()))\n+    } else {\n+        Some(GeneratedFunctionTarget::InEmptyItemList(impl_.assoc_item_list()?.syntax().clone()))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};"}]}