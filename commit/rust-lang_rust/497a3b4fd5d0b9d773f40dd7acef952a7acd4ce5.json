{"sha": "497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5N2EzYjRmZDVkMGI5ZDc3M2Y0MGRkN2FjZWY5NTJhN2FjZDRjZTU=", "commit": {"author": {"name": "Eh2406", "email": "YeomanYaacov@gmail.com", "date": "2018-06-27T21:19:43Z"}, "committer": {"name": "Eh2406", "email": "YeomanYaacov@gmail.com", "date": "2018-06-28T14:18:30Z"}, "message": "fix typo and tidy", "tree": {"sha": "4d43d4715a967434778c074f8440543fe866cd68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d43d4715a967434778c074f8440543fe866cd68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "html_url": "https://github.com/rust-lang/rust/commit/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/comments", "author": {"login": "Eh2406", "id": 3709504, "node_id": "MDQ6VXNlcjM3MDk1MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3709504?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eh2406", "html_url": "https://github.com/Eh2406", "followers_url": "https://api.github.com/users/Eh2406/followers", "following_url": "https://api.github.com/users/Eh2406/following{/other_user}", "gists_url": "https://api.github.com/users/Eh2406/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eh2406/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eh2406/subscriptions", "organizations_url": "https://api.github.com/users/Eh2406/orgs", "repos_url": "https://api.github.com/users/Eh2406/repos", "events_url": "https://api.github.com/users/Eh2406/events{/privacy}", "received_events_url": "https://api.github.com/users/Eh2406/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Eh2406", "id": 3709504, "node_id": "MDQ6VXNlcjM3MDk1MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3709504?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eh2406", "html_url": "https://github.com/Eh2406", "followers_url": "https://api.github.com/users/Eh2406/followers", "following_url": "https://api.github.com/users/Eh2406/following{/other_user}", "gists_url": "https://api.github.com/users/Eh2406/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eh2406/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eh2406/subscriptions", "organizations_url": "https://api.github.com/users/Eh2406/orgs", "repos_url": "https://api.github.com/users/Eh2406/repos", "events_url": "https://api.github.com/users/Eh2406/events{/privacy}", "received_events_url": "https://api.github.com/users/Eh2406/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2c0378a63041e8c2696760039b9117251dbee30", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c0378a63041e8c2696760039b9117251dbee30", "html_url": "https://github.com/rust-lang/rust/commit/e2c0378a63041e8c2696760039b9117251dbee30"}], "stats": {"total": 47, "additions": 31, "deletions": 16}, "files": [{"sha": "249b03e0c8b5395645c0df0fa0f5cfecc49a8093", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::ty::RegionVid;\n@@ -14,7 +24,10 @@ crate struct ConstraintSet {\n \n impl ConstraintSet {\n     pub fn push(&mut self, outlives_constraint: OutlivesConstraint) {\n-        debug!(\"add_outlives({:?}: {:?} @ {:?}\", outlives_constraint.sup, outlives_constraint.sub, outlives_constraint.point);\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\",\n+               outlives_constraint.sup,\n+               outlives_constraint.sub,\n+               outlives_constraint.point);\n         if outlives_constraint.sup == outlives_constraint.sub {\n             // 'a: 'a is pretty uninteresting\n             return;\n@@ -24,12 +37,14 @@ impl ConstraintSet {\n         }\n     }\n \n-    pub fn iner(&self) -> &IndexVec<ConstraintIndex, OutlivesConstraint> {\n+    pub fn inner(&self) -> &IndexVec<ConstraintIndex, OutlivesConstraint> {\n         &self.constraints\n     }\n \n-    /// Do Not use this to add nor remove items to the Vec, nor change the `sup`, nor `sub` of the data.\n-    pub fn iner_mut(&mut self) -> &mut IndexVec<ConstraintIndex, OutlivesConstraint> {\n+    /// Do Not use this to add nor remove items to the Vec,\n+    /// nor change the `sup`,\n+    /// nor `sub` of the data.\n+    pub fn inner_mut(&mut self) -> &mut IndexVec<ConstraintIndex, OutlivesConstraint> {\n         &mut self.constraints\n     }\n }"}, {"sha": "b10e7cf21e9e54bc4477e624e67eb84bd68897a6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        let mut constraints: Vec<_> = self.constraints.iner().iter().collect();\n+        let mut constraints: Vec<_> = self.constraints.inner().iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n             let OutlivesConstraint {"}, {"sha": "f9c1b799c084488cd2355d46e5597c8a9cb96924", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "patch": "@@ -57,7 +57,7 @@ impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n         vids.into_cow()\n     }\n     fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n-        (&self.constraints.iner().raw[..]).into_cow()\n+        (&self.constraints.inner().raw[..]).into_cow()\n     }\n \n     // Render `a: b` as `a <- b`, indicating the flow"}, {"sha": "3a2eb7faaa57305e560030f5cbc9be6c46a2ec62", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=497a3b4fd5d0b9d773f40dd7acef952a7acd4ce5", "patch": "@@ -216,7 +216,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n         // The `next` field should not yet have been initialized:\n-        debug_assert!(outlives_constraints.iner().iter().all(|c| c.next.is_none()));\n+        debug_assert!(outlives_constraints.inner().iter().all(|c| c.next.is_none()));\n \n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n@@ -438,7 +438,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.iner().iter().collect();\n+            let mut constraints: Vec<_> = self.constraints.inner().iter().collect();\n             constraints.sort();\n             constraints\n         });\n@@ -450,7 +450,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let dependency_map = self.dependency_map.as_ref().unwrap();\n \n         // Constraints that may need to be repropagated (initially all):\n-        let mut dirty_list: Vec<_> = self.constraints.iner().indices().collect();\n+        let mut dirty_list: Vec<_> = self.constraints.inner().indices().collect();\n \n         // Set to 0 for each constraint that is on the dirty list:\n         let mut clean_bit_vec = BitVector::new(dirty_list.len());\n@@ -459,7 +459,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         while let Some(constraint_idx) = dirty_list.pop() {\n             clean_bit_vec.insert(constraint_idx.index());\n \n-            let constraint = &self.constraints.iner()[constraint_idx];\n+            let constraint = &self.constraints.inner()[constraint_idx];\n             debug!(\"propagate_constraints: constraint={:?}\", constraint);\n \n             if inferred_values.add_region(constraint.sup, constraint.sub) {\n@@ -471,7 +471,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     if clean_bit_vec.remove(dep_idx.index()) {\n                         dirty_list.push(dep_idx);\n                     }\n-                    opt_dep_idx = self.constraints.iner()[dep_idx].next;\n+                    opt_dep_idx = self.constraints.inner()[dep_idx].next;\n                 }\n             }\n \n@@ -488,7 +488,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n         let mut map = IndexVec::from_elem(None, &self.definitions);\n \n-        for (idx, constraint) in self.constraints.iner_mut().iter_enumerated_mut().rev() {\n+        for (idx, constraint) in self.constraints.inner_mut().iter_enumerated_mut().rev() {\n             let mut head = &mut map[constraint.sub];\n             debug_assert!(constraint.next.is_none());\n             constraint.next = *head;\n@@ -936,7 +936,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n-            let blame_span = self.constraints.iner()[blame_index].span;\n+            let blame_span = self.constraints.inner()[blame_index].span;\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -1027,7 +1027,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // - `fr1: X` transitively\n         // - and `Y` is live at `elem`\n         let index = self.blame_constraint(fr1, elem);\n-        let region_sub = self.constraints.iner()[index].sub;\n+        let region_sub = self.constraints.inner()[index].sub;\n \n         // then return why `Y` was live at `elem`\n         self.liveness_constraints.cause(region_sub, elem)\n@@ -1048,7 +1048,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // of dependencies, which doesn't account for the locations of\n         // contraints at all. But it will do for now.\n         let relevant_constraint = self.constraints\n-            .iner()\n+            .inner()\n             .iter_enumerated()\n             .filter_map(|(i, constraint)| {\n                 if !self.liveness_constraints.contains(constraint.sub, elem) {\n@@ -1084,7 +1084,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         while changed {\n             changed = false;\n-            for constraint in self.constraints.iner() {\n+            for constraint in self.constraints.inner() {\n                 if let Some(n) = result_set[constraint.sup] {\n                     let m = n + 1;\n                     if result_set[constraint.sub]"}]}