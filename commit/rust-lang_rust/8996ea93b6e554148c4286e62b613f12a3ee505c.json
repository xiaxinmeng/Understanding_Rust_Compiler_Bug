{"sha": "8996ea93b6e554148c4286e62b613f12a3ee505c", "node_id": "C_kwDOAAsO6NoAKDg5OTZlYTkzYjZlNTU0MTQ4YzQyODZlNjJiNjEzZjEyYTNlZTUwNWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-09T20:23:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-09T20:23:00Z"}, "message": "Auto merge of #107853 - Dylan-DPC:rollup-macf1qo, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #107648 (unused-lifetimes: don't warn about lifetimes originating from expanded code)\n - #107655 (rustdoc: use the same URL escape rules for fragments as for examples)\n - #107659 (test: snapshot for derive suggestion in diff files)\n - #107786 (Implement some tweaks in the new solver)\n - #107803 (Do not bring trait alias supertraits into scope)\n - #107815 (Disqualify `auto trait` built-in impl in new solver if explicit `impl` exists)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1e54719a1d3b2d503d76ad2c7f4bc77d6c51ff45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e54719a1d3b2d503d76ad2c7f4bc77d6c51ff45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8996ea93b6e554148c4286e62b613f12a3ee505c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8996ea93b6e554148c4286e62b613f12a3ee505c", "html_url": "https://github.com/rust-lang/rust/commit/8996ea93b6e554148c4286e62b613f12a3ee505c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8996ea93b6e554148c4286e62b613f12a3ee505c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "html_url": "https://github.com/rust-lang/rust/commit/8cca42a47f5d574c8f7302c98c3f918cdc772fbb"}, {"sha": "b080a1a4fc68bc6150a281f21012b79b9f1ee57f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b080a1a4fc68bc6150a281f21012b79b9f1ee57f", "html_url": "https://github.com/rust-lang/rust/commit/b080a1a4fc68bc6150a281f21012b79b9f1ee57f"}], "stats": {"total": 702, "additions": 437, "deletions": 265}, "files": [{"sha": "5f460b26488c442b7cdfa12f2499cf6fa591b1ec", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -1796,17 +1796,17 @@ impl EmitterWriter {\n                 // telling users to make a change but not clarifying *where*.\n                 let loc = sm.lookup_char_pos(parts[0].span.lo());\n                 if loc.file.name != sm.span_to_filename(span) && loc.file.name.is_real() {\n-                    buffer.puts(row_num - 1, 0, \"--> \", Style::LineNumber);\n-                    buffer.append(\n-                        row_num - 1,\n-                        &format!(\n-                            \"{}:{}:{}\",\n-                            sm.filename_for_diagnostics(&loc.file.name),\n-                            sm.doctest_offset_line(&loc.file.name, loc.line),\n-                            loc.col.0 + 1,\n-                        ),\n-                        Style::LineAndColumn,\n-                    );\n+                    let arrow = \"--> \";\n+                    buffer.puts(row_num - 1, 0, arrow, Style::LineNumber);\n+                    let filename = sm.filename_for_diagnostics(&loc.file.name);\n+                    let offset = sm.doctest_offset_line(&loc.file.name, loc.line);\n+                    let message = format!(\"{}:{}:{}\", filename, offset, loc.col.0 + 1);\n+                    if row_num == 2 {\n+                        let col = usize::max(max_line_num_len + 1, arrow.len());\n+                        buffer.puts(1, col, &message, Style::LineAndColumn);\n+                    } else {\n+                        buffer.append(row_num - 1, &message, Style::LineAndColumn);\n+                    }\n                     for _ in 0..max_line_num_len {\n                         buffer.prepend(row_num - 1, \" \", Style::NoStyle);\n                     }"}, {"sha": "0cf58179ec27210b7ec96d9e6e0dd3e8ae5c342e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -951,24 +951,38 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let trait_ref = self.tcx.mk_trait_ref(trait_def_id, trait_substs);\n \n         if self.tcx.is_trait_alias(trait_def_id) {\n-            // For trait aliases, assume all supertraits are relevant.\n-            let bounds = iter::once(ty::Binder::dummy(trait_ref));\n-            self.elaborate_bounds(bounds, |this, new_trait_ref, item| {\n-                let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n+            // For trait aliases, recursively assume all explicitly named traits are relevant\n+            for expansion in traits::expand_trait_aliases(\n+                self.tcx,\n+                iter::once((ty::Binder::dummy(trait_ref), self.span)),\n+            ) {\n+                let bound_trait_ref = expansion.trait_ref();\n+                for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n+                    if !self.has_applicable_self(&item) {\n+                        self.record_static_candidate(CandidateSource::Trait(\n+                            bound_trait_ref.def_id(),\n+                        ));\n+                    } else {\n+                        let new_trait_ref = self.erase_late_bound_regions(bound_trait_ref);\n \n-                let (xform_self_ty, xform_ret_ty) =\n-                    this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n-                this.push_candidate(\n-                    Candidate {\n-                        xform_self_ty,\n-                        xform_ret_ty,\n-                        item,\n-                        import_ids: import_ids.clone(),\n-                        kind: TraitCandidate(new_trait_ref),\n-                    },\n-                    false,\n-                );\n-            });\n+                        let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(\n+                            &item,\n+                            new_trait_ref.self_ty(),\n+                            new_trait_ref.substs,\n+                        );\n+                        self.push_candidate(\n+                            Candidate {\n+                                xform_self_ty,\n+                                xform_ret_ty,\n+                                item,\n+                                import_ids: import_ids.clone(),\n+                                kind: TraitCandidate(new_trait_ref),\n+                            },\n+                            false,\n+                        );\n+                    }\n+                }\n+            }\n         } else {\n             debug_assert!(self.tcx.is_trait(trait_def_id));\n             if self.tcx.trait_is_auto(trait_def_id) {"}, {"sha": "a9dbb3ca1319c6c0525b2bd9ef6a8762e2d04785", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -2244,19 +2244,23 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n                 None => {\n                     debug!(?param.ident, ?param.ident.span);\n-\n                     let deletion_span = deletion_span();\n-                    self.r.lint_buffer.buffer_lint_with_diagnostic(\n-                        lint::builtin::UNUSED_LIFETIMES,\n-                        param.id,\n-                        param.ident.span,\n-                        &format!(\"lifetime parameter `{}` never used\", param.ident),\n-                        lint::BuiltinLintDiagnostics::SingleUseLifetime {\n-                            param_span: param.ident.span,\n-                            use_span: None,\n-                            deletion_span,\n-                        },\n-                    );\n+                    // the give lifetime originates from expanded code so we won't be able to remove it #104432\n+                    let lifetime_only_in_expanded_code =\n+                        deletion_span.map(|sp| sp.in_derive_expansion()).unwrap_or(true);\n+                    if !lifetime_only_in_expanded_code {\n+                        self.r.lint_buffer.buffer_lint_with_diagnostic(\n+                            lint::builtin::UNUSED_LIFETIMES,\n+                            param.id,\n+                            param.ident.span,\n+                            &format!(\"lifetime parameter `{}` never used\", param.ident),\n+                            lint::BuiltinLintDiagnostics::SingleUseLifetime {\n+                                param_span: param.ident.span,\n+                                use_span: None,\n+                                deletion_span,\n+                            },\n+                        );\n+                    }\n                 }\n             }\n         }"}, {"sha": "775974d8e9a608aaefbcc5cb6c0bee561a3b4dfe", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -3,7 +3,7 @@\n use super::infcx_ext::InferCtxtExt;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -399,10 +399,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Alias(_, alias_ty) => alias_ty,\n         };\n \n-        for (assumption, _) in self\n-            .tcx()\n-            .bound_explicit_item_bounds(alias_ty.def_id)\n-            .subst_iter_copied(self.tcx(), alias_ty.substs)\n+        for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n             match G::consider_assumption(self, goal, assumption) {\n                 Ok(result) => {\n@@ -462,4 +459,78 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn merge_candidates_and_discard_reservation_impls(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.trait_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                i += 1;\n+            }\n+\n+            // If there are *STILL* multiple candidates, give up\n+            // and report ambiguity.\n+            if candidates.len() > 1 {\n+                let certainty = if candidates.iter().all(|x| {\n+                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n+                }) {\n+                    Certainty::Maybe(MaybeCause::Overflow)\n+                } else {\n+                    Certainty::AMBIGUOUS\n+                };\n+                return self.make_canonical_response(certainty);\n+            }\n+        }\n+\n+        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+    }\n+\n+    fn trait_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::AliasBound, _)\n+            | (CandidateSource::BuiltinImpl, _) => false,\n+        }\n+    }\n+\n+    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+        if let CandidateSource::Impl(def_id) = candidate.source {\n+            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n+                debug!(\"Selected reservation impl\");\n+                // We assemble all candidates inside of a probe so by\n+                // making a new canonical response here our result will\n+                // have no constraints.\n+                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+            }\n+        }\n+\n+        candidate\n+    }\n }"}, {"sha": "4fea49893a6c6c2b86de4d31e832f5310253d453", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::assembly::{self, Candidate, CandidateSource};\n+use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n use super::{Certainty, EvalCtxt, Goal, QueryResult};\n@@ -34,7 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_project_candidates(candidates)\n+            self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = match predicate.term.unpack() {\n@@ -153,59 +153,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n     }\n-\n-    fn merge_project_candidates(\n-        &mut self,\n-        mut candidates: Vec<Candidate<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n-        }\n-\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.project_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n-                    }\n-                }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                // If there are *STILL* multiple candidates, give up\n-                // and report ambiguity.\n-                i += 1;\n-                if i > 1 {\n-                    debug!(\"multiple matches, ambig\");\n-                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n-                    unimplemented!();\n-                }\n-            }\n-        }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn project_candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::BuiltinImpl, _)\n-            | (CandidateSource::AliasBound, _) => unimplemented!(),\n-        }\n-    }\n }\n \n impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n@@ -452,7 +399,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let is_sized_certainty = ecx.evaluate_goal(goal.with(tcx, sized_predicate))?.1;\n+                    let (_, is_sized_certainty) =\n+                        ecx.evaluate_goal(goal.with(tcx, sized_predicate))?;\n                     return ecx.eq_term_and_make_canonical_response(\n                         goal,\n                         is_sized_certainty,"}, {"sha": "6554c739b3f0c18c75748ab11c91a3dc0519c90e", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 16, "deletions": 69, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use super::assembly::{self, Candidate, CandidateSource};\n+use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n@@ -89,6 +89,20 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        // This differs from the current stable behavior and\n+        // fixes #84857. Due to breakage found via crater, we\n+        // currently instead lint patterns which can be used to\n+        // exploit this unsoundness on stable, see #93367 for\n+        // more details.\n+        if let Some(def_id) = ecx.tcx().find_map_relevant_impl(\n+            goal.predicate.def_id(),\n+            goal.predicate.self_ty(),\n+            Some,\n+        ) {\n+            debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");\n+            return Err(NoSolution);\n+        }\n+\n         ecx.probe_and_evaluate_goal_for_constituent_tys(\n             goal,\n             structural_traits::instantiate_constituent_tys_for_auto_trait,\n@@ -479,73 +493,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_trait_candidates_discard_reservation_impls(candidates)\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn merge_trait_candidates_discard_reservation_impls(\n-        &mut self,\n-        mut candidates: Vec<Candidate<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n-            _ => {}\n-        }\n-\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.trait_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n-                    }\n-                }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                // If there are *STILL* multiple candidates, give up\n-                // and report ambiguity.\n-                i += 1;\n-                if i > 1 {\n-                    debug!(\"multiple matches, ambig\");\n-                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n-                    unimplemented!();\n-                }\n-            }\n-        }\n-\n-        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n-    }\n-\n-    fn trait_candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => unimplemented!(),\n-        }\n-    }\n-\n-    fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n-        if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n-                debug!(\"Selected reservation impl\");\n-                // FIXME: reduce candidate to ambiguous\n-                // FIXME: replace `var_values` with identity, yeet external constraints.\n-                unimplemented!()\n-            }\n-        }\n-\n-        candidate\n+        self.merge_candidates_and_discard_reservation_impls(candidates)\n     }\n }"}, {"sha": "bafa2981a87391f2558f1ec56333086b2afd5b8f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -646,11 +646,9 @@ fn object_ty_for_trait<'tcx>(\n             debug!(?obligation);\n             let pred = obligation.predicate.to_opt_poly_projection_pred()?;\n             Some(pred.map_bound(|p| {\n-                ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n-                    def_id: p.projection_ty.def_id,\n-                    substs: p.projection_ty.substs,\n-                    term: p.term,\n-                })\n+                ty::ExistentialPredicate::Projection(ty::ExistentialProjection::erase_self_ty(\n+                    tcx, p,\n+                ))\n             }))\n         })\n         .collect();"}, {"sha": "7596e9cc005e962d15c95dcd439ebac258894854", "filename": "library/core/src/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -458,7 +458,7 @@\n //! [`Result`] of a collection of each contained value of the original\n //! [`Result`] values, or [`Err`] if any of the elements was [`Err`].\n //!\n-//! [impl-FromIterator]: Result#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E-for-Result%3CV%2C%20E%3E\n+//! [impl-FromIterator]: Result#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E\n //!\n //! ```\n //! let v = [Ok(2), Ok(4), Err(\"err!\"), Ok(8)];\n@@ -474,8 +474,8 @@\n //! to provide the [`product`][Iterator::product] and\n //! [`sum`][Iterator::sum] methods.\n //!\n-//! [impl-Product]: Result#impl-Product%3CResult%3CU%2C%20E%3E%3E-for-Result%3CT%2C%20E%3E\n-//! [impl-Sum]: Result#impl-Sum%3CResult%3CU%2C%20E%3E%3E-for-Result%3CT%2C%20E%3E\n+//! [impl-Product]: Result#impl-Product%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E\n+//! [impl-Sum]: Result#impl-Sum%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E\n //!\n //! ```\n //! let v = [Err(\"error!\"), Ok(1), Ok(2), Ok(3), Err(\"foo\")];"}, {"sha": "94de93e7a991620d386071075dd948f58dbabc59", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -46,6 +46,7 @@ use crate::html::escape::Escape;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::length_limit::HtmlWithLimit;\n+use crate::html::render::small_url_encode;\n use crate::html::toc::TocBuilder;\n \n use pulldown_cmark::{\n@@ -294,47 +295,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 doctest::make_test(&test, krate, false, &Default::default(), edition, None);\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };\n \n-            // These characters don't need to be escaped in a URI.\n-            // See https://url.spec.whatwg.org/#query-percent-encode-set\n-            // and https://url.spec.whatwg.org/#urlencoded-parsing\n-            // and https://url.spec.whatwg.org/#url-code-points\n-            fn dont_escape(c: u8) -> bool {\n-                (b'a' <= c && c <= b'z')\n-                    || (b'A' <= c && c <= b'Z')\n-                    || (b'0' <= c && c <= b'9')\n-                    || c == b'-'\n-                    || c == b'_'\n-                    || c == b'.'\n-                    || c == b','\n-                    || c == b'~'\n-                    || c == b'!'\n-                    || c == b'\\''\n-                    || c == b'('\n-                    || c == b')'\n-                    || c == b'*'\n-                    || c == b'/'\n-                    || c == b';'\n-                    || c == b':'\n-                    || c == b'?'\n-                    // As described in urlencoded-parsing, the\n-                    // first `=` is the one that separates key from\n-                    // value. Following `=`s are part of the value.\n-                    || c == b'='\n-            }\n-            let mut test_escaped = String::new();\n-            for b in test.bytes() {\n-                if dont_escape(b) {\n-                    test_escaped.push(char::from(b));\n-                } else if b == b' ' {\n-                    // URL queries are decoded with + replaced with SP\n-                    test_escaped.push('+');\n-                } else if b == b'%' {\n-                    test_escaped.push('%');\n-                    test_escaped.push('%');\n-                } else {\n-                    write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                }\n-            }\n+            let test_escaped = small_url_encode(test);\n             Some(format!(\n                 r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}&amp;edition={}\">Run</a>\"#,\n                 url, test_escaped, channel, edition,"}, {"sha": "fa22c4612051751c4a4d66d10724d6efa875dbd0", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -38,7 +38,7 @@ pub(crate) use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;\n-use std::fmt;\n+use std::fmt::{self, Write};\n use std::fs;\n use std::iter::Peekable;\n use std::path::PathBuf;\n@@ -2020,31 +2020,60 @@ fn get_associated_constants(\n         .collect::<Vec<_>>()\n }\n \n-// The point is to url encode any potential character from a type with genericity.\n-fn small_url_encode(s: String) -> String {\n+pub(crate) fn small_url_encode(s: String) -> String {\n+    // These characters don't need to be escaped in a URI.\n+    // See https://url.spec.whatwg.org/#query-percent-encode-set\n+    // and https://url.spec.whatwg.org/#urlencoded-parsing\n+    // and https://url.spec.whatwg.org/#url-code-points\n+    fn dont_escape(c: u8) -> bool {\n+        (b'a' <= c && c <= b'z')\n+            || (b'A' <= c && c <= b'Z')\n+            || (b'0' <= c && c <= b'9')\n+            || c == b'-'\n+            || c == b'_'\n+            || c == b'.'\n+            || c == b','\n+            || c == b'~'\n+            || c == b'!'\n+            || c == b'\\''\n+            || c == b'('\n+            || c == b')'\n+            || c == b'*'\n+            || c == b'/'\n+            || c == b';'\n+            || c == b':'\n+            || c == b'?'\n+            // As described in urlencoded-parsing, the\n+            // first `=` is the one that separates key from\n+            // value. Following `=`s are part of the value.\n+            || c == b'='\n+    }\n     let mut st = String::new();\n     let mut last_match = 0;\n-    for (idx, c) in s.char_indices() {\n-        let escaped = match c {\n-            '<' => \"%3C\",\n-            '>' => \"%3E\",\n-            ' ' => \"%20\",\n-            '?' => \"%3F\",\n-            '\\'' => \"%27\",\n-            '&' => \"%26\",\n-            ',' => \"%2C\",\n-            ':' => \"%3A\",\n-            ';' => \"%3B\",\n-            '[' => \"%5B\",\n-            ']' => \"%5D\",\n-            '\"' => \"%22\",\n-            _ => continue,\n-        };\n+    for (idx, b) in s.bytes().enumerate() {\n+        if dont_escape(b) {\n+            continue;\n+        }\n \n-        st += &s[last_match..idx];\n-        st += escaped;\n-        // NOTE: we only expect single byte characters here - which is fine as long as we\n-        // only match single byte characters\n+        if last_match != idx {\n+            // Invariant: `idx` must be the first byte in a character at this point.\n+            st += &s[last_match..idx];\n+        }\n+        if b == b' ' {\n+            // URL queries are decoded with + replaced with SP.\n+            // While the same is not true for hashes, rustdoc only needs to be\n+            // consistent with itself when encoding them.\n+            st += \"+\";\n+        } else if b == b'%' {\n+            st += \"%%\";\n+        } else {\n+            write!(st, \"%{:02X}\", b).unwrap();\n+        }\n+        // Invariant: if the current byte is not at the start of a multi-byte character,\n+        // we need to get down here so that when the next turn of the loop comes around,\n+        // last_match winds up equalling idx.\n+        //\n+        // In other words, dont_escape must always return `false` in multi-byte character.\n         last_match = idx + 1;\n     }\n "}, {"sha": "828486a41d465461af54d33beafe6e829011a94c", "filename": "tests/rustdoc/const-generics/const-generics-docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -21,8 +21,8 @@ pub use extern_crate::WTrait;\n //      'pub trait Trait<const N: usize>'\n // @has - '//*[@id=\"impl-Trait%3C1%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<1> for u8'\n // @has - '//*[@id=\"impl-Trait%3C2%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<2> for u8'\n-// @has - '//*[@id=\"impl-Trait%3C{1%20+%202}%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<{1 + 2}> for u8'\n-// @has - '//*[@id=\"impl-Trait%3CN%3E-for-%5Bu8%3B%20N%5D\"]//h3[@class=\"code-header\"]' \\\n+// @has - '//*[@id=\"impl-Trait%3C%7B1+%2B+2%7D%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<{1 + 2}> for u8'\n+// @has - '//*[@id=\"impl-Trait%3CN%3E-for-%5Bu8;+N%5D\"]//h3[@class=\"code-header\"]' \\\n //      'impl<const N: usize> Trait<N> for [u8; N]'\n pub trait Trait<const N: usize> {}\n impl Trait<1> for u8 {}\n@@ -47,7 +47,7 @@ impl<const M: usize> Foo<M> where u8: Trait<M> {\n     }\n }\n \n-// @has foo/struct.Bar.html '//*[@id=\"impl-Bar%3Cu8%2C%20M%3E\"]/h3[@class=\"code-header\"]' 'impl<const M: usize> Bar<u8, M>'\n+// @has foo/struct.Bar.html '//*[@id=\"impl-Bar%3Cu8,+M%3E\"]/h3[@class=\"code-header\"]' 'impl<const M: usize> Bar<u8, M>'\n impl<const M: usize> Bar<u8, M> {\n     // @has - '//*[@id=\"method.hey\"]' \\\n     //      'pub fn hey<const N: usize>(&self) -> Foo<N>where u8: Trait<N>'"}, {"sha": "152b643bf4bd8cb156acb6f3e8ec1e9612273e93", "filename": "tests/rustdoc/const-generics/const-impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fconst-generics%2Fconst-impl.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -9,20 +9,20 @@ pub enum Order {\n }\n \n // @has foo/struct.VSet.html '//pre[@class=\"rust item-decl\"]' 'pub struct VSet<T, const ORDER: Order>'\n-// @has foo/struct.VSet.html '//*[@id=\"impl-Send-for-VSet%3CT%2C%20ORDER%3E\"]/h3[@class=\"code-header\"]' 'impl<T, const ORDER: Order> Send for VSet<T, ORDER>'\n-// @has foo/struct.VSet.html '//*[@id=\"impl-Sync-for-VSet%3CT%2C%20ORDER%3E\"]/h3[@class=\"code-header\"]' 'impl<T, const ORDER: Order> Sync for VSet<T, ORDER>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-Send-for-VSet%3CT,+ORDER%3E\"]/h3[@class=\"code-header\"]' 'impl<T, const ORDER: Order> Send for VSet<T, ORDER>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-Sync-for-VSet%3CT,+ORDER%3E\"]/h3[@class=\"code-header\"]' 'impl<T, const ORDER: Order> Sync for VSet<T, ORDER>'\n pub struct VSet<T, const ORDER: Order> {\n     inner: Vec<T>,\n }\n \n-// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT%2C%20{%20Order%3A%3ASorted%20}%3E\"]/h3[@class=\"code-header\"]' 'impl<T> VSet<T, { Order::Sorted }>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT,+%7B+Order::Sorted+%7D%3E\"]/h3[@class=\"code-header\"]' 'impl<T> VSet<T, { Order::Sorted }>'\n impl<T> VSet<T, { Order::Sorted }> {\n     pub fn new() -> Self {\n         Self { inner: Vec::new() }\n     }\n }\n \n-// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT%2C%20{%20Order%3A%3AUnsorted%20}%3E\"]/h3[@class=\"code-header\"]' 'impl<T> VSet<T, { Order::Unsorted }>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT,+%7B+Order::Unsorted+%7D%3E\"]/h3[@class=\"code-header\"]' 'impl<T> VSet<T, { Order::Unsorted }>'\n impl<T> VSet<T, { Order::Unsorted }> {\n     pub fn new() -> Self {\n         Self { inner: Vec::new() }\n@@ -31,7 +31,7 @@ impl<T> VSet<T, { Order::Unsorted }> {\n \n pub struct Escape<const S: &'static str>;\n \n-// @has foo/struct.Escape.html '//*[@id=\"impl-Escape%3Cr#%22%3Cscript%3Ealert(%22Escape%22)%3B%3C/script%3E%22#%3E\"]/h3[@class=\"code-header\"]' 'impl Escape<r#\"<script>alert(\"Escape\");</script>\"#>'\n+// @has foo/struct.Escape.html '//*[@id=\"impl-Escape%3Cr%23%22%3Cscript%3Ealert(%22Escape%22);%3C/script%3E%22%23%3E\"]/h3[@class=\"code-header\"]' 'impl Escape<r#\"<script>alert(\"Escape\");</script>\"#>'\n impl Escape<r#\"<script>alert(\"Escape\");</script>\"#> {\n     pub fn f() {}\n }"}, {"sha": "4f4436377a07beb8b77cacec6454ad8c2bd53166", "filename": "tests/rustdoc/double-quote-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fdouble-quote-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fdouble-quote-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdouble-quote-escape.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -7,5 +7,5 @@ pub trait Foo<T> {\n pub struct Bar;\n \n // @has foo/struct.Bar.html\n-// @has - '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-Foo%3Cunsafe%20extern%20%22C%22%20fn()%3E-for-Bar\"]' 'Foo<unsafe extern \"C\" fn()>'\n+// @has - '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-Foo%3Cunsafe+extern+%22C%22+fn()%3E-for-Bar\"]' 'Foo<unsafe extern \"C\" fn()>'\n impl Foo<unsafe extern \"C\" fn()> for Bar {}"}, {"sha": "846028bbb1906d95697184827d5d27cdd21ca3ab", "filename": "tests/rustdoc/primitive-tuple-variadic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fprimitive-tuple-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fprimitive-tuple-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fprimitive-tuple-variadic.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -6,13 +6,13 @@\n pub trait Foo {}\n \n // @has foo/trait.Foo.html\n-// @has - '//section[@id=\"impl-Foo-for-(T%2C)\"]/h3' 'impl<T> Foo for (T\u2081, T\u2082, \u2026, T\u2099)'\n+// @has - '//section[@id=\"impl-Foo-for-(T,)\"]/h3' 'impl<T> Foo for (T\u2081, T\u2082, \u2026, T\u2099)'\n #[doc(fake_variadic)]\n impl<T> Foo for (T,) {}\n \n pub trait Bar {}\n \n // @has foo/trait.Bar.html\n-// @has - '//section[@id=\"impl-Bar-for-(U%2C)\"]/h3' 'impl<U: Foo> Bar for (U\u2081, U\u2082, \u2026, U\u2099)'\n+// @has - '//section[@id=\"impl-Bar-for-(U,)\"]/h3' 'impl<U: Foo> Bar for (U\u2081, U\u2082, \u2026, U\u2099)'\n #[doc(fake_variadic)]\n impl<U: Foo> Bar for (U,) {}"}, {"sha": "caa17dfbb1c7367cf7fd8ad3027ced0017b5b59a", "filename": "tests/rustdoc/sidebar-links-to-foreign-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fsidebar-links-to-foreign-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fsidebar-links-to-foreign-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fsidebar-links-to-foreign-impl.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -7,8 +7,8 @@\n // @has - '//h2[@id=\"foreign-impls\"]' 'Implementations on Foreign Types'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-Foo-for-u32\"]' 'u32'\n // @has - '//*[@id=\"impl-Foo-for-u32\"]//h3[@class=\"code-header\"]' 'impl Foo for u32'\n-// @has - '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-Foo-for-%26%27a%20str\"]' \"&'a str\"\n-// @has - '//*[@id=\"impl-Foo-for-%26%27a%20str\"]//h3[@class=\"code-header\"]' \"impl<'a> Foo for &'a str\"\n+// @has - \"//*[@class=\\\"sidebar-elems\\\"]//section//a[@href=\\\"#impl-Foo-for-%26'a+str\\\"]\" \"&'a str\"\n+// @has - \"//*[@id=\\\"impl-Foo-for-%26'a+str\\\"]//h3[@class=\\\"code-header\\\"]\" \"impl<'a> Foo for &'a str\"\n pub trait Foo {}\n \n impl Foo for u32 {}"}, {"sha": "b10f8f6856e8cebb90e9b5bdf87feafcc9fb8bee", "filename": "tests/rustdoc/where-clause-order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fwhere-clause-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Frustdoc%2Fwhere-clause-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhere-clause-order.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -7,7 +7,7 @@ where\n }\n \n // @has 'foo/trait.SomeTrait.html'\n-// @has - \"//*[@id='impl-SomeTrait%3C(A%2C%20B%2C%20C%2C%20D%2C%20E)%3E-for-(A%2C%20B%2C%20C%2C%20D%2C%20E)']/h3\" \"impl<A, B, C, D, E> SomeTrait<(A, B, C, D, E)> for (A, B, C, D, E)where A: PartialOrd<A> + PartialEq<A>, B: PartialOrd<B> + PartialEq<B>, C: PartialOrd<C> + PartialEq<C>, D: PartialOrd<D> + PartialEq<D>, E: PartialOrd<E> + PartialEq<E> + ?Sized, \"\n+// @has - \"//*[@id='impl-SomeTrait%3C(A,+B,+C,+D,+E)%3E-for-(A,+B,+C,+D,+E)']/h3\" \"impl<A, B, C, D, E> SomeTrait<(A, B, C, D, E)> for (A, B, C, D, E)where A: PartialOrd<A> + PartialEq<A>, B: PartialOrd<B> + PartialEq<B>, C: PartialOrd<C> + PartialEq<C>, D: PartialOrd<D> + PartialEq<D>, E: PartialOrd<E> + PartialEq<E> + ?Sized, \"\n impl<A, B, C, D, E> SomeTrait<(A, B, C, D, E)> for (A, B, C, D, E)\n where\n     A: PartialOrd<A> + PartialEq<A>,"}, {"sha": "5d5429ec895befc413b2e2cd7fd98bf7df1dbf6e", "filename": "tests/ui/lifetimes/issue-104432-unused-lifetimes-in-expansion.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Flifetimes%2Fissue-104432-unused-lifetimes-in-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Flifetimes%2Fissue-104432-unused-lifetimes-in-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-104432-unused-lifetimes-in-expansion.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![deny(unused_lifetimes)]\n+trait Trait2 {\n+    type As;\n+}\n+\n+// we should not warn about an unused lifetime about code generated from this proc macro here\n+#[derive(Clone)]\n+struct ShimMethod4<T: Trait2 + 'static>(pub &'static dyn for<'s> Fn(&'s mut T::As));\n+\n+pub fn main() {}"}, {"sha": "71b84cd30d6ff5eb313b4b3e5b39a8fec9ec5071", "filename": "tests/ui/modules/issue-107649.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Fmodules%2Fissue-107649.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Fmodules%2Fissue-107649.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodules%2Fissue-107649.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,106 @@\n+// compile-flags: -Z ui-testing=no\n+#[path = \"auxiliary/dummy_lib.rs\"]\n+mod lib;\n+\n+/// The function needs to be long enough to\n+/// ensure `max_line_num_len` to be large enough\n+/// for no-ui-testing\n+fn main() {\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    ();\n+    dbg!(lib::Dummy); //~ Error: `Dummy` doesn't implement `Debug`\n+}"}, {"sha": "1cea71f2829fd98677ada1da7b4c28d2e3fff1a3", "filename": "tests/ui/modules/issue-107649.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Fmodules%2Fissue-107649.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Fmodules%2Fissue-107649.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodules%2Fissue-107649.stderr?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: `Dummy` doesn't implement `Debug`\n+   --> $DIR/issue-107649.rs:105:5\n+    |\n+105 |     dbg!(lib::Dummy);\n+    |     ^^^^^^^^^^^^^^^^ `Dummy` cannot be formatted using `{:?}`\n+    |\n+    = help: the trait `Debug` is not implemented for `Dummy`\n+    = note: add `#[derive(Debug)]` to `Dummy` or manually `impl Debug for Dummy`\n+    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `dbg` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Dummy` with `#[derive(Debug)]`\n+   --> $DIR/auxiliary/dummy_lib.rs:2:1\n+    |\n+2   | #[derive(Debug)]\n+    |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9b41a8096c4e50cf927198d66590f14ebb4294fc", "filename": "tests/ui/traits/alias/issue-107747-do-not-assemble-supertraits.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Falias%2Fissue-107747-do-not-assemble-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Falias%2Fissue-107747-do-not-assemble-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fissue-107747-do-not-assemble-supertraits.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #107747: methods from trait alias supertraits were brought into scope\n+//\n+// check-pass\n+\n+#![feature(trait_alias)]\n+\n+use std::fmt;\n+\n+trait Foo: fmt::Debug {}\n+trait Bar = Foo;\n+\n+#[derive(Debug)]\n+struct Qux(bool);\n+\n+impl fmt::Display for Qux {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "076aefcf8fc60afedc88307195ffde433d5a5d42", "filename": "tests/ui/traits/new-solver/elaborate-item-bounds.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Felaborate-item-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Felaborate-item-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Felaborate-item-bounds.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo {\n+    type Bar: Bar;\n+}\n+\n+trait Bar: Baz {}\n+\n+trait Baz {}\n+\n+fn main() {}"}, {"sha": "254ab356ad89c2f8610a1bf2fff75ec5bc135bdb", "filename": "tests/ui/traits/new-solver/provisional-result-done.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -1,9 +1,5 @@\n // known-bug: unknown\n // compile-flags: -Ztrait-solver=next\n-// failure-status: 101\n-// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n-// rustc-env:RUST_BACKTRACE=0\n \n // This tests checks that we update results in the provisional cache when\n // we pop a goal from the stack."}, {"sha": "5bd0613d25911612d5757accb5200e92354002d7", "filename": "tests/ui/traits/new-solver/provisional-result-done.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -1,6 +1,11 @@\n-error: the compiler unexpectedly panicked. this is a bug.\n+error[E0283]: type annotations needed: cannot satisfy `Bar<T>: Coinductive`\n+  --> $DIR/provisional-result-done.rs:16:25\n+   |\n+LL | impl<T> Coinductive for Bar<T>\n+   |                         ^^^^^^\n+   |\n+   = note: cannot satisfy `Bar<T>: Coinductive`\n \n-query stack during panic:\n-#0 [check_well_formed] checking that `<impl at $DIR/provisional-result-done.rs:20:1: 20:31>` is well-formed\n-#1 [check_mod_type_wf] checking that types are well-formed in top-level module\n-end of query stack\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "18ee05457009b736a5ae53778972223f356d6bd7", "filename": "tests/ui/traits/new-solver/temporary-ambiguity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Ftemporary-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Ftemporary-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftemporary-ambiguity.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Checks that we don't explode when we assemble >1 candidate for a goal.\n+\n+struct Wrapper<T>(T);\n+\n+trait Foo {}\n+\n+impl Foo for Wrapper<i32> {}\n+\n+impl Foo for Wrapper<()> {}\n+\n+fn needs_foo(_: impl Foo) {}\n+\n+fn main() {\n+    let mut x = Default::default();\n+    let w = Wrapper(x);\n+    needs_foo(w);\n+    x = 1;\n+    drop(x);\n+}"}, {"sha": "bcfc747ebb17051dff391564569253e6ce2231b8", "filename": "tests/ui/traits/new-solver/unsafe-auto-trait-impl.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Funsafe-auto-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996ea93b6e554148c4286e62b613f12a3ee505c/tests%2Fui%2Ftraits%2Fnew-solver%2Funsafe-auto-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Funsafe-auto-trait-impl.rs?ref=8996ea93b6e554148c4286e62b613f12a3ee505c", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+struct Foo(*mut ());\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {}"}]}