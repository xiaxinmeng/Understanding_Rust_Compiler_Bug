{"sha": "a2f4d84f73647ac755871a06570fee636897b8c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZjRkODRmNzM2NDdhYzc1NTg3MWEwNjU3MGZlZTYzNjg5N2I4Yzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-13T06:29:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-13T06:29:42Z"}, "message": "Merge branch 'master' into eq-hash", "tree": {"sha": "5b97f5f94bac265baa3c1f219c5b2103fe6c6218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b97f5f94bac265baa3c1f219c5b2103fe6c6218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2f4d84f73647ac755871a06570fee636897b8c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbSEbWCRBK7hj4Ov3rIwAAdHIIAC8nVzqWi9WuE8hb5Vrul3Vn\nXLJPVt4fZF4Gv+KM6vsa20+tKZ6sPNQ0OLO/zMJ36lDnHdbmlkm1zvI+BFDczZA8\nwQ0NBl/3L7N3K7L+RFnC/jyspRf4o6gofB0ufJWSdNnZplgI8z87uRgB3F0hoZZ9\nj0NVDixI6JJjYG8gs1UmB7ys/G45QIS4Zhe5g4Ot+dZTiTMt5SRWSPLOe50DDU7J\nKwSEKm5NAGCLp08Fy7Py2ZU8+fbYkgMK9pGddKrQTrZYotmT5U7L/elBthpu9D4d\nUvezLfvdMN+Ho7o6eMf6678kQJi4i9mw6jayRfYEivym8027+ALws8arnmZY1DE=\n=+pJL\n-----END PGP SIGNATURE-----\n", "payload": "tree 5b97f5f94bac265baa3c1f219c5b2103fe6c6218\nparent 5a7f4412eed61ac82880d67d2bc5275c5dee4922\nparent 19e214e6ad3b67701549a821b3ba31b3164ecd67\nauthor Ralf Jung <post@ralfj.de> 1531463382 +0200\ncommitter GitHub <noreply@github.com> 1531463382 +0200\n\nMerge branch 'master' into eq-hash"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f4d84f73647ac755871a06570fee636897b8c7", "html_url": "https://github.com/rust-lang/rust/commit/a2f4d84f73647ac755871a06570fee636897b8c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2f4d84f73647ac755871a06570fee636897b8c7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a7f4412eed61ac82880d67d2bc5275c5dee4922", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7f4412eed61ac82880d67d2bc5275c5dee4922", "html_url": "https://github.com/rust-lang/rust/commit/5a7f4412eed61ac82880d67d2bc5275c5dee4922"}, {"sha": "19e214e6ad3b67701549a821b3ba31b3164ecd67", "url": "https://api.github.com/repos/rust-lang/rust/commits/19e214e6ad3b67701549a821b3ba31b3164ecd67", "html_url": "https://github.com/rust-lang/rust/commit/19e214e6ad3b67701549a821b3ba31b3164ecd67"}], "stats": {"total": 330, "additions": 168, "deletions": 162}, "files": [{"sha": "c46ba7c41429500fde27ea6772d9aeb1126c0deb", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -20,8 +20,8 @@ required-features = [\"cargo_miri\"]\n \n [dependencies]\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n-cargo_metadata = { version = \"0.5\", optional = true }\n-regex = \"0.2.2\"\n+cargo_metadata = { version = \"0.6\", optional = true }\n+regex = \"1.0\"\n lazy_static = \"1.0\"\n env_logger = \"0.5.0-rc.1\"\n log = \"0.4\"\n@@ -31,3 +31,4 @@ cargo_miri = [\"cargo_metadata\"]\n \n [dev-dependencies]\n compiletest_rs = { version = \"0.3.4\", features = [\"tmp\"] }\n+colored = \"1.6\""}, {"sha": "d0ae5ec46ff9d9eb498bec9701177fc193a39174", "filename": "README.md", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -42,10 +42,22 @@ cargo run --bin miri tests/run-pass-fullmir/vecs.rs # Or whatever test you like.\n \n ## Debugging\n \n-You can get detailed, statement-by-statement traces by setting the `MIRI_LOG`\n-environment variable to `trace`. These traces are indented based on call stack\n-depth. You can get a much less verbose set of information with other logging\n-levels such as `warn`.\n+Since the heart of miri (the main interpreter engine) lives in rustc, tracing\n+the interpreter requires a version of rustc compiled with tracing.  To this\n+end, you will have to compile your own rustc:\n+```\n+git clone https://github.com/rust-lang/rust/ rustc\n+cd rustc\n+cp config.toml.example config.toml\n+# Now edit `config.toml` and set `debug-assertions = true`\n+./x.py build\n+rustup toolchain link custom build/x86_64-unknown-linux-gnu/stage2\n+```\n+The `build` step can take 30 to 60 minutes.\n+\n+Now, in the miri directory, you can `rustup override set custom` and re-build\n+everything.  Finally, if you now set `RUST_LOG=rustc_mir::interpret=trace` as\n+environment variable, you will get detailed step-by-step tracing information.\n \n ## Running miri on your own project('s test suite)\n \n@@ -70,12 +82,15 @@ RUSTFLAGS='-Zalways-encode-mir' xargo build\n Now you can run miri against the libstd compiled by xargo:\n \n ```sh\n-MIRI_SYSROOT=~/.xargo/HOST cargo run --bin miri tests/run-pass-fullmir/vecs.rs\n+MIRI_SYSROOT=~/.xargo/HOST cargo run --bin miri tests/run-pass-fullmir/hashmap.rs\n ```\n \n Notice that you will have to re-run the last step of the preparations above when\n your toolchain changes (e.g., when you update the nightly).\n \n+You can also set `-Zmiri-start-fn` to make miri start evaluation with the\n+`start_fn` lang item, instead of starting at the `main` function.\n+\n ## Contributing and getting help\n \n Check out the issues on this GitHub repository for some ideas. There's lots that"}, {"sha": "51c53b4af275d03663deb1c22dc06dc6cac9fe74", "filename": "src/bin/miri.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -87,10 +87,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n         let start_fn = this.start_fn;\n         control.after_analysis.callback = Box::new(move |state| after_analysis(state, start_fn));\n-        if sess.target.target != sess.host {\n-            // only fully compile targets on the host. linking will fail for cross-compilation.\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n+        control.after_analysis.stop = Compilation::Stop;\n         control\n     }\n }\n@@ -138,13 +135,12 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>, use_start_fn: bo\n         );\n     } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items().start_fn().and_then(|start_fn| {\n-            if use_start_fn {\n-                Some(start_fn)\n-            } else {\n-                None\n-            }\n-        });\n+        // Use start_fn lang item if we have -Zmiri-start-fn set\n+        let start_wrapper = if use_start_fn {\n+            Some(tcx.lang_items().start_fn().unwrap())\n+        } else {\n+            None\n+        };\n         miri::eval_main(tcx, entry_def_id, start_wrapper);\n \n         state.session.abort_if_errors();\n@@ -232,9 +228,6 @@ fn main() {\n         }\n     });\n \n-    // Make sure we always have all the MIR (e.g. for auxilary builds in unit tests).\n-    args.push(\"-Zalways-encode-mir\".to_owned());\n-\n     rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n         default: Box::new(RustcDefaultCalls),\n         start_fn,"}, {"sha": "d2149ee5dbe7d3ee75280440acf226f16237b25f", "filename": "src/fn_call.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n-                    let ptr = self.memory.allocate(Size::from_bytes(size), align, Some(MemoryKind::C.into()))?;\n+                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MemoryKind::C.into())?;\n                     self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n                 }\n             }\n@@ -268,7 +268,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 )?;\n                 let mut args = self.frame().mir.args_iter();\n \n-                let arg_local = args.next().ok_or(\n+                let arg_local = args.next().ok_or_else(||\n                     EvalErrorKind::AbiViolation(\n                         \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n                             .to_owned(),\n@@ -395,7 +395,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     let value_copy = self.memory.allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n-                        Some(MemoryKind::Env.into()),\n+                        MemoryKind::Env.into(),\n                     )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n@@ -504,7 +504,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_type = args[0].ty.builtin_deref(true)\n-                                   .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                                   .ok_or_else(|| EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = self.layout_of(key_type)?.size;\n \n                 // Create key and write it into the memory where key_ptr wants it\n@@ -656,7 +656,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n-                                               Some(MemoryKind::Rust.into()))?;\n+                                               MemoryKind::Rust.into())?;\n                 self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::alloc::::__rust_alloc_zeroed\" => {\n@@ -670,7 +670,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n-                                               Some(MemoryKind::Rust.into()))?;\n+                                               MemoryKind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n@@ -747,7 +747,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         // current frame.\n         self.dump_local(dest);\n         self.goto_block(dest_block);\n-        return Ok(());\n+        Ok(())\n     }\n \n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {"}, {"sha": "aa699b509fad8a4210c7ac177b475afdcfe2082f", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+         if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.ptr_signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let Scalar::Ptr(ptr) = ptr {\n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             Ok(ptr)\n         } else {\n             err!(Overflow(mir::BinOp::Mul))\n-        };\n+        }\n     }\n \n     fn value_to_isize("}, {"sha": "75397262b225a1d0d30b1d0b75e8c6f8d83fbae9", "filename": "src/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -5,6 +5,8 @@\n     inclusive_range_methods,\n )]\n \n+#![cfg_attr(feature = \"cargo-clippy\", allow(cast_lossless))]\n+\n #[macro_use]\n extern crate log;\n \n@@ -24,7 +26,6 @@ use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::ty::subst::Subst;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::middle::const_val;\n \n use rustc_data_structures::fx::FxHasher;\n \n@@ -175,7 +176,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // Return value\n         let size = ecx.tcx.data_layout.pointer_size;\n         let align = ecx.tcx.data_layout.pointer_align;\n-        let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n+        let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n         cleanup_ptr = Some(ret_ptr);\n \n         // Push our stack frame\n@@ -214,7 +215,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n         let ptr_size = ecx.memory.pointer_size();\n         let ptr_align = ecx.tcx.data_layout.pointer_align;\n-        let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n+        let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, MemoryKind::Stack)?;\n         ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n         ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n         ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n@@ -273,10 +274,10 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                     block.terminator().source_info.span\n                 };\n \n-                let mut err = const_val::struct_error(ecx.tcx.tcx.at(span), \"constant evaluation error\");\n+                let mut err = struct_error(ecx.tcx.tcx.at(span), \"constant evaluation error\");\n                 let (frames, span) = ecx.generate_stacktrace(None);\n                 err.span_label(span, e.to_string());\n-                for const_val::FrameInfo { span, location, .. } in frames {\n+                for FrameInfo { span, location, .. } in frames {\n                     err.span_note(span, &format!(\"inside call to `{}`\", location));\n                 }\n                 err.emit();\n@@ -440,7 +441,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let ptr = ecx.memory.allocate(\n             layout.size,\n             layout.align,\n-            None,\n+            MemoryKind::Stack,\n         )?;\n \n         // Step 4: Cache allocation id for recursive statics\n@@ -463,14 +464,11 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 let frame = ecx.frame_mut();\n                 let bb = &frame.mir.basic_blocks()[frame.block];\n                 if bb.statements.len() == frame.stmt && !bb.is_cleanup {\n-                    match bb.terminator().kind {\n-                        ::rustc::mir::TerminatorKind::Return => {\n-                            for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n-                                // Don't deallocate locals, because the return value might reference them\n-                                frame.storage_dead(local);\n-                            }\n+                    if let ::rustc::mir::TerminatorKind::Return = bb.terminator().kind {\n+                        for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n+                            // Don't deallocate locals, because the return value might reference them\n+                            frame.storage_dead(local);\n                         }\n-                        _ => {}\n                     }\n                 }\n             }\n@@ -514,7 +512,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 value: Value::Scalar(Scalar::from_u128(match layout.size.bytes() {\n                     0 => 1 as u128,\n                     size => size as u128,\n-                }.into())),\n+                })),\n                 ty: usize,\n             },\n             dest,"}, {"sha": "9f4126ad82b60002e105863b78712e8f10ae5278", "filename": "src/locks.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -241,11 +241,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n                     // All is well\n                     continue 'locks;\n                 }\n-            } else {\n-                if !is_our_lock {\n-                    // All is well.\n-                    continue 'locks;\n-                }\n+            } else if !is_our_lock {\n+                // All is well.\n+                continue 'locks;\n             }\n             // If we get here, releasing this is an error except for NoLock.\n             if lock.active != NoLock {\n@@ -377,7 +375,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             }\n             // Clean up the map\n             alloc_locks.retain(|lock| match lock.active {\n-                NoLock => lock.suspended.len() > 0,\n+                NoLock => !lock.suspended.is_empty(),\n                 _ => true,\n             });\n         }"}, {"sha": "1440f1dab4e0fc8187cadb09490907e0d329d7b0", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset(\n-                    left.into(),\n+                    left,\n                     pointee_ty,\n                     right.to_bits(self.memory.pointer_size())? as i64,\n                 )?;"}, {"sha": "76d01ad19e3ab609e5bfafc80aed5ea3c7cf24c7", "filename": "src/range_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -19,7 +19,7 @@ pub struct RangeMap<T> {\n // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n // This kind of search breaks, if `end < start`, so don't do that!\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-struct Range {\n+pub struct Range {\n     start: u64,\n     end: u64, // Invariant: end > start\n }\n@@ -189,7 +189,7 @@ impl<T> RangeMap<T> {\n         F: FnMut(&T) -> bool,\n     {\n         let mut remove = Vec::new();\n-        for (range, data) in self.map.iter() {\n+        for (range, data) in &self.map {\n             if !f(data) {\n                 remove.push(*range);\n             }"}, {"sha": "45805f3aa8cc1199e15b24ede7dfecf42b95f57e", "filename": "src/tls.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -30,38 +30,38 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             },\n         );\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n+        new_key\n     }\n \n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.remove(&key) {\n+        match self.data.thread_local.remove(&key) {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n-        return match self.data.thread_local.get(&key) {\n+        match self.data.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.get_mut(&key) {\n+        match self.data.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n                 *data = new_data;\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     /// Returns a dtor, its argument and its index, if one is supposed to run\n@@ -104,7 +104,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n                 }\n             }\n         }\n-        return Ok(None);\n+        Ok(None)\n     }\n }\n \n@@ -124,8 +124,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 Place::undef(),\n                 StackPopCleanup::None,\n             )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(\n-                EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n+            let arg_local = self.frame().mir.args_iter().next().ok_or_else(\n+                || EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n             )?;\n             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);"}, {"sha": "758fd5d274701c409415b8e42f1504a0978eaf8d", "filename": "src/validation.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::subst::{Substs, Subst};\n use rustc::traits::{self, TraitEngine};\n use rustc::infer::InferCtxt;\n use rustc::middle::region;\n-use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{ConstValue};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::interpret::HasMemory;\n \n@@ -135,10 +135,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n     }\n \n     fn abstract_place(&self, place: &mir::Place<'tcx>) -> EvalResult<'tcx, AbsPlace<'tcx>> {\n-        Ok(match place {\n-            &mir::Place::Local(l) => AbsPlace::Local(l),\n-            &mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n-            &mir::Place::Projection(ref p) =>\n+        Ok(match *place {\n+            mir::Place::Local(l) => AbsPlace::Local(l),\n+            mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n+            mir::Place::Projection(ref p) =>\n                 AbsPlace::Projection(Box::new(self.abstract_place_projection(&*p)?)),\n         })\n     }\n@@ -378,11 +378,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         mut layout: ty::layout::TyLayout<'tcx>,\n         i: usize,\n     ) -> EvalResult<'tcx, Ty<'tcx>> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                layout = layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n+        if let Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } = base {\n+            layout = layout.for_variant(&self, variant_index);\n         }\n         let tcx = self.tcx.tcx;\n         Ok(match layout.ty.sty {\n@@ -667,12 +664,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n                     // we record the region of this borrow to the context.\n                     if query.re == None {\n-                        match *region {\n-                            ReScope(scope) => query.re = Some(scope),\n-                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                            // this functions' Subst will be erased.\n-                            _ => {}\n+                        if let ReScope(scope) = *region {\n+                            query.re = Some(scope);\n                         }\n+                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n                     }\n                     self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)?;\n                 }\n@@ -719,14 +715,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 TyArray(elem_ty, len) => {\n                     let len = match len.val {\n-                        ConstVal::Unevaluated(def_id, substs) => {\n+                        ConstValue::Unevaluated(def_id, substs) => {\n                             self.tcx.const_eval(self.tcx.param_env(def_id).and(GlobalId {\n                                 instance: Instance::new(def_id, substs),\n                                 promoted: None,\n                             }))\n                                 .map_err(|_err|EvalErrorKind::MachineError(\"<already reported>\".to_string()))?\n                         }\n-                        ConstVal::Value(_) => len,\n+                        _ => len,\n                     };\n                     let len = len.unwrap_usize(self.tcx.tcx);\n                     for i in 0..len {\n@@ -772,7 +768,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                             let variant_idx = self.read_discriminant_as_variant_index(query.place.1, query.ty)?;\n                             let variant = &adt.variants[variant_idx];\n \n-                            if variant.fields.len() > 0 {\n+                            if !variant.fields.is_empty() {\n                                 // Downcast to this variant, if needed\n                                 let place = if adt.is_enum() {\n                                     ("}, {"sha": "4b89f0ac70c79a6b7cc793c410280758a48257e5", "filename": "tests/compile-fail-fullmir/deallocate-bad-alignment.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-alignment.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -9,7 +9,7 @@ use std::alloc::*;\n \n fn main() {\n     unsafe {\n-        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1));\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n         Global.dealloc(x, Layout::from_size_align_unchecked(1, 2));\n     }\n }", "previous_filename": "tests/compile-fail/deallocate-bad-alignment.rs"}, {"sha": "3a74245816c469afdee9f172fd699e23a5934fd3", "filename": "tests/compile-fail-fullmir/deallocate-bad-size.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-size.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -9,7 +9,7 @@ use std::alloc::*;\n \n fn main() {\n     unsafe {\n-        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1));\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n         Global.dealloc(x, Layout::from_size_align_unchecked(2, 1));\n     }\n }", "previous_filename": "tests/compile-fail/deallocate-bad-size.rs"}, {"sha": "613edf3c6af95d81768c7e9ee0d269a5ee464e4e", "filename": "tests/compile-fail-fullmir/deallocate-twice.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fdeallocate-twice.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -9,7 +9,7 @@ use std::alloc::*;\n \n fn main() {\n     unsafe {\n-        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1));\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n         Global.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n         Global.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n     }", "previous_filename": "tests/compile-fail/deallocate-twice.rs"}, {"sha": "8dce7e578626403647b5764d26387798a15420b4", "filename": "tests/compile-fail-fullmir/out_of_bounds_ptr_1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/compile-fail/out_of_bounds_ptr_1.rs"}, {"sha": "e19a616a191651db51acc1fabce20565261fb500", "filename": "tests/compile-fail-fullmir/out_of_bounds_ptr_2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_2.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/compile-fail/out_of_bounds_ptr_2.rs"}, {"sha": "32ab2daebf0d0443b5aab4572cfa2e5892b1b8d5", "filename": "tests/compile-fail-fullmir/ptr_offset_overflow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fptr_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fptr_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fptr_offset_overflow.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/compile-fail/ptr_offset_overflow.rs"}, {"sha": "f85b651e857304a41e774244b288fbd2a98e6c74", "filename": "tests/compile-fail-fullmir/reallocate-bad-size.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Freallocate-bad-size.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -9,7 +9,7 @@ use std::alloc::*;\n \n fn main() {\n     unsafe {\n-        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1));\n-        let _y = Global.realloc(x, Layout::from_size_align_unchecked(2, 1), 1);\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        let _y = Global.realloc(x, Layout::from_size_align_unchecked(2, 1), 1).unwrap();\n     }\n }", "previous_filename": "tests/compile-fail/reallocate-bad-size.rs"}, {"sha": "03040cd178da2009010ad0ae5ef816bd7f849fea", "filename": "tests/compile-fail-fullmir/reallocate-change-alloc.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Freallocate-change-alloc.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -7,9 +7,9 @@ use std::alloc::*;\n \n fn main() {\n     unsafe {\n-        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1));\n-        let _y = Global.realloc(x, Layout::from_size_align_unchecked(1, 1), 1);\n-        let _z = *(x as *mut u8); //~ ERROR constant evaluation error [E0080]\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        let _y = Global.realloc(x, Layout::from_size_align_unchecked(1, 1), 1).unwrap();\n+        let _z = *(x.as_ptr() as *mut u8); //~ ERROR constant evaluation error [E0080]\n         //~^ NOTE dangling pointer was dereferenced\n     }\n }", "previous_filename": "tests/compile-fail/reallocate-change-alloc.rs"}, {"sha": "6dfb7fe2b9663b6cc637e58514ff8a079d06c37c", "filename": "tests/compile-fail-fullmir/reallocate-dangling.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Freallocate-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Freallocate-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Freallocate-dangling.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -9,8 +9,8 @@ use std::alloc::*;\n \n fn main() {\n     unsafe {\n-        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1));\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n         Global.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-        Global.realloc(x, Layout::from_size_align_unchecked(1, 1), 1);\n+        Global.realloc(x, Layout::from_size_align_unchecked(1, 1), 1).unwrap();\n     }\n }", "previous_filename": "tests/compile-fail/reallocate-dangling.rs"}, {"sha": "96006c884e5806b085aafc46e7fff5691108149b", "filename": "tests/compile-fail-fullmir/stack_free.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstack_free.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/compile-fail/stack_free.rs"}, {"sha": "0d45d70eb781ac7564c209fd3564a61642deca33", "filename": "tests/compile-fail/match_char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fmatch_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fmatch_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_char.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test FIXME: we are not checking these things on match any more?\n+\n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());\n     match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR constant evaluation error [E0080]"}, {"sha": "c03cf50eb27f613f6100a24ef02163c61a8cfe70", "filename": "tests/compile-fail/memleak.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -1,3 +1,4 @@\n+// ignore-test FIXME: leak detection is disabled\n //error-pattern: the evaluated program leaked memory\n \n fn main() {"}, {"sha": "da3a58118a2a5671f295b67f0af108889988c70a", "filename": "tests/compile-fail/memleak_rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak_rc.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -1,3 +1,4 @@\n+// ignore-test FIXME: leak detection is disabled\n //error-pattern: the evaluated program leaked memory\n \n use std::rc::Rc;"}, {"sha": "967c8b020cca099781347a769c233d13f45d4585", "filename": "tests/compile-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     // Make sure we catch overflows that would be hidden by first casting the RHS to u32\n     let _n = 1i64 >> (u32::max_value() as i64 + 1); //~ ERROR constant evaluation error [E0080]\n-    //~^ NOTE suiriuruihrihue\n+    //~^ NOTE attempt to shift right with overflow\n }"}, {"sha": "1f9e8f6e1d0b0b3af0eee73d145713785e6c8fd0", "filename": "tests/compile-fail/panic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -1,3 +1,4 @@\n+//ignore-windows\n // FIXME: Something in panic handling fails validation with full-MIR\n // compile-flags: -Zmir-emit-validate=0\n //error-pattern: the evaluated program panicked"}, {"sha": "a85ff545ee4239e36552db4e5df696acf8b579fd", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -1,3 +1,4 @@\n+// ignore-test FIXME: we are not making these statics read-only any more?\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]"}, {"sha": "24718bce7db96bb04147b4e13fe8a480dabcb43e", "filename": "tests/compile-fail/undefined_byte_read.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fundefined_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompile-fail%2Fundefined_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fundefined_byte_read.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -4,6 +4,7 @@\n fn main() {\n     let v: Vec<u8> = Vec::with_capacity(10);\n     let undef = unsafe { *v.get_unchecked(5) };\n-    let x = undef + 1; //~ ERROR: attempted to read undefined bytes\n+    let x = undef + 1; //~ ERROR: error\n+    //~^ NOTE attempted to read undefined bytes\n     panic!(\"this should never print: {}\", x);\n }", "previous_filename": "tests/compile-fail-fullmir/undefined_byte_read.rs"}, {"sha": "896d1cae5969e921c448e4df4793508f852acc5c", "filename": "tests/compiletest.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -1,6 +1,9 @@\n #![feature(slice_concat_ext)]\n \n extern crate compiletest_rs as compiletest;\n+extern crate colored;\n+\n+use colored::*;\n \n use std::slice::SliceConcatExt;\n use std::path::{PathBuf, Path};\n@@ -30,12 +33,26 @@ fn rustc_lib_path() -> PathBuf {\n     option_env!(\"RUSTC_LIB_PATH\").unwrap().into()\n }\n \n-fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: bool) {\n-    eprintln!(\n+fn have_fullmir() -> bool {\n+    // We assume we have full MIR when MIRI_SYSROOT is set or when we are in rustc\n+    std::env::var(\"MIRI_SYSROOT\").is_ok() || rustc_test_suite().is_some()\n+}\n+\n+fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir: bool) {\n+    if need_fullmir && !have_fullmir() {\n+        eprintln!(\"{}\", format!(\n+            \"## Skipping compile-fail tests in {} against miri for target {} due to missing mir\",\n+            path,\n+            target\n+        ).yellow().bold());\n+        return;\n+    }\n+\n+    eprintln!(\"{}\", format!(\n         \"## Running compile-fail tests in {} against miri for target {}\",\n         path,\n         target\n-    );\n+    ).green().bold());\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n     config.rustc_path = miri_path();\n@@ -44,52 +61,49 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: b\n         config.run_lib_path = rustc_lib_path();\n         config.compile_lib_path = rustc_lib_path();\n     }\n-    // if we are building as part of the rustc test suite, we already have fullmir for everything\n-    if fullmir && rustc_test_suite().is_none() {\n-        if host != target {\n-            // skip fullmir on nonhost\n-            return;\n-        }\n-        let sysroot = std::env::home_dir().unwrap()\n-            .join(\".xargo\")\n-            .join(\"HOST\");\n-        flags.push(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-        config.src_base = PathBuf::from(path.to_string());\n-    } else {\n-        flags.push(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-        config.src_base = PathBuf::from(path.to_string());\n-    }\n+    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n+    config.src_base = PathBuf::from(path.to_string());\n     flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     config.target_rustcflags = Some(flags.join(\" \"));\n     config.target = target.to_owned();\n+    config.host = host.to_owned();\n     compiletest::run_tests(&config);\n }\n \n-fn run_pass(path: &str) {\n-    eprintln!(\"## Running run-pass tests in {} against rustc\", path);\n+fn rustc_pass(sysroot: &Path, path: &str) {\n+    eprintln!(\"{}\", format!(\"## Running run-pass tests in {} against rustc\", path).green().bold());\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"run-pass\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n     if let Some(rustc_path) = rustc_test_suite() {\n         config.rustc_path = rustc_path;\n         config.run_lib_path = rustc_lib_path();\n         config.compile_lib_path = rustc_lib_path();\n-        config.target_rustcflags = Some(format!(\"-Dwarnings --sysroot {}\", get_sysroot().display()));\n+        config.target_rustcflags = Some(format!(\"-Dwarnings --sysroot {}\", sysroot.display()));\n     } else {\n         config.target_rustcflags = Some(\"-Dwarnings\".to_owned());\n     }\n     config.host_rustcflags = Some(\"-Dwarnings\".to_string());\n     compiletest::run_tests(&config);\n }\n \n-fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n+fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir: bool, opt: bool) {\n+    if need_fullmir && !have_fullmir() {\n+        eprintln!(\"{}\", format!(\n+            \"## Skipping run-pass tests in {} against miri for target {} due to missing mir\",\n+            path,\n+            target\n+        ).yellow().bold());\n+        return;\n+    }\n+\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n-    eprintln!(\n+    eprintln!(\"{}\", format!(\n         \"## Running run-pass tests in {} against miri for target {}{}\",\n         path,\n         target,\n         opt_str\n-    );\n+    ).green().bold());\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"ui\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n@@ -101,21 +115,9 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n         config.compile_lib_path = rustc_lib_path();\n     }\n     let mut flags = Vec::new();\n-    // Control miri logging. This is okay despite concurrent test execution as all tests\n-    // will set this env var to the same value.\n-    env::set_var(\"MIRI_LOG\", \"warn\");\n-    // if we are building as part of the rustc test suite, we already have fullmir for everything\n-    if fullmir && rustc_test_suite().is_none() {\n-        if host != target {\n-            // skip fullmir on nonhost\n-            return;\n-        }\n-        let sysroot = std::env::home_dir().unwrap()\n-            .join(\".xargo\")\n-            .join(\"HOST\");\n-\n+    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n+    if have_fullmir() {\n         flags.push(\"-Zmiri-start-fn\".to_owned());\n-        flags.push(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n     }\n     if opt {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n@@ -124,6 +126,9 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n         // For now, only validate without optimizations.  Inlining breaks validation.\n         flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     }\n+    // Control miri logging. This is okay despite concurrent test execution as all tests\n+    // will set this env var to the same value.\n+    env::set_var(\"MIRI_LOG\", \"warn\");\n     config.target_rustcflags = Some(flags.join(\" \"));\n     compiletest::run_tests(&config);\n }\n@@ -180,36 +185,39 @@ fn run_pass_miri(opt: bool) {\n     let host = get_host();\n \n     for_all_targets(&sysroot, |target| {\n-        miri_pass(\"tests/run-pass\", &target, &host, false, opt);\n+        miri_pass(&sysroot, \"tests/run-pass\", &target, &host, false, opt);\n     });\n-    miri_pass(\"tests/run-pass-fullmir\", &host, &host, true, opt);\n-}\n-\n-#[test]\n-fn run_pass_miri_noopt() {\n-    run_pass_miri(false);\n+    miri_pass(&sysroot, \"tests/run-pass-fullmir\", &host, &host, true, opt);\n }\n \n-#[test]\n-#[ignore] // FIXME: Disabled for now, as the optimizer is pretty broken and crashes...\n-fn run_pass_miri_opt() {\n-    run_pass_miri(true);\n-}\n-\n-#[test]\n fn run_pass_rustc() {\n-    run_pass(\"tests/run-pass\");\n-    run_pass(\"tests/run-pass-fullmir\");\n+    let sysroot = get_sysroot();\n+    rustc_pass(&sysroot, \"tests/run-pass\");\n+    rustc_pass(&sysroot, \"tests/run-pass-fullmir\");\n }\n \n-#[test]\n-#[should_panic] // TODO: update test errors\n fn compile_fail_miri() {\n     let sysroot = get_sysroot();\n     let host = get_host();\n \n     // FIXME: run tests for other targets, too\n-    compile_fail(&sysroot, \"tests/compile-fail\", &host, &host, true);\n-\n+    compile_fail(&sysroot, \"tests/compile-fail\", &host, &host, false);\n     compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true);\n }\n+\n+#[test]\n+fn test() {\n+    // We put everything into a single test to avoid the parallelism `cargo test`\n+    // introduces.  We still get parallelism within our tests because `compiletest`\n+    // uses `libtest` which runs jobs in parallel.\n+\n+    run_pass_rustc();\n+\n+    run_pass_miri(false);\n+\n+    // FIXME: Disabled for now, as the optimizer is pretty broken and crashes...\n+    // See https://github.com/rust-lang/rust/issues/50411\n+    //run_pass_miri(true);\n+\n+    compile_fail_miri();\n+}"}, {"sha": "beed82e058029681b73495548cea7c316098ba2c", "filename": "tests/run-pass/aux_test.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a7f4412eed61ac82880d67d2bc5275c5dee4922/tests%2Frun-pass%2Faux_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7f4412eed61ac82880d67d2bc5275c5dee4922/tests%2Frun-pass%2Faux_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Faux_test.rs?ref=5a7f4412eed61ac82880d67d2bc5275c5dee4922", "patch": "@@ -1,9 +0,0 @@\n-// aux-build:dep.rs\n-\n-// ignore-cross-compile\n-\n-extern crate dep;\n-\n-fn main() {\n-    dep::foo();\n-}"}, {"sha": "b76b4321d62aa8e066b24d213c79ccc8230b8d7b", "filename": "tests/run-pass/auxiliary/dep.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a7f4412eed61ac82880d67d2bc5275c5dee4922/tests%2Frun-pass%2Fauxiliary%2Fdep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7f4412eed61ac82880d67d2bc5275c5dee4922/tests%2Frun-pass%2Fauxiliary%2Fdep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fauxiliary%2Fdep.rs?ref=5a7f4412eed61ac82880d67d2bc5275c5dee4922", "patch": "@@ -1 +0,0 @@\n-pub fn foo() {}"}, {"sha": "917d51d0e4b654b71de324efebf5fc2dac7c9053", "filename": "tests/run-pass/heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/run-pass-fullmir/heap.rs"}, {"sha": "4a84f2bc5d62d60fa29453dc6eeef69450ad8be1", "filename": "tests/run-pass/issue-15080.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-15080.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/run-pass-fullmir/issue-15080.rs"}, {"sha": "f3c656623765fedbdede95cfa23a62ad35ecffaa", "filename": "tests/run-pass/move-arg-2-unique.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-2-unique.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/run-pass-fullmir/move-arg-2-unique.rs"}, {"sha": "74e94ddbf84f6b0b35b6c217a63e69e55bdb4171", "filename": "tests/run-pass/regions-mock-trans.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-mock-trans.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: We handle uninitialzied storage here, which currently makes validation fail.\n+// FIXME: We handle uninitialized storage here, which currently makes validation fail.\n // compile-flags: -Zmir-emit-validate=0\n \n //ignore-msvc", "previous_filename": "tests/run-pass-fullmir/regions-mock-trans.rs"}, {"sha": "9a8912a6b98897cc527c2e2c5a85aef216e5f23e", "filename": "tests/run-pass/vecs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f4d84f73647ac755871a06570fee636897b8c7/tests%2Frun-pass%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecs.rs?ref=a2f4d84f73647ac755871a06570fee636897b8c7", "previous_filename": "tests/run-pass-fullmir/vecs.rs"}]}