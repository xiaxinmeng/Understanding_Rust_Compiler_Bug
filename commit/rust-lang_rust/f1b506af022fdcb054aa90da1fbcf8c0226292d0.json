{"sha": "f1b506af022fdcb054aa90da1fbcf8c0226292d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYjUwNmFmMDIyZmRjYjA1NGFhOTBkYTFmYmNmOGMwMjI2MjkyZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T19:59:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T19:59:52Z"}, "message": "Auto merge of #53607 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #53418 (Mark some suggestions as MachineApplicable)\n - #53431 (Moved some feature gate ui tests to correct location)\n - #53442 (Update version of rls-data used with save-analysis)\n - #53504 (Set applicability for more suggestions.)\n - #53541 (Fix missing impl trait display as ret type)\n - #53544 (Point at the trait argument when using unboxed closure)\n - #53558 (Normalize source line and column numbers.)\n - #53562 (Lament the invincibility of the Turbofish)\n - #53574 (Suggest direct raw-pointer dereference)\n - #53585 (Remove super old comment on function that parses items)\n\nFailed merges:\n\n - #53472 (Use FxHash{Map,Set} instead of the default Hash{Map,Set} everywhere in rustc.)\n - #53563 (use String::new() instead of String::from(\"\"), \"\".to_string(), \"\".to_owned() or \"\".into())\n\nr? @ghost", "tree": {"sha": "43f9e1d2cac8d4a873e634ade9214a6c6baee42d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43f9e1d2cac8d4a873e634ade9214a6c6baee42d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1b506af022fdcb054aa90da1fbcf8c0226292d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b506af022fdcb054aa90da1fbcf8c0226292d0", "html_url": "https://github.com/rust-lang/rust/commit/f1b506af022fdcb054aa90da1fbcf8c0226292d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1b506af022fdcb054aa90da1fbcf8c0226292d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75b0471a8b87c44e0bd953d2a5c36d896128723", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75b0471a8b87c44e0bd953d2a5c36d896128723", "html_url": "https://github.com/rust-lang/rust/commit/b75b0471a8b87c44e0bd953d2a5c36d896128723"}, {"sha": "f012b4c84e9b44b48510712be0ce64cc964b352a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f012b4c84e9b44b48510712be0ce64cc964b352a", "html_url": "https://github.com/rust-lang/rust/commit/f012b4c84e9b44b48510712be0ce64cc964b352a"}], "stats": {"total": 538, "additions": 391, "deletions": 147}, "files": [{"sha": "eabd26c6e6707534f73df0c010ce99be341e617e", "filename": "src/Cargo.lock", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -1858,6 +1858,15 @@ dependencies = [\n  \"serde_derive 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rls-data\"\n+version = \"0.18.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rls-rustc\"\n version = \"0.5.0\"\n@@ -2382,7 +2391,7 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3286,6 +3295,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-analysis 0.14.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"96f84d303dcbe1c1bdd41b10867d3399c38fbdac32c4e3645cdb6dbd7f82db1d\"\n \"checksum rls-blacklist 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e4a9cc2545ccb7e05b355bfe047b8039a6ec12270d5f3c996b766b340a50f7d2\"\n \"checksum rls-data 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dd20763e1c60ae8945384c8a8fa4ac44f8afa7b0a817511f5e8927e5d24f988\"\n+\"checksum rls-data 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f81e838ecff6830ed33c2907fd236f38d441c206e983a2aa29fbce99295fab9\"\n \"checksum rls-rustc 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9dba7390427aefa953608429701e3665192ca810ba8ae09301e001b7c7bed0\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ecbc8541b4c341d6271eae10f869dd9d36db871afe184f5b6f9bffbd6ed0373f\""}, {"sha": "57351822cc3cfe765ebd961dde0e12c61ff470e6", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -582,6 +582,21 @@ impl<T: ?Sized> *const T {\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// # Null-unchecked version\n+    ///\n+    /// If you are sure the pointer can never be null and are looking for some kind of\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// dereference the pointer directly.\n+    ///\n+    /// ```\n+    /// let ptr: *const u8 = &10u8 as *const u8;\n+    ///\n+    /// unsafe {\n+    ///     let val_back = &*ptr;\n+    ///     println!(\"We got back the value: {}!\", val_back);\n+    /// }\n+    /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n@@ -1303,6 +1318,21 @@ impl<T: ?Sized> *mut T {\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// # Null-unchecked version\n+    ///\n+    /// If you are sure the pointer can never be null and are looking for some kind of\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// dereference the pointer directly.\n+    ///\n+    /// ```\n+    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n+    ///\n+    /// unsafe {\n+    ///     let val_back = &*ptr;\n+    ///     println!(\"We got back the value: {}!\", val_back);\n+    /// }\n+    /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {"}, {"sha": "b29ab55f9ba78a950197cb2c208ef7b8be43187c", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -17,7 +17,7 @@ use rustc::ty;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n use syntax::ast;\n use syntax_pos;\n-use errors::DiagnosticBuilder;\n+use errors::{DiagnosticBuilder, Applicability};\n use borrowck::gather_loans::gather_moves::PatternSource;\n \n pub struct MoveErrorCollector<'tcx> {\n@@ -80,9 +80,12 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n                 let initializer =\n                     e.init.as_ref().expect(\"should have an initializer to get an error\");\n                 if let Ok(snippet) = bccx.tcx.sess.source_map().span_to_snippet(initializer.span) {\n-                    err.span_suggestion(initializer.span,\n-                                        \"consider using a reference instead\",\n-                                        format!(\"&{}\", snippet));\n+                    err.span_suggestion_with_applicability(\n+                        initializer.span,\n+                        \"consider using a reference instead\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::MaybeIncorrect // using a reference may not be the right fix\n+                    );\n                 }\n             }\n             _ => {"}, {"sha": "b8d6df368d47879e256892493136d357d1a457c8", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -13,6 +13,7 @@ use rustc::hir::{self, HirId};\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::ty;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use errors::Applicability;\n use std::slice;\n use syntax::ptr::P;\n \n@@ -83,7 +84,11 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n                                      hir_id,\n                                      span,\n                                      \"variable does not need to be mutable\")\n-                .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+                .span_suggestion_short_with_applicability(\n+                    mut_span,\n+                    \"remove this `mut`\",\n+                    \"\".to_owned(),\n+                    Applicability::MachineApplicable)\n                 .emit();\n         }\n     }"}, {"sha": "b6f7347dd574d8e81be9bf05695dd22f0f1f5f97", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -24,7 +24,7 @@ use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n \n-use rustc_errors::{Diagnostic, DiagnosticBuilder, Level};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -324,7 +324,11 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n                 span,\n                 \"variable does not need to be mutable\",\n             );\n-            err.span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned());\n+            err.span_suggestion_short_with_applicability(\n+                mut_span,\n+                \"remove this `mut`\",\n+                \"\".to_owned(),\n+                Applicability::MachineApplicable);\n \n             err.buffer(&mut mbcx.errors_buffer);\n         }"}, {"sha": "bca119660aa2a4e93a9dd14768fa1d64b0dd2032", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -25,6 +25,7 @@ use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;\n+use errors::Applicability;\n \n struct AstValidator<'a> {\n     session: &'a Session,\n@@ -185,11 +186,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 );\n                 match val.node {\n                     ExprKind::Lit(ref v) if v.node.is_numeric() => {\n-                        err.span_suggestion(\n+                        err.span_suggestion_with_applicability(\n                             place.span.between(val.span),\n                             \"if you meant to write a comparison against a negative value, add a \\\n                              space in between `<` and `-`\",\n                             \"< -\".to_string(),\n+                            Applicability::MaybeIncorrect\n                         );\n                     }\n                     _ => {}"}, {"sha": "fcdb8fb1465eb2ab0f01f861e1919d685ad26e79", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -38,6 +38,7 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::{TokenStream, TokenTree, Delimited};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n+use errors::Applicability;\n \n use std::cell::Cell;\n use std::mem;\n@@ -938,9 +939,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         if let Some(suggestion) = suggestion {\n             if suggestion != name {\n                 if let MacroKind::Bang = kind {\n-                    err.span_suggestion(span, \"you could try the macro\", suggestion.to_string());\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"you could try the macro\",\n+                        suggestion.to_string(),\n+                        Applicability::MaybeIncorrect\n+                    );\n                 } else {\n-                    err.span_suggestion(span, \"try\", suggestion.to_string());\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"try\",\n+                        suggestion.to_string(),\n+                        Applicability::MaybeIncorrect\n+                    );\n                 }\n             } else {\n                 err.help(\"have you added the `#[macro_use]` on the module/import?\");\n@@ -1065,10 +1076,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             if let Some(span) = span {\n                 let found_use = if found_use { \"\" } else { \"\\n\" };\n                 self.session.struct_span_err(err.use_span, err.warn_msg)\n-                    .span_suggestion(\n+                    .span_suggestion_with_applicability(\n                         span,\n                         \"instead, import the procedural macro like any other item\",\n                         format!(\"use {}::{};{}\", err.crate_name, err.name, found_use),\n+                        Applicability::MachineApplicable\n                     ).emit();\n             } else {\n                 self.session.struct_span_err(err.use_span, err.warn_msg)"}, {"sha": "2dbea2155aec2094eb2d7bcfd5ca3370b409449e", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -16,7 +16,7 @@ rustc_target = { path = \"../librustc_target\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rls-data = \"0.16\"\n+rls-data = \"0.18\"\n rls-span = \"0.4\"\n # FIXME(#40527) should move rustc serialize out of tree\n rustc-serialize = \"0.3\""}, {"sha": "53186c64befd3aaac1cb84da6af62772645ef1e6", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoB\n use rustc_target::spec::abi;\n use syntax::ast::Ident;\n use syntax_pos::Span;\n+use errors::Applicability;\n \n use rustc::hir;\n \n@@ -234,10 +235,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(call_expr.span, \"not a function\");\n \n                 if let Some(ref path) = unit_variant {\n-                    err.span_suggestion(call_expr.span,\n-                                        &format!(\"`{}` is a unit variant, you need to write it \\\n-                                                  without the parenthesis\", path),\n-                                        path.to_string());\n+                    err.span_suggestion_with_applicability(\n+                        call_expr.span,\n+                        &format!(\"`{}` is a unit variant, you need to write it \\\n+                                 without the parenthesis\", path),\n+                        path.to_string(),\n+                        Applicability::MachineApplicable\n+                    );\n                 }\n \n                 if let hir::ExprKind::Call(ref expr, _) = call_expr.node {"}, {"sha": "b0b2799c793b28957ff3a4b9c7fca6daceb9e86c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 146, "deletions": 95, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::map::{NodeItem, NodeExpr};\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n-use errors::{DiagnosticBuilder, SourceMapper};\n+use errors::{Applicability, DiagnosticBuilder, SourceMapper};\n \n use super::method::probe;\n \n@@ -422,24 +422,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect // lossy conversion\n+                                );\n                             }\n                         }\n                         (None, _) | (_, None) => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_isize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect // lossy conversion\n+                                );\n                             }\n                         }\n                         _ => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                into_suggestion);\n+                            err.span_suggestion_with_applicability(\n+                                expr.span,\n+                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                into_suggestion,\n+                                Applicability::MachineApplicable\n+                            );\n                         }\n                     }\n                     true\n@@ -448,24 +455,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                         }\n                         (None, _) | (_, None) => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_usize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                         }\n                         _ => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n-                                                into_suggestion);\n+                            err.span_suggestion_with_applicability(\n+                                expr.span,\n+                                &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                into_suggestion,\n+                                Applicability::MachineApplicable\n+                            );\n                         }\n                     }\n                     true\n@@ -474,33 +488,44 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found > exp - 1 => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (None, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (None, _) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_isize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (_, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_usize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             _ => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                    cast_suggestion,\n+                                    Applicability::MachineApplicable\n+                                );\n                             }\n                         }\n                     }\n@@ -510,58 +535,75 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found - 1 > exp => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (None, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                    cast_suggestion,\n+                                    Applicability::MachineApplicable  // lossy conversion\n+                                );\n                             }\n                             (None, _) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_usize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (_, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_isize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             _ => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                    cast_suggestion,\n+                                    Applicability::MachineApplicable\n+                                );\n                             }\n                         }\n                     }\n                     true\n                 }\n                 (&ty::Float(ref exp), &ty::Float(ref found)) => {\n                     if found.bit_width() < exp.bit_width() {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{} in a lossless way\",\n-                                                     msg),\n-                                            into_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{} in a lossless way\", msg),\n+                            into_suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     } else if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the closest possible value\",\n-                                                     msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the closest possible value\", msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                     }\n                     true\n                 }\n                 (&ty::Uint(_), &ty::Float(_)) | (&ty::Int(_), &ty::Float(_)) => {\n                     if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, rounding the float towards zero\",\n-                                                     msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, rounding the float towards zero\", msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                         err.warn(\"casting here will cause undefined behavior if the rounded value \\\n                                   cannot be represented by the target integer type, including \\\n                                   `Inf` and `NaN` (this is a bug and will be fixed)\");\n@@ -571,36 +613,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n                     // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer\",\n-                                                      msg),\n-                                            into_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer\",\n+                                      msg),\n+                            into_suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     } else if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer, rounded if \\\n-                                                      necessary\",\n-                                                      msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer, rounded if necessary\",\n+                                      msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                     }\n                     true\n                 }\n                 (&ty::Float(ref exp), &ty::Int(ref found)) => {\n                     // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer\",\n-                                                      msg),\n-                                            into_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer\",\n+                                      msg),\n+                            into_suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     } else if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer, rounded if \\\n-                                                      necessary\",\n-                                                      msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer, rounded if necessary\",\n+                                      msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                     }\n                     true\n                 }"}, {"sha": "14e36ba3429eccd4482af8ee412c177f48c1d1a9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -24,7 +24,7 @@ use util::nodemap::FxHashSet;\n \n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::{Span, FileName};\n \n \n@@ -407,11 +407,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 if static_sources.len() == 1 {\n                     if let Some(expr) = rcvr_expr {\n-                        err.span_suggestion(expr.span.to(span),\n+                        err.span_suggestion_with_applicability(expr.span.to(span),\n                                             \"use associated function syntax instead\",\n                                             format!(\"{}::{}\",\n                                                     self.ty_to_string(actual),\n-                                                    item_name));\n+                                                    item_name),\n+                                            Applicability::MachineApplicable);\n                     } else {\n                         err.help(&format!(\"try with `{}::{}`\",\n                                           self.ty_to_string(actual), item_name));"}, {"sha": "aa05191cd4ae6af4abc822237dc811b91055130c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -102,7 +102,7 @@ use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoB\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n-use errors::{DiagnosticBuilder, DiagnosticId};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n@@ -2678,10 +2678,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let sugg_span = tcx.sess.source_map().end_point(expr_sp);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n-                err.span_suggestion(\n+                err.span_suggestion_with_applicability(\n                     sugg_span,\n                     \"expected the unit value `()`; create it with empty parentheses\",\n-                    String::from(\"()\"));\n+                    String::from(\"()\"),\n+                    Applicability::MachineApplicable);\n             } else {\n                 err.span_label(sp, format!(\"expected {}{} parameter{}\",\n                                             if variadic {\"at least \"} else {\"\"},\n@@ -2943,7 +2944,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.tcx.sess.source_map().span_to_snippet(lhs.span),\n                         self.tcx.sess.source_map().span_to_snippet(rhs.span))\n                     {\n-                        err.span_suggestion(expr.span, msg, format!(\"{} == {}\", left, right));\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            msg,\n+                            format!(\"{} == {}\", left, right),\n+                            Applicability::MaybeIncorrect);\n                     } else {\n                         err.help(msg);\n                     }\n@@ -4237,9 +4242,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.source_map().span_to_snippet(base.span);\n                                         if let Ok(snip) = snip {\n-                                            err.span_suggestion(expr.span,\n-                                                                \"to access tuple elements, use\",\n-                                                                format!(\"{}.{}\", snip, i));\n+                                            err.span_suggestion_with_applicability(\n+                                                expr.span,\n+                                                \"to access tuple elements, use\",\n+                                                format!(\"{}.{}\", snip, i),\n+                                                Applicability::MachineApplicable);\n                                             needs_note = false;\n                                         }\n                                     }\n@@ -4677,9 +4684,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::ExprKind::Match(..) |\n                 hir::ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.source_map().next_point(cause_span);\n-                    err.span_suggestion(sp,\n-                                        \"try adding a semicolon\",\n-                                        \";\".to_string());\n+                    err.span_suggestion_with_applicability(\n+                        sp,\n+                        \"try adding a semicolon\",\n+                        \";\".to_string(),\n+                        Applicability::MachineApplicable);\n                 }\n                 _ => (),\n             }\n@@ -4708,10 +4717,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n         match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_nil()) {\n             (&hir::FunctionRetTy::DefaultReturn(span), true, true, true) => {\n-                err.span_suggestion(span,\n-                                    \"try adding a return type\",\n-                                    format!(\"-> {} \",\n-                                            self.resolve_type_vars_with_obligations(found)));\n+                err.span_suggestion_with_applicability(\n+                    span,\n+                    \"try adding a return type\",\n+                    format!(\"-> {} \", self.resolve_type_vars_with_obligations(found)),\n+                    Applicability::MachineApplicable);\n             }\n             (&hir::FunctionRetTy::DefaultReturn(span), false, true, true) => {\n                 err.span_label(span, \"possibly return type missing here?\");\n@@ -4770,7 +4780,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n         let span_semi = original_span.with_lo(original_span.hi() - BytePos(1));\n-        err.span_suggestion(span_semi, \"consider removing this semicolon\", \"\".to_string());\n+        err.span_suggestion_with_applicability(\n+            span_semi,\n+            \"consider removing this semicolon\",\n+            \"\".to_string(),\n+            Applicability::MachineApplicable);\n     }\n \n     fn def_ids_for_path_segments(&self,"}, {"sha": "62015907f0c8e608ff7df79bfe22e033fb111de0", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -11,6 +11,7 @@\n use lint;\n use rustc::ty::TyCtxt;\n \n+use errors::Applicability;\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -138,7 +139,11 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             let id = tcx.hir.hir_to_node_id(hir_id);\n             let msg = \"unused extern crate\";\n             tcx.struct_span_lint_node(lint, id, span, msg)\n-                .span_suggestion_short(span, \"remove it\", \"\".to_string())\n+                .span_suggestion_short_with_applicability(\n+                    span,\n+                    \"remove it\",\n+                    \"\".to_string(),\n+                    Applicability::MachineApplicable)\n                 .emit();\n             continue;\n         }"}, {"sha": "b660613bb9faf4e88ab1a485326d783a5208e252", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -2378,6 +2378,7 @@ impl From<ast::FloatTy> for PrimitiveType {\n impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n+\n         match self.node {\n             TyKind::Never => Never,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n@@ -2415,6 +2416,14 @@ impl Clean<Type> for hir::Ty {\n                     if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did) {\n                         return ImplTrait(bounds);\n                     }\n+                } else if let Def::Existential(did) = path.def {\n+                    // This block is for returned impl trait only.\n+                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(did) {\n+                        let item = cx.tcx.hir.expect_item(node_id);\n+                        if let hir::ItemKind::Existential(ref ty) = item.node {\n+                            return ImplTrait(ty.bounds.clean(cx));\n+                        }\n+                    }\n                 }\n \n                 let mut alias = None;"}, {"sha": "03bf1b5a4e1ed53069e3ddc118a04e1bc8ce9007", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -12,7 +12,7 @@\n // http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n use syntax_pos::{Span, NO_EXPANSION};\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n use super::StringReader;\n \n const UNICODE_ARRAY: &[(char, &str, char)] = &[\n@@ -346,7 +346,11 @@ crate fn check_for_substitution<'a>(reader: &StringReader<'a>,\n                 let msg =\n                     format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n                             ch, u_name, ascii_char, ascii_name);\n-                err.span_suggestion(span, &msg, ascii_char.to_string());\n+                err.span_suggestion_with_applicability(\n+                    span,\n+                    &msg,\n+                    ascii_char.to_string(),\n+                    Applicability::MaybeIncorrect);\n                 true\n             },\n             None => {"}, {"sha": "e85b5dca2b73b16f1a15d957f011200dd5044948", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -1079,12 +1079,13 @@ impl<'a> Parser<'a> {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n-    fn parse_seq_to_before_tokens<T, F>(&mut self,\n-                                            kets: &[&token::Token],\n-                                            sep: SeqSep,\n-                                            expect: TokenExpectType,\n-                                            mut f: F)\n-                                            -> PResult<'a, Vec<T>>\n+    fn parse_seq_to_before_tokens<T, F>(\n+        &mut self,\n+        kets: &[&token::Token],\n+        sep: SeqSep,\n+        expect: TokenExpectType,\n+        mut f: F,\n+    ) -> PResult<'a, Vec<T>>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n     {\n         let mut first: bool = true;\n@@ -2058,12 +2059,12 @@ impl<'a> Parser<'a> {\n                     TokenExpectType::Expect,\n                     |p| p.parse_ty())?;\n                 self.bump(); // `)`\n+                let span = lo.to(self.prev_span);\n                 let output = if self.eat(&token::RArrow) {\n                     Some(self.parse_ty_common(false, false)?)\n                 } else {\n                     None\n                 };\n-                let span = lo.to(self.prev_span);\n                 ParenthesisedArgs { inputs, output, span }.into()\n             };\n \n@@ -6842,8 +6843,6 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse one of the items allowed by the flags.\n-    /// NB: this function no longer parses the items inside an\n-    /// extern crate.\n     fn parse_item_implementation(\n         &mut self,\n         attrs: Vec<Attribute>,"}, {"sha": "b23c2ec3db1011437ac717d9212794b410fbd8c7", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -22,6 +22,7 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n+use errors::Applicability;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n@@ -791,10 +792,11 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                 0 => \"{}\".to_string(),\n                 _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n             };\n-            err.span_suggestion(\n+            err.span_suggestion_with_applicability(\n                 fmt_sp.shrink_to_lo(),\n                 \"you might be missing a string literal to format with\",\n                 format!(\"\\\"{}\\\", \", sugg_fmt),\n+                Applicability::MaybeIncorrect,\n             );\n             err.emit();\n             return DummyResult::raw_expr(sp);"}, {"sha": "62da6f13942d8f1e225f1b7d10b74300209f78d0", "filename": "src/test/rustdoc/impl-everywhere.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Frustdoc%2Fimpl-everywhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Frustdoc%2Fimpl-everywhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-everywhere.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+pub trait Foo {}\n+pub trait Foo2 {}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {}\n+impl Foo2 for Bar {}\n+\n+// @!has foo/fn.foo.html '//section[@id=\"main\"]//pre' \"x: &\\'x impl Foo\"\n+// @!has foo/fn.foo.html '//section[@id=\"main\"]//pre' \"-> &\\'x impl Foo {\"\n+pub fn foo<'x>(x: &'x impl Foo) -> &'x impl Foo {\n+    x\n+}\n+\n+// @!has foo/fn.foo2.html '//section[@id=\"main\"]//pre' \"x: &\\'x impl Foo\"\n+// @!has foo/fn.foo2.html '//section[@id=\"main\"]//pre' '-> impl Foo2 {'\n+pub fn foo2<'x>(_x: &'x impl Foo) -> impl Foo2 {\n+    Bar\n+}\n+\n+// @!has foo/fn.foo_foo.html '//section[@id=\"main\"]//pre' '-> impl Foo + Foo2 {'\n+pub fn foo_foo() -> impl Foo + Foo2 {\n+    Bar\n+}\n+\n+// @!has foo/fn.foo2.html '//section[@id=\"main\"]//pre' \"x: &'x (impl Foo + Foo2)\"\n+pub fn foo_foo_foo<'x>(_x: &'x (impl Foo + Foo2)) {\n+}"}, {"sha": "bd789737552c14ab43f8f3796f80358ecd2d3dd2", "filename": "src/test/ui/bastion-of-the-turbofish.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Fbastion-of-the-turbofish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Fbastion-of-the-turbofish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbastion-of-the-turbofish.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+// Bastion of the Turbofish\n+// ------------------------\n+// Beware travellers, lest you venture into waters callous and unforgiving,\n+// where hope must be abandoned, ere it is cruelly torn from you. For here\n+// stands the bastion of the Turbofish: an impenetrable fortress holding\n+// unshaking against those who would dare suggest the supererogation of the\n+// Turbofish.\n+//\n+// Once I was young and foolish and had the impudence to imagine that I could\n+// shake free from the coils by which that creature had us tightly bound. I\n+// dared to suggest that there was a better way: a brighter future, in which\n+// Rustaceans both new and old could be rid of that vile beast. But alas! In\n+// my foolhardiness my ignorance was unveiled and my dreams were dashed\n+// unforgivingly against the rock of syntactic ambiguity.\n+//\n+// This humble program, small and insignificant though it might seem,\n+// demonstrates that to which we had previously cast a blind eye: an ambiguity\n+// in permitting generic arguments to be provided without the consent of the\n+// Great Turbofish. Should you be so na\u00efve as to try to revolt against its\n+// mighty clutches, here shall its wrath be indomitably displayed. This\n+// program must pass for all eternity, fundamentally at odds with an impetuous\n+// rebellion against the Turbofish.\n+//\n+// My heart aches in sorrow, for I know I am defeated. Let this be a warning\n+// to all those who come after. Here stands the bastion of the Turbofish.\n+\n+fn main() {\n+    let (oh, woe, is, me) = (\"the\", \"Turbofish\", \"remains\", \"undefeated\");\n+    let _: (bool, bool) = (oh<woe, is>(me));\n+}"}, {"sha": "16d87f7e31c9bb126b81f7ac4a0580d9fc1ef2c6", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -2,13 +2,13 @@ error[E0391]: cycle detected when computing layout of `Foo`\n    |\n note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All }, value: [u8; _] }`...\n note: ...which requires const-evaluating `Foo::bytes::{{constant}}`...\n-  --> $SRC_DIR/libcore/mem.rs:323:14\n+  --> $SRC_DIR/libcore/mem.rs:LL:COL\n    |\n LL |     unsafe { intrinsics::size_of::<T>() }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires computing layout of `Foo`, completing the cycle\n note: cycle used when const-evaluating `Foo::bytes::{{constant}}`\n-  --> $SRC_DIR/libcore/mem.rs:323:14\n+  --> $SRC_DIR/libcore/mem.rs:LL:COL\n    |\n LL |     unsafe { intrinsics::size_of::<T>() }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "7295de80db56dec9a6fa29d19596a87dfd2c2cef", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "previous_filename": "src/test/ui/feature-gate-rustc-attrs-1.rs"}, {"sha": "54a580ce9f9426b339f6954b9c45412650d1544c", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "previous_filename": "src/test/ui/feature-gate-rustc-attrs-1.stderr"}, {"sha": "140655d52bd46a17002a2aa7141f1a343ed03d16", "filename": "src/test/ui/feature-gates/feature-gate-uniform-paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "previous_filename": "src/test/ui/feature-gate-uniform-paths.rs"}, {"sha": "68faacfcbe75eafc318128796ce5fd34e1836951", "filename": "src/test/ui/feature-gates/feature-gate-uniform-paths.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "previous_filename": "src/test/ui/feature-gate-uniform-paths.stderr"}, {"sha": "daebbe658a23bbf2dd5e0ba12da187186edbce3e", "filename": "src/test/ui/feature-gates/feature-gate-unrestricted-attribute-tokens.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unrestricted-attribute-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unrestricted-attribute-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unrestricted-attribute-tokens.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "previous_filename": "src/test/ui/feature-gate-unrestricted-attribute-tokens.rs"}, {"sha": "cc5694b1598d3b9b2e5aab1d0d2e4b74ee6506aa", "filename": "src/test/ui/feature-gates/feature-gate-unrestricted-attribute-tokens.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unrestricted-attribute-tokens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unrestricted-attribute-tokens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unrestricted-attribute-tokens.stderr?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "previous_filename": "src/test/ui/feature-gate-unrestricted-attribute-tokens.stderr"}, {"sha": "7ad16b1f8f237c0eeb2510d8e59f754b5e274b70", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -30,7 +30,7 @@ error[E0643]: method `hash` has incompatible signature for trait\n LL |     fn hash(&self, hasher: &mut impl Hasher) {}\n    |                                 ^^^^^^^^^^^ expected generic parameter, found `impl Trait`\n    | \n-  ::: $SRC_DIR/libcore/hash/mod.rs:185:13\n+  ::: $SRC_DIR/libcore/hash/mod.rs:LL:COL\n    |\n LL |     fn hash<H: Hasher>(&self, state: &mut H);\n    |             - declaration in trait here"}, {"sha": "91f57cbd468a8e10dc1ffcebc11b9e90456fac31", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-wrong-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -2,7 +2,7 @@ error[E0244]: wrong number of type arguments: expected 0, found 1\n   --> $DIR/unboxed-closure-sugar-wrong-trait.rs:15:13\n    |\n LL | fn f<F:Trait(isize) -> isize>(x: F) {}\n-   |             ^^^^^^^^^^^^^^^^ unexpected type argument\n+   |             ^^^^^^^ unexpected type argument\n \n error[E0220]: associated type `Output` not found for `Trait`\n   --> $DIR/unboxed-closure-sugar-wrong-trait.rs:15:24"}, {"sha": "24b575aae12f9f44c6a5c90e13b3a10ccce1c9ad", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b506af022fdcb054aa90da1fbcf8c0226292d0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=f1b506af022fdcb054aa90da1fbcf8c0226292d0", "patch": "@@ -2963,6 +2963,13 @@ impl<'test> TestCx<'test> {\n             normalized = normalized.replace(\"\\\\n\", \"\\n\");\n         }\n \n+        // If there are `$SRC_DIR` normalizations with line and column numbers, then replace them\n+        // with placeholders as we do not want tests needing updated when compiler source code\n+        // changes.\n+        // eg. $SRC_DIR/libcore/mem.rs:323:14 becomes $SRC_DIR/libcore/mem.rs:LL:COL\n+        normalized = Regex::new(\"SRC_DIR(.+):\\\\d+:\\\\d+\").unwrap()\n+            .replace_all(&normalized, \"SRC_DIR$1:LL:COL\").into_owned();\n+\n         normalized = normalized.replace(\"\\\\\\\\\", \"\\\\\") // denormalize for paths on windows\n               .replace(\"\\\\\", \"/\") // normalize for paths on windows\n               .replace(\"\\r\\n\", \"\\n\") // normalize for linebreaks on windows"}]}