{"sha": "1cabe37155bf83af04ce7814186fbef096a253cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYWJlMzcxNTViZjgzYWYwNGNlNzgxNDE4NmZiZWYwOTZhMjUzY2I=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T14:46:54Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T14:46:54Z"}, "message": "Prevent memory errors when returning references to temp args.\n\nIssue #918", "tree": {"sha": "58068b8e4959c9b94e70e53d10f6ebb8e1b74def", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58068b8e4959c9b94e70e53d10f6ebb8e1b74def"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cabe37155bf83af04ce7814186fbef096a253cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cabe37155bf83af04ce7814186fbef096a253cb", "html_url": "https://github.com/rust-lang/rust/commit/1cabe37155bf83af04ce7814186fbef096a253cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cabe37155bf83af04ce7814186fbef096a253cb/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "html_url": "https://github.com/rust-lang/rust/commit/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "fbdbe9f269aa95c84e290428d5dc730fbceeb0f3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe37155bf83af04ce7814186fbef096a253cb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe37155bf83af04ce7814186fbef096a253cb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1cabe37155bf83af04ce7814186fbef096a253cb", "patch": "@@ -3521,8 +3521,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n        args: [ValueRef],\n        retslot: ValueRef,\n        to_zero: [{v: ValueRef, t: ty::t}],\n-       to_revoke: [{v: ValueRef, t: ty::t}],\n-       by_ref: bool} {\n+       to_revoke: [{v: ValueRef, t: ty::t}]} {\n \n     let args: [ty::arg] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n     let llargs: [ValueRef] = [];\n@@ -3545,8 +3544,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n              args: [],\n              retslot: C_nil(),\n              to_zero: to_zero,\n-             to_revoke: to_revoke,\n-             by_ref: by_ref};\n+             to_revoke: to_revoke};\n     }\n     let retty = ty::ty_fn_ret(tcx, fn_ty);\n     let llretslot_res = if by_ref {\n@@ -3620,8 +3618,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n          args: llargs,\n          retslot: llretslot,\n          to_zero: to_zero,\n-         to_revoke: to_revoke,\n-         by_ref: by_ref};\n+         to_revoke: to_revoke};\n }\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n@@ -3630,10 +3627,18 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n-    let cx = new_scope_block_ctxt(in_cx, \"call\");\n-    Br(in_cx, cx.llbb);\n+    let fn_expr_ty = ty::expr_ty(bcx_tcx(in_cx), f);\n+    let fn_ty = ty::type_autoderef(bcx_tcx(in_cx), fn_expr_ty);\n+    let by_ref = ty::ty_fn_ret_style(bcx_tcx(in_cx), fn_ty) == ast::return_ref;\n+    // Things that return by reference must put their arguments (FIXME only\n+    // the referenced arguments) into the outer scope, so that they are still\n+    // alive when the return value is used.\n+    let cx = if by_ref { in_cx } else {\n+        let cx = new_scope_block_ctxt(in_cx, \"call\");\n+        Br(in_cx, cx.llbb);\n+        cx\n+    };\n     let f_res = trans_lval_gen(cx, f);\n-    let fn_ty = ty::expr_ty(bcx_tcx(cx), f);\n     let bcx = f_res.res.bcx;\n \n     let faddr = f_res.res.val;\n@@ -3646,10 +3651,9 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n       }\n       none. {\n         // It's a closure. We have to autoderef.\n-        if f_res.is_mem { faddr = load_if_immediate(bcx, faddr, fn_ty); }\n-        let res = autoderef(bcx, faddr, fn_ty);\n+        if f_res.is_mem { faddr = load_if_immediate(bcx, faddr, fn_expr_ty); }\n+        let res = autoderef(bcx, faddr, fn_expr_ty);\n         bcx = res.bcx;\n-        fn_ty = res.ty;\n \n         let pair = res.val;\n         faddr = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n@@ -3684,7 +3688,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         alt lliterbody {\n           none. {\n             if !ty::type_is_nil(bcx_tcx(cx), ret_ty) {\n-                if args_res.by_ref {\n+                if by_ref {\n                     let retptr = Load(bcx, llretslot);\n                     retval = load_if_immediate(bcx, retptr, ret_ty);\n                 } else {\n@@ -3710,7 +3714,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         for {v: v, t: t} in args_res.to_revoke {\n             bcx = revoke_clean(bcx, v, t);\n         }\n-        bcx = trans_block_cleanups(bcx, cx);\n+        if !by_ref { bcx = trans_block_cleanups(bcx, cx); }\n         let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n         Br(bcx, next_cx.llbb);\n         bcx = next_cx;"}]}