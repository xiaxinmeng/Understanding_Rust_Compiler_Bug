{"sha": "874208bcd5490ee19a42787c529ab80c1595cf36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NDIwOGJjZDU0OTBlZTE5YTQyNzg3YzUyOWFiODBjMTU5NWNmMzY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-20T11:38:49Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-26T08:14:27Z"}, "message": "Add closure support (fixes #2)", "tree": {"sha": "25f41e29d8d176df2c46a96c3d4b1ee60531dab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25f41e29d8d176df2c46a96c3d4b1ee60531dab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/874208bcd5490ee19a42787c529ab80c1595cf36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/874208bcd5490ee19a42787c529ab80c1595cf36", "html_url": "https://github.com/rust-lang/rust/commit/874208bcd5490ee19a42787c529ab80c1595cf36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/874208bcd5490ee19a42787c529ab80c1595cf36/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae44a1a172a8ec1b358a174b5a306b2b017cf133", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae44a1a172a8ec1b358a174b5a306b2b017cf133", "html_url": "https://github.com/rust-lang/rust/commit/ae44a1a172a8ec1b358a174b5a306b2b017cf133"}], "stats": {"total": 112, "additions": 79, "deletions": 33}, "files": [{"sha": "724f5deedfc93b9c17d49df3b0464985c0697aac", "filename": "build.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/874208bcd5490ee19a42787c529ab80c1595cf36/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/874208bcd5490ee19a42787c529ab80c1595cf36/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=874208bcd5490ee19a42787c529ab80c1595cf36", "patch": "@@ -3,3 +3,5 @@ cargo build || exit 1\n rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cranelift.so mini_core.rs --crate-name mini_core --crate-type lib -Og &&\n rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cranelift.so -L crate=. example.rs --crate-type lib -Og &&\n rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cranelift.so ./target/libcore/src/libcore/lib.rs --crate-type lib -Og\n+\n+rm libmini_core.rlib libexample.rlib"}, {"sha": "0f37d7f4c363592c8084cf2e56448aeadf7267e1", "filename": "example.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874208bcd5490ee19a42787c529ab80c1595cf36/example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874208bcd5490ee19a42787c529ab80c1595cf36/example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example.rs?ref=874208bcd5490ee19a42787c529ab80c1595cf36", "patch": "@@ -60,7 +60,7 @@ fn cmp_raw_ptr(a: *const u8, b: *const u8) -> bool {\n     a == b\n }\n \n-fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize) {\n+fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n     (\n         a as u8,\n         a as u16,\n@@ -70,6 +70,8 @@ fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize) {\n         a as i16,\n         a as i32,\n         a as isize,\n+        b as u8,\n+        b as u32\n     )\n }\n \n@@ -107,3 +109,9 @@ const Abc: u8 = 6 * 7;\n fn use_const() -> u8 {\n     Abc\n }\n+\n+fn call_closure() {\n+    (|_, _, _| {\n+\n+    })(0u8, 42u8, 0u8)\n+}"}, {"sha": "d4844cc0be2d9879e919043d66d93e63e328173d", "filename": "mini_core.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874208bcd5490ee19a42787c529ab80c1595cf36/mini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874208bcd5490ee19a42787c529ab80c1595cf36/mini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini_core.rs?ref=874208bcd5490ee19a42787c529ab80c1595cf36", "patch": "@@ -1,4 +1,4 @@\n-#![feature(no_core, lang_items, intrinsics)]\n+#![feature(no_core, lang_items, intrinsics, unboxed_closures)]\n #![no_core]\n #![allow(dead_code)]\n \n@@ -55,6 +55,20 @@ impl<T: ?Sized> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { *self != *other }\n }\n \n+#[lang = \"fn_once\"]\n+#[rustc_paren_sugar]\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn_mut\"]\n+#[rustc_paren_sugar]\n+trait FnMut<Args> : FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n #[lang=\"panic\"]\n pub fn panic(_expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     loop {}"}, {"sha": "a36ac1611a1942271392667ba86fe0577d217139", "filename": "src/abi.rs", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/874208bcd5490ee19a42787c529ab80c1595cf36/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874208bcd5490ee19a42787c529ab80c1595cf36/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=874208bcd5490ee19a42787c529ab80c1595cf36", "patch": "@@ -7,12 +7,22 @@ use prelude::*;\n \n pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_ty: Ty<'tcx>) -> Signature {\n     let sig = ty_fn_sig(tcx, fn_ty);\n-    let sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &sig);\n     assert!(!sig.variadic, \"Variadic function are not yet supported\");\n     let (call_conv, inputs, _output): (CallConv, Vec<Ty>, Ty) = match sig.abi {\n         Abi::Rust => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         Abi::RustCall => {\n-            unimplemented!(\"rust-call\");\n+            println!(\"rust-call sig: {:?} inputs: {:?} output: {:?}\", sig, sig.inputs(), sig.output());\n+            let extra_args = match sig.inputs().last().unwrap().sty {\n+                ty::TyTuple(ref tupled_arguments) => tupled_arguments,\n+                _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n+            };\n+            let mut inputs: Vec<Ty> = sig.inputs()[0..sig.inputs().len() - 1].to_vec();\n+            inputs.extend(extra_args.into_iter());\n+            (\n+                CallConv::SystemV,\n+                inputs,\n+                sig.output(),\n+            )\n         }\n         Abi::System => bug!(\"system abi should be selected elsewhere\"),\n         // TODO: properly implement intrinsics\n@@ -32,8 +42,8 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_ty: Ty<\n fn ty_fn_sig<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>\n-) -> ty::PolyFnSig<'tcx> {\n-    match ty.sty {\n+) -> ty::FnSig<'tcx> {\n+    let sig = match ty.sty {\n         ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n         ty::TyFnPtr(_) => ty.fn_sig(tcx),\n@@ -73,7 +83,8 @@ fn ty_fn_sig<'a, 'tcx>(\n             })\n         }\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n-    }\n+    };\n+    tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &sig)\n }\n \n impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n@@ -91,8 +102,7 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n     }\n \n     fn self_sig(&self) -> FnSig<'tcx> {\n-        let sig = ty_fn_sig(self.tcx, self.instance.ty(self.tcx));\n-        self.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &sig)\n+        ty_fn_sig(self.tcx, self.instance.ty(self.tcx))\n     }\n \n     fn return_type(&self) -> Ty<'tcx> {\n@@ -153,36 +163,42 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n     destination: &Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let func = ::base::trans_operand(fx, func);\n+    let fn_ty = func.layout().ty;\n+    let sig = ty_fn_sig(fx.tcx, fn_ty);\n \n     let return_place = if let Some((place, _)) = destination {\n         Some(::base::trans_place(fx, place))\n     } else {\n         None\n     };\n \n-    let args = args\n-        .into_iter()\n-        .map(|arg| {\n-            let arg = ::base::trans_operand(fx, arg);\n-            if let Some(_) = fx.cton_type(arg.layout().ty) {\n-                arg.load_value(fx)\n-            } else {\n-                arg.force_stack(fx)\n-            }\n-        })\n-        .collect::<Vec<_>>();\n+    // Unpack arguments tuple for closures\n+    let args = if sig.abi == Abi::RustCall {\n+        assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n+        let self_arg = ::base::trans_operand(fx, &args[0]);\n+        let pack_arg = ::base::trans_operand(fx, &args[1]);\n+        let mut args = Vec::new();\n+        args.push(self_arg);\n+        match pack_arg.layout().ty.sty {\n+            ty::TyTuple(ref tupled_arguments) => {\n+                for (i, _) in tupled_arguments.iter().enumerate() {\n+                    args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n+                }\n+            },\n+            _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n+        }\n+        args\n+    } else {\n+        args\n+            .into_iter()\n+            .map(|arg| {\n+                ::base::trans_operand(fx, arg)\n+            })\n+            .collect::<Vec<_>>()\n+    };\n \n-    let fn_ty = func.layout().ty;\n     if let TypeVariants::TyFnDef(def_id, substs) = fn_ty.sty {\n-        let instance = ty::Instance::resolve(\n-            fx.tcx,\n-            ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap();\n-\n-        // Handle intrinsics old codegen wants Expr's for, ourselves.\n-        if let InstanceDef::Intrinsic(def_id) = instance.def {\n+        if sig.abi == Abi::RustIntrinsic {\n             let intrinsic = fx.tcx.item_name(def_id).as_str();\n             let intrinsic = &intrinsic[..];\n \n@@ -218,17 +234,23 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         None => fx.bcx.ins().iconst(types::I64, 0),\n     };\n \n-    let args = Some(return_ptr).into_iter().chain(args).collect::<Vec<_>>();\n+    let call_args = Some(return_ptr).into_iter().chain(args.into_iter().map(|arg| {\n+        if fx.cton_type(arg.layout().ty).is_some() {\n+            arg.load_value(fx)\n+        } else {\n+            arg.force_stack(fx)\n+        }\n+    })).collect::<Vec<_>>();\n \n     match func {\n         CValue::Func(func, _) => {\n-            fx.bcx.ins().call(func, &args);\n+            fx.bcx.ins().call(func, &call_args);\n         }\n         func => {\n             let func_ty = func.layout().ty;\n             let func = func.load_value(fx);\n             let sig = fx.bcx.import_signature(cton_sig_from_fn_ty(fx.tcx, func_ty));\n-            fx.bcx.ins().call_indirect(sig, func, &args);\n+            fx.bcx.ins().call_indirect(sig, func, &call_args);\n         }\n     }\n     if let Some((_, dest)) = *destination {"}]}