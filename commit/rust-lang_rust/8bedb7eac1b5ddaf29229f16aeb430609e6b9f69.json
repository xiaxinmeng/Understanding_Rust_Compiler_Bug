{"sha": "8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZWRiN2VhYzFiNWRkYWYyOTIyOWYxNmFlYjQzMDYwOWU2YjlmNjk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-03-31T23:50:15Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-01T22:44:13Z"}, "message": "Remove duplicated code in trait selection", "tree": {"sha": "c35c3bc5337012d78ea4a775102b44f021c4d298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35c3bc5337012d78ea4a775102b44f021c4d298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "html_url": "https://github.com/rust-lang/rust/commit/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b09d35473615e7142f5570f5c5fad0caf68bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b09d35473615e7142f5570f5c5fad0caf68bd2", "html_url": "https://github.com/rust-lang/rust/commit/a5b09d35473615e7142f5570f5c5fad0caf68bd2"}], "stats": {"total": 379, "additions": 81, "deletions": 298}, "files": [{"sha": "758a0b39d43ee21c8c8606c5f6a99c8e3a4cb66b", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "patch": "@@ -6,7 +6,7 @@ mod engine;\n pub mod error_reporting;\n mod project;\n mod structural_impls;\n-mod util;\n+pub mod util;\n \n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};"}, {"sha": "4fa74f93ddcb05675785a46709636f8f78183abb", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "patch": "@@ -2,9 +2,12 @@ use smallvec::smallvec;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::outlives::Component;\n-use rustc_middle::ty::{self, ToPolyTraitRef, TyCtxt};\n+use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, TyCtxt, WithConstness};\n \n-fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+pub fn anonymize_predicate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    pred: &ty::Predicate<'tcx>,\n+) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data, constness) => {\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n@@ -88,6 +91,21 @@ pub struct Elaborator<'tcx> {\n     visited: PredicateSet<'tcx>,\n }\n \n+pub fn elaborate_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'tcx> {\n+    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n+}\n+\n+pub fn elaborate_trait_refs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'tcx> {\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n+    elaborate_predicates(tcx, predicates)\n+}\n+\n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>,\n@@ -98,6 +116,10 @@ pub fn elaborate_predicates<'tcx>(\n }\n \n impl Elaborator<'tcx> {\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits::new(self)\n+    }\n+\n     fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n         let tcx = self.visited.tcx;\n         match *predicate {\n@@ -223,3 +245,57 @@ impl Iterator for Elaborator<'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n+\n+pub fn supertraits<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+}\n+\n+pub fn transitive_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// A filter around an iterator of predicates that makes it yield up\n+/// just trait references.\n+pub struct FilterToTraits<I> {\n+    base_iterator: I,\n+}\n+\n+impl<I> FilterToTraits<I> {\n+    fn new(base: I) -> FilterToTraits<I> {\n+        FilterToTraits { base_iterator: base }\n+    }\n+}\n+\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+    type Item = ty::PolyTraitRef<'tcx>;\n+\n+    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let ty::Predicate::Trait(data, _) = pred {\n+                return Some(data.to_poly_trait_ref());\n+            }\n+        }\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.base_iterator.size_hint();\n+        (0, upper)\n+    }\n+}"}, {"sha": "b7c645699686ee82dfdf3d72cd14a15a6833700f", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 2, "deletions": 295, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bedb7eac1b5ddaf29229f16aeb430609e6b9f69/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=8bedb7eac1b5ddaf29229f16aeb430609e6b9f69", "patch": "@@ -6,270 +6,11 @@ use smallvec::SmallVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n \n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n-\n-fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n-    match *pred {\n-        ty::Predicate::Trait(ref data, constness) => {\n-            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n-        }\n-\n-        ty::Predicate::RegionOutlives(ref data) => {\n-            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::TypeOutlives(ref data) => {\n-            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::Projection(ref data) => {\n-            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n-\n-        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n-\n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n-        }\n-\n-        ty::Predicate::Subtype(ref data) => {\n-            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            ty::Predicate::ConstEvaluatable(def_id, substs)\n-        }\n-    }\n-}\n-\n-struct PredicateSet<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    set: FxHashSet<ty::Predicate<'tcx>>,\n-}\n-\n-impl PredicateSet<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx, set: Default::default() }\n-    }\n-\n-    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n-        // We have to be careful here because we want\n-        //\n-        //    for<'a> Foo<&'a int>\n-        //\n-        // and\n-        //\n-        //    for<'b> Foo<&'b int>\n-        //\n-        // to be considered equivalent. So normalize all late-bound\n-        // regions before we throw things into the underlying set.\n-        self.set.insert(anonymize_predicate(self.tcx, pred))\n-    }\n-}\n-\n-impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n-    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        for pred in iter {\n-            self.insert(pred.as_ref());\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// `Elaboration` iterator\n-///////////////////////////////////////////////////////////////////////////\n-\n-/// \"Elaboration\" is the process of identifying all the predicates that\n-/// are implied by a source predicate. Currently, this basically means\n-/// walking the \"supertraits\" and other similar assumptions. For example,\n-/// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n-/// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n-/// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'tcx> {\n-    stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'tcx>,\n-}\n-\n-pub fn elaborate_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n-}\n-\n-pub fn elaborate_trait_refs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n-    elaborate_predicates(tcx, predicates)\n-}\n-\n-pub fn elaborate_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut predicates: Vec<ty::Predicate<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let mut visited = PredicateSet::new(tcx);\n-    predicates.retain(|pred| visited.insert(pred));\n-    Elaborator { stack: predicates, visited }\n-}\n-\n-impl Elaborator<'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n-    }\n-\n-    fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n-        let tcx = self.visited.tcx;\n-        match *predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n-                // Get predicates declared on the trait.\n-                let predicates = tcx.super_predicates_of(data.def_id());\n-\n-                let predicates = predicates\n-                    .predicates\n-                    .iter()\n-                    .map(|(pred, _)| pred.subst_supertrait(tcx, &data.to_poly_trait_ref()));\n-                debug!(\"super_predicates: data={:?} predicates={:?}\", data, predicates.clone());\n-\n-                // Only keep those bounds that we haven't already seen.\n-                // This is necessary to prevent infinite recursion in some\n-                // cases. One common case is when people define\n-                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n-                let visited = &mut self.visited;\n-                let predicates = predicates.filter(|pred| visited.insert(pred));\n-\n-                self.stack.extend(predicates);\n-            }\n-            ty::Predicate::WellFormed(..) => {\n-                // Currently, we do not elaborate WF predicates,\n-                // although we easily could.\n-            }\n-            ty::Predicate::ObjectSafe(..) => {\n-                // Currently, we do not elaborate object-safe\n-                // predicates.\n-            }\n-            ty::Predicate::Subtype(..) => {\n-                // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n-                // though conceivably we might.\n-            }\n-            ty::Predicate::Projection(..) => {\n-                // Nothing to elaborate in a projection predicate.\n-            }\n-            ty::Predicate::ClosureKind(..) => {\n-                // Nothing to elaborate when waiting for a closure's kind to be inferred.\n-            }\n-            ty::Predicate::ConstEvaluatable(..) => {\n-                // Currently, we do not elaborate const-evaluatable\n-                // predicates.\n-            }\n-            ty::Predicate::RegionOutlives(..) => {\n-                // Nothing to elaborate from `'a: 'b`.\n-            }\n-            ty::Predicate::TypeOutlives(ref data) => {\n-                // We know that `T: 'a` for some type `T`. We can\n-                // often elaborate this. For example, if we know that\n-                // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n-                // we know `&'a U: 'b`, then we know that `'a: 'b` and\n-                // `U: 'b`.\n-                //\n-                // We can basically ignore bound regions here. So for\n-                // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to\n-                // `'a: 'b`.\n-\n-                // Ignore `for<'a> T: 'a` -- we might in the future\n-                // consider this as evidence that `T: 'static`, but\n-                // I'm a bit wary of such constructions and so for now\n-                // I want to be conservative. --nmatsakis\n-                let ty_max = data.skip_binder().0;\n-                let r_min = data.skip_binder().1;\n-                if r_min.is_late_bound() {\n-                    return;\n-                }\n-\n-                let visited = &mut self.visited;\n-                let mut components = smallvec![];\n-                tcx.push_outlives_components(ty_max, &mut components);\n-                self.stack.extend(\n-                    components\n-                        .into_iter()\n-                        .filter_map(|component| match component {\n-                            Component::Region(r) => {\n-                                if r.is_late_bound() {\n-                                    None\n-                                } else {\n-                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n-                                        ty::OutlivesPredicate(r, r_min),\n-                                    )))\n-                                }\n-                            }\n-\n-                            Component::Param(p) => {\n-                                let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n-                                    ty::OutlivesPredicate(ty, r_min),\n-                                )))\n-                            }\n-\n-                            Component::UnresolvedInferenceVariable(_) => None,\n-\n-                            Component::Projection(_) | Component::EscapingProjection(_) => {\n-                                // We can probably do more here. This\n-                                // corresponds to a case like `<T as\n-                                // Foo<'a>>::U: 'b`.\n-                                None\n-                            }\n-                        })\n-                        .filter(|p| visited.insert(p)),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-impl Iterator for Elaborator<'tcx> {\n-    type Item = ty::Predicate<'tcx>;\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.stack.len(), None)\n-    }\n-\n-    fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n-        // Extract next item from top-most stack frame, if any.\n-        if let Some(pred) = self.stack.pop() {\n-            self.elaborate(&pred);\n-            Some(pred)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Supertrait iterator\n-///////////////////////////////////////////////////////////////////////////\n-\n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n-\n-pub fn supertraits<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n-}\n-\n-pub fn transitive_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n-}\n+pub use rustc_infer::traits::util::*;\n \n ///////////////////////////////////////////////////////////////////////////\n // `TraitAliasExpander` iterator\n@@ -451,40 +192,6 @@ impl Iterator for SupertraitDefIds<'tcx> {\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n-/// A filter around an iterator of predicates that makes it yield up\n-/// just trait references.\n-pub struct FilterToTraits<I> {\n-    base_iterator: I,\n-}\n-\n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n-    }\n-}\n-\n-impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n-    type Item = ty::PolyTraitRef<'tcx>;\n-\n-    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        while let Some(pred) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data, _) = pred {\n-                return Some(data.to_poly_trait_ref());\n-            }\n-        }\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.base_iterator.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Other\n-///////////////////////////////////////////////////////////////////////////\n-\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization."}]}