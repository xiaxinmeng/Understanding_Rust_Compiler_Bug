{"sha": "1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYWUzMDljYTFjOGFlODkzODQxNzBkZTJlNWQ0NjgzZDVmOTRjZDQ=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-06-22T03:10:52Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-06-22T21:24:02Z"}, "message": "Run rustfmt", "tree": {"sha": "d380a75d2ba7fd3fa0fa6cd52a0e8641b894cf80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d380a75d2ba7fd3fa0fa6cd52a0e8641b894cf80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlstaPMACgkQiMlBzaHU\nZDJZSA//Wk5i/u1zL5F0irqURDp2riv8ydtacEXyigYUF3G3uinbIoB1e1Q2J58F\nTk6RB+c9mIfO7N/csqyn84RZsDXDwFxSonmFsJiqv+P2DtSoHhCq2yxdSnRxKCjx\nQWGUK6oIOZ6Cq7Z+s1+hRpQptSt95YkQw3TjeUfR8zJD7w/G2f+LDWy4Y4je+EhU\nfZfhlp36k+bqwdw4q1JYMjuK41o1FZrcl2MVcvqySKZrYKTTdNAMTB4ANXRrw3Ky\niTWNSFSBjgvJbwMQt8ugJdYGkQwx/oASC93Lss1XMm6Z4yOQCqZZeK44trxwLnzW\nC9bgfbGcyJquXquwJsroc0qYOs5d/IL0kinGoJhuWwaEYFvLBzqDN36aovMt85A0\ntdB6hfx8vjy8aQZkrUpNKT3u4YqBftWQ96P0fd+EW2LWlYE5/jdLqo6ntSAEUkMZ\nPhIaB+m205ytc0yySKdSoMzLskmM/tSvdNDaiW8QN5EfLZ6T5me9eA3BQe/moY6m\n/Pb6vFIlgeRmZvNT04JEAUDyOsyyiGyeGyZOCGUCfe7rvhv8l9OCI3o396vJSY+5\n9iSkzHymBz5ylqRwsVqxqI3pICNiYfCqxN3ScgYPN9ZiqwQSuYqs4BzjuHd39X7L\n55XPpCkWCByukk1506zHChU4XQtSqUAfDg2GYHqfAv+DvYxVzAU=\n=mtPi\n-----END PGP SIGNATURE-----", "payload": "tree d380a75d2ba7fd3fa0fa6cd52a0e8641b894cf80\nparent ad612d660cf782e895a9957cb4d5a2465bec1f4c\nauthor Santiago Pastorino <spastorino@gmail.com> 1529637052 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1529702642 -0300\n\nRun rustfmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "html_url": "https://github.com/rust-lang/rust/commit/1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad612d660cf782e895a9957cb4d5a2465bec1f4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad612d660cf782e895a9957cb4d5a2465bec1f4c", "html_url": "https://github.com/rust-lang/rust/commit/ad612d660cf782e895a9957cb4d5a2465bec1f4c"}], "stats": {"total": 1163, "additions": 696, "deletions": 467}, "files": [{"sha": "44fc67dfa437959e869863a4c244db732cf81069", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "patch": "@@ -60,7 +60,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 .cannot_act_on_uninitialized_variable(\n                     span,\n                     desired_action.as_noun(),\n-                    &self.describe_place_with_options(place, IncludingDowncast(true)).unwrap_or(\"_\".to_owned()),\n+                    &self\n+                        .describe_place_with_options(place, IncludingDowncast(true))\n+                        .unwrap_or(\"_\".to_owned()),\n                     Origin::Mir,\n                 )\n                 .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n@@ -79,7 +81,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let mut is_loop_move = false;\n             for moi in &mois {\n                 let move_msg = \"\"; //FIXME: add \" (into closure)\"\n-                let move_span = self.mir.source_info(self.move_data.moves[**moi].source).span;\n+                let move_span = self\n+                    .mir\n+                    .source_info(self.move_data.moves[**moi].source)\n+                    .span;\n                 if span == move_span {\n                     err.span_label(\n                         span,\n@@ -120,7 +125,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     let place = &self.move_data.move_paths[mpi].place;\n \n                     if let Some(ty) = self.retrieve_type_for_place(place) {\n-                        let note_msg = match self.describe_place_with_options(place, IncludingDowncast(true)) {\n+                        let note_msg = match self\n+                            .describe_place_with_options(place, IncludingDowncast(true))\n+                        {\n                             Some(name) => format!(\"`{}`\", name),\n                             None => \"value\".to_owned(),\n                         };\n@@ -649,8 +656,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let local_decl = &self.mir.local_decls[*local];\n             if let Some(name) = local_decl.name {\n                 if local_decl.can_be_made_mutable() {\n-                    err.span_label(local_decl.source_info.span,\n-                                   format!(\"consider changing this to `mut {}`\", name));\n+                    err.span_label(\n+                        local_decl.source_info.span,\n+                        format!(\"consider changing this to `mut {}`\", name),\n+                    );\n                 }\n             }\n         }\n@@ -672,7 +681,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // place is a temporary for instance, None will be returned.\n     // `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n     // `Downcast` and `IncludingDowncast` is true\n-    pub(super) fn describe_place_with_options(&self, place: &Place<'tcx>, including_downcast: IncludingDowncast) -> Option<String> {\n+    pub(super) fn describe_place_with_options(\n+        &self,\n+        place: &Place<'tcx>,\n+        including_downcast: IncludingDowncast,\n+    ) -> Option<String> {\n         let mut buf = String::new();\n         match self.append_place_to_string(place, &mut buf, false, &including_downcast) {\n             Ok(()) => Some(buf),\n@@ -708,15 +721,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                         } else {\n                             if autoderef {\n-                                self.append_place_to_string(&proj.base, buf, autoderef, &including_downcast)?;\n+                                self.append_place_to_string(\n+                                    &proj.base,\n+                                    buf,\n+                                    autoderef,\n+                                    &including_downcast,\n+                                )?;\n                             } else {\n                                 buf.push_str(&\"*\");\n-                                self.append_place_to_string(&proj.base, buf, autoderef, &including_downcast)?;\n+                                self.append_place_to_string(\n+                                    &proj.base,\n+                                    buf,\n+                                    autoderef,\n+                                    &including_downcast,\n+                                )?;\n                             }\n                         }\n                     }\n                     ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(&proj.base, buf, autoderef, &including_downcast)?;\n+                        self.append_place_to_string(\n+                            &proj.base,\n+                            buf,\n+                            autoderef,\n+                            &including_downcast,\n+                        )?;\n                         if including_downcast.0 {\n                             return Err(());\n                         }\n@@ -730,14 +758,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);\n-                            self.append_place_to_string(&proj.base, buf, autoderef, &including_downcast)?;\n+                            self.append_place_to_string(\n+                                &proj.base,\n+                                buf,\n+                                autoderef,\n+                                &including_downcast,\n+                            )?;\n                             buf.push_str(&format!(\".{}\", field_name));\n                         }\n                     }\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n \n-                        self.append_place_to_string(&proj.base, buf, autoderef, &including_downcast)?;\n+                        self.append_place_to_string(\n+                            &proj.base,\n+                            buf,\n+                            autoderef,\n+                            &including_downcast,\n+                        )?;\n                         buf.push_str(\"[\");\n                         if let Err(_) = self.append_local_to_string(index, buf) {\n                             buf.push_str(\"..\");\n@@ -749,7 +787,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        self.append_place_to_string(&proj.base, buf, autoderef, &including_downcast)?;\n+                        self.append_place_to_string(\n+                            &proj.base,\n+                            buf,\n+                            autoderef,\n+                            &including_downcast,\n+                        )?;\n                         buf.push_str(&\"[..]\");\n                     }\n                 };"}, {"sha": "6d77364aae02a6b783beceef0339cf6aec44e611", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 171, "deletions": 142, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "patch": "@@ -15,13 +15,13 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n-use rustc::ty::{self, ParamEnv, TyCtxt};\n-use rustc::ty::query::Providers;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{self, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n-use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n+use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place};\n+use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n+use rustc::ty::query::Providers;\n+use rustc::ty::{self, ParamEnv, TyCtxt};\n \n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n@@ -33,20 +33,20 @@ use std::rc::Rc;\n \n use syntax_pos::Span;\n \n-use dataflow::{do_dataflow, DebugFormatted};\n+use dataflow::indexes::BorrowIndex;\n+use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n+use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n+use dataflow::Borrows;\n+use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n-use dataflow::{DataflowResultsConsumer};\n-use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n-use dataflow::Borrows;\n-use dataflow::indexes::BorrowIndex;\n-use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n-use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n use util::collect_writes::FindAssignments;\n \n-use self::borrow_set::{BorrowSet, BorrowData};\n+use self::borrow_set::{BorrowData, BorrowSet};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -58,9 +58,9 @@ crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod location;\n+mod path_utils;\n crate mod place_ext;\n mod prefixes;\n-mod path_utils;\n mod used_muts;\n \n pub(crate) mod nll;\n@@ -72,10 +72,7 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> BorrowCheckResult<'tcx> {\n+fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n@@ -103,7 +100,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n-    let id = tcx.hir\n+    let id = tcx\n+        .hir\n         .as_local_node_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n@@ -138,9 +136,10 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(..) =>\n-                                tcx.cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n-                            _ => tcx.cannot_move_out_of(span, \"borrowed content\", origin)\n+                            ty::TyArray(..) | ty::TySlice(..) => {\n+                                tcx.cannot_move_out_of_interior_noncopy(span, ty, None, origin)\n+                            }\n+                            _ => tcx.cannot_move_out_of(span, \"borrowed content\", origin),\n                         }\n                     }\n                     IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n@@ -277,16 +276,21 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // Note that this set is expected to be small - only upvars from closures\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n-    let temporary_used_locals: FxHashSet<Local> =\n-        mbcx.used_mut.iter()\n-            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n-            .cloned()\n-            .collect();\n+    let temporary_used_locals: FxHashSet<Local> = mbcx\n+        .used_mut\n+        .iter()\n+        .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n+        .cloned()\n+        .collect();\n     mbcx.gather_used_muts(temporary_used_locals);\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n \n-    for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n+    for local in mbcx\n+        .mir\n+        .mut_vars_and_args_iter()\n+        .filter(|local| !mbcx.used_mut.contains(local))\n+    {\n         if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n             let local_decl = &mbcx.mir.local_decls[local];\n \n@@ -297,7 +301,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n             // Skip over locals that begin with an underscore or have no name\n             match local_decl.name {\n-                Some(name) => if name.as_str().starts_with(\"_\") { continue; },\n+                Some(name) => if name.as_str().starts_with(\"_\") {\n+                    continue;\n+                },\n                 None => continue,\n             }\n \n@@ -308,10 +314,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n                 UNUSED_MUT,\n                 vsi[local_decl.source_info.scope].lint_root,\n                 span,\n-                \"variable does not need to be mutable\"\n-            )\n-            .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n-            .emit();\n+                \"variable does not need to be mutable\",\n+            ).span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+                .emit();\n         }\n     }\n \n@@ -419,12 +424,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 );\n             }\n             StatementKind::ReadForMatch(ref place) => {\n-                self.access_place(ContextKind::ReadForMatch.new(location),\n-                                  (place, span),\n-                                  (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n-                                  LocalMutationIsAllowed::No,\n-                                  flow_state,\n-                                  );\n+                self.access_place(\n+                    ContextKind::ReadForMatch.new(location),\n+                    (place, span),\n+                    (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                    LocalMutationIsAllowed::No,\n+                    flow_state,\n+                );\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -479,10 +485,10 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // ignored when consuming results (update to\n                 // flow_state already handled).\n             }\n-            StatementKind::Nop |\n-            StatementKind::UserAssertTy(..) |\n-            StatementKind::Validate(..) |\n-            StatementKind::StorageLive(..) => {\n+            StatementKind::Nop\n+            | StatementKind::UserAssertTy(..)\n+            | StatementKind::Validate(..)\n+            | StatementKind::StorageLive(..) => {\n                 // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n@@ -596,11 +602,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n-                    self.consume_operand(\n-                        ContextKind::Assert.new(loc),\n-                        (index, span),\n-                        flow_state,\n-                    );\n+                    self.consume_operand(ContextKind::Assert.new(loc), (index, span), flow_state);\n                 }\n             }\n \n@@ -660,8 +662,8 @@ enum MutateMode {\n     WriteAndRead,\n }\n \n-use self::ShallowOrDeep::{Deep, Shallow};\n use self::ReadOrWrite::{Activation, Read, Reservation, Write};\n+use self::ShallowOrDeep::{Deep, Shallow};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ArtificialField {\n@@ -795,10 +797,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n     ) {\n         let gcx = self.tcx.global_tcx();\n-        let drop_field = |\n-            mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n-            (index, field): (usize, ty::Ty<'gcx>),\n-        | {\n+        let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+                          (index, field): (usize, ty::Ty<'gcx>)| {\n             let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n             let place = drop_place.clone().field(Field::new(index), field_ty);\n \n@@ -820,23 +820,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // Same as above, but for tuples.\n             ty::TyTuple(tys) => {\n-                tys.iter().cloned().enumerate()\n+                tys.iter()\n+                    .cloned()\n+                    .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Closures also have disjoint fields, but they are only\n             // directly accessed in the body of the closure.\n             ty::TyClosure(def, substs)\n-                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n-            => {\n-                substs.upvar_tys(def, self.tcx).enumerate()\n+                if *drop_place == Place::Local(Local::new(1))\n+                    && !self.mir.upvar_decls.is_empty() =>\n+            {\n+                substs\n+                    .upvar_tys(def, self.tcx)\n+                    .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Generators also have disjoint fields, but they are only\n             // directly accessed in the body of the generator.\n             ty::TyGenerator(def, substs, _)\n-                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n-            => {\n-                substs.upvar_tys(def, self.tcx).enumerate()\n+                if *drop_place == Place::Local(Local::new(1))\n+                    && !self.mir.upvar_decls.is_empty() =>\n+            {\n+                substs\n+                    .upvar_tys(def, self.tcx)\n+                    .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             _ => {\n@@ -888,7 +896,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        if self.access_place_error_reported\n+        if self\n+            .access_place_error_reported\n             .contains(&(place_span.0.clone(), place_span.1))\n         {\n             debug!(\n@@ -931,10 +940,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         debug!(\n             \"check_access_for_conflict(context={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            context,\n-            place_span,\n-            sd,\n-            rw,\n+            context, place_span, sd, rw,\n         );\n \n         let mut error_reported = false;\n@@ -951,8 +957,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (sd, place_span.0),\n             &borrow_set,\n             flow_state.borrows_in_scope(location),\n-            |this, borrow_index, borrow|\n-            match (rw, borrow.kind) {\n+            |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n                 // borrow); so don't check if they interfere.\n@@ -989,12 +994,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                         ReadKind::Borrow(bk) => {\n                             error_reported = true;\n-                            this.report_conflicting_borrow(\n-                                context,\n-                                place_span,\n-                                bk,\n-                                &borrow,\n-                            )\n+                            this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                     }\n                     Control::Break\n@@ -1026,12 +1026,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n                             error_reported = true;\n-                            this.report_conflicting_borrow(\n-                                context,\n-                                place_span,\n-                                bk,\n-                                &borrow,\n-                            )\n+                            this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n@@ -1185,7 +1180,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set.\n                 if let AggregateKind::Closure(def_id, _) = &**aggregate_kind {\n-                    let BorrowCheckResult { used_mut_upvars, .. } = self.tcx.mir_borrowck(*def_id);\n+                    let BorrowCheckResult {\n+                        used_mut_upvars, ..\n+                    } = self.tcx.mir_borrowck(*def_id);\n                     debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                     for field in used_mut_upvars {\n                         match operands[field.index()] {\n@@ -1197,9 +1194,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     self.used_mut_upvars.push(field);\n                                 }\n                             }\n-                            Operand::Move(Place::Static(..)) |\n-                            Operand::Copy(..) |\n-                            Operand::Constant(..) => {}\n+                            Operand::Move(Place::Static(..))\n+                            | Operand::Copy(..)\n+                            | Operand::Constant(..) => {}\n                         }\n                     }\n                 }\n@@ -1280,7 +1277,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n-                let is_thread_local = self.tcx\n+                let is_thread_local = self\n+                    .tcx\n                     .get_attrs(statik.def_id)\n                     .iter()\n                     .any(|attr| attr.check_name(\"thread_local\"));\n@@ -1676,8 +1674,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n             | Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. }))\n             | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n-            | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. })) =>\n-            {\n+            | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. })) => {\n                 let is_local_mutation_allowed = match borrow_kind {\n                     BorrowKind::Unique => LocalMutationIsAllowed::Yes,\n                     BorrowKind::Mut { .. } => is_local_mutation_allowed,\n@@ -1747,28 +1744,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // `act` and `acted_on` are strings that let us abstract over\n         // the verbs used in some diagnostic messages.\n-        let act; let acted_on;\n+        let act;\n+        let acted_on;\n \n         match error_access {\n             AccessKind::Mutate => {\n                 let item_msg = match the_place_err {\n                     Place::Projection(box Projection {\n                         base: _,\n-                        elem: ProjectionElem::Deref }\n-                    ) => match self.describe_place(place) {\n-                        Some(description) =>\n-                            format!(\"`{}` which is behind a `&` reference\", description),\n+                        elem: ProjectionElem::Deref,\n+                    }) => match self.describe_place(place) {\n+                        Some(description) => {\n+                            format!(\"`{}` which is behind a `&` reference\", description)\n+                        }\n                         None => format!(\"data in a `&` reference\"),\n                     },\n                     _ => item_msg,\n                 };\n                 err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                act = \"assign\"; acted_on = \"written\";\n+                act = \"assign\";\n+                acted_on = \"written\";\n             }\n             AccessKind::MutableBorrow => {\n-                err = self.tcx\n+                err = self\n+                    .tcx\n                     .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                act = \"borrow as mutable\"; acted_on = \"borrowed as mutable\";\n+                act = \"borrow as mutable\";\n+                acted_on = \"borrowed as mutable\";\n             }\n         }\n \n@@ -1783,23 +1785,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local_decl = &self.mir.local_decls[*local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n-                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n-                err.span_suggestion(local_decl.source_info.span,\n-                                    \"consider changing this to be mutable\",\n-                                    format!(\"mut {}\", local_decl.name.unwrap()));\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_suggestion(\n+                    local_decl.source_info.span,\n+                    \"consider changing this to be mutable\",\n+                    format!(\"mut {}\", local_decl.name.unwrap()),\n+                );\n             }\n \n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            Place::Local(_) if {\n-                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                    snippet.starts_with(\"&mut \")\n-                } else {\n-                    false\n-                }\n-            } => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+            Place::Local(_)\n+                if {\n+                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                        snippet.starts_with(\"&mut \")\n+                    } else {\n+                        false\n+                    }\n+                } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n@@ -1808,29 +1814,40 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             //\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n-            Place::Projection(box Projection { base: Place::Local(local),\n-                                               elem: ProjectionElem::Deref })\n-                if self.mir.local_decls[*local].is_nonref_binding() =>\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) if self.mir.local_decls[*local].is_nonref_binding() =>\n             {\n                 let (err_help_span, suggested_code) =\n                     find_place_to_suggest_ampmut(self.tcx, self.mir, *local);\n-                err.span_suggestion(err_help_span,\n-                                    \"consider changing this to be a mutable reference\",\n-                                    suggested_code);\n+                err.span_suggestion(\n+                    err_help_span,\n+                    \"consider changing this to be a mutable reference\",\n+                    suggested_code,\n+                );\n \n                 let local_decl = &self.mir.local_decls[*local];\n                 if let Some(name) = local_decl.name {\n                     err.span_label(\n-                        span, format!(\"`{NAME}` is a `&` reference, \\\n-                                       so the data it refers to cannot be {ACTED_ON}\",\n-                                      NAME=name, ACTED_ON=acted_on));\n+                        span,\n+                        format!(\n+                            \"`{NAME}` is a `&` reference, \\\n+                             so the data it refers to cannot be {ACTED_ON}\",\n+                            NAME = name,\n+                            ACTED_ON = acted_on\n+                        ),\n+                    );\n                 } else {\n-                    err.span_label(span, format!(\"cannot {ACT} through `&`-reference\", ACT=act));\n+                    err.span_label(\n+                        span,\n+                        format!(\"cannot {ACT} through `&`-reference\", ACT = act),\n+                    );\n                 }\n             }\n \n             _ => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n             }\n         }\n \n@@ -1852,10 +1869,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // for example, if the RHS is present and the Type is not, then the type is going to\n         // be inferred *from* the RHS, which means we should highlight that (and suggest\n         // that they borrow the RHS mutably).\n-        fn find_place_to_suggest_ampmut<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-                                                         mir: &Mir<'tcx>,\n-                                                         local: Local) -> (Span, String)\n-        {\n+        fn find_place_to_suggest_ampmut<'cx, 'gcx, 'tcx>(\n+            tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+            mir: &Mir<'tcx>,\n+            local: Local,\n+        ) -> (Span, String) {\n             // This implementation attempts to emulate AST-borrowck prioritization\n             // by trying (3.), then (2.) and finally falling back on (1.).\n             let locations = mir.find_assignments(local);\n@@ -1877,7 +1895,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // if this is a variable binding with an explicit type,\n                 // try to highlight that for the suggestion.\n                 Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                    opt_ty_info: Some(ty_span), .. }))) => ty_span,\n+                    opt_ty_info: Some(ty_span),\n+                    ..\n+                }))) => ty_span,\n \n                 Some(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n \n@@ -1896,7 +1916,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn add_used_mut<'d>(\n         &mut self,\n         root_place: RootPlace<'d, 'tcx>,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match root_place {\n             RootPlace {\n@@ -1944,29 +1964,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes => {\n-                            Ok(RootPlace {\n-                                place,\n-                                is_local_mutation_allowed: LocalMutationIsAllowed::Yes\n-                            })\n-                        }\n-                        LocalMutationIsAllowed::ExceptUpvars => {\n-                            Ok(RootPlace {\n-                                place,\n-                                is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars\n-                            })\n-                        }\n+                        LocalMutationIsAllowed::Yes => Ok(RootPlace {\n+                            place,\n+                            is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n+                        }),\n+                        LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n+                            place,\n+                            is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n+                        }),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n-                    Mutability::Mut => Ok(RootPlace { place, is_local_mutation_allowed }),\n+                    Mutability::Mut => Ok(RootPlace {\n+                        place,\n+                        is_local_mutation_allowed,\n+                    }),\n                 }\n             }\n-            Place::Static(ref static_) =>\n+            Place::Static(ref static_) => {\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n-                    Ok(RootPlace { place, is_local_mutation_allowed })\n-                },\n+                    Ok(RootPlace {\n+                        place,\n+                        is_local_mutation_allowed,\n+                    })\n+                }\n+            }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n@@ -2004,7 +2027,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n-                                        return Ok(RootPlace { place, is_local_mutation_allowed });\n+                                        return Ok(RootPlace {\n+                                            place,\n+                                            is_local_mutation_allowed,\n+                                        });\n                                     }\n                                 }\n                             }\n@@ -2063,7 +2089,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // }\n                                     // ```\n                                     let _ = self.is_mutable(&proj.base, is_local_mutation_allowed)?;\n-                                    Ok(RootPlace { place, is_local_mutation_allowed })\n+                                    Ok(RootPlace {\n+                                        place,\n+                                        is_local_mutation_allowed,\n+                                    })\n                                 }\n                             }\n                         } else {\n@@ -2083,7 +2112,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *place {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n-                    let is_projection_from_ty_closure = proj.base\n+                    let is_projection_from_ty_closure = proj\n+                        .base\n                         .ty(self.mir, self.tcx)\n                         .to_ty(self.tcx)\n                         .is_closure();\n@@ -2185,4 +2215,3 @@ impl ContextKind {\n         }\n     }\n }\n-"}, {"sha": "be87365bdbb5d98bb370ffca66e6071ff667aae6", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 470, "deletions": 313, "changes": 783, "blob_url": "https://github.com/rust-lang/rust/blob/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dae309ca1c8ae89384170de2e5d4683d5f94cd4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "patch": "@@ -8,15 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::{self, TyCtxt};\n use rustc::session::config::BorrowckMode;\n+use rustc::ty::{self, TyCtxt};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use syntax_pos::{MultiSpan, Span};\n \n use std::fmt;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Origin { Ast, Mir }\n+pub enum Origin {\n+    Ast,\n+    Mir,\n+}\n \n impl fmt::Display for Origin {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n@@ -53,474 +56,628 @@ impl Origin {\n }\n \n pub trait BorrowckErrors<'cx>: Sized + Copy {\n-    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n-                                                     sp: S,\n-                                                     msg: &str,\n-                                                     code: DiagnosticId)\n-                                                     -> DiagnosticBuilder<'cx>;\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(\n+        self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'cx>;\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self,\n-                                           sp: S,\n-                                           msg: &str)\n-                                           -> DiagnosticBuilder<'cx>;\n+    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx>;\n \n     /// Cancels the given error if we shouldn't emit errors for a given\n     /// origin in the current mode.\n     ///\n     /// Always make sure that the error gets passed through this function\n     /// before you return it.\n-    fn cancel_if_wrong_origin(self,\n-                              diag: DiagnosticBuilder<'cx>,\n-                              o: Origin)\n-                              -> DiagnosticBuilder<'cx>;\n-\n-    fn cannot_move_when_borrowed(self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0505,\n-                                   \"cannot move out of `{}` because it is borrowed{OGN}\",\n-                                   desc, OGN=o);\n+    fn cancel_if_wrong_origin(\n+        self,\n+        diag: DiagnosticBuilder<'cx>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx>;\n+\n+    fn cannot_move_when_borrowed(\n+        self,\n+        span: Span,\n+        desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0505,\n+            \"cannot move out of `{}` because it is borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_use_when_mutably_borrowed(self,\n-                                        span: Span,\n-                                        desc: &str,\n-                                        borrow_span: Span,\n-                                        borrow_desc: &str,\n-                                        o: Origin)\n-                                        -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0503,\n-                         \"cannot use `{}` because it was mutably borrowed{OGN}\",\n-                         desc, OGN=o);\n-\n-        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", borrow_desc));\n+    fn cannot_use_when_mutably_borrowed(\n+        self,\n+        span: Span,\n+        desc: &str,\n+        borrow_span: Span,\n+        borrow_desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0503,\n+            \"cannot use `{}` because it was mutably borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n+\n+        err.span_label(\n+            borrow_span,\n+            format!(\"borrow of `{}` occurs here\", borrow_desc),\n+        );\n         err.span_label(span, format!(\"use of borrowed `{}`\", borrow_desc));\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_uninitialized_variable(self,\n-                                            span: Span,\n-                                            verb: &str,\n-                                            desc: &str,\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0381,\n-                                   \"{} of possibly uninitialized variable: `{}`{OGN}\",\n-                                   verb, desc, OGN=o);\n+    fn cannot_act_on_uninitialized_variable(\n+        self,\n+        span: Span,\n+        verb: &str,\n+        desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0381,\n+            \"{} of possibly uninitialized variable: `{}`{OGN}\",\n+            verb,\n+            desc,\n+            OGN = o\n+        );\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_mutably_borrow_multiply(self,\n-                                      new_loan_span: Span,\n-                                      desc: &str,\n-                                      opt_via: &str,\n-                                      old_loan_span: Span,\n-                                      old_opt_via: &str,\n-                                      old_load_end_span: Option<Span>,\n-                                      o: Origin)\n-                                      -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0499,\n-                         \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n-                         desc, opt_via, OGN=o);\n+    fn cannot_mutably_borrow_multiply(\n+        self,\n+        new_loan_span: Span,\n+        desc: &str,\n+        opt_via: &str,\n+        old_loan_span: Span,\n+        old_opt_via: &str,\n+        old_load_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            new_loan_span,\n+            E0499,\n+            \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n+            desc,\n+            opt_via,\n+            OGN = o\n+        );\n         if old_loan_span == new_loan_span {\n             // Both borrows are happening in the same place\n             // Meaning the borrow is occurring in a loop\n-            err.span_label(new_loan_span,\n-                           format!(\"mutable borrow starts here in previous \\\n-                                    iteration of loop{}\", opt_via));\n+            err.span_label(\n+                new_loan_span,\n+                format!(\n+                    \"mutable borrow starts here in previous \\\n+                     iteration of loop{}\",\n+                    opt_via\n+                ),\n+            );\n             if let Some(old_load_end_span) = old_load_end_span {\n                 err.span_label(old_load_end_span, \"mutable borrow ends here\");\n             }\n         } else {\n-            err.span_label(old_loan_span,\n-                           format!(\"first mutable borrow occurs here{}\", old_opt_via));\n-            err.span_label(new_loan_span,\n-                           format!(\"second mutable borrow occurs here{}\", opt_via));\n+            err.span_label(\n+                old_loan_span,\n+                format!(\"first mutable borrow occurs here{}\", old_opt_via),\n+            );\n+            err.span_label(\n+                new_loan_span,\n+                format!(\"second mutable borrow occurs here{}\", opt_via),\n+            );\n             if let Some(old_load_end_span) = old_load_end_span {\n                 err.span_label(old_load_end_span, \"first borrow ends here\");\n             }\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(self,\n-                                              new_loan_span: Span,\n-                                              desc: &str,\n-                                              old_loan_span: Span,\n-                                              old_load_end_span: Option<Span>,\n-                                              o: Origin)\n-                                              -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0524,\n-                         \"two closures require unique access to `{}` at the same time{OGN}\",\n-                         desc, OGN=o);\n-        err.span_label(\n-            old_loan_span,\n-            \"first closure is constructed here\");\n-        err.span_label(\n+    fn cannot_uniquely_borrow_by_two_closures(\n+        self,\n+        new_loan_span: Span,\n+        desc: &str,\n+        old_loan_span: Span,\n+        old_load_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n             new_loan_span,\n-            \"second closure is constructed here\");\n+            E0524,\n+            \"two closures require unique access to `{}` at the same time{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n+        err.span_label(old_loan_span, \"first closure is constructed here\");\n+        err.span_label(new_loan_span, \"second closure is constructed here\");\n         if let Some(old_load_end_span) = old_load_end_span {\n-            err.span_label(\n-                old_load_end_span,\n-                \"borrow from first closure ends here\");\n+            err.span_label(old_load_end_span, \"borrow from first closure ends here\");\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_one_closure(self,\n-                                             new_loan_span: Span,\n-                                             desc_new: &str,\n-                                             opt_via: &str,\n-                                             old_loan_span: Span,\n-                                             noun_old: &str,\n-                                             old_opt_via: &str,\n-                                             previous_end_span: Option<Span>,\n-                                             o: Origin)\n-                                             -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0500,\n-                         \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n-                         desc_new, noun_old, old_opt_via, OGN=o);\n-        err.span_label(new_loan_span,\n-                       format!(\"closure construction occurs here{}\", opt_via));\n-        err.span_label(old_loan_span,\n-                       format!(\"borrow occurs here{}\", old_opt_via));\n+    fn cannot_uniquely_borrow_by_one_closure(\n+        self,\n+        new_loan_span: Span,\n+        desc_new: &str,\n+        opt_via: &str,\n+        old_loan_span: Span,\n+        noun_old: &str,\n+        old_opt_via: &str,\n+        previous_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            new_loan_span,\n+            E0500,\n+            \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n+            desc_new,\n+            noun_old,\n+            old_opt_via,\n+            OGN = o\n+        );\n+        err.span_label(\n+            new_loan_span,\n+            format!(\"closure construction occurs here{}\", opt_via),\n+        );\n+        err.span_label(old_loan_span, format!(\"borrow occurs here{}\", old_opt_via));\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow ends here\");\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_uniquely_borrowed(self,\n-                                                 new_loan_span: Span,\n-                                                 desc_new: &str,\n-                                                 opt_via: &str,\n-                                                 kind_new: &str,\n-                                                 old_loan_span: Span,\n-                                                 old_opt_via: &str,\n-                                                 previous_end_span: Option<Span>,\n-                                                 o: Origin)\n-                                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0501,\n-                         \"cannot borrow `{}`{} as {} because previous closure \\\n-                          requires unique access{OGN}\",\n-                         desc_new, opt_via, kind_new, OGN=o);\n-        err.span_label(new_loan_span,\n-                       format!(\"borrow occurs here{}\", opt_via));\n-        err.span_label(old_loan_span,\n-                       format!(\"closure construction occurs here{}\", old_opt_via));\n+    fn cannot_reborrow_already_uniquely_borrowed(\n+        self,\n+        new_loan_span: Span,\n+        desc_new: &str,\n+        opt_via: &str,\n+        kind_new: &str,\n+        old_loan_span: Span,\n+        old_opt_via: &str,\n+        previous_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            new_loan_span,\n+            E0501,\n+            \"cannot borrow `{}`{} as {} because previous closure \\\n+             requires unique access{OGN}\",\n+            desc_new,\n+            opt_via,\n+            kind_new,\n+            OGN = o\n+        );\n+        err.span_label(new_loan_span, format!(\"borrow occurs here{}\", opt_via));\n+        err.span_label(\n+            old_loan_span,\n+            format!(\"closure construction occurs here{}\", old_opt_via),\n+        );\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow from closure ends here\");\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_borrowed(self,\n-                                        span: Span,\n-                                        desc_new: &str,\n-                                        msg_new: &str,\n-                                        kind_new: &str,\n-                                        old_span: Span,\n-                                        noun_old: &str,\n-                                        kind_old: &str,\n-                                        msg_old: &str,\n-                                        old_load_end_span: Option<Span>,\n-                                        o: Origin)\n-                                        -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0502,\n-                         \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n-                         desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o);\n+    fn cannot_reborrow_already_borrowed(\n+        self,\n+        span: Span,\n+        desc_new: &str,\n+        msg_new: &str,\n+        kind_new: &str,\n+        old_span: Span,\n+        noun_old: &str,\n+        kind_old: &str,\n+        msg_old: &str,\n+        old_load_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0502,\n+            \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n+            desc_new,\n+            msg_new,\n+            kind_new,\n+            noun_old,\n+            kind_old,\n+            msg_old,\n+            OGN = o\n+        );\n         err.span_label(span, format!(\"{} borrow occurs here{}\", kind_new, msg_new));\n-        err.span_label(old_span, format!(\"{} borrow occurs here{}\", kind_old, msg_old));\n+        err.span_label(\n+            old_span,\n+            format!(\"{} borrow occurs here{}\", kind_old, msg_old),\n+        );\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_to_borrowed(self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0506,\n-                         \"cannot assign to `{}` because it is borrowed{OGN}\",\n-                         desc, OGN=o);\n+    fn cannot_assign_to_borrowed(\n+        self,\n+        span: Span,\n+        borrow_span: Span,\n+        desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0506,\n+            \"cannot assign to `{}` because it is borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n \n         err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", desc));\n-        err.span_label(span, format!(\"assignment to borrowed `{}` occurs here\", desc));\n+        err.span_label(\n+            span,\n+            format!(\"assignment to borrowed `{}` occurs here\", desc),\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin)\n-                                -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0504,\n-                                   \"cannot move `{}` into closure because it is borrowed{OGN}\",\n-                                   desc, OGN=o);\n+    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0504,\n+            \"cannot move `{}` into closure because it is borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reassign_immutable(self, span: Span, desc: &str, is_arg: bool, o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_reassign_immutable(\n+        self,\n+        span: Span,\n+        desc: &str,\n+        is_arg: bool,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         let msg = if is_arg {\n             \"to immutable argument\"\n         } else {\n             \"twice to immutable variable\"\n         };\n-        let err = struct_span_err!(self, span, E0384,\n-                                   \"cannot assign {} `{}`{OGN}\",\n-                                   msg, desc, OGN=o);\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0384,\n+            \"cannot assign {} `{}`{OGN}\",\n+            msg,\n+            desc,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign(self, span: Span, desc: &str, o: Origin)\n-                     -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0594,\n-                                  \"cannot assign to {}{OGN}\",\n-                                  desc, OGN=o);\n+    fn cannot_assign(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(self, span, E0594, \"cannot assign to {}{OGN}\", desc, OGN = o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin)\n-                            -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n \n-    fn cannot_move_out_of(self, move_from_span: Span, move_from_desc: &str, o: Origin)\n-                          -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, move_from_span, E0507,\n-                                       \"cannot move out of {}{OGN}\",\n-                                       move_from_desc, OGN=o);\n+    fn cannot_move_out_of(\n+        self,\n+        move_from_span: Span,\n+        move_from_desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            move_from_span,\n+            E0507,\n+            \"cannot move out of {}{OGN}\",\n+            move_from_desc,\n+            OGN = o\n+        );\n         err.span_label(\n             move_from_span,\n-            format!(\"cannot move out of {}\", move_from_desc));\n+            format!(\"cannot move out of {}\", move_from_desc),\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n     /// Signal an error due to an attempt to move out of the interior\n     /// of an array or slice. `is_index` is None when error origin\n     /// didn't capture whether there was an indexing operation or not.\n-    fn cannot_move_out_of_interior_noncopy(self,\n-                                           move_from_span: Span,\n-                                           ty: ty::Ty,\n-                                           is_index: Option<bool>,\n-                                           o: Origin)\n-                                           -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_move_out_of_interior_noncopy(\n+        self,\n+        move_from_span: Span,\n+        ty: ty::Ty,\n+        is_index: Option<bool>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         let type_name = match (&ty.sty, is_index) {\n-            (&ty::TyArray(_, _), Some(true)) |\n-            (&ty::TyArray(_, _), None) => \"array\",\n-            (&ty::TySlice(_),    _) => \"slice\",\n+            (&ty::TyArray(_, _), Some(true)) | (&ty::TyArray(_, _), None) => \"array\",\n+            (&ty::TySlice(_), _) => \"slice\",\n             _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),\n         };\n-        let mut err = struct_span_err!(self, move_from_span, E0508,\n-                                       \"cannot move out of type `{}`, \\\n-                                        a non-copy {}{OGN}\",\n-                                       ty, type_name, OGN=o);\n+        let mut err = struct_span_err!(\n+            self,\n+            move_from_span,\n+            E0508,\n+            \"cannot move out of type `{}`, \\\n+             a non-copy {}{OGN}\",\n+            ty,\n+            type_name,\n+            OGN = o\n+        );\n         err.span_label(move_from_span, \"cannot move out of here\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_of_drop(self,\n-                                           move_from_span: Span,\n-                                           container_ty: ty::Ty,\n-                                           o: Origin)\n-                                           -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, move_from_span, E0509,\n-                                       \"cannot move out of type `{}`, \\\n-                                        which implements the `Drop` trait{OGN}\",\n-                                       container_ty, OGN=o);\n+    fn cannot_move_out_of_interior_of_drop(\n+        self,\n+        move_from_span: Span,\n+        container_ty: ty::Ty,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            move_from_span,\n+            E0509,\n+            \"cannot move out of type `{}`, \\\n+             which implements the `Drop` trait{OGN}\",\n+            container_ty,\n+            OGN = o\n+        );\n         err.span_label(move_from_span, \"cannot move out of here\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_moved_value(self,\n-                                 use_span: Span,\n-                                 verb: &str,\n-                                 optional_adverb_for_moved: &str,\n-                                 moved_path: Option<String>,\n-                                 o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let moved_path = moved_path.map(|mp| format!(\": `{}`\", mp)).unwrap_or(\"\".to_owned());\n-\n-        let err = struct_span_err!(self, use_span, E0382,\n-                                   \"{} of {}moved value{}{OGN}\",\n-                                   verb, optional_adverb_for_moved, moved_path, OGN=o);\n+    fn cannot_act_on_moved_value(\n+        self,\n+        use_span: Span,\n+        verb: &str,\n+        optional_adverb_for_moved: &str,\n+        moved_path: Option<String>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let moved_path = moved_path\n+            .map(|mp| format!(\": `{}`\", mp))\n+            .unwrap_or(\"\".to_owned());\n+\n+        let err = struct_span_err!(\n+            self,\n+            use_span,\n+            E0382,\n+            \"{} of {}moved value{}{OGN}\",\n+            verb,\n+            optional_adverb_for_moved,\n+            moved_path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_partially_reinit_an_uninit_struct(self,\n-                                                span: Span,\n-                                                uninit_path: &str,\n-                                                o: Origin)\n-                                                -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self,\n-                                   span,\n-                                   E0383,\n-                                   \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n-                                   uninit_path, OGN=o);\n+    fn cannot_partially_reinit_an_uninit_struct(\n+        self,\n+        span: Span,\n+        uninit_path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0383,\n+            \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+            uninit_path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn closure_cannot_assign_to_borrowed(self,\n-                                         span: Span,\n-                                         descr: &str,\n-                                         o: Origin)\n-                                         -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n-                                   descr, OGN=o);\n+    fn closure_cannot_assign_to_borrowed(\n+        self,\n+        span: Span,\n+        descr: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0595,\n+            \"closure cannot assign to {}{OGN}\",\n+            descr,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(self,\n-                                     span: Span,\n-                                     path: &str,\n-                                     o: Origin)\n-                                     -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n-                                   path, OGN=o);\n+    fn cannot_borrow_path_as_mutable(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0596,\n+            \"cannot borrow {} as mutable{OGN}\",\n+            path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_across_generator_yield(self,\n-                                            span: Span,\n-                                            yield_span: Span,\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self,\n-                                       span,\n-                                       E0626,\n-                                       \"borrow may still be in use when generator yields{OGN}\",\n-                                       OGN=o);\n+    fn cannot_borrow_across_generator_yield(\n+        self,\n+        span: Span,\n+        yield_span: Span,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0626,\n+            \"borrow may still be in use when generator yields{OGN}\",\n+            OGN = o\n+        );\n         err.span_label(yield_span, \"possible yield occurs here\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn path_does_not_live_long_enough(self,\n-                                      span: Span,\n-                                      path: &str,\n-                                      o: Origin)\n-                                      -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n-                                   path, OGN=o);\n+    fn path_does_not_live_long_enough(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0597,\n+            \"{} does not live long enough{OGN}\",\n+            path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn lifetime_too_short_for_reborrow(self,\n-                                       span: Span,\n-                                       path: &str,\n-                                       o: Origin)\n-                                       -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0598,\n-                                   \"lifetime of {} is too short to guarantee \\\n-                                    its contents can be safely reborrowed{OGN}\",\n-                                   path, OGN=o);\n+    fn lifetime_too_short_for_reborrow(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0598,\n+            \"lifetime of {} is too short to guarantee \\\n+             its contents can be safely reborrowed{OGN}\",\n+            path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_capture_in_sharable_fn(self,\n-                                            span: Span,\n-                                            bad_thing: &str,\n-                                            help: (Span, &str),\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_act_on_capture_in_sharable_fn(\n+        self,\n+        span: Span,\n+        bad_thing: &str,\n+        help: (Span, &str),\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         let (help_span, help_msg) = help;\n-        let mut err = struct_span_err!(self, span, E0387,\n-                                       \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n-                                       bad_thing, OGN=o);\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0387,\n+            \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+            bad_thing,\n+            OGN = o\n+        );\n         err.span_help(help_span, help_msg);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_into_immutable_reference(self,\n-                                              span: Span,\n-                                              bad_thing: &str,\n-                                              o: Origin)\n-                                              -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n-                                       bad_thing, OGN=o);\n+    fn cannot_assign_into_immutable_reference(\n+        self,\n+        span: Span,\n+        bad_thing: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0389,\n+            \"{} in a `&` reference{OGN}\",\n+            bad_thing,\n+            OGN = o\n+        );\n         err.span_label(span, \"assignment into an immutable reference\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_capture_in_long_lived_closure(self,\n-                                            closure_span: Span,\n-                                            borrowed_path: &str,\n-                                            capture_span: Span,\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, closure_span, E0373,\n-                                       \"closure may outlive the current function, \\\n-                                        but it borrows {}, \\\n-                                        which is owned by the current function{OGN}\",\n-                                       borrowed_path, OGN=o);\n+    fn cannot_capture_in_long_lived_closure(\n+        self,\n+        closure_span: Span,\n+        borrowed_path: &str,\n+        capture_span: Span,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            closure_span,\n+            E0373,\n+            \"closure may outlive the current function, \\\n+             but it borrows {}, \\\n+             which is owned by the current function{OGN}\",\n+            borrowed_path,\n+            OGN = o\n+        );\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n-            .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n+            .span_label(\n+                closure_span,\n+                format!(\"may outlive borrowed value {}\", borrowed_path),\n+            );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n }\n \n impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n-    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n-                                                     sp: S,\n-                                                     msg: &str,\n-                                                     code: DiagnosticId)\n-                                                     -> DiagnosticBuilder<'cx>\n-    {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(\n+        self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'cx> {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self,\n-                                           sp: S,\n-                                           msg: &str)\n-                                           -> DiagnosticBuilder<'cx>\n-    {\n+    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx> {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin(self,\n-                              mut diag: DiagnosticBuilder<'cx>,\n-                              o: Origin)\n-                              -> DiagnosticBuilder<'cx>\n-    {\n+    fn cancel_if_wrong_origin(\n+        self,\n+        mut diag: DiagnosticBuilder<'cx>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }"}]}