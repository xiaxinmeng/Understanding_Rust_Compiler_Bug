{"sha": "e7337fc9c3b4995fdab4e90871bfb48a26d5eaec", "node_id": "C_kwDOAAsO6NoAKGU3MzM3ZmM5YzNiNDk5NWZkYWI0ZTkwODcxYmZiNDhhMjZkNWVhZWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T12:52:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T12:52:18Z"}, "message": "Auto merge of #14426 - HKalbasi:master, r=HKalbasi\n\nfix stack overflow in `is_ty_uninhabited_from`\n\nfix #14421", "tree": {"sha": "fd38d3abc896814588b311b2e4c1998e8822ebcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd38d3abc896814588b311b2e4c1998e8822ebcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec", "html_url": "https://github.com/rust-lang/rust/commit/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a375ad668cde817d5ee18a5f96cbc7f3044b812e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a375ad668cde817d5ee18a5f96cbc7f3044b812e", "html_url": "https://github.com/rust-lang/rust/commit/a375ad668cde817d5ee18a5f96cbc7f3044b812e"}, {"sha": "d0d4245a7445830f8eafa3398b591f1030b3040e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d4245a7445830f8eafa3398b591f1030b3040e", "html_url": "https://github.com/rust-lang/rust/commit/d0d4245a7445830f8eafa3398b591f1030b3040e"}], "stats": {"total": 59, "additions": 55, "deletions": 4}, "files": [{"sha": "39324d27306b31368e78c0b3661860dd9e8640e0", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=e7337fc9c3b4995fdab4e90871bfb48a26d5eaec", "patch": "@@ -9,14 +9,16 @@ use hir_def::{\n     adt::VariantData, attr::Attrs, visibility::Visibility, AdtId, EnumVariantId, HasModule, Lookup,\n     ModuleId, VariantId,\n };\n+use rustc_hash::FxHashSet;\n \n use crate::{\n     consteval::try_const_usize, db::HirDatabase, Binders, Interner, Substitution, Ty, TyKind,\n };\n \n /// Checks whether a type is visibly uninhabited from a particular module.\n pub(crate) fn is_ty_uninhabited_from(ty: &Ty, target_mod: ModuleId, db: &dyn HirDatabase) -> bool {\n-    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let mut uninhabited_from =\n+        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: FxHashSet::default() };\n     let inhabitedness = ty.visit_with(&mut uninhabited_from, DebruijnIndex::INNERMOST);\n     inhabitedness == BREAK_VISIBLY_UNINHABITED\n }\n@@ -32,7 +34,8 @@ pub(crate) fn is_enum_variant_uninhabited_from(\n     let vars_attrs = db.variants_attrs(variant.parent);\n     let is_local = variant.parent.lookup(db.upcast()).container.krate() == target_mod.krate();\n \n-    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let mut uninhabited_from =\n+        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: FxHashSet::default() };\n     let inhabitedness = uninhabited_from.visit_variant(\n         variant.into(),\n         &enum_data.variants[variant.local_id].variant_data,\n@@ -45,6 +48,9 @@ pub(crate) fn is_enum_variant_uninhabited_from(\n \n struct UninhabitedFrom<'a> {\n     target_mod: ModuleId,\n+    recursive_ty: FxHashSet<Ty>,\n+    // guard for preventing stack overflow in non trivial non terminating types\n+    max_depth: usize,\n     db: &'a dyn HirDatabase,\n }\n \n@@ -65,7 +71,14 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n         ty: &Ty,\n         outer_binder: DebruijnIndex,\n     ) -> ControlFlow<VisiblyUninhabited> {\n-        match ty.kind(Interner) {\n+        if self.recursive_ty.contains(ty) || self.max_depth == 0 {\n+            // rustc considers recursive types always inhabited. I think it is valid to consider\n+            // recursive types as always uninhabited, but we should do what rustc is doing.\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+        self.recursive_ty.insert(ty.clone());\n+        self.max_depth -= 1;\n+        let r = match ty.kind(Interner) {\n             TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n             TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n             TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n@@ -75,7 +88,10 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n             },\n \n             TyKind::Ref(..) | _ => CONTINUE_OPAQUELY_INHABITED,\n-        }\n+        };\n+        self.recursive_ty.remove(ty);\n+        self.max_depth += 1;\n+        r\n     }\n \n     fn interner(&self) -> Interner {"}, {"sha": "0b66350894ae564c4365a45e669d5a2ffaffbd71", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7337fc9c3b4995fdab4e90871bfb48a26d5eaec/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=e7337fc9c3b4995fdab4e90871bfb48a26d5eaec", "patch": "@@ -692,6 +692,41 @@ fn f(inp: (Foo, Foo, Foo, Foo)) {\n         );\n     }\n \n+    #[test]\n+    // FIXME: We should have tests for `is_ty_uninhabited_from`\n+    fn regression_14421() {\n+        check_diagnostics(\n+            r#\"\n+pub enum Tree {\n+    Node(TreeNode),\n+    Leaf(TreeLeaf),\n+}\n+\n+struct Box<T>(&T);\n+\n+pub struct TreeNode {\n+    pub depth: usize,\n+    pub children: [Box<Tree>; 8]\n+}\n+\n+pub struct TreeLeaf {\n+    pub depth: usize,\n+    pub data: u8\n+}\n+\n+pub fn test() {\n+    let mut tree = Tree::Leaf(\n+      //^^^^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        TreeLeaf {\n+            depth: 0,\n+            data: 0\n+        }\n+    );\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn fn_traits() {\n         check_diagnostics("}]}