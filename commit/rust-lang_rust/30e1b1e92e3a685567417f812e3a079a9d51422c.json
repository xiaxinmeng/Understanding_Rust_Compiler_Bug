{"sha": "30e1b1e92e3a685567417f812e3a079a9d51422c", "node_id": "C_kwDOAAsO6NoAKDMwZTFiMWU5MmUzYTY4NTU2NzQxN2Y4MTJlM2EwNzlhOWQ1MTQyMmM", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-12-13T18:47:28Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:27Z"}, "message": "Address code review comments\n\n1. Add test case for partial drops\n2. Simplify code in `propagate_to_fixpoint` and remove most clones\n3. Clean up PostOrderIndex creation", "tree": {"sha": "e9b776182f82f4bba137c4206deb2242fe2ce6e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b776182f82f4bba137c4206deb2242fe2ce6e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30e1b1e92e3a685567417f812e3a079a9d51422c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30e1b1e92e3a685567417f812e3a079a9d51422c", "html_url": "https://github.com/rust-lang/rust/commit/30e1b1e92e3a685567417f812e3a079a9d51422c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30e1b1e92e3a685567417f812e3a079a9d51422c/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006f5471629e309c19084698e3bcb494ce60d808", "url": "https://api.github.com/repos/rust-lang/rust/commits/006f5471629e309c19084698e3bcb494ce60d808", "html_url": "https://github.com/rust-lang/rust/commit/006f5471629e309c19084698e3bcb494ce60d808"}], "stats": {"total": 65, "additions": 43, "deletions": 22}, "files": [{"sha": "7b76ff5e02bf7b0052589018b9a21e80fa3665d3", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/30e1b1e92e3a685567417f812e3a079a9d51422c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e1b1e92e3a685567417f812e3a079a9d51422c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=30e1b1e92e3a685567417f812e3a079a9d51422c", "patch": "@@ -34,13 +34,13 @@ use crate::expr_use_visitor;\n /// record the parent expression, which is the point where the drop actually takes place.\n pub struct ExprUseDelegate<'tcx> {\n     hir: Map<'tcx>,\n-    /// Records the point at which an expression or local variable is dropped.\n+    /// Records the variables/expressions that are dropped by a given expression.\n     ///\n     /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n     /// or values that are consumed by that expression.\n     ///\n     /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n-    /// not considered a drop of `x`.\n+    /// not considered a drop of `x`, although it would be a drop of `x.y`.\n     consumed_places: HirIdMap<HirIdSet>,\n     /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n     borrowed_places: HirIdSet,\n@@ -437,29 +437,29 @@ impl DropRanges {\n             let mut changed = false;\n             for id in self.nodes.indices() {\n                 let old_state = self.nodes[id].drop_state.clone();\n-                if preds[id].len() != 0 {\n-                    self.nodes[id].drop_state = self.nodes[preds[id][0]].drop_state.clone();\n-                    for pred in &preds[id][1..] {\n-                        let state = self.nodes[*pred].drop_state.clone();\n-                        self.nodes[id].drop_state.intersect(&state);\n-                    }\n+                let mut new_state = if id.index() == 0 {\n+                    BitSet::new_empty(self.num_values())\n                 } else {\n-                    self.nodes[id].drop_state = if id.index() == 0 {\n-                        BitSet::new_empty(self.num_values())\n-                    } else {\n-                        // If we are not the start node and we have no predecessors, treat\n-                        // everything as dropped because there's no way to get here anyway.\n-                        BitSet::new_filled(self.num_values())\n-                    };\n+                    // If we are not the start node and we have no predecessors, treat\n+                    // everything as dropped because there's no way to get here anyway.\n+                    BitSet::new_filled(self.num_values())\n                 };\n-                for drop in &self.nodes[id].drops.clone() {\n-                    self.nodes[id].drop_state.insert(*drop);\n+\n+                for pred in &preds[id] {\n+                    let state = &self.nodes[*pred].drop_state;\n+                    new_state.intersect(state);\n+                }\n+\n+                for drop in &self.nodes[id].drops {\n+                    new_state.insert(*drop);\n                 }\n-                for reinit in &self.nodes[id].reinits.clone() {\n-                    self.nodes[id].drop_state.remove(*reinit);\n+\n+                for reinit in &self.nodes[id].reinits {\n+                    new_state.remove(*reinit);\n                 }\n \n-                changed |= old_state != self.nodes[id].drop_state;\n+                changed |= old_state != new_state;\n+                self.nodes[id].drop_state = new_state;\n             }\n \n             changed\n@@ -476,7 +476,7 @@ impl DropRanges {\n         let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n         for (id, node) in self.nodes.iter_enumerated() {\n             if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n-                preds[<_>::from(id.index() + 1)].push(id);\n+                preds[id + 1].push(id);\n             } else {\n                 for succ in &node.successors {\n                     preds[*succ].push(id);\n@@ -501,7 +501,7 @@ impl<'a> dot::GraphWalk<'a> for DropRanges {\n             .iter_enumerated()\n             .flat_map(|(i, node)| {\n                 if node.successors.len() == 0 {\n-                    vec![(i, PostOrderId::from_usize(i.index() + 1))]\n+                    vec![(i, i + 1)]\n                 } else {\n                     node.successors.iter().map(move |&s| (i, s)).collect()\n                 }"}, {"sha": "a2f616aa31336db1d9d945d53c99f11f2f0d70ee", "filename": "src/test/ui/generator/partial-drop.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/30e1b1e92e3a685567417f812e3a079a9d51422c/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e1b1e92e3a685567417f812e3a079a9d51422c/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs?ref=30e1b1e92e3a685567417f812e3a079a9d51422c", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+#![feature(negative_impls, generators)]\n+\n+struct Foo;\n+impl !Send for Foo {}\n+\n+struct Bar {\n+    foo: Foo,\n+    x: i32,\n+}\n+\n+fn main() {\n+    assert_send(|| {\n+        let guard = Bar { foo: Foo, x: 42 };\n+        drop(guard.foo);\n+        yield;\n+    })\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}]}