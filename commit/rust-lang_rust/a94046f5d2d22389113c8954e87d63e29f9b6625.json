{"sha": "a94046f5d2d22389113c8954e87d63e29f9b6625", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NDA0NmY1ZDJkMjIzODkxMTNjODk1NGU4N2Q2M2UyOWY5YjY2MjU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-30T01:42:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-30T01:42:53Z"}, "message": "Teach typechecker about record types.", "tree": {"sha": "81124655656a7459c99135defa0b14d896ce3fc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81124655656a7459c99135defa0b14d896ce3fc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a94046f5d2d22389113c8954e87d63e29f9b6625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a94046f5d2d22389113c8954e87d63e29f9b6625", "html_url": "https://github.com/rust-lang/rust/commit/a94046f5d2d22389113c8954e87d63e29f9b6625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a94046f5d2d22389113c8954e87d63e29f9b6625/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "html_url": "https://github.com/rust-lang/rust/commit/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f"}], "stats": {"total": 110, "additions": 109, "deletions": 1}, "files": [{"sha": "4fc847af8bd453c06d87dff1aab36cda132d626e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a94046f5d2d22389113c8954e87d63e29f9b6625/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94046f5d2d22389113c8954e87d63e29f9b6625/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a94046f5d2d22389113c8954e87d63e29f9b6625", "patch": "@@ -26,6 +26,7 @@ type fn_ctxt = rec(@ty ret_ty,\n                    @crate_ctxt ccx);\n \n type arg = rec(ast.mode mode, @ty ty);\n+type field = rec(ast.ident label, @ty ty);\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n@@ -41,6 +42,7 @@ tag sty {\n     ty_box(@ty);\n     ty_vec(@ty);\n     ty_tup(vec[@ty]);\n+    ty_rec(vec[field]);\n     ty_fn(vec[arg], @ty);                           // TODO: effect\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n@@ -52,6 +54,9 @@ tag type_err {\n     terr_mismatch;\n     terr_tuple_size(uint, uint);\n     terr_tuple_mutability;\n+    terr_record_size(uint, uint);\n+    terr_record_mutability;\n+    terr_record_fields(ast.ident,ast.ident);\n     terr_arg_count;\n }\n \n@@ -78,6 +83,10 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n         ret s + ast_ty_to_str(input.ty);\n     }\n \n+    fn ast_field_to_str(&tup(ast.ident, @ast.ty) f) -> str {\n+        ret ast_ty_to_str(f._1) + \" \" + f._0;\n+    }\n+\n     auto s;\n     alt (ty.node) {\n         case (ast.ty_nil)          { s = \"()\";                            }\n@@ -97,6 +106,14 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n             s += \")\";\n         }\n \n+        case (ast.ty_rec(?elems)) {\n+            auto f = ast_field_to_str;\n+            s = \"rec(\";\n+            s += _str.connect(_vec.map[tup(ast.ident, @ast.ty),str]\n+                              (f, elems), \",\");\n+            s += \")\";\n+        }\n+\n         case (ast.ty_fn(?inputs, ?output)) {\n             auto f = ast_fn_input_to_str;\n             s = \"fn(\";\n@@ -154,6 +171,10 @@ fn ty_to_str(&@ty typ) -> str {\n         ret s + ty_to_str(input.ty);\n     }\n \n+    fn field_to_str(&field f) -> str {\n+        ret ty_to_str(f.ty) + \" \" + f.label;\n+    }\n+\n     auto s = \"\";\n     if (typ.mut == ast.mut) {\n         s += \"mutable \";\n@@ -176,6 +197,12 @@ fn ty_to_str(&@ty typ) -> str {\n             s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n+        case (ty_rec(?elems)) {\n+            auto f = field_to_str;\n+            auto strs = _vec.map[field,str](f, elems);\n+            s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n+        }\n+\n         case (ty_fn(?inputs, ?output)) {\n             auto f = fn_input_to_str;\n             s = \"fn(\" + _str.connect(_vec.map[arg,str](f, inputs),\n@@ -222,6 +249,14 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n             }\n             sty = ty_tup(flds);\n         }\n+        case (ast.ty_rec(?fields)) {\n+            let vec[field] flds = vec();\n+            for (tup(ast.ident, @ast.ty) f in fields) {\n+                append[field](flds, rec(label=f._0,\n+                                        ty=ast_ty_to_ty(getter, f._1)));\n+            }\n+            sty = ty_rec(flds);\n+        }\n \n         case (ast.ty_fn(?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(getter, _);\n@@ -281,6 +316,19 @@ fn type_err_to_str(&type_err err) -> str {\n         case (terr_tuple_mutability) {\n             ret \"tuple elements differ in mutability\";\n         }\n+        case (terr_record_size(?e_sz, ?a_sz)) {\n+            ret \"expected a record with \" + _uint.to_str(e_sz, 10u) +\n+                \" fields but found one with \" + _uint.to_str(a_sz, 10u) +\n+                \" fields\";\n+        }\n+        case (terr_record_mutability) {\n+            ret \"record elements differ in mutability\";\n+        }\n+        case (terr_record_fields(?e_fld, ?a_fld)) {\n+            ret \"expected a record with field '\" + e_fld +\n+                \"' but found one with field '\" + a_fld +\n+                \"'\";\n+        }\n         case (terr_arg_count) {\n             ret \"incorrect number of function parameters\";\n         }\n@@ -445,8 +493,9 @@ fn type_is_nil(@ty t) -> bool {\n \n fn type_is_structural(@ty t) -> bool {\n     alt (t.struct) {\n-        // FIXME: cover rec and tag when we support them.\n+        // FIXME: cover tag when we support it.\n         case (ty_tup(_)) { ret true; }\n+        case (ty_rec(_)) { ret true; }\n     }\n     ret false;\n }\n@@ -726,6 +775,65 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n             }\n \n+            case (ty_rec(?expected_fields)) {\n+                alt (actual.struct) {\n+                    case (ty_rec(?actual_fields)) {\n+                        auto expected_len = _vec.len[field](expected_fields);\n+                        auto actual_len = _vec.len[field](actual_fields);\n+                        if (expected_len != actual_len) {\n+                            auto err = terr_record_size(expected_len,\n+                                                        actual_len);\n+                            ret ures_err(err, expected, actual);\n+                        }\n+\n+                        // TODO: implement an iterator that can iterate over\n+                        // two arrays simultaneously.\n+                        let vec[field] result_fields = vec();\n+                        auto i = 0u;\n+                        while (i < expected_len) {\n+                            auto expected_field = expected_fields.(i);\n+                            auto actual_field = actual_fields.(i);\n+                            if (expected_field.ty.mut != actual_field.ty.mut) {\n+                                auto err = terr_record_mutability;\n+                                ret ures_err(err, expected, actual);\n+                            }\n+\n+                            if (!_str.eq(expected_field.label,\n+                                        actual_field.label)) {\n+                                auto err =\n+                                    terr_record_fields(expected_field.label,\n+                                                       actual_field.label);\n+                                ret ures_err(err, expected, actual);\n+                            }\n+\n+                            auto result = unify_step(fcx,\n+                                                     bindings,\n+                                                     expected_field.ty,\n+                                                     actual_field.ty);\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    append[field](result_fields,\n+                                                  rec(ty=rty with expected_field));\n+                                }\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n+                        }\n+\n+                        ret ures_ok(plain_ty(ty_rec(result_fields)));\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n             case (ty_fn(?expected_inputs, ?expected_output)) {\n                 alt (actual.struct) {\n                     case (ty_fn(?actual_inputs, ?actual_output)) {"}]}