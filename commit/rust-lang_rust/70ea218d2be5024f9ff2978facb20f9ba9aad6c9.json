{"sha": "70ea218d2be5024f9ff2978facb20f9ba9aad6c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZWEyMThkMmJlNTAyNGY5ZmYyOTc4ZmFjYjIwZjliYTlhYWQ2Yzk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-23T12:35:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-23T12:35:19Z"}, "message": "Reuse more rustc code instead of copying it into miri", "tree": {"sha": "ee9a00fa3b84cf933a16f40894c1f3be989cd5f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee9a00fa3b84cf933a16f40894c1f3be989cd5f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70ea218d2be5024f9ff2978facb20f9ba9aad6c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70ea218d2be5024f9ff2978facb20f9ba9aad6c9", "html_url": "https://github.com/rust-lang/rust/commit/70ea218d2be5024f9ff2978facb20f9ba9aad6c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70ea218d2be5024f9ff2978facb20f9ba9aad6c9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0255a5146874f4e340d470af0f6dd96aa5afe8a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0255a5146874f4e340d470af0f6dd96aa5afe8a8", "html_url": "https://github.com/rust-lang/rust/commit/0255a5146874f4e340d470af0f6dd96aa5afe8a8"}], "stats": {"total": 231, "additions": 12, "deletions": 219}, "files": [{"sha": "77541a5b70fb4e7f254734b9521e4065db2e9434", "filename": "src/traits.rs", "status": "modified", "additions": 12, "deletions": 219, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/70ea218d2be5024f9ff2978facb20f9ba9aad6c9/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ea218d2be5024f9ff2978facb20f9ba9aad6c9/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=70ea218d2be5024f9ff2978facb20f9ba9aad6c9", "patch": "@@ -1,12 +1,11 @@\n-use rustc::traits::{self, Reveal, SelectionContext};\n+use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n use memory::Pointer;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n use syntax::ast;\n \n@@ -43,101 +42,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T:Trait`.\n     pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        let tcx = self.tcx;\n-\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n-        let methods: Vec<_> = traits::supertraits(tcx, trait_ref).flat_map(|trait_ref| {\n-            match self.fulfill_obligation(trait_ref) {\n-                // Should default trait error here?\n-                traits::VtableDefaultImpl(_) |\n-                traits::VtableBuiltin(_) => {\n-                    Vec::new().into_iter()\n-                }\n-\n-                traits::VtableImpl(traits::VtableImplData { impl_def_id: id, substs, .. }) => {\n-                    self.get_vtable_methods(id, substs)\n-                        .into_iter()\n-                        .map(|opt_mth| opt_mth.map(|mth| {\n-                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs)\n-                        }))\n-                        .collect::<Vec<_>>()\n-                        .into_iter()\n-                }\n-\n-                traits::VtableClosure(\n-                    traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        ..\n-                    }\n-                ) => {\n-                    let instance = ::eval_context::resolve_closure(self.tcx, closure_def_id, substs, ty::ClosureKind::FnOnce);\n-                    vec![Some(self.memory.create_fn_alloc(instance))].into_iter()\n-                }\n-\n-                // turn a function definition into a Fn trait object\n-                traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, .. }) => {\n-                    match fn_ty.sty {\n-                        ty::TyFnDef(did, substs, _) => {\n-                            let instance = ty::Instance {\n-                                def: ty::InstanceDef::FnPtrShim(did, fn_ty),\n-                                substs,\n-                            };\n-                            vec![Some(self.memory.create_fn_alloc(instance))].into_iter()\n-                        },\n-                        ty::TyFnPtr(_) => {\n-                            unimplemented!();\n-                        },\n-                        _ => bug!(\"bad VtableFnPointer fn_ty: {:#?}\", fn_ty.sty),\n-                    }\n-                }\n-\n-                traits::VtableObject(ref data) => {\n-                    // this would imply that the Self type being erased is\n-                    // an object type; this cannot happen because we\n-                    // cannot cast an unsized type into a trait object\n-                    bug!(\"cannot get vtable for an object type: {:?}\",\n-                         data);\n-                }\n-\n-                vtable @ traits::VtableParam(..) => {\n-                    bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n-                         trait_ref,\n-                         vtable);\n-                }\n-            }\n-        }).collect();\n-\n         let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n         let align = self.type_align(trait_ref.self_ty())?;\n \n         let ptr_size = self.memory.pointer_size();\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.len() as u64), ptr_size)?;\n+        let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size)?;\n \n-        // in case there is no drop function to be called, this still needs to be initialized\n-        self.memory.write_usize(vtable, 0)?;\n-        let drop_in_place = self.tcx.lang_items.drop_in_place_fn().expect(\"drop_in_place lang item not available\");\n-        if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n-            if adt_def.has_dtor(self.tcx) {\n-                let env = self.tcx.empty_parameter_environment();\n-                let def = if self.tcx.type_needs_drop_given_env(ty, &env) {\n-                    ty::InstanceDef::DropGlue(drop_in_place, Some(ty))\n-                } else {\n-                    ty::InstanceDef::DropGlue(drop_in_place, None)\n-                };\n-                let instance = ty::Instance { substs, def };\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n-                self.memory.write_ptr(vtable, fn_ptr)?;\n-            }\n-        }\n+        let drop = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n+        let drop = self.memory.create_fn_alloc(drop);\n+        self.memory.write_ptr(vtable, drop)?;\n \n         self.memory.write_usize(vtable.offset(ptr_size), size)?;\n         self.memory.write_usize(vtable.offset(ptr_size * 2), align)?;\n \n-        for (i, method) in methods.into_iter().enumerate() {\n-            if let Some(method) = method {\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), method)?;\n+        for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n+            if let Some((def_id, substs)) = method {\n+                let instance = ::eval_context::resolve(self.tcx, def_id, substs);\n+                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), fn_ptr)?;\n             }\n         }\n \n@@ -167,94 +92,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok((size, align))\n     }\n \n-    fn get_vtable_methods(&mut self, impl_id: DefId, substs: &'tcx Substs<'tcx>) -> Vec<Option<ImplMethod<'tcx>>> {\n-        debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n-\n-        let trait_id = match self.tcx.impl_trait_ref(impl_id) {\n-            Some(t_id) => t_id.def_id,\n-            None       => bug!(\"make_impl_vtable: don't know how to \\\n-                                make a vtable for a type impl!\")\n-        };\n-\n-        self.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-\n-        self.tcx\n-            .associated_items(trait_id)\n-            // Filter out non-method items.\n-            .filter_map(|trait_method_type| {\n-                if trait_method_type.kind != ty::AssociatedKind::Method {\n-                    return None;\n-                }\n-                debug!(\"get_vtable_methods: trait_method_type={:?}\",\n-                       trait_method_type);\n-\n-                let name = trait_method_type.name;\n-\n-                // Some methods cannot be called on an object; skip those.\n-                if !self.tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n-                    debug!(\"get_vtable_methods: not vtable safe\");\n-                    return Some(None);\n-                }\n-\n-                debug!(\"get_vtable_methods: trait_method_type={:?}\",\n-                       trait_method_type);\n-\n-                // the method may have some early-bound lifetimes, add\n-                // regions for those\n-                let method_substs = Substs::for_item(self.tcx, trait_method_type.def_id,\n-                                                     |_, _| self.tcx.mk_region(ty::ReErased),\n-                                                     |_, _| self.tcx.types.err);\n-\n-                // The substitutions we have are on the impl, so we grab\n-                // the method type from the impl to substitute into.\n-                let mth = get_impl_method(self.tcx, method_substs, impl_id, substs, name);\n-\n-                debug!(\"get_vtable_methods: mth={:?}\", mth);\n-\n-                // If this is a default method, it's possible that it\n-                // relies on where clauses that do not hold for this\n-                // particular set of type parameters. Note that this\n-                // method could then never be called, so we do not want to\n-                // try and trans it, in that case. Issue #23435.\n-                if mth.is_provided {\n-                    let predicates = self.tcx.item_predicates(trait_method_type.def_id).instantiate_own(self.tcx, mth.substs);\n-                    if !self.normalize_and_test_predicates(predicates.predicates) {\n-                        debug!(\"get_vtable_methods: predicates do not hold\");\n-                        return Some(None);\n-                    }\n-                }\n-\n-                Some(Some(mth))\n-            })\n-            .collect()\n-    }\n-\n-    /// Normalizes the predicates and checks whether they hold.  If this\n-    /// returns false, then either normalize encountered an error or one\n-    /// of the predicates did not hold. Used when creating vtables to\n-    /// check for unsatisfiable methods.\n-    fn normalize_and_test_predicates(&mut self, predicates: Vec<ty::Predicate<'tcx>>) -> bool {\n-        debug!(\"normalize_and_test_predicates(predicates={:?})\",\n-               predicates);\n-\n-        self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let cause = traits::ObligationCause::dummy();\n-            let traits::Normalized { value: predicates, obligations } =\n-                traits::normalize(&mut selcx, cause.clone(), &predicates);\n-            for obligation in obligations {\n-                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-            }\n-            for predicate in predicates {\n-                let obligation = traits::Obligation::new(cause.clone(), predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-            }\n-\n-            fulfill_cx.select_all_or_error(&infcx).is_ok()\n-        })\n-    }\n-\n     pub(crate) fn resolve_associated_const(\n         &self,\n         def_id: DefId,\n@@ -275,47 +112,3 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty::Instance::new(def_id, substs)\n     }\n }\n-\n-#[derive(Debug)]\n-pub(super) struct ImplMethod<'tcx> {\n-    pub(super) method: ty::AssociatedItem,\n-    pub(super) substs: &'tcx Substs<'tcx>,\n-    pub(super) is_provided: bool,\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub(super) fn get_impl_method<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    substs: &'tcx Substs<'tcx>,\n-    impl_def_id: DefId,\n-    impl_substs: &'tcx Substs<'tcx>,\n-    name: ast::Name,\n-) -> ImplMethod<'tcx> {\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id,\n-                                                      substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            ImplMethod {\n-                method: node_item.item,\n-                substs,\n-                is_provided: node_item.node.is_from_trait(),\n-            }\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}"}]}