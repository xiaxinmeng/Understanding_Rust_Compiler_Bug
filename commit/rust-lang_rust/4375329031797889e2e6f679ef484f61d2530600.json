{"sha": "4375329031797889e2e6f679ef484f61d2530600", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNzUzMjkwMzE3OTc4ODllMmU2ZjY3OWVmNDg0ZjYxZDI1MzA2MDA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-12T06:15:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-12T06:15:16Z"}, "message": "rustc: Translate interior vector index expressions", "tree": {"sha": "95551e2d4d9cfc982da4a69884d226bf2e01b804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95551e2d4d9cfc982da4a69884d226bf2e01b804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4375329031797889e2e6f679ef484f61d2530600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4375329031797889e2e6f679ef484f61d2530600", "html_url": "https://github.com/rust-lang/rust/commit/4375329031797889e2e6f679ef484f61d2530600", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4375329031797889e2e6f679ef484f61d2530600/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b318be4ce4381a5f7acc1864914e6ba8b0a5af2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b318be4ce4381a5f7acc1864914e6ba8b0a5af2", "html_url": "https://github.com/rust-lang/rust/commit/8b318be4ce4381a5f7acc1864914e6ba8b0a5af2"}], "stats": {"total": 65, "additions": 57, "deletions": 8}, "files": [{"sha": "c1f80feec333c23a8dfc0091b857cb44713188f5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4375329031797889e2e6f679ef484f61d2530600/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4375329031797889e2e6f679ef484f61d2530600/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4375329031797889e2e6f679ef484f61d2530600", "patch": "@@ -2662,7 +2662,8 @@ fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n         [C_int(0), C_uint(abi::ivec_elt_len)]));\n     auto stack_elem = bcx.build.GEP(v, [C_int(0),\n                                         C_uint(abi::ivec_elt_elems)]);\n-    stack_elem = bcx.build.PointerCast(stack_elem, T_ptr(llunitty));\n+    stack_elem = bcx.build.PointerCast(stack_elem,\n+                                       T_ptr(T_array(llunitty, 0u)));\n \n     auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n \n@@ -2690,21 +2691,21 @@ fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n     // Technically this context is unnecessary, but it makes this function\n     // clearer.\n     auto zero_len = C_int(0);\n-    auto zero_elem = C_null(T_ptr(llunitty));\n+    auto zero_elem = C_null(T_ptr(T_array(llunitty, 0u)));\n     zero_len_cx.build.Br(next_cx.llbb);\n \n     // If we're here, then we actually have a heapified vector.\n     auto heap_len = nonzero_len_cx.build.Load(nonzero_len_cx.build.GEP(\n         heap_ptr, [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n     auto heap_elem = nonzero_len_cx.build.GEP(heap_ptr,\n-        [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+        [C_int(0), C_uint(abi::ivec_heap_elt_elems)]);\n     nonzero_len_cx.build.Br(next_cx.llbb);\n \n     // Now we can figure out the length of `v` and get a pointer to its first\n     // element.\n     auto len = next_cx.build.Phi(T_int(), [stack_len, zero_len, heap_len],\n         [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n-    auto elem = next_cx.build.Phi(T_ptr(llunitty),\n+    auto elem = next_cx.build.Phi(T_ptr(T_array(llunitty, 0u)),\n         [stack_elem, zero_elem, heap_elem],\n         [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n     ret tup(len, elem, next_cx);\n@@ -4743,8 +4744,21 @@ fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base,\n                &@ast::expr idx, &ast::ann ann) -> lval_result {\n \n+    // Is this an interior vector?\n+    auto base_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n+    auto base_ty_no_boxes = ty::strip_boxes(cx.fcx.lcx.ccx.tcx, base_ty);\n+\n+    auto is_interior;\n+    alt (ty::struct(cx.fcx.lcx.ccx.tcx, base_ty_no_boxes)) {\n+        // TODO: Or-patterns\n+        case (ty::ty_vec(_))    { is_interior = false; }\n+        case (ty::ty_str)       { is_interior = false; }\n+        case (ty::ty_ivec(_))   { is_interior = true; }\n+        case (ty::ty_istr)      { is_interior = true; }\n+    };\n+\n     auto lv = trans_expr(cx, base);\n-    lv = autoderef(lv.bcx, lv.val, ty::expr_ty(cx.fcx.lcx.ccx.tcx, base));\n+    lv = autoderef(lv.bcx, lv.val, base_ty);\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n     auto bcx = ix.bcx;\n@@ -4769,8 +4783,23 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base,\n     auto scaled_ix = bcx.build.Mul(ix_val, unit_sz.val);\n     maybe_name_value(cx.fcx.lcx.ccx, scaled_ix, \"scaled_ix\");\n \n-    auto lim = bcx.build.GEP(v, [C_int(0), C_int(abi::vec_elt_fill)]);\n-    lim = bcx.build.Load(lim);\n+    auto interior_len_and_data;\n+    if (is_interior) {\n+        auto rslt = get_ivec_len_and_data(bcx, v, unit_ty);\n+        interior_len_and_data = some(tup(rslt._0, rslt._1));\n+        bcx = rslt._2;\n+    } else {\n+        interior_len_and_data = none;\n+    }\n+\n+    auto lim;\n+    alt (interior_len_and_data) {\n+        case (some(?lad)) { lim = lad._0; }\n+        case (none) {\n+            lim = bcx.build.GEP(v, [C_int(0), C_int(abi::vec_elt_fill)]);\n+            lim = bcx.build.Load(lim);\n+        }\n+    }\n \n     auto bounds_check = bcx.build.ICmp(lib::llvm::LLVMIntULT,\n                                        scaled_ix, lim);\n@@ -4783,7 +4812,14 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base,\n     auto fail_res = trans_fail(fail_cx, some[common::span](sp),\n                                \"bounds check\");\n \n-    auto body = next_cx.build.GEP(v, [C_int(0), C_int(abi::vec_elt_data)]);\n+    auto body;\n+    alt (interior_len_and_data) {\n+        case (some(?lad)) { body = lad._1; }\n+        case (none) {\n+            body = next_cx.build.GEP(v, [C_int(0), C_int(abi::vec_elt_data)]);\n+        }\n+    }\n+\n     auto elt;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, unit_ty)) {\n         body = next_cx.build.PointerCast(body, T_ptr(T_array(T_i8(), 0u)));"}, {"sha": "9df1666acc479d3c93afa91ea69aa10d17e7823b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4375329031797889e2e6f679ef484f61d2530600/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4375329031797889e2e6f679ef484f61d2530600/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4375329031797889e2e6f679ef484f61d2530600", "patch": "@@ -2789,6 +2789,19 @@ fn ret_ty_of_fn(ctxt cx, ast::ann ann) -> t {\n     ret ret_ty_of_fn_ty(cx, ann_to_type(cx, ann));\n }\n \n+// NB: This function requires that the given type has no variables. So, inside\n+// typeck, you should use typeck::strip_boxes() instead.\n+fn strip_boxes(&ctxt cx, &ty::t t) -> ty::t {\n+    auto t1 = t;\n+    while (true) {\n+        alt (struct(cx, t1)) {\n+            case (ty::ty_box(?inner)) { t1 = inner.ty; }\n+            case (_) { ret t1; }\n+        }\n+    }\n+    fail;\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}]}