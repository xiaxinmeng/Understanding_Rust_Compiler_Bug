{"sha": "27235698f5c73b12539e4765e8dccfec8e27c533", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MjM1Njk4ZjVjNzNiMTI1MzllNDc2NWU4ZGNjZmVjOGUyN2M1MzM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-28T01:07:31Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-08T11:15:11Z"}, "message": "resolve: Introduce \"may appear after\" abstraction for macro path resolutions", "tree": {"sha": "89ef57bf132b6d623ae59f4628635448d0e2f001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89ef57bf132b6d623ae59f4628635448d0e2f001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27235698f5c73b12539e4765e8dccfec8e27c533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27235698f5c73b12539e4765e8dccfec8e27c533", "html_url": "https://github.com/rust-lang/rust/commit/27235698f5c73b12539e4765e8dccfec8e27c533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27235698f5c73b12539e4765e8dccfec8e27c533/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a539ade9fa450bc5653309499a87e71a2fe9286", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a539ade9fa450bc5653309499a87e71a2fe9286", "html_url": "https://github.com/rust-lang/rust/commit/9a539ade9fa450bc5653309499a87e71a2fe9286"}], "stats": {"total": 75, "additions": 54, "deletions": 21}, "files": [{"sha": "e1f532232f5599da8c5ab326a87fb7ee19724718", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27235698f5c73b12539e4765e8dccfec8e27c533/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27235698f5c73b12539e4765e8dccfec8e27c533/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=27235698f5c73b12539e4765e8dccfec8e27c533", "patch": "@@ -1269,6 +1269,15 @@ impl<'a> NameBinding<'a> {\n     fn descr(&self) -> &'static str {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n+\n+    // Suppose that we resolved macro invocation with `invoc_id` to binding `binding` at some\n+    // expansion round `max(invoc_id, binding)` when they both emerged from macros.\n+    // Then this function returns `true` if `self` may emerge from a macro *after* that\n+    // in some later round and screw up our previously found resolution.\n+    fn may_appear_after(&self, _invoc_id: Mark, _binding: &NameBinding) -> bool {\n+        // FIXME: This is a very conservative estimation.\n+        self.expansion != Mark::root()\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -3466,6 +3475,20 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_invoc_id(base_module, path, opt_ns, Mark::root(),\n+                                        record_used, path_span, crate_lint)\n+    }\n+\n+    fn resolve_path_with_invoc_id(\n+        &mut self,\n+        base_module: Option<ModuleOrUniformRoot<'a>>,\n+        path: &[Ident],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        invoc_id: Mark,\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         let mut module = base_module;\n         let mut allow_super = true;\n@@ -3555,8 +3578,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used, record_used,\n-                                                        false, path_span).map(|(b, _)| b)\n+                self.resolve_lexical_macro_path_segment(ident, ns, invoc_id, record_used,\n+                                                        record_used, false, path_span)\n+                                                        .map(|(binding, _)| binding)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };"}, {"sha": "af9959c808435ad8c167b97ca0b7e1c3d13fe553", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/27235698f5c73b12539e4765e8dccfec8e27c533/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27235698f5c73b12539e4765e8dccfec8e27c533/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=27235698f5c73b12539e4765e8dccfec8e27c533", "patch": "@@ -431,12 +431,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         Ok((def, self.get_macro(def)))\n     }\n \n-    pub fn resolve_macro_to_def_inner(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    pub fn resolve_macro_to_def_inner(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                                       derives_in_scope: &[ast::Path], force: bool)\n                                       -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n-        let invocation = self.invocations[&scope];\n+        let invocation = self.invocations[&invoc_id];\n         let module = invocation.module.get();\n         self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n \n@@ -448,8 +448,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let res = self.resolve_path(None, &path, Some(MacroNS), false, span, CrateLint::No);\n-            let def = match res {\n+            let def = match self.resolve_path_with_invoc_id(None, &path, Some(MacroNS), invoc_id,\n+                                                            false, span, CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -480,11 +480,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n+        let legacy_resolution =\n+            self.resolve_legacy_scope(path[0], invoc_id, &invocation.legacy_scope, false);\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, force,\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, invoc_id, false, force,\n                                                           kind == MacroKind::Attr, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n@@ -496,7 +497,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0], kind, result.ok()));\n+            .push((invoc_id, path[0], kind, result.ok()));\n \n         if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n             return result;\n@@ -515,7 +516,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         enum ConvertToDeriveHelper { Yes, No, DontKnow }\n         let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n         for derive in derives_in_scope {\n-            match self.resolve_macro_path(derive, MacroKind::Derive, scope, &[], force) {\n+            match self.resolve_macro_path(derive, MacroKind::Derive, invoc_id, &[], force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n                     if inert_attrs.contains(&path[0].name) {\n                         convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n@@ -543,10 +544,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n+        invoc_id: Mark,\n         record_used: bool,\n         force: bool,\n         is_attr: bool,\n-        path_span: Span\n+        path_span: Span,\n     ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n@@ -737,7 +739,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.0.def() != innermost_result.0.def() &&\n                            (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.expansion != Mark::root()) {\n+                            innermost_result.0.may_appear_after(invoc_id, result.0)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: path_span,\n                                 name: ident.name,\n@@ -781,8 +783,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     }\n \n     fn resolve_legacy_scope(&mut self,\n-                            invocation_legacy_scope: &'a Cell<LegacyScope<'a>>,\n                             ident: Ident,\n+                            invoc_id: Mark,\n+                            invoc_parent_legacy_scope: &'a Cell<LegacyScope<'a>>,\n                             record_used: bool)\n                             -> Option<&'a NameBinding<'a>> {\n         let ident = ident.modern();\n@@ -801,7 +804,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<&NameBinding> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = invocation_legacy_scope;\n+        let mut where_to_resolve = invoc_parent_legacy_scope;\n         loop {\n             let result = match where_to_resolve.get() {\n                 LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n@@ -837,7 +840,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if let Some(innermost_result) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.def() != innermost_result.def() &&\n-                           innermost_result.expansion != Mark::root() {\n+                           innermost_result.may_appear_after(invoc_id, result) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: ident.span,\n                                 name: ident.name,\n@@ -875,12 +878,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        for &(mark, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, true,\n-                                                                     kind == MacroKind::Attr, span);\n+            let legacy_scope = &self.invocations[&invoc_id].legacy_scope;\n+            let legacy_resolution = self.resolve_legacy_scope(ident, invoc_id, legacy_scope, true);\n+            let resolution = self.resolve_lexical_macro_path_segment(\n+                ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n+            );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n                 if let Some(def) = def {\n@@ -913,7 +917,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     err.emit();\n                 },\n                 (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n-                        if !from_prelude || legacy_binding.expansion != Mark::root() => {\n+                        if !from_prelude || legacy_binding.may_appear_after(invoc_id, binding) => {\n                     if legacy_binding.def_ignoring_ambiguity() != binding.def_ignoring_ambiguity() {\n                         self.report_ambiguity_error(ident.name, span, legacy_binding, binding);\n                     }"}, {"sha": "f053cb10d0649b893c41a014434097444d6bdff6", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27235698f5c73b12539e4765e8dccfec8e27c533/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27235698f5c73b12539e4765e8dccfec8e27c533/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=27235698f5c73b12539e4765e8dccfec8e27c533", "patch": "@@ -100,6 +100,11 @@ impl Mark {\n         Mark(raw)\n     }\n \n+    #[inline]\n+    pub fn parent(self) -> Mark {\n+        HygieneData::with(|data| data.marks[self.0 as usize].parent)\n+    }\n+\n     #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info.clone())"}]}