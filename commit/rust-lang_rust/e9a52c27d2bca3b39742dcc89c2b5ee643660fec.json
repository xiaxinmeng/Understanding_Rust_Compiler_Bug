{"sha": "e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "node_id": "C_kwDOAAsO6NoAKGU5YTUyYzI3ZDJiY2EzYjM5NzQyZGNjODljMmI1ZWU2NDM2NjBmZWM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-26T19:59:09Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-12T17:49:02Z"}, "message": "Move ident resolution to a dedicated module.", "tree": {"sha": "115bdd23565361d71d7467b55595bd0b0731b6c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/115bdd23565361d71d7467b55595bd0b0731b6c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "html_url": "https://github.com/rust-lang/rust/commit/e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341883d051ebbfaa6daa456b198d557fa0272b71", "url": "https://api.github.com/repos/rust-lang/rust/commits/341883d051ebbfaa6daa456b198d557fa0272b71", "html_url": "https://github.com/rust-lang/rust/commit/341883d051ebbfaa6daa456b198d557fa0272b71"}], "stats": {"total": 3311, "additions": 1668, "deletions": 1643}, "files": [{"sha": "0111ab506c54fb6d5bdca9e739e6f8e4e4065d92", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "added", "additions": 1645, "deletions": 0, "changes": 1645, "blob_url": "https://github.com/rust-lang/rust/blob/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "patch": "@@ -0,0 +1,1645 @@\n+use rustc_ast::{self as ast, NodeId};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::Applicability;\n+use rustc_feature::is_builtin_attr_name;\n+use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n+use rustc_hir::PrimTy;\n+use rustc_middle::bug;\n+use rustc_middle::ty;\n+use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::edition::Edition;\n+use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::ptr;\n+\n+use crate::late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind};\n+use crate::macros::{sub_namespace_match, MacroRulesScope};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n+use crate::{\n+    ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot, NameBinding,\n+};\n+use crate::{\n+    NameBindingKind, ParentScope, PathResult, PrivacyError, Res, ResolutionError, Resolver, Scope,\n+    ScopeSet, Segment,\n+};\n+use crate::{ToNameBinding, Weak};\n+\n+use Determinacy::*;\n+use Namespace::*;\n+use RibKind::*;\n+\n+impl<'a> Resolver<'a> {\n+    /// A generic scope visitor.\n+    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n+    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n+    crate fn visit_scopes<T>(\n+        &mut self,\n+        scope_set: ScopeSet<'a>,\n+        parent_scope: &ParentScope<'a>,\n+        ctxt: SyntaxContext,\n+        mut visitor: impl FnMut(\n+            &mut Self,\n+            Scope<'a>,\n+            /*use_prelude*/ bool,\n+            SyntaxContext,\n+        ) -> Option<T>,\n+    ) -> Option<T> {\n+        // General principles:\n+        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n+        //    built into the language or standard library. This way we can add new names into the\n+        //    language or standard library without breaking user code.\n+        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n+        // Places to search (in order of decreasing priority):\n+        // (Type NS)\n+        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n+        // 4. Tool modules (closed, controlled right now, but not in the future).\n+        // 5. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude (closed, controlled).\n+        // (Value NS)\n+        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Standard library prelude (de-facto closed, controlled).\n+        // (Macro NS)\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n+        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n+        //    (open, the open part is from macro expansions, not controlled).\n+        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n+        // 4c. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+\n+        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n+        let (ns, macro_kind, is_absolute_path) = match scope_set {\n+            ScopeSet::All(ns, _) => (ns, None, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+        let module = match scope_set {\n+            // Start with the specified module.\n+            ScopeSet::Late(_, module, _) => module,\n+            // Jump out of trait or enum modules, they do not act as scopes.\n+            _ => parent_scope.module.nearest_item_scope(),\n+        };\n+        let mut scope = match ns {\n+            _ if is_absolute_path => Scope::CrateRoot,\n+            TypeNS | ValueNS => Scope::Module(module, None),\n+            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n+        };\n+        let mut ctxt = ctxt.normalize_to_macros_2_0();\n+        let mut use_prelude = !module.no_implicit_prelude;\n+\n+        loop {\n+            let visit = match scope {\n+                // Derive helpers are not in scope when resolving derives in the same container.\n+                Scope::DeriveHelpers(expn_id) => {\n+                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n+                }\n+                Scope::DeriveHelpersCompat => true,\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n+                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n+                    // As another consequence of this optimization visitors never observe invocation\n+                    // scopes for macros that were already expanded.\n+                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n+                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n+                            macro_rules_scope.set(next_scope.get());\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    true\n+                }\n+                Scope::CrateRoot => true,\n+                Scope::Module(..) => true,\n+                Scope::RegisteredAttrs => use_prelude,\n+                Scope::MacroUsePrelude => use_prelude || rust_2015,\n+                Scope::BuiltinAttrs => true,\n+                Scope::ExternPrelude => use_prelude || is_absolute_path,\n+                Scope::ToolPrelude => use_prelude,\n+                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n+                Scope::BuiltinTypes => true,\n+            };\n+\n+            if visit {\n+                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n+                    return break_result;\n+                }\n+            }\n+\n+            scope = match scope {\n+                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n+                Scope::DeriveHelpers(expn_id) => {\n+                    // Derive helpers are not visible to code generated by bang or derive macros.\n+                    let expn_data = expn_id.expn_data();\n+                    match expn_data.kind {\n+                        ExpnKind::Root\n+                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n+                            Scope::DeriveHelpersCompat\n+                        }\n+                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n+                    }\n+                }\n+                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n+                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n+                    MacroRulesScope::Binding(binding) => {\n+                        Scope::MacroRules(binding.parent_macro_rules_scope)\n+                    }\n+                    MacroRulesScope::Invocation(invoc_id) => {\n+                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n+                    }\n+                    MacroRulesScope::Empty => Scope::Module(module, None),\n+                },\n+                Scope::CrateRoot => match ns {\n+                    TypeNS => {\n+                        ctxt.adjust(ExpnId::root());\n+                        Scope::ExternPrelude\n+                    }\n+                    ValueNS | MacroNS => break,\n+                },\n+                Scope::Module(module, prev_lint_id) => {\n+                    use_prelude = !module.no_implicit_prelude;\n+                    let derive_fallback_lint_id = match scope_set {\n+                        ScopeSet::Late(.., lint_id) => lint_id,\n+                        _ => None,\n+                    };\n+                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n+                        Some((parent_module, lint_id)) => {\n+                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n+                        }\n+                        None => {\n+                            ctxt.adjust(ExpnId::root());\n+                            match ns {\n+                                TypeNS => Scope::ExternPrelude,\n+                                ValueNS => Scope::StdLibPrelude,\n+                                MacroNS => Scope::RegisteredAttrs,\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n+                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n+                Scope::BuiltinAttrs => break, // nowhere else to search\n+                Scope::ExternPrelude if is_absolute_path => break,\n+                Scope::ExternPrelude => Scope::ToolPrelude,\n+                Scope::ToolPrelude => Scope::StdLibPrelude,\n+                Scope::StdLibPrelude => match ns {\n+                    TypeNS => Scope::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => Scope::BuiltinAttrs,\n+                },\n+                Scope::BuiltinTypes => break, // nowhere else to search\n+            };\n+        }\n+\n+        None\n+    }\n+\n+    fn hygienic_lexical_parent(\n+        &mut self,\n+        module: Module<'a>,\n+        ctxt: &mut SyntaxContext,\n+        derive_fallback_lint_id: Option<NodeId>,\n+    ) -> Option<(Module<'a>, Option<NodeId>)> {\n+        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n+            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n+        }\n+\n+        if let ModuleKind::Block(..) = module.kind {\n+            return Some((module.parent.unwrap().nearest_item_scope(), None));\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if derive_fallback_lint_id.is_some() {\n+            if let Some(parent) = module.parent {\n+                // Inner module is inside the macro, parent module is outside of the macro.\n+                if module.expansion != parent.expansion\n+                    && module.expansion.is_descendant_of(parent.expansion)\n+                {\n+                    // The macro is a proc macro derive\n+                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n+                        let ext = self.get_macro_by_def_id(def_id);\n+                        if ext.builtin_name.is_none()\n+                            && ext.macro_kind() == MacroKind::Derive\n+                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n+                        {\n+                            return Some((parent, derive_fallback_lint_id));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n+    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n+    /// `ident` in the first scope that defines it (or None if no scopes define it).\n+    ///\n+    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n+    /// the items are defined in the block. For example,\n+    /// ```rust\n+    /// fn f() {\n+    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n+    ///    let g = || {};\n+    ///    fn g() {}\n+    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n+    /// }\n+    /// ```\n+    ///\n+    /// Invariant: This must only be called during main resolution, not during\n+    /// import resolution.\n+    crate fn resolve_ident_in_lexical_scope(\n+        &mut self,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: &[Rib<'a>],\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        let orig_ident = ident;\n+        if ident.name == kw::Empty {\n+            return Some(LexicalScopeBinding::Res(Res::Err));\n+        }\n+        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n+            // FIXME(jseyfried) improve `Self` hygiene\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n+            (empty_span, empty_span)\n+        } else if ns == TypeNS {\n+            let normalized_span = ident.span.normalize_to_macros_2_0();\n+            (normalized_span, normalized_span)\n+        } else {\n+            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n+        };\n+        ident.span = general_span;\n+        let normalized_ident = Ident { span: normalized_span, ..ident };\n+\n+        // Walk backwards up the ribs in scope.\n+        let finalize = finalize_full.path_span();\n+        let mut module = self.graph_root;\n+        for i in (0..ribs.len()).rev() {\n+            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n+            // Use the rib kind to determine whether we are resolving parameters\n+            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n+            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n+            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n+            {\n+                // The ident resolves to a type parameter or local variable.\n+                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n+                    i,\n+                    rib_ident,\n+                    *res,\n+                    finalize,\n+                    *original_rib_ident_def,\n+                    ribs,\n+                )));\n+            }\n+\n+            module = match ribs[i].kind {\n+                ModuleRibKind(module) => module,\n+                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    ident.span.remove_mark();\n+                    continue;\n+                }\n+                _ => continue,\n+            };\n+\n+            match module.kind {\n+                ModuleKind::Block(..) => {} // We can see through blocks\n+                _ => break,\n+            }\n+\n+            let item = self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                parent_scope,\n+                finalize,\n+            );\n+            if let Ok(binding) = item {\n+                // The ident resolves to an item.\n+                return Some(LexicalScopeBinding::Item(binding));\n+            }\n+        }\n+        self.early_resolve_ident_in_lexical_scope(\n+            orig_ident,\n+            ScopeSet::Late(ns, module, finalize_full.node_id()),\n+            parent_scope,\n+            finalize,\n+            finalize.is_some(),\n+        )\n+        .ok()\n+        .map(LexicalScopeBinding::Item)\n+    }\n+\n+    /// Resolve an identifier in lexical scope.\n+    /// This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n+    /// expansion and import resolution (perhaps they can be merged in the future).\n+    /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n+    /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n+    crate fn early_resolve_ident_in_lexical_scope(\n+        &mut self,\n+        orig_ident: Ident,\n+        scope_set: ScopeSet<'a>,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        force: bool,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        bitflags::bitflags! {\n+            struct Flags: u8 {\n+                const MACRO_RULES          = 1 << 0;\n+                const MODULE               = 1 << 1;\n+                const MISC_SUGGEST_CRATE   = 1 << 2;\n+                const MISC_SUGGEST_SELF    = 1 << 3;\n+                const MISC_FROM_PRELUDE    = 1 << 4;\n+            }\n+        }\n+\n+        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n+\n+        // Make sure `self`, `super` etc produce an error when passed to here.\n+        if orig_ident.is_path_segment_keyword() {\n+            return Err(Determinacy::Determined);\n+        }\n+\n+        let (ns, macro_kind, is_import) = match scope_set {\n+            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+\n+        // This is *the* result, resolution from the scope closest to the resolved identifier.\n+        // However, sometimes this result is \"weak\" because it comes from a glob import or\n+        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n+        // mod m { ... } // solution in outer scope\n+        // {\n+        //     use prefix::*; // imports another `m` - innermost solution\n+        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n+        //     m::mac!();\n+        // }\n+        // So we have to save the innermost solution and continue searching in outer scopes\n+        // to detect potential ambiguities.\n+        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n+        let mut determinacy = Determinacy::Determined;\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let break_result = self.visit_scopes(\n+            scope_set,\n+            parent_scope,\n+            orig_ident.span.ctxt(),\n+            |this, scope, use_prelude, ctxt| {\n+                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n+                let ok = |res, span, arenas| {\n+                    Ok((\n+                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n+                            .to_name_binding(arenas),\n+                        Flags::empty(),\n+                    ))\n+                };\n+                let result = match scope {\n+                    Scope::DeriveHelpers(expn_id) => {\n+                        if let Some(attr) = this\n+                            .helper_attrs\n+                            .get(&expn_id)\n+                            .and_then(|attrs| attrs.iter().rfind(|i| ident == **i))\n+                        {\n+                            let binding = (\n+                                Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                ty::Visibility::Public,\n+                                attr.span,\n+                                expn_id,\n+                            )\n+                                .to_name_binding(this.arenas);\n+                            Ok((binding, Flags::empty()))\n+                        } else {\n+                            Err(Determinacy::Determined)\n+                        }\n+                    }\n+                    Scope::DeriveHelpersCompat => {\n+                        let mut result = Err(Determinacy::Determined);\n+                        for derive in parent_scope.derives {\n+                            let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n+                            match this.resolve_macro_path(\n+                                derive,\n+                                Some(MacroKind::Derive),\n+                                parent_scope,\n+                                true,\n+                                force,\n+                            ) {\n+                                Ok((Some(ext), _)) => {\n+                                    if ext.helper_attrs.contains(&ident.name) {\n+                                        result = ok(\n+                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n+                                            derive.span,\n+                                            this.arenas,\n+                                        );\n+                                        break;\n+                                    }\n+                                }\n+                                Ok(_) | Err(Determinacy::Determined) => {}\n+                                Err(Determinacy::Undetermined) => {\n+                                    result = Err(Determinacy::Undetermined)\n+                                }\n+                            }\n+                        }\n+                        result\n+                    }\n+                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n+                        MacroRulesScope::Binding(macro_rules_binding)\n+                            if ident == macro_rules_binding.ident =>\n+                        {\n+                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n+                        }\n+                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n+                        _ => Err(Determinacy::Determined),\n+                    },\n+                    Scope::CrateRoot => {\n+                        let root_ident = Ident::new(kw::PathRoot, ident.span);\n+                        let root_module = this.resolve_crate_root(root_ident);\n+                        let binding = this.resolve_ident_in_module_ext(\n+                            ModuleOrUniformRoot::Module(root_module),\n+                            ident,\n+                            ns,\n+                            parent_scope,\n+                            finalize,\n+                        );\n+                        match binding {\n+                            Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n+                            Err((Determinacy::Undetermined, Weak::No)) => {\n+                                return Some(Err(Determinacy::determined(force)));\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n+                                Err(Determinacy::Undetermined)\n+                            }\n+                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                        }\n+                    }\n+                    Scope::Module(module, derive_fallback_lint_id) => {\n+                        let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n+                        let binding = this.resolve_ident_in_module_unadjusted_ext(\n+                            ModuleOrUniformRoot::Module(module),\n+                            ident,\n+                            ns,\n+                            adjusted_parent_scope,\n+                            !matches!(scope_set, ScopeSet::Late(..)),\n+                            finalize,\n+                        );\n+                        match binding {\n+                            Ok(binding) => {\n+                                if let Some(lint_id) = derive_fallback_lint_id {\n+                                    this.lint_buffer.buffer_lint_with_diagnostic(\n+                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                                        lint_id,\n+                                        orig_ident.span,\n+                                        &format!(\n+                                            \"cannot find {} `{}` in this scope\",\n+                                            ns.descr(),\n+                                            ident\n+                                        ),\n+                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n+                                            orig_ident.span,\n+                                        ),\n+                                    );\n+                                }\n+                                let misc_flags = if ptr::eq(module, this.graph_root) {\n+                                    Flags::MISC_SUGGEST_CRATE\n+                                } else if module.is_normal() {\n+                                    Flags::MISC_SUGGEST_SELF\n+                                } else {\n+                                    Flags::empty()\n+                                };\n+                                Ok((binding, Flags::MODULE | misc_flags))\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::No)) => {\n+                                return Some(Err(Determinacy::determined(force)));\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n+                                Err(Determinacy::Undetermined)\n+                            }\n+                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                        }\n+                    }\n+                    Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n+                        Some(ident) => ok(\n+                            Res::NonMacroAttr(NonMacroAttrKind::Registered),\n+                            ident.span,\n+                            this.arenas,\n+                        ),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                    Scope::MacroUsePrelude => {\n+                        match this.macro_use_prelude.get(&ident.name).cloned() {\n+                            Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n+                    Scope::BuiltinAttrs => {\n+                        if is_builtin_attr_name(ident.name) {\n+                            ok(\n+                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n+                                DUMMY_SP,\n+                                this.arenas,\n+                            )\n+                        } else {\n+                            Err(Determinacy::Determined)\n+                        }\n+                    }\n+                    Scope::ExternPrelude => {\n+                        match this.extern_prelude_get(ident, finalize.is_some()) {\n+                            Some(binding) => Ok((binding, Flags::empty())),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n+                    Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n+                        Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                    Scope::StdLibPrelude => {\n+                        let mut result = Err(Determinacy::Determined);\n+                        if let Some(prelude) = this.prelude {\n+                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n+                                ModuleOrUniformRoot::Module(prelude),\n+                                ident,\n+                                ns,\n+                                parent_scope,\n+                                None,\n+                            ) {\n+                                if use_prelude || this.is_builtin_macro(binding.res()) {\n+                                    result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n+                                }\n+                            }\n+                        }\n+                        result\n+                    }\n+                    Scope::BuiltinTypes => match PrimTy::from_name(ident.name) {\n+                        Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                };\n+\n+                match result {\n+                    Ok((binding, flags))\n+                        if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n+                    {\n+                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n+                            return Some(Ok(binding));\n+                        }\n+\n+                        if let Some((innermost_binding, innermost_flags)) = innermost_result {\n+                            // Found another solution, if the first one was \"weak\", report an error.\n+                            let (res, innermost_res) = (binding.res(), innermost_binding.res());\n+                            if res != innermost_res {\n+                                let is_builtin = |res| {\n+                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n+                                };\n+                                let derive_helper =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                                let derive_helper_compat =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n+\n+                                let ambiguity_error_kind = if is_import {\n+                                    Some(AmbiguityKind::Import)\n+                                } else if is_builtin(innermost_res) || is_builtin(res) {\n+                                    Some(AmbiguityKind::BuiltinAttr)\n+                                } else if innermost_res == derive_helper_compat\n+                                    || res == derive_helper_compat && innermost_res != derive_helper\n+                                {\n+                                    Some(AmbiguityKind::DeriveHelper)\n+                                } else if innermost_flags.contains(Flags::MACRO_RULES)\n+                                    && flags.contains(Flags::MODULE)\n+                                    && !this.disambiguate_macro_rules_vs_modularized(\n+                                        innermost_binding,\n+                                        binding,\n+                                    )\n+                                    || flags.contains(Flags::MACRO_RULES)\n+                                        && innermost_flags.contains(Flags::MODULE)\n+                                        && !this.disambiguate_macro_rules_vs_modularized(\n+                                            binding,\n+                                            innermost_binding,\n+                                        )\n+                                {\n+                                    Some(AmbiguityKind::MacroRulesVsModularized)\n+                                } else if innermost_binding.is_glob_import() {\n+                                    Some(AmbiguityKind::GlobVsOuter)\n+                                } else if innermost_binding\n+                                    .may_appear_after(parent_scope.expansion, binding)\n+                                {\n+                                    Some(AmbiguityKind::MoreExpandedVsOuter)\n+                                } else {\n+                                    None\n+                                };\n+                                if let Some(kind) = ambiguity_error_kind {\n+                                    let misc = |f: Flags| {\n+                                        if f.contains(Flags::MISC_SUGGEST_CRATE) {\n+                                            AmbiguityErrorMisc::SuggestCrate\n+                                        } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n+                                            AmbiguityErrorMisc::SuggestSelf\n+                                        } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n+                                            AmbiguityErrorMisc::FromPrelude\n+                                        } else {\n+                                            AmbiguityErrorMisc::None\n+                                        }\n+                                    };\n+                                    this.ambiguity_errors.push(AmbiguityError {\n+                                        kind,\n+                                        ident: orig_ident,\n+                                        b1: innermost_binding,\n+                                        b2: binding,\n+                                        misc1: misc(innermost_flags),\n+                                        misc2: misc(flags),\n+                                    });\n+                                    return Some(Ok(innermost_binding));\n+                                }\n+                            }\n+                        } else {\n+                            // Found the first solution.\n+                            innermost_result = Some((binding, flags));\n+                        }\n+                    }\n+                    Ok(..) | Err(Determinacy::Determined) => {}\n+                    Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n+                }\n+\n+                None\n+            },\n+        );\n+\n+        if let Some(break_result) = break_result {\n+            return break_result;\n+        }\n+\n+        // The first found solution was the only one, return it.\n+        if let Some((binding, _)) = innermost_result {\n+            return Ok(binding);\n+        }\n+\n+        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n+    }\n+\n+    crate fn resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n+            .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    fn resolve_ident_in_module_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n+        let tmp_parent_scope;\n+        let mut adjusted_parent_scope = parent_scope;\n+        match module {\n+            ModuleOrUniformRoot::Module(m) => {\n+                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n+            }\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n+                // No adjustments\n+            }\n+        }\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module,\n+            ident,\n+            ns,\n+            adjusted_parent_scope,\n+            false,\n+            finalize,\n+        )\n+    }\n+\n+    fn resolve_ident_in_module_unadjusted(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module,\n+            ident,\n+            ns,\n+            parent_scope,\n+            false,\n+            finalize,\n+        )\n+        .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n+    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n+    fn resolve_ident_in_module_unadjusted_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        restricted_shadowing: bool,\n+        finalize: Option<Span>,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n+        let module = match module {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident,\n+                    ScopeSet::AbsolutePath(ns),\n+                    parent_scope,\n+                    finalize,\n+                    finalize.is_some(),\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                return if ns != TypeNS {\n+                    Err((Determined, Weak::No))\n+                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n+                    Ok(binding)\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n+                    // Macro-expanded `extern crate` items can add names to extern prelude.\n+                    Err((Undetermined, Weak::No))\n+                } else {\n+                    Err((Determined, Weak::No))\n+                };\n+            }\n+            ModuleOrUniformRoot::CurrentScope => {\n+                assert!(!restricted_shadowing);\n+                if ns == TypeNS {\n+                    if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n+                        let module = self.resolve_crate_root(ident);\n+                        let binding =\n+                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n+                                .to_name_binding(self.arenas);\n+                        return Ok(binding);\n+                    } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n+                        // FIXME: Implement these with renaming requirements so that e.g.\n+                        // `use super;` doesn't work, but `use super as name;` does.\n+                        // Fall through here to get an error from `early_resolve_...`.\n+                    }\n+                }\n+\n+                let scopes = ScopeSet::All(ns, true);\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident,\n+                    scopes,\n+                    parent_scope,\n+                    finalize,\n+                    finalize.is_some(),\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+        };\n+\n+        let key = self.new_key(ident, ns);\n+        let resolution =\n+            self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n+\n+        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n+            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n+                if let NameBindingKind::Res(_, true) = binding.kind {\n+                    self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n+                }\n+            }\n+        }\n+\n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            if let Some(unusable_binding) = this.unusable_binding {\n+                if ptr::eq(binding, unusable_binding) {\n+                    return Err((Determined, Weak::No));\n+                }\n+            }\n+            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n+            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n+        };\n+\n+        if let Some(path_span) = finalize {\n+            return resolution\n+                .binding\n+                .and_then(|binding| {\n+                    // If the primary binding is unusable, search further and return the shadowed glob\n+                    // binding if it exists. What we really want here is having two separate scopes in\n+                    // a module - one for non-globs and one for globs, but until that's done use this\n+                    // hack to avoid inconsistent resolution ICEs during import validation.\n+                    if let Some(unusable_binding) = self.unusable_binding {\n+                        if ptr::eq(binding, unusable_binding) {\n+                            return resolution.shadowed_glob;\n+                        }\n+                    }\n+                    Some(binding)\n+                })\n+                .ok_or((Determined, Weak::No))\n+                .and_then(|binding| {\n+                    if self.last_import_segment && check_usable(self, binding).is_err() {\n+                        Err((Determined, Weak::No))\n+                    } else {\n+                        self.record_use(ident, binding, restricted_shadowing);\n+\n+                        if let Some(shadowed_glob) = resolution.shadowed_glob {\n+                            // Forbid expanded shadowing to avoid time travel.\n+                            if restricted_shadowing\n+                                && binding.expansion != LocalExpnId::ROOT\n+                                && binding.res() != shadowed_glob.res()\n+                            {\n+                                self.ambiguity_errors.push(AmbiguityError {\n+                                    kind: AmbiguityKind::GlobVsExpanded,\n+                                    ident,\n+                                    b1: binding,\n+                                    b2: shadowed_glob,\n+                                    misc1: AmbiguityErrorMisc::None,\n+                                    misc2: AmbiguityErrorMisc::None,\n+                                });\n+                            }\n+                        }\n+\n+                        if !self.is_accessible_from(binding.vis, parent_scope.module) {\n+                            self.privacy_errors.push(PrivacyError {\n+                                ident,\n+                                binding,\n+                                dedup_span: path_span,\n+                            });\n+                        }\n+\n+                        Ok(binding)\n+                    }\n+                });\n+        }\n+\n+        // Items and single imports are not shadowable, if we have one, then it's determined.\n+        if let Some(binding) = resolution.binding {\n+            if !binding.is_glob_import() {\n+                return check_usable(self, binding);\n+            }\n+        }\n+\n+        // --- From now on we either have a glob resolution or no resolution. ---\n+\n+        // Check if one of single imports can still define the name,\n+        // if it can then our result is not determined and can be invalidated.\n+        for single_import in &resolution.single_imports {\n+            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n+                continue;\n+            }\n+            let Some(module) = single_import.imported_module.get() else {\n+                return Err((Undetermined, Weak::No));\n+            };\n+            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n+                unreachable!();\n+            };\n+            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n+            {\n+                Err(Determined) => continue,\n+                Ok(binding)\n+                    if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n+                {\n+                    continue;\n+                }\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n+            }\n+        }\n+\n+        // So we have a resolution that's from a glob import. This resolution is determined\n+        // if it cannot be shadowed by some new item/import expanded from a macro.\n+        // This happens either if there are no unexpanded macros, or expanded names cannot\n+        // shadow globs (that happens in macro namespace or with restricted shadowing).\n+        //\n+        // Additionally, any macro in any module can plant names in the root module if it creates\n+        // `macro_export` macros, so the root module effectively has unresolved invocations if any\n+        // module has unresolved invocations.\n+        // However, it causes resolution/expansion to stuck too often (#53144), so, to make\n+        // progress, we have to ignore those potential unresolved invocations from other modules\n+        // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n+        // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n+        if let Some(binding) = resolution.binding {\n+            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n+                return check_usable(self, binding);\n+            } else {\n+                return Err((Undetermined, Weak::No));\n+            }\n+        }\n+\n+        // --- From now on we have no resolution. ---\n+\n+        // Now we are in situation when new item/import can appear only from a glob or a macro\n+        // expansion. With restricted shadowing names from globs and macro expansions cannot\n+        // shadow names from outer scopes, so we can freely fallback from module search to search\n+        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n+        // scopes we return `Undetermined` with `Weak::Yes`.\n+\n+        // Check if one of unexpanded macros can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        if unexpanded_macros {\n+            return Err((Undetermined, Weak::Yes));\n+        }\n+\n+        // Check if one of glob imports can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        for glob_import in module.globs.borrow().iter() {\n+            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n+                continue;\n+            }\n+            let module = match glob_import.imported_module.get() {\n+                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                Some(_) => continue,\n+                None => return Err((Undetermined, Weak::Yes)),\n+            };\n+            let tmp_parent_scope;\n+            let (mut adjusted_parent_scope, mut ident) =\n+                (parent_scope, ident.normalize_to_macros_2_0());\n+            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n+                Some(Some(def)) => {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n+                Some(None) => {}\n+                None => continue,\n+            };\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                adjusted_parent_scope,\n+                None,\n+            );\n+\n+            match result {\n+                Err(Determined) => continue,\n+                Ok(binding)\n+                    if !self.is_accessible_from(binding.vis, glob_import.parent_scope.module) =>\n+                {\n+                    continue;\n+                }\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n+            }\n+        }\n+\n+        // No resolution and no one else can define the name - determinate error.\n+        Err((Determined, Weak::No))\n+    }\n+\n+    /// Validate a local resolution (from ribs).\n+    fn validate_res_from_ribs(\n+        &mut self,\n+        rib_index: usize,\n+        rib_ident: Ident,\n+        mut res: Res,\n+        finalize: Option<Span>,\n+        original_rib_ident_def: Ident,\n+        all_ribs: &[Rib<'a>],\n+    ) -> Res {\n+        const CG_BUG_STR: &str = \"min_const_generics resolve check didn't stop compilation\";\n+        debug!(\"validate_res_from_ribs({:?})\", res);\n+        let ribs = &all_ribs[rib_index + 1..];\n+\n+        // An invalid forward use of a generic parameter from a previous default.\n+        if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n+            if let Some(span) = finalize {\n+                let res_error = if rib_ident.name == kw::SelfUpper {\n+                    ResolutionError::SelfInGenericParamDefault\n+                } else {\n+                    ResolutionError::ForwardDeclaredGenericParam\n+                };\n+                self.report_error(span, res_error);\n+            }\n+            assert_eq!(res, Res::Err);\n+            return Res::Err;\n+        }\n+\n+        match res {\n+            Res::Local(_) => {\n+                use ResolutionError::*;\n+                let mut res_err = None;\n+\n+                for rib in ribs {\n+                    match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n+                            if let Some(span) = finalize {\n+                                // We don't immediately trigger a resolve error, because\n+                                // we want certain other resolution errors (namely those\n+                                // emitted for `ConstantItemRibKind` below) to take\n+                                // precedence.\n+                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n+                            }\n+                        }\n+                        ConstantItemRibKind(_, item) => {\n+                            // Still doesn't deal with upvars\n+                            if let Some(span) = finalize {\n+                                let (span, resolution_error) =\n+                                    if let Some((ident, constant_item_kind)) = item {\n+                                        let kind_str = match constant_item_kind {\n+                                            ConstantItemKind::Const => \"const\",\n+                                            ConstantItemKind::Static => \"static\",\n+                                        };\n+                                        (\n+                                            span,\n+                                            AttemptToUseNonConstantValueInConstant(\n+                                                ident, \"let\", kind_str,\n+                                            ),\n+                                        )\n+                                    } else {\n+                                        (\n+                                            rib_ident.span,\n+                                            AttemptToUseNonConstantValueInConstant(\n+                                                original_rib_ident_def,\n+                                                \"const\",\n+                                                \"let\",\n+                                            ),\n+                                        )\n+                                    };\n+                                self.report_error(span, resolution_error);\n+                            }\n+                            return Res::Err;\n+                        }\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n+                            }\n+                            return Res::Err;\n+                        }\n+                    }\n+                }\n+                if let Some((span, res_err)) = res_err {\n+                    self.report_error(span, res_err);\n+                    return Res::Err;\n+                }\n+            }\n+            Res::Def(DefKind::TyParam, _) | Res::SelfTy { .. } => {\n+                for rib in ribs {\n+                    let has_generic_params: HasGenericParams = match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | AssocItemRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => {\n+                            // Nothing to do. Continue.\n+                            continue;\n+                        }\n+\n+                        ConstantItemRibKind(trivial, _) => {\n+                            let features = self.session.features_untracked();\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !(trivial || features.generic_const_exprs) {\n+                                // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n+                                // we can't easily tell if it's generic at this stage, so we instead remember\n+                                // this and then enforce the self type to be concrete later on.\n+                                if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n+                                    res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n+                                } else {\n+                                    if let Some(span) = finalize {\n+                                        self.report_error(\n+                                            span,\n+                                            ResolutionError::ParamInNonTrivialAnonConst {\n+                                                name: rib_ident.name,\n+                                                is_type: true,\n+                                            },\n+                                        );\n+                                        self.session.delay_span_bug(span, CG_BUG_STR);\n+                                    }\n+\n+                                    return Res::Err;\n+                                }\n+                            }\n+\n+                            continue;\n+                        }\n+\n+                        // This was an attempt to use a type parameter outside its scope.\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(\n+                                    span,\n+                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                );\n+                            }\n+                            return Res::Err;\n+                        }\n+                    };\n+\n+                    if let Some(span) = finalize {\n+                        self.report_error(\n+                            span,\n+                            ResolutionError::GenericParamsFromOuterFunction(\n+                                res,\n+                                has_generic_params,\n+                            ),\n+                        );\n+                    }\n+                    return Res::Err;\n+                }\n+            }\n+            Res::Def(DefKind::ConstParam, _) => {\n+                let mut ribs = ribs.iter().peekable();\n+                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n+                    // When declaring const parameters inside function signatures, the first rib\n+                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n+                    // (spuriously) conflicting with the const param.\n+                    ribs.next();\n+                }\n+\n+                for rib in ribs {\n+                    let has_generic_params = match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | AssocItemRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => continue,\n+\n+                        ConstantItemRibKind(trivial, _) => {\n+                            let features = self.session.features_untracked();\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !(trivial || features.generic_const_exprs) {\n+                                if let Some(span) = finalize {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst {\n+                                            name: rib_ident.name,\n+                                            is_type: false,\n+                                        },\n+                                    );\n+                                    self.session.delay_span_bug(span, CG_BUG_STR);\n+                                }\n+\n+                                return Res::Err;\n+                            }\n+\n+                            continue;\n+                        }\n+\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(\n+                                    span,\n+                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                );\n+                            }\n+                            return Res::Err;\n+                        }\n+                    };\n+\n+                    // This was an attempt to use a const parameter outside its scope.\n+                    if let Some(span) = finalize {\n+                        self.report_error(\n+                            span,\n+                            ResolutionError::GenericParamsFromOuterFunction(\n+                                res,\n+                                has_generic_params,\n+                            ),\n+                        );\n+                    }\n+                    return Res::Err;\n+                }\n+            }\n+            _ => {}\n+        }\n+        res\n+    }\n+\n+    crate fn resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Finalize,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n+    }\n+\n+    crate fn resolve_path_with_ribs(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+    ) -> PathResult<'a> {\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n+\n+        let finalize = finalize_full.path_span();\n+        let mut module = None;\n+        let mut allow_super = true;\n+        let mut second_binding = None;\n+\n+        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n+            let record_segment_res = |this: &mut Self, res| {\n+                if finalize.is_some() {\n+                    if let Some(id) = id {\n+                        if !this.partial_res_map.contains_key(&id) {\n+                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                            this.record_partial_res(id, PartialRes::new(res));\n+                        }\n+                    }\n+                }\n+            };\n+\n+            let is_last = i == path.len() - 1;\n+            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+            let name = ident.name;\n+\n+            allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);\n+\n+            if ns == TypeNS {\n+                if allow_super && name == kw::Super {\n+                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n+                    let self_module = match i {\n+                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n+                        _ => match module {\n+                            Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n+                            _ => None,\n+                        },\n+                    };\n+                    if let Some(self_module) = self_module {\n+                        if let Some(parent) = self_module.parent {\n+                            module = Some(ModuleOrUniformRoot::Module(\n+                                self.resolve_self(&mut ctxt, parent),\n+                            ));\n+                            continue;\n+                        }\n+                    }\n+                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                        (\"there are too many leading `super` keywords\".to_string(), None)\n+                    });\n+                }\n+                if i == 0 {\n+                    if name == kw::SelfLower {\n+                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n+                        module = Some(ModuleOrUniformRoot::Module(\n+                            self.resolve_self(&mut ctxt, parent_scope.module),\n+                        ));\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot && ident.span.rust_2018() {\n+                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n+                        // `::a::b` from 2015 macro on 2018 global edition\n+                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {\n+                        // `::a::b`, `crate::a::b` or `$crate::a::b`\n+                        module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Report special messages for path segment keywords in wrong positions.\n+            if ident.is_path_segment_keyword() && i != 0 {\n+                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                    let name_str = if name == kw::PathRoot {\n+                        \"crate root\".to_string()\n+                    } else {\n+                        format!(\"`{}`\", name)\n+                    };\n+                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n+                        format!(\"global paths cannot start with {}\", name_str)\n+                    } else {\n+                        format!(\"{} in paths can only be used in start position\", name_str)\n+                    };\n+                    (label, None)\n+                });\n+            }\n+\n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                PathResult(PathResult<'a>),\n+            }\n+            let find_binding_in_ns = |this: &mut Self, ns| {\n+                let binding = if let Some(module) = module {\n+                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n+                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n+                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n+                    this.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        finalize,\n+                        finalize.is_some(),\n+                    )\n+                } else {\n+                    match this.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        finalize_full,\n+                        &ribs.unwrap()[ns],\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res))\n+                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n+                        {\n+                            record_segment_res(this, res);\n+                            return FindBindingResult::PathResult(PathResult::NonModule(\n+                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n+                            ));\n+                        }\n+                        _ => Err(Determinacy::determined(finalize.is_some())),\n+                    }\n+                };\n+                FindBindingResult::Binding(binding)\n+            };\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::PathResult(x) => return x,\n+                FindBindingResult::Binding(binding) => binding,\n+            };\n+            match binding {\n+                Ok(binding) => {\n+                    if i == 1 {\n+                        second_binding = Some(binding);\n+                    }\n+                    let res = binding.res();\n+                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n+                    if let Some(next_module) = binding.module() {\n+                        module = Some(ModuleOrUniformRoot::Module(next_module));\n+                        record_segment_res(self, res);\n+                    } else if res == Res::ToolMod && i + 1 != path.len() {\n+                        if binding.is_import() {\n+                            self.session\n+                                .struct_span_err(\n+                                    ident.span,\n+                                    \"cannot use a tool module through an import\",\n+                                )\n+                                .span_note(binding.span, \"the tool module imported here\")\n+                                .emit();\n+                        }\n+                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                        return PathResult::NonModule(PartialRes::new(res));\n+                    } else if res == Res::Err {\n+                        return PathResult::NonModule(PartialRes::new(Res::Err));\n+                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n+                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                            res,\n+                            path.len() - i - 1,\n+                        ));\n+                    } else {\n+                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                            let label = format!(\n+                                \"`{ident}` is {} {}, not a module\",\n+                                res.article(),\n+                                res.descr()\n+                            );\n+                            (label, None)\n+                        });\n+                    }\n+                }\n+                Err(Undetermined) => return PathResult::Indeterminate,\n+                Err(Determined) => {\n+                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n+                        if opt_ns.is_some() && !module.is_normal() {\n+                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                                module.res().unwrap(),\n+                                path.len() - i,\n+                            ));\n+                        }\n+                    }\n+\n+                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                        let module_res = match module {\n+                            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n+                            _ => None,\n+                        };\n+                        if module_res == self.graph_root.res() {\n+                            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n+                            let mut candidates =\n+                                self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n+                            candidates.sort_by_cached_key(|c| {\n+                                (c.path.segments.len(), pprust::path_to_string(&c.path))\n+                            });\n+                            if let Some(candidate) = candidates.get(0) {\n+                                (\n+                                    String::from(\"unresolved import\"),\n+                                    Some((\n+                                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n+                                        String::from(\"a similar path exists\"),\n+                                        Applicability::MaybeIncorrect,\n+                                    )),\n+                                )\n+                            } else if self.session.edition() == Edition::Edition2015 {\n+                                (format!(\"maybe a missing crate `{}`?\", ident), None)\n+                            } else {\n+                                (format!(\"could not find `{}` in the crate root\", ident), None)\n+                            }\n+                        } else if i == 0 {\n+                            if ident\n+                                .name\n+                                .as_str()\n+                                .chars()\n+                                .next()\n+                                .map_or(false, |c| c.is_ascii_uppercase())\n+                            {\n+                                // Check whether the name refers to an item in the value namespace.\n+                                let suggestion = if ribs.is_some() {\n+                                    let match_span = match self.resolve_ident_in_lexical_scope(\n+                                        ident,\n+                                        ValueNS,\n+                                        parent_scope,\n+                                        Finalize::No,\n+                                        &ribs.unwrap()[ValueNS],\n+                                    ) {\n+                                        // Name matches a local variable. For example:\n+                                        // ```\n+                                        // fn f() {\n+                                        //     let Foo: &str = \"\";\n+                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                        //                               // variable `Foo`.\n+                                        // }\n+                                        // ```\n+                                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                                            Some(*self.pat_span_map.get(&id).unwrap())\n+                                        }\n+\n+                                        // Name matches item from a local name binding\n+                                        // created by `use` declaration. For example:\n+                                        // ```\n+                                        // pub Foo: &str = \"\";\n+                                        //\n+                                        // mod submod {\n+                                        //     use super::Foo;\n+                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                        //                               // binding `Foo`.\n+                                        // }\n+                                        // ```\n+                                        Some(LexicalScopeBinding::Item(name_binding)) => {\n+                                            Some(name_binding.span)\n+                                        }\n+                                        _ => None,\n+                                    };\n+\n+                                    if let Some(span) = match_span {\n+                                        Some((\n+                                            vec![(span, String::from(\"\"))],\n+                                            format!(\n+                                                \"`{}` is defined here, but is not a type\",\n+                                                ident\n+                                            ),\n+                                            Applicability::MaybeIncorrect,\n+                                        ))\n+                                    } else {\n+                                        None\n+                                    }\n+                                } else {\n+                                    None\n+                                };\n+\n+                                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n+                            } else {\n+                                (\n+                                    format!(\"use of undeclared crate or module `{}`\", ident),\n+                                    if ident.name == sym::alloc {\n+                                        Some((\n+                                            vec![],\n+                                            String::from(\n+                                                \"add `extern crate alloc` to use the `alloc` crate\",\n+                                            ),\n+                                            Applicability::MaybeIncorrect,\n+                                        ))\n+                                    } else {\n+                                        self.find_similarly_named_module_or_crate(\n+                                            ident.name,\n+                                            &parent_scope.module,\n+                                        )\n+                                        .map(|sugg| {\n+                                            (\n+                                                vec![(ident.span, sugg.to_string())],\n+                                                String::from(\n+                                                    \"there is a crate or module with a similar name\",\n+                                                ),\n+                                                Applicability::MaybeIncorrect,\n+                                            )\n+                                        })\n+                                    },\n+                                )\n+                            }\n+                        } else {\n+                            let parent = path[i - 1].ident.name;\n+                            let parent = match parent {\n+                                // ::foo is mounted at the crate root for 2015, and is the extern\n+                                // prelude for 2018+\n+                                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                                    \"the list of imported crates\".to_owned()\n+                                }\n+                                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n+                                _ => {\n+                                    format!(\"`{}`\", parent)\n+                                }\n+                            };\n+\n+                            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n+                            if ns == TypeNS || ns == ValueNS {\n+                                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                                if let FindBindingResult::Binding(Ok(binding)) =\n+                                    find_binding_in_ns(self, ns_to_try)\n+                                {\n+                                    let mut found = |what| {\n+                                        msg = format!(\n+                                            \"expected {}, found {} `{}` in {}\",\n+                                            ns.descr(),\n+                                            what,\n+                                            ident,\n+                                            parent\n+                                        )\n+                                    };\n+                                    if binding.module().is_some() {\n+                                        found(\"module\")\n+                                    } else {\n+                                        match binding.res() {\n+                                            Res::Def(kind, id) => found(kind.descr(id)),\n+                                            _ => found(ns_to_try.descr()),\n+                                        }\n+                                    }\n+                                };\n+                            }\n+                            (msg, None)\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+\n+        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+\n+        PathResult::Module(match module {\n+            Some(module) => module,\n+            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n+            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n+        })\n+    }\n+}"}, {"sha": "3d199afb13d4179a8689e70ded3d2ab431846dc2", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 8, "deletions": 281, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "patch": "@@ -2,12 +2,11 @@\n \n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n-use crate::Namespace::{self, MacroNS, TypeNS};\n+use crate::Namespace::{MacroNS, TypeNS};\n use crate::{module_to_string, names_to_string};\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n-use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n-use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n+use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n+use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n+use crate::{NameBinding, NameBindingKind, PathResult};\n \n use rustc_ast::NodeId;\n use rustc_data_structures::fx::FxHashSet;\n@@ -125,15 +124,15 @@ impl<'a> Import<'a> {\n     }\n }\n \n-#[derive(Clone, Default, Debug)]\n /// Records information about the resolution of a name in a namespace of a module.\n-pub struct NameResolution<'a> {\n+#[derive(Clone, Default, Debug)]\n+crate struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n+    pub single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n-    shadowed_glob: Option<&'a NameBinding<'a>>,\n+    pub shadowed_glob: Option<&'a NameBinding<'a>>,\n }\n \n impl<'a> NameResolution<'a> {\n@@ -169,278 +168,6 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolve_ident_in_module_unadjusted(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_unadjusted_ext(\n-            module,\n-            ident,\n-            ns,\n-            parent_scope,\n-            false,\n-            finalize,\n-        )\n-        .map_err(|(determinacy, _)| determinacy)\n-    }\n-\n-    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n-    crate fn resolve_ident_in_module_unadjusted_ext(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        restricted_shadowing: bool,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let module = match module {\n-            ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n-                assert!(!restricted_shadowing);\n-                let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    ScopeSet::AbsolutePath(ns),\n-                    parent_scope,\n-                    finalize,\n-                    finalize.is_some(),\n-                );\n-                return binding.map_err(|determinacy| (determinacy, Weak::No));\n-            }\n-            ModuleOrUniformRoot::ExternPrelude => {\n-                assert!(!restricted_shadowing);\n-                return if ns != TypeNS {\n-                    Err((Determined, Weak::No))\n-                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n-                    Ok(binding)\n-                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n-                    // Macro-expanded `extern crate` items can add names to extern prelude.\n-                    Err((Undetermined, Weak::No))\n-                } else {\n-                    Err((Determined, Weak::No))\n-                };\n-            }\n-            ModuleOrUniformRoot::CurrentScope => {\n-                assert!(!restricted_shadowing);\n-                if ns == TypeNS {\n-                    if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n-                        let module = self.resolve_crate_root(ident);\n-                        let binding =\n-                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n-                                .to_name_binding(self.arenas);\n-                        return Ok(binding);\n-                    } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n-                        // FIXME: Implement these with renaming requirements so that e.g.\n-                        // `use super;` doesn't work, but `use super as name;` does.\n-                        // Fall through here to get an error from `early_resolve_...`.\n-                    }\n-                }\n-\n-                let scopes = ScopeSet::All(ns, true);\n-                let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    scopes,\n-                    parent_scope,\n-                    finalize,\n-                    finalize.is_some(),\n-                );\n-                return binding.map_err(|determinacy| (determinacy, Weak::No));\n-            }\n-        };\n-\n-        let key = self.new_key(ident, ns);\n-        let resolution =\n-            self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n-\n-        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n-            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n-                    self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n-                }\n-            }\n-        }\n-\n-        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            if let Some(unusable_binding) = this.unusable_binding {\n-                if ptr::eq(binding, unusable_binding) {\n-                    return Err((Determined, Weak::No));\n-                }\n-            }\n-            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n-            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n-        };\n-\n-        if let Some(path_span) = finalize {\n-            return resolution\n-                .binding\n-                .and_then(|binding| {\n-                    // If the primary binding is unusable, search further and return the shadowed glob\n-                    // binding if it exists. What we really want here is having two separate scopes in\n-                    // a module - one for non-globs and one for globs, but until that's done use this\n-                    // hack to avoid inconsistent resolution ICEs during import validation.\n-                    if let Some(unusable_binding) = self.unusable_binding {\n-                        if ptr::eq(binding, unusable_binding) {\n-                            return resolution.shadowed_glob;\n-                        }\n-                    }\n-                    Some(binding)\n-                })\n-                .ok_or((Determined, Weak::No))\n-                .and_then(|binding| {\n-                    if self.last_import_segment && check_usable(self, binding).is_err() {\n-                        Err((Determined, Weak::No))\n-                    } else {\n-                        self.record_use(ident, binding, restricted_shadowing);\n-\n-                        if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                            // Forbid expanded shadowing to avoid time travel.\n-                            if restricted_shadowing\n-                                && binding.expansion != LocalExpnId::ROOT\n-                                && binding.res() != shadowed_glob.res()\n-                            {\n-                                self.ambiguity_errors.push(AmbiguityError {\n-                                    kind: AmbiguityKind::GlobVsExpanded,\n-                                    ident,\n-                                    b1: binding,\n-                                    b2: shadowed_glob,\n-                                    misc1: AmbiguityErrorMisc::None,\n-                                    misc2: AmbiguityErrorMisc::None,\n-                                });\n-                            }\n-                        }\n-\n-                        if !self.is_accessible_from(binding.vis, parent_scope.module) {\n-                            self.privacy_errors.push(PrivacyError {\n-                                ident,\n-                                binding,\n-                                dedup_span: path_span,\n-                            });\n-                        }\n-\n-                        Ok(binding)\n-                    }\n-                });\n-        }\n-\n-        // Items and single imports are not shadowable, if we have one, then it's determined.\n-        if let Some(binding) = resolution.binding {\n-            if !binding.is_glob_import() {\n-                return check_usable(self, binding);\n-            }\n-        }\n-\n-        // --- From now on we either have a glob resolution or no resolution. ---\n-\n-        // Check if one of single imports can still define the name,\n-        // if it can then our result is not determined and can be invalidated.\n-        for single_import in &resolution.single_imports {\n-            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n-                continue;\n-            }\n-            let Some(module) = single_import.imported_module.get() else {\n-                return Err((Undetermined, Weak::No));\n-            };\n-            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n-                unreachable!();\n-            };\n-            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n-            {\n-                Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n-                {\n-                    continue;\n-                }\n-                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n-            }\n-        }\n-\n-        // So we have a resolution that's from a glob import. This resolution is determined\n-        // if it cannot be shadowed by some new item/import expanded from a macro.\n-        // This happens either if there are no unexpanded macros, or expanded names cannot\n-        // shadow globs (that happens in macro namespace or with restricted shadowing).\n-        //\n-        // Additionally, any macro in any module can plant names in the root module if it creates\n-        // `macro_export` macros, so the root module effectively has unresolved invocations if any\n-        // module has unresolved invocations.\n-        // However, it causes resolution/expansion to stuck too often (#53144), so, to make\n-        // progress, we have to ignore those potential unresolved invocations from other modules\n-        // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n-        // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n-        if let Some(binding) = resolution.binding {\n-            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n-                return check_usable(self, binding);\n-            } else {\n-                return Err((Undetermined, Weak::No));\n-            }\n-        }\n-\n-        // --- From now on we have no resolution. ---\n-\n-        // Now we are in situation when new item/import can appear only from a glob or a macro\n-        // expansion. With restricted shadowing names from globs and macro expansions cannot\n-        // shadow names from outer scopes, so we can freely fallback from module search to search\n-        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n-        // scopes we return `Undetermined` with `Weak::Yes`.\n-\n-        // Check if one of unexpanded macros can still define the name,\n-        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n-        if unexpanded_macros {\n-            return Err((Undetermined, Weak::Yes));\n-        }\n-\n-        // Check if one of glob imports can still define the name,\n-        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n-        for glob_import in module.globs.borrow().iter() {\n-            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n-                continue;\n-            }\n-            let module = match glob_import.imported_module.get() {\n-                Some(ModuleOrUniformRoot::Module(module)) => module,\n-                Some(_) => continue,\n-                None => return Err((Undetermined, Weak::Yes)),\n-            };\n-            let tmp_parent_scope;\n-            let (mut adjusted_parent_scope, mut ident) =\n-                (parent_scope, ident.normalize_to_macros_2_0());\n-            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n-                Some(Some(def)) => {\n-                    tmp_parent_scope =\n-                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n-                    adjusted_parent_scope = &tmp_parent_scope;\n-                }\n-                Some(None) => {}\n-                None => continue,\n-            };\n-            let result = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                adjusted_parent_scope,\n-                None,\n-            );\n-\n-            match result {\n-                Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, glob_import.parent_scope.module) =>\n-                {\n-                    continue;\n-                }\n-                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n-            }\n-        }\n-\n-        // No resolution and no one else can define the name - determinate error.\n-        Err((Determined, Weak::No))\n-    }\n-\n     // Given a binding and an import that resolves to it,\n     // return the corresponding binding defined by the import.\n     crate fn import("}, {"sha": "f4a650e8d2678e952c6d0ebf667e016e383362d9", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1000, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "patch": "@@ -26,8 +26,6 @@ extern crate tracing;\n \n pub use rustc_hir::def::{Namespace, PerNS};\n \n-use Determinacy::*;\n-\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n@@ -37,7 +35,6 @@ use rustc_ast::{Crate, CRATE_NODE_ID};\n use rustc_ast::{Expr, ExprKind, LitKind};\n use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n-use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n@@ -46,7 +43,7 @@ use rustc_errors::{\n };\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n@@ -55,16 +52,15 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n-use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n-use rustc_span::edition::Edition;\n-use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n+use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -78,7 +74,7 @@ use tracing::debug;\n use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n-use late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind::*};\n+use late::{HasGenericParams, PathSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n use crate::access_levels::AccessLevelsVisitor;\n@@ -90,6 +86,7 @@ mod build_reduced_graph;\n mod check_unused;\n mod def_collector;\n mod diagnostics;\n+mod ident;\n mod imports;\n mod late;\n mod macros;\n@@ -1731,387 +1728,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// A generic scope visitor.\n-    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n-    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n-    fn visit_scopes<T>(\n-        &mut self,\n-        scope_set: ScopeSet<'a>,\n-        parent_scope: &ParentScope<'a>,\n-        ctxt: SyntaxContext,\n-        mut visitor: impl FnMut(\n-            &mut Self,\n-            Scope<'a>,\n-            /*use_prelude*/ bool,\n-            SyntaxContext,\n-        ) -> Option<T>,\n-    ) -> Option<T> {\n-        // General principles:\n-        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n-        //    built into the language or standard library. This way we can add new names into the\n-        //    language or standard library without breaking user code.\n-        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n-        // Places to search (in order of decreasing priority):\n-        // (Type NS)\n-        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n-        // 4. Tool modules (closed, controlled right now, but not in the future).\n-        // 5. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude (closed, controlled).\n-        // (Value NS)\n-        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Standard library prelude (de-facto closed, controlled).\n-        // (Macro NS)\n-        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and probably even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n-        //    priority than prelude macros, but create ambiguities with macros in modules.\n-        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled). Have higher priority than prelude macros, but create\n-        //    ambiguities with `macro_rules`.\n-        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 4a. User-defined prelude from macro-use\n-        //    (open, the open part is from macro expansions, not controlled).\n-        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n-        // 4c. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude: builtin attributes (closed, controlled).\n-\n-        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n-        let (ns, macro_kind, is_absolute_path) = match scope_set {\n-            ScopeSet::All(ns, _) => (ns, None, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Late(ns, ..) => (ns, None, false),\n-        };\n-        let module = match scope_set {\n-            // Start with the specified module.\n-            ScopeSet::Late(_, module, _) => module,\n-            // Jump out of trait or enum modules, they do not act as scopes.\n-            _ => parent_scope.module.nearest_item_scope(),\n-        };\n-        let mut scope = match ns {\n-            _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module, None),\n-            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n-        };\n-        let mut ctxt = ctxt.normalize_to_macros_2_0();\n-        let mut use_prelude = !module.no_implicit_prelude;\n-\n-        loop {\n-            let visit = match scope {\n-                // Derive helpers are not in scope when resolving derives in the same container.\n-                Scope::DeriveHelpers(expn_id) => {\n-                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n-                }\n-                Scope::DeriveHelpersCompat => true,\n-                Scope::MacroRules(macro_rules_scope) => {\n-                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n-                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n-                    // As another consequence of this optimization visitors never observe invocation\n-                    // scopes for macros that were already expanded.\n-                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n-                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n-                            macro_rules_scope.set(next_scope.get());\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-                    true\n-                }\n-                Scope::CrateRoot => true,\n-                Scope::Module(..) => true,\n-                Scope::RegisteredAttrs => use_prelude,\n-                Scope::MacroUsePrelude => use_prelude || rust_2015,\n-                Scope::BuiltinAttrs => true,\n-                Scope::ExternPrelude => use_prelude || is_absolute_path,\n-                Scope::ToolPrelude => use_prelude,\n-                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n-                Scope::BuiltinTypes => true,\n-            };\n-\n-            if visit {\n-                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n-                    return break_result;\n-                }\n-            }\n-\n-            scope = match scope {\n-                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n-                Scope::DeriveHelpers(expn_id) => {\n-                    // Derive helpers are not visible to code generated by bang or derive macros.\n-                    let expn_data = expn_id.expn_data();\n-                    match expn_data.kind {\n-                        ExpnKind::Root\n-                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n-                            Scope::DeriveHelpersCompat\n-                        }\n-                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n-                    }\n-                }\n-                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n-                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n-                    MacroRulesScope::Binding(binding) => {\n-                        Scope::MacroRules(binding.parent_macro_rules_scope)\n-                    }\n-                    MacroRulesScope::Invocation(invoc_id) => {\n-                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n-                    }\n-                    MacroRulesScope::Empty => Scope::Module(module, None),\n-                },\n-                Scope::CrateRoot => match ns {\n-                    TypeNS => {\n-                        ctxt.adjust(ExpnId::root());\n-                        Scope::ExternPrelude\n-                    }\n-                    ValueNS | MacroNS => break,\n-                },\n-                Scope::Module(module, prev_lint_id) => {\n-                    use_prelude = !module.no_implicit_prelude;\n-                    let derive_fallback_lint_id = match scope_set {\n-                        ScopeSet::Late(.., lint_id) => lint_id,\n-                        _ => None,\n-                    };\n-                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n-                        Some((parent_module, lint_id)) => {\n-                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n-                        }\n-                        None => {\n-                            ctxt.adjust(ExpnId::root());\n-                            match ns {\n-                                TypeNS => Scope::ExternPrelude,\n-                                ValueNS => Scope::StdLibPrelude,\n-                                MacroNS => Scope::RegisteredAttrs,\n-                            }\n-                        }\n-                    }\n-                }\n-                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n-                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n-                Scope::BuiltinAttrs => break, // nowhere else to search\n-                Scope::ExternPrelude if is_absolute_path => break,\n-                Scope::ExternPrelude => Scope::ToolPrelude,\n-                Scope::ToolPrelude => Scope::StdLibPrelude,\n-                Scope::StdLibPrelude => match ns {\n-                    TypeNS => Scope::BuiltinTypes,\n-                    ValueNS => break, // nowhere else to search\n-                    MacroNS => Scope::BuiltinAttrs,\n-                },\n-                Scope::BuiltinTypes => break, // nowhere else to search\n-            };\n-        }\n-\n-        None\n-    }\n-\n-    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n-    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n-    /// `ident` in the first scope that defines it (or None if no scopes define it).\n-    ///\n-    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n-    /// the items are defined in the block. For example,\n-    /// ```rust\n-    /// fn f() {\n-    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n-    ///    let g = || {};\n-    ///    fn g() {}\n-    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n-    /// }\n-    /// ```\n-    ///\n-    /// Invariant: This must only be called during main resolution, not during\n-    /// import resolution.\n-    fn resolve_ident_in_lexical_scope(\n-        &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n-        ribs: &[Rib<'a>],\n-    ) -> Option<LexicalScopeBinding<'a>> {\n-        assert!(ns == TypeNS || ns == ValueNS);\n-        let orig_ident = ident;\n-        if ident.name == kw::Empty {\n-            return Some(LexicalScopeBinding::Res(Res::Err));\n-        }\n-        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n-            // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n-            (empty_span, empty_span)\n-        } else if ns == TypeNS {\n-            let normalized_span = ident.span.normalize_to_macros_2_0();\n-            (normalized_span, normalized_span)\n-        } else {\n-            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n-        };\n-        ident.span = general_span;\n-        let normalized_ident = Ident { span: normalized_span, ..ident };\n-\n-        // Walk backwards up the ribs in scope.\n-        let finalize = finalize_full.path_span();\n-        let mut module = self.graph_root;\n-        for i in (0..ribs.len()).rev() {\n-            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n-            // Use the rib kind to determine whether we are resolving parameters\n-            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n-            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n-            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n-            {\n-                // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n-                    i,\n-                    rib_ident,\n-                    *res,\n-                    finalize,\n-                    *original_rib_ident_def,\n-                    ribs,\n-                )));\n-            }\n-\n-            module = match ribs[i].kind {\n-                ModuleRibKind(module) => module,\n-                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n-                    // If an invocation of this macro created `ident`, give up on `ident`\n-                    // and switch to `ident`'s source from the macro definition.\n-                    ident.span.remove_mark();\n-                    continue;\n-                }\n-                _ => continue,\n-            };\n-\n-            match module.kind {\n-                ModuleKind::Block(..) => {} // We can see through blocks\n-                _ => break,\n-            }\n-\n-            let item = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                parent_scope,\n-                finalize,\n-            );\n-            if let Ok(binding) = item {\n-                // The ident resolves to an item.\n-                return Some(LexicalScopeBinding::Item(binding));\n-            }\n-        }\n-        self.early_resolve_ident_in_lexical_scope(\n-            orig_ident,\n-            ScopeSet::Late(ns, module, finalize_full.node_id()),\n-            parent_scope,\n-            finalize,\n-            finalize.is_some(),\n-        )\n-        .ok()\n-        .map(LexicalScopeBinding::Item)\n-    }\n-\n-    fn hygienic_lexical_parent(\n-        &mut self,\n-        module: Module<'a>,\n-        ctxt: &mut SyntaxContext,\n-        derive_fallback_lint_id: Option<NodeId>,\n-    ) -> Option<(Module<'a>, Option<NodeId>)> {\n-        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n-        }\n-\n-        if let ModuleKind::Block(..) = module.kind {\n-            return Some((module.parent.unwrap().nearest_item_scope(), None));\n-        }\n-\n-        // We need to support the next case under a deprecation warning\n-        // ```\n-        // struct MyStruct;\n-        // ---- begin: this comes from a proc macro derive\n-        // mod implementation_details {\n-        //     // Note that `MyStruct` is not in scope here.\n-        //     impl SomeTrait for MyStruct { ... }\n-        // }\n-        // ---- end\n-        // ```\n-        // So we have to fall back to the module's parent during lexical resolution in this case.\n-        if derive_fallback_lint_id.is_some() {\n-            if let Some(parent) = module.parent {\n-                // Inner module is inside the macro, parent module is outside of the macro.\n-                if module.expansion != parent.expansion\n-                    && module.expansion.is_descendant_of(parent.expansion)\n-                {\n-                    // The macro is a proc macro derive\n-                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                        let ext = self.get_macro_by_def_id(def_id);\n-                        if ext.builtin_name.is_none()\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n-                        {\n-                            return Some((parent, derive_fallback_lint_id));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_ident_in_module(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n-            .map_err(|(determinacy, _)| determinacy)\n-    }\n-\n-    fn resolve_ident_in_module_ext(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let tmp_parent_scope;\n-        let mut adjusted_parent_scope = parent_scope;\n-        match module {\n-            ModuleOrUniformRoot::Module(m) => {\n-                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n-                    tmp_parent_scope =\n-                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n-                    adjusted_parent_scope = &tmp_parent_scope;\n-                }\n-            }\n-            ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n-            }\n-            ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n-                // No adjustments\n-            }\n-        }\n-        self.resolve_ident_in_module_unadjusted_ext(\n-            module,\n-            ident,\n-            ns,\n-            adjusted_parent_scope,\n-            false,\n-            finalize,\n-        )\n-    }\n-\n     fn resolve_crate_root(&mut self, ident: Ident) -> Module<'a> {\n         debug!(\"resolve_crate_root({:?})\", ident);\n         let mut ctxt = ident.span.ctxt();\n@@ -2194,384 +1810,6 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    fn resolve_path(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Finalize,\n-    ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n-    }\n-\n-    fn resolve_path_with_ribs(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n-        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n-    ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n-\n-        let finalize = finalize_full.path_span();\n-        let mut module = None;\n-        let mut allow_super = true;\n-        let mut second_binding = None;\n-\n-        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n-            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n-            let record_segment_res = |this: &mut Self, res| {\n-                if finalize.is_some() {\n-                    if let Some(id) = id {\n-                        if !this.partial_res_map.contains_key(&id) {\n-                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_partial_res(id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-            };\n-\n-            let is_last = i == path.len() - 1;\n-            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n-            let name = ident.name;\n-\n-            allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);\n-\n-            if ns == TypeNS {\n-                if allow_super && name == kw::Super {\n-                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                    let self_module = match i {\n-                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n-                        _ => match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n-                            _ => None,\n-                        },\n-                    };\n-                    if let Some(self_module) = self_module {\n-                        if let Some(parent) = self_module.parent {\n-                            module = Some(ModuleOrUniformRoot::Module(\n-                                self.resolve_self(&mut ctxt, parent),\n-                            ));\n-                            continue;\n-                        }\n-                    }\n-                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                        (\"there are too many leading `super` keywords\".to_string(), None)\n-                    });\n-                }\n-                if i == 0 {\n-                    if name == kw::SelfLower {\n-                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                        module = Some(ModuleOrUniformRoot::Module(\n-                            self.resolve_self(&mut ctxt, parent_scope.module),\n-                        ));\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot && ident.span.rust_2018() {\n-                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n-                        // `::a::b` from 2015 macro on 2018 global edition\n-                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {\n-                        // `::a::b`, `crate::a::b` or `$crate::a::b`\n-                        module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));\n-                        continue;\n-                    }\n-                }\n-            }\n-\n-            // Report special messages for path segment keywords in wrong positions.\n-            if ident.is_path_segment_keyword() && i != 0 {\n-                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                    let name_str = if name == kw::PathRoot {\n-                        \"crate root\".to_string()\n-                    } else {\n-                        format!(\"`{}`\", name)\n-                    };\n-                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n-                        format!(\"global paths cannot start with {}\", name_str)\n-                    } else {\n-                        format!(\"{} in paths can only be used in start position\", name_str)\n-                    };\n-                    (label, None)\n-                });\n-            }\n-\n-            enum FindBindingResult<'a> {\n-                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n-                PathResult(PathResult<'a>),\n-            }\n-            let find_binding_in_ns = |this: &mut Self, ns| {\n-                let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n-                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n-                    this.early_resolve_ident_in_lexical_scope(\n-                        ident,\n-                        scopes,\n-                        parent_scope,\n-                        finalize,\n-                        finalize.is_some(),\n-                    )\n-                } else {\n-                    match this.resolve_ident_in_lexical_scope(\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        finalize_full,\n-                        &ribs.unwrap()[ns],\n-                    ) {\n-                        // we found a locally-imported or available item/module\n-                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                        // we found a local variable or type param\n-                        Some(LexicalScopeBinding::Res(res))\n-                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                        {\n-                            record_segment_res(this, res);\n-                            return FindBindingResult::PathResult(PathResult::NonModule(\n-                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n-                            ));\n-                        }\n-                        _ => Err(Determinacy::determined(finalize.is_some())),\n-                    }\n-                };\n-                FindBindingResult::Binding(binding)\n-            };\n-            let binding = match find_binding_in_ns(self, ns) {\n-                FindBindingResult::PathResult(x) => return x,\n-                FindBindingResult::Binding(binding) => binding,\n-            };\n-            match binding {\n-                Ok(binding) => {\n-                    if i == 1 {\n-                        second_binding = Some(binding);\n-                    }\n-                    let res = binding.res();\n-                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n-                    if let Some(next_module) = binding.module() {\n-                        module = Some(ModuleOrUniformRoot::Module(next_module));\n-                        record_segment_res(self, res);\n-                    } else if res == Res::ToolMod && i + 1 != path.len() {\n-                        if binding.is_import() {\n-                            self.session\n-                                .struct_span_err(\n-                                    ident.span,\n-                                    \"cannot use a tool module through an import\",\n-                                )\n-                                .span_note(binding.span, \"the tool module imported here\")\n-                                .emit();\n-                        }\n-                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        return PathResult::NonModule(PartialRes::new(res));\n-                    } else if res == Res::Err {\n-                        return PathResult::NonModule(PartialRes::new(Res::Err));\n-                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n-                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                            res,\n-                            path.len() - i - 1,\n-                        ));\n-                    } else {\n-                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                            let label = format!(\n-                                \"`{ident}` is {} {}, not a module\",\n-                                res.article(),\n-                                res.descr()\n-                            );\n-                            (label, None)\n-                        });\n-                    }\n-                }\n-                Err(Undetermined) => return PathResult::Indeterminate,\n-                Err(Determined) => {\n-                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n-                        if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                                module.res().unwrap(),\n-                                path.len() - i,\n-                            ));\n-                        }\n-                    }\n-\n-                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                        let module_res = match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                            _ => None,\n-                        };\n-                        if module_res == self.graph_root.res() {\n-                            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n-                            let mut candidates =\n-                                self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n-                            candidates.sort_by_cached_key(|c| {\n-                                (c.path.segments.len(), pprust::path_to_string(&c.path))\n-                            });\n-                            if let Some(candidate) = candidates.get(0) {\n-                                (\n-                                    String::from(\"unresolved import\"),\n-                                    Some((\n-                                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n-                                        String::from(\"a similar path exists\"),\n-                                        Applicability::MaybeIncorrect,\n-                                    )),\n-                                )\n-                            } else if self.session.edition() == Edition::Edition2015 {\n-                                (format!(\"maybe a missing crate `{}`?\", ident), None)\n-                            } else {\n-                                (format!(\"could not find `{}` in the crate root\", ident), None)\n-                            }\n-                        } else if i == 0 {\n-                            if ident\n-                                .name\n-                                .as_str()\n-                                .chars()\n-                                .next()\n-                                .map_or(false, |c| c.is_ascii_uppercase())\n-                            {\n-                                // Check whether the name refers to an item in the value namespace.\n-                                let suggestion = if ribs.is_some() {\n-                                    let match_span = match self.resolve_ident_in_lexical_scope(\n-                                        ident,\n-                                        ValueNS,\n-                                        parent_scope,\n-                                        Finalize::No,\n-                                        &ribs.unwrap()[ValueNS],\n-                                    ) {\n-                                        // Name matches a local variable. For example:\n-                                        // ```\n-                                        // fn f() {\n-                                        //     let Foo: &str = \"\";\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // variable `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                                            Some(*self.pat_span_map.get(&id).unwrap())\n-                                        }\n-\n-                                        // Name matches item from a local name binding\n-                                        // created by `use` declaration. For example:\n-                                        // ```\n-                                        // pub Foo: &str = \"\";\n-                                        //\n-                                        // mod submod {\n-                                        //     use super::Foo;\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // binding `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Item(name_binding)) => {\n-                                            Some(name_binding.span)\n-                                        }\n-                                        _ => None,\n-                                    };\n-\n-                                    if let Some(span) = match_span {\n-                                        Some((\n-                                            vec![(span, String::from(\"\"))],\n-                                            format!(\n-                                                \"`{}` is defined here, but is not a type\",\n-                                                ident\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        None\n-                                    }\n-                                } else {\n-                                    None\n-                                };\n-\n-                                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n-                            } else {\n-                                (\n-                                    format!(\"use of undeclared crate or module `{}`\", ident),\n-                                    if ident.name == sym::alloc {\n-                                        Some((\n-                                            vec![],\n-                                            String::from(\n-                                                \"add `extern crate alloc` to use the `alloc` crate\",\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        self.find_similarly_named_module_or_crate(\n-                                            ident.name,\n-                                            &parent_scope.module,\n-                                        )\n-                                        .map(|sugg| {\n-                                            (\n-                                                vec![(ident.span, sugg.to_string())],\n-                                                String::from(\n-                                                    \"there is a crate or module with a similar name\",\n-                                                ),\n-                                                Applicability::MaybeIncorrect,\n-                                            )\n-                                        })\n-                                    },\n-                                )\n-                            }\n-                        } else {\n-                            let parent = path[i - 1].ident.name;\n-                            let parent = match parent {\n-                                // ::foo is mounted at the crate root for 2015, and is the extern\n-                                // prelude for 2018+\n-                                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n-                                    \"the list of imported crates\".to_owned()\n-                                }\n-                                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                                _ => {\n-                                    format!(\"`{}`\", parent)\n-                                }\n-                            };\n-\n-                            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n-                            if ns == TypeNS || ns == ValueNS {\n-                                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                                if let FindBindingResult::Binding(Ok(binding)) =\n-                                    find_binding_in_ns(self, ns_to_try)\n-                                {\n-                                    let mut found = |what| {\n-                                        msg = format!(\n-                                            \"expected {}, found {} `{}` in {}\",\n-                                            ns.descr(),\n-                                            what,\n-                                            ident,\n-                                            parent\n-                                        )\n-                                    };\n-                                    if binding.module().is_some() {\n-                                        found(\"module\")\n-                                    } else {\n-                                        match binding.res() {\n-                                            def::Res::<NodeId>::Def(kind, id) => {\n-                                                found(kind.descr(id))\n-                                            }\n-                                            _ => found(ns_to_try.descr()),\n-                                        }\n-                                    }\n-                                };\n-                            }\n-                            (msg, None)\n-                        }\n-                    });\n-                }\n-            }\n-        }\n-\n-        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n-\n-        PathResult::Module(match module {\n-            Some(module) => module,\n-            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n-            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n-        })\n-    }\n-\n     fn lint_if_path_starts_with_module(\n         &mut self,\n         finalize: Finalize,\n@@ -2631,239 +1869,6 @@ impl<'a> Resolver<'a> {\n         );\n     }\n \n-    // Validate a local resolution (from ribs).\n-    fn validate_res_from_ribs(\n-        &mut self,\n-        rib_index: usize,\n-        rib_ident: Ident,\n-        mut res: Res,\n-        finalize: Option<Span>,\n-        original_rib_ident_def: Ident,\n-        all_ribs: &[Rib<'a>],\n-    ) -> Res {\n-        const CG_BUG_STR: &str = \"min_const_generics resolve check didn't stop compilation\";\n-        debug!(\"validate_res_from_ribs({:?})\", res);\n-        let ribs = &all_ribs[rib_index + 1..];\n-\n-        // An invalid forward use of a generic parameter from a previous default.\n-        if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n-            if let Some(span) = finalize {\n-                let res_error = if rib_ident.name == kw::SelfUpper {\n-                    ResolutionError::SelfInGenericParamDefault\n-                } else {\n-                    ResolutionError::ForwardDeclaredGenericParam\n-                };\n-                self.report_error(span, res_error);\n-            }\n-            assert_eq!(res, Res::Err);\n-            return Res::Err;\n-        }\n-\n-        match res {\n-            Res::Local(_) => {\n-                use ResolutionError::*;\n-                let mut res_err = None;\n-\n-                for rib in ribs {\n-                    match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => {\n-                            // Nothing to do. Continue.\n-                        }\n-                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n-                            // This was an attempt to access an upvar inside a\n-                            // named function item. This is not allowed, so we\n-                            // report an error.\n-                            if let Some(span) = finalize {\n-                                // We don't immediately trigger a resolve error, because\n-                                // we want certain other resolution errors (namely those\n-                                // emitted for `ConstantItemRibKind` below) to take\n-                                // precedence.\n-                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n-                            }\n-                        }\n-                        ConstantItemRibKind(_, item) => {\n-                            // Still doesn't deal with upvars\n-                            if let Some(span) = finalize {\n-                                let (span, resolution_error) =\n-                                    if let Some((ident, constant_item_kind)) = item {\n-                                        let kind_str = match constant_item_kind {\n-                                            ConstantItemKind::Const => \"const\",\n-                                            ConstantItemKind::Static => \"static\",\n-                                        };\n-                                        (\n-                                            span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                ident, \"let\", kind_str,\n-                                            ),\n-                                        )\n-                                    } else {\n-                                        (\n-                                            rib_ident.span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                original_rib_ident_def,\n-                                                \"const\",\n-                                                \"let\",\n-                                            ),\n-                                        )\n-                                    };\n-                                self.report_error(span, resolution_error);\n-                            }\n-                            return Res::Err;\n-                        }\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n-                            }\n-                            return Res::Err;\n-                        }\n-                    }\n-                }\n-                if let Some((span, res_err)) = res_err {\n-                    self.report_error(span, res_err);\n-                    return Res::Err;\n-                }\n-            }\n-            Res::Def(DefKind::TyParam, _) | Res::SelfTy { .. } => {\n-                for rib in ribs {\n-                    let has_generic_params: HasGenericParams = match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => {\n-                            // Nothing to do. Continue.\n-                            continue;\n-                        }\n-\n-                        ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial || features.generic_const_exprs) {\n-                                // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n-                                // we can't easily tell if it's generic at this stage, so we instead remember\n-                                // this and then enforce the self type to be concrete later on.\n-                                if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n-                                    res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n-                                } else {\n-                                    if let Some(span) = finalize {\n-                                        self.report_error(\n-                                            span,\n-                                            ResolutionError::ParamInNonTrivialAnonConst {\n-                                                name: rib_ident.name,\n-                                                is_type: true,\n-                                            },\n-                                        );\n-                                        self.session.delay_span_bug(span, CG_BUG_STR);\n-                                    }\n-\n-                                    return Res::Err;\n-                                }\n-                            }\n-\n-                            continue;\n-                        }\n-\n-                        // This was an attempt to use a type parameter outside its scope.\n-                        ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(\n-                                    span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n-                    };\n-\n-                    if let Some(span) = finalize {\n-                        self.report_error(\n-                            span,\n-                            ResolutionError::GenericParamsFromOuterFunction(\n-                                res,\n-                                has_generic_params,\n-                            ),\n-                        );\n-                    }\n-                    return Res::Err;\n-                }\n-            }\n-            Res::Def(DefKind::ConstParam, _) => {\n-                let mut ribs = ribs.iter().peekable();\n-                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n-                    // When declaring const parameters inside function signatures, the first rib\n-                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n-                    // (spuriously) conflicting with the const param.\n-                    ribs.next();\n-                }\n-\n-                for rib in ribs {\n-                    let has_generic_params = match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => continue,\n-\n-                        ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial || features.generic_const_exprs) {\n-                                if let Some(span) = finalize {\n-                                    self.report_error(\n-                                        span,\n-                                        ResolutionError::ParamInNonTrivialAnonConst {\n-                                            name: rib_ident.name,\n-                                            is_type: false,\n-                                        },\n-                                    );\n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n-                                }\n-\n-                                return Res::Err;\n-                            }\n-\n-                            continue;\n-                        }\n-\n-                        ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(\n-                                    span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n-                    };\n-\n-                    // This was an attempt to use a const parameter outside its scope.\n-                    if let Some(span) = finalize {\n-                        self.report_error(\n-                            span,\n-                            ResolutionError::GenericParamsFromOuterFunction(\n-                                res,\n-                                has_generic_params,\n-                            ),\n-                        );\n-                    }\n-                    return Res::Err;\n-                }\n-            }\n-            _ => {}\n-        }\n-        res\n-    }\n-\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {"}, {"sha": "71795ef1633f29e09654399314bf821bfd87a3cc", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 10, "deletions": 362, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a52c27d2bca3b39742dcc89c2b5ee643660fec/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "patch": "@@ -3,9 +3,9 @@\n \n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n-use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n-use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{BuiltinMacroState, Determinacy};\n+use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n+use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n@@ -18,14 +18,11 @@ use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, Resolver\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, Invocation, InvocationKind, SupportsMacroExpansion};\n-use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n-use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::{self, RegisteredTools};\n-use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, PROC_MACRO_DERIVE_RESOLUTION_FALLBACK};\n-use rustc_session::lint::builtin::{SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_middle::ty::RegisteredTools;\n+use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE, UNUSED_MACROS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -35,7 +32,7 @@ use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n-use std::{mem, ptr};\n+use std::mem;\n \n type Res = def::Res<NodeId>;\n \n@@ -73,10 +70,10 @@ pub enum MacroRulesScope<'a> {\n /// in a module (including derives) and hurt performance.\n pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>;\n \n-// Macro namespace is separated into two sub-namespaces, one for bang macros and\n-// one for attribute-like macros (attributes, derives).\n-// We ignore resolutions from one sub-namespace when searching names in scope for another.\n-fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n+/// Macro namespace is separated into two sub-namespaces, one for bang macros and\n+/// one for attribute-like macros (attributes, derives).\n+/// We ignore resolutions from one sub-namespace when searching names in scope for another.\n+crate fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS {\n         Bang,\n@@ -630,355 +627,6 @@ impl<'a> Resolver<'a> {\n         res.map(|res| (self.get_macro(res), res))\n     }\n \n-    // Resolve an identifier in lexical scope.\n-    // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n-    // expansion and import resolution (perhaps they can be merged in the future).\n-    // The function is used for resolving initial segments of macro paths (e.g., `foo` in\n-    // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n-    crate fn early_resolve_ident_in_lexical_scope(\n-        &mut self,\n-        orig_ident: Ident,\n-        scope_set: ScopeSet<'a>,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-        force: bool,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        bitflags::bitflags! {\n-            struct Flags: u8 {\n-                const MACRO_RULES          = 1 << 0;\n-                const MODULE               = 1 << 1;\n-                const MISC_SUGGEST_CRATE   = 1 << 2;\n-                const MISC_SUGGEST_SELF    = 1 << 3;\n-                const MISC_FROM_PRELUDE    = 1 << 4;\n-            }\n-        }\n-\n-        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n-\n-        // Make sure `self`, `super` etc produce an error when passed to here.\n-        if orig_ident.is_path_segment_keyword() {\n-            return Err(Determinacy::Determined);\n-        }\n-\n-        let (ns, macro_kind, is_import) = match scope_set {\n-            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Late(ns, ..) => (ns, None, false),\n-        };\n-\n-        // This is *the* result, resolution from the scope closest to the resolved identifier.\n-        // However, sometimes this result is \"weak\" because it comes from a glob import or\n-        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n-        // mod m { ... } // solution in outer scope\n-        // {\n-        //     use prefix::*; // imports another `m` - innermost solution\n-        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n-        //     m::mac!();\n-        // }\n-        // So we have to save the innermost solution and continue searching in outer scopes\n-        // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n-        let mut determinacy = Determinacy::Determined;\n-\n-        // Go through all the scopes and try to resolve the name.\n-        let break_result = self.visit_scopes(\n-            scope_set,\n-            parent_scope,\n-            orig_ident.span.ctxt(),\n-            |this, scope, use_prelude, ctxt| {\n-                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n-                let ok = |res, span, arenas| {\n-                    Ok((\n-                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n-                            .to_name_binding(arenas),\n-                        Flags::empty(),\n-                    ))\n-                };\n-                let result = match scope {\n-                    Scope::DeriveHelpers(expn_id) => {\n-                        if let Some(attr) = this\n-                            .helper_attrs\n-                            .get(&expn_id)\n-                            .and_then(|attrs| attrs.iter().rfind(|i| ident == **i))\n-                        {\n-                            let binding = (\n-                                Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                ty::Visibility::Public,\n-                                attr.span,\n-                                expn_id,\n-                            )\n-                                .to_name_binding(this.arenas);\n-                            Ok((binding, Flags::empty()))\n-                        } else {\n-                            Err(Determinacy::Determined)\n-                        }\n-                    }\n-                    Scope::DeriveHelpersCompat => {\n-                        let mut result = Err(Determinacy::Determined);\n-                        for derive in parent_scope.derives {\n-                            let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n-                            match this.resolve_macro_path(\n-                                derive,\n-                                Some(MacroKind::Derive),\n-                                parent_scope,\n-                                true,\n-                                force,\n-                            ) {\n-                                Ok((Some(ext), _)) => {\n-                                    if ext.helper_attrs.contains(&ident.name) {\n-                                        result = ok(\n-                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n-                                            derive.span,\n-                                            this.arenas,\n-                                        );\n-                                        break;\n-                                    }\n-                                }\n-                                Ok(_) | Err(Determinacy::Determined) => {}\n-                                Err(Determinacy::Undetermined) => {\n-                                    result = Err(Determinacy::Undetermined)\n-                                }\n-                            }\n-                        }\n-                        result\n-                    }\n-                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n-                        MacroRulesScope::Binding(macro_rules_binding)\n-                            if ident == macro_rules_binding.ident =>\n-                        {\n-                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n-                        }\n-                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n-                        _ => Err(Determinacy::Determined),\n-                    },\n-                    Scope::CrateRoot => {\n-                        let root_ident = Ident::new(kw::PathRoot, ident.span);\n-                        let root_module = this.resolve_crate_root(root_ident);\n-                        let binding = this.resolve_ident_in_module_ext(\n-                            ModuleOrUniformRoot::Module(root_module),\n-                            ident,\n-                            ns,\n-                            parent_scope,\n-                            finalize,\n-                        );\n-                        match binding {\n-                            Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n-                            Err((Determinacy::Undetermined, Weak::No)) => {\n-                                return Some(Err(Determinacy::determined(force)));\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n-                                Err(Determinacy::Undetermined)\n-                            }\n-                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n-                        }\n-                    }\n-                    Scope::Module(module, derive_fallback_lint_id) => {\n-                        let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n-                        let binding = this.resolve_ident_in_module_unadjusted_ext(\n-                            ModuleOrUniformRoot::Module(module),\n-                            ident,\n-                            ns,\n-                            adjusted_parent_scope,\n-                            !matches!(scope_set, ScopeSet::Late(..)),\n-                            finalize,\n-                        );\n-                        match binding {\n-                            Ok(binding) => {\n-                                if let Some(lint_id) = derive_fallback_lint_id {\n-                                    this.lint_buffer.buffer_lint_with_diagnostic(\n-                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                                        lint_id,\n-                                        orig_ident.span,\n-                                        &format!(\n-                                            \"cannot find {} `{}` in this scope\",\n-                                            ns.descr(),\n-                                            ident\n-                                        ),\n-                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n-                                            orig_ident.span,\n-                                        ),\n-                                    );\n-                                }\n-                                let misc_flags = if ptr::eq(module, this.graph_root) {\n-                                    Flags::MISC_SUGGEST_CRATE\n-                                } else if module.is_normal() {\n-                                    Flags::MISC_SUGGEST_SELF\n-                                } else {\n-                                    Flags::empty()\n-                                };\n-                                Ok((binding, Flags::MODULE | misc_flags))\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::No)) => {\n-                                return Some(Err(Determinacy::determined(force)));\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n-                                Err(Determinacy::Undetermined)\n-                            }\n-                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n-                        }\n-                    }\n-                    Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n-                        Some(ident) => ok(\n-                            Res::NonMacroAttr(NonMacroAttrKind::Registered),\n-                            ident.span,\n-                            this.arenas,\n-                        ),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                    Scope::MacroUsePrelude => {\n-                        match this.macro_use_prelude.get(&ident.name).cloned() {\n-                            Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                            )),\n-                        }\n-                    }\n-                    Scope::BuiltinAttrs => {\n-                        if is_builtin_attr_name(ident.name) {\n-                            ok(\n-                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n-                                DUMMY_SP,\n-                                this.arenas,\n-                            )\n-                        } else {\n-                            Err(Determinacy::Determined)\n-                        }\n-                    }\n-                    Scope::ExternPrelude => {\n-                        match this.extern_prelude_get(ident, finalize.is_some()) {\n-                            Some(binding) => Ok((binding, Flags::empty())),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                            )),\n-                        }\n-                    }\n-                    Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n-                        Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                    Scope::StdLibPrelude => {\n-                        let mut result = Err(Determinacy::Determined);\n-                        if let Some(prelude) = this.prelude {\n-                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n-                                ModuleOrUniformRoot::Module(prelude),\n-                                ident,\n-                                ns,\n-                                parent_scope,\n-                                None,\n-                            ) {\n-                                if use_prelude || this.is_builtin_macro(binding.res()) {\n-                                    result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n-                                }\n-                            }\n-                        }\n-                        result\n-                    }\n-                    Scope::BuiltinTypes => match PrimTy::from_name(ident.name) {\n-                        Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                };\n-\n-                match result {\n-                    Ok((binding, flags))\n-                        if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n-                    {\n-                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n-                            return Some(Ok(binding));\n-                        }\n-\n-                        if let Some((innermost_binding, innermost_flags)) = innermost_result {\n-                            // Found another solution, if the first one was \"weak\", report an error.\n-                            let (res, innermost_res) = (binding.res(), innermost_binding.res());\n-                            if res != innermost_res {\n-                                let is_builtin = |res| {\n-                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n-                                };\n-                                let derive_helper =\n-                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n-                                let derive_helper_compat =\n-                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n-\n-                                let ambiguity_error_kind = if is_import {\n-                                    Some(AmbiguityKind::Import)\n-                                } else if is_builtin(innermost_res) || is_builtin(res) {\n-                                    Some(AmbiguityKind::BuiltinAttr)\n-                                } else if innermost_res == derive_helper_compat\n-                                    || res == derive_helper_compat && innermost_res != derive_helper\n-                                {\n-                                    Some(AmbiguityKind::DeriveHelper)\n-                                } else if innermost_flags.contains(Flags::MACRO_RULES)\n-                                    && flags.contains(Flags::MODULE)\n-                                    && !this.disambiguate_macro_rules_vs_modularized(\n-                                        innermost_binding,\n-                                        binding,\n-                                    )\n-                                    || flags.contains(Flags::MACRO_RULES)\n-                                        && innermost_flags.contains(Flags::MODULE)\n-                                        && !this.disambiguate_macro_rules_vs_modularized(\n-                                            binding,\n-                                            innermost_binding,\n-                                        )\n-                                {\n-                                    Some(AmbiguityKind::MacroRulesVsModularized)\n-                                } else if innermost_binding.is_glob_import() {\n-                                    Some(AmbiguityKind::GlobVsOuter)\n-                                } else if innermost_binding\n-                                    .may_appear_after(parent_scope.expansion, binding)\n-                                {\n-                                    Some(AmbiguityKind::MoreExpandedVsOuter)\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(kind) = ambiguity_error_kind {\n-                                    let misc = |f: Flags| {\n-                                        if f.contains(Flags::MISC_SUGGEST_CRATE) {\n-                                            AmbiguityErrorMisc::SuggestCrate\n-                                        } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n-                                            AmbiguityErrorMisc::SuggestSelf\n-                                        } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n-                                            AmbiguityErrorMisc::FromPrelude\n-                                        } else {\n-                                            AmbiguityErrorMisc::None\n-                                        }\n-                                    };\n-                                    this.ambiguity_errors.push(AmbiguityError {\n-                                        kind,\n-                                        ident: orig_ident,\n-                                        b1: innermost_binding,\n-                                        b2: binding,\n-                                        misc1: misc(innermost_flags),\n-                                        misc2: misc(flags),\n-                                    });\n-                                    return Some(Ok(innermost_binding));\n-                                }\n-                            }\n-                        } else {\n-                            // Found the first solution.\n-                            innermost_result = Some((binding, flags));\n-                        }\n-                    }\n-                    Ok(..) | Err(Determinacy::Determined) => {}\n-                    Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n-                }\n-\n-                None\n-            },\n-        );\n-\n-        if let Some(break_result) = break_result {\n-            return break_result;\n-        }\n-\n-        // The first found solution was the only one, return it.\n-        if let Some((binding, _)) = innermost_result {\n-            return Ok(binding);\n-        }\n-\n-        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n-    }\n-\n     crate fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self,\n                                  path: &[Segment],"}]}