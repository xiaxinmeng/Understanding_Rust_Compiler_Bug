{"sha": "8cc3fbd41dddbb11f442a17902cd0d276aa22566", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYzNmYmQ0MWRkZGJiMTFmNDQyYTE3OTAyY2QwZDI3NmFhMjI1NjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-15T12:52:31Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-15T12:52:31Z"}, "message": "Rollup merge of #22218 - huonw:raw-docs, r=steveklabnik,huonw\n\nThis overhauls the very meager docs that currently exist to clarify\r\nvarious understandable confusions that I've noticed, e.g. people look in\r\n`std::raw` for the \"real\" types of slices like `&[T]`, or think that\r\n`Slice<T>` refers to `[T]` (fixes #22214).\r\n\r\nThis patch takes the liberty of offering some \"style\" guidance around\r\n`raw::Slice`, since there's more restricted ways to duplicate all\r\nfunctionality connected to it: `std::slice::from_raw_parts{,_mut}` for\r\nconstruction and `.as_{,mut_}ptr` & `.len` for deconstruction.\r\n\r\nIt also deprecates the `std::raw::Closure` type which is now useless for\r\nnon-type-erased closures, and replaced by `TraitObject` for `&Fn`, `&mut\r\nFnMut` etc, so I guess it should be called a:\r\n\r\n[breaking-change]", "tree": {"sha": "e161c7ec52efc9aad02a2ac2979b30b9aa606814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e161c7ec52efc9aad02a2ac2979b30b9aa606814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cc3fbd41dddbb11f442a17902cd0d276aa22566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc3fbd41dddbb11f442a17902cd0d276aa22566", "html_url": "https://github.com/rust-lang/rust/commit/8cc3fbd41dddbb11f442a17902cd0d276aa22566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cc3fbd41dddbb11f442a17902cd0d276aa22566/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63091efa3bdcb18a6fac8af48acfa5634087624b", "url": "https://api.github.com/repos/rust-lang/rust/commits/63091efa3bdcb18a6fac8af48acfa5634087624b", "html_url": "https://github.com/rust-lang/rust/commit/63091efa3bdcb18a6fac8af48acfa5634087624b"}, {"sha": "7a52932f4cd65f57bcc8d77f12e32066b2a9c432", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a52932f4cd65f57bcc8d77f12e32066b2a9c432", "html_url": "https://github.com/rust-lang/rust/commit/7a52932f4cd65f57bcc8d77f12e32066b2a9c432"}], "stats": {"total": 119, "additions": 111, "deletions": 8}, "files": [{"sha": "bb0c22d3561d26138a8b6cadd49e8fb6a4be2d34", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 111, "deletions": 8, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8cc3fbd41dddbb11f442a17902cd0d276aa22566/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc3fbd41dddbb11f442a17902cd0d276aa22566/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=8cc3fbd41dddbb11f442a17902cd0d276aa22566", "patch": "@@ -21,7 +21,40 @@\n use marker::Copy;\n use mem;\n \n-/// The representation of a Rust slice\n+/// The representation of a slice like `&[T]`.\n+///\n+/// This struct is guaranteed to have the layout of types like `&[T]`,\n+/// `&str`, and `Box<[T]>`, but is not the type of such slices\n+/// (e.g. the fields are not directly accessible on a `&[T]`) nor does\n+/// it control that layout (changing the definition will not change\n+/// the layout of a `&[T]`). It is only designed to be used by unsafe\n+/// code that needs to manipulate the low-level details.\n+///\n+/// However, it is not recommended to use this type for such code,\n+/// since there are alternatives which may be safer:\n+///\n+/// - Creating a slice from a data pointer and length can be done with\n+///   `std::slice::from_raw_parts` or `std::slice::from_raw_parts_mut`\n+///   instead of `std::mem::transmute`ing a value of type `Slice`.\n+/// - Extracting the data pointer and length from a slice can be\n+///   performed with the `as_ptr` (or `as_mut_ptr`) and `len`\n+///   methods.\n+///\n+/// If one does decide to convert a slice value to a `Slice`, the\n+/// `Repr` trait in this module provides a method for a safe\n+/// conversion from `&[T]` (and `&str`) to a `Slice`, more type-safe\n+/// than a call to `transmute`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::raw::{self, Repr};\n+///\n+/// let slice: &[u16] = &[1, 2, 3, 4];\n+///\n+/// let repr: raw::Slice<u16> = slice.repr();\n+/// println!(\"data pointer = {:?}, length = {}\", repr.data, repr.len);\n+/// ```\n #[repr(C)]\n pub struct Slice<T> {\n     pub data: *const T,\n@@ -30,18 +63,88 @@ pub struct Slice<T> {\n \n impl<T> Copy for Slice<T> {}\n \n-/// The representation of a Rust closure\n+/// The representation of an old closure.\n #[repr(C)]\n #[derive(Copy)]\n+#[unstable(feature = \"core\")]\n+#[deprecated(reason = \"unboxed new closures do not have a universal representation; \\\n+                       `&Fn` (etc) trait objects should use `TraitObject` instead\",\n+             since= \"1.0.0\")]\n pub struct Closure {\n     pub code: *mut (),\n     pub env: *mut (),\n }\n \n-/// The representation of a Rust trait object.\n+/// The representation of a trait object like `&SomeTrait`.\n+///\n+/// This struct has the same layout as types like `&SomeTrait` and\n+/// `Box<AnotherTrait>`. The [Static and Dynamic Dispatch chapter of the\n+/// Book][moreinfo] contains more details about the precise nature of\n+/// these internals.\n+///\n+/// [moreinfo]: ../../book/static-and-dynamic-dispatch.html#representation\n+///\n+/// `TraitObject` is guaranteed to match layouts, but it is not the\n+/// type of trait objects (e.g. the fields are not directly accessible\n+/// on a `&SomeTrait`) nor does it control that layout (changing the\n+/// definition will not change the layout of a `&SometTrait`). It is\n+/// only designed to be used by unsafe code that needs to manipulate\n+/// the low-level details.\n+///\n+/// There is no `Repr` implementation for `TraitObject` because there\n+/// is no way to refer to all trait objects generically, so the only\n+/// way to create values of this type is with functions like\n+/// `std::mem::transmute`. Similarly, the only way to create a true\n+/// trait object from a `TraitObject` value is with `transmute`.\n+///\n+/// Synthesizing a trait object with mismatched types\u2014one where the\n+/// vtable does not correspond to the type of the value to which the\n+/// data pointer points\u2014is highly likely to lead to undefined\n+/// behaviour.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::raw;\n+///\n+/// // an example trait\n+/// trait Foo {\n+///     fn bar(&self) -> i32;\n+/// }\n+/// impl Foo for i32 {\n+///     fn bar(&self) -> i32 {\n+///          *self + 1\n+///     }\n+/// }\n+///\n+/// let value: i32 = 123;\n+///\n+/// // let the compiler make a trait object\n+/// let object: &Foo = &value;\n+///\n+/// // look at the raw representation\n+/// let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n+///\n+/// // the data pointer is the address of `value`\n+/// assert_eq!(raw_object.data as *const i32, &value as *const _);\n+///\n+///\n+/// let other_value: i32 = 456;\n+///\n+/// // construct a new object, pointing to a different `i32`, being\n+/// // careful to use the `i32` vtable from `object`\n+/// let synthesized: &Foo = unsafe {\n+///      mem::transmute(raw::TraitObject {\n+///          data: &other_value as *const _ as *mut (),\n+///          vtable: raw_object.vtable\n+///      })\n+/// };\n ///\n-/// This struct does not have a `Repr` implementation\n-/// because there is no way to refer to all trait objects generically.\n+/// // it should work just like we constructed a trait object out of\n+/// // `other_value` directly\n+/// assert_eq!(synthesized.bar(), 457);\n+/// ```\n #[repr(C)]\n #[derive(Copy)]\n pub struct TraitObject {\n@@ -51,7 +154,7 @@ pub struct TraitObject {\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n-pub trait Repr<T> {\n+pub unsafe trait Repr<T> {\n     /// This function \"unwraps\" a rust value (without consuming it) into its raw\n     /// struct representation. This can be used to read/write different values\n     /// for the struct. This is a safe method because by default it does not\n@@ -60,5 +163,5 @@ pub trait Repr<T> {\n     fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }\n }\n \n-impl<T> Repr<Slice<T>> for [T] {}\n-impl Repr<Slice<u8>> for str {}\n+unsafe impl<T> Repr<Slice<T>> for [T] {}\n+unsafe impl Repr<Slice<u8>> for str {}"}]}