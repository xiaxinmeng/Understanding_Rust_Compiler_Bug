{"sha": "7dcc74eee5584639c182aecdfe80a7f5369c5b69", "node_id": "C_kwDOAAsO6NoAKDdkY2M3NGVlZTU1ODQ2MzljMTgyYWVjZGZlODBhN2Y1MzY5YzViNjk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-25T17:59:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-26T10:30:27Z"}, "message": "Access upvars through a query.", "tree": {"sha": "4fecd9e78b8cd8f05ff619bfb68f58d3685742bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fecd9e78b8cd8f05ff619bfb68f58d3685742bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dcc74eee5584639c182aecdfe80a7f5369c5b69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dcc74eee5584639c182aecdfe80a7f5369c5b69", "html_url": "https://github.com/rust-lang/rust/commit/7dcc74eee5584639c182aecdfe80a7f5369c5b69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dcc74eee5584639c182aecdfe80a7f5369c5b69/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d35dbbdc8ec3437807213ec103e42659467d9a77", "url": "https://api.github.com/repos/rust-lang/rust/commits/d35dbbdc8ec3437807213ec103e42659467d9a77", "html_url": "https://github.com/rust-lang/rust/commit/d35dbbdc8ec3437807213ec103e42659467d9a77"}], "stats": {"total": 222, "additions": 111, "deletions": 111}, "files": [{"sha": "0f591460e9d195348790afb76929f76fa446aa2d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -202,14 +202,14 @@ fn do_mir_borrowck<'tcx>(\n     let mut errors = error::BorrowckErrors::new(infcx.tcx);\n \n     // Gather the upvars of a closure, if any.\n-    let tables = tcx.typeck_opt_const_arg(def);\n-    if let Some(e) = tables.tainted_by_errors {\n+    if let Some(e) = input_body.tainted_by_errors {\n         infcx.set_tainted_by_errors(e);\n         errors.set_tainted_by_errors(e);\n     }\n-    let upvars: Vec<_> = tables\n-        .closure_min_captures_flattened(def.did)\n-        .map(|captured_place| {\n+    let upvars: Vec<_> = tcx\n+        .closure_captures(def.did)\n+        .iter()\n+        .map(|&captured_place| {\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,"}, {"sha": "f7881c5096021d6f710afcac1634e41d29284ef6", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -240,10 +240,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME this should be more descriptive i.e. CapturePlace instead of CapturedVar\n                 // https://github.com/rust-lang/project-rfc-2229/issues/46\n                 if let Some(local_def_id) = def_id.as_local() {\n-                    let tables = self.ecx.tcx.typeck(local_def_id);\n-                    if let Some(captured_place) =\n-                        tables.closure_min_captures_flattened(local_def_id).nth(field)\n-                    {\n+                    let captures = self.ecx.tcx.closure_captures(local_def_id);\n+                    if let Some(captured_place) = captures.get(field) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         let var_hir_id = captured_place.get_root_variable();"}, {"sha": "3e27a78135e499653faa97ecf16ca8789fec6777", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -526,10 +526,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n+            let var_ident = self.tcx.hir().ident(var_hir_id);\n \n             let Some(min_cap_list) = root_var_min_capture_list.get_mut(&var_hir_id) else {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let min_cap_list = vec![ty::CapturedPlace {\n+                    var_ident,\n                     place,\n                     info: capture_info,\n                     mutability,\n@@ -628,6 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if !ancestor_found {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let captured_place = ty::CapturedPlace {\n+                    var_ident,\n                     place,\n                     info: updated_capture_info,\n                     mutability,"}, {"sha": "4b5bacac8149c8b591512fb31d9febf1b824e63e", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -902,6 +902,11 @@ impl<'hir> Map<'hir> {\n         self.opt_ident(id).map(|ident| ident.span)\n     }\n \n+    #[inline]\n+    pub fn ident(self, id: HirId) -> Ident {\n+        self.opt_ident(id).unwrap()\n+    }\n+\n     #[inline]\n     pub fn opt_name(self, id: HirId) -> Option<Symbol> {\n         self.opt_ident(id).map(|ident| ident.name)"}, {"sha": "03d2eea7d4a81a7df8ff644d20380ca15678d7ee", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -475,14 +475,10 @@ rustc_queries! {\n         }\n     }\n \n-    query symbols_for_closure_captures(\n-        key: (LocalDefId, LocalDefId)\n-    ) -> &'tcx Vec<rustc_span::Symbol> {\n-        arena_cache\n+    query closure_captures(key: LocalDefId) -> &'tcx [&'tcx ty::CapturedPlace<'tcx>] {\n         desc {\n-            |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n-            tcx.def_path_str(key.1.to_def_id()),\n-            tcx.def_path_str(key.0.to_def_id())\n+            |tcx| \"finding symbols for captures of closure `{}`\",\n+            tcx.def_path_str(key.to_def_id())\n         }\n     }\n "}, {"sha": "65df7204302c3e4b5d7fa681a7893ab81f3270a8", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -5,10 +5,11 @@ use crate::{mir, ty};\n \n use std::fmt::Write;\n \n-use hir::LangItem;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::{self as hir, LangItem};\n+use rustc_span::symbol::Ident;\n use rustc_span::{Span, Symbol};\n \n use super::{Ty, TyCtxt};\n@@ -129,6 +130,9 @@ impl<'tcx> ClosureKind {\n #[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct CapturedPlace<'tcx> {\n+    /// Name and span where the binding happens.\n+    pub var_ident: Ident,\n+\n     /// The `Place` that is captured.\n     pub place: HirPlace<'tcx>,\n \n@@ -148,12 +152,8 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n \n     /// Returns a symbol of the captured upvar, which looks like `name__field1__field2`.\n-    fn to_symbol(&self, tcx: TyCtxt<'tcx>) -> Symbol {\n-        let hir_id = match self.place.base {\n-            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-            base => bug!(\"Expected an upvar, found {:?}\", base),\n-        };\n-        let mut symbol = tcx.hir().name(hir_id).as_str().to_string();\n+    pub fn to_symbol(&self) -> Symbol {\n+        let mut symbol = self.var_ident.to_string();\n \n         let mut ty = self.place.base_ty;\n         for proj in self.place.projections.iter() {\n@@ -169,11 +169,7 @@ impl<'tcx> CapturedPlace<'tcx> {\n                         .unwrap();\n                     }\n                     ty => {\n-                        span_bug!(\n-                            self.get_capture_kind_span(tcx),\n-                            \"Unexpected type {:?} for `Field` projection\",\n-                            ty\n-                        )\n+                        bug!(\"Unexpected type {:?} for `Field` projection\", ty)\n                     }\n                 },\n \n@@ -238,10 +234,14 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n }\n \n-fn symbols_for_closure_captures(tcx: TyCtxt<'_>, def_id: (LocalDefId, LocalDefId)) -> Vec<Symbol> {\n-    let typeck_results = tcx.typeck(def_id.0);\n-    let captures = typeck_results.closure_min_captures_flattened(def_id.1);\n-    captures.into_iter().map(|captured_place| captured_place.to_symbol(tcx)).collect()\n+fn closure_captures<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: LocalDefId,\n+) -> &'tcx [&'tcx ty::CapturedPlace<'tcx>] {\n+    let (DefKind::Closure | DefKind::Generator) = tcx.def_kind(def) else { return &[] };\n+    let typeck_results = tcx.typeck(def);\n+    let captures = typeck_results.closure_min_captures_flattened(def);\n+    tcx.arena.alloc_from_iter(captures)\n }\n \n /// Return true if the `proj_possible_ancestor` represents an ancestor path\n@@ -434,5 +434,5 @@ impl BorrowKind {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { symbols_for_closure_captures, ..*providers }\n+    *providers = ty::query::Providers { closure_captures, ..*providers }\n }"}, {"sha": "ef643531bb288658368f3d94da959f67a5509126", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -263,6 +263,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n     ::rustc_span::Span,\n+    ::rustc_span::symbol::Ident,\n     ::rustc_errors::ErrorGuaranteed,\n     Field,\n     interpret::Scalar,"}, {"sha": "b3f9d82829f1306b7d97c727609356272d831165", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::*;\n use rustc_middle::thir::{\n     self, BindingMode, Expr, ExprId, LintLevel, LocalVarId, Param, ParamId, PatKind, Thir,\n };\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_span::Symbol;\n@@ -155,13 +155,13 @@ struct BlockContext(Vec<BlockFrame>);\n struct Builder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: InferCtxt<'tcx>,\n-    typeck_results: &'tcx TypeckResults<'tcx>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n \n     thir: &'a Thir<'tcx>,\n     cfg: CFG<'tcx>,\n \n+    def: ty::WithOptConstParam<LocalDefId>,\n     def_id: DefId,\n     hir_id: hir::HirId,\n     parent_module: DefId,\n@@ -522,13 +522,7 @@ fn construct_fn<'tcx>(\n         let return_block =\n             unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                    builder.args_and_body(\n-                        START_BLOCK,\n-                        fn_def.did,\n-                        arguments,\n-                        arg_scope,\n-                        &thir[expr],\n-                    )\n+                    builder.args_and_body(START_BLOCK, arguments, arg_scope, &thir[expr])\n                 }))\n             }));\n         let source_info = builder.source_info(fn_end);\n@@ -704,9 +698,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             thir,\n             tcx,\n             infcx,\n-            typeck_results: tcx.typeck_opt_const_arg(def),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             param_env,\n+            def,\n             def_id: def.did.to_def_id(),\n             hir_id,\n             parent_module: tcx.parent_module(hir_id).to_def_id(),\n@@ -756,14 +750,78 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info,\n             self.fn_span,\n             self.generator_kind,\n-            self.typeck_results.tainted_by_errors,\n+            None,\n         )\n     }\n \n+    fn insert_upvar_arg(&mut self) {\n+        let Some(closure_arg) = self.local_decls.get(ty::CAPTURE_STRUCT_LOCAL) else { return };\n+\n+        let mut closure_ty = closure_arg.ty;\n+        let mut closure_env_projs = vec![];\n+        if let ty::Ref(_, ty, _) = closure_ty.kind() {\n+            closure_env_projs.push(ProjectionElem::Deref);\n+            closure_ty = *ty;\n+        }\n+\n+        let upvar_substs = match closure_ty.kind() {\n+            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+            _ => return,\n+        };\n+\n+        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n+        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n+        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n+        // the given closure and use the necessary information to create upvar\n+        // debuginfo and to fill `self.upvars`.\n+        let capture_tys = upvar_substs.upvar_tys();\n+\n+        let tcx = self.tcx;\n+        self.upvars = tcx\n+            .closure_captures(self.def.did)\n+            .iter()\n+            .zip(capture_tys)\n+            .enumerate()\n+            .map(|(i, (captured_place, ty))| {\n+                let name = captured_place.to_symbol();\n+\n+                let capture = captured_place.info.capture_kind;\n+                let var_id = match captured_place.place.base {\n+                    HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                    _ => bug!(\"Expected an upvar\"),\n+                };\n+\n+                let mutability = captured_place.mutability;\n+\n+                let mut projs = closure_env_projs.clone();\n+                projs.push(ProjectionElem::Field(Field::new(i), ty));\n+                match capture {\n+                    ty::UpvarCapture::ByValue => {}\n+                    ty::UpvarCapture::ByRef(..) => {\n+                        projs.push(ProjectionElem::Deref);\n+                    }\n+                };\n+\n+                let use_place = Place {\n+                    local: ty::CAPTURE_STRUCT_LOCAL,\n+                    projection: tcx.mk_place_elems(&projs),\n+                };\n+                self.var_debug_info.push(VarDebugInfo {\n+                    name,\n+                    source_info: SourceInfo::outermost(captured_place.var_ident.span),\n+                    value: VarDebugInfoContents::Place(use_place),\n+                });\n+\n+                let capture = Capture { captured_place, use_place, mutability };\n+                (var_id, capture)\n+            })\n+            .collect();\n+    }\n+\n     fn args_and_body(\n         &mut self,\n         mut block: BasicBlock,\n-        fn_def_id: LocalDefId,\n         arguments: &IndexVec<ParamId, Param<'tcx>>,\n         argument_scope: region::Scope,\n         expr: &Expr<'tcx>,\n@@ -785,69 +843,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let tcx = self.tcx;\n-        let tcx_hir = tcx.hir();\n-        let hir_typeck_results = self.typeck_results;\n-\n-        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n-        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n-        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n-        // the given closure and use the necessary information to create upvar\n-        // debuginfo and to fill `self.upvars`.\n-        if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n-            let mut closure_env_projs = vec![];\n-            let mut closure_ty = self.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n-            if let ty::Ref(_, ty, _) = closure_ty.kind() {\n-                closure_env_projs.push(ProjectionElem::Deref);\n-                closure_ty = *ty;\n-            }\n-            let upvar_substs = match closure_ty.kind() {\n-                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-                _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n-            };\n-            let def_id = self.def_id.as_local().unwrap();\n-            let capture_syms = tcx.symbols_for_closure_captures((def_id, fn_def_id));\n-            let capture_tys = upvar_substs.upvar_tys();\n-            let captures_with_tys = hir_typeck_results\n-                .closure_min_captures_flattened(fn_def_id)\n-                .zip(capture_tys.zip(capture_syms));\n-\n-            self.upvars = captures_with_tys\n-                .enumerate()\n-                .map(|(i, (captured_place, (ty, sym)))| {\n-                    let capture = captured_place.info.capture_kind;\n-                    let var_id = match captured_place.place.base {\n-                        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-                        _ => bug!(\"Expected an upvar\"),\n-                    };\n-\n-                    let mutability = captured_place.mutability;\n-\n-                    let mut projs = closure_env_projs.clone();\n-                    projs.push(ProjectionElem::Field(Field::new(i), ty));\n-                    match capture {\n-                        ty::UpvarCapture::ByValue => {}\n-                        ty::UpvarCapture::ByRef(..) => {\n-                            projs.push(ProjectionElem::Deref);\n-                        }\n-                    };\n-\n-                    let use_place = Place {\n-                        local: ty::CAPTURE_STRUCT_LOCAL,\n-                        projection: tcx.mk_place_elems(&projs),\n-                    };\n-                    self.var_debug_info.push(VarDebugInfo {\n-                        name: *sym,\n-                        source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n-                        value: VarDebugInfoContents::Place(use_place),\n-                    });\n-\n-                    let capture = Capture { captured_place, use_place, mutability };\n-                    (var_id, capture)\n-                })\n-                .collect();\n-        }\n+        self.insert_upvar_arg();\n \n         let mut scope = None;\n         // Bind the argument patterns"}, {"sha": "666b8e5cc7b4734c3b393520fc30dc5ca0153ee2", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc74eee5584639c182aecdfe80a7f5369c5b69/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=7dcc74eee5584639c182aecdfe80a7f5369c5b69", "patch": "@@ -541,8 +541,9 @@ impl<'tcx> Cx<'tcx> {\n                 let def_id = def_id.expect_local();\n \n                 let upvars = self\n-                    .typeck_results\n-                    .closure_min_captures_flattened(def_id)\n+                    .tcx\n+                    .closure_captures(def_id)\n+                    .iter()\n                     .zip(substs.upvar_tys())\n                     .map(|(captured_place, ty)| {\n                         let upvars = self.capture_upvar(expr, captured_place, ty);"}]}