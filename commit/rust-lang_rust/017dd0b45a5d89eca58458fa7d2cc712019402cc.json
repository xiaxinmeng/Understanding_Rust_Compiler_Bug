{"sha": "017dd0b45a5d89eca58458fa7d2cc712019402cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxN2RkMGI0NWE1ZDg5ZWNhNTg0NThmYTdkMmNjNzEyMDE5NDAyY2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-18T19:05:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-18T19:05:20Z"}, "message": "Merge #8093\n\n8093: Record custom derive helpers in `DefMap` r=jonas-schievink a=jonas-schievink\n\nAlso clean up proc macro attribute parsing a bit\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "c442de2fa974c23662c99fd2d933ce0e9200e87a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c442de2fa974c23662c99fd2d933ce0e9200e87a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/017dd0b45a5d89eca58458fa7d2cc712019402cc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgU6RwCRBK7hj4Ov3rIwAAdHIIACRI8MZXdIPQMKiXt7O3lasO\nBOUXHOrvrCPXXfO/0ykg9ieH5q+/FtDc5UBWTAdox/Ktw0ohd1ZczSB/cwq/jlvB\nl7jv+daTk+iVc9Ckd5UZeuitr1t5IuApPPrGpat7ZHfmuRByMB1iDYubs7Oj0Wum\nqaktrLzFWLAyCTB+OqRXeku3MEJCdZHAzUebDJihkzaOGoWfc/0X6wihH/neYvS/\nxXGMXTtLRHugSpApeR+HVe90M6mFAZ2YNHrc4E5geryZbWH0OPUPLrPv8AUhb7Zp\nWSGhO50q9JR9HYDrMRh6qgCsLN+9WGZk63gLG+f5mQwMJTo/+H+081BlochpikU=\n=Y52p\n-----END PGP SIGNATURE-----\n", "payload": "tree c442de2fa974c23662c99fd2d933ce0e9200e87a\nparent d0805c6444e06e082465cd1a064c83c0f90faf71\nparent 6489e5b7851dab447cb630958e6870cf792efa38\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616094320 +0000\ncommitter GitHub <noreply@github.com> 1616094320 +0000\n\nMerge #8093\n\n8093: Record custom derive helpers in `DefMap` r=jonas-schievink a=jonas-schievink\n\nAlso clean up proc macro attribute parsing a bit\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/017dd0b45a5d89eca58458fa7d2cc712019402cc", "html_url": "https://github.com/rust-lang/rust/commit/017dd0b45a5d89eca58458fa7d2cc712019402cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/017dd0b45a5d89eca58458fa7d2cc712019402cc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0805c6444e06e082465cd1a064c83c0f90faf71", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0805c6444e06e082465cd1a064c83c0f90faf71", "html_url": "https://github.com/rust-lang/rust/commit/d0805c6444e06e082465cd1a064c83c0f90faf71"}, {"sha": "6489e5b7851dab447cb630958e6870cf792efa38", "url": "https://api.github.com/repos/rust-lang/rust/commits/6489e5b7851dab447cb630958e6870cf792efa38", "html_url": "https://github.com/rust-lang/rust/commit/6489e5b7851dab447cb630958e6870cf792efa38"}], "stats": {"total": 142, "additions": 117, "deletions": 25}, "files": [{"sha": "1ac326f971d89de09af3489e3053538186f10095", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=017dd0b45a5d89eca58458fa7d2cc712019402cc", "patch": "@@ -53,11 +53,12 @@ mod path_resolution;\n \n #[cfg(test)]\n mod tests;\n+mod proc_macro;\n \n use std::sync::Arc;\n \n use base_db::{CrateId, Edition, FileId};\n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile, MacroDefId};\n use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n@@ -73,6 +74,8 @@ use crate::{\n     AstId, BlockId, BlockLoc, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n+use self::proc_macro::ProcMacroDef;\n+\n /// Contains the results of (early) name resolution.\n ///\n /// A `DefMap` stores the module tree and the definitions that are in scope in every module after\n@@ -95,6 +98,12 @@ pub struct DefMap {\n     prelude: Option<ModuleId>,\n     extern_prelude: FxHashMap<Name, ModuleDefId>,\n \n+    /// Side table with additional proc. macro info, for use by name resolution in downstream\n+    /// crates.\n+    ///\n+    /// (the primary purpose is to resolve derive helpers)\n+    exported_proc_macros: FxHashMap<MacroDefId, ProcMacroDef>,\n+\n     edition: Edition,\n     diagnostics: Vec<DefDiagnostic>,\n }\n@@ -237,6 +246,7 @@ impl DefMap {\n             krate,\n             edition,\n             extern_prelude: FxHashMap::default(),\n+            exported_proc_macros: FxHashMap::default(),\n             prelude: None,\n             root,\n             modules,"}, {"sha": "dcedf7766d9c179d810853cca5b11e54bcd61588", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=017dd0b45a5d89eca58458fa7d2cc712019402cc", "patch": "@@ -18,7 +18,6 @@ use hir_expand::{\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n-use tt::{Leaf, TokenTree};\n \n use crate::{\n     attr::Attrs,\n@@ -42,6 +41,8 @@ use crate::{\n     UnresolvedMacro,\n };\n \n+use super::proc_macro::ProcMacroDef;\n+\n const GLOB_RECURSION_LIMIT: usize = 100;\n const EXPANSION_DEPTH_LIMIT: usize = 128;\n const FIXED_POINT_LIMIT: usize = 8192;\n@@ -353,9 +354,9 @@ impl DefCollector<'_> {\n     /// use a dummy expander that always errors. This comes with the drawback of macros potentially\n     /// going out of sync with what the build system sees (since we resolve using VFS state, but\n     /// Cargo builds only on-disk files). We could and probably should add diagnostics for that.\n-    fn resolve_proc_macro(&mut self, name: &Name, ast_id: AstId<ast::Fn>) {\n+    fn export_proc_macro(&mut self, def: ProcMacroDef, ast_id: AstId<ast::Fn>) {\n         self.exports_proc_macros = true;\n-        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == name) {\n+        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n             Some((_, expander)) => MacroDefId {\n                 krate: self.def_map.krate,\n                 kind: MacroDefKind::ProcMacro(*expander, ast_id),\n@@ -368,7 +369,8 @@ impl DefCollector<'_> {\n             },\n         };\n \n-        self.define_proc_macro(name.clone(), macro_def);\n+        self.define_proc_macro(def.name.clone(), macro_def);\n+        self.def_map.exported_proc_macros.insert(macro_def, def);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -1386,26 +1388,9 @@ impl ModCollector<'_, '_> {\n     /// If `attrs` registers a procedural macro, collects its definition.\n     fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n         // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n-        // FIXME: distinguish the type of macro\n-        let macro_name = if attrs.by_key(\"proc_macro\").exists()\n-            || attrs.by_key(\"proc_macro_attribute\").exists()\n-        {\n-            func_name.clone()\n-        } else {\n-            let derive = attrs.by_key(\"proc_macro_derive\");\n-            if let Some(arg) = derive.tt_values().next() {\n-                if let [TokenTree::Leaf(Leaf::Ident(trait_name)), ..] = &*arg.token_trees {\n-                    trait_name.as_name()\n-                } else {\n-                    log::trace!(\"malformed `#[proc_macro_derive]`: {}\", arg);\n-                    return;\n-                }\n-            } else {\n-                return;\n-            }\n-        };\n-\n-        self.def_collector.resolve_proc_macro(&macro_name, ast_id);\n+        if let Some(proc_macro) = attrs.parse_proc_macro_decl(func_name) {\n+            self.def_collector.export_proc_macro(proc_macro, ast_id);\n+        }\n     }\n \n     fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {"}, {"sha": "156598f1951711202d9007cc0d08c8bf26b55c57", "filename": "crates/hir_def/src/nameres/proc_macro.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=017dd0b45a5d89eca58458fa7d2cc712019402cc", "patch": "@@ -0,0 +1,71 @@\n+//! Nameres-specific procedural macro data and helpers.\n+\n+use hir_expand::name::{AsName, Name};\n+use tt::{Leaf, TokenTree};\n+\n+use crate::attr::Attrs;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) struct ProcMacroDef {\n+    pub(super) name: Name,\n+    pub(super) kind: ProcMacroKind,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) enum ProcMacroKind {\n+    CustomDerive { helpers: Box<[Name]> },\n+    FnLike,\n+    Attr,\n+}\n+\n+impl Attrs {\n+    #[rustfmt::skip]\n+    pub(super) fn parse_proc_macro_decl(&self, func_name: &Name) -> Option<ProcMacroDef> {\n+        if self.by_key(\"proc_macro\").exists() {\n+            Some(ProcMacroDef { name: func_name.clone(), kind: ProcMacroKind::FnLike })\n+        } else if self.by_key(\"proc_macro_attribute\").exists() {\n+            Some(ProcMacroDef { name: func_name.clone(), kind: ProcMacroKind::Attr })\n+        } else if self.by_key(\"proc_macro_derive\").exists() {\n+            let derive = self.by_key(\"proc_macro_derive\").tt_values().next().unwrap();\n+\n+            match &*derive.token_trees {\n+                // `#[proc_macro_derive(Trait)]`\n+                [TokenTree::Leaf(Leaf::Ident(trait_name))] => Some(ProcMacroDef {\n+                    name: trait_name.as_name(),\n+                    kind: ProcMacroKind::CustomDerive { helpers: Box::new([]) },\n+                }),\n+\n+                // `#[proc_macro_derive(Trait, attibutes(helper1, helper2, ...))]`\n+                [\n+                    TokenTree::Leaf(Leaf::Ident(trait_name)),\n+                    TokenTree::Leaf(Leaf::Punct(comma)),\n+                    TokenTree::Leaf(Leaf::Ident(attributes)),\n+                    TokenTree::Subtree(helpers)\n+                ] if comma.char == ',' && attributes.text == \"attributes\" =>\n+                {\n+                    let helpers = helpers.token_trees.iter()\n+                        .filter(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Punct(comma)) if comma.char == ','))\n+                        .map(|tt| {\n+                            match tt {\n+                                TokenTree::Leaf(Leaf::Ident(helper)) => Some(helper.as_name()),\n+                                _ => None\n+                            }\n+                        })\n+                        .collect::<Option<Box<[_]>>>()?;\n+\n+                    Some(ProcMacroDef {\n+                        name: trait_name.as_name(),\n+                        kind: ProcMacroKind::CustomDerive { helpers },\n+                    })\n+                }\n+\n+                _ => {\n+                    log::trace!(\"malformed `#[proc_macro_derive]`: {}\", derive);\n+                    None\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "d59d3c0db1dd1b0072e1e828e8970d9ce97c7bfb", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017dd0b45a5d89eca58458fa7d2cc712019402cc/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=017dd0b45a5d89eca58458fa7d2cc712019402cc", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use crate::nameres::proc_macro::{ProcMacroDef, ProcMacroKind};\n \n #[test]\n fn macro_rules_are_globally_visible() {\n@@ -790,3 +791,28 @@ fn proc_macro_censoring() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn collects_derive_helpers() {\n+    let def_map = compute_crate_def_map(\n+        r\"\n+        struct TokenStream;\n+\n+        #[proc_macro_derive(AnotherTrait, attributes(helper_attr))]\n+        pub fn derive_macro_2(_item: TokenStream) -> TokenStream {\n+            TokenStream\n+        }\n+        \",\n+    );\n+\n+    assert_eq!(def_map.exported_proc_macros.len(), 1);\n+    match def_map.exported_proc_macros.values().next() {\n+        Some(ProcMacroDef { kind: ProcMacroKind::CustomDerive { helpers }, .. }) => {\n+            match &**helpers {\n+                [attr] => assert_eq!(attr.to_string(), \"helper_attr\"),\n+                _ => unreachable!(),\n+            }\n+        }\n+        _ => unreachable!(),\n+    }\n+}"}]}