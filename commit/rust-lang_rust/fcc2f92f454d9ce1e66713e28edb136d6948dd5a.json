{"sha": "fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYzJmOTJmNDU0ZDljZTFlNjY3MTNlMjhlZGIxMzZkNjk0OGRkNWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-18T14:36:30Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-23T09:44:05Z"}, "message": "syntax: Return named errors from literal parsing functions", "tree": {"sha": "1a5893ca61d737492851dfba7d3831949333071e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a5893ca61d737492851dfba7d3831949333071e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "html_url": "https://github.com/rust-lang/rust/commit/fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85334c50921a1c90707c9d0fb344c63bd373e1b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/85334c50921a1c90707c9d0fb344c63bd373e1b8", "html_url": "https://github.com/rust-lang/rust/commit/85334c50921a1c90707c9d0fb344c63bd373e1b8"}], "stats": {"total": 300, "additions": 169, "deletions": 131}, "files": [{"sha": "2f75a8c9db57e453f9165f5bb5819aef15c06791", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "patch": "@@ -554,7 +554,7 @@ impl MetaItemKind {\n             Some(TokenTree::Token(_, token::Eq)) => {\n                 tokens.next();\n                 return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n-                    Lit::from_token(&token, span, None).map(MetaItemKind::NameValue)\n+                    Lit::from_token(&token, span).ok().map(MetaItemKind::NameValue)\n                 } else {\n                     None\n                 };\n@@ -599,7 +599,7 @@ impl NestedMetaItem {\n         where I: Iterator<Item = TokenTree>,\n     {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n-            if let Some(lit) = Lit::from_token(&token, span, None) {\n+            if let Ok(lit) = Lit::from_token(&token, span) {\n                 tokens.next();\n                 return Some(NestedMetaItem::Literal(lit));\n             }"}, {"sha": "343aa6bc653baeb31a3467c75cbb8db48a9e77a1", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 140, "deletions": 123, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "patch": "@@ -16,11 +16,64 @@ use syntax_pos::Span;\n \n use std::ascii;\n \n-macro_rules! err {\n-    ($opt_diag:expr, |$span:ident, $diag:ident| $($body:tt)*) => {\n-        match $opt_diag {\n-            Some(($span, $diag)) => { $($body)* }\n-            None => return None,\n+crate enum LitError {\n+    NotLiteral,\n+    LexerError,\n+    InvalidSuffix,\n+    InvalidIntSuffix,\n+    InvalidFloatSuffix,\n+    NonDecimalFloat(&'static str),\n+    IntTooLarge,\n+}\n+\n+impl LitError {\n+    crate fn report(&self, diag: &Handler, lit: token::Lit, suf: Option<Symbol>, span: Span) {\n+        match *self {\n+            LitError::NotLiteral | LitError::LexerError => {}\n+            LitError::InvalidSuffix => {\n+                expect_no_suffix(diag, span, &format!(\"{} {}\", lit.article(), lit.descr()), suf);\n+            }\n+            LitError::InvalidIntSuffix => {\n+                let suf = suf.expect(\"suffix error with no suffix\").as_str();\n+                if looks_like_width_suffix(&['i', 'u'], &suf) {\n+                    // If it looks like a width, try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n+                    diag.struct_span_err(span, &msg)\n+                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n+                        .emit();\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for numeric literal\", suf);\n+                    diag.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"the suffix must be one of the integral types (`u32`, `isize`, etc)\")\n+                        .emit();\n+                }\n+            }\n+            LitError::InvalidFloatSuffix => {\n+                let suf = suf.expect(\"suffix error with no suffix\").as_str();\n+                if looks_like_width_suffix(&['f'], &suf) {\n+                    // If it looks like a width, try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n+                    diag.struct_span_err(span, &msg)\n+                        .help(\"valid widths are 32 and 64\")\n+                        .emit();\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    diag.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"valid suffixes are `f32` and `f64`\")\n+                        .emit();\n+                }\n+            }\n+            LitError::NonDecimalFloat(descr) => {\n+                diag.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n+                    .span_label(span, \"not supported\")\n+                    .emit();\n+            }\n+            LitError::IntTooLarge => {\n+                diag.struct_span_err(span, \"int literal is too large\")\n+                    .emit();\n+            }\n         }\n     }\n }\n@@ -33,15 +86,12 @@ impl LitKind {\n     fn from_lit_token(\n         lit: token::Lit,\n         suf: Option<Symbol>,\n-        diag: Option<(Span, &Handler)>\n-    ) -> Option<LitKind> {\n+    ) -> Result<LitKind, LitError> {\n         if suf.is_some() && !lit.may_have_suffix() {\n-            err!(diag, |span, diag| {\n-                expect_no_suffix(span, diag, &format!(\"a {}\", lit.literal_name()), suf)\n-            });\n+            return Err(LitError::InvalidSuffix);\n         }\n \n-        Some(match lit {\n+        Ok(match lit {\n             token::Bool(i) => {\n                 assert!(i == kw::True || i == kw::False);\n                 LitKind::Bool(i == kw::True)\n@@ -55,33 +105,33 @@ impl LitKind {\n             token::Char(i) => {\n                 match unescape_char(&i.as_str()) {\n                     Ok(c) => LitKind::Char(c),\n-                    Err(_) => LitKind::Err(i),\n+                    Err(_) => return Err(LitError::LexerError),\n                 }\n             },\n             token::Err(i) => LitKind::Err(i),\n \n             // There are some valid suffixes for integer and float literals,\n             // so all the handling is done internally.\n-            token::Integer(s) => return integer_lit(&s.as_str(), suf, diag),\n-            token::Float(s) => return float_lit(&s.as_str(), suf, diag),\n+            token::Integer(s) => return integer_lit(s, suf),\n+            token::Float(s) => return float_lit(s, suf),\n \n             token::Str_(mut sym) => {\n                 // If there are no characters requiring special treatment we can\n                 // reuse the symbol from the Token. Otherwise, we must generate a\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the Token.\n-                let mut has_error = false;\n+                let mut error = None;\n                 let s = &sym.as_str();\n                 if s.as_bytes().iter().any(|&c| c == b'\\\\' || c == b'\\r') {\n                     let mut buf = String::with_capacity(s.len());\n                     unescape_str(s, &mut |_, unescaped_char| {\n                         match unescaped_char {\n                             Ok(c) => buf.push(c),\n-                            Err(_) => has_error = true,\n+                            Err(_) => error = Some(LitError::LexerError),\n                         }\n                     });\n-                    if has_error {\n-                        return Some(LitKind::Err(sym));\n+                    if let Some(error) = error {\n+                        return Err(error);\n                     }\n                     sym = Symbol::intern(&buf)\n                 }\n@@ -99,15 +149,15 @@ impl LitKind {\n             token::ByteStr(i) => {\n                 let s = &i.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n-                let mut has_error = false;\n+                let mut error = None;\n                 unescape_byte_str(s, &mut |_, unescaped_byte| {\n                     match unescaped_byte {\n                         Ok(c) => buf.push(c),\n-                        Err(_) => has_error = true,\n+                        Err(_) => error = Some(LitError::LexerError),\n                     }\n                 });\n-                if has_error {\n-                    return Some(LitKind::Err(i));\n+                if let Some(error) = error {\n+                    return Err(error);\n                 }\n                 buf.shrink_to_fit();\n                 LitKind::ByteStr(Lrc::new(buf))\n@@ -165,33 +215,40 @@ impl LitKind {\n }\n \n impl Lit {\n+    fn from_lit_token(\n+        token: token::Lit,\n+        suffix: Option<Symbol>,\n+        span: Span,\n+    ) -> Result<Lit, LitError> {\n+        let node = LitKind::from_lit_token(token, suffix)?;\n+        Ok(Lit { node, token, suffix, span })\n+    }\n+\n     /// Converts literal token with a suffix into an AST literal.\n     /// Works speculatively and may return `None` if diagnostic handler is not passed.\n     /// If diagnostic handler is passed, may return `Some`,\n     /// possibly after reporting non-fatal errors and recovery, or `None` for irrecoverable errors.\n     crate fn from_token(\n         token: &token::Token,\n         span: Span,\n-        diag: Option<(Span, &Handler)>,\n-    ) -> Option<Lit> {\n-        let (token, suffix) = match *token {\n+    ) -> Result<Lit, LitError> {\n+        let (lit, suf) = match *token {\n             token::Ident(ident, false) if ident.name == kw::True || ident.name == kw::False =>\n                 (token::Bool(ident.name), None),\n             token::Literal(token, suffix) =>\n                 (token, suffix),\n             token::Interpolated(ref nt) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n                     if let ast::ExprKind::Lit(lit) = &expr.node {\n-                        return Some(lit.clone());\n+                        return Ok(lit.clone());\n                     }\n                 }\n-                return None;\n+                return Err(LitError::NotLiteral);\n             }\n-            _ => return None,\n+            _ => return Err(LitError::NotLiteral)\n         };\n \n-        let node = LitKind::from_lit_token(token, suffix, diag)?;\n-        Some(Lit { node, token, suffix, span })\n+        Lit::from_lit_token(lit, suf, span)\n     }\n \n     /// Attempts to recover an AST literal from semantic literal.\n@@ -215,13 +272,10 @@ impl Lit {\n impl<'a> Parser<'a> {\n     /// Matches `lit = true | false | token_lit`.\n     crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        let diag = Some((self.span, &self.sess.span_diagnostic));\n-        if let Some(lit) = Lit::from_token(&self.token, self.span, diag) {\n-            self.bump();\n-            return Ok(lit);\n-        } else if self.token == token::Dot {\n-            // Recover `.4` as `0.4`.\n-            let recovered = self.look_ahead(1, |t| {\n+        let mut recovered = None;\n+        if self.token == token::Dot {\n+            // Attempt to recover `.4` as `0.4`.\n+            recovered = self.look_ahead(1, |t| {\n                 if let token::Literal(token::Integer(val), suf) = *t {\n                     let next_span = self.look_ahead_span(1);\n                     if self.span.hi() == next_span.lo() {\n@@ -232,7 +286,7 @@ impl<'a> Parser<'a> {\n                 }\n                 None\n             });\n-            if let Some((token, span)) = recovered {\n+            if let Some((ref token, span)) = recovered {\n                 self.diagnostic()\n                     .struct_span_err(span, \"float literals must have an integer part\")\n                     .span_suggestion(\n@@ -242,27 +296,37 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     )\n                     .emit();\n-                let diag = Some((span, &self.sess.span_diagnostic));\n-                if let Some(lit) = Lit::from_token(&token, span, diag) {\n-                    self.bump();\n-                    self.bump();\n-                    return Ok(lit);\n-                }\n+                self.bump();\n             }\n         }\n \n-        Err(self.span_fatal(self.span, &format!(\"unexpected token: {}\", self.this_token_descr())))\n+        let (token, span) = recovered.as_ref().map_or((&self.token, self.span),\n+                                                      |(token, span)| (token, *span));\n+\n+        match Lit::from_token(token, span) {\n+            Ok(lit) => {\n+                self.bump();\n+                return Ok(lit);\n+            }\n+            Err(LitError::NotLiteral) => {\n+                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+                return Err(self.span_fatal(span, &msg));\n+            }\n+            Err(err) => {\n+                let (lit, suf) = token.expect_lit();\n+                self.bump();\n+                err.report(&self.sess.span_diagnostic, lit, suf, span);\n+                return Ok(Lit::from_lit_token(token::Err(lit.symbol()), suf, span).ok().unwrap());\n+            }\n+        }\n     }\n }\n \n-crate fn expect_no_suffix(sp: Span, diag: &Handler, kind: &str, suffix: Option<ast::Name>) {\n+crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n     match suffix {\n         None => {/* everything ok */}\n         Some(suf) => {\n             let text = suf.as_str();\n-            if text.is_empty() {\n-                diag.span_bug(sp, \"found empty literal suffix in Some\")\n-            }\n             let mut err = if kind == \"a tuple index\" &&\n                 [\"i32\", \"u32\", \"isize\", \"usize\"].contains(&text.to_string().as_str())\n             {\n@@ -318,64 +382,51 @@ fn raw_str_lit(lit: &str) -> String {\n     res\n }\n \n-// check if `s` looks like i32 or u1234 etc.\n+// Checks if `s` looks like i32 or u1234 etc.\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n-    s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n+    s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n }\n \n-fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                      -> Option<LitKind> {\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     let suffix = match suffix {\n         Some(suffix) => suffix,\n-        None => return Some(LitKind::FloatUnsuffixed(data)),\n+        None => return Ok(LitKind::FloatUnsuffixed(data)),\n     };\n \n-    Some(match &*suffix.as_str() {\n+    Ok(match &*suffix.as_str() {\n         \"f32\" => LitKind::Float(data, ast::FloatTy::F32),\n         \"f64\" => LitKind::Float(data, ast::FloatTy::F64),\n-        suf => {\n-            err!(diag, |span, diag| {\n-                if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n-                    // if it looks like a width, lets try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n-                    diag.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit()\n-                } else {\n-                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n-                    diag.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                        .help(\"valid suffixes are `f32` and `f64`\")\n-                        .emit();\n-                }\n-            });\n-\n-            LitKind::FloatUnsuffixed(data)\n-        }\n+        _ => return Err(LitError::InvalidFloatSuffix),\n     })\n }\n-fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                 -> Option<LitKind> {\n+\n+fn float_lit(s: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n \n     // Strip underscores without allocating a new String unless necessary.\n     let s2;\n+    let s = s.as_str();\n+    let s = s.get();\n     let s = if s.chars().any(|c| c == '_') {\n         s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n         &s2\n     } else {\n         s\n     };\n \n-    filtered_float_lit(Symbol::intern(s), suffix, diag)\n+    filtered_float_lit(Symbol::intern(s), suffix)\n }\n \n-fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                   -> Option<LitKind> {\n+fn integer_lit(s: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n     // s can only be ascii, byte indexing is fine\n \n     // Strip underscores without allocating a new String unless necessary.\n     let s2;\n+    let orig = s;\n+    let s = s.as_str();\n+    let s = s.get();\n     let mut s = if s.chars().any(|c| c == '_') {\n         s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n         &s2\n@@ -386,7 +437,6 @@ fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n     debug!(\"integer_lit: {}, {:?}\", s, suffix);\n \n     let mut base = 10;\n-    let orig = s;\n     let mut ty = ast::LitIntType::Unsuffixed;\n \n     if s.starts_with('0') && s.len() > 1 {\n@@ -402,19 +452,15 @@ fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n     if let Some(suf) = suffix {\n         if looks_like_width_suffix(&['f'], &suf.as_str()) {\n             let err = match base {\n-                16 => Some(\"hexadecimal float literal is not supported\"),\n-                8 => Some(\"octal float literal is not supported\"),\n-                2 => Some(\"binary float literal is not supported\"),\n+                16 => Some(LitError::NonDecimalFloat(\"hexadecimal\")),\n+                8 => Some(LitError::NonDecimalFloat(\"octal\")),\n+                2 => Some(LitError::NonDecimalFloat(\"binary\")),\n                 _ => None,\n             };\n             if let Some(err) = err {\n-                err!(diag, |span, diag| {\n-                    diag.struct_span_err(span, err)\n-                        .span_label(span, \"not supported\")\n-                        .emit();\n-                });\n+                return Err(err);\n             }\n-            return filtered_float_lit(Symbol::intern(s), Some(suf), diag)\n+            return filtered_float_lit(Symbol::intern(s), Some(suf))\n         }\n     }\n \n@@ -423,9 +469,6 @@ fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n     }\n \n     if let Some(suf) = suffix {\n-        if suf.as_str().is_empty() {\n-            err!(diag, |span, diag| diag.span_bug(span, \"found empty literal suffix in Some\"));\n-        }\n         ty = match &*suf.as_str() {\n             \"isize\" => ast::LitIntType::Signed(ast::IntTy::Isize),\n             \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n@@ -439,48 +482,22 @@ fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n             \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n-            suf => {\n-                // i<digits> and u<digits> look like widths, so lets\n-                // give an error message along those lines\n-                err!(diag, |span, diag| {\n-                    if looks_like_width_suffix(&['i', 'u'], suf) {\n-                        let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n-                        diag.struct_span_err(span, &msg)\n-                            .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                            .emit();\n-                    } else {\n-                        let msg = format!(\"invalid suffix `{}` for numeric literal\", suf);\n-                        diag.struct_span_err(span, &msg)\n-                            .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                            .help(\"the suffix must be one of the integral types \\\n-                                   (`u32`, `isize`, etc)\")\n-                            .emit();\n-                    }\n-                });\n-\n-                ty\n-            }\n+            _ => return Err(LitError::InvalidIntSuffix),\n         }\n     }\n \n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    Some(match u128::from_str_radix(s, base) {\n+    Ok(match u128::from_str_radix(s, base) {\n         Ok(r) => LitKind::Int(r, ty),\n         Err(_) => {\n-            // small bases are lexed as if they were base 10, e.g, the string\n+            // Small bases are lexed as if they were base 10, e.g, the string\n             // might be `0b10201`. This will cause the conversion above to fail,\n-            // but these cases have errors in the lexer: we don't want to emit\n-            // two errors, and we especially don't want to emit this error since\n-            // it isn't necessarily true.\n-            let already_errored = base < 10 &&\n-                s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n-\n-            if !already_errored {\n-                err!(diag, |span, diag| diag.span_err(span, \"int literal is too large\"));\n-            }\n-            LitKind::Int(0, ty)\n+            // but these kinds of errors are already reported by the lexer.\n+            let from_lexer =\n+                base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+            return Err(if from_lexer { LitError::LexerError } else { LitError::IntTooLarge });\n         }\n     })\n }"}, {"sha": "3d82344ac1e54f4889f253173287563b31238d8b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "patch": "@@ -1054,7 +1054,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n-        literal::expect_no_suffix(sp, &self.sess.span_diagnostic, kind, suffix)\n+        literal::expect_no_suffix(&self.sess.span_diagnostic, sp, kind, suffix)\n     }\n \n     /// Attempts to consume a `<`. If `<<` is seen, replaces it with a single"}, {"sha": "f089fc024fecfded6ee51f9fc2b74b40e8565f2c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "patch": "@@ -77,7 +77,21 @@ pub enum Lit {\n static_assert_size!(Lit, 8);\n \n impl Lit {\n-    crate fn literal_name(&self) -> &'static str {\n+    crate fn symbol(&self) -> Symbol {\n+        match *self {\n+            Bool(s) | Byte(s) | Char(s) | Integer(s) | Float(s) | Err(s) |\n+            Str_(s) | StrRaw(s, _) | ByteStr(s) | ByteStrRaw(s, _) => s\n+        }\n+    }\n+\n+    crate fn article(&self) -> &'static str {\n+        match *self {\n+            Integer(_) | Err(_) => \"an\",\n+            _ => \"a\",\n+        }\n+    }\n+\n+    crate fn descr(&self) -> &'static str {\n         match *self {\n             Bool(_) => panic!(\"literal token contains `Lit::Bool`\"),\n             Byte(_) => \"byte literal\",\n@@ -92,7 +106,7 @@ impl Lit {\n \n     crate fn may_have_suffix(&self) -> bool {\n         match *self {\n-            Integer(..) | Float(..) => true,\n+            Integer(..) | Float(..) | Err(..) => true,\n             _ => false,\n         }\n     }\n@@ -318,6 +332,13 @@ impl Token {\n         }\n     }\n \n+    crate fn expect_lit(&self) -> (Lit, Option<Symbol>) {\n+        match *self {\n+            Literal(lit, suf) => (lit, suf),\n+            _=> panic!(\"`expect_lit` called on non-literal\"),\n+        }\n+    }\n+\n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,\n     /// for example a '-42', or one of the boolean idents).\n     crate fn can_begin_literal_or_bool(&self) -> bool {"}, {"sha": "88574ba6f922c2771a45c25444fb06d2cbf4d1af", "filename": "src/test/ui/parser/no-hex-float-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.rs?ref=fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     0x567.89;\n     //~^ ERROR hexadecimal float literal is not supported\n     0xDEAD.BEEFp-2f;\n-    //~^ ERROR invalid suffix `f` for float literal\n+    //~^ ERROR invalid suffix `f` for integer literal\n     //~| ERROR `{integer}` is a primitive type and therefore doesn't have fields\n }"}, {"sha": "48041f34838ccbf1e723438d472cd91ba5bd2e0e", "filename": "src/test/ui/parser/no-hex-float-literal.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc2f92f454d9ce1e66713e28edb136d6948dd5a/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.stderr?ref=fcc2f92f454d9ce1e66713e28edb136d6948dd5a", "patch": "@@ -4,13 +4,13 @@ error: hexadecimal float literal is not supported\n LL |     0x567.89;\n    |     ^^^^^^^^\n \n-error: invalid suffix `f` for float literal\n+error: invalid suffix `f` for integer literal\n   --> $DIR/no-hex-float-literal.rs:6:18\n    |\n LL |     0xDEAD.BEEFp-2f;\n    |                  ^^ invalid suffix `f`\n    |\n-   = help: valid suffixes are `f32` and `f64`\n+   = help: the suffix must be one of the integral types (`u32`, `isize`, etc)\n \n error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n   --> $DIR/no-hex-float-literal.rs:2:11"}]}