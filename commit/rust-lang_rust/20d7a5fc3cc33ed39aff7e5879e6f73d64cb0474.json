{"sha": "20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZDdhNWZjM2NjMzNlZDM5YWZmN2U1ODc5ZTZmNzNkNjRjYjA0NzQ=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-15T16:54:35Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-22T19:11:43Z"}, "message": "Make bitv's APIs match RFC + fixup", "tree": {"sha": "5c16926b6de40ac2dcabb12e34e69a6cef7b3994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c16926b6de40ac2dcabb12e34e69a6cef7b3994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474", "html_url": "https://github.com/rust-lang/rust/commit/20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24329d72935c2753454e2187e632579c2405b6fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/24329d72935c2753454e2187e632579c2405b6fc", "html_url": "https://github.com/rust-lang/rust/commit/24329d72935c2753454e2187e632579c2405b6fc"}], "stats": {"total": 84, "additions": 26, "deletions": 58}, "files": [{"sha": "f50e13c1b3c0a44ffc790765f7e3145a661a5942", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 26, "deletions": 58, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=20d7a5fc3cc33ed39aff7e5879e6f73d64cb0474", "patch": "@@ -91,7 +91,7 @@ use core::num::Int;\n use core::slice::{Items, MutItems};\n use core::{u8, u32, uint};\n \n-use hash;\n+use core::hash;\n use Vec;\n \n type Blocks<'a> = Cloned<Items<'a, u32>>;\n@@ -922,7 +922,7 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n \n /// Deprecated: Now a static method on Bitv.\n #[deprecated = \"Now a static method on Bitv\"]\n-pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n+pub fn from_fn<F>(len: uint, f: F) -> Bitv where F: FnMut(uint) -> bool {\n     Bitv::from_fn(len, f)\n }\n \n@@ -1226,55 +1226,53 @@ impl BitvSet {\n         self.bitv.capacity()\n     }\n \n-    /// Reserves capacity for an element to be inserted at `index` in the given\n-    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Reserves capacity for the given `BitvSet` to contain `len` distinct elements. In the case\n+    /// of `BitvSet` this means reallocations will not occur as long as all inserted elements\n+    /// are less than `len`.\n     ///\n-    /// # Panics\n+    /// The collection may reserve more space to avoid frequent reallocations.\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n     ///\n     /// let mut s = BitvSet::new();\n-    /// s.reserve_index(10);\n-    /// assert!(s.capacity() >= 11);\n+    /// s.reserve_len(10);\n+    /// assert!(s.capacity() >= 10);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve_index(&mut self, index: uint) {\n-        let len = self.bitv.len();\n-        if index >= len {\n-            self.bitv.reserve(index - len + 1);\n+    pub fn reserve_len(&mut self, len: uint) {\n+        let cur_len = self.bitv.len();\n+        if len >= cur_len {\n+            self.bitv.reserve(len - cur_len);\n         }\n     }\n \n-    /// Reserves the minimum capacity for an element to be inserted at `index`\n-    /// in the given `BitvSet`. Does nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for the given `BitvSet` to contain `len` distinct elements.\n+    /// In the case of `BitvSet` this means reallocations will not occur as long as all inserted\n+    /// elements are less than `len`.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve_index` if future\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve_len` if future\n     /// insertions are expected.\n     ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n     ///\n     /// let mut s = BitvSet::new();\n-    /// s.reserve_index_exact(10);\n-    /// assert!(s.capacity() >= 11);\n+    /// s.reserve_len_exact(10);\n+    /// assert!(s.capacity() >= 10);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve_index_exact(&mut self, index: uint) {\n-        let len = self.bitv.len();\n-        if index >= len {\n-            self.bitv.reserve_exact(index - len + 1);\n+    pub fn reserve_len_exact(&mut self, len: uint) {\n+        let cur_len = self.bitv.len();\n+        if len >= cur_len {\n+            self.bitv.reserve_exact(len - cur_len);\n         }\n     }\n \n@@ -2233,35 +2231,6 @@ mod tests {\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }\n \n-    #[test]\n-    fn test_bitv_set_iterator() {\n-        let bools = [true, false, true, true];\n-        let bitv: BitvSet = bools.iter().map(|n| *n).collect();\n-\n-        let idxs: Vec<uint> = bitv.iter().collect();\n-        assert_eq!(idxs, vec!(0, 2, 3));\n-\n-        let long: BitvSet = range(0u, 10000).map(|n| n % 2 == 0).collect();\n-        let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n-\n-        let idxs: Vec<uint> = long.iter().collect();\n-        assert_eq!(idxs, real);\n-    }\n-\n-    #[test]\n-    fn test_bitv_set_frombitv_init() {\n-        let bools = [true, false];\n-        let lengths = [10, 64, 100];\n-        for &b in bools.iter() {\n-            for &l in lengths.iter() {\n-                let bitset = BitvSet::from_bitv(Bitv::with_capacity(l, b));\n-                assert_eq!(bitset.contains(&1u), b);\n-                assert_eq!(bitset.contains(&(l-1u)), b);\n-                assert!(!bitset.contains(&l))\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn test_small_difference() {\n         let mut b1 = Bitv::from_elem(3, false);\n@@ -2587,11 +2556,10 @@ mod bitv_bench {\n \n #[cfg(test)]\n mod bitv_set_test {\n-    use std::prelude::*;\n+    use prelude::*;\n     use std::iter::range_step;\n \n     use super::{Bitv, BitvSet};\n-    use vec::Vec;\n \n     #[test]\n     fn test_bitv_set_show() {\n@@ -2636,9 +2604,9 @@ mod bitv_set_test {\n         for &b in bools.iter() {\n             for &l in lengths.iter() {\n                 let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n-                assert_eq!(bitset.contains(&1u), b)\n-                assert_eq!(bitset.contains(&(l-1u)), b)\n-                assert!(!bitset.contains(&l))\n+                assert_eq!(bitset.contains(&1u), b);\n+                assert_eq!(bitset.contains(&(l-1u)), b);\n+                assert!(!bitset.contains(&l));\n             }\n         }\n     }"}]}