{"sha": "2d91939bb7130a8e6c092a290b7d37f654e3c23c", "node_id": "C_kwDOAAsO6NoAKDJkOTE5MzliYjcxMzBhOGU2YzA5MmEyOTBiN2QzN2Y2NTRlM2MyM2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-13T10:18:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-13T10:18:48Z"}, "message": "Auto merge of #107634 - scottmcm:array-drain, r=thomcc\n\nImprove the `array::map` codegen\n\nThe `map` method on arrays [is documented as sometimes performing poorly](https://doc.rust-lang.org/std/primitive.array.html#note-on-performance-and-stack-usage), and after [a question on URLO](https://users.rust-lang.org/t/try-trait-residual-o-trait-and-try-collect-into-array/88510?u=scottmcm) prompted me to take another look at the core [`try_collect_into_array`](https://github.com/rust-lang/rust/blob/7c46fb2111936ad21a8e3aa41e9128752357f5d8/library/core/src/array/mod.rs#L865-L912) function, I had some ideas that ended up working better than I'd expected.\n\nThere's three main ideas in here, split over three commits:\n1. Don't use `array::IntoIter` when we can avoid it, since that seems to not get SRoA'd, meaning that every step writes things like loop counters into the stack unnecessarily\n2. Don't return arrays in `Result`s unnecessarily, as that doesn't seem to optimize away even with `unwrap_unchecked` (perhaps because it needs to get moved into a new LLVM type to account for the discriminant)\n3. Don't distract LLVM with all the `Option` dances when we know for sure we have enough items (like in `map` and `zip`).  This one's a larger commit as to do it I ended up adding a new `pub(crate)` trait, but hopefully those changes are still straight-forward.\n\n(No libs-api changes; everything should be completely implementation-detail-internal.)\n\nIt's still not completely fixed -- I think it needs pcwalton's `memcpy` optimizations still (#103830) to get further -- but this seems to go much better than before.  And the remaining `memcpy`s are just `transmute`-equivalent (`[T; N] -> ManuallyDrop<[T; N]>` and `[MaybeUninit<T>; N] -> [T; N]`), so hopefully those will be easier to remove with LLVM16 than the previous subobject copies \ud83e\udd1e\n\nr? `@thomcc`\n\nAs a simple example, this test\n```rust\npub fn long_integer_map(x: [u32; 64]) -> [u32; 64] {\n    x.map(|x| 13 * x + 7)\n}\n```\nOn nightly <https://rust.godbolt.org/z/xK7548TGj> takes `sub rsp, 808`\n```llvm\nstart:\n  %array.i.i.i.i = alloca [64 x i32], align 4\n  %_3.sroa.5.i.i.i = alloca [65 x i32], align 4\n  %_5.i = alloca %\"core::iter::adapters::map::Map<core::array::iter::IntoIter<u32, 64>, [closure@/app/example.rs:2:11: 2:14]>\", align 8\n```\n(and yes, that's a 6**5**-element array `alloca` despite 6**4**-element input and output)\n\nBut with this PR it's only `sub rsp, 520`\n```llvm\nstart:\n  %array.i.i.i.i.i.i = alloca [64 x i32], align 4\n  %array1.i.i.i = alloca %\"core::mem::manually_drop::ManuallyDrop<[u32; 64]>\", align 4\n```\n\nSimilarly, the loop it emits on nightly is scalar-only and horrifying\n```nasm\n.LBB0_1:\n        mov     esi, 64\n        mov     edi, 0\n        cmp     rdx, 64\n        je      .LBB0_3\n        lea     rsi, [rdx + 1]\n        mov     qword ptr [rsp + 784], rsi\n        mov     r8d, dword ptr [rsp + 4*rdx + 528]\n        mov     edi, 1\n        lea     edx, [r8 + 2*r8]\n        lea     r8d, [r8 + 4*rdx]\n        add     r8d, 7\n.LBB0_3:\n        test    edi, edi\n        je      .LBB0_11\n        mov     dword ptr [rsp + 4*rcx + 272], r8d\n        cmp     rsi, 64\n        jne     .LBB0_6\n        xor     r8d, r8d\n        mov     edx, 64\n        test    r8d, r8d\n        jne     .LBB0_8\n        jmp     .LBB0_11\n.LBB0_6:\n        lea     rdx, [rsi + 1]\n        mov     qword ptr [rsp + 784], rdx\n        mov     edi, dword ptr [rsp + 4*rsi + 528]\n        mov     r8d, 1\n        lea     esi, [rdi + 2*rdi]\n        lea     edi, [rdi + 4*rsi]\n        add     edi, 7\n        test    r8d, r8d\n        je      .LBB0_11\n.LBB0_8:\n        mov     dword ptr [rsp + 4*rcx + 276], edi\n        add     rcx, 2\n        cmp     rcx, 64\n        jne     .LBB0_1\n```\n\nwhereas with this PR it's unrolled and vectorized\n```nasm\n\tvpmulld\tymm1, ymm0, ymmword ptr [rsp + 64]\n\tvpaddd\tymm1, ymm1, ymm2\n\tvmovdqu\tymmword ptr [rsp + 328], ymm1\n\tvpmulld\tymm1, ymm0, ymmword ptr [rsp + 96]\n\tvpaddd\tymm1, ymm1, ymm2\n\tvmovdqu\tymmword ptr [rsp + 360], ymm1\n```\n(though sadly still stack-to-stack)", "tree": {"sha": "dff12eb677ee849041903b887126bab1b193ba3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dff12eb677ee849041903b887126bab1b193ba3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d91939bb7130a8e6c092a290b7d37f654e3c23c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d91939bb7130a8e6c092a290b7d37f654e3c23c", "html_url": "https://github.com/rust-lang/rust/commit/2d91939bb7130a8e6c092a290b7d37f654e3c23c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d91939bb7130a8e6c092a290b7d37f654e3c23c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20081880ad2a98bbc8c8293f96c5b284d1584d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/20081880ad2a98bbc8c8293f96c5b284d1584d86", "html_url": "https://github.com/rust-lang/rust/commit/20081880ad2a98bbc8c8293f96c5b284d1584d86"}, {"sha": "bb77860d9ccdc6a920edeedce313446545294c04", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb77860d9ccdc6a920edeedce313446545294c04", "html_url": "https://github.com/rust-lang/rust/commit/bb77860d9ccdc6a920edeedce313446545294c04"}], "stats": {"total": 537, "additions": 395, "deletions": 142}, "files": [{"sha": "5fadf907b6219cdf25be26364fc41e1c86b70f84", "filename": "library/core/src/array/drain.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -0,0 +1,76 @@\n+use crate::iter::{TrustedLen, UncheckedIterator};\n+use crate::mem::ManuallyDrop;\n+use crate::ptr::drop_in_place;\n+use crate::slice;\n+\n+/// A situationally-optimized version of `array.into_iter().for_each(func)`.\n+///\n+/// [`crate::array::IntoIter`]s are great when you need an owned iterator, but\n+/// storing the entire array *inside* the iterator like that can sometimes\n+/// pessimize code.  Notable, it can be more bytes than you really want to move\n+/// around, and because the array accesses index into it SRoA has a harder time\n+/// optimizing away the type than it does iterators that just hold a couple pointers.\n+///\n+/// Thus this function exists, which gives a way to get *moved* access to the\n+/// elements of an array using a small iterator -- no bigger than a slice iterator.\n+///\n+/// The function-taking-a-closure structure makes it safe, as it keeps callers\n+/// from looking at already-dropped elements.\n+pub(crate) fn drain_array_with<T, R, const N: usize>(\n+    array: [T; N],\n+    func: impl for<'a> FnOnce(Drain<'a, T>) -> R,\n+) -> R {\n+    let mut array = ManuallyDrop::new(array);\n+    // SAFETY: Now that the local won't drop it, it's ok to construct the `Drain` which will.\n+    let drain = Drain(array.iter_mut());\n+    func(drain)\n+}\n+\n+/// See [`drain_array_with`] -- this is `pub(crate)` only so it's allowed to be\n+/// mentioned in the signature of that method.  (Otherwise it hits `E0446`.)\n+// INVARIANT: It's ok to drop the remainder of the inner iterator.\n+pub(crate) struct Drain<'a, T>(slice::IterMut<'a, T>);\n+\n+impl<T> Drop for Drain<'_, T> {\n+    fn drop(&mut self) {\n+        // SAFETY: By the type invariant, we're allowed to drop all these.\n+        unsafe { drop_in_place(self.0.as_mut_slice()) }\n+    }\n+}\n+\n+impl<T> Iterator for Drain<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        let p: *const T = self.0.next()?;\n+        // SAFETY: The iterator was already advanced, so we won't drop this later.\n+        Some(unsafe { p.read() })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.len();\n+        (n, Some(n))\n+    }\n+}\n+\n+impl<T> ExactSizeIterator for Drain<'_, T> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+}\n+\n+// SAFETY: This is a 1:1 wrapper for a slice iterator, which is also `TrustedLen`.\n+unsafe impl<T> TrustedLen for Drain<'_, T> {}\n+\n+impl<T> UncheckedIterator for Drain<'_, T> {\n+    unsafe fn next_unchecked(&mut self) -> T {\n+        // SAFETY: `Drain` is 1:1 with the inner iterator, so if the caller promised\n+        // that there's an element left, the inner iterator has one too.\n+        let p: *const T = unsafe { self.0.next_unchecked() };\n+        // SAFETY: The iterator was already advanced, so we won't drop this later.\n+        unsafe { p.read() }\n+    }\n+}"}, {"sha": "1643842d60756c29f0bace16942acbfcc3ebf2cc", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 129, "deletions": 127, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -10,16 +10,19 @@ use crate::convert::{Infallible, TryFrom};\n use crate::error::Error;\n use crate::fmt;\n use crate::hash::{self, Hash};\n-use crate::iter::TrustedLen;\n+use crate::iter::UncheckedIterator;\n use crate::mem::{self, MaybeUninit};\n use crate::ops::{\n     ChangeOutputType, ControlFlow, FromResidual, Index, IndexMut, NeverShortCircuit, Residual, Try,\n };\n use crate::slice::{Iter, IterMut};\n \n+mod drain;\n mod equality;\n mod iter;\n \n+pub(crate) use drain::drain_array_with;\n+\n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n pub use iter::IntoIter;\n \n@@ -52,16 +55,11 @@ pub use iter::IntoIter;\n /// ```\n #[inline]\n #[stable(feature = \"array_from_fn\", since = \"1.63.0\")]\n-pub fn from_fn<T, const N: usize, F>(mut cb: F) -> [T; N]\n+pub fn from_fn<T, const N: usize, F>(cb: F) -> [T; N]\n where\n     F: FnMut(usize) -> T,\n {\n-    let mut idx = 0;\n-    [(); N].map(|_| {\n-        let res = cb(idx);\n-        idx += 1;\n-        res\n-    })\n+    try_from_fn(NeverShortCircuit::wrap_mut_1(cb)).0\n }\n \n /// Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n@@ -101,9 +99,14 @@ where\n     R: Try,\n     R::Residual: Residual<[R::Output; N]>,\n {\n-    // SAFETY: we know for certain that this iterator will yield exactly `N`\n-    // items.\n-    unsafe { try_collect_into_array_unchecked(&mut (0..N).map(cb)) }\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    match try_from_fn_erased(&mut array, cb) {\n+        ControlFlow::Break(r) => FromResidual::from_residual(r),\n+        ControlFlow::Continue(()) => {\n+            // SAFETY: All elements of the array were populated.\n+            try { unsafe { MaybeUninit::array_assume_init(array) } }\n+        }\n+    }\n }\n \n /// Converts a reference to `T` into a reference to an array of length 1 (without copying).\n@@ -414,9 +417,7 @@ trait SpecArrayClone: Clone {\n impl<T: Clone> SpecArrayClone for T {\n     #[inline]\n     default fn clone<const N: usize>(array: &[T; N]) -> [T; N] {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut array.iter().cloned()) }\n+        from_trusted_iterator(array.iter().cloned())\n     }\n }\n \n@@ -500,9 +501,7 @@ impl<T, const N: usize> [T; N] {\n     where\n         F: FnMut(T) -> U,\n     {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n+        self.try_map(NeverShortCircuit::wrap_mut_1(f)).0\n     }\n \n     /// A fallible function `f` applied to each element on array `self` in order to\n@@ -539,9 +538,7 @@ impl<T, const N: usize> [T; N] {\n         R: Try,\n         R::Residual: Residual<[R::Output; N]>,\n     {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { try_collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n+        drain_array_with(self, |iter| try_from_trusted_iterator(iter.map(f)))\n     }\n \n     /// 'Zips up' two arrays into a single array of pairs.\n@@ -562,11 +559,9 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        let mut iter = IntoIterator::into_iter(self).zip(rhs);\n-\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut iter) }\n+        drain_array_with(self, |lhs| {\n+            drain_array_with(rhs, |rhs| from_trusted_iterator(crate::iter::zip(lhs, rhs)))\n+        })\n     }\n \n     /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n@@ -613,9 +608,7 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_ref(&self) -> [&T; N] {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut self.iter()) }\n+        from_trusted_iterator(self.iter())\n     }\n \n     /// Borrows each element mutably and returns an array of mutable references\n@@ -635,9 +628,7 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_mut(&mut self) -> [&mut T; N] {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut self.iter_mut()) }\n+        from_trusted_iterator(self.iter_mut())\n     }\n \n     /// Divides one array reference into two at an index.\n@@ -797,105 +788,71 @@ impl<T, const N: usize> [T; N] {\n     }\n }\n \n-/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n-/// yields fewer than `N` items, this function exhibits undefined behavior.\n-///\n-/// See [`try_collect_into_array`] for more information.\n+/// Populate an array from the first `N` elements of `iter`\n ///\n+/// # Panics\n ///\n-/// # Safety\n+/// If the iterator doesn't actually have enough items.\n ///\n-/// It is up to the caller to guarantee that `iter` yields at least `N` items.\n-/// Violating this condition causes undefined behavior.\n-unsafe fn try_collect_into_array_unchecked<I, T, R, const N: usize>(iter: &mut I) -> R::TryType\n-where\n-    // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n-    // internal function, so feel free to remove if this bound turns out to be a\n-    // bad idea. In that case, remember to also remove the lower bound\n-    // `debug_assert!` below!\n-    I: Iterator + TrustedLen,\n-    I::Item: Try<Output = T, Residual = R>,\n-    R: Residual<[T; N]>,\n-{\n-    debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n-    debug_assert!(N <= iter.size_hint().0);\n-\n-    // SAFETY: covered by the function contract.\n-    unsafe { try_collect_into_array(iter).unwrap_unchecked() }\n+/// By depending on `TrustedLen`, however, we can do that check up-front (where\n+/// it easily optimizes away) so it doesn't impact the loop that fills the array.\n+#[inline]\n+fn from_trusted_iterator<T, const N: usize>(iter: impl UncheckedIterator<Item = T>) -> [T; N] {\n+    try_from_trusted_iterator(iter.map(NeverShortCircuit)).0\n }\n \n-// Infallible version of `try_collect_into_array_unchecked`.\n-unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+#[inline]\n+fn try_from_trusted_iterator<T, R, const N: usize>(\n+    iter: impl UncheckedIterator<Item = R>,\n+) -> ChangeOutputType<R, [T; N]>\n where\n-    I: Iterator + TrustedLen,\n+    R: Try<Output = T>,\n+    R::Residual: Residual<[T; N]>,\n {\n-    let mut map = iter.map(NeverShortCircuit);\n-\n-    // SAFETY: The same safety considerations w.r.t. the iterator length\n-    // apply for `try_collect_into_array_unchecked` as for\n-    // `collect_into_array_unchecked`\n-    match unsafe { try_collect_into_array_unchecked(&mut map) } {\n-        NeverShortCircuit(array) => array,\n+    assert!(iter.size_hint().0 >= N);\n+    fn next<T>(mut iter: impl UncheckedIterator<Item = T>) -> impl FnMut(usize) -> T {\n+        move |_| {\n+            // SAFETY: We know that `from_fn` will call this at most N times,\n+            // and we checked to ensure that we have at least that many items.\n+            unsafe { iter.next_unchecked() }\n+        }\n     }\n+\n+    try_from_fn(next(iter))\n }\n \n-/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n-/// yields fewer than `N` items, `Err` is returned containing an iterator over\n-/// the already yielded items.\n+/// Version of [`try_from_fn`] using a passed-in slice in order to avoid\n+/// needing to monomorphize for every array length.\n ///\n-/// Since the iterator is passed as a mutable reference and this function calls\n-/// `next` at most `N` times, the iterator can still be used afterwards to\n-/// retrieve the remaining items.\n+/// This takes a generator rather than an iterator so that *at the type level*\n+/// it never needs to worry about running out of items.  When combined with\n+/// an infallible `Try` type, that means the loop canonicalizes easily, allowing\n+/// it to optimize well.\n ///\n-/// If `iter.next()` panicks, all items already yielded by the iterator are\n-/// dropped.\n+/// It would be *possible* to unify this and [`iter_next_chunk_erased`] into one\n+/// function that does the union of both things, but last time it was that way\n+/// it resulted in poor codegen from the \"are there enough source items?\" checks\n+/// not optimizing away.  So if you give it a shot, make sure to watch what\n+/// happens in the codegen tests.\n #[inline]\n-fn try_collect_into_array<I, T, R, const N: usize>(\n-    iter: &mut I,\n-) -> Result<R::TryType, IntoIter<T, N>>\n+fn try_from_fn_erased<T, R>(\n+    buffer: &mut [MaybeUninit<T>],\n+    mut generator: impl FnMut(usize) -> R,\n+) -> ControlFlow<R::Residual>\n where\n-    I: Iterator,\n-    I::Item: Try<Output = T, Residual = R>,\n-    R: Residual<[T; N]>,\n+    R: Try<Output = T>,\n {\n-    if N == 0 {\n-        // SAFETY: An empty array is always inhabited and has no validity invariants.\n-        return Ok(Try::from_output(unsafe { mem::zeroed() }));\n-    }\n+    let mut guard = Guard { array_mut: buffer, initialized: 0 };\n \n-    let mut array = MaybeUninit::uninit_array::<N>();\n-    let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n-\n-    for _ in 0..N {\n-        match iter.next() {\n-            Some(item_rslt) => {\n-                let item = match item_rslt.branch() {\n-                    ControlFlow::Break(r) => {\n-                        return Ok(FromResidual::from_residual(r));\n-                    }\n-                    ControlFlow::Continue(elem) => elem,\n-                };\n-\n-                // SAFETY: `guard.initialized` starts at 0, which means push can be called\n-                // at most N times, which this loop does.\n-                unsafe {\n-                    guard.push_unchecked(item);\n-                }\n-            }\n-            None => {\n-                let alive = 0..guard.initialized;\n-                mem::forget(guard);\n-                // SAFETY: `array` was initialized with exactly `initialized`\n-                // number of elements.\n-                return Err(unsafe { IntoIter::new_unchecked(array, alive) });\n-            }\n-        }\n+    while guard.initialized < guard.array_mut.len() {\n+        let item = generator(guard.initialized).branch()?;\n+\n+        // SAFETY: The loop condition ensures we have space to push the item\n+        unsafe { guard.push_unchecked(item) };\n     }\n \n     mem::forget(guard);\n-    // SAFETY: All elements of the array were populated in the loop above.\n-    let output = unsafe { array.transpose().assume_init() };\n-    Ok(Try::from_output(output))\n+    ControlFlow::Continue(())\n }\n \n /// Panic guard for incremental initialization of arrays.\n@@ -909,14 +866,14 @@ where\n ///\n /// To minimize indirection fields are still pub but callers should at least use\n /// `push_unchecked` to signal that something unsafe is going on.\n-pub(crate) struct Guard<'a, T, const N: usize> {\n+struct Guard<'a, T> {\n     /// The array to be initialized.\n-    pub array_mut: &'a mut [MaybeUninit<T>; N],\n+    pub array_mut: &'a mut [MaybeUninit<T>],\n     /// The number of items that have been initialized so far.\n     pub initialized: usize,\n }\n \n-impl<T, const N: usize> Guard<'_, T, N> {\n+impl<T> Guard<'_, T> {\n     /// Adds an item to the array and updates the initialized item counter.\n     ///\n     /// # Safety\n@@ -934,28 +891,73 @@ impl<T, const N: usize> Guard<'_, T, N> {\n     }\n }\n \n-impl<T, const N: usize> Drop for Guard<'_, T, N> {\n+impl<T> Drop for Guard<'_, T> {\n     fn drop(&mut self) {\n-        debug_assert!(self.initialized <= N);\n+        debug_assert!(self.initialized <= self.array_mut.len());\n \n         // SAFETY: this slice will contain only initialized objects.\n         unsafe {\n             crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n-                &mut self.array_mut.get_unchecked_mut(..self.initialized),\n+                self.array_mut.get_unchecked_mut(..self.initialized),\n             ));\n         }\n     }\n }\n \n-/// Returns the next chunk of `N` items from the iterator or errors with an\n-/// iterator over the remainder. Used for `Iterator::next_chunk`.\n+/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n+/// yields fewer than `N` items, `Err` is returned containing an iterator over\n+/// the already yielded items.\n+///\n+/// Since the iterator is passed as a mutable reference and this function calls\n+/// `next` at most `N` times, the iterator can still be used afterwards to\n+/// retrieve the remaining items.\n+///\n+/// If `iter.next()` panicks, all items already yielded by the iterator are\n+/// dropped.\n+///\n+/// Used for [`Iterator::next_chunk`].\n #[inline]\n-pub(crate) fn iter_next_chunk<I, const N: usize>(\n-    iter: &mut I,\n-) -> Result<[I::Item; N], IntoIter<I::Item, N>>\n-where\n-    I: Iterator,\n-{\n-    let mut map = iter.map(NeverShortCircuit);\n-    try_collect_into_array(&mut map).map(|NeverShortCircuit(arr)| arr)\n+pub(crate) fn iter_next_chunk<T, const N: usize>(\n+    iter: &mut impl Iterator<Item = T>,\n+) -> Result<[T; N], IntoIter<T, N>> {\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    let r = iter_next_chunk_erased(&mut array, iter);\n+    match r {\n+        Ok(()) => {\n+            // SAFETY: All elements of `array` were populated.\n+            Ok(unsafe { MaybeUninit::array_assume_init(array) })\n+        }\n+        Err(initialized) => {\n+            // SAFETY: Only the first `initialized` elements were populated\n+            Err(unsafe { IntoIter::new_unchecked(array, 0..initialized) })\n+        }\n+    }\n+}\n+\n+/// Version of [`iter_next_chunk`] using a passed-in slice in order to avoid\n+/// needing to monomorphize for every array length.\n+///\n+/// Unfortunately this loop has two exit conditions, the buffer filling up\n+/// or the iterator running out of items, making it tend to optimize poorly.\n+#[inline]\n+fn iter_next_chunk_erased<T>(\n+    buffer: &mut [MaybeUninit<T>],\n+    iter: &mut impl Iterator<Item = T>,\n+) -> Result<(), usize> {\n+    let mut guard = Guard { array_mut: buffer, initialized: 0 };\n+    while guard.initialized < guard.array_mut.len() {\n+        let Some(item) = iter.next() else {\n+            // Unlike `try_from_fn_erased`, we want to keep the partial results,\n+            // so we need to defuse the guard instead of using `?`.\n+            let initialized = guard.initialized;\n+            mem::forget(guard);\n+            return Err(initialized)\n+        };\n+\n+        // SAFETY: The loop condition ensures we have space to push the item\n+        unsafe { guard.push_unchecked(item) };\n+    }\n+\n+    mem::forget(guard);\n+    Ok(())\n }"}, {"sha": "13719c727e93f700d7cf754db55965cf6bfa76c0", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -1,6 +1,5 @@\n use crate::array;\n use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n-use crate::mem::{self, MaybeUninit};\n use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n@@ -212,19 +211,14 @@ where\n         let mut i = 0;\n         // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n         while inner_len - i >= N {\n-            let mut chunk = MaybeUninit::uninit_array();\n-            let mut guard = array::Guard { array_mut: &mut chunk, initialized: 0 };\n-            while guard.initialized < N {\n+            let chunk = crate::array::from_fn(|local| {\n                 // SAFETY: The method consumes the iterator and the loop condition ensures that\n                 // all accesses are in bounds and only happen once.\n                 unsafe {\n-                    let idx = i + guard.initialized;\n-                    guard.push_unchecked(self.iter.__iterator_get_unchecked(idx));\n+                    let idx = i + local;\n+                    self.iter.__iterator_get_unchecked(idx)\n                 }\n-            }\n-            mem::forget(guard);\n-            // SAFETY: The loop above initialized all elements\n-            let chunk = unsafe { MaybeUninit::array_assume_init(chunk) };\n+            });\n             accum = f(accum, chunk);\n             i += N;\n         }"}, {"sha": "914ff86c1a95972dbe708215944a4c3831a31104", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -1,7 +1,7 @@\n use crate::iter::adapters::{\n     zip::try_get_unchecked, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n-use crate::iter::{FusedIterator, TrustedLen};\n+use crate::iter::{FusedIterator, TrustedLen, UncheckedIterator};\n use crate::ops::Try;\n \n /// An iterator that clones the elements of an underlying iterator.\n@@ -140,3 +140,16 @@ where\n     T: Clone,\n {\n }\n+\n+impl<'a, I, T: 'a> UncheckedIterator for Cloned<I>\n+where\n+    I: UncheckedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    unsafe fn next_unchecked(&mut self) -> T {\n+        // SAFETY: `Cloned` is 1:1 with the inner iterator, so if the caller promised\n+        // that there's an element left, the inner iterator has one too.\n+        let item = unsafe { self.it.next_unchecked() };\n+        item.clone()\n+    }\n+}"}, {"sha": "31d02a4da6ea53ab9b11f4b54544bf866fcf128c", "filename": "library/core/src/iter/adapters/map.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -2,7 +2,7 @@ use crate::fmt;\n use crate::iter::adapters::{\n     zip::try_get_unchecked, SourceIter, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n-use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen, UncheckedIterator};\n use crate::ops::Try;\n \n /// An iterator that maps the values of `iter` with `f`.\n@@ -187,6 +187,19 @@ where\n {\n }\n \n+impl<B, I, F> UncheckedIterator for Map<I, F>\n+where\n+    I: UncheckedIterator,\n+    F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn next_unchecked(&mut self) -> B {\n+        // SAFETY: `Map` is 1:1 with the inner iterator, so if the caller promised\n+        // that there's an element left, the inner iterator has one too.\n+        let item = unsafe { self.iter.next_unchecked() };\n+        (self.f)(item)\n+    }\n+}\n+\n #[doc(hidden)]\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<I, F> TrustedRandomAccess for Map<I, F> where I: TrustedRandomAccess {}"}, {"sha": "b6b0c90cb7d146a1a03a8d95a126718a57f5214c", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp;\n use crate::fmt::{self, Debug};\n use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n-use crate::iter::{InPlaceIterable, SourceIter, TrustedLen};\n+use crate::iter::{InPlaceIterable, SourceIter, TrustedLen, UncheckedIterator};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n@@ -417,6 +417,13 @@ where\n {\n }\n \n+impl<A, B> UncheckedIterator for Zip<A, B>\n+where\n+    A: UncheckedIterator,\n+    B: UncheckedIterator,\n+{\n+}\n+\n // Arbitrarily selects the left side of the zip iteration as extractable \"source\"\n // it would require negative trait bounds to be able to try both\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]"}, {"sha": "156b925de773f177f192acf559098a4633efcf4b", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -450,6 +450,7 @@ pub use self::adapters::{\n pub use self::adapters::{Intersperse, IntersperseWith};\n \n pub(crate) use self::adapters::try_process;\n+pub(crate) use self::traits::UncheckedIterator;\n \n mod adapters;\n mod range;"}, {"sha": "41ea29e6a84d98f178fd59ca8e06bc5d95cac7c7", "filename": "library/core/src/iter/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -4,6 +4,7 @@ mod double_ended;\n mod exact_size;\n mod iterator;\n mod marker;\n+mod unchecked_iterator;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::{\n@@ -19,3 +20,5 @@ pub use self::{\n pub use self::marker::InPlaceIterable;\n #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n pub use self::marker::TrustedStep;\n+\n+pub(crate) use self::unchecked_iterator::UncheckedIterator;"}, {"sha": "ae4bfcad4e68f8222878708f28b994b09a8fe5e7", "filename": "library/core/src/iter/traits/unchecked_iterator.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Funchecked_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Funchecked_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Funchecked_iterator.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -0,0 +1,36 @@\n+use crate::iter::TrustedLen;\n+\n+/// [`TrustedLen`] cannot have methods, so this allows augmenting it.\n+///\n+/// It currently requires `TrustedLen` because it's unclear whether it's\n+/// reasonably possible to depend on the `size_hint` of anything else.\n+pub(crate) trait UncheckedIterator: TrustedLen {\n+    /// Gets the next item from a non-empty iterator.\n+    ///\n+    /// Because there's always a value to return, that means it can return\n+    /// the `Item` type directly, without wrapping it in an `Option`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This can only be called if `size_hint().0 != 0`, guaranteeing that\n+    /// there's at least one item available.\n+    ///\n+    /// Otherwise (aka when `size_hint().1 == Some(0)`), this is UB.\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// This has a default implementation using [`Option::unwrap_unchecked`].\n+    /// That's probably sufficient if your `next` *always* returns `Some`,\n+    /// such as for infinite iterators.  In more complicated situations, however,\n+    /// sometimes there can still be `insertvalue`/`assume`/`extractvalue`\n+    /// instructions remaining in the IR from the `Option` handling, at which\n+    /// point you might want to implement this manually instead.\n+    #[unstable(feature = \"trusted_len_next_unchecked\", issue = \"37572\")]\n+    #[inline]\n+    unsafe fn next_unchecked(&mut self) -> Self::Item {\n+        let opt = self.next();\n+        // SAFETY: The caller promised that we're not empty, and\n+        // `Self: TrustedLen` so we can actually trust the `size_hint`.\n+        unsafe { opt.unwrap_unchecked() }\n+    }\n+}"}, {"sha": "86aa1e4fd20ba48ce698ca58edcfe40daebb187b", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -379,6 +379,15 @@ pub(crate) type ChangeOutputType<T, V> = <<T as Try>::Residual as Residual<V>>::\n pub(crate) struct NeverShortCircuit<T>(pub T);\n \n impl<T> NeverShortCircuit<T> {\n+    /// Wraps a unary function to produce one that wraps the output into a `NeverShortCircuit`.\n+    ///\n+    /// This is useful for implementing infallible functions in terms of the `try_` ones,\n+    /// without accidentally capturing extra generic parameters in a closure.\n+    #[inline]\n+    pub fn wrap_mut_1<A>(mut f: impl FnMut(A) -> T) -> impl FnMut(A) -> NeverShortCircuit<T> {\n+        move |a| NeverShortCircuit(f(a))\n+    }\n+\n     #[inline]\n     pub fn wrap_mut_2<A, B>(\n         mut f: impl ~const FnMut(A, B) -> T,"}, {"sha": "c4317799bcc68958e8b7e4dc2409a4753cfaca1c", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -7,7 +7,9 @@ use crate::cmp;\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::intrinsics::assume;\n-use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n+use crate::iter::{\n+    FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce, UncheckedIterator,\n+};\n use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem::{self, SizedTypeProperties};\n use crate::num::NonZeroUsize;"}, {"sha": "89b92a7d5975fb2fe582bd4495881c5dca17c78c", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -384,6 +384,15 @@ macro_rules! iterator {\n \n         #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n         unsafe impl<T> TrustedLen for $name<'_, T> {}\n+\n+        impl<'a, T> UncheckedIterator for $name<'a, T> {\n+            unsafe fn next_unchecked(&mut self) -> $elem {\n+                // SAFETY: The caller promised there's at least one more item.\n+                unsafe {\n+                    next_unchecked!(self)\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "5327e4f813925cdbe40fb3afc1c6a8003e737a65", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -700,3 +700,28 @@ fn array_into_iter_rfold() {\n     let s = it.rfold(10, |a, b| 10 * a + b);\n     assert_eq!(s, 10432);\n }\n+\n+#[cfg(not(panic = \"abort\"))]\n+#[test]\n+fn array_map_drops_unmapped_elements_on_panic() {\n+    struct DropCounter<'a>(usize, &'a AtomicUsize);\n+    impl Drop for DropCounter<'_> {\n+        fn drop(&mut self) {\n+            self.1.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    const MAX: usize = 11;\n+    for panic_after in 0..MAX {\n+        let counter = AtomicUsize::new(0);\n+        let a = array::from_fn::<_, 11, _>(|i| DropCounter(i, &counter));\n+        let success = std::panic::catch_unwind(|| {\n+            let _ = a.map(|x| {\n+                assert!(x.0 < panic_after);\n+                assert_eq!(counter.load(Ordering::SeqCst), x.0);\n+            });\n+        });\n+        assert!(success.is_err());\n+        assert_eq!(counter.load(Ordering::SeqCst), MAX);\n+    }\n+}"}, {"sha": "62566a9502d046a4bee0c58d71221203f3ef3107", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -582,6 +582,9 @@ fn test_next_chunk() {\n     assert_eq!(it.next_chunk().unwrap(), []);\n     assert_eq!(it.next_chunk().unwrap(), [4, 5, 6, 7, 8, 9]);\n     assert_eq!(it.next_chunk::<4>().unwrap_err().as_slice(), &[10, 11]);\n+\n+    let mut it = std::iter::repeat_with(|| panic!());\n+    assert_eq!(it.next_chunk::<0>().unwrap(), []);\n }\n \n // just tests by whether or not this compiles"}, {"sha": "9298e89e397d0ccd91a41fcfdf37ea0698d69573", "filename": "tests/codegen/array-map.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/tests%2Fcodegen%2Farray-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/tests%2Fcodegen%2Farray-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-map.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -0,0 +1,49 @@\n+// compile-flags: -C opt-level=3 -C target-cpu=x86-64-v3\n+// no-system-llvm\n+// only-x86_64\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+#![feature(array_zip)]\n+\n+// CHECK-LABEL: @short_integer_map\n+#[no_mangle]\n+pub fn short_integer_map(x: [u32; 8]) -> [u32; 8] {\n+    // CHECK: load <8 x i32>\n+    // CHECK: shl <8 x i32>\n+    // CHECK: or <8 x i32>\n+    // CHECK: store <8 x i32>\n+    x.map(|x| 2 * x + 1)\n+}\n+\n+// CHECK-LABEL: @short_integer_zip_map\n+#[no_mangle]\n+pub fn short_integer_zip_map(x: [u32; 8], y: [u32; 8]) -> [u32; 8] {\n+    // CHECK: %[[A:.+]] = load <8 x i32>\n+    // CHECK: %[[B:.+]] = load <8 x i32>\n+    // CHECK: sub <8 x i32> %[[A]], %[[B]]\n+    // CHECK: store <8 x i32>\n+    x.zip(y).map(|(x, y)| x - y)\n+}\n+\n+// This test is checking that LLVM can SRoA away a bunch of the overhead,\n+// like fully moving the iterators to registers.  Notably, previous implementations\n+// of `map` ended up `alloca`ing the whole `array::IntoIterator`, meaning both a\n+// hard-to-eliminate `memcpy` and that the iteration counts needed to be written\n+// out to stack every iteration, even for infallible operations on `Copy` types.\n+//\n+// This is still imperfect, as there's more copies than would be ideal,\n+// but hopefully work like #103830 will improve that in future,\n+// and update this test to be stricter.\n+//\n+// CHECK-LABEL: @long_integer_map\n+#[no_mangle]\n+pub fn long_integer_map(x: [u32; 64]) -> [u32; 64] {\n+    // CHECK: start:\n+    // CHECK-NEXT: alloca [64 x i32]\n+    // CHECK-NEXT: alloca %\"core::mem::manually_drop::ManuallyDrop<[u32; 64]>\"\n+    // CHECK-NOT: alloca\n+    // CHECK: mul <{{[0-9]+}} x i32>\n+    // CHECK: add <{{[0-9]+}} x i32>\n+    x.map(|x| 13 * x + 7)\n+}"}, {"sha": "9ecea53f1c05cc64ba18c4a7eff10cf9c1912a6e", "filename": "tests/codegen/autovectorize-f32x4.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d91939bb7130a8e6c092a290b7d37f654e3c23c/tests%2Fcodegen%2Fautovectorize-f32x4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d91939bb7130a8e6c092a290b7d37f654e3c23c/tests%2Fcodegen%2Fautovectorize-f32x4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fautovectorize-f32x4.rs?ref=2d91939bb7130a8e6c092a290b7d37f654e3c23c", "patch": "@@ -1,6 +1,7 @@\n-// compile-flags: -C opt-level=3\n+// compile-flags: -C opt-level=3 -Z merge-functions=disabled\n // only-x86_64\n #![crate_type = \"lib\"]\n+#![feature(array_zip)]\n \n // CHECK-LABEL: @auto_vectorize_direct\n #[no_mangle]\n@@ -30,3 +31,13 @@ pub fn auto_vectorize_loop(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n     }\n     c\n }\n+\n+// CHECK-LABEL: @auto_vectorize_array_zip_map\n+#[no_mangle]\n+pub fn auto_vectorize_array_zip_map(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n+// CHECK: load <4 x float>\n+// CHECK: load <4 x float>\n+// CHECK: fadd <4 x float>\n+// CHECK: store <4 x float>\n+    a.zip(b).map(|(a, b)| a + b)\n+}"}]}