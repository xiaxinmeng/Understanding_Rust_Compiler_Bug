{"sha": "ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMWQ1MGNlYzFkNmRiZmJkODY2MzgxZjBiNzkzY2JkOWM2MTdiMWI=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-01-07T16:53:56Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-21T10:02:25Z"}, "message": "Implement wildcard_imports lint", "tree": {"sha": "4c58807b1994fcad92757e156a9b5e27dc34b505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c58807b1994fcad92757e156a9b5e27dc34b505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl5PqrEACgkQaTCGhp1Q\nZjd/fBAApVVulrlHfgSwBm2RWimYJ3WPX6N8YmyV+ruds3Be8duPjlaDfTtm8ouk\n+fPvUG5FhOaTZNznC/DqrAJBJKsiITdEtY3fEeVBbYTRWuEj+NduieA9cMK89hAN\nAWyb5rYpndDF6b+flfs1r3wVRlH7/jd0g16q65jiAvCB4nifWvg2BacsD6wXcMJQ\nZREAKm1I+h8GY/RXHvWTpdJp60DiKK2W4CzMCIXajSyIofImYiIu/s7SzhrsySTz\nHhmn7zvByGSQfSNWhH+L7Q7rmogWEx4T2lNCcDXOJOid3G9eNtZ1OTXb2rJf7G09\ng4Ky0pPy17HAwO0/y4wSrG8AM3QZtVUIrREnBkGlBDzZXWe8JEB8Y530vpMIGwud\nMsl/O9whcKjIZ3BzI8aWPSorsGHZaaVwHEqoBeA81/+5vX/jnNLm4IIlvor+kyem\ns7sLeT8ZBa1uNc9CoYbET/kiLoGKrkMGVjciSC96jEjwIb9K/uC+dmNgD2npJauD\nrjmk4oX6AOjNEcg+WqDSjjgKQy7IiBwSmVKLomB01HKjoG+BgY1V4FxlpZk2AVul\nG1x/JpuG36FxDHDEYQmyMXqyeg6BCL2hQRz0X3KhTbLo8QcZkzQqLcHm9jTHsTKt\nlmeDKHWouIRMYJOT6rYQsjpssDXncIYWTXoc9bXeMlPZgWavSdM=\n=sfGZ\n-----END PGP SIGNATURE-----", "payload": "tree 4c58807b1994fcad92757e156a9b5e27dc34b505\nparent 8a572a540af53bee712bc50a9d882a1c1376174c\nauthor flip1995 <hello@philkrones.com> 1578416036 +0100\ncommitter flip1995 <hello@philkrones.com> 1582279345 +0100\n\nImplement wildcard_imports lint\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b", "html_url": "https://github.com/rust-lang/rust/commit/ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a572a540af53bee712bc50a9d882a1c1376174c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a572a540af53bee712bc50a9d882a1c1376174c", "html_url": "https://github.com/rust-lang/rust/commit/8a572a540af53bee712bc50a9d882a1c1376174c"}], "stats": {"total": 271, "additions": 271, "deletions": 0}, "files": [{"sha": "70098f31aef7b16c5b091925bce8fcb5391f7831", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=ba1d50cec1d6dbfbd866381f0b793cbd9c617b1b", "patch": "@@ -0,0 +1,271 @@\n+use crate::utils::{in_macro, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc::ty::DefIdTree;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{walk_item, NestedVisitorMap, Visitor};\n+use rustc_hir::*;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{symbol::Symbol, BytePos};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for wildcard imports `use _::*`.\n+    ///\n+    /// **Why is this bad?** wildcard imports can polute the namespace. This is especially bad if\n+    /// you try to import something through a wildcard, that already has been imported by name from\n+    /// a different source:\n+    ///\n+    /// ```rust,ignore\n+    /// use crate1::foo; // Imports a function named foo\n+    /// use crate2::*; // Has a function named foo\n+    ///\n+    /// foo(); // Calls crate1::foo\n+    /// ```\n+    ///\n+    /// This can lead to confusing error messages at best and to unexpected behavior at worst.\n+    ///\n+    /// **Known problems:** If macros are imported through the wildcard, this macro is not included\n+    /// by the suggestion and has to be added by hand.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// use crate1::*;\n+    ///\n+    /// foo();\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// use crate1::foo;\n+    ///\n+    /// foo();\n+    /// ```\n+    pub WILDCARD_IMPORTS,\n+    pedantic,\n+    \"lint `use _::*` statements\"\n+}\n+\n+declare_lint_pass!(WildcardImports => [WILDCARD_IMPORTS]);\n+\n+impl LateLintPass<'_, '_> for WildcardImports {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+        if item.vis.node.is_pub() || item.vis.node.is_pub_restricted() {\n+            return;\n+        }\n+        if_chain! {\n+            if !in_macro(item.span);\n+            if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n+            if let Some(def_id) = use_path.res.opt_def_id();\n+            then {\n+                let hir = cx.tcx.hir();\n+                let parent_id = hir.get_parent_item(item.hir_id);\n+                let (items, in_module) = if parent_id == CRATE_HIR_ID {\n+                    let items = hir\n+                        .krate()\n+                        .module\n+                        .item_ids\n+                        .iter()\n+                        .map(|item_id| hir.get(item_id.id))\n+                        .filter_map(|node| {\n+                            if let Node::Item(item) = node {\n+                                Some(item)\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .collect();\n+                    (items, true)\n+                } else if let Node::Item(item) = hir.get(parent_id) {\n+                    (vec![item], false)\n+                } else {\n+                    (vec![], false)\n+                };\n+\n+                let mut import_used_visitor = ImportsUsedVisitor {\n+                    cx,\n+                    wildcard_def_id: def_id,\n+                    in_module,\n+                    used_imports: FxHashSet::default(),\n+                };\n+                for item in items {\n+                    import_used_visitor.visit_item(item);\n+                }\n+\n+                if !import_used_visitor.used_imports.is_empty() {\n+                    let module_name = use_path\n+                        .segments\n+                        .iter()\n+                        .last()\n+                        .expect(\"path has at least one segment\")\n+                        .ident\n+                        .name;\n+\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    let import_source = snippet_with_applicability(cx, use_path.span, \"..\", &mut applicability);\n+                    let (span, braced_glob) = if import_source.is_empty() {\n+                        // This is a `_::{_, *}` import\n+                        // Probably it's `_::{self, *}`, in that case we don't want to suggest to\n+                        // import `self`.\n+                        // If it is something else, we also don't want to include `self` in the\n+                        // suggestion, since either it was imported through another use statement:\n+                        // ```\n+                        // use foo::bar;\n+                        // use foo::bar::{baz, *};\n+                        // ```\n+                        // or it couldn't be used anywhere.\n+                        (\n+                            use_path.span.with_hi(use_path.span.hi() + BytePos(1)),\n+                            true,\n+                        )\n+                    } else {\n+                        (\n+                            use_path.span.with_hi(use_path.span.hi() + BytePos(3)),\n+                            false,\n+                        )\n+                    };\n+\n+                    let imports_string = if import_used_visitor.used_imports.len() == 1 {\n+                        // We don't need to check for accidental suggesting the module name instead\n+                        // of `self` here, since if `used_imports.len() == 1`, and the only usage\n+                        // is `self`, then it's not through a `*` and if there is a `*`, it gets\n+                        // already linted by `unused_imports` of rustc.\n+                        import_used_visitor.used_imports.iter().next().unwrap().to_string()\n+                    } else {\n+                        let mut imports = import_used_visitor\n+                            .used_imports\n+                            .iter()\n+                            .filter_map(|import_name| {\n+                                if braced_glob && *import_name == module_name {\n+                                    None\n+                                } else if *import_name == module_name {\n+                                    Some(\"self\".to_string())\n+                                } else {\n+                                    Some(import_name.to_string())\n+                                }\n+                            })\n+                            .collect::<Vec<_>>();\n+                        imports.sort();\n+                        if braced_glob {\n+                            imports.join(\", \")\n+                        } else {\n+                            format!(\"{{{}}}\", imports.join(\", \"))\n+                        }\n+                    };\n+\n+                    let sugg = if import_source.is_empty() {\n+                        imports_string\n+                    } else {\n+                        format!(\"{}::{}\", import_source, imports_string)\n+                    };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        WILDCARD_IMPORTS,\n+                        span,\n+                        \"usage of wildcard import\",\n+                        \"try\",\n+                        sugg,\n+                        applicability,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ImportsUsedVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    wildcard_def_id: def_id::DefId,\n+    in_module: bool,\n+    used_imports: FxHashSet<Symbol>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ImportsUsedVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_item(&mut self, item: &'tcx Item<'_>) {\n+        match item.kind {\n+            ItemKind::Use(..) => {},\n+            ItemKind::Mod(..) if self.in_module => {},\n+            ItemKind::Mod(..) => self.in_module = true,\n+            _ => walk_item(self, item),\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &Path<'_>, _: HirId) {\n+        if let Some(def_id) = self.first_path_segment_def_id(path) {\n+            // Check if the function/enum/... was exported\n+            if let Some(exports) = self.cx.tcx.module_exports(self.wildcard_def_id) {\n+                for export in exports {\n+                    if let Some(export_def_id) = export.res.opt_def_id() {\n+                        if export_def_id == def_id {\n+                            self.used_imports.insert(\n+                                path.segments\n+                                    .iter()\n+                                    .next()\n+                                    .expect(\"path has at least one segment\")\n+                                    .ident\n+                                    .name,\n+                            );\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check if it is directly in the module\n+            if let Some(parent_def_id) = self.cx.tcx.parent(def_id) {\n+                if self.wildcard_def_id == parent_def_id {\n+                    self.used_imports.insert(\n+                        path.segments\n+                            .iter()\n+                            .next()\n+                            .expect(\"path has at least one segment\")\n+                            .ident\n+                            .name,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<'_, Self::Map> {\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n+    }\n+}\n+\n+impl ImportsUsedVisitor<'_, '_> {\n+    fn skip_def_id(&self, def_id: DefId) -> DefId {\n+        let def_key = self.cx.tcx.def_key(def_id);\n+        match def_key.disambiguated_data.data {\n+            DefPathData::Ctor => {\n+                if let Some(def_id) = self.cx.tcx.parent(def_id) {\n+                    self.skip_def_id(def_id)\n+                } else {\n+                    def_id\n+                }\n+            },\n+            _ => def_id,\n+        }\n+    }\n+\n+    fn first_path_segment_def_id(&self, path: &Path<'_>) -> Option<DefId> {\n+        path.res.opt_def_id().and_then(|mut def_id| {\n+            def_id = self.skip_def_id(def_id);\n+            for _ in path.segments.iter().skip(1) {\n+                def_id = self.skip_def_id(def_id);\n+                if let Some(parent_def_id) = self.cx.tcx.parent(def_id) {\n+                    def_id = parent_def_id;\n+                } else {\n+                    return None;\n+                }\n+            }\n+\n+            Some(def_id)\n+        })\n+    }\n+}"}]}