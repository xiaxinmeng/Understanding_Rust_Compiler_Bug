{"sha": "0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMjFhMDVlNmMwYmMwYmZhOTA1MjkxYTkxNmIzOGJkYjlkYWY5MGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-16T03:23:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-16T04:36:16Z"}, "message": "rustc: Extract loader mod from creader mod\n\nloader is a utility for locating crates and loading their metadata.\ncreader is a compiler pass that loads metadata for all used libraries.", "tree": {"sha": "fffd203146f2656baba17d439a2b477cd9c36d0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fffd203146f2656baba17d439a2b477cd9c36d0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "html_url": "https://github.com/rust-lang/rust/commit/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bfa19b100c0fef982bfad20c9b108c4f2e7a329", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bfa19b100c0fef982bfad20c9b108c4f2e7a329", "html_url": "https://github.com/rust-lang/rust/commit/4bfa19b100c0fef982bfad20c9b108c4f2e7a329"}], "stats": {"total": 422, "additions": 222, "deletions": 200}, "files": [{"sha": "a0a630bb10bae28998fdf0bac3d7f94389ae0825", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "patch": "@@ -672,7 +672,7 @@ fn early_error(emitter: diagnostic::emitter, msg: str) -> ! {\n }\n \n fn list_metadata(sess: session, path: str, out: io::writer) {\n-    metadata::creader::list_file_metadata(sess, path, out);\n+    metadata::loader::list_file_metadata(sess, path, out);\n }\n \n #[cfg(test)]"}, {"sha": "2cc3f1a5a4a2893f3cdfcf8d0fc1aafd97ef59a6", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 199, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "patch": "@@ -1,20 +1,20 @@\n-// Extracting metadata from crate files\n+#[doc = \"\n+\n+Validates all used crates and native libraries and loads their metadata\n+\n+\"];\n \n import driver::session;\n import session::session;\n import syntax::{ast, ast_util};\n-import lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n import syntax::attr;\n import syntax::visit;\n import syntax::codemap::span;\n-import util::{filesearch};\n-import io::writer_util;\n import std::map::{hashmap, int_hash};\n import syntax::print::pprust;\n import common::*;\n \n export read_crates;\n-export list_file_metadata;\n \n // Traverses an AST, reading all the information about use'd crates and native\n // libraries necessary for later resolving, typechecking, linking, etc.\n@@ -59,10 +59,10 @@ fn warn_if_multiple_versions(sess: session::session,\n     import either::*;\n \n     if crate_cache.is_not_empty() {\n-        let name = crate_name_from_metas(*crate_cache.last().metas);\n+        let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n         let {lefts: matches, rights: non_matches} =\n             partition(crate_cache.map {|entry|\n-                let othername = crate_name_from_metas(*entry.metas);\n+                let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n                     left(entry)\n                 } else {\n@@ -79,7 +79,7 @@ fn warn_if_multiple_versions(sess: session::session,\n                 let attrs = [\n                     attr::mk_attr(attr::mk_list_item(\"link\", *match.metas))\n                 ];\n-                note_linkage_attrs(sess, attrs);\n+                loader::note_linkage_attrs(sess, attrs);\n             }\n         }\n \n@@ -148,195 +148,6 @@ fn visit_item(e: env, i: @ast::item) {\n     }\n }\n \n-// A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(sess: session::session, path: str, out: io::writer) {\n-    alt get_metadata_section(sess, path) {\n-      option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n-      option::none {\n-        out.write_str(\"could not find metadata in \" + path + \".\\n\");\n-      }\n-    }\n-}\n-\n-fn crate_matches(crate_data: @[u8], metas: [@ast::meta_item], hash: str) ->\n-    bool {\n-    let attrs = decoder::get_crate_attributes(crate_data);\n-    let linkage_metas = attr::find_linkage_metas(attrs);\n-    if hash.is_not_empty() {\n-        let chash = decoder::get_crate_hash(crate_data);\n-        if chash != hash { ret false; }\n-    }\n-    metadata_matches(linkage_metas, metas)\n-}\n-\n-fn metadata_matches(extern_metas: [@ast::meta_item],\n-                    local_metas: [@ast::meta_item]) -> bool {\n-\n-    #debug(\"matching %u metadata requirements against %u items\",\n-           vec::len(local_metas), vec::len(extern_metas));\n-\n-    #debug(\"crate metadata:\");\n-    for extern_metas.each {|have|\n-        #debug(\"  %s\", pprust::meta_item_to_str(*have));\n-    }\n-\n-    for local_metas.each {|needed|\n-        #debug(\"looking for %s\", pprust::meta_item_to_str(*needed));\n-        if !attr::contains(extern_metas, needed) {\n-            #debug(\"missing %s\", pprust::meta_item_to_str(*needed));\n-            ret false;\n-        }\n-    }\n-    ret true;\n-}\n-\n-fn default_native_lib_naming(sess: session::session, static: bool) ->\n-   {prefix: str, suffix: str} {\n-    if static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n-    alt sess.targ_cfg.os {\n-      session::os_win32 { ret {prefix: \"\", suffix: \".dll\"}; }\n-      session::os_macos { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n-      session::os_linux { ret {prefix: \"lib\", suffix: \".so\"}; }\n-      session::os_freebsd { ret {prefix: \"lib\", suffix: \".so\"}; }\n-    }\n-}\n-\n-fn crate_name_from_metas(metas: [@ast::meta_item]) -> str {\n-    let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-    alt vec::last_opt(name_items) {\n-      some(i) {\n-        alt attr::get_meta_item_value_str(i) {\n-          some(n) { n }\n-          // FIXME: Probably want a warning here since the user\n-          // is using the wrong type of meta item\n-          _ { fail }\n-        }\n-      }\n-      none { fail \"expected to find the crate name\" }\n-    }\n-}\n-\n-fn find_library_crate(sess: session::session, span: span,\n-                      metas: [@ast::meta_item], hash: str)\n-   -> option<{ident: str, data: @[u8]}> {\n-\n-    attr::require_unique_names(sess.diagnostic(), metas);\n-    let metas = metas;\n-\n-    let nn = default_native_lib_naming(sess, sess.opts.static);\n-    let x =\n-        find_library_crate_aux(sess, span, nn,\n-                               metas, hash, sess.filesearch);\n-    if x != none || sess.opts.static { ret x; }\n-    let nn2 = default_native_lib_naming(sess, true);\n-    ret find_library_crate_aux(sess, span, nn2, metas, hash,\n-                               sess.filesearch);\n-}\n-\n-fn find_library_crate_aux(sess: session::session,\n-                          span: span,\n-                          nn: {prefix: str, suffix: str},\n-                          metas: [@ast::meta_item],\n-                          hash: str,\n-                          filesearch: filesearch::filesearch) ->\n-   option<{ident: str, data: @[u8]}> {\n-    let crate_name = crate_name_from_metas(metas);\n-    let prefix: str = nn.prefix + crate_name + \"-\";\n-    let suffix: str = nn.suffix;\n-\n-    let mut matches = [];\n-    filesearch::search(filesearch, { |path|\n-        #debug(\"inspecting file %s\", path);\n-        let f: str = path::basename(path);\n-        if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n-            #debug(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n-                   suffix);\n-            option::none::<()>\n-        } else {\n-            #debug(\"%s is a candidate\", path);\n-            alt get_metadata_section(sess, path) {\n-              option::some(cvec) {\n-                if !crate_matches(cvec, metas, hash) {\n-                    #debug(\"skipping %s, metadata doesn't match\", path);\n-                    option::none::<()>\n-                } else {\n-                    #debug(\"found %s with matching metadata\", path);\n-                    matches += [{ident: path, data: cvec}];\n-                    option::none::<()>\n-                }\n-              }\n-              _ {\n-                #debug(\"could not load metadata for %s\", path);\n-                option::none::<()>\n-              }\n-            }\n-        }\n-    });\n-\n-    if matches.is_empty() {\n-        none\n-    } else if matches.len() == 1u {\n-        some(matches[0])\n-    } else {\n-        sess.span_err(\n-            span, #fmt(\"multiple matching crates for `%s`\", crate_name));\n-        sess.note(\"candidates:\");\n-        for matches.each {|match|\n-            sess.note(#fmt(\"path: %s\", match.ident));\n-            let attrs = decoder::get_crate_attributes(match.data);\n-            note_linkage_attrs(sess, attrs);\n-        }\n-        sess.abort_if_errors();\n-        none\n-    }\n-}\n-\n-fn note_linkage_attrs(sess: session::session, attrs: [ast::attribute]) {\n-    for attr::find_linkage_attrs(attrs).each {|attr|\n-        sess.note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n-    }\n-}\n-\n-fn get_metadata_section(sess: session::session,\n-                        filename: str) -> option<@[u8]> unsafe {\n-    let mb = str::as_c_str(filename, {|buf|\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-                                   });\n-    if mb as int == 0 { ret option::none::<@[u8]>; }\n-    let of = alt mk_object_file(mb) {\n-        option::some(of) { of }\n-        _ { ret option::none::<@[u8]>; }\n-    };\n-    let si = mk_section_iter(of.llof);\n-    while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-        let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = unsafe { str::unsafe::from_c_str(name_buf) };\n-        if str::eq(name, sess.targ_cfg.target_strs.meta_sect_name) {\n-            let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-            let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-            unsafe {\n-                let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n-                ret some(@vec::unsafe::from_buf(cvbuf, csz));\n-            }\n-        }\n-        llvm::LLVMMoveToNextSection(si.llsi);\n-    }\n-    ret option::none::<@[u8]>;\n-}\n-\n-fn load_library_crate(sess: session::session, ident: ast::ident, span: span,\n-                      metas: [@ast::meta_item], hash: str)\n-   -> {ident: str, data: @[u8]} {\n-\n-\n-    alt find_library_crate(sess, span, metas, hash) {\n-      some(t) { ret t; }\n-      none {\n-        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n-      }\n-    }\n-}\n-\n fn metas_with(ident: ast::ident, key: str,\n                     metas: [@ast::meta_item]) -> [@ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, key);\n@@ -355,7 +166,7 @@ fn metas_with_ident(ident: ast::ident,\n fn existing_match(e: env, metas: [@ast::meta_item], hash: str) ->\n     option<int> {\n     let maybe_entry = e.crate_cache.find {|c|\n-        metadata_matches(*c.metas, metas) &&\n+        loader::metadata_matches(*c.metas, metas) &&\n             (hash.is_empty() || c.hash == hash)\n     };\n \n@@ -369,7 +180,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n     alt existing_match(e, metas, hash) {\n       none {\n         let cinfo =\n-            load_library_crate(e.sess, ident, span, metas, hash);\n+            loader::load_library_crate(e.sess, ident, span, metas, hash);\n \n         let cfilename = cinfo.ident;\n         let cdata = cinfo.data;"}, {"sha": "4ef60c4a8cc4cd195d782d3d75ab0da1bc3da2b3", "filename": "src/rustc/metadata/loader.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "patch": "@@ -0,0 +1,209 @@\n+#[doc = \"\n+\n+Finds crate binaries and loads their metadata\n+\n+\"];\n+\n+import driver::session;\n+import session::session;\n+import syntax::{ast, attr};\n+import syntax::print::pprust;\n+import syntax::codemap::span;\n+import lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n+import util::{filesearch};\n+import io::writer_util;\n+\n+export load_library_crate;\n+export list_file_metadata;\n+export note_linkage_attrs;\n+export crate_name_from_metas;\n+export metadata_matches;\n+\n+fn load_library_crate(sess: session::session, ident: ast::ident, span: span,\n+                      metas: [@ast::meta_item], hash: str)\n+   -> {ident: str, data: @[u8]} {\n+\n+\n+    alt find_library_crate(sess, span, metas, hash) {\n+      some(t) { ret t; }\n+      none {\n+        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n+      }\n+    }\n+}\n+\n+fn find_library_crate(sess: session::session, span: span,\n+                      metas: [@ast::meta_item], hash: str)\n+   -> option<{ident: str, data: @[u8]}> {\n+\n+    attr::require_unique_names(sess.diagnostic(), metas);\n+    let metas = metas;\n+\n+    let nn = default_native_lib_naming(sess, sess.opts.static);\n+    let x =\n+        find_library_crate_aux(sess, span, nn,\n+                               metas, hash, sess.filesearch);\n+    if x != none || sess.opts.static { ret x; }\n+    let nn2 = default_native_lib_naming(sess, true);\n+    ret find_library_crate_aux(sess, span, nn2, metas, hash,\n+                               sess.filesearch);\n+}\n+\n+fn default_native_lib_naming(sess: session::session, static: bool) ->\n+   {prefix: str, suffix: str} {\n+    if static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n+    alt sess.targ_cfg.os {\n+      session::os_win32 { ret {prefix: \"\", suffix: \".dll\"}; }\n+      session::os_macos { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n+      session::os_linux { ret {prefix: \"lib\", suffix: \".so\"}; }\n+      session::os_freebsd { ret {prefix: \"lib\", suffix: \".so\"}; }\n+    }\n+}\n+\n+fn find_library_crate_aux(sess: session::session,\n+                          span: span,\n+                          nn: {prefix: str, suffix: str},\n+                          metas: [@ast::meta_item],\n+                          hash: str,\n+                          filesearch: filesearch::filesearch) ->\n+   option<{ident: str, data: @[u8]}> {\n+    let crate_name = crate_name_from_metas(metas);\n+    let prefix: str = nn.prefix + crate_name + \"-\";\n+    let suffix: str = nn.suffix;\n+\n+    let mut matches = [];\n+    filesearch::search(filesearch, { |path|\n+        #debug(\"inspecting file %s\", path);\n+        let f: str = path::basename(path);\n+        if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n+            #debug(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n+                   suffix);\n+            option::none::<()>\n+        } else {\n+            #debug(\"%s is a candidate\", path);\n+            alt get_metadata_section(sess, path) {\n+              option::some(cvec) {\n+                if !crate_matches(cvec, metas, hash) {\n+                    #debug(\"skipping %s, metadata doesn't match\", path);\n+                    option::none::<()>\n+                } else {\n+                    #debug(\"found %s with matching metadata\", path);\n+                    matches += [{ident: path, data: cvec}];\n+                    option::none::<()>\n+                }\n+              }\n+              _ {\n+                #debug(\"could not load metadata for %s\", path);\n+                option::none::<()>\n+              }\n+            }\n+        }\n+    });\n+\n+    if matches.is_empty() {\n+        none\n+    } else if matches.len() == 1u {\n+        some(matches[0])\n+    } else {\n+        sess.span_err(\n+            span, #fmt(\"multiple matching crates for `%s`\", crate_name));\n+        sess.note(\"candidates:\");\n+        for matches.each {|match|\n+            sess.note(#fmt(\"path: %s\", match.ident));\n+            let attrs = decoder::get_crate_attributes(match.data);\n+            note_linkage_attrs(sess, attrs);\n+        }\n+        sess.abort_if_errors();\n+        none\n+    }\n+}\n+\n+fn crate_name_from_metas(metas: [@ast::meta_item]) -> str {\n+    let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+    alt vec::last_opt(name_items) {\n+      some(i) {\n+        alt attr::get_meta_item_value_str(i) {\n+          some(n) { n }\n+          // FIXME: Probably want a warning here since the user\n+          // is using the wrong type of meta item\n+          _ { fail }\n+        }\n+      }\n+      none { fail \"expected to find the crate name\" }\n+    }\n+}\n+\n+fn note_linkage_attrs(sess: session::session, attrs: [ast::attribute]) {\n+    for attr::find_linkage_attrs(attrs).each {|attr|\n+        sess.note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n+    }\n+}\n+\n+fn crate_matches(crate_data: @[u8], metas: [@ast::meta_item], hash: str) ->\n+    bool {\n+    let attrs = decoder::get_crate_attributes(crate_data);\n+    let linkage_metas = attr::find_linkage_metas(attrs);\n+    if hash.is_not_empty() {\n+        let chash = decoder::get_crate_hash(crate_data);\n+        if chash != hash { ret false; }\n+    }\n+    metadata_matches(linkage_metas, metas)\n+}\n+\n+fn metadata_matches(extern_metas: [@ast::meta_item],\n+                    local_metas: [@ast::meta_item]) -> bool {\n+\n+    #debug(\"matching %u metadata requirements against %u items\",\n+           vec::len(local_metas), vec::len(extern_metas));\n+\n+    #debug(\"crate metadata:\");\n+    for extern_metas.each {|have|\n+        #debug(\"  %s\", pprust::meta_item_to_str(*have));\n+    }\n+\n+    for local_metas.each {|needed|\n+        #debug(\"looking for %s\", pprust::meta_item_to_str(*needed));\n+        if !attr::contains(extern_metas, needed) {\n+            #debug(\"missing %s\", pprust::meta_item_to_str(*needed));\n+            ret false;\n+        }\n+    }\n+    ret true;\n+}\n+\n+fn get_metadata_section(sess: session::session,\n+                        filename: str) -> option<@[u8]> unsafe {\n+    let mb = str::as_c_str(filename, {|buf|\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+                                   });\n+    if mb as int == 0 { ret option::none::<@[u8]>; }\n+    let of = alt mk_object_file(mb) {\n+        option::some(of) { of }\n+        _ { ret option::none::<@[u8]>; }\n+    };\n+    let si = mk_section_iter(of.llof);\n+    while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n+        let name_buf = llvm::LLVMGetSectionName(si.llsi);\n+        let name = unsafe { str::unsafe::from_c_str(name_buf) };\n+        if str::eq(name, sess.targ_cfg.target_strs.meta_sect_name) {\n+            let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+            let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n+            unsafe {\n+                let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n+                ret some(@vec::unsafe::from_buf(cvbuf, csz));\n+            }\n+        }\n+        llvm::LLVMMoveToNextSection(si.llsi);\n+    }\n+    ret option::none::<@[u8]>;\n+}\n+\n+// A diagnostic function for dumping crate metadata to an output stream\n+fn list_file_metadata(sess: session::session, path: str, out: io::writer) {\n+    alt get_metadata_section(sess, path) {\n+      option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n+      option::none {\n+        out.write_str(\"could not find metadata in \" + path + \".\\n\");\n+      }\n+    }\n+}"}, {"sha": "69f225e5ed890a4f1d94fe09f4047cff6f704c74", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0e21a05e6c0bc0bfa905291a916b38bdb9daf90d/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=0e21a05e6c0bc0bfa905291a916b38bdb9daf90d", "patch": "@@ -117,6 +117,7 @@ mod metadata {\n     export decoder;\n     export tyencode;\n     export tydecode;\n+    export loader;\n \n     mod common;\n     mod tyencode;\n@@ -126,6 +127,7 @@ mod metadata {\n     mod creader;\n     mod cstore;\n     mod csearch;\n+    mod loader;\n }\n \n mod driver {"}]}