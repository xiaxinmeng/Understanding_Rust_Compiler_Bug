{"sha": "53f41f07ce2811a975ea6362d6a07b070d4bdf77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZjQxZjA3Y2UyODExYTk3NWVhNjM2MmQ2YTA3YjA3MGQ0YmRmNzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-07T22:16:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-07T22:17:36Z"}, "message": "librustc: Make vectors no longer implicitly copyable in rustc. r=graydon\n\n~20% perf win for trans on -O0, with other minor improvements across the board.\nNo effect on -O2.", "tree": {"sha": "087407eba404f6fbe4baaed5b6feafd57f2adc1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/087407eba404f6fbe4baaed5b6feafd57f2adc1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53f41f07ce2811a975ea6362d6a07b070d4bdf77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53f41f07ce2811a975ea6362d6a07b070d4bdf77", "html_url": "https://github.com/rust-lang/rust/commit/53f41f07ce2811a975ea6362d6a07b070d4bdf77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53f41f07ce2811a975ea6362d6a07b070d4bdf77/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09758f7072cee989c87bcfd88ac2aa737a26de4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/09758f7072cee989c87bcfd88ac2aa737a26de4d", "html_url": "https://github.com/rust-lang/rust/commit/09758f7072cee989c87bcfd88ac2aa737a26de4d"}], "stats": {"total": 2083, "additions": 1216, "deletions": 867}, "files": [{"sha": "17222b7498b27c9a42ba549e00f4ae075722b39f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::rpath;\n use driver::session;\n use lib::llvm::llvm;\n@@ -56,11 +57,13 @@ impl output_type : cmp::Eq {\n     pure fn ne(&self, other: &output_type) -> bool { !(*self).eq(other) }\n }\n \n-fn llvm_err(sess: Session, msg: ~str) -> ! unsafe {\n+fn llvm_err(sess: Session, +msg: ~str) -> ! unsafe {\n     let cstr = llvm::LLVMRustGetLastError();\n     if cstr == ptr::null() {\n         sess.fatal(msg);\n-    } else { sess.fatal(msg + ~\": \" + str::raw::from_c_str(cstr)); }\n+    } else {\n+        sess.fatal(msg + ~\": \" + str::raw::from_c_str(cstr));\n+    }\n }\n \n fn WriteOutputFile(sess: Session,\n@@ -147,7 +150,7 @@ pub mod jit {\n             };\n             let func: fn(++argv: ~[~str]) = cast::transmute(move closure);\n \n-            func(~[sess.opts.binary]);\n+            func(~[/*bad*/copy sess.opts.binary]);\n         }\n     }\n }\n@@ -177,7 +180,7 @@ mod write {\n         if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n         let mut pm = mk_pass_manager();\n         let td = mk_target_data(\n-            sess.targ_cfg.target_strs.data_layout);\n+            /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n         llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n         // FIXME (#2812): run the linter here also, once there are llvm-c\n         // bindings for it.\n@@ -438,17 +441,19 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n         let mut name: Option<~str> = None;\n         let mut vers: Option<~str> = None;\n         let mut cmh_items: ~[@ast::meta_item] = ~[];\n-        let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n-        attr::require_unique_names(sess.diagnostic(), linkage_metas);\n+        let linkage_metas =\n+            attr::find_linkage_metas(/*bad*/copy c.node.attrs);\n+        // XXX: Bad copy.\n+        attr::require_unique_names(sess.diagnostic(), copy linkage_metas);\n         for linkage_metas.each |meta| {\n             if attr::get_meta_item_name(*meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(ref v) => { name = Some((*v)); }\n+                  Some(ref v) => { name = Some((/*bad*/copy *v)); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(ref v) => { vers = Some((*v)); }\n+                  Some(ref v) => { vers = Some((/*bad*/copy *v)); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else { cmh_items.push(*meta); }\n@@ -469,7 +474,7 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n             return len_and_str(pprust::lit_to_str(@l));\n         }\n \n-        let cmh_items = attr::sort_meta_items(metas.cmh_items);\n+        let cmh_items = attr::sort_meta_items(/*bad*/copy metas.cmh_items);\n \n         symbol_hasher.reset();\n         for cmh_items.each |m| {\n@@ -504,15 +509,16 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n     fn crate_meta_name(sess: Session, _crate: ast::crate,\n                        output: &Path, metas: provided_metas) -> ~str {\n         return match metas.name {\n-              Some(ref v) => (*v),\n+              Some(ref v) => (/*bad*/copy *v),\n               None => {\n                 let name = match output.filestem() {\n                   None => sess.fatal(fmt!(\"output file name `%s` doesn't\\\n                                            appear to have a stem\",\n                                           output.to_str())),\n-                  Some(ref s) => (*s)\n+                  Some(ref s) => (/*bad*/copy *s)\n                 };\n-                warn_missing(sess, ~\"name\", name);\n+                // XXX: Bad copy.\n+                warn_missing(sess, ~\"name\", copy name);\n                 name\n               }\n             };\n@@ -521,10 +527,11 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n     fn crate_meta_vers(sess: Session, _crate: ast::crate,\n                        metas: provided_metas) -> ~str {\n         return match metas.vers {\n-              Some(ref v) => (*v),\n+              Some(ref v) => (/*bad*/copy *v),\n               None => {\n                 let vers = ~\"0.0\";\n-                warn_missing(sess, ~\"vers\", vers);\n+                // Bad copy.\n+                warn_missing(sess, ~\"vers\", copy vers);\n                 vers\n               }\n             };\n@@ -565,10 +572,11 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n     match ccx.type_hashcodes.find(t) {\n-      Some(ref h) => return (*h),\n+      Some(ref h) => return (/*bad*/copy *h),\n       None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n-        ccx.type_hashcodes.insert(t, hash);\n+        // XXX: Bad copy. Prefer `@str`?\n+        ccx.type_hashcodes.insert(t, copy hash);\n         return hash;\n       }\n     }\n@@ -625,21 +633,26 @@ fn mangle(sess: Session, ss: path) -> ~str {\n     n\n }\n \n-fn exported_name(sess: Session, path: path, hash: ~str, vers: ~str) -> ~str {\n+fn exported_name(sess: Session,\n+                 +path: path,\n+                 +hash: ~str,\n+                 +vers: ~str) -> ~str {\n     return mangle(sess,\n                   vec::append_one(\n                       vec::append_one(path, path_name(sess.ident_of(hash))),\n                       path_name(sess.ident_of(vers))));\n }\n \n-fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> ~str {\n+fn mangle_exported_name(ccx: @crate_ctxt, +path: path, t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n-    return exported_name(ccx.sess, path, hash, ccx.link_meta.vers);\n+    return exported_name(ccx.sess, path,\n+                         hash,\n+                         /*bad*/copy ccx.link_meta.vers);\n }\n \n fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n-                                     t: ty::t, name: ~str) ->\n-   ~str {\n+                                     t: ty::t,\n+                                     +name: ~str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n@@ -648,17 +661,18 @@ fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n                     path_name(ccx.sess.ident_of(hash))]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n-                                        flav: ~str) -> ~str {\n+fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt,\n+                                        +path: path,\n+                                        +flav: ~str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-fn mangle_internal_name_by_path(ccx: @crate_ctxt, path: path) -> ~str {\n+fn mangle_internal_name_by_path(ccx: @crate_ctxt, +path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: ~str) -> ~str {\n+fn mangle_internal_name_by_seq(ccx: @crate_ctxt, +flav: ~str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n \n@@ -669,7 +683,7 @@ fn link_binary(sess: Session,\n                out_filename: &Path,\n                lm: link_meta) {\n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: @session::config, stem: ~str) -> ~str {\n+    fn unlib(config: @session::config, +stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n             config.os != session::os_win32 {\n             stem.slice(3, stem.len())\n@@ -689,7 +703,7 @@ fn link_binary(sess: Session,\n \n         out_filename.dir_path().push(long_libname)\n     } else {\n-        *out_filename\n+        /*bad*/copy *out_filename\n     };\n \n     log(debug, ~\"output: \" + output.to_str());\n@@ -736,7 +750,7 @@ fn link_binary(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { cc_args.push(*arg); }\n+    for ula.each |arg| { cc_args.push(/*bad*/copy *arg); }\n \n     // # Extern library linking\n \n@@ -746,7 +760,7 @@ fn link_binary(sess: Session,\n     // to be found at compile time so it is still entirely up to outside\n     // forces to make sure that library can be found at runtime.\n \n-    let addl_paths = sess.opts.addl_lib_search_paths;\n+    let addl_paths = /*bad*/copy sess.opts.addl_lib_search_paths;\n     for addl_paths.each |path| { cc_args.push(~\"-L\" + path.to_str()); }\n \n     // The names of the extern libraries"}, {"sha": "c6b43ff6ad53a22221acb96d74cb880be75a14d3", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session;\n use metadata::cstore;\n use metadata::filesearch;\n@@ -45,7 +46,7 @@ fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n     // where rustrt is and we know every rust program needs it\n     let libs = vec::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n \n-    let target_triple = sess.opts.target_triple;\n+    let target_triple = /*bad*/copy sess.opts.target_triple;\n     let rpaths = get_rpaths(os, &sysroot, output, libs, target_triple);\n     rpaths_to_flags(rpaths)\n }\n@@ -139,8 +140,8 @@ fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let abs2 = abs2.normalize();\n     debug!(\"finding relative path from %s to %s\",\n            abs1.to_str(), abs2.to_str());\n-    let split1 = abs1.components;\n-    let split2 = abs2.components;\n+    let split1 = /*bad*/copy abs1.components;\n+    let split2 = /*bad*/copy abs2.components;\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n     assert len1 > 0;\n@@ -190,7 +191,7 @@ fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     for rpaths.each |rpath| {\n         let s = rpath.to_str();\n         if !set.contains_key(s) {\n-            minimized.push(*rpath);\n+            minimized.push(/*bad*/copy *rpath);\n             set.insert(s, ());\n         }\n     }"}, {"sha": "490ba574c5325a7b1e67cfbdc9cd55c55331e00a", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n type t = {\n     module_asm: ~str,\n     meta_sect_name: ~str,"}, {"sha": "5c9bdcf14eca8df74122962c209b4099a92d8d7f", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -36,8 +36,10 @@ fn declare_upcalls(targ_cfg: @session::config,\n     fn nothrow(f: ValueRef) -> ValueRef {\n         base::set_no_unwind(f); f\n     }\n-    let d = |a,b,c| decl(llmod, ~\"upcall_\", a, b, c);\n-    let dv = |a,b| decl(llmod, ~\"upcall_\", a, b, T_void());\n+    let d: &fn(+a: ~str, +b: ~[TypeRef], +c: TypeRef) -> ValueRef =\n+        |a,b,c| decl(llmod, ~\"upcall_\", a, b, c);\n+    let dv: &fn(+a: ~str, +b: ~[TypeRef]) -> ValueRef =\n+        |a,b| decl(llmod, ~\"upcall_\", a, b, T_void());\n \n     let int_t = T_int(targ_cfg);\n "}, {"sha": "205867feb3d4b8f4fd7475b69d6ed8504f9df050", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::target_strs;\n use driver::session;\n use metadata::loader::meta_section_name;"}, {"sha": "929634e5bd32155bae6797f320e472b50e833fba", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::target_strs;\n use driver::session;\n use metadata::loader::meta_section_name;"}, {"sha": "12573e0fc6293a13669707a372e443c7b9750882", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -9,6 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::link;\n use back::{x86, x86_64};\n use front;\n@@ -66,7 +67,7 @@ fn source_name(input: input) -> ~str {\n     }\n }\n \n-fn default_configuration(sess: Session, argv0: ~str, input: input) ->\n+fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n       session::os_win32 => ~\"msvcrt.dll\",\n@@ -96,20 +97,21 @@ fn default_configuration(sess: Session, argv0: ~str, input: input) ->\n          mk(~\"build_input\", source_name(input))];\n }\n \n-fn append_configuration(cfg: ast::crate_cfg, name: ~str) -> ast::crate_cfg {\n-    if attr::contains_name(cfg, name) {\n+fn append_configuration(+cfg: ast::crate_cfg, +name: ~str) -> ast::crate_cfg {\n+    // XXX: Bad copy.\n+    if attr::contains_name(copy cfg, copy name) {\n         return cfg;\n     } else {\n         return vec::append_one(cfg, attr::mk_word_item(name));\n     }\n }\n \n-fn build_configuration(sess: Session, argv0: ~str, input: input) ->\n+fn build_configuration(sess: Session, +argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess, argv0, input);\n-    let user_cfg = sess.opts.cfg;\n+    let user_cfg = /*bad*/copy sess.opts.cfg;\n     // If the user wants a test runner, then add the test cfg\n     let user_cfg = append_configuration(\n         user_cfg,\n@@ -128,7 +130,7 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // meta_word variant.\n     let mut words = ~[];\n     for cfgspecs.each |s| {\n-        words.push(attr::mk_word_item(*s));\n+        words.push(attr::mk_word_item(/*bad*/copy *s));\n     }\n     return words;\n }\n@@ -140,7 +142,7 @@ enum input {\n     str_input(~str)\n }\n \n-fn parse_input(sess: Session, cfg: ast::crate_cfg, input: input)\n+fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n     match input {\n       file_input(ref file) => {\n@@ -149,7 +151,7 @@ fn parse_input(sess: Session, cfg: ast::crate_cfg, input: input)\n       str_input(ref src) => {\n         // FIXME (#2319): Don't really want to box the source string\n         parse::parse_crate_from_source_str(\n-            anon_src(), @(*src), cfg, sess.parse_sess)\n+            anon_src(), @(/*bad*/copy *src), cfg, sess.parse_sess)\n       }\n     }\n }\n@@ -326,7 +328,7 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n     return {crate: crate, tcx: None};\n }\n \n-fn compile_input(sess: Session, cfg: ast::crate_cfg, input: input,\n+fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n                  outdir: &Option<Path>, output: &Option<Path>) {\n \n     let upto = if sess.opts.parse_only { cu_parse }\n@@ -336,7 +338,7 @@ fn compile_input(sess: Session, cfg: ast::crate_cfg, input: input,\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n-fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: input,\n+fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n                       ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n@@ -482,7 +484,7 @@ fn host_triple() -> ~str {\n         };\n }\n \n-fn build_session_options(binary: ~str,\n+fn build_session_options(+binary: ~str,\n                          matches: &getopts::Matches,\n                          demitter: diagnostic::emitter) -> @session::options {\n     let crate_type = if opt_present(matches, ~\"lib\") {\n@@ -527,7 +529,7 @@ fn build_session_options(binary: ~str,\n     for debug_flags.each |debug_flag| {\n         let mut this_bit = 0u;\n         for debug_map.each |pair| {\n-            let (name, _, bit) = *pair;\n+            let (name, _, bit) = /*bad*/copy *pair;\n             if name == *debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n@@ -588,7 +590,7 @@ fn build_session_options(binary: ~str,\n     let target =\n         match target_opt {\n             None => host_triple(),\n-            Some(ref s) => (*s)\n+            Some(ref s) => (/*bad*/copy *s)\n         };\n \n     let addl_lib_search_paths =\n@@ -641,7 +643,7 @@ fn build_session_(sopts: @session::options,\n     let filesearch = filesearch::mk_filesearch(\n         sopts.maybe_sysroot,\n         sopts.target_triple,\n-        sopts.addl_lib_search_paths);\n+        /*bad*/copy sopts.addl_lib_search_paths);\n     let lint_settings = lint::mk_lint_settings();\n     Session_(@{targ_cfg: target_cfg,\n                opts: sopts,\n@@ -768,7 +770,7 @@ fn build_output_filenames(input: input,\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let dirpath = match *odir {\n-          Some(ref d) => (*d),\n+          Some(ref d) => (/*bad*/copy *d),\n           None => match input {\n             str_input(_) => os::getcwd(),\n             file_input(ref ifile) => (*ifile).dir_path()\n@@ -790,9 +792,9 @@ fn build_output_filenames(input: input,\n       }\n \n       Some(ref out_file) => {\n-        out_path = (*out_file);\n+        out_path = (/*bad*/copy *out_file);\n         obj_path = if stop_after_codegen {\n-            (*out_file)\n+            (/*bad*/copy *out_file)\n         } else {\n             (*out_file).with_filetype(obj_suffix)\n         };"}, {"sha": "d645ec2d9b05471580da87361e7db3eaeb9adb18", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -208,8 +208,7 @@ impl Session {\n     fn unimpl(msg: ~str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(level: lint::level,\n-                       sp: span, msg: ~str) {\n+    fn span_lint_level(level: lint::level, sp: span, +msg: ~str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -219,8 +218,10 @@ impl Session {\n         }\n     }\n     fn span_lint(lint_mode: lint::lint,\n-                 expr_id: ast::node_id, item_id: ast::node_id,\n-                 span: span, msg: ~str) {\n+                 expr_id: ast::node_id,\n+                 item_id: ast::node_id,\n+                 span: span,\n+                 +msg: ~str) {\n         let level = lint::get_lint_settings_level(\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);\n@@ -258,9 +259,9 @@ impl Session {\n     }\n \n     fn str_of(id: ast::ident) -> ~str {\n-        *self.parse_sess.interner.get(id)\n+        /*bad*/copy *self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(st: ~str) -> ast::ident {\n+    fn ident_of(+st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)\n     }\n     fn intr() -> @syntax::parse::token::ident_interner {"}, {"sha": "7a073057f0d59fc363f96e8e95d9712e138fcdf0", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use syntax::{ast, fold, attr};\n \n use core::option;\n@@ -17,7 +18,7 @@ export strip_unconfigured_items;\n export metas_in_cfg;\n export strip_items;\n \n-type in_cfg_pred = fn@(~[ast::attribute]) -> bool;\n+type in_cfg_pred = fn@(+attrs: ~[ast::attribute]) -> bool;\n \n type ctxt = @{\n     in_cfg: in_cfg_pred\n@@ -27,7 +28,7 @@ type ctxt = @{\n // any items that do not belong in the current configuration\n fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n     do strip_items(crate) |attrs| {\n-        in_cfg(crate.node.config, attrs)\n+        in_cfg(/*bad*/copy crate.node.config, attrs)\n     }\n }\n \n@@ -40,7 +41,10 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n         @{fold_mod: |a,b| fold_mod(ctxt, a, b),\n           fold_block: fold::wrap(|a,b| fold_block(ctxt, a, b) ),\n           fold_foreign_mod: |a,b| fold_foreign_mod(ctxt, a, b),\n-          fold_item_underscore: |a,b| fold_item_underscore(ctxt, a, b),\n+          fold_item_underscore: |a,b| {\n+            // Bad copy.\n+            fold_item_underscore(ctxt, copy a, b)\n+          },\n           .. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n@@ -94,18 +98,18 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n     };\n }\n \n-fn fold_item_underscore(cx: ctxt, item: ast::item_,\n+fn fold_item_underscore(cx: ctxt, +item: ast::item_,\n                         fld: fold::ast_fold) -> ast::item_ {\n     let item = match item {\n         ast::item_impl(a, b, c, methods) => {\n             let methods = methods.filter(|m| method_in_cfg(cx, *m) );\n             ast::item_impl(a, b, c, methods)\n         }\n-        ast::item_trait(a, b, ref methods) => {\n+        ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.filter(|m| trait_method_in_cfg(cx, m) );\n-            ast::item_trait(a, b, methods)\n+            ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n         }\n-        _ => item\n+        item => item\n     };\n \n     fold::noop_fold_item_underscore(item, fld)\n@@ -131,44 +135,43 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filtered_stmts = vec::filter_map(b.stmts, |a| filter_stmt(cx, *a));\n-    return {view_items: b.view_items,\n+    return {view_items: /*bad*/copy b.view_items,\n          stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n          expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n          id: b.id,\n          rules: b.rules};\n }\n \n fn item_in_cfg(cx: ctxt, item: @ast::item) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n fn foreign_item_in_cfg(cx: ctxt, item: @ast::foreign_item) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n fn view_item_in_cfg(cx: ctxt, item: @ast::view_item) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n fn method_in_cfg(cx: ctxt, meth: @ast::method) -> bool {\n-    return (cx.in_cfg)(meth.attrs);\n+    return (cx.in_cfg)(/*bad*/copy meth.attrs);\n }\n \n fn trait_method_in_cfg(cx: ctxt, meth: &ast::trait_method) -> bool {\n     match *meth {\n-        ast::required(ref meth) => (cx.in_cfg)(meth.attrs),\n-        ast::provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n+        ast::required(ref meth) => (cx.in_cfg)(/*bad*/copy meth.attrs),\n+        ast::provided(@ref meth) => (cx.in_cfg)(/*bad*/copy meth.attrs)\n     }\n }\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n+fn in_cfg(+cfg: ast::crate_cfg, +attrs: ~[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n-fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n-\n+fn metas_in_cfg(cfg: ast::crate_cfg, +metas: ~[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, ~\"cfg\");\n \n@@ -182,7 +185,7 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n     if !has_cfg_metas { return true; }\n \n     for cfg_metas.each |cfg_mi| {\n-        if attr::contains(cfg, *cfg_mi) { return true; }\n+        if attr::contains(/*bad*/copy cfg, *cfg_mi) { return true; }\n     }\n \n     return false;"}, {"sha": "6df5e367ad1c37426b5652c98dafa0d2237f2e1d", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session::Session;\n \n use core::vec;\n@@ -61,10 +62,14 @@ fn inject_libcore_ref(sess: Session,\n                         span: dummy_sp()};\n \n             let vis = vec::append(~[vi1], crate.module.view_items);\n-            let mut new_module = { view_items: vis, ..crate.module };\n+            let mut new_module = {\n+                view_items: vis,\n+                ../*bad*/copy crate.module\n+            };\n             new_module = fld.fold_mod(new_module);\n \n-            let new_crate = { module: new_module, ..crate };\n+            // XXX: Bad copy.\n+            let new_crate = { module: new_module, ..copy crate };\n             (new_crate, span)\n         },\n         fold_mod: |module, fld| {\n@@ -80,7 +85,9 @@ fn inject_libcore_ref(sess: Session,\n                         span: dummy_sp()};\n \n             let vis = vec::append(~[vi2], module.view_items);\n-            let new_module = { view_items: vis, ..module };\n+\n+            // XXX: Bad copy.\n+            let new_module = { view_items: vis, ..copy module };\n             fold::noop_fold_mod(new_module, fld)\n         },\n         ..*fold::default_ast_fold()"}, {"sha": "08b61557fdd74eb1b17ba49a5577bc762312afab", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session::Session;\n use syntax::parse;\n use syntax::ast;\n@@ -21,7 +22,7 @@ fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n \n     let item = parse::parse_item_from_source_str(~\"<intrinsic>\",\n                                                  intrinsic_module,\n-                                                 sess.opts.cfg,\n+                                                 /*bad*/copy sess.opts.cfg,\n                                                  ~[],\n                                                  sess.parse_sess);\n     let item =\n@@ -34,6 +35,6 @@ fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n \n     let items = vec::append(~[item], crate.node.module.items);\n \n-    return @{node: {module: { items: items ,.. crate.node.module }\n-                 ,.. crate.node} ,.. *crate }\n+    return @{node: {module: { items: items ,.. /*bad*/copy crate.node.module }\n+                 ,.. /*bad*/copy crate.node} ,.. /*bad*/copy *crate }\n }"}, {"sha": "555ef837047cd4c7bcebfd5e8e0393906163a1cc", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -10,6 +10,7 @@\n \n // Code that generates a test runner to run all the tests in a crate\n \n+\n use driver::session;\n use front::config;\n use session::Session;\n@@ -45,7 +46,7 @@ fn modify_for_testing(sess: session::Session,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains(crate.node.config,\n+    let should_test = attr::contains(/*bad*/copy crate.node.config,\n                                      attr::mk_word_item(~\"test\"));\n \n     if should_test {\n@@ -101,7 +102,7 @@ fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     }\n \n     let mod_nomain =\n-        {view_items: m.view_items,\n+        {view_items: /*bad*/copy m.view_items,\n          items: vec::filter_map(m.items, |i| nomain(cx, *i))};\n     return fold::noop_fold_mod(mod_nomain, fld);\n }\n@@ -112,7 +113,7 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n \n     // Add a special __test module to the crate that will contain code\n     // generated for the test harness\n-    return {module: add_test_module(cx, folded.module),.. folded};\n+    return {module: add_test_module(cx, /*bad*/copy folded.module),.. folded};\n }\n \n \n@@ -133,7 +134,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n           _ => {\n             debug!(\"this is a test function\");\n             let test = {span: i.span,\n-                        path: cx.path, ignore: is_ignored(cx, i),\n+                        path: /*bad*/copy cx.path, ignore: is_ignored(cx, i),\n                         should_fail: should_fail(i)};\n             cx.testfns.push(test);\n             debug!(\"have %u test functions\", cx.testfns.len());\n@@ -151,7 +152,7 @@ fn is_test_fn(i: @ast::item) -> bool {\n         vec::len(attr::find_attrs_by_name(i.attrs, ~\"test\")) > 0u;\n \n     fn has_test_signature(i: @ast::item) -> bool {\n-        match i.node {\n+        match /*bad*/copy i.node {\n           ast::item_fn(decl, _, tps, _) => {\n             let input_cnt = vec::len(decl.inputs);\n             let no_output = match decl.output.node {\n@@ -169,12 +170,13 @@ fn is_test_fn(i: @ast::item) -> bool {\n }\n \n fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n-    let ignoreattrs = attr::find_attrs_by_name(i.attrs, ~\"ignore\");\n+    let ignoreattrs = attr::find_attrs_by_name(/*bad*/copy i.attrs,\n+                                               ~\"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n         |i| attr::get_meta_item_list(*i)));\n     return if vec::is_not_empty(ignoreitems) {\n-        config::metas_in_cfg(cx.crate.node.config, cfg_metas)\n+        config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n     } else {\n         false\n     }\n@@ -184,9 +186,9 @@ fn should_fail(i: @ast::item) -> bool {\n     vec::len(attr::find_attrs_by_name(i.attrs, ~\"should_fail\")) > 0u\n }\n \n-fn add_test_module(cx: test_ctxt, m: ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: test_ctxt, +m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n-    return {items: vec::append_one(m.items, testmod),.. m};\n+    return {items: vec::append_one(/*bad*/copy m.items, testmod),.. m};\n }\n \n /*\n@@ -228,7 +230,7 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n          span: dummy_sp()};\n \n     debug!(\"Synthetic test module:\\n%s\\n\",\n-           pprust::item_to_str(@item, cx.sess.intr()));\n+           pprust::item_to_str(@copy item, cx.sess.intr()));\n \n     return @item;\n }\n@@ -237,11 +239,11 @@ fn nospan<T: Copy>(t: T) -> ast::spanned<T> {\n     return {node: t, span: dummy_sp()};\n }\n \n-fn path_node(ids: ~[ast::ident]) -> @ast::path {\n+fn path_node(+ids: ~[ast::ident]) -> @ast::path {\n     @{span: dummy_sp(), global: false, idents: ids, rp: None, types: ~[]}\n }\n \n-fn path_node_global(ids: ~[ast::ident]) -> @ast::path {\n+fn path_node_global(+ids: ~[ast::ident]) -> @ast::path {\n     @{span: dummy_sp(), global: true, idents: ids, rp: None, types: ~[]}\n }\n \n@@ -271,11 +273,11 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     return @item;\n }\n \n-fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n+fn mk_path(cx: test_ctxt, +path: ~[ast::ident]) -> ~[ast::ident] {\n     // For tests that are inside of std we don't want to prefix\n     // the paths with std::\n     let is_std = {\n-        let items = attr::find_linkage_metas(cx.crate.node.attrs);\n+        let items = attr::find_linkage_metas(/*bad*/copy cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n           Some(~\"std\") => true,\n           _ => false\n@@ -325,14 +327,15 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n \n fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let span = test.span;\n-    let path = test.path;\n+    let path = /*bad*/copy test.path;\n \n     debug!(\"encoding %s\", ast_util::path_name_i(path,\n                                                 cx.sess.parse_sess.interner));\n \n+    // XXX: Bad copy of `path`.\n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(@ast_util::path_name_i(path, cx.sess.parse_sess\n-                                                   .interner)));\n+        nospan(ast::lit_str(@ast_util::path_name_i(\n+            copy path, cx.sess.parse_sess.interner)));\n     let name_expr_inner: @ast::expr =\n         @{id: cx.sess.next_node_id(),\n           callee_id: cx.sess.next_node_id(),\n@@ -401,7 +404,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n // FIXME (#1281): This can go away once fn is the type of bare function.\n fn mk_test_wrapper(cx: test_ctxt,\n-                   fn_path_expr: ast::expr,\n+                   +fn_path_expr: ast::expr,\n                    span: span) -> @ast::expr {\n     let call_expr: ast::expr = {\n         id: cx.sess.next_node_id(),"}, {"sha": "629563411895f3a3e22f0c78280c1f23cff0d4c5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use core::cast;\n use core::cmp;\n use core::int;\n@@ -1070,16 +1071,17 @@ fn SetLinkage(Global: ValueRef, Link: Linkage) {\n type type_names = @{type_names: HashMap<TypeRef, ~str>,\n                     named_types: HashMap<~str, TypeRef>};\n \n-fn associate_type(tn: type_names, s: ~str, t: TypeRef) {\n-    assert tn.type_names.insert(t, s);\n+fn associate_type(tn: type_names, +s: ~str, t: TypeRef) {\n+    // XXX: Bad copy, use @str instead?\n+    assert tn.type_names.insert(t, copy s);\n     assert tn.named_types.insert(s, t);\n }\n \n fn type_has_name(tn: type_names, t: TypeRef) -> Option<~str> {\n     return tn.type_names.find(t);\n }\n \n-fn name_has_type(tn: type_names, s: ~str) -> Option<TypeRef> {\n+fn name_has_type(tn: type_names, +s: ~str) -> Option<TypeRef> {\n     return tn.named_types.find(s);\n }\n \n@@ -1092,14 +1094,15 @@ fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n     return type_to_str_inner(names, ~[], ty);\n }\n \n-fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n+fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n     match type_has_name(names, ty) {\n-      option::Some(ref n) => return (*n),\n+      option::Some(ref n) => return (/*bad*/copy *n),\n       _ => {}\n     }\n \n-    let outer = vec::append_one(outer0, ty);\n+    // XXX: Bad copy.\n+    let outer = vec::append_one(copy outer0, ty);\n \n     let kind = llvm::LLVMGetTypeKind(ty);\n "}, {"sha": "e6a367ac1a863472e6b69b09487146b7c969b67b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // EBML enum definitions and utils shared by the encoder and decoder\n \n const tag_items: uint = 0x02u;"}, {"sha": "da33aaa460baf79c81d1c40e723ecc305f5a3c3f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n //! Validates all used crates and extern libraries and loads their metadata\n \n use metadata::cstore;\n@@ -79,7 +80,8 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n     use either::*;\n \n     if crate_cache.len() != 0u {\n-        let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n+        let name = loader::crate_name_from_metas(\n+            /*bad*/copy *crate_cache.last().metas);\n         let (matches, non_matches) =\n             partition(crate_cache.map_to_vec(|&entry| {\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n@@ -98,7 +100,8 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n             for matches.each |match_| {\n                 diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n-                    attr::mk_attr(attr::mk_list_item(~\"link\", *match_.metas))\n+                    attr::mk_attr(attr::mk_list_item(\n+                        ~\"link\", /*bad*/copy *match_.metas))\n                 ];\n                 loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n@@ -118,7 +121,7 @@ type env = @{diag: span_handler,\n              intr: @ident_interner};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n-    match i.node {\n+    match /*bad*/copy i.node {\n       ast::view_item_use(ident, meta_items, id) => {\n         debug!(\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items);\n         let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n@@ -129,7 +132,7 @@ fn visit_view_item(e: env, i: @ast::view_item) {\n }\n \n fn visit_item(e: env, i: @ast::item) {\n-    match i.node {\n+    match /*bad*/copy i.node {\n       ast::item_foreign_mod(fm) => {\n         match attr::foreign_abi(i.attrs) {\n           either::Right(abi) => {\n@@ -141,7 +144,8 @@ fn visit_item(e: env, i: @ast::item) {\n \n         let cstore = e.cstore;\n         let mut already_added = false;\n-        let link_args = attr::find_attrs_by_name(i.attrs, ~\"link_args\");\n+        let link_args = attr::find_attrs_by_name(/*bad*/copy i.attrs,\n+                                                 ~\"link_args\");\n \n         match fm.sort {\n           ast::named => {\n@@ -154,9 +158,9 @@ fn visit_item(e: env, i: @ast::item) {\n                           i.span,\n                           ~\"empty #[link_name] not allowed; use #[nolink].\");\n                    }\n-                   (*nn)\n+                   (/*bad*/copy *nn)\n                  }\n-                None => *e.intr.get(i.ident)\n+                None => /*bad*/copy *e.intr.get(i.ident)\n             };\n             if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n                 already_added = !cstore::add_used_library(cstore,\n@@ -173,7 +177,7 @@ fn visit_item(e: env, i: @ast::item) {\n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n               Some(ref linkarg) => {\n-                cstore::add_used_link_args(cstore, (*linkarg));\n+                cstore::add_used_link_args(cstore, (/*bad*/copy *linkarg));\n               }\n               None => {/* fallthrough */ }\n             }\n@@ -183,17 +187,18 @@ fn visit_item(e: env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: ~str, key: ~str, metas: ~[@ast::meta_item])\n+fn metas_with(+ident: ~str, +key: ~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, key);\n+    // XXX: Bad copies.\n+    let name_items = attr::find_meta_items_by_name(copy metas, copy key);\n     if name_items.is_empty() {\n         vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {\n         metas\n     }\n }\n \n-fn metas_with_ident(ident: ~str, metas: ~[@ast::meta_item])\n+fn metas_with_ident(+ident: ~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     metas_with(ident, ~\"name\", metas)\n }\n@@ -210,9 +215,9 @@ fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n     return None;\n }\n \n-fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n-                 hash: ~str, span: span) -> ast::crate_num {\n-    let metas = metas_with_ident(*e.intr.get(ident), metas);\n+fn resolve_crate(e: env, ident: ast::ident, +metas: ~[@ast::meta_item],\n+                 +hash: ~str, span: span) -> ast::crate_num {\n+    let metas = metas_with_ident(/*bad*/copy *e.intr.get(ident), metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -221,7 +226,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n             filesearch: e.filesearch,\n             span: span,\n             ident: ident,\n-            metas: metas,\n+            metas: copy metas,  // XXX: Bad copy.\n             hash: hash,\n             os: e.os,\n             static: e.static,\n@@ -247,8 +252,8 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n         let cname =\n             match attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n-              option::Some(ref v) => (*v),\n-              option::None => *e.intr.get(ident)\n+              option::Some(ref v) => (/*bad*/copy *v),\n+              option::None => /*bad*/copy *e.intr.get(ident)\n             };\n         let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n@@ -273,7 +278,7 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(dep.vers, ~\"vers\", ~[]);\n+        let cmetas = metas_with(/*bad*/copy dep.vers, ~\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n                *e.intr.get(dep.name), dep.vers, dep.hash);\n         match existing_match(e, metas_with_ident(*e.intr.get(cname), cmetas),\n@@ -289,8 +294,8 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = ast_util::dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, cmetas, dep.hash,\n-                                           fake_span);\n+            let local_cnum = resolve_crate(e, cname, cmetas,\n+                                           /*bad*/copy dep.hash, fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }"}, {"sha": "2dfe5bad27a22aadf205a58d88b900dc9dced995", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // Searching for information from the cstore\n \n use metadata::common::*;\n@@ -100,7 +101,8 @@ fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec::append(~[ast_map::path_mod(tcx.sess.ident_of(cdata.name))], path)\n+    vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n+        /*bad*/copy cdata.name))], path)\n }\n \n enum found_ast {"}, {"sha": "b09f2d87b6c6b68fb8ccebc7afaa9594a661f06f", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n@@ -125,10 +126,10 @@ fn add_used_crate_file(cstore: CStore, lib: &Path) {\n }\n \n fn get_used_crate_files(cstore: CStore) -> ~[Path] {\n-    return p(cstore).used_crate_files;\n+    return /*bad*/copy p(cstore).used_crate_files;\n }\n \n-fn add_used_library(cstore: CStore, lib: ~str) -> bool {\n+fn add_used_library(cstore: CStore, +lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n     if vec::contains(p(cstore).used_libraries, &lib) { return false; }\n@@ -137,15 +138,15 @@ fn add_used_library(cstore: CStore, lib: ~str) -> bool {\n }\n \n fn get_used_libraries(cstore: CStore) -> ~[~str] {\n-    return p(cstore).used_libraries;\n+    return /*bad*/copy p(cstore).used_libraries;\n }\n \n fn add_used_link_args(cstore: CStore, args: ~str) {\n     p(cstore).used_link_args.push_all(str::split_char(args, ' '));\n }\n \n fn get_used_link_args(cstore: CStore) -> ~[~str] {\n-    return p(cstore).used_link_args;\n+    return /*bad*/copy p(cstore).used_link_args;\n }\n \n fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n@@ -168,15 +169,15 @@ fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         debug!(\"Add hash[%s]: %s\", cdata.name, hash);\n-        result.push({name: cdata.name, hash: hash});\n+        result.push({name: /*bad*/copy cdata.name, hash: hash});\n     };\n     pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n     let sorted = std::sort::merge_sort(result, lteq);\n     debug!(\"sorted:\");\n     for sorted.each |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n-    fn mapper(ch: &crate_hash) -> ~str { return ch.hash; }\n+    fn mapper(ch: &crate_hash) -> ~str { return /*bad*/copy ch.hash; }\n     return vec::map(sorted, mapper);\n }\n "}, {"sha": "d4cebea66cde8c81a3da75cb8b054a331d4be72c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // Decoding metadata from a single crate's metadata\n \n use cmd = metadata::cstore::crate_metadata;\n@@ -472,7 +473,7 @@ struct path_entry {\n     def_like: def_like,\n }\n \n-fn path_entry(path_string: ~str, def_like: def_like) -> path_entry {\n+fn path_entry(+path_string: ~str, def_like: def_like) -> path_entry {\n     path_entry {\n         path_string: path_string,\n         def_like: def_like\n@@ -520,7 +521,8 @@ fn each_path(intr: @ident_interner, cdata: cmd,\n                 let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n \n                 // Hand the information off to the iteratee.\n-                let this_path_entry = path_entry(path, def_like);\n+                // XXX: Bad copy.\n+                let this_path_entry = path_entry(copy path, def_like);\n                 if !f(this_path_entry) {\n                     broken = true;      // XXX: This is awful.\n                 }\n@@ -608,15 +610,15 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(intr, item_doc));\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n-      Some(ref ii) => csearch::found((*ii)),\n+      Some(ref ii) => csearch::found((/*bad*/copy *ii)),\n       None => {\n         match item_parent_item(item_doc) {\n           Some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n             match decode_inlined_item(cdata, tcx, path,\n                                                parent_item) {\n-              Some(ref ii) => csearch::found_parent(did, (*ii)),\n+              Some(ref ii) => csearch::found_parent(did, (/*bad*/copy *ii)),\n               None => csearch::not_found\n             }\n           }\n@@ -755,7 +757,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let ty = doc_type(mth, tcx, cdata);\n         let def_id = item_def_id(mth, cdata);\n         let fty = match ty::get(ty).sty {\n-          ty::ty_fn(ref f) => (*f),\n+          ty::ty_fn(ref f) => (/*bad*/copy *f),\n           _ => {\n             tcx.diag.handler().bug(\n                 ~\"get_trait_methods: id has non-function type\");\n@@ -786,7 +788,7 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         let fty;\n         match ty::get(ty).sty {\n-            ty::ty_fn(ref f) => fty = (*f),\n+            ty::ty_fn(ref f) => fty = (/*bad*/copy *f),\n             _ => {\n                 tcx.diag.handler().bug(~\"get_provided_trait_methods(): id \\\n                                          has non-function type\");\n@@ -1027,7 +1029,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n-                {node: {style: ast::attr_outer, value: *meta_item,\n+                {node: {style: ast::attr_outer, value: /*bad*/copy *meta_item,\n                         is_sugared_doc: false},\n                  span: ast_util::dummy_sp()});\n         };\n@@ -1102,19 +1104,20 @@ fn get_crate_vers(data: @~[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n-      Some(ref ver) => (*ver),\n+      Some(ref ver) => (/*bad*/copy *ver),\n       None => ~\"0.0\"\n     };\n }\n \n fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n                     get_crate_data: GetCrateDataCb,\n-                    proc: fn(~str, ast::def_id)) {\n+                    proc: fn(+path: ~str, ast::def_id)) {\n     for each_path(intr, cdata, get_crate_data) |path_entry| {\n         match path_entry.def_like {\n             dl_impl(*) | dl_field => {}\n             dl_def(def) => {\n-                proc(path_entry.path_string, ast_util::def_id_of_def(def))\n+                proc(/*bad*/copy path_entry.path_string,\n+                     ast_util::def_id_of_def(def))\n             }\n         }\n     }"}, {"sha": "5a936e113eed0606b9c9e3fc86da8e31195523ea", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 90, "deletions": 65, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // Metadata encoding\n \n use metadata::common::*;\n@@ -233,7 +234,7 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n-      Some(ref x) => (*x),\n+      Some(ref x) => (/*bad*/copy *x),\n       None => {\n         ecx.diag.handler().bug(\n             fmt!(\"encode_symbol: id not found %d\", id));\n@@ -280,7 +281,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type(ecx, ebml_w,\n                     node_id_to_type(ecx.tcx, variant.node.id));\n         match variant.node.kind {\n-            ast::tuple_variant_kind(args)\n+            ast::tuple_variant_kind(ref args)\n                     if args.len() > 0 && ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n@@ -292,8 +293,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n             disr_val = vi[i].disr_val;\n         }\n-        encode_type_param_bounds(ebml_w, ecx, ty_params);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(variant.node.name));\n+        encode_type_param_bounds(ebml_w, ecx, /*bad*/copy ty_params);\n+        encode_path(ecx, ebml_w, /*bad*/copy path,\n+                    ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n@@ -322,7 +324,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n }\n \n fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                       md: _mod, id: node_id, path: ast_map::path,\n+                       md: _mod, id: node_id, +path: ast_map::path,\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -449,7 +451,8 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        tcx.sess.str_of(nm), id);\n                 encode_visibility(ebml_w, vis);\n                 encode_name(ecx, ebml_w, nm);\n-                encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n+                encode_path(ecx, ebml_w, /*bad*/copy path,\n+                            ast_map::path_name(nm));\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n                 encode_mutability(ebml_w, mt);\n                 encode_def_id(ebml_w, local_def(id));\n@@ -458,13 +461,13 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             unnamed_field => {}\n         }\n     }\n-    *index\n+    /*bad*/copy *index\n }\n \n // This is for encoding info for ctors and dtors\n fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                        id: node_id, ident: ident, path: ast_map::path,\n-                        item: Option<inlined_item>, tps: ~[ty_param]) {\n+                        id: node_id, ident: ident, +path: ast_map::path,\n+                        item: Option<inlined_item>, +tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n@@ -475,7 +478,8 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n+        // XXX: Bad copy.\n+        encode_path(ecx, ebml_w, copy path, ast_map::path_name(ident));\n         match item {\n            Some(ref it) => {\n              (ecx.encode_inlined_item)(ecx, ebml_w, path, (*it));\n@@ -487,10 +491,13 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                          impl_path: ast_map::path, should_inline: bool,\n+fn encode_info_for_method(ecx: @encode_ctxt,\n+                          ebml_w: writer::Encoder,\n+                          +impl_path: ast_map::path,\n+                          should_inline: bool,\n                           parent_id: node_id,\n-                          m: @method, all_tps: ~[ty_param]) {\n+                          m: @method,\n+                          +all_tps: ~[ty_param]) {\n     debug!(\"encode_info_for_method: %d %s %u\", m.id,\n            ecx.tcx.sess.str_of(m.ident), all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n@@ -501,12 +508,14 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         }\n         _ => encode_family(ebml_w, purity_fn_family(m.purity))\n     }\n+    let len = all_tps.len();\n     encode_type_param_bounds(ebml_w, ecx, all_tps);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ecx, ebml_w, m.ident);\n-    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n+    // XXX: Bad copy.\n+    encode_path(ecx, ebml_w, copy impl_path, ast_map::path_name(m.ident));\n     encode_self_type(ebml_w, m.self_ty.node);\n-    if all_tps.len() > 0u || should_inline {\n+    if len > 0u || should_inline {\n         (ecx.encode_inlined_item)(\n            ecx, ebml_w, impl_path,\n            ii_method(local_def(parent_id), m));\n@@ -544,7 +553,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                         item: @item, index: @mut ~[entry<int>],\n-                        path: ast_map::path) {\n+                        +path: ast_map::path) {\n \n     let tcx = ecx.tcx;\n     let must_write =\n@@ -564,7 +573,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     debug!(\"encoding info for item at %s\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n-    match item.node {\n+    match /*bad*/copy item.node {\n       item_const(_, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n@@ -580,11 +589,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n+        let tps_len = tps.len();\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_attributes(ebml_w, item.attrs);\n-        if tps.len() > 0u || should_inline(item.attrs) {\n+        // XXX: Bad copy.\n+        encode_path(ecx, ebml_w, copy path, ast_map::path_name(item.ident));\n+        encode_attributes(ebml_w, /*bad*/copy item.attrs);\n+        if tps_len > 0u || should_inline(item.attrs) {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n@@ -616,47 +627,50 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n-      item_enum(ref enum_definition, tps) => {\n+      item_enum(ref enum_definition, ref tps) => {\n         add_to_index();\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, tps);\n+            encode_type_param_bounds(ebml_w, ecx, /*bad*/copy *tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n             encode_name(ecx, ebml_w, item.ident);\n             for (*enum_definition).variants.each |v| {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n-            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, /*bad*/copy path,\n+                                      ii_item(item));\n+            encode_path(ecx, ebml_w, /*bad*/copy path,\n+                        ast_map::path_name(item.ident));\n             encode_region_param(ecx, ebml_w, item);\n         }\n         encode_enum_variant_info(ecx,\n                                  ebml_w,\n                                  item.id,\n-                                 (*enum_definition).variants,\n+                                 /*bad*/copy (*enum_definition).variants,\n                                  path,\n                                  index,\n-                                 tps);\n+                                 /*bad*/copy *tps);\n       }\n       item_struct(struct_def, tps) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_struct(ecx, ebml_w, path,\n-                                        struct_def.fields, index);\n+        // XXX: Bad copy of `path`.\n+        let idx = encode_info_for_struct(ecx, ebml_w, copy path,\n+                                        /*bad*/copy struct_def.fields, index);\n         /* Encode the dtor */\n         do struct_def.dtor.iter |dtor| {\n             index.push({val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_ctor(ecx, ebml_w, dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n                                    ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n-                               path, if tps.len() > 0u {\n+                               /*bad*/copy path, if tps.len() > 0u {\n                                    Some(ii_dtor(*dtor, item.ident, tps,\n                                                 local_def(item.id))) }\n-                               else { None }, tps);\n+                               else { None }, /*bad*/copy tps);\n         }\n \n         /* Index the class*/\n@@ -705,10 +719,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        // XXX: Bad copy.\n+        encode_type_param_bounds(ebml_w, ecx, copy tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, /*bad*/copy item.attrs);\n         match ty.node {\n             ast::ty_path(path, _) if path.idents.len() == 1 => {\n                 encode_impl_type_basename(ecx, ebml_w,\n@@ -725,39 +740,42 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         do opt_trait.iter() |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait);\n         }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        // XXX: Bad copy.\n+        encode_path(ecx, ebml_w, copy path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n         let impl_path = vec::append_one(path,\n                                         ast_map::path_name(item.ident));\n         for methods.each |m| {\n             index.push({val: m.id, pos: ebml_w.writer.tell()});\n-            encode_info_for_method(ecx, ebml_w, impl_path,\n-                                   should_inline(m.attrs), item.id, *m,\n-                                   vec::append(tps, m.tps));\n+            encode_info_for_method(ecx, ebml_w, /*bad*/copy impl_path,\n+                                   should_inline(/*bad*/copy m.attrs),\n+                                   item.id, *m,\n+                                   vec::append(/*bad*/copy tps, m.tps));\n         }\n       }\n-      item_trait(tps, traits, ref ms) => {\n+      item_trait(ref tps, ref traits, ref ms) => {\n         let provided_methods = dvec::DVec();\n \n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, /*bad*/copy *tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, /*bad*/copy item.attrs);\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n             match (*ms)[i] {\n               required(ref ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_def_id(ebml_w, local_def((*ty_m).id));\n                 encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx, (*ty_m).tps);\n-                encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n+                encode_type_param_bounds(ebml_w, ecx,\n+                                         /*bad*/copy (*ty_m).tps);\n+                encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'r');\n@@ -769,8 +787,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_def_id(ebml_w, local_def(m.id));\n                 encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx, m.tps);\n-                encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n+                encode_type_param_bounds(ebml_w, ecx, /*bad*/copy m.tps);\n+                encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'p');\n@@ -779,7 +797,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             }\n             i += 1u;\n         }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        // XXX: Bad copy.\n+        encode_path(ecx, ebml_w, copy path, ast_map::path_name(item.ident));\n         for traits.each |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait)\n         }\n@@ -805,7 +824,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n             encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n             encode_type(ecx, ebml_w, polyty.ty);\n-            let m_path = vec::append_one(path,\n+            let m_path = vec::append_one(/*bad*/copy path,\n                                          ast_map::path_name(item.ident));\n             encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n             ebml_w.end_tag();\n@@ -814,30 +833,33 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         // Finally, output all the provided methods as items.\n         for provided_methods.each |m| {\n             index.push({val: m.id, pos: ebml_w.writer.tell()});\n-            encode_info_for_method(ecx, ebml_w, path, true, item.id, *m,\n-                                   m.tps);\n+            encode_info_for_method(ecx, ebml_w, /*bad*/copy path,\n+                                   true, item.id, *m, /*bad*/copy m.tps);\n         }\n       }\n       item_mac(*) => fail ~\"item macros unimplemented\"\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt,\n+                                ebml_w: writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n-                                path: ast_map::path, abi: foreign_abi) {\n+                                +path: ast_map::path,\n+                                abi: foreign_abi) {\n     if !reachable(ecx, nitem.id) { return; }\n     index.push({val: nitem.id, pos: ebml_w.writer.tell()});\n \n     ebml_w.start_tag(tag_items_data_item);\n-    match nitem.node {\n+    match /*bad*/copy nitem.node {\n       foreign_item_fn(_, purity, tps) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == foreign_abi_rust_intrinsic {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path,\n+            // XXX: Bad copy of `path`.\n+            (ecx.encode_inlined_item)(ecx, ebml_w, copy path,\n                                       ii_foreign(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n@@ -869,7 +891,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             visit::visit_item(i, cx, v);\n             match ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) => {\n-                encode_info_for_item(ecx, ebml_w, i, index, *pt);\n+                encode_info_for_item(ecx, ebml_w, i, index, /*bad*/copy *pt);\n               }\n               _ => fail ~\"bad item\"\n             }\n@@ -879,7 +901,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             match ecx.tcx.items.get(ni.id) {\n               ast_map::node_foreign_item(_, abi, pt) => {\n                 encode_info_for_foreign_item(ecx, ebml_w, ni,\n-                                             index, *pt, abi);\n+                                             index, /*bad*/copy *pt, abi);\n               }\n               // case for separate item and foreign-item tables\n               _ => fail ~\"bad foreign item\"\n@@ -888,7 +910,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         ,.. *visit::default_visitor()\n     }));\n     ebml_w.end_tag();\n-    return *index;\n+    return /*bad*/copy *index;\n }\n \n \n@@ -905,7 +927,7 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n \n     let mut buckets_frozen = ~[];\n     for buckets.each |bucket| {\n-        buckets_frozen.push(@**bucket);\n+        buckets_frozen.push(@/*bad*/copy **bucket);\n     }\n     return buckets_frozen;\n }\n@@ -969,7 +991,7 @@ fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      meta_list(ref name, items) => {\n+      meta_list(ref name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::to_bytes((*name)));\n@@ -998,16 +1020,18 @@ fn encode_attributes(ebml_w: writer::Encoder, attrs: ~[attribute]) {\n // them in anyway with default values.\n fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @encode_ctxt, items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @encode_ctxt, +items: ~[@meta_item]) ->\n        attribute {\n \n         assert (ecx.link_meta.name != ~\"\");\n         assert (ecx.link_meta.vers != ~\"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(~\"name\", ecx.link_meta.name);\n+            attr::mk_name_value_item_str(~\"name\",\n+                                         /*bad*/copy ecx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(~\"vers\", ecx.link_meta.vers);\n+            attr::mk_name_value_item_str(~\"vers\",\n+                                         /*bad*/copy ecx.link_meta.vers);\n \n         let other_items =\n             {\n@@ -1026,14 +1050,14 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     for crate.node.attrs.each |attr| {\n         attrs.push(\n             if attr::get_attr_name(*attr) != ~\"link\" {\n-                *attr\n+                /*bad*/copy *attr\n             } else {\n-                match attr.node.value.node {\n+                match /*bad*/copy attr.node.value.node {\n                   meta_list(_, l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, l)\n                   }\n-                  _ => *attr\n+                  _ => /*bad*/copy *attr\n                 }\n             });\n     }\n@@ -1055,7 +1079,8 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps: ~[numdep] = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n-            let dep = {cnum: key, name: ecx.tcx.sess.ident_of(val.name),\n+            let dep = {cnum: key,\n+                       name: ecx.tcx.sess.ident_of(/*bad*/copy val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);\n@@ -1161,15 +1186,15 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         reexports2: parms.reexports2,\n         item_symbols: parms.item_symbols,\n         discrim_symbols: parms.discrim_symbols,\n-        link_meta: parms.link_meta,\n+        link_meta: /*bad*/copy parms.link_meta,\n         cstore: parms.cstore,\n         encode_inlined_item: parms.encode_inlined_item,\n         type_abbrevs: ty::new_ty_hash()\n      });\n \n     let ebml_w = writer::Encoder(wr as io::Writer);\n \n-    encode_hash(ebml_w, ecx.link_meta.extras_hash);\n+    encode_hash(ebml_w, /*bad*/copy ecx.link_meta.extras_hash);\n \n     let mut i = wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);"}, {"sha": "0401d8fcb6ca6f1be11f23807455ec75289a2019", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n@@ -45,24 +46,24 @@ trait FileSearch {\n \n fn mk_filesearch(maybe_sysroot: Option<Path>,\n                  target_triple: &str,\n-                 addl_lib_search_paths: ~[Path]) -> FileSearch {\n+                 +addl_lib_search_paths: ~[Path]) -> FileSearch {\n     type filesearch_impl = {sysroot: Path,\n                             addl_lib_search_paths: ~[Path],\n                             target_triple: ~str};\n     impl filesearch_impl: FileSearch {\n-        fn sysroot() -> Path { self.sysroot }\n+        fn sysroot() -> Path { /*bad*/copy self.sysroot }\n         fn lib_search_paths() -> ~[Path] {\n-            let mut paths = self.addl_lib_search_paths;\n+            let mut paths = /*bad*/copy self.addl_lib_search_paths;\n \n             paths.push(\n                 make_target_lib_path(&self.sysroot,\n                                      self.target_triple));\n             match get_cargo_lib_path_nearest() {\n-              result::Ok(ref p) => paths.push((*p)),\n+              result::Ok(ref p) => paths.push((/*bad*/copy *p)),\n               result::Err(_) => ()\n             }\n             match get_cargo_lib_path() {\n-              result::Ok(ref p) => paths.push((*p)),\n+              result::Ok(ref p) => paths.push((/*bad*/copy *p)),\n               result::Err(_) => ()\n             }\n             paths\n@@ -122,7 +123,7 @@ fn get_or_default_sysroot() -> Path {\n \n fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n     match maybe_sysroot {\n-      option::Some(ref sr) => (*sr),\n+      option::Some(ref sr) => (/*bad*/copy *sr),\n       option::None => get_or_default_sysroot()\n     }\n }\n@@ -146,7 +147,7 @@ fn get_cargo_root_nearest() -> Result<Path, ~str> {\n         let cwd = os::getcwd();\n         let cwd_cargo = cwd.push(\".cargo\");\n         let mut par_cargo = cwd.pop().push(\".cargo\");\n-        let mut rslt = result::Ok(cwd_cargo);\n+        let mut rslt = result::Ok(copy cwd_cargo);  // XXX: Bad copy.\n \n         if !os::path_is_dir(&cwd_cargo) && cwd_cargo != p {\n             while par_cargo != p {"}, {"sha": "818b93545cf656565092c6627823008614fdd045", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n //! Finds crate binaries and loads their metadata\n \n use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n@@ -62,7 +63,7 @@ type ctxt = {\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     match find_library_crate(cx) {\n-      Some(ref t) => return (*t),\n+      Some(ref t) => return (/*bad*/copy *t),\n       None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n@@ -72,7 +73,7 @@ fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n }\n \n fn find_library_crate(cx: ctxt) -> Option<{ident: ~str, data: @~[u8]}> {\n-    attr::require_unique_names(cx.diag, cx.metas);\n+    attr::require_unique_names(cx.diag, /*bad*/copy cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n \n@@ -90,9 +91,9 @@ fn find_library_crate_aux(cx: ctxt,\n                           nn: {prefix: ~str, suffix: ~str},\n                           filesearch: filesearch::FileSearch) ->\n    Option<{ident: ~str, data: @~[u8]}> {\n-    let crate_name = crate_name_from_metas(cx.metas);\n+    let crate_name = crate_name_from_metas(/*bad*/copy cx.metas);\n     let prefix: ~str = nn.prefix + crate_name + ~\"-\";\n-    let suffix: ~str = nn.suffix;\n+    let suffix: ~str = /*bad*/copy nn.suffix;\n \n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n@@ -127,7 +128,7 @@ fn find_library_crate_aux(cx: ctxt,\n     if matches.is_empty() {\n         None\n     } else if matches.len() == 1u {\n-        Some(matches[0])\n+        Some(/*bad*/copy matches[0])\n     } else {\n         cx.diag.span_err(\n             cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n@@ -142,12 +143,12 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> ~str {\n+fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n       Some(i) => {\n         match attr::get_meta_item_value_str(i) {\n-          Some(ref n) => (*n),\n+          Some(ref n) => (/*bad*/copy *n),\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n           _ => fail\n@@ -165,7 +166,7 @@ fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n     }\n }\n \n-fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n+fn crate_matches(crate_data: @~[u8], +metas: ~[@ast::meta_item],\n                  hash: ~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);"}, {"sha": "25a73b009a94f478e054dea146dbbf3b54ade698", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[legacy_exports];\n+\n export encoder;\n export creader;\n export cstore;"}, {"sha": "38bfaa98566312c1e0264815ed66a443f4e3288e", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // Type decoding\n \n // tjc note: Would be great to have a `match check` macro equivalent"}, {"sha": "cf1a7db07a530fc692e9c5e8ccd59c92e3a69dcf", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // Type encoding\n \n use middle::ty;\n@@ -60,12 +61,12 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(t) {\n-            Some(s) => *s,\n+            Some(s) => /*bad*/copy *s,\n             None => {\n                 let s = do io::with_str_writer |wr| {\n-                    enc_sty(wr, cx, ty::get(t).sty);\n+                    enc_sty(wr, cx, /*bad*/copy ty::get(t).sty);\n                 };\n-                cx.tcx.short_names_cache.insert(t, @s);\n+                cx.tcx.short_names_cache.insert(t, @copy s);\n                 s\n           }\n         };\n@@ -89,7 +90,7 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n               }\n               _ => {}\n             }\n-            enc_sty(w, cx, ty::get(t).sty);\n+            enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n             let end = w.tell();\n             let len = end - pos;\n             fn estimate_sz(u: uint) -> uint {\n@@ -210,7 +211,7 @@ fn enc_vstore(w: io::Writer, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n-fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n+fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n     match st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),"}, {"sha": "f6208d3b1ddb1e2f0ff9064f4037590b015a2d0a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use c = metadata::common;\n use cstore = metadata::cstore;\n use driver::session::Session;\n@@ -113,7 +114,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        tcx: ty::ctxt,\n                        maps: maps,\n-                       path: ast_map::path,\n+                       +path: ast_map::path,\n                        par_doc: ebml::Doc) -> Option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     match par_doc.opt_child(c::tag_ast) {\n@@ -129,8 +130,9 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                                           to_id_range: to_id_range});\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n+        // XXX: Bad copy of `path`.\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n-                                  dcx.tcx.items, path, ii);\n+                                  dcx.tcx.items, copy path, ii);\n         debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n         decode_side_tables(xcx, ast_doc);\n         debug!(\"< Decoded inlined fn: %s::%s\",\n@@ -261,7 +263,8 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n               ast::stmt_mac(*) => fail ~\"unexpanded macro in astencode\"\n             }\n         };\n-        let blk_sans_items = { stmts: stmts_sans_items,.. blk };\n+        // XXX: Bad copy.\n+        let blk_sans_items = { stmts: stmts_sans_items,.. copy blk };\n         fold::noop_fold_block(blk_sans_items, fld)\n     }\n \n@@ -280,11 +283,11 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(ref dtor, nm, tps, parent_id) => {\n+      ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n         let dtor_body = fld.fold_block((*dtor).node.body);\n         ast::ii_dtor({node: {body: dtor_body,\n-                              .. (*dtor).node},\n-            .. (*dtor)}, nm, tps, parent_id)\n+                              .. /*bad*/copy (*dtor).node},\n+            .. (/*bad*/copy *dtor)}, nm, /*bad*/copy *tps, parent_id)\n       }\n     }\n }\n@@ -313,16 +316,16 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(ref dtor, nm, tps, parent_id) => {\n+      ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n         let dtor_body = fld.fold_block((*dtor).node.body);\n-        let dtor_attrs = fld.fold_attributes((*dtor).node.attrs);\n-        let new_params = fold::fold_ty_params(tps, fld);\n+        let dtor_attrs = fld.fold_attributes(/*bad*/copy (*dtor).node.attrs);\n+        let new_params = fold::fold_ty_params(/*bad*/copy *tps, fld);\n         let dtor_id = fld.new_id((*dtor).node.id);\n         let new_parent = xcx.tr_def_id(parent_id);\n         let new_self = fld.new_id((*dtor).node.self_id);\n         ast::ii_dtor({node: {id: dtor_id, attrs: dtor_attrs,\n                 self_id: new_self, body: dtor_body},\n-                        .. (*dtor)},\n+                        .. (/*bad*/copy *dtor)},\n           nm, new_params, new_parent)\n       }\n      }\n@@ -520,7 +523,7 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n+    do ebml_w.emit_from_vec(/*bad*/copy *dr) |vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, *vtable_origin)\n     }\n }\n@@ -529,14 +532,14 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                       ebml_w: writer::Encoder,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n-        match vtable_origin {\n+        match /*bad*/copy vtable_origin {\n           typeck::vtable_static(def_id, tys, vtable_res) => {\n             do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n                     ebml_w.emit_def_id(def_id)\n                 }\n                 do ebml_w.emit_enum_variant_arg(1u) {\n-                    ebml_w.emit_tys(ecx, tys);\n+                    ebml_w.emit_tys(ecx, /*bad*/copy tys);\n                 }\n                 do ebml_w.emit_enum_variant_arg(2u) {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n@@ -559,7 +562,7 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                     ebml_w.emit_def_id(def_id)\n                 }\n                 do ebml_w.emit_enum_variant_arg(1u) {\n-                    ebml_w.emit_tys(ecx, tys);\n+                    ebml_w.emit_tys(ecx, /*bad*/copy tys);\n                 }\n             }\n           }\n@@ -670,7 +673,8 @@ impl writer::Encoder: ebml_writer_helpers {\n     }\n \n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n-        do self.emit_from_vec(tys) |ty| {\n+        // XXX: Bad copy.\n+        do self.emit_from_vec(copy tys) |ty| {\n             self.emit_ty(ecx, *ty)\n         }\n     }\n@@ -684,7 +688,7 @@ impl writer::Encoder: ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_rec {\n             do self.emit_field(~\"bounds\", 0u) {\n-                do self.emit_from_vec(*tpbt.bounds) |bs| {\n+                do self.emit_from_vec(/*bad*/copy *tpbt.bounds) |bs| {\n                     self.emit_bounds(ecx, *bs);\n                 }\n             }\n@@ -758,7 +762,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_node_type_subst) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                ebml_w.emit_tys(ecx, *tys)\n+                ebml_w.emit_tys(ecx, /*bad*/copy *tys)\n             }\n         }\n     }\n@@ -767,7 +771,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_freevars) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(**fv) |fv_entry| {\n+                do ebml_w.emit_from_vec(/*bad*/copy **fv) |fv_entry| {\n                     encode_freevar_entry(ebml_w, *fv_entry)\n                 }\n             }"}, {"sha": "4370707e665548d17d0a64cef3e9bacf6f893864", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -17,6 +17,7 @@\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves to dnot affect things loaned out in any way\n \n+\n use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty;\n \n@@ -631,7 +632,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n         Some(ReadValue) | Some(CopyValue) | None => {}\n     }\n \n-    match expr.node {\n+    match /*bad*/copy expr.node {\n       ast::expr_path(*) if self.bccx.last_use_map.contains_key(expr.id) => {\n         self.check_last_use(expr);\n       }"}, {"sha": "9524980a1f94fe5e1936f879a47602658c0d32bb", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -16,6 +16,7 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n+\n use middle::borrowck::preserve::{preserve_condition, pc_ok, pc_if_pure};\n use middle::mem_categorization::{mem_categorization_ctxt, opt_deref_kind};\n use middle::pat_util;\n@@ -122,7 +123,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n     }\n \n     // Special checks for various kinds of expressions:\n-    match ex.node {\n+    match /*bad*/copy ex.node {\n       ast::expr_addr_of(mutbl, base) => {\n         let base_cmt = self.bccx.cat_expr(base);\n "}, {"sha": "6539cb0c6c3cc2cc5c6a07ea13fc8aef2445d906", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -12,6 +12,7 @@\n // Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n // of the scope S, presuming that the returned set of loans `Ls` are honored.\n \n+\n use middle::ty;\n \n use core::result::{Result, Ok, Err};"}, {"sha": "1cd88aa8197c7c3ea8bee196384d63cd93310c57", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -519,11 +519,11 @@ impl borrowck_ctxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn span_err(s: span, m: ~str) {\n+    fn span_err(s: span, +m: ~str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(s: span, m: ~str) {\n+    fn span_note(s: span, +m: ~str) {\n         self.tcx.sess.span_note(s, m);\n     }\n "}, {"sha": "220685e58cab89245b8ab08e6cf33313da83bb6a", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -13,6 +13,7 @@\n // the scope S.\n //\n \n+\n use middle::ty;\n \n use syntax::ast;"}, {"sha": "86d9151ae9b501f2850f6dba71622404b248b008", "filename": "src/librustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcapture.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::freevars;\n use middle::ty;\n "}, {"sha": "bdd2b06e6abf65dea9260bf3a192cab2babebd03", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::const_eval::{compare_const_vals, lookup_const_by_id};\n use middle::const_eval::{eval_const_expr, const_val, const_int, const_bool};\n use middle::pat_util::*;\n@@ -73,7 +74,7 @@ fn check_expr(cx: @AltCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n                                             arm.pats);\n         }\n \n-        check_arms(cx, (*arms));\n+        check_arms(cx, (/*bad*/copy *arms));\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n          // types.\n@@ -215,7 +216,7 @@ impl ctor : cmp::Eq {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: @AltCheckCtxt, m: matrix, v: ~[@pat]) -> useful {\n+fn is_useful(cx: @AltCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match vec::find(m, |r| r[0].id != 0) {\n@@ -238,30 +239,30 @@ fn is_useful(cx: @AltCheckCtxt, m: matrix, v: ~[@pat]) -> useful {\n                                           val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n-                  ref u => (*u)\n+                  ref u => (/*bad*/copy *u)\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n                 for (*ty::enum_variants(cx.tcx, eid)).each |va| {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n-                      ref u => return (*u)\n+                      ref u => return (/*bad*/copy *u)\n                     }\n                 }\n                 not_useful\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                 let max_len = do m.foldr(0) |r, max_len| {\n-                  match r[0].node {\n+                  match /*bad*/copy r[0].node {\n                     pat_vec(elems, _) => uint::max(elems.len(), max_len),\n                     _ => max_len\n                   }\n                 };\n                 for uint::range(0, max_len + 1) |n| {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n-                    ref u => return (*u)\n+                    ref u => return (/*bad*/copy *u)\n                   }\n                 }\n                 not_useful\n@@ -275,33 +276,33 @@ fn is_useful(cx: @AltCheckCtxt, m: matrix, v: ~[@pat]) -> useful {\n           Some(ref ctor) => {\n             match is_useful(cx, vec::filter_map(m, |r| default(cx, *r)),\n                             vec::tail(v)) {\n-              useful_ => useful(left_ty, (*ctor)),\n-              ref u => (*u)\n+              useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n+              ref u => (/*bad*/copy *u)\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n         let arity = ctor_arity(cx, (*v0_ctor), left_ty);\n-        is_useful_specialized(cx, m, v, (*v0_ctor), arity, left_ty)\n+        is_useful_specialized(cx, m, v, /*bad*/copy *v0_ctor, arity, left_ty)\n       }\n     }\n }\n \n-fn is_useful_specialized(cx: @AltCheckCtxt, m: matrix, v: ~[@pat], ctor: ctor,\n-                          arity: uint, lty: ty::t) -> useful {\n+fn is_useful_specialized(cx: @AltCheckCtxt, m: matrix, +v: ~[@pat],\n+                         +ctor: ctor, arity: uint, lty: ty::t) -> useful {\n     let ms = vec::filter_map(m, |r| specialize(cx, *r, ctor, arity, lty));\n     let could_be_useful = is_useful(\n         cx, ms, specialize(cx, v, ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n-      ref u => (*u)\n+      ref u => (/*bad*/copy *u)\n     }\n }\n \n fn pat_ctor_id(cx: @AltCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n-    match pat.node {\n+    match /*bad*/copy pat.node {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n         match cx.tcx.def_map.find(pat.id) {\n@@ -367,7 +368,7 @@ fn missing_ctor(cx: @AltCheckCtxt,\n         for m.each |r| {\n             do option::iter(&pat_ctor_id(cx, r[0])) |id| {\n                 if !vec::contains(found, id) {\n-                    found.push(*id);\n+                    found.push(/*bad*/copy *id);\n                 }\n             }\n         }\n@@ -400,7 +401,7 @@ fn missing_ctor(cx: @AltCheckCtxt,\n \n         // Find the lengths and tails of all vector patterns.\n         let vec_pat_lens = do m.filter_map |r| {\n-            match r[0].node {\n+            match /*bad*/copy r[0].node {\n                 pat_vec(elems, tail) => {\n                     Some((elems.len(), tail.is_some()))\n                 }\n@@ -451,7 +452,7 @@ fn missing_ctor(cx: @AltCheckCtxt,\n }\n \n fn ctor_arity(cx: @AltCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n-    match ty::get(ty).sty {\n+    match /*bad*/copy ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n       ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n@@ -481,7 +482,7 @@ fn wild() -> @pat {\n fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n               left_ty: ty::t) -> Option<~[@pat]> {\n     let r0 = raw_pat(r[0]);\n-    match r0.node {\n+    match /*bad*/copy r0.node {\n       pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n                                    vec::tail(r))),\n       pat_ident(_, _, _) => {\n@@ -530,7 +531,7 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n       }\n       pat_rec(flds, _) => {\n-        let ty_flds = match ty::get(left_ty).sty {\n+        let ty_flds = match /*bad*/copy ty::get(left_ty).sty {\n             ty::ty_rec(flds) => flds,\n             _ => fail ~\"bad type for pat_rec\"\n         };\n@@ -602,8 +603,8 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       }\n       pat_range(lo, hi) => {\n         let (c_lo, c_hi) = match ctor_id {\n-          val(ref v) => ((*v), (*v)),\n-          range(ref lo, ref hi) => ((*lo), (*hi)),\n+          val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n+          range(ref lo, ref hi) => ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n           single => return Some(vec::tail(r)),\n           _ => fail ~\"type error\"\n         };\n@@ -617,8 +618,9 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         match ctor_id {\n           vec(_) => {\n             if elems.len() < arity && tail.is_some() {\n+              // XXX: Bad copy.\n               Some(vec::append(\n-                vec::append(elems, vec::from_elem(\n+                vec::append(copy elems, vec::from_elem(\n                     arity - elems.len(), wild()\n                 )),\n                 vec::tail(r)\n@@ -683,7 +685,7 @@ fn is_refutable(cx: @AltCheckCtxt, pat: &pat) -> bool {\n       _ => ()\n     }\n \n-    match pat.node {\n+    match /*bad*/copy pat.node {\n       pat_box(sub) | pat_uniq(sub) | pat_region(sub) |\n       pat_ident(_, _, Some(sub)) => {\n         is_refutable(cx, sub)"}, {"sha": "13df0b73db0c32fb0ef96498c67eea897d419444", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session::Session;\n use middle::resolve;\n use middle::ty;"}, {"sha": "884438432704558ce2514dfa9bdacec120c5201a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n \n use syntax::ast::*;"}, {"sha": "dbde060c6f595d809c9e781eb68ff542311fcde3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::resolve;\n use middle::ty;\n use middle;\n@@ -79,7 +80,7 @@ fn classify(e: @expr,\n       Some(x) => x,\n       None => {\n         let cn =\n-            match e.node {\n+            match /*bad*/copy e.node {\n               ast::expr_lit(lit) => {\n                 match lit.node {\n                   ast::lit_str(*) |\n@@ -241,8 +242,8 @@ impl const_val : cmp::Eq {\n \n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n-        Ok(ref r) => (*r),\n-        Err(ref s) => fail (*s)\n+        Ok(ref r) => (/*bad*/copy *r),\n+        Err(ref s) => fail (/*bad*/copy *s)\n     }\n }\n \n@@ -258,7 +259,7 @@ fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n           Ok(const_str(_)) => Err(~\"Negate on string\"),\n           Ok(const_bool(_)) => Err(~\"Negate on boolean\"),\n-          ref err => (*err)\n+          ref err => (/*bad*/copy *err)\n         }\n       }\n       expr_unary(not, inner) => {\n@@ -405,7 +406,7 @@ fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n \n fn lit_to_const(lit: @lit) -> const_val {\n     match lit.node {\n-      lit_str(s) => const_str(*s),\n+      lit_str(s) => const_str(/*bad*/copy *s),\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),"}, {"sha": "9b718ec3beecdc27eea9cac1c53c24c022f47563", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // A pass that annotates for each loops and functions with the free\n // variables that they contain.\n \n@@ -92,7 +93,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n     let v = visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr,\n                            .. *visit::default_visitor()});\n     (v.visit_block)(blk, 1, v);\n-    return @*refs;\n+    return @/*bad*/copy *refs;\n }\n \n // Build a map from every function and for-each body to a set of the"}, {"sha": "671a0a2dc81368b4df51fcc227aa493a5c4a2ba1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::freevars::freevar_entry;\n use middle::freevars;\n use middle::lint::{non_implicitly_copyable_typarams, implicit_copies};\n@@ -296,7 +297,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n     }\n \n-    match e.node {\n+    match /*bad*/copy e.node {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(Some(ex)) => {\n@@ -329,7 +330,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n           Some(ex) => {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n-            let ty_fields = match ty::get(t).sty {\n+            let ty_fields = match /*bad*/copy ty::get(t).sty {\n               ty::ty_rec(f) => f,\n               ty::ty_struct(did, ref substs) =>\n                   ty::struct_fields(cx.tcx, did, &(*substs)),\n@@ -407,7 +408,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n \n fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     match stmt.node {\n-      stmt_decl(@{node: decl_local(locals), _}, _) => {\n+      stmt_decl(@{node: decl_local(ref locals), _}, _) => {\n         for locals.each |local| {\n             match local.node.init {\n               Some(expr) =>\n@@ -614,7 +615,7 @@ fn check_cast_for_escaping_regions(\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     let target_substs = match ty::get(target_ty).sty {\n-      ty::ty_trait(_, ref substs, _) => {(*substs)}\n+      ty::ty_trait(_, ref substs, _) => {(/*bad*/copy *substs)}\n       _ => { return; /* not a cast to a trait */ }\n     };\n "}, {"sha": "8c887139b70f171dc8d4d2105153766799ba8370", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // Detecting language items.\n //\n // Language items are items that represent concepts intrinsic to the language\n@@ -287,8 +288,8 @@ impl LanguageItemCollector {\n                 match literal.node {\n                     lit_str(value) => {\n                         self.match_and_collect_item(item_def_id,\n-                                                    (*key),\n-                                                    *value);\n+                                                    (/*bad*/copy *key),\n+                                                    /*bad*/copy *value);\n                     }\n                     _ => {} // Skip.\n                 }"}, {"sha": "77a63b187782859c32b5167ed485d1a1d852c9e7", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session::Session;\n use driver::session;\n use middle::pat_util::{pat_bindings};\n@@ -310,7 +311,7 @@ impl ctxt {\n         }\n     }\n \n-    fn span_lint(level: level, span: span, msg: ~str) {\n+    fn span_lint(level: level, span: span, +msg: ~str) {\n         self.sess.span_lint_level(level, span, msg);\n     }\n \n@@ -327,15 +328,17 @@ impl ctxt {\n         for [allow, warn, deny, forbid].each |level| {\n             let level_name = level_to_str(*level);\n             let metas =\n-                attr::attr_metas(attr::find_attrs_by_name(attrs,\n+                attr::attr_metas(attr::find_attrs_by_name(/*bad*/copy attrs,\n                                                           level_name));\n             for metas.each |meta| {\n-                match meta.node {\n+                match /*bad*/copy meta.node {\n                   ast::meta_list(_, metas) => {\n                     for metas.each |meta| {\n                         match meta.node {\n                           ast::meta_word(ref lintname) => {\n-                            triples.push((*meta, *level, *lintname));\n+                            triples.push((*meta,\n+                                          *level,\n+                                          /*bad*/copy *lintname));\n                           }\n                           _ => {\n                             self.sess.span_err(\n@@ -354,7 +357,7 @@ impl ctxt {\n         }\n \n         for triples.each |pair| {\n-            let (meta, level, lintname) = *pair;\n+            let (meta, level, lintname) = /*bad*/copy *pair;\n             match self.dict.find(lintname) {\n               None => {\n                 self.span_lint(\n@@ -394,7 +397,7 @@ impl ctxt {\n \n \n fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n-    do cx.with_lint_attrs(i.attrs) |cx| {\n+    do cx.with_lint_attrs(/*bad*/copy i.attrs) |cx| {\n         if !cx.is_default {\n             cx.sess.lint_settings.settings_map.insert(i.id, cx.curr);\n         }\n@@ -418,7 +421,7 @@ fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n         cx.set_level(lint, level);\n     }\n \n-    do cx.with_lint_attrs(crate.node.attrs) |cx| {\n+    do cx.with_lint_attrs(/*bad*/copy crate.node.attrs) |cx| {\n         // Copy out the default settings\n         for cx.curr.each |k, v| {\n             sess.lint_settings.default_settings.insert(k, v);\n@@ -538,7 +541,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         } else {\n             binop\n         };\n-        match ty::get(ty::expr_ty(cx, @*expr)).sty {\n+        match ty::get(ty::expr_ty(cx, @/*bad*/copy *expr)).sty {\n             ty::ty_int(int_ty) => {\n                 let (min, max) = int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n@@ -597,7 +600,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n-    match item.node {\n+    match /*bad*/copy item.node {\n         ast::item_trait(_, _, methods) => {\n             for methods.each |method| {\n                 match *method {\n@@ -630,10 +633,10 @@ fn check_item_deprecated_self(cx: ty::ctxt, item: @ast::item) {\n               parameter or mark the method as static\");\n     }\n \n-    match item.node {\n+    match /*bad*/copy item.node {\n         ast::item_trait(_, _, methods) => {\n             for methods.each |method| {\n-                match *method {\n+                match /*bad*/copy *method {\n                     ast::required(ty_method) => {\n                         maybe_warn(cx, item, ty_method.self_ty);\n                     }\n@@ -701,10 +704,11 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n     }\n \n     match it.node {\n-      ast::item_foreign_mod(nmod) if attr::foreign_abi(it.attrs) !=\n-      either::Right(ast::foreign_abi_rust_intrinsic) => {\n+      ast::item_foreign_mod(ref nmod)\n+      if attr::foreign_abi(it.attrs) !=\n+            either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n-            match ni.node {\n+            match /*bad*/copy ni.node {\n               ast::foreign_item_fn(decl, _, _) => {\n                 check_foreign_fn(cx, it.id, decl);\n               }\n@@ -812,14 +816,14 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n             !ident.contains_char('_')\n     }\n \n-    fn ident_without_trailing_underscores(ident: ~str) -> ~str {\n+    fn ident_without_trailing_underscores(+ident: ~str) -> ~str {\n         match str::rfind(ident, |c| c != '_') {\n             Some(idx) => (ident).slice(0, idx + 1),\n             None => { ident } // all underscores\n         }\n     }\n \n-    fn ident_without_leading_underscores(ident: ~str) -> ~str {\n+    fn ident_without_leading_underscores(+ident: ~str) -> ~str {\n         match str::find(ident, |c| c != '_') {\n           Some(idx) => ident.slice(idx, ident.len()),\n           None => {"}, {"sha": "91e6ed289bd1471708ec6155f1efbcd4bedcf652", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n /*!\n  * A classic liveness analysis based on dataflow over the AST.  Computes,\n  * for each local variable in a function, whether that variable is live\n@@ -1032,7 +1033,7 @@ impl Liveness {\n     }\n \n     fn propagate_through_decl(decl: @decl, succ: LiveNode) -> LiveNode {\n-        match decl.node {\n+        match /*bad*/copy decl.node {\n           decl_local(locals) => {\n             do locals.foldr(succ) |local, succ| {\n                 self.propagate_through_local(*local, succ)\n@@ -1081,7 +1082,7 @@ impl Liveness {\n         debug!(\"propagate_through_expr: %s\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n-        match expr.node {\n+        match /*bad*/copy expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n           expr_path(_) => {\n@@ -1562,7 +1563,7 @@ fn check_call(args: &[@expr],\n }\n \n fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n-    match expr.node {\n+    match /*bad*/copy expr.node {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);"}, {"sha": "1bbdc699377a2febf6417f4c5041b9e76727a24c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n /*!\n  * # Categorization\n  *\n@@ -913,7 +914,7 @@ impl &mem_categorization_ctxt {\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                self.cmt_to_repr(cmt));\n \n-        match pat.node {\n+        match /*bad*/copy pat.node {\n           ast::pat_wild => {\n             // _\n           }\n@@ -1117,7 +1118,7 @@ fn field_mutbl(tcx: ty::ctxt,\n                f_name: ast::ident,\n                node_id: ast::node_id) -> Option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n-    match ty::get(base_ty).sty {\n+    match /*bad*/copy ty::get(base_ty).sty {\n       ty::ty_rec(fields) => {\n         for fields.each |f| {\n             if f.ident == f_name {"}, {"sha": "a736b3d2fa6a4663e2f82d59d06b4c912096afa1", "filename": "src/librustc/middle/mode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fmode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fmode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmode.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::pat_util;\n use middle::ty;\n use middle::ty::{CopyValue, MoveValue, ReadValue, ValueMode, ctxt};\n@@ -89,7 +90,7 @@ fn compute_modes_for_expr(expr: @expr,\n         }\n     };\n \n-    match expr.node {\n+    match /*bad*/copy expr.node {\n         expr_call(callee, args, is_block) => {\n             let callee_cx = VisitContext { mode: ReadValue, ..cx };\n             compute_modes_for_expr(callee, callee_cx, v);"}, {"sha": "54d3180dbe49f0f323df36010f7acbeee0d91da6", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::resolve;\n use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty;"}, {"sha": "1aa3017083c84bda77f94ea019990f283c4769a4", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n // A pass that checks to make sure private fields and methods aren't used\n // outside their scopes.\n \n@@ -311,7 +312,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n             visit::visit_expr(expr, method_map, visitor);\n         },\n         visit_pat: |pattern, method_map, visitor| {\n-            match pattern.node {\n+            match /*bad*/copy pattern.node {\n                 pat_struct(_, fields, _) => {\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {"}, {"sha": "3a263347536210a16d038452f4ab1faf9d4dfdde", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -17,6 +17,7 @@ region parameterized.\n \n */\n \n+\n use driver::session::Session;\n use metadata::csearch;\n use middle::resolve;"}, {"sha": "625ed9076e7186257913514b54ebf3a8d1841e25", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session::Session;\n use metadata::csearch::{each_path, get_method_names_if_trait};\n use metadata::csearch::{get_static_methods_if_impl, get_type_name_if_impl};\n@@ -1126,7 +1127,7 @@ impl Resolver {\n         };\n         let privacy = visibility_to_privacy(item.vis, legacy);\n \n-        match item.node {\n+        match /*bad*/copy item.node {\n             item_mod(module_) => {\n                 let legacy = has_legacy_export_attr(item.attrs);\n                 let (name_bindings, new_parent) =\n@@ -1458,7 +1459,7 @@ impl Resolver {\n           ModuleReducedGraphParent(m) => m.legacy_exports\n         };\n         let privacy = visibility_to_privacy(view_item.vis, legacy);\n-        match view_item.node {\n+        match /*bad*/copy view_item.node {\n             view_item_import(view_paths) => {\n                 for view_paths.each |view_path| {\n                     // Extract and intern the module part of the path. For\n@@ -1626,7 +1627,7 @@ impl Resolver {\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n-        match foreign_item.node {\n+        match /*bad*/copy foreign_item.node {\n             foreign_item_fn(_, purity, type_parameters) => {\n                 let def = def_fn(local_def(foreign_item.id), purity);\n                 (*name_bindings).define_value(Public, def, foreign_item.span);\n@@ -1809,7 +1810,7 @@ impl Resolver {\n \n             let mut current_module = root;\n             for pieces.each |ident_str| {\n-                let ident = self.session.ident_of(*ident_str);\n+                let ident = self.session.ident_of(/*bad*/copy *ident_str);\n                 // Create or reuse a graph node for the child.\n                 let (child_name_bindings, new_parent) =\n                     self.add_child(ident,\n@@ -1869,17 +1870,14 @@ impl Resolver {\n                 }\n                 dl_impl(def) => {\n                     // We only process static methods of impls here.\n-                    debug!(\"(building reduced graph for external crate) \\\n-                            processing impl %s\", final_ident_str);\n-\n                     match get_type_name_if_impl(self.session.cstore, def) {\n                         None => {}\n                         Some(final_ident) => {\n                             let static_methods_opt =\n                                 get_static_methods_if_impl(\n                                     self.session.cstore, def);\n                             match static_methods_opt {\n-                                Some(static_methods) if\n+                                Some(ref static_methods) if\n                                     static_methods.len() >= 1 => {\n                                     debug!(\"(building reduced graph for \\\n                                             external crate) processing \\\n@@ -1955,7 +1953,7 @@ impl Resolver {\n                 }\n                 dl_field => {\n                     debug!(\"(building reduced graph for external crate) \\\n-                            ignoring field %s\", final_ident_str);\n+                            ignoring field\");\n                 }\n             }\n         }\n@@ -3816,15 +3814,16 @@ impl Resolver {\n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n         let orig_xray_flag = self.xray_context;\n-        if contains_name(attr_metas(item.attrs), ~\"!resolve_unexported\") {\n+        if contains_name(attr_metas(/*bad*/copy item.attrs),\n+                         ~\"!resolve_unexported\") {\n             self.xray_context = Xray;\n         }\n \n-        match item.node {\n+        match /*bad*/copy item.node {\n \n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n-            item_enum(ref enum_def, type_parameters) => {\n+            item_enum(ref enum_def, ref type_parameters) => {\n \n                 for (*enum_def).variants.each() |variant| {\n                     do variant.node.disr_expr.iter() |dis_expr| {\n@@ -3839,11 +3838,9 @@ impl Resolver {\n                 // n.b. the discr expr gets visted twice.\n                 // but maybe it's okay since the first time will signal an\n                 // error if there is one? -- tjc\n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0,\n-                                           NormalRibKind))\n-                        || {\n-\n+                do self.with_type_parameter_rib(\n+                    HasTypeParameters(\n+                        type_parameters, item.id, 0, NormalRibKind)) {\n                     visit_item(item, (), visitor);\n                 }\n             }\n@@ -3871,7 +3868,7 @@ impl Resolver {\n                                             visitor);\n             }\n \n-            item_trait(type_parameters, traits, ref methods) => {\n+            item_trait(ref type_parameters, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n@@ -3880,10 +3877,11 @@ impl Resolver {\n \n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0,\n+                        (HasTypeParameters(type_parameters, item.id, 0,\n                                            NormalRibKind)) {\n \n-                    self.resolve_type_parameters(type_parameters, visitor);\n+                    self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                                                 visitor);\n \n                     // Resolve derived traits.\n                     for traits.each |trt| {\n@@ -3922,8 +3920,9 @@ impl Resolver {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n-                                self.resolve_type_parameters((*ty_m).tps,\n-                                                             visitor);\n+                                self.resolve_type_parameters(\n+                                    /*bad*/copy (*ty_m).tps,\n+                                    visitor);\n \n                                 for (*ty_m).decl.inputs.each |argument| {\n                                     self.resolve_type(argument.ty, visitor);\n@@ -3949,7 +3948,7 @@ impl Resolver {\n             item_struct(struct_def, ty_params) => {\n                 self.resolve_struct(item.id,\n                                    @copy ty_params,\n-                                   struct_def.fields,\n+                                   /*bad*/copy struct_def.fields,\n                                    struct_def.dtor,\n                                    visitor);\n             }\n@@ -3964,7 +3963,7 @@ impl Resolver {\n             item_foreign_mod(foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n-                        match foreign_item.node {\n+                        match /*bad*/copy foreign_item.node {\n                             foreign_item_fn(_, _, type_parameters) => {\n                                 do self.with_type_parameter_rib\n                                     (HasTypeParameters(&type_parameters,\n@@ -3986,7 +3985,7 @@ impl Resolver {\n                 }\n             }\n \n-            item_fn(fn_decl, _, ty_params, ref block) => {\n+            item_fn(ref fn_decl, _, ref ty_params, ref block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 //\n@@ -4001,9 +4000,9 @@ impl Resolver {\n                 }\n \n                 self.resolve_function(OpaqueFunctionRibKind,\n-                                      Some(@fn_decl),\n+                                      Some(@/*bad*/copy *fn_decl),\n                                       HasTypeParameters\n-                                        (&ty_params,\n+                                        (ty_params,\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n@@ -4128,7 +4127,8 @@ impl Resolver {\n                     // Continue.\n                 }\n                 HasTypeParameters(type_parameters, _, _, _) => {\n-                    self.resolve_type_parameters(*type_parameters, visitor);\n+                    self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                                                 visitor);\n                 }\n             }\n \n@@ -4200,7 +4200,8 @@ impl Resolver {\n                                          OpaqueFunctionRibKind)) {\n \n             // Resolve the type parameters.\n-            self.resolve_type_parameters(*type_parameters, visitor);\n+            self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                                         visitor);\n \n             // Resolve fields.\n             for fields.each |field| {\n@@ -4247,7 +4248,7 @@ impl Resolver {\n         };\n \n         self.resolve_function(rib_kind,\n-                              Some(@method.decl),\n+                              Some(@/*bad*/copy method.decl),\n                               type_parameters,\n                               method.body,\n                               self_binding,\n@@ -4269,7 +4270,8 @@ impl Resolver {\n                                         (borrowed_type_parameters, id, 0,\n                                          NormalRibKind)) {\n             // Resolve the type parameters.\n-            self.resolve_type_parameters(type_parameters, visitor);\n+            self.resolve_type_parameters(/*bad*/copy type_parameters,\n+                                         visitor);\n \n             // Resolve the trait reference, if necessary.\n             let original_trait_refs = self.current_trait_refs;\n@@ -5114,7 +5116,8 @@ impl Resolver {\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name = self.idents_to_str(path.idents);\n+                        let wrong_name = self.idents_to_str(\n+                            /*bad*/copy path.idents);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n                             self.session.span_err(expr.span,\n                                         fmt!(\"unresolved name: `%s`. \\\n@@ -5133,10 +5136,10 @@ impl Resolver {\n                 visit_expr(expr, (), visitor);\n             }\n \n-            expr_fn(_, fn_decl, ref block, capture_clause) |\n-            expr_fn_block(fn_decl, ref block, capture_clause) => {\n+            expr_fn(_, ref fn_decl, ref block, capture_clause) |\n+            expr_fn_block(ref fn_decl, ref block, capture_clause) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n-                                      Some(@fn_decl),\n+                                      Some(@/*bad*/copy *fn_decl),\n                                       NoTypeParameters,\n                                       (*block),\n                                       NoSelfBinding,"}, {"sha": "a183bd453d0e7831454f7a5196a422c4069c96b8", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -142,6 +142,7 @@\n  *\n  */\n \n+\n use back::abi;\n use lib::llvm::llvm;\n use lib::llvm::{ValueRef, BasicBlockRef};\n@@ -499,7 +500,7 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     let tcx = bcx.tcx();\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n-        match p.node {\n+        match /*bad*/copy p.node {\n             ast::pat_enum(_, subpats) => {\n                 if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     Some(option::get_or_default(subpats,\n@@ -600,7 +601,7 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n \n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        match p.node {\n+        match /*bad*/copy p.node {\n             ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n                 let mut pats = ~[];\n                 for vec::each(fields) |fname| {\n@@ -632,7 +633,7 @@ fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n \n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        match p.node {\n+        match /*bad*/copy p.node {\n             ast::pat_tup(elts) => {\n                 Some(elts)\n             }\n@@ -657,7 +658,7 @@ fn enter_tuple_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n \n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        match p.node {\n+        match /*bad*/copy p.node {\n             ast::pat_enum(_, Some(elts)) => Some(elts),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n@@ -754,7 +755,7 @@ fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n     let found = DVec();\n     for vec::each(m) |br| {\n         let cur = br.pats[col];\n-        match cur.node {\n+        match /*bad*/copy cur.node {\n             ast::pat_lit(l) => {\n                 add_to_set(ccx.tcx, &found, lit(ExprLit(l)));\n             }\n@@ -812,7 +813,10 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n-      ty::ty_enum(id, ref substs) => { assert id == vdefs.enm; (*substs).tps }\n+      ty::ty_enum(id, ref substs) => {\n+        assert id == vdefs.enm;\n+        /*bad*/copy (*substs).tps\n+      }\n       _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n     };\n     let mut blobptr = val;\n@@ -828,7 +832,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     let vdefs_var = vdefs.var;\n     let args = do vec::from_fn(size) |i| {\n         GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n-                 enum_ty_substs, i)\n+                 /*bad*/copy enum_ty_substs, i)\n     };\n     return {vals: args, bcx: bcx};\n }\n@@ -873,7 +877,7 @@ fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n                                    ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n-        match br.pats[col].node {\n+        match /*bad*/copy br.pats[col].node {\n           ast::pat_rec(fs, _) => extend(&mut fields, fs),\n           ast::pat_struct(_, fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n@@ -1259,7 +1263,7 @@ fn compile_submatch(bcx: block,\n \n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n-        let n_tup_elts = match ty::get(tup_ty).sty {\n+        let n_tup_elts = match /*bad*/copy ty::get(tup_ty).sty {\n           ty::ty_tup(elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n@@ -1485,7 +1489,7 @@ fn compile_submatch(bcx: block,\n             var(_, vdef) => {\n                 let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n                 size = args.vals.len();\n-                unpacked = args.vals;\n+                unpacked = /*bad*/copy args.vals;\n                 opt_cx = args.bcx;\n             }\n             vec_len_eq(n) | vec_len_ge(n) => {\n@@ -1495,7 +1499,7 @@ fn compile_submatch(bcx: block,\n                 };\n                 let args = extract_vec_elems(opt_cx, pat_id, n, tail, val);\n                 size = args.vals.len();\n-                unpacked = args.vals;\n+                unpacked = /*bad*/copy args.vals;\n                 opt_cx = args.bcx;\n             }\n             lit(_) | range(_, _) => ()\n@@ -1634,7 +1638,7 @@ fn trans_alt_inner(scope_cx: block,\n \n     return controlflow::join_blocks(scope_cx, dvec::unwrap(move arm_cxs));\n \n-    fn mk_fail(bcx: block, sp: span, msg: ~str,\n+    fn mk_fail(bcx: block, sp: span, +msg: ~str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n@@ -1663,7 +1667,7 @@ fn bind_irrefutable_pat(bcx: block,\n     let mut bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n-    match pat.node {\n+    match /*bad*/copy pat.node {\n         ast::pat_ident(_, _,inner) => {\n             if pat_is_variant_or_struct(bcx.tcx().def_map, pat) {\n                 return bcx;"}, {"sha": "c20747b54b5984092d12342d0c637c3194a76e36", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 162, "deletions": 118, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -23,6 +23,7 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n+\n use back::link::{mangle_exported_name};\n use back::link::{mangle_internal_name_by_path_and_seq};\n use back::link::{mangle_internal_name_by_path};\n@@ -126,7 +127,7 @@ impl fn_ctxt: get_insn_ctxt {\n     }\n }\n \n-fn log_fn_time(ccx: @crate_ctxt, name: ~str, start: time::Timespec,\n+fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n                end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n@@ -142,31 +143,36 @@ fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n     return llfn;\n }\n \n-fn decl_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) -> ValueRef {\n+fn decl_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n }\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n+fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n    ValueRef {\n     let llfn = decl_cdecl_fn(llmod, name, llty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     return llfn;\n }\n \n fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n-                 llmod: ModuleRef, name: ~str,\n-                 cc: lib::llvm::CallConv, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(name) { return externs.get(name); }\n-    let f = decl_fn(llmod, name, cc, ty);\n+                 llmod: ModuleRef,\n+                 +name: ~str,\n+                 cc: lib::llvm::CallConv,\n+                 ty: TypeRef) -> ValueRef {\n+    // XXX: Bad copy.\n+    if externs.contains_key(copy name) { return externs.get(name); }\n+    // XXX: Bad copy.\n+    let f = decl_fn(llmod, copy name, cc, ty);\n     externs.insert(name, f);\n     return f;\n }\n \n fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n-                    name: ~str, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(name) { return externs.get(name); }\n+                    +name: ~str, ty: TypeRef) -> ValueRef {\n+    // XXX: Bad copy.\n+    if externs.contains_key(copy name) { return externs.get(name); }\n     let c = str::as_c_str(name, |buf| llvm::LLVMAddGlobal(llmod, ty, buf));\n     externs.insert(name, c);\n     return c;\n@@ -175,7 +181,8 @@ fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n fn get_simple_extern_fn(cx: block,\n                         externs: HashMap<~str, ValueRef>,\n                         llmod: ModuleRef,\n-                        name: ~str, n_args: int) -> ValueRef {\n+                        +name: ~str,\n+                        n_args: int) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n@@ -185,7 +192,7 @@ fn get_simple_extern_fn(cx: block,\n }\n \n fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n-                      llmod: ModuleRef, name: ~str, args: ~[ValueRef]) ->\n+                      llmod: ModuleRef, +name: ~str, args: ~[ValueRef]) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n@@ -413,8 +420,9 @@ fn set_glue_inlining(f: ValueRef, t: ty::t) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: ~str) {\n-    if ccx.all_llvm_symbols.contains_key(sym) {\n+fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n+    // XXX: Bad copy.\n+    if ccx.all_llvm_symbols.contains_key(copy sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     ccx.all_llvm_symbols.insert(sym, ());\n@@ -570,7 +578,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             let mut j = 0u;\n             let v_id = variant.id;\n             for vec::each(fn_ty.sig.inputs) |a| {\n-                let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n+                let llfldp_a = GEP_enum(cx, a_tup, tid, v_id,\n+                                        /*bad*/copy tps, j);\n                 // XXX: Is \"None\" right here?\n                 let ty_subst = ty::subst_tps(ccx.tcx, tps, None, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n@@ -585,11 +594,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         return cx;\n     }\n \n-    /*\n-    Typestate constraint that shows the unimpl case doesn't happen?\n-    */\n     let mut cx = cx;\n-    match ty::get(t).sty {\n+    match /*bad*/copy ty::get(t).sty {\n       ty::ty_rec(*) | ty::ty_struct(*) => {\n           do expr::with_field_tys(cx.tcx(), t, None) |_has_dtor, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n@@ -615,8 +621,12 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n \n         // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n-            return iter_variant(cx, av, variants[0],\n-                             (*substs).tps, tid, f);\n+            return iter_variant(cx,\n+                                av,\n+                                variants[0],\n+                                /*bad*/copy substs.tps,\n+                                tid,\n+                                f);\n         }\n \n         let ccx = cx.ccx();\n@@ -641,7 +651,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             let variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, *variant,\n-                             (*substs).tps, tid, f);\n+                             /*bad*/copy (*substs).tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n         return next_cx;\n@@ -711,7 +721,7 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n       }\n     };\n     do with_cond(cx, is_zero) |bcx| {\n-        controlflow::trans_fail(bcx, Some(span), text)\n+        controlflow::trans_fail(bcx, Some(span), /*bad*/copy text)\n     }\n }\n \n@@ -754,7 +764,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     }\n }\n \n-fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef]) -> block {\n+fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }\n     if need_invoke(bcx) {\n@@ -954,16 +964,17 @@ fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: ~str) {\n+fn trans_trace(bcx: block, sp_opt: Option<span>, +trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n-    add_comment(bcx, trace_str);\n+    // XXX: Bad copy.\n+    add_comment(bcx, copy trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let {V_filename, V_line} = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n+        {V_filename: C_cstr(bcx.ccx(), /*bad*/copy loc.file.name),\n          V_line: loc.line as int}\n       }\n       None => {\n@@ -1057,7 +1068,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n             bcx = expr::trans_into(cx, e, expr::Ignore);\n         }\n         ast::stmt_decl(d, _) => {\n-            match d.node {\n+            match /*bad*/copy d.node {\n                 ast::decl_local(locals) => {\n                     for vec::each(locals) |local| {\n                         bcx = init_local(bcx, *local);\n@@ -1078,7 +1089,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n-             is_lpad: bool, name: ~str, opt_node_info: Option<node_info>)\n+             is_lpad: bool, +name: ~str, opt_node_info: Option<node_info>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -1112,13 +1123,13 @@ fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<node_info>) -> block {\n \n fn scope_block(bcx: block,\n                opt_node_info: Option<node_info>,\n-               n: ~str) -> block {\n+               +n: ~str) -> block {\n     return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n fn loop_scope_block(bcx: block, loop_break: block, loop_label: Option<ident>,\n-                    n: ~str, opt_node_info: Option<node_info>) -> block {\n+                    +n: ~str, opt_node_info: Option<node_info>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n@@ -1129,12 +1140,12 @@ fn loop_scope_block(bcx: block, loop_break: block, loop_label: Option<ident>,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-fn lpad_block(bcx: block, n: ~str) -> block {\n+fn lpad_block(bcx: block, +n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-fn sub_block(bcx: block, n: ~str) -> block {\n+fn sub_block(bcx: block, +n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n }\n \n@@ -1240,7 +1251,7 @@ fn leave_block(bcx: block, out_of: block) -> block {\n }\n \n fn with_scope(bcx: block, opt_node_info: Option<node_info>,\n-              name: ~str, f: fn(block) -> block) -> block {\n+              +name: ~str, f: fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n@@ -1252,10 +1263,11 @@ fn with_scope(bcx: block, opt_node_info: Option<node_info>,\n     leave_block(f(scope_cx), scope_cx)\n }\n \n-fn with_scope_result(bcx: block, opt_node_info: Option<node_info>,\n-                     name: ~str, f: fn(block) -> Result)\n-    -> Result\n-{\n+fn with_scope_result(bcx: block,\n+                     opt_node_info: Option<node_info>,\n+                     +name: ~str,\n+                     f: fn(block) -> Result)\n+                  -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n@@ -1264,7 +1276,7 @@ fn with_scope_result(bcx: block, opt_node_info: Option<node_info>,\n }\n \n fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n-                         name: ~str, f: fn(block) -> datum::DatumBlock)\n+                         +name: ~str, f: fn(block) -> datum::DatumBlock)\n     -> datum::DatumBlock\n {\n     use middle::trans::datum::DatumBlock;\n@@ -1280,7 +1292,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n-            match d.node {\n+            match /*bad*/copy d.node {\n               ast::decl_local(locals) => {\n                 for vec::each(locals) |local| {\n                     it(*local);\n@@ -1443,11 +1455,11 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - new_fn_ctxt\n //  - trans_args\n fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n-                    path: path,\n+                    +path: path,\n                     llfndecl: ValueRef,\n                     id: ast::node_id,\n                     impl_id: Option<ast::def_id>,\n-                    param_substs: Option<param_substs>,\n+                    +param_substs: Option<param_substs>,\n                     sp: Option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     return @fn_ctxt_ {\n@@ -1472,8 +1484,11 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n     };\n }\n \n-fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n-               sp: Option<span>) -> fn_ctxt {\n+fn new_fn_ctxt(ccx: @crate_ctxt,\n+               +path: path,\n+               llfndecl: ValueRef,\n+               sp: Option<span>)\n+            -> fn_ctxt {\n     return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, None, sp);\n }\n \n@@ -1625,10 +1640,13 @@ enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n-                 body: ast::blk, llfndecl: ValueRef,\n+fn trans_closure(ccx: @crate_ctxt,\n+                 +path: path,\n+                 decl: ast::fn_decl,\n+                 body: ast::blk,\n+                 llfndecl: ValueRef,\n                  ty_self: self_arg,\n-                 param_substs: Option<param_substs>,\n+                 +param_substs: Option<param_substs>,\n                  id: ast::node_id,\n                  impl_id: Option<ast::def_id>,\n                  maybe_load_env: fn(fn_ctxt),\n@@ -1640,7 +1658,8 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, impl_id, param_substs,\n                                   Some(body.span));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self,\n+                                               /*bad*/copy decl.inputs);\n \n     // Set GC for function.\n     if ccx.sess.opts.gc {\n@@ -1684,12 +1703,12 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(ccx: @crate_ctxt,\n-            path: path,\n+            +path: path,\n             decl: ast::fn_decl,\n             body: ast::blk,\n             llfndecl: ValueRef,\n             ty_self: self_arg,\n-            param_substs: Option<param_substs>,\n+            +param_substs: Option<param_substs>,\n             id: ast::node_id,\n             impl_id: Option<ast::def_id>) {\n     let do_time = ccx.sess.trans_stats();\n@@ -1698,7 +1717,8 @@ fn trans_fn(ccx: @crate_ctxt,\n     debug!(\"trans_fn(ty_self=%?)\", ty_self);\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n-    trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n+    // XXX: Bad copy of `path`.\n+    trans_closure(ccx, copy path, decl, body, llfndecl, ty_self,\n                   param_substs, id, impl_id,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo {\n@@ -1718,7 +1738,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                       args: ~[ast::variant_arg],\n                       disr: int,\n                       is_degen: bool,\n-                      param_substs: Option<param_substs>,\n+                      +param_substs: Option<param_substs>,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n@@ -1729,11 +1749,13 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                                      ast_util::dummy_sp(),\n                                      special_idents::arg),\n          id: varg.id});\n+    // XXX: Bad copy of `param_substs`.\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id, None,\n-                               param_substs, None);\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n+                               copy param_substs, None);\n+    // XXX: Bad copy.\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, copy fn_args);\n     let ty_param_substs = match param_substs {\n-      Some(substs) => substs.tys,\n+      Some(ref substs) => /*bad*/copy substs.tys,\n       None => ~[]\n     };\n     let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n@@ -1754,7 +1776,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     let v_id = local_def(variant.node.id);\n     for vec::eachi(args) |i, va| {\n         let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n-                                 ty_param_substs, i);\n+                                 /*bad*/copy ty_param_substs, i);\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n@@ -1774,7 +1796,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n fn trans_tuple_struct(ccx: @crate_ctxt,\n                       fields: ~[@ast::struct_field],\n                       ctor_id: ast::node_id,\n-                      param_substs: Option<param_substs>,\n+                      +param_substs: Option<param_substs>,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_tuple_struct\");\n \n@@ -1792,7 +1814,9 @@ fn trans_tuple_struct(ccx: @crate_ctxt,\n \n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, ctor_id, None,\n                                param_substs, None);\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n+\n+    // XXX: Bad copy.\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, copy fn_args);\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n@@ -1816,11 +1840,14 @@ fn trans_tuple_struct(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_struct_dtor(ccx: @crate_ctxt, path: path,\n-    body: ast::blk, dtor_id: ast::node_id,\n-    psubsts: Option<param_substs>,\n-    hash_id: Option<mono_id>, parent_id: ast::def_id)\n-    -> ValueRef {\n+fn trans_struct_dtor(ccx: @crate_ctxt,\n+                     +path: path,\n+                     body: ast::blk,\n+                     dtor_id: ast::node_id,\n+                     +psubsts: Option<param_substs>,\n+                     hash_id: Option<mono_id>,\n+                     parent_id: ast::def_id)\n+                  -> ValueRef {\n   let tcx = ccx.tcx;\n   /* Look up the parent class's def_id */\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n@@ -1833,7 +1860,8 @@ fn trans_struct_dtor(ccx: @crate_ctxt, path: path,\n      and returns () */\n   let lldty = type_of_dtor(ccx, class_ty);\n \n-  let s = get_dtor_symbol(ccx, path, dtor_id, psubsts);\n+  // XXX: Bad copies.\n+  let s = get_dtor_symbol(ccx, copy path, dtor_id, copy psubsts);\n \n   /* Register the dtor as a function. It has external linkage */\n   let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n@@ -1859,23 +1887,23 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n         *i += 1;\n \n         match variant.node.kind {\n-            ast::tuple_variant_kind(args) if args.len() > 0 => {\n+            ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, *variant, args, disr_val,\n-                                   degen, None, llfn);\n+                trans_enum_variant(ccx, id, *variant, /*bad*/copy *args,\n+                                   disr_val, degen, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n                 // Nothing to do.\n             }\n             ast::struct_variant_kind(struct_def) => {\n-                trans_struct_def(ccx, struct_def, tps, path,\n+                trans_struct_def(ccx, struct_def, /*bad*/copy tps, path,\n                                  variant.node.id);\n             }\n             ast::enum_variant_kind(ref enum_definition) => {\n                 trans_enum_def(ccx,\n                                *enum_definition,\n                                id,\n-                               tps,\n+                               /*bad*/copy tps,\n                                degen,\n                                path,\n                                vi,\n@@ -1892,19 +1920,20 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         // tjc: ?\n         _ => fail ~\"trans_item\",\n     };\n-    match item.node {\n-      ast::item_fn(decl, purity, tps, ref body) => {\n+    match /*bad*/copy item.node {\n+      // XXX: Bad copies.\n+      ast::item_fn(copy decl, purity, copy tps, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n                                      vec::append(\n-                                         *path,\n+                                         /*bad*/copy *path,\n                                          ~[path_name(item.ident)]),\n                                      decl, (*body), llfndecl, item.id);\n         } else if tps.is_empty() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n-                     vec::append(*path, ~[path_name(item.ident)]),\n+                     vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n                      decl, (*body), llfndecl, no_self, None, item.id, None);\n         } else {\n             for vec::each((*body).node.stmts) |stmt| {\n@@ -1918,26 +1947,27 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         }\n       }\n       ast::item_impl(tps, _, _, ms) => {\n-        meth::trans_impl(ccx, *path, item.ident, ms, tps, None,\n+        meth::trans_impl(ccx, /*bad*/copy *path, item.ident, ms, tps, None,\n                          item.id);\n       }\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);\n       }\n-      ast::item_enum(ref enum_definition, tps) => {\n+      ast::item_enum(ref enum_definition, ref tps) => {\n         if tps.len() == 0u {\n             let degen = (*enum_definition).variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, (*enum_definition), item.id, tps, degen, path,\n-                           vi, &mut i);\n+            trans_enum_def(ccx, (*enum_definition), item.id, /*bad*/copy *tps,\n+                           degen, path, vi, &mut i);\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n       ast::item_foreign_mod(foreign_mod) => {\n         let abi = match attr::foreign_abi(item.attrs) {\n           either::Right(abi_) => abi_,\n-          either::Left(ref msg) => ccx.sess.span_fatal(item.span, (*msg))\n+          either::Left(ref msg) => ccx.sess.span_fatal(item.span,\n+                                                       /*bad*/copy *msg)\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n@@ -1956,7 +1986,7 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     if tps.len() == 0u {\n         // Translate the destructor.\n         do option::iter(&struct_def.dtor) |dtor| {\n-            trans_struct_dtor(ccx, *path, dtor.node.body,\n+            trans_struct_dtor(ccx, /*bad*/copy *path, dtor.node.body,\n                              dtor.node.id, None, None, local_def(id));\n         };\n \n@@ -1966,8 +1996,8 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n             // otherwise this is a unit-like struct.\n             Some(ctor_id) if struct_def.fields.len() > 0 => {\n                 let llfndecl = get_item_val(ccx, ctor_id);\n-                trans_tuple_struct(ccx, struct_def.fields, ctor_id, None,\n-                                   llfndecl);\n+                trans_tuple_struct(ccx, /*bad*/copy struct_def.fields,\n+                                   ctor_id, None, llfndecl);\n             }\n             Some(_) | None => {}\n         }\n@@ -1991,30 +2021,35 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     return struct_elt(llpairty, 0u);\n }\n \n-fn register_fn(ccx: @crate_ctxt, sp: span, path: path,\n-               node_id: ast::node_id) -> ValueRef {\n+fn register_fn(ccx: @crate_ctxt,\n+               sp: span,\n+               +path: path,\n+               node_id: ast::node_id)\n+            -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, path, node_id, t)\n }\n \n-fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path,\n+fn register_fn_full(ccx: @crate_ctxt, sp: span, +path: path,\n                     node_id: ast::node_id, node_type: ty::t) -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n     register_fn_fuller(ccx, sp, path, node_id, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n \n-fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n+fn register_fn_fuller(ccx: @crate_ctxt, sp: span, +path: path,\n                       node_id: ast::node_id, node_type: ty::t,\n                       cc: lib::llvm::CallConv, llfty: TypeRef) -> ValueRef {\n-    let ps: ~str = mangle_exported_name(ccx, path, node_type);\n-    let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n-    ccx.item_symbols.insert(node_id, ps);\n-\n-    debug!(\"register_fn_fuller created fn %s for item %d with path %s\",\n-           val_str(ccx.tn, llfn), node_id,\n+    debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n+           node_id,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n \n+    // XXX: Bad copy.\n+    let ps: ~str = mangle_exported_name(ccx, copy path, node_type);\n+    // XXX: Bad copy.\n+    let llfn: ValueRef = decl_fn(ccx.llmod, copy ps, cc, llfty);\n+    ccx.item_symbols.insert(node_id, ps);\n+\n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn); }\n     llfn\n@@ -2098,7 +2133,7 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n \n fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     vec::append(\n-        *match ccx.tcx.items.get(i.id) {\n+        /*bad*/copy *match ccx.tcx.items.get(i.id) {\n             ast_map::node_item(_, p) => p,\n                 // separate map for paths?\n             _ => fail ~\"item_path\"\n@@ -2108,17 +2143,21 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n \n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n    return it; otherwise, create one and register it, returning it as well */\n-fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n-                   substs: Option<param_substs>) -> ~str {\n+fn get_dtor_symbol(ccx: @crate_ctxt,\n+                   +path: path,\n+                   id: ast::node_id,\n+                   +substs: Option<param_substs>)\n+                -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n   match ccx.item_symbols.find(id) {\n-     Some(ref s) => (*s),\n+     Some(ref s) => (/*bad*/copy *s),\n      None if substs.is_none() => {\n        let s = mangle_exported_name(\n            ccx,\n            vec::append(path, ~[path_name((ccx.names)(~\"dtor\"))]),\n            t);\n-       ccx.item_symbols.insert(id, s);\n+       // XXX: Bad copy, use `@str`?\n+       ccx.item_symbols.insert(id, copy s);\n        s\n      }\n      None   => {\n@@ -2152,7 +2191,8 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n         let mut exprt = false;\n         let val = match ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n-            let my_path = vec::append(*pth, ~[path_name(i.ident)]);\n+            let my_path = vec::append(/*bad*/copy *pth,\n+                                      ~[path_name(i.ident)]);\n             match i.node {\n               ast::item_const(_, _) => {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n@@ -2169,7 +2209,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 } else {\n                     foreign::register_foreign_fn(ccx, i.span, my_path, i.id)\n                 };\n-                set_inline_hint_if_appr(i.attrs, llfn);\n+                set_inline_hint_if_appr(/*bad*/copy i.attrs, llfn);\n                 llfn\n               }\n               _ => fail ~\"get_item_val: weird result in table\"\n@@ -2197,7 +2237,8 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             match ni.node {\n                 ast::foreign_item_fn(*) => {\n                     register_fn(ccx, ni.span,\n-                                vec::append(*pth, ~[path_name(ni.ident)]),\n+                                vec::append(/*bad*/copy *pth,\n+                                            ~[path_name(ni.ident)]),\n                                 ni.id)\n                 }\n                 ast::foreign_item_const(*) => {\n@@ -2223,7 +2264,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             let lldty = T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n                     T_ptr(type_of(ccx, class_ty))],\n                                    llvm::LLVMVoidType());\n-            let s = get_dtor_symbol(ccx, *pt, dt.node.id, None);\n+            let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n \n             /* Make the declaration for the dtor */\n             let llfn = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n@@ -2233,10 +2274,10 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n \n           ast_map::node_variant(ref v, enm, pth) => {\n             let llfn;\n-            match (*v).node.kind {\n+            match /*bad*/copy (*v).node.kind {\n                 ast::tuple_variant_kind(args) => {\n                     assert args.len() != 0u;\n-                    let pth = vec::append(*pth,\n+                    let pth = vec::append(/*bad*/copy *pth,\n                                           ~[path_name(enm.ident),\n                                             path_name((*v).node.name)]);\n                     llfn = match enm.node {\n@@ -2266,7 +2307,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 }\n                 Some(ctor_id) => {\n                     let llfn = register_fn(ccx, struct_item.span,\n-                                           *struct_path, ctor_id);\n+                                           /*bad*/copy *struct_path, ctor_id);\n                     set_inline_hint(llfn);\n                     llfn\n                 }\n@@ -2289,10 +2330,10 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n                 m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n-    let pth = vec::append(*pth, ~[path_name((ccx.names)(~\"meth\")),\n+    let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(~\"meth\")),\n                                   path_name(m.ident)]);\n     let llfn = register_fn_full(ccx, m.span, pth, id, mty);\n-    set_inline_hint_if_appr(m.attrs, llfn);\n+    set_inline_hint_if_appr(/*bad*/copy m.attrs, llfn);\n     llfn\n }\n \n@@ -2306,11 +2347,14 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n         let mut i = 0;\n         let path = item_path(ccx, it);\n         for vec::each((*enum_definition).variants) |variant| {\n-            let p = vec::append(path, ~[path_name(variant.node.name),\n-                                        path_name(special_idents::descrim)]);\n+            let p = vec::append(/*bad*/copy path, ~[\n+                path_name(variant.node.name),\n+                path_name(special_idents::descrim)\n+            ]);\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n-            note_unique_llvm_symbol(ccx, s);\n+            // XXX: Bad copy.\n+            note_unique_llvm_symbol(ccx, copy s);\n             let discrim_gvar = str::as_c_str(s, |buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n             });\n@@ -2639,11 +2683,10 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n           C_array(ccx.int_type, subcrates)]));\n }\n \n-fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n-    -> encoder::encode_parms {\n-\n+fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n+    // XXX: Bad copy of `c`, whatever it is.\n     let encode_inlined_item =\n-        |a,b,c,d| astencode::encode_inlined_item(a, b, c, d, cx.maps);\n+        |a,b,c,d| astencode::encode_inlined_item(a, b, copy c, d, cx.maps);\n \n     return {\n         diag: cx.sess.diagnostic(),\n@@ -2652,7 +2695,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         reexports2: cx.exp_map2,\n         item_symbols: cx.item_symbols,\n         discrim_symbols: cx.discrim_symbols,\n-        link_meta: cx.link_meta,\n+        link_meta: /*bad*/copy cx.link_meta,\n         cstore: cx.sess.cstore,\n         encode_inlined_item: encode_inlined_item\n     };\n@@ -2715,16 +2758,17 @@ fn trans_crate(sess: session::Session,\n         llvm::LLVMModuleCreateWithNameInContext\n             (buf, llvm::LLVMGetGlobalContext())\n     });\n-    let data_layout = sess.targ_cfg.target_strs.data_layout;\n-    let targ_triple = sess.targ_cfg.target_strs.target_triple;\n+    let data_layout = /*bad*/copy sess.targ_cfg.target_strs.data_layout;\n+    let targ_triple = /*bad*/copy sess.targ_cfg.target_strs.target_triple;\n     let _: () =\n         str::as_c_str(data_layout,\n                     |buf| llvm::LLVMSetDataLayout(llmod, buf));\n     let _: () =\n         str::as_c_str(targ_triple,\n                     |buf| llvm::LLVMSetTarget(llmod, buf));\n     let targ_cfg = sess.targ_cfg;\n-    let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n+    let td = mk_target_data(\n+        /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n     let tn = mk_type_names();\n     let intrinsics = declare_intrinsics(llmod);\n     if sess.opts.extra_debuginfo {\n@@ -2739,9 +2783,9 @@ fn trans_crate(sess: session::Session,\n     lib::llvm::associate_type(tn, ~\"tydesc\", tydesc_type);\n     let crate_map = decl_crate_map(sess, link_meta, llmod);\n     let dbg_cx = if sess.opts.debuginfo {\n-        option::Some(debuginfo::mk_ctxt(llmod_id, sess.parse_sess.interner))\n+        Some(debuginfo::mk_ctxt(copy llmod_id, sess.parse_sess.interner))\n     } else {\n-        option::None\n+        None\n     };\n \n     let ccx = @crate_ctxt {\n@@ -2756,7 +2800,7 @@ fn trans_crate(sess: session::Session,\n           reachable: reachable,\n           item_symbols: HashMap(),\n           mut main_fn: None::<ValueRef>,\n-          link_meta: link_meta,\n+          link_meta: copy link_meta,    // XXX: Bad copy.\n           enum_sizes: ty::new_ty_hash(),\n           discrims: HashMap(),\n           discrim_symbols: HashMap(),"}, {"sha": "98151ff008820d37366644d73dfcd1a0adec6fd2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use codemap::span;\n use lib::llvm::llvm;\n use lib::llvm::{CallConv, TypeKind, AtomicBinOp, AtomicOrdering};\n@@ -53,8 +54,8 @@ fn count_insn(cx: block, category: &str) {\n         let mut s = ~\".\";\n         i = 0u;\n         while i < len {\n-            let e = v[i];\n-            i = mm.get(e);\n+            let e = /*bad*/copy v[i];\n+            i = mm.get(/*bad*/ copy e);\n             s += ~\"/\";\n             s += e;\n             i += 1u;\n@@ -662,7 +663,7 @@ fn add_span_comment(bcx: block, sp: span, text: ~str) {\n     if !ccx.sess.no_asm_comments() {\n         let s = text + ~\" (\" + ccx.sess.codemap.span_to_str(sp)\n             + ~\")\";\n-        log(debug, s);\n+        log(debug, copy s);\n         add_comment(bcx, s);\n     }\n }"}, {"sha": "88f908c4c26327e077af93194882731e39944640", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -16,6 +16,7 @@\n // and methods are represented as just a fn ptr and not a full\n // closure.\n \n+\n use lib::llvm::ValueRef;\n use middle::trans::base::{get_item_val, trans_external_path};\n use middle::trans::build::*;\n@@ -159,7 +160,7 @@ fn trans_fn_ref(bcx: block,\n fn trans_fn_ref_with_vtables_to_callee(bcx: block,\n                                        def_id: ast::def_id,\n                                        ref_id: ast::node_id,\n-                                       type_params: ~[ty::t],\n+                                       +type_params: ~[ty::t],\n                                        vtables: Option<typeck::vtable_res>)\n     -> Callee\n {\n@@ -172,7 +173,7 @@ fn trans_fn_ref_with_vtables(\n     bcx: block,            //\n     def_id: ast::def_id,   // def id of fn\n     ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n-    type_params: ~[ty::t], // values for fn's ty params\n+    +type_params: ~[ty::t], // values for fn's ty params\n     vtables: Option<typeck::vtable_res>)\n     -> FnData\n {\n@@ -415,7 +416,7 @@ fn trans_call_inner(\n     autoref_arg: AutorefArg) -> block\n {\n     do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n-        let ret_in_loop = match args {\n+        let ret_in_loop = match /*bad*/copy args {\n           ArgExprs(args) => {\n             args.len() > 0u && match vec::last(args).node {\n               ast::expr_loop_body(@{\n@@ -459,10 +460,10 @@ fn trans_call_inner(\n             }\n         };\n \n-        let args_res = trans_args(bcx, llenv, args, fn_expr_ty,\n+        let args_res = trans_args(bcx, llenv, /*bad*/copy args, fn_expr_ty,\n                                   dest, ret_flag, autoref_arg);\n         bcx = args_res.bcx;\n-        let mut llargs = args_res.args;\n+        let mut llargs = /*bad*/copy args_res.args;\n \n         let llretslot = args_res.retslot;\n \n@@ -519,8 +520,12 @@ enum CallArgs {\n     ArgVals(~[ValueRef])\n }\n \n-fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n-              dest: expr::Dest, ret_flag: Option<ValueRef>,\n+fn trans_args(cx: block,\n+              llenv: ValueRef,\n+              +args: CallArgs,\n+              fn_ty: ty::t,\n+              dest: expr::Dest,\n+              ret_flag: Option<ValueRef>,\n               +autoref_arg: AutorefArg)\n     -> {bcx: block, args: ~[ValueRef], retslot: ValueRef}\n {\n@@ -614,14 +619,18 @@ fn trans_arg_expr(bcx: block,\n         Some(_) => {\n             match arg_expr.node {\n                 ast::expr_loop_body(\n-                    blk@@{node:ast::expr_fn_block(decl, ref body, cap), _}) =>\n+                    // XXX: Bad copy.\n+                    blk@@{\n+                        node: ast::expr_fn_block(copy decl, ref body, cap),\n+                        _\n+                    }) =>\n                 {\n                     let scratch_ty = expr_ty(bcx, blk);\n                     let scratch = alloc_ty(bcx, scratch_ty);\n                     let arg_ty = expr_ty(bcx, arg_expr);\n                     let proto = ty::ty_fn_proto(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n-                        bcx, proto, decl, (*body), blk.id, cap,\n+                        bcx, proto, decl, /*bad*/copy *body, blk.id, cap,\n                         Some(ret_flag), expr::SaveIn(scratch));\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,"}, {"sha": "6a0c2aceda35a0b1d12bf6617a27c66b7df9a359", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::abi;\n use back::link::{mangle_internal_name_by_path_and_seq};\n use back::link::{mangle_internal_name_by_path};\n@@ -211,7 +212,8 @@ fn store_environment(bcx: block,\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values);\n+    // XXX: Bad copy.\n+    let cdata_ty = mk_closure_tys(tcx, copy bound_values);\n \n     // allocate closure in the heap\n     let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, proto, cdata_ty);\n@@ -374,8 +376,8 @@ fn load_environment(fcx: fn_ctxt,\n \n fn trans_expr_fn(bcx: block,\n                  proto: ast::Proto,\n-                 decl: ast::fn_decl,\n-                 body: ast::blk,\n+                 +decl: ast::fn_decl,\n+                 +body: ast::blk,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n                  is_loop_body: Option<Option<ValueRef>>,\n@@ -392,19 +394,24 @@ fn trans_expr_fn(bcx: block,\n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n-    let sub_path = vec::append_one(bcx.fcx.path,\n+    let sub_path = vec::append_one(/*bad*/copy bcx.fcx.path,\n                                    path_name(special_idents::anon));\n-    let s = mangle_internal_name_by_path_and_seq(ccx, sub_path, ~\"expr_fn\");\n+    // XXX: Bad copy.\n+    let s = mangle_internal_name_by_path_and_seq(ccx,\n+                                                 copy sub_path,\n+                                                 ~\"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let trans_closure_env = fn@(proto: ast::Proto) -> Result {\n+    // XXX: Bad copies.\n+    let trans_closure_env = |proto, copy body, copy sub_path, copy decl| {\n         let cap_vars = capture::compute_capture_vars(ccx.tcx, id, proto,\n                                                      cap_clause);\n         let ret_handle = match is_loop_body { Some(x) => x, None => None };\n-        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, proto,\n+        // XXX: Bad copy.\n+        let {llbox, cdata_ty, bcx} = build_closure(bcx, copy cap_vars, proto,\n                                                    ret_handle);\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n-                      bcx.fcx.param_substs, id, None, |fcx| {\n+        trans_closure(ccx, /*bad*/copy sub_path, decl, body, llfn, no_self,\n+                      /*bad*/copy bcx.fcx.param_substs, id, None, |fcx| {\n             load_environment(fcx, cdata_ty, cap_vars,\n                              ret_handle.is_some(), proto);\n                       }, |bcx| {"}, {"sha": "ee2028200e413da29b2d19e6aef78d507c6ac573", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n /**\n    Code that is useful in various trans modules.\n \n@@ -59,7 +60,10 @@ use syntax::{ast, ast_map};\n type namegen = fn@(~str) -> ident;\n fn new_namegen(intr: @ident_interner) -> namegen {\n     return fn@(prefix: ~str) -> ident {\n-        return intr.gensym(@fmt!(\"%s_%u\", prefix, intr.gensym(@prefix).repr))\n+        // XXX: Bad copies.\n+        return intr.gensym(@fmt!(\"%s_%u\",\n+                                 prefix,\n+                                 intr.gensym(@copy prefix).repr))\n     };\n }\n \n@@ -470,7 +474,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n fn block_cleanups(bcx: block) -> ~[cleanup] {\n     match bcx.kind {\n        block_non_scope  => ~[],\n-       block_scope(ref inf) => (*inf).cleanups\n+       block_scope(ref inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n@@ -1077,7 +1081,7 @@ fn C_u8(i: uint) -> ValueRef { return C_integral(T_i8(), i as u64, False); }\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n+fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n     match cx.const_cstr_cache.find(s) {\n       Some(llval) => return llval,\n       None => ()\n@@ -1100,9 +1104,10 @@ fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-fn C_estr_slice(cx: @crate_ctxt, s: ~str) -> ValueRef {\n+fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n+    let len = str::len(s);\n     let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n-    C_struct(~[cs, C_uint(cx, str::len(s) + 1u /* +1 for null */)])\n+    C_struct(~[cs, C_uint(cx, len + 1u /* +1 for null */)])\n }\n \n // Returns a Plain Old LLVM String:\n@@ -1149,7 +1154,7 @@ fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef unsafe {\n         bytes.len() as c_uint, False);\n }\n \n-fn C_shape(ccx: @crate_ctxt, bytes: ~[u8]) -> ValueRef {\n+fn C_shape(ccx: @crate_ctxt, +bytes: ~[u8]) -> ValueRef {\n     let llshape = C_bytes_plus_null(bytes);\n     let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n     let llglobal = str::as_c_str(name, |buf| {\n@@ -1185,19 +1190,20 @@ type mono_id = @mono_id_;\n \n impl mono_param_id : cmp::Eq {\n     pure fn eq(&self, other: &mono_param_id) -> bool {\n-        match ((*self), (*other)) {\n-            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n+        match (self, other) {\n+            (&mono_precise(ty_a, ref ids_a),\n+             &mono_precise(ty_b, ref ids_b)) => {\n                 ty_a == ty_b && ids_a == ids_b\n             }\n-            (mono_any, mono_any) => true,\n-            (mono_repr(size_a, align_a, is_float_a, mode_a),\n-             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n+            (&mono_any, &mono_any) => true,\n+            (&mono_repr(size_a, align_a, is_float_a, mode_a),\n+             &mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n                 size_a == size_b && align_a == align_b &&\n                     is_float_a == is_float_b && mode_a == mode_b\n             }\n-            (mono_precise(*), _) => false,\n-            (mono_any, _) => false,\n-            (mono_repr(*), _) => false\n+            (&mono_precise(*), _) => false,\n+            (&mono_any, _) => false,\n+            (&mono_repr(*), _) => false\n         }\n     }\n     pure fn ne(&self, other: &mono_param_id) -> bool { !(*self).eq(other) }\n@@ -1212,7 +1218,7 @@ impl mono_id_ : cmp::Eq {\n \n impl mono_param_id : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n+        match /*bad*/copy *self {\n           mono_precise(t, mids) =>\n           to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), &mids, lsb0, f),\n \n@@ -1261,7 +1267,7 @@ fn path_str(sess: session::Session, p: path) -> ~str {\n }\n \n fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n-    match bcx.fcx.param_substs {\n+    match /*bad*/copy bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n         }\n@@ -1282,7 +1288,7 @@ fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n-    match bcx.fcx.param_substs {\n+    match /*bad*/copy bcx.fcx.param_substs {\n       Some(substs) => {\n         do vec::map(params) |t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n@@ -1306,13 +1312,13 @@ fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n-fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n+fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n     -> typeck::vtable_origin\n {\n     let tcx = fcx.ccx.tcx;\n     match vt {\n         typeck::vtable_static(trait_id, tys, sub) => {\n-            let tys = match fcx.param_substs {\n+            let tys = match /*bad*/copy fcx.param_substs {\n                 Some(substs) => {\n                     do vec::map(tys) |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n@@ -1330,12 +1336,12 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n                 }\n                 _ => {\n                     tcx.sess.bug(fmt!(\n-                        \"resolve_vtable_in_fn_ctxt: asked to lookup %? but \\\n-                         no vtables in the fn_ctxt!\", vt))\n+                        \"resolve_vtable_in_fn_ctxt: asked to lookup but \\\n+                         no vtables in the fn_ctxt!\"))\n                 }\n             }\n         }\n-        _ => vt\n+        vt => vt\n     }\n }\n \n@@ -1352,10 +1358,10 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     let vtables_to_skip =\n         ty::count_traits_and_supertraits(tcx, first_n_bounds);\n     let vtable_off = vtables_to_skip + n_bound;\n-    ps.vtables.get()[vtable_off]\n+    /*bad*/ copy ps.vtables.get()[vtable_off]\n }\n \n-fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n+fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n     {self_r: Some(ty::re_bound(ty::br_self)),\n      self_ty: None,\n      tps: tps}"}, {"sha": "0d698b2871d76042970457f586bf768c3ce77d0e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::const_eval;\n use middle::trans::base::get_insn_ctxt;\n use middle::trans::common::*;\n@@ -36,12 +37,12 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n                                 ~\"integer literal doesn't have a type\")\n         }\n       }\n-      ast::lit_float(fs, t) => C_floating(*fs, T_float_ty(cx, t)),\n+      ast::lit_float(fs, t) => C_floating(/*bad*/copy *fs, T_float_ty(cx, t)),\n       ast::lit_float_unsuffixed(fs) => {\n         let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_float_ty).sty {\n           ty::ty_float(t) => {\n-            C_floating(*fs, T_float_ty(cx, t))\n+            C_floating(/*bad*/copy *fs, T_float_ty(cx, t))\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,\n@@ -52,7 +53,7 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n       }\n       ast::lit_bool(b) => C_bool(b),\n       ast::lit_nil => C_nil(),\n-      ast::lit_str(s) => C_estr_slice(cx, *s)\n+      ast::lit_str(s) => C_estr_slice(cx, /*bad*/copy *s)\n     }\n }\n \n@@ -129,7 +130,7 @@ fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n \n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"const_expr\");\n-    return match e.node {\n+    return match /*bad*/copy e.node {\n       ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n       ast::expr_binary(b, e1, e2) => {\n         let te1 = const_expr(cx, e1);\n@@ -358,7 +359,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         const_expr(cx, e)\n       }\n       ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n-        match sub.node {\n+        match /*bad*/copy sub.node {\n           ast::expr_lit(lit) => {\n             match lit.node {\n               ast::lit_str(*) => { const_expr(cx, sub) }"}, {"sha": "7ae3fbcd1b8c44593d2ef332fc466d6eb9fd0939", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n use middle::trans::callee;\n@@ -171,13 +172,15 @@ fn trans_log(log_ex: @ast::expr,\n     }\n \n     let modpath = vec::append(\n-        ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n+        ~[path_mod(ccx.sess.ident_of(/*bad*/copy ccx.link_meta.name))],\n         vec::filter(bcx.fcx.path, |e|\n             match *e { path_mod(_) => true, _ => false }\n         ));\n-    let modname = path_str(ccx.sess, modpath);\n+    // XXX: Bad copy.\n+    let modname = path_str(ccx.sess, copy modpath);\n \n-    let global = if ccx.module_data.contains_key(modname) {\n+    // XXX: Bad copy.\n+    let global = if ccx.module_data.contains_key(copy modname) {\n         ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n@@ -310,7 +313,7 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n         }\n     };\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n-        trans_fail(bcx, Some(pred_expr.span), expr_str)\n+        trans_fail(bcx, Some(pred_expr.span), /*bad*/copy expr_str)\n     }\n }\n \n@@ -340,7 +343,7 @@ fn trans_fail_expr(bcx: block,\n     }\n }\n \n-fn trans_fail(bcx: block, sp_opt: Option<span>, fail_str: ~str)\n+fn trans_fail(bcx: block, sp_opt: Option<span>, +fail_str: ~str)\n     -> block\n {\n     let _icx = bcx.insn_ctxt(\"trans_fail\");\n@@ -357,7 +360,7 @@ fn trans_fail_value(bcx: block, sp_opt: Option<span>, V_fail_str: ValueRef)\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n+        {V_filename: C_cstr(bcx.ccx(), /*bad*/copy loc.file.name),\n          V_line: loc.line as int}\n       }\n       None => {\n@@ -381,7 +384,7 @@ fn trans_fail_bounds_check(bcx: block, sp: span,\n \n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(sp.lo);\n     let line = C_int(ccx, loc.line as int);\n-    let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n+    let filename_cstr = C_cstr(bcx.ccx(), /*bad*/copy loc.file.name);\n     let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n \n     let args = ~[filename, line, index, len];"}, {"sha": "5c13364ddeb7932a41bf26fb7527f594f720d47c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -95,6 +95,7 @@\n  * methods themselves.  Most are only suitable for some types of\n  * values. */\n \n+\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n use middle::trans::build::*;"}, {"sha": "78d19e9e0cbaa9321f489c13420d8a6bb84512f3", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n@@ -107,7 +108,7 @@ type debug_ctxt = {\n     crate_file: ~str\n };\n \n-fn mk_ctxt(crate: ~str, intr: @ident_interner) -> debug_ctxt {\n+fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n     {llmetadata: map::HashMap(),\n      names: new_namegen(intr),\n      crate_file: crate}\n@@ -181,7 +182,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache, mdtag: int,\n fn create_compile_unit(cx: @crate_ctxt)\n     -> @metadata<compile_unit_md> unsafe {\n     let cache = get_cache(cx);\n-    let crate_name = cx.dbg_cx.get().crate_file;\n+    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n     let tg = CompileUnitTag;\n     match cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n                         |md| md.data.name == crate_name) {\n@@ -194,7 +195,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n     let unit_metadata = ~[lltag(tg),\n                          llunused(),\n                          lli32(DW_LANG_RUST),\n-                         llstr(crate_name),\n+                         llstr(copy crate_name),\n                          llstr(work_dir),\n                          llstr(env!(\"CFG_VERSION\")),\n                          lli1(true), // deprecated: main compile unit\n@@ -211,7 +212,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n }\n \n fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n-    cx.dbg_cx.get().llmetadata\n+    (/*bad*/copy cx.dbg_cx).get().llmetadata\n }\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n@@ -223,7 +224,7 @@ fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     }, str::from_slice(work_dir))\n }\n \n-fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n+fn create_file(cx: @crate_ctxt, +full_path: ~str) -> @metadata<file_md> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n     match cached_metadata::<@metadata<file_md>>(\n@@ -262,7 +263,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let sp = cx.node_info.get().span;\n \n     let start = cx.sess().codemap.lookup_char_pos(sp.lo);\n-    let fname = start.file.name;\n+    let fname = /*bad*/copy start.file.name;\n     let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n     let tg = LexicalBlockTag;\n     /*alt cached_metadata::<@metadata<block_md>>(\n@@ -365,12 +366,18 @@ type struct_ctxt = {\n };\n \n fn finish_structure(cx: @struct_ctxt) -> ValueRef {\n-    return create_composite_type(StructureTypeTag, cx.name, cx.file, cx.line,\n-                              cx.total_size, cx.align, 0, option::None,\n-                              option::Some(cx.members));\n-}\n-\n-fn create_structure(file: @metadata<file_md>, name: ~str, line: int)\n+    return create_composite_type(StructureTypeTag,\n+                                 /*bad*/copy cx.name,\n+                                 cx.file,\n+                                 cx.line,\n+                                 cx.total_size,\n+                                 cx.align,\n+                                 0,\n+                                 option::None,\n+                                 option::Some(/*bad*/copy cx.members));\n+}\n+\n+fn create_structure(file: @metadata<file_md>, +name: ~str, line: int)\n     -> @struct_ctxt {\n     let cx = @{file: file.node,\n                name: name,\n@@ -382,7 +389,7 @@ fn create_structure(file: @metadata<file_md>, name: ~str, line: int)\n     return cx;\n }\n \n-fn create_derived_type(type_tag: int, file: ValueRef, name: ~str, line: int,\n+fn create_derived_type(type_tag: int, file: ValueRef, +name: ~str, line: int,\n                        size: int, align: int, offset: int, ty: ValueRef)\n     -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n@@ -398,7 +405,7 @@ fn create_derived_type(type_tag: int, file: ValueRef, name: ~str, line: int,\n     return llmdnode(lldata);\n }\n \n-fn add_member(cx: @struct_ctxt, name: ~str, line: int, size: int, align: int,\n+fn add_member(cx: @struct_ctxt, +name: ~str, line: int, size: int, align: int,\n               ty: ValueRef) {\n     cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n                                        size * 8, align * 8, cx.total_size,\n@@ -412,7 +419,8 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n                                cx.sess.str_of(\n-                                   (cx.dbg_cx.get().names)(~\"rec\")),\n+                                   ((/*bad*/copy cx.dbg_cx).get().names)\n+                                   (~\"rec\")),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for fields.each |field| {\n@@ -455,10 +463,10 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     return mdval;\n }\n \n-fn create_composite_type(type_tag: int, name: ~str, file: ValueRef, line: int,\n-                         size: int, align: int, offset: int,\n+fn create_composite_type(type_tag: int, +name: ~str, file: ValueRef,\n+                         line: int, size: int, align: int, offset: int,\n                          derived: Option<ValueRef>,\n-                         members: Option<~[ValueRef]>)\n+                         +members: Option<~[ValueRef]>)\n     -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n                   file,\n@@ -614,10 +622,10 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n }\n \n fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> ~str {\n-    cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n+    /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n-fn create_var(type_tag: int, context: ValueRef, name: ~str, file: ValueRef,\n+fn create_var(type_tag: int, context: ValueRef, +name: ~str, file: ValueRef,\n               line: int, ret_ty: ValueRef) -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n                   context,\n@@ -649,7 +657,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n-    let filemd = create_file(cx, loc.file.name);\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n     let context = match bcx.parent {\n         None => create_function(bcx.fcx).node,\n         Some(_) => create_block(bcx).node\n@@ -693,7 +701,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n-    let filemd = create_file(cx, loc.file.name);\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n     let context = create_function(bcx.fcx);\n \n     match arg.pat.node {\n@@ -740,7 +748,7 @@ fn update_source_pos(cx: block, s: span) {\n \n fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx.ccx;\n-    let dbg_cx = cx.dbg_cx.get();\n+    let dbg_cx = (/*bad*/copy cx.dbg_cx).get();\n \n     debug!(\"~~\");\n     log(debug, fcx.id);\n@@ -750,7 +758,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) => {\n-        match item.node {\n+        match /*bad*/copy item.node {\n           ast::item_fn(decl, _, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n@@ -762,7 +770,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n           (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_expr(expr) => {\n-        match expr.node {\n+        match /*bad*/copy expr.node {\n           ast::expr_fn(_, decl, _, _) => {\n             ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }"}, {"sha": "d225409710656c4285702d8f6968ef90adfcda0a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -111,6 +111,7 @@ lvalues are *never* stored by value.\n \n */\n \n+\n use lib::llvm::ValueRef;\n use middle::resolve;\n use middle::trans::base::*;\n@@ -514,7 +515,8 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n-    match expr.node {\n+    // XXX: This copy is really bad.\n+    match /*bad*/copy expr.node {\n         ast::expr_paren(e) => {\n             return trans_rvalue_dps_unadjusted(bcx, e, dest);\n         }\n@@ -526,7 +528,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return controlflow::trans_if(bcx, cond, (*thn), els, dest);\n         }\n         ast::expr_match(discr, ref arms) => {\n-            return alt::trans_alt(bcx, expr, discr, (*arms), dest);\n+            return alt::trans_alt(bcx, expr, discr, /*bad*/copy *arms, dest);\n         }\n         ast::expr_block(ref blk) => {\n             return do base::with_scope(bcx, (*blk).info(),\n@@ -554,21 +556,23 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_vec(*) | ast::expr_repeat(*) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n-        ast::expr_fn(proto, decl, ref body, cap_clause) => {\n+        // XXX: Bad copy.\n+        ast::expr_fn(proto, copy decl, ref body, cap_clause) => {\n             // Don't use this function for anything real. Use the one in\n             // astconv instead.\n-            return closure::trans_expr_fn(bcx, proto, decl, *body, expr.id,\n-                                          cap_clause, None, dest);\n+            return closure::trans_expr_fn(bcx, proto, decl, /*bad*/copy *body,\n+                                          expr.id, cap_clause, None, dest);\n         }\n-        ast::expr_fn_block(decl, ref body, cap_clause) => {\n+        ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n             let expr_ty = expr_ty(bcx, expr);\n             match ty::get(expr_ty).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     debug!(\"translating fn_block %s with type %s\",\n                            expr_to_str(expr, tcx.sess.intr()),\n                            ty_to_str(tcx, expr_ty));\n                     return closure::trans_expr_fn(\n-                        bcx, fn_ty.meta.proto, decl, *body, expr.id,\n+                        bcx, fn_ty.meta.proto, /*bad*/copy *decl,\n+                        /*bad*/copy *body, expr.id,\n                         cap_clause, None, dest);\n                 }\n                 _ => {\n@@ -581,10 +585,16 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             match ty::get(expr_ty(bcx, expr)).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     match blk.node {\n-                        ast::expr_fn_block(decl, ref body, cap) => {\n+                        ast::expr_fn_block(copy decl, ref body, cap) => {\n                             return closure::trans_expr_fn(\n-                                bcx, fn_ty.meta.proto, decl, *body, blk.id,\n-                                cap, Some(None), dest);\n+                                bcx,\n+                                fn_ty.meta.proto,\n+                                decl,\n+                                /*bad*/copy *body,\n+                                blk.id,\n+                                cap,\n+                                Some(None),\n+                                dest);\n                         }\n                         _ => {\n                             bcx.sess().impossible_case("}, {"sha": "9777d87513cbeda8881525e66a2df245512de8e0", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -11,6 +11,7 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n+\n use back::{link, abi};\n use driver::session::arch_x86_64;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n@@ -441,7 +442,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n-        option::Some(ref ln) => (*ln)\n+        option::Some(ref ln) => (/*bad*/copy *ln)\n     }\n }\n \n@@ -458,7 +459,9 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n     match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n         ty::ty_fn(ref fn_ty) => {\n-            let llargtys = type_of_explicit_args(ccx, fn_ty.sig.inputs);\n+            let llargtys = type_of_explicit_args(\n+                ccx,\n+                /*bad*/copy fn_ty.sig.inputs);\n             let llretty = type_of::type_of(ccx, fn_ty.sig.output);\n             (llargtys, llretty, fn_ty.sig.output)\n         }\n@@ -469,7 +472,8 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n fn c_stack_tys(ccx: @crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n-    let bundle_ty = T_struct(vec::append_one(llargtys, T_ptr(llretty)));\n+    // XXX: Bad copy.\n+    let bundle_ty = T_struct(vec::append_one(copy llargtys, T_ptr(llretty)));\n     let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n     let x86_64 = if ccx.sess.targ_cfg.arch == arch_x86_64 {\n         option::Some(x86_64_tys(llargtys, llretty, ret_def))\n@@ -493,7 +497,7 @@ type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef, llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @crate_ctxt,\n-                  shim_name: ~str,\n+                  +shim_name: ~str,\n                   llbasefn: ValueRef,\n                   tys: @c_stack_tys,\n                   cc: lib::llvm::CallConv,\n@@ -615,8 +619,8 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n             match tys.x86_64_tys {\n                 Some(ref x86_64) => {\n-                    let mut atys = (*x86_64).arg_tys;\n-                    let mut attrs = (*x86_64).attrs;\n+                    let mut atys = /*bad*/copy (*x86_64).arg_tys;\n+                    let mut attrs = /*bad*/copy (*x86_64).attrs;\n                     if (*x86_64).sret {\n                         let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                         let llretloc = Load(bcx, llretptr);\n@@ -696,24 +700,24 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         }\n \n         let lname = link_name(ccx, foreign_item);\n-        let llbasefn = base_fn(ccx, lname, tys, cc);\n+        let llbasefn = base_fn(ccx, copy lname, tys, cc);\n         // Name the shim function\n         let shim_name = lname + ~\"__c_stack_shim\";\n         return build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n                            build_args, build_ret);\n     }\n \n-    fn base_fn(ccx: @crate_ctxt, lname: ~str, tys: @c_stack_tys,\n+    fn base_fn(ccx: @crate_ctxt, +lname: ~str, tys: @c_stack_tys,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         match tys.x86_64_tys {\n           Some(ref x86_64) => {\n             do decl_x86_64_fn((*x86_64)) |fnty| {\n-                decl_fn(ccx.llmod, lname, cc, fnty)\n+                decl_fn(ccx.llmod, /*bad*/copy lname, cc, fnty)\n             }\n           }\n           _ => {\n-            let llbasefnty = T_fn(tys.arg_tys, tys.ret_ty);\n+            let llbasefnty = T_fn(/*bad*/copy tys.arg_tys, tys.ret_ty);\n             decl_fn(ccx.llmod, lname, cc, llbasefnty)\n           }\n         }\n@@ -786,7 +790,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n           if abi != ast::foreign_abi_rust_intrinsic {\n               let llwrapfn = get_item_val(ccx, id);\n               let tys = c_stack_tys(ccx, id);\n-              if attr::attrs_contains_name(foreign_item.attrs,\n+              if attr::attrs_contains_name(/*bad*/copy foreign_item.attrs,\n                                            ~\"rust_stack\") {\n                   build_direct_fn(ccx, llwrapfn, *foreign_item, tys, cc);\n               } else {\n@@ -806,13 +810,14 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n }\n \n fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n-                   path: ast_map::path, substs: param_substs,\n+                   +path: ast_map::path, +substs: param_substs,\n                    ref_id: Option<ast::node_id>)\n {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n+    // XXX: Bad copy.\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, None,\n-                               Some(substs), Some(item.span));\n+                               Some(copy substs), Some(item.span));\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     match ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {\n@@ -1292,18 +1297,19 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n-                  body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n-\n+fn trans_foreign_fn(ccx: @crate_ctxt, +path: ast_map::path,\n+                    decl: ast::fn_decl, body: ast::blk, llwrapfn: ValueRef,\n+                    id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n-    fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n+    fn build_rust_fn(ccx: @crate_ctxt, +path: ast_map::path,\n                      decl: ast::fn_decl, body: ast::blk,\n                      id: ast::node_id) -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n+        // XXX: Bad copy.\n         let ps = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one(path, ast_map::path_name(\n+            ccx, vec::append_one(copy path, ast_map::path_name(\n                 special_idents::clownshoe_abi\n             )));\n         let llty = type_of_fn_from_ty(ccx, t);\n@@ -1312,9 +1318,8 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n+    fn build_shim_fn(ccx: @crate_ctxt, +path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n-\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n@@ -1360,8 +1365,8 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n             match tys.x86_64_tys {\n                 option::Some(ref x86_64) => {\n-                    let mut atys = (*x86_64).arg_tys;\n-                    let mut attrs = (*x86_64).attrs;\n+                    let mut atys = /*bad*/copy (*x86_64).arg_tys;\n+                    let mut attrs = /*bad*/copy (*x86_64).attrs;\n                     let mut j = 0u;\n                     let llretptr = if (*x86_64).sret {\n                         atys = vec::tail(atys);\n@@ -1445,24 +1450,27 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n \n     let tys = c_stack_tys(ccx, id);\n     // The internal Rust ABI function - runs on the Rust stack\n-    let llrustfn = build_rust_fn(ccx, path, decl, body, id);\n+    // XXX: Bad copy.\n+    let llrustfn = build_rust_fn(ccx, copy path, decl, body, id);\n     // The internal shim function - runs on the Rust stack\n     let llshimfn = build_shim_fn(ccx, path, llrustfn, tys);\n     // The foreign C function - runs on the C stack\n     build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n }\n \n-fn register_foreign_fn(ccx: @crate_ctxt, sp: span,\n-                     path: ast_map::path, node_id: ast::node_id)\n-    -> ValueRef {\n+fn register_foreign_fn(ccx: @crate_ctxt,\n+                       sp: span,\n+                       +path: ast_map::path,\n+                       node_id: ast::node_id)\n+                    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n     return if ccx.sess.targ_cfg.arch == arch_x86_64 {\n         let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n         let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n         do decl_x86_64_fn(x86_64) |fnty| {\n-            register_fn_fuller(ccx, sp, path, node_id,\n+            register_fn_fuller(ccx, sp, /*bad*/copy path, node_id,\n                                t, lib::llvm::CCallConv, fnty)\n         }\n     } else {\n@@ -1482,7 +1490,9 @@ fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n       },\n       Some(_) => match attr::foreign_abi(i.attrs) {\n         either::Right(abi) => abi,\n-        either::Left(ref msg) => ccx.sess.span_fatal(i.span, (*msg))\n+        either::Left(ref msg) => {\n+            ccx.sess.span_fatal(i.span, (/*bad*/copy *msg))\n+        }\n       }\n     }\n }"}, {"sha": "2ea3873ebcd49d876b4f252606e26672d5da63f3", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -12,6 +12,7 @@\n //\n // Code relating to taking, dropping, etc as well as type descriptors.\n \n+\n use lib::llvm::{ValueRef, TypeRef};\n use middle::trans::base::*;\n use middle::trans::callee;\n@@ -447,7 +448,7 @@ fn trans_struct_drop(bcx: block,\n \n         // Find and call the actual destructor\n         let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                     class_did, substs.tps);\n+                                     class_did, /*bad*/copy substs.tps);\n \n         // The second argument is the \"self\" argument for drop\n         let params = lib::llvm::fn_ty_param_tys(\n@@ -656,7 +657,8 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     } else {\n         mangle_internal_name_by_seq(ccx, ~\"tydesc\")\n     };\n-    note_unique_llvm_symbol(ccx, name);\n+    // XXX: Bad copy.\n+    note_unique_llvm_symbol(ccx, copy name);\n     log(debug, fmt!(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n     let gvar = str::as_c_str(name, |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n@@ -678,7 +680,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n type glue_helper = fn@(block, ValueRef, ty::t);\n \n fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n-                        name: ~str) -> ValueRef {\n+                        +name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let mut fn_nm;\n@@ -689,7 +691,8 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n         fn_nm = mangle_internal_name_by_seq(ccx, (~\"glue_\" + name));\n     }\n     debug!(\"%s is for type %s\", fn_nm, ty_to_str(ccx.tcx, t));\n-    note_unique_llvm_symbol(ccx, fn_nm);\n+    // XXX: Bad copy.\n+    note_unique_llvm_symbol(ccx, copy fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);\n     return llfn;"}, {"sha": "28955f49844f0d6085e89b95b5cc0b91cba6621c", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::astencode;\n use middle::trans::base::{get_insn_ctxt};\n use middle::trans::base::{impl_owned_self, impl_self, no_self};"}, {"sha": "5c7ed2dd0ba8a025026235c8e3ca98538ca11aac", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -10,6 +10,7 @@\n \n // Information concerning the machine representation of various types.\n \n+\n use middle::trans::common::*;\n use middle::trans::type_of;\n use middle::ty;\n@@ -152,8 +153,9 @@ pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n         let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n         for vec::each(*variants) |variant| {\n-            let tup_ty = simplify_type(cx.tcx,\n-                                       ty::mk_tup(cx.tcx, variant.args));\n+            let tup_ty = simplify_type(\n+                cx.tcx,\n+                ty::mk_tup(cx.tcx, /*bad*/copy variant.args));\n             // Perform any type parameter substitutions.\n             let tup_ty = ty::subst(cx.tcx, substs, tup_ty);\n             // Here we possibly do a recursive call."}, {"sha": "dad4a8bd2bf4bb167817ca132ed52f50738e5155", "filename": "src/librustc/middle/trans/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -52,4 +52,4 @@ macro_rules! trace(\n     )\n );\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "070a3b667bd330cd5df6d8e9b7b49c3450f438e5", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -44,7 +44,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n+fn trans_impl(ccx: @crate_ctxt, +path: path, name: ast::ident,\n               methods: ~[@ast::method], tps: ~[ast::ty_param],\n               self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n@@ -53,7 +53,8 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     for vec::each(methods) |method| {\n         if method.tps.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            let path = vec::append_one(sub_path, path_name(method.ident));\n+            let path = vec::append_one(/*bad*/copy sub_path,\n+                                       path_name(method.ident));\n \n             let param_substs_opt;\n             match self_ty {\n@@ -90,13 +91,12 @@ Translates a (possibly monomorphized) method body.\n - `impl_id`: the node ID of the impl this method is inside\n */\n fn trans_method(ccx: @crate_ctxt,\n-                path: path,\n+                +path: path,\n                 method: &ast::method,\n-                param_substs: Option<param_substs>,\n+                +param_substs: Option<param_substs>,\n                 base_self_ty: Option<ty::t>,\n                 llfn: ValueRef,\n                 impl_id: ast::def_id) {\n-\n     // figure out how self is being passed\n     let self_arg = match method.self_ty.node {\n       ast::sty_static => {\n@@ -289,7 +289,7 @@ fn trans_static_method_callee(bcx: block,\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n \n-    match vtbls[bound_index] {\n+    match /*bad*/copy vtbls[bound_index] {\n         typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n \n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n@@ -325,8 +325,11 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(impl_id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n-            method_from_methods(ms, name).get()\n+          ast_map::node_item(@{\n+                node: ast::item_impl(_, _, _, ref ms),\n+                _\n+            }, _) => {\n+            method_from_methods(/*bad*/copy *ms, name).get()\n           }\n           _ => fail ~\"method_with_name\"\n         }\n@@ -339,8 +342,10 @@ fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n                                name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(impl_id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n-              let did = method_from_methods(ms, name);\n+          ast_map::node_item(@{\n+                node: ast::item_impl(_, _, _, ref ms), _\n+          }, _) => {\n+              let did = method_from_methods(/*bad*/copy *ms, name);\n               if did.is_some() {\n                   return did.get();\n               } else {\n@@ -400,7 +405,7 @@ fn trans_monomorphized_callee(bcx: block,\n                               mentry: typeck::method_map_entry,\n                               trait_id: ast::def_id,\n                               n_method: uint,\n-                              vtbl: typeck::vtable_origin)\n+                              +vtbl: typeck::vtable_origin)\n     -> Callee\n {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n@@ -462,7 +467,7 @@ fn combine_impl_and_methods_tps(bcx: block,\n                                 mth_did: ast::def_id,\n                                 impl_did: ast::def_id,\n                                 callee_id: ast::node_id,\n-                                rcvr_substs: ~[ty::t])\n+                                +rcvr_substs: ~[ty::t])\n     -> ~[ty::t]\n {\n     /*!\n@@ -485,12 +490,12 @@ fn combine_impl_and_methods_tps(bcx: block,\n     let ccx = bcx.ccx();\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n     let node_substs = node_id_type_params(bcx, callee_id);\n+    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n     let ty_substs\n         = vec::append(rcvr_substs,\n                       vec::tailn(node_substs,\n                                  node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);\n-    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n     debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n     debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n \n@@ -535,7 +540,7 @@ fn combine_impl_and_methods_origins(bcx: block,\n     let m_origins = vec::tailn(*r_m_origins, r_m_origins.len() - m_vtables);\n \n     // Combine rcvr + method to find the final result:\n-    @vec::append(*rcvr_origins, m_origins)\n+    @vec::append(/*bad*/copy *rcvr_origins, m_origins)\n }\n \n \n@@ -706,7 +711,7 @@ fn trans_trait_callee_from_llval(bcx: block,\n     };\n }\n \n-fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n+fn vtable_id(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> mono_id {\n     match origin {\n         typeck::vtable_static(impl_id, substs, sub_vtables) => {\n             monomorphize::make_mono_id(\n@@ -733,9 +738,9 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n     }\n }\n \n-fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n-    -> ValueRef {\n-    let hash_id = vtable_id(ccx, origin);\n+fn get_vtable(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> ValueRef {\n+    // XXX: Bad copy.\n+    let hash_id = vtable_id(ccx, copy origin);\n     match ccx.vtables.find(hash_id) {\n       Some(val) => val,\n       None => match origin {\n@@ -868,7 +873,7 @@ fn trans_trait_cast(bcx: block,\n     }\n \n     // Store the vtable into the pair or triple.\n-    let orig = ccx.maps.vtable_map.get(id)[0];\n+    let orig = /*bad*/copy ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n     Store(bcx, vtable, PointerCast(bcx,"}, {"sha": "4b5fdedb7386034a9059aa6ab37eb36163d4a2de", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::link::mangle_exported_name;\n use middle::trans::base::{get_insn_ctxt};\n use middle::trans::base::{set_inline_hint_if_appr, set_inline_hint};\n@@ -53,7 +54,8 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     for real_substs.each() |s| { assert !ty::type_has_params(*s); }\n     for substs.each() |s| { assert !ty::type_has_params(*s); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n-    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n+    // XXX: Bad copy.\n+    let hash_id = make_mono_id(ccx, fn_id, copy substs, vtables, impl_did_opt,\n                                Some(param_uses));\n     if vec::any(hash_id.params,\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n@@ -146,12 +148,12 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     }\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n-    let pt = vec::append(*pt,\n+    let pt = vec::append(/*bad*/copy *pt,\n                          ~[path_name((ccx.names)(ccx.sess.str_of(name)))]);\n-    let s = mangle_exported_name(ccx, pt, mono_ty);\n+    let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n-    let mk_lldecl = || {\n-        let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n+    let mk_lldecl = |/*bad*/copy s| {\n+        let lldecl = decl_internal_cdecl_fn(ccx.llmod, /*bad*/copy s, llfty);\n         ccx.monomorphized.insert(hash_id, lldecl);\n         lldecl\n     };\n@@ -165,11 +167,12 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n \n     let lldecl = match map_node {\n       ast_map::node_item(i@@{\n-                node: ast::item_fn(decl, _, _, ref body),\n+                // XXX: Bad copy.\n+                node: ast::item_fn(copy decl, _, _, ref body),\n                 _\n             }, _) => {\n         let d = mk_lldecl();\n-        set_inline_hint_if_appr(i.attrs, d);\n+        set_inline_hint_if_appr(/*bad*/copy i.attrs, d);\n         trans_fn(ccx, pt, decl, *body, d, no_self, psubsts, fn_id.node, None);\n         d\n       }\n@@ -189,9 +192,9 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         match (*v).node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                trans_enum_variant(ccx, enum_item.id, (*v), args,\n-                                   this_tv.disr_val, (*tvs).len() == 1u,\n+            ast::tuple_variant_kind(ref args) => {\n+                trans_enum_variant(ccx, enum_item.id, *v, /*bad*/copy *args,\n+                                   this_tv.disr_val, tvs.len() == 1u,\n                                    psubsts, d);\n             }\n             ast::struct_variant_kind(_) =>\n@@ -204,7 +207,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n       ast_map::node_method(mth, supplied_impl_did, _) => {\n         // XXX: What should the self type be here?\n         let d = mk_lldecl();\n-        set_inline_hint_if_appr(mth.attrs, d);\n+        set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n \n         // Override the impl def ID if necessary.\n         let impl_did;\n@@ -223,22 +226,22 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n                 None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n                                                             dtor\")\n         };\n-        trans_struct_dtor(ccx, *pt, dtor.node.body,\n+        trans_struct_dtor(ccx, /*bad*/copy *pt, dtor.node.body,\n           dtor.node.id, psubsts, Some(hash_id), parent_id)\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n         let d = mk_lldecl();\n-        set_inline_hint_if_appr(mth.attrs, d);\n+        set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n         debug!(\"monomorphic_fn impl_did_opt is %?\", impl_did_opt);\n-        meth::trans_method(ccx, *pt, mth, psubsts, None, d,\n+        meth::trans_method(ccx, /*bad*/copy *pt, mth, psubsts, None, d,\n                            impl_did_opt.get());\n         d\n       }\n       ast_map::node_struct_ctor(struct_def, _, _) => {\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n-                                 struct_def.fields,\n+                                 /*bad*/copy struct_def.fields,\n                                  option::expect(struct_def.ctor_id,\n                                                 ~\"ast-mapped tuple struct \\\n                                                   didn't have a ctor id\"),\n@@ -316,7 +319,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n             for bounds.each |bound| {\n                 match *bound {\n                   ty::bound_trait(_) => {\n-                    v.push(meth::vtable_id(ccx, vts[i]));\n+                    v.push(meth::vtable_id(ccx, /*bad*/copy vts[i]));\n                     i += 1u;\n                   }\n                   _ => ()\n@@ -330,15 +333,16 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n       }\n     };\n     let param_ids = match param_uses {\n-      Some(uses) => {\n-        vec::map2(precise_param_ids, uses, |id, uses| {\n+      Some(ref uses) => {\n+        vec::map2(precise_param_ids, *uses, |id, uses| {\n             if ccx.sess.no_monomorphic_collapse() {\n                 match *id {\n                     (a, b) => mono_precise(a, b)\n                 }\n             } else {\n                 match *id {\n-                    (a, b@Some(_)) => mono_precise(a, b),\n+                    // XXX: Bad copy.\n+                    (a, copy b@Some(_)) => mono_precise(a, b),\n                     (subst, None) => {\n                         if *uses == 0u {\n                             mono_any"}, {"sha": "832f4f8294eac2dff0b955ed56087d2faf777940", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -15,6 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n+\n use driver::session::*;\n use middle::resolve;\n use middle::ty;\n@@ -71,7 +72,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n     let n = match cx.tcx.items.find(did.node) {\n         None => return, // This can happen for self, for example\n-        Some(ref n) => (*n)\n+        Some(ref n) => (/*bad*/copy *n)\n     };\n     match n {\n       ast_map::node_item(item, _) => traverse_public_item(cx, item),\n@@ -98,7 +99,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n fn traverse_public_item(cx: ctx, item: @item) {\n     if cx.rmap.contains_key(item.id) { return; }\n     cx.rmap.insert(item.id, ());\n-    match item.node {\n+    match /*bad*/copy item.node {\n       item_mod(m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(nm) => {\n           if !traverse_exports(cx, item.id) {\n@@ -107,7 +108,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n               }\n           }\n       }\n-      item_fn(_, _, tps, ref blk) => {\n+      item_fn(_, _, ref tps, ref blk) => {\n         if tps.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n             traverse_inline_body(cx, (*blk));"}, {"sha": "239ed6b83eefc29984783dc0c9ea66b43e55a1c0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::abi;\n use lib::llvm::{TypeRef, ValueRef};\n use middle::trans::base::*;\n@@ -45,16 +46,16 @@ impl reflector {\n         C_int(self.bcx.ccx(), i)\n     }\n \n-    fn c_slice(s: ~str) -> ValueRef {\n+    fn c_slice(+s: ~str) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::re_static);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, false);\n+        let len = C_uint(bcx.ccx(), s.len() + 1);\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), T_ptr(T_i8()));\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n-        let len = C_uint(bcx.ccx(), s.len() + 1);\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n         scratch.val\n     }\n@@ -85,7 +86,9 @@ impl reflector {\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n             *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n                                                 for %s\", ty_name));\n-        let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);\n+        let mth_ty = ty::mk_fn(\n+            tcx,\n+            /*bad*/copy self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n@@ -110,16 +113,17 @@ impl reflector {\n         self.bcx = next_bcx\n     }\n \n-    fn bracketed(bracket_name: ~str, extra: ~[ValueRef],\n+    fn bracketed(bracket_name: ~str, +extra: ~[ValueRef],\n                  inner: fn()) {\n-        self.visit(~\"enter_\" + bracket_name, extra);\n+        // XXX: Bad copy.\n+        self.visit(~\"enter_\" + bracket_name, copy extra);\n         inner();\n         self.visit(~\"leave_\" + bracket_name, extra);\n     }\n \n     fn vstore_name_and_extra(t: ty::t,\n                              vstore: ty::vstore,\n-                             f: fn(~str,~[ValueRef])) {\n+                             f: fn(+s: ~str,+v: ~[ValueRef])) {\n         match vstore {\n           ty::vstore_fixed(n) => {\n             let extra = vec::append(~[self.c_uint(n)],\n@@ -132,7 +136,7 @@ impl reflector {\n         }\n     }\n \n-    fn leaf(name: ~str) {\n+    fn leaf(+name: ~str) {\n         self.visit(name, ~[]);\n     }\n \n@@ -143,7 +147,7 @@ impl reflector {\n         debug!(\"reflect::visit_ty %s\",\n                ty_to_str(bcx.ccx().tcx, t));\n \n-        match ty::get(t).sty {\n+        match /*bad*/copy ty::get(t).sty {\n           ty::ty_bot => self.leaf(~\"bot\"),\n           ty::ty_nil => self.leaf(~\"nil\"),\n           ty::ty_bool => self.leaf(~\"bool\"),\n@@ -219,11 +223,12 @@ impl reflector {\n               ast::noreturn => 0u,\n               ast::return_val => 1u\n             };\n+            // XXX: Must we allocate here?\n             let extra = ~[self.c_uint(pureval),\n                           self.c_uint(protoval),\n                           self.c_uint(vec::len(fty.sig.inputs)),\n                           self.c_uint(retval)];\n-            self.visit(~\"enter_fn\", extra);\n+            self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n             for fty.sig.inputs.eachi |i, arg| {\n                 let modeval = match arg.mode {\n                   ast::infer(_) => 0u,"}, {"sha": "9f107997a6554d03722a5ffb253385bc6f37fada", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -11,6 +11,7 @@\n // A \"shape\" is a compact encoding of a type that is used by interpreted glue.\n // This substitutes for the runtime tags used by e.g. MLs.\n \n+\n use back::abi;\n use lib::llvm::llvm;\n use lib::llvm::{True, False, ModuleRef, TypeRef, ValueRef};"}, {"sha": "ee44c80943bb9ba34afaddbc50e7b89dde601512", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back::abi;\n use lib::llvm::{ValueRef, TypeRef};\n use middle::trans::build::*;\n@@ -257,7 +258,7 @@ fn trans_lit_str(bcx: block,\n         SaveIn(lldest) => {\n             let bytes = lit_str.len() + 1; // count null-terminator too\n             let llbytes = C_uint(bcx.ccx(), bytes);\n-            let llcstr = C_cstr(bcx.ccx(), *lit_str);\n+            let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *lit_str);\n             let llcstr = llvm::LLVMConstPointerCast(llcstr, T_ptr(T_i8()));\n             Store(bcx, llcstr, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n             Store(bcx, llbytes, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n@@ -314,7 +315,7 @@ fn write_content(bcx: block,\n            bcx.expr_to_str(vstore_expr));\n     let _indenter = indenter();\n \n-    match content_expr.node {\n+    match /*bad*/copy content_expr.node {\n         ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n             match dest {\n                 Ignore => {\n@@ -323,7 +324,7 @@ fn write_content(bcx: block,\n                 SaveIn(lldest) => {\n                     let bytes = s.len() + 1; // copy null-terminator too\n                     let llbytes = C_uint(bcx.ccx(), bytes);\n-                    let llcstr = C_cstr(bcx.ccx(), *s);\n+                    let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *s);\n                     base::call_memcpy(bcx, lldest, llcstr, llbytes);\n                     return bcx;\n                 }\n@@ -420,7 +421,7 @@ fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n-    match content_expr.node {\n+    match /*bad*/copy content_expr.node {\n         ast::expr_lit(@{node: ast::lit_str(s), span: _}) => s.len() + 1,\n         ast::expr_vec(es, _) => es.len(),\n         ast::expr_repeat(_, count_expr, _) => {"}, {"sha": "9f413a65332a807b84bfe30a3c2dd308d6b86eaf", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use lib::llvm::llvm;\n use lib::llvm::{TypeRef};\n use middle::trans::common::*;\n@@ -107,7 +108,8 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         return llty;\n     }\n \n-    let llty = match ty::get(t).sty {\n+    // XXX: This is a terrible terrible copy.\n+    let llty = match /*bad*/copy ty::get(t).sty {\n       ty::ty_nil | ty::ty_bot => T_nil(),\n       ty::ty_bool => T_bool(),\n       ty::ty_int(t) => T_int_ty(cx, t),\n@@ -122,7 +124,10 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n \n-        common::T_named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n+        common::T_named_struct(llvm_type_name(cx,\n+                                              an_enum,\n+                                              did,\n+                                              /*bad*/copy substs.tps))\n       }\n       ty::ty_estr(ty::vstore_box) => {\n         T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n@@ -187,7 +192,10 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         // in *after* placing it into the type cache. This prevents\n         // infinite recursion with recursive struct types.\n \n-        common::T_named_struct(llvm_type_name(cx, a_struct, did, substs.tps))\n+        common::T_named_struct(llvm_type_name(cx,\n+                                              a_struct,\n+                                              did,\n+                                              /*bad*/ copy substs.tps))\n       }\n       ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),"}, {"sha": "1b2fc4e387ad8ad1b8ce86dd7d081a8135cfa186", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -27,6 +27,7 @@\n // much information, but have the disadvantage of being very\n // invasive.)\n \n+\n use metadata::csearch;\n use middle::freevars;\n use middle::trans::common::*;\n@@ -84,11 +85,11 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n     if fn_id_loc.crate != local_crate {\n         let uses = vec::from_mut(copy cx.uses);\n-        ccx.type_use_cache.insert(fn_id, uses);\n+        ccx.type_use_cache.insert(fn_id, copy uses);\n         return uses;\n     }\n     let map_node = match ccx.tcx.items.find(fn_id_loc.node) {\n-        Some(ref x) => (*x),\n+        Some(ref x) => (/*bad*/copy *x),\n         None    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n                                      fn_id_loc))\n     };\n@@ -165,7 +166,8 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       }\n     }\n     let uses = vec::from_mut(copy cx.uses);\n-    ccx.type_use_cache.insert(fn_id, uses);\n+    // XXX: Bad copy, use @vec instead?\n+    ccx.type_use_cache.insert(fn_id, copy uses);\n     uses\n }\n "}, {"sha": "58853224891d8aafb7dade5dc1cbb3930cbea091", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use back;\n use lib::llvm::ValueRef;\n use middle::trans::base::*;"}, {"sha": "1841d0b17e32dcd2d5c3af2fb290adbbe362dff2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -1172,9 +1172,9 @@ fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec({ty: ty, mutbl: ast::m_imm}))\n }\n \n-fn mk_rec(cx: ctxt, fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n+fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n-fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n+fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n // take a copy because we want to own the various vectors inside\n fn mk_fn(cx: ctxt, +fty: FnTy) -> t { mk_t(cx, ty_fn(fty)) }\n@@ -1213,7 +1213,7 @@ fn mk_opaque_closure_ptr(cx: ctxt, proto: ast::Proto) -> t {\n fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n-    mk_t_with_id(cx, get(base).sty, Some(def_id))\n+    mk_t_with_id(cx, /*bad*/copy get(base).sty, Some(def_id))\n }\n \n // Converts s to its machine type equivalent\n@@ -1222,7 +1222,7 @@ pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n       ty_float(ast::ty_f) => ty_float(cfg.float_type),\n-      ref s => (*s)\n+      ref s => (/*bad*/copy *s)\n     }\n }\n \n@@ -1286,7 +1286,7 @@ fn walk_ty(ty: t, f: fn(t)) {\n \n fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     if !f(ty) { return; }\n-    match get(ty).sty {\n+    match /*bad*/copy get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n@@ -1322,7 +1322,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n          tps: substs.tps.map(|t| fldop(*t))}\n     }\n \n-    match *sty {\n+    match /*bad*/copy *sty {\n         ty_box(tm) => {\n             ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n@@ -1376,7 +1376,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n         ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self => {\n-            *sty\n+            /*bad*/copy *sty\n         }\n     }\n }\n@@ -1476,7 +1476,7 @@ fn apply_op_on_t_to_ty_fn(\n     f: &FnTy,\n     t_op: fn(t) -> t) -> FnTy\n {\n-    let t0 = ty::mk_fn(cx, *f);\n+    let t0 = ty::mk_fn(cx, /*bad*/copy *f);\n     let t1 = t_op(t0);\n     match ty::get(t1).sty {\n         ty::ty_fn(copy f) => {\n@@ -1701,7 +1701,7 @@ fn sequence_element_type(cx: ctxt, ty: t) -> t {\n }\n \n fn get_element_type(ty: t, i: uint) -> t {\n-    match get(ty).sty {\n+    match /*bad*/copy get(ty).sty {\n       ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n       _ => fail ~\"get_element_type called on invalid type\"\n@@ -1794,7 +1794,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     }\n \n     let mut accum = false;\n-    let result = match get(ty).sty {\n+    let result = match /*bad*/copy get(ty).sty {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_rptr(_, _) |\n@@ -2154,7 +2154,7 @@ fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n     // Insert a default in case we loop back on self recursively.\n     cx.kind_cache.insert(ty, kind_top());\n \n-    let mut result = match get(ty).sty {\n+    let mut result = match /*bad*/copy get(ty).sty {\n       // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) => {\n@@ -2326,7 +2326,7 @@ fn type_implicitly_moves(cx: ctxt, ty: t) -> bool {\n /// gives a rough estimate of how much space it takes to represent\n /// an instance of `ty`.  Used for the mode transition.\n fn type_size(cx: ctxt, ty: t) -> uint {\n-    match get(ty).sty {\n+    match /*bad*/copy get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n       ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n@@ -2411,7 +2411,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n-        let r = match get(ty).sty {\n+        let r = match /*bad*/copy get(ty).sty {\n           ty_nil |\n           ty_bot |\n           ty_bool |\n@@ -2503,7 +2503,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n     debug!(\"type_structurally_contains: %s\",\n            ::util::ppaux::ty_to_str(cx, ty));\n     if test(sty) { return true; }\n-    match *sty {\n+    match /*bad*/copy *sty {\n       ty_enum(did, ref substs) => {\n         for vec::each(*enum_variants(cx, did)) |variant| {\n             for variant.args.each |aty| {\n@@ -2589,7 +2589,7 @@ fn type_is_signed(ty: t) -> bool {\n // that the cycle collector might care about.\n fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let mut result = true;\n-    match get(ty).sty {\n+    match /*bad*/copy get(ty).sty {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) => result = true,\n@@ -2602,7 +2602,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n         for vec::each(*variants) |variant| {\n-            let tup_ty = mk_tup(cx, variant.args);\n+            let tup_ty = mk_tup(cx, /*bad*/copy variant.args);\n \n             // Perform any type parameter substitutions.\n             let tup_ty = subst(cx, substs, tup_ty);\n@@ -2943,7 +2943,7 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n // Type accessors for substructures of types\n fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {\n-      ty_fn(ref f) => f.sig.inputs,\n+      ty_fn(ref f) => /*bad*/copy f.sig.inputs,\n       _ => fail ~\"ty_fn_args() called on non-fn type\"\n     }\n }\n@@ -3054,8 +3054,8 @@ fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // trait itself.  This ought to be harmonized.\n             let trt_bounds =\n                 ty::lookup_item_type(tcx, trt_id).bounds;\n-            let mth = ty::trait_methods(tcx, trt_id)[n_mth];\n-            @(vec::append(*trt_bounds, *mth.tps))\n+            let mth = /*bad*/copy ty::trait_methods(tcx, trt_id)[n_mth];\n+            @(vec::append(/*bad*/copy *trt_bounds, *mth.tps))\n           }\n         }\n     }\n@@ -3252,7 +3252,7 @@ fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n }\n \n fn get_fields(rec_ty:t) -> ~[field] {\n-    match get(rec_ty).sty {\n+    match /*bad*/copy get(rec_ty).sty {\n       ty_rec(fields) => fields,\n       // Can we check at the caller?\n       _ => fail ~\"get_fields: not a record type\"\n@@ -3597,7 +3597,7 @@ fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n                         node: item_trait(_, _, ref ms),\n                         _\n                     }, _)) =>\n-                match ast_util::split_trait_methods((*ms)) {\n+                match ast_util::split_trait_methods((/*bad*/copy *ms)) {\n                    (_, p) => p.map(|method| method.ident)\n                 },\n             _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n@@ -3627,7 +3627,7 @@ fn trait_supertraits(cx: ctxt, id: ast::def_id) -> @~[InstantiatedTraitRef] {\n             ty_trait(def_id, ref substs, _) => {\n                 result.push(InstantiatedTraitRef {\n                     def_id: def_id,\n-                    tpt: { substs: (*substs), ty: *trait_type }\n+                    tpt: { substs: (/*bad*/copy *substs), ty: *trait_type }\n                 });\n             }\n             _ => cx.sess.bug(~\"trait_supertraits: trait ref wasn't a trait\")\n@@ -3665,7 +3665,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n         match ty::get(ty).sty {\n             ty::ty_trait(_, _, trait_vstore) if vstore == trait_vstore => ty,\n             ty::ty_trait(did, ref substs, _) => {\n-                mk_trait(cx, did, (*substs), vstore)\n+                mk_trait(cx, did, (/*bad*/copy *substs), vstore)\n             }\n             _ => cx.sess.bug(~\"impl_traits: not a trait\")\n         }\n@@ -3745,7 +3745,7 @@ fn substd_enum_variants(cx: ctxt,\n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n         @VariantInfo_{args: substd_args, ctor_ty: substd_ctor_ty,\n-                      ..**variant_info}\n+                      ../*bad*/copy **variant_info}\n     }\n }\n \n@@ -3817,19 +3817,22 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                 ast_map::path_name(item.ident)\n               }\n             };\n-            vec::append_one(*path, item_elt)\n+            vec::append_one(/*bad*/copy *path, item_elt)\n           }\n \n           ast_map::node_foreign_item(nitem, _, path) => {\n-            vec::append_one(*path, ast_map::path_name(nitem.ident))\n+            vec::append_one(/*bad*/copy *path,\n+                            ast_map::path_name(nitem.ident))\n           }\n \n           ast_map::node_method(method, _, path) => {\n-            vec::append_one(*path, ast_map::path_name(method.ident))\n+            vec::append_one(/*bad*/copy *path,\n+                            ast_map::path_name(method.ident))\n           }\n           ast_map::node_trait_method(trait_method, _, path) => {\n             let method = ast_util::trait_method_to_ty_method(*trait_method);\n-            vec::append_one(*path, ast_map::path_name(method.ident))\n+            vec::append_one(/*bad*/copy *path,\n+                            ast_map::path_name(method.ident))\n           }\n \n           ast_map::node_variant(ref variant, _, path) => {\n@@ -3838,12 +3841,12 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_dtor(_, _, _, path) => {\n-            vec::append_one(*path, ast_map::path_name(\n+            vec::append_one(/*bad*/copy *path, ast_map::path_name(\n                 syntax::parse::token::special_idents::literally_dtor))\n           }\n \n           ast_map::node_struct_ctor(_, item, path) => {\n-            vec::append_one(*path, ast_map::path_name(item.ident))\n+            vec::append_one(/*bad*/copy *path, ast_map::path_name(item.ident))\n           }\n \n           ast_map::node_stmt(*) | ast_map::node_expr(*) |\n@@ -3885,7 +3888,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let variants = (*enum_definition).variants;\n+            let variants = /*bad*/copy (*enum_definition).variants;\n             let mut disr_val = -1;\n             @vec::map(variants, |variant| {\n                 match variant.node.kind {\n@@ -3994,15 +3997,15 @@ fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n        Some(ast_map::node_item(i,_)) => {\n          match i.node {\n             ast::item_struct(struct_def, _) => {\n-               struct_field_tys(struct_def.fields)\n+               struct_field_tys(/*bad*/copy struct_def.fields)\n             }\n             _ => cx.sess.bug(~\"struct ID bound to non-struct\")\n          }\n        }\n        Some(ast_map::node_variant(ref variant, _, _)) => {\n           match (*variant).node.kind {\n             ast::struct_variant_kind(struct_def) => {\n-              struct_field_tys(struct_def.fields)\n+              struct_field_tys(/*bad*/copy struct_def.fields)\n             }\n             _ => {\n               cx.sess.bug(~\"struct ID bound to enum variant that isn't \\\n@@ -4211,7 +4214,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n                     region: ty::re_static,\n                     ..fn_ty.meta\n                 },\n-                sig: fn_ty.sig\n+                sig: /*bad*/copy fn_ty.sig\n             })\n         }\n \n@@ -4222,7 +4225,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n                     mk_enum(cx, did,\n                      {self_r: Some(ty::re_static),\n                       self_ty: None,\n-                      tps: (*r).tps}),\n+                      tps: /*bad*/copy (*r).tps}),\n                 None =>\n                     t\n             },\n@@ -4233,7 +4236,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n                 // Ditto.\n                 mk_struct(cx, did, {self_r: Some(ty::re_static),\n                                     self_ty: None,\n-                                    tps: (*r).tps}),\n+                                    tps: /*bad*/copy (*r).tps}),\n               None =>\n                 t\n             },\n@@ -4537,7 +4540,7 @@ impl InferTy : cmp::Eq {\n \n impl sty : cmp::Eq {\n     pure fn eq(&self, other: &sty) -> bool {\n-        match (*self) {\n+        match (/*bad*/copy *self) {\n             ty_nil => {\n                 match (*other) {\n                     ty_nil => true,\n@@ -4617,7 +4620,7 @@ impl sty : cmp::Eq {\n                 }\n             }\n             ty_rec(e0a) => {\n-                match (*other) {\n+                match (/*bad*/copy *other) {\n                     ty_rec(e0b) => e0a == e0b,\n                     _ => false\n                 }\n@@ -4642,7 +4645,7 @@ impl sty : cmp::Eq {\n                 }\n             }\n             ty_tup(e0a) => {\n-                match (*other) {\n+                match (/*bad*/copy *other) {\n                     ty_tup(e0b) => e0a == e0b,\n                     _ => false\n                 }"}, {"sha": "635a83ba25163d5508783f4b77f08b18dc93130b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -52,6 +52,7 @@\n  * an rptr (`&r.T`) use the region `r` that appears in the rptr.\n  */\n \n+\n use middle::ty::{FnTyBase, FnMeta, FnSig};\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n@@ -80,7 +81,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n     match res {\n       result::Ok(r) => r,\n       result::Err(ref e) => {\n-        tcx.sess.span_err(span, (*e));\n+        tcx.sess.span_err(span, (/*bad*/copy *e));\n         ty::re_static\n       }\n     }\n@@ -145,7 +146,8 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n \n     let substs = {self_r:self_r, self_ty:None, tps:tps};\n-    {substs: substs, ty: ty::subst(tcx, &substs, decl_ty)}\n+    let ty = ty::subst(tcx, &substs, decl_ty);\n+    {substs: substs, ty: ty}\n }\n \n pub fn ast_path_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n@@ -161,7 +163,7 @@ pub fn ast_path_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     let {substs: substs, ty: ty} =\n         ast_path_to_substs_and_ty(self, rscope, did, path);\n     write_ty_to_tcx(tcx, path_id, ty);\n-    write_substs_to_tcx(tcx, path_id, substs.tps);\n+    write_substs_to_tcx(tcx, path_id, /*bad*/copy substs.tps);\n     return {substs: substs, ty: ty};\n }\n \n@@ -225,7 +227,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n                                     }\n                                 }\n                                 return ty::mk_trait(tcx, trait_def_id,\n-                                                    (*substs), vst);\n+                                                    /*bad*/copy *substs, vst);\n \n                             }\n                             _ => {}\n@@ -274,7 +276,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     }\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n-    let typ = match ast_ty.node {\n+    let typ = match /*bad*/copy ast_ty.node {\n       ast::ty_nil => ty::mk_nil(tcx),\n       ast::ty_bot => ty::mk_bot(tcx),\n       ast::ty_box(mt) => {"}, {"sha": "95bd9a397696cea4cd58388a1ede285f256462a1", "filename": "src/librustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::pat_util::{pat_is_binding, pat_is_const};\n use middle::pat_util::{pat_is_variant_or_struct};\n use middle::ty;\n@@ -69,7 +70,7 @@ struct pat_ctxt {\n }\n \n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n-                     subpats: Option<~[@ast::pat]>, expected: ty::t) {\n+                     +subpats: Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -150,7 +151,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n     let subpats_len;\n     match subpats {\n         None => subpats_len = arg_len,\n-        Some(subpats) => subpats_len = subpats.len()\n+        Some(ref subpats) => subpats_len = subpats.len()\n     }\n \n     if arg_len > 0u {\n@@ -244,7 +245,7 @@ fn check_struct_pat_fields(pcx: pat_ctxt,\n \n fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n                     expected: ty::t, path: @ast::path,\n-                    fields: ~[ast::field_pat], etc: bool,\n+                    +fields: ~[ast::field_pat], etc: bool,\n                     class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -285,7 +286,7 @@ fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n                                       span: span,\n                                       expected: ty::t,\n                                       path: @ast::path,\n-                                      fields: ~[ast::field_pat],\n+                                      +fields: ~[ast::field_pat],\n                                       etc: bool,\n                                       enum_id: ast::def_id,\n                                       substitutions: &ty::substs) {\n@@ -322,7 +323,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    match pat.node {\n+    match /*bad*/copy pat.node {\n       ast::pat_wild => {\n         fcx.write_ty(pat.id, expected);\n       }"}, {"sha": "954608540f5cb7ebeef44abe618ec64312a9361e", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n use middle::typeck::infer;"}, {"sha": "1a788fd9574449c3de455e1038339c8aaa32b9ba", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -79,6 +79,7 @@ obtained the type `Foo`, we would never match this method.\n \n */\n \n+\n use middle::resolve::{Impl, MethodInfo};\n use middle::resolve;\n use middle::ty::*;\n@@ -358,7 +359,7 @@ impl LookupContext {\n \n \n             let bound_substs = match ty::get(bound_trait_ty).sty {\n-                ty::ty_trait(_, ref substs, _) => (*substs),\n+                ty::ty_trait(_, ref substs, _) => (/*bad*/copy *substs),\n                 _ => {\n                     self.bug(fmt!(\"add_candidates_from_param: \\\n                                    non-trait bound %s\",\n@@ -386,7 +387,7 @@ impl LookupContext {\n \n             let mut i = 0;\n             while i < worklist.len() {\n-                let (init_trait_ty, init_substs) = worklist[i];\n+                let (init_trait_ty, init_substs) = /*bad*/copy worklist[i];\n                 i += 1;\n \n                 let init_trait_id = ty::ty_to_def_id(init_trait_ty).get();\n@@ -491,7 +492,7 @@ impl LookupContext {\n         // `trait_ty` for `self` here, because it allows the compiler\n         // to soldier on.  An error will be reported should this\n         // candidate be selected if the method refers to `self`.\n-        let rcvr_substs = {self_ty: Some(self_ty), ..*substs};\n+        let rcvr_substs = {self_ty: Some(self_ty), ../*bad*/copy *substs};\n \n         let (rcvr_ty, rcvr_substs) =\n             self.create_rcvr_ty_and_substs_for_method(method.self_ty,\n@@ -522,7 +523,7 @@ impl LookupContext {\n         }\n         let method = &methods[index];\n \n-        let rcvr_substs = { self_ty: Some(self_ty), ..*substs };\n+        let rcvr_substs = { self_ty: Some(self_ty), ../*bad*/copy *substs };\n         let (rcvr_ty, rcvr_substs) =\n             self.create_rcvr_ty_and_substs_for_method(\n                 method.self_ty,\n@@ -893,13 +894,13 @@ impl LookupContext {\n         let mut merged = ~[];\n         let mut i = 0;\n         while i < candidates.len() {\n-            let candidate_a = candidates[i];\n+            let candidate_a = /*bad*/copy candidates[i];\n \n             let mut skip = false;\n \n             let mut j = i + 1;\n             while j < candidates.len() {\n-                let candidate_b = candidates[j];\n+                let candidate_b = /*bad*/copy candidates[j];\n                 debug!(\"attempting to merge %? and %?\",\n                        candidate_a, candidate_b);\n                 let candidates_same = match (&candidate_a.origin,\n@@ -985,9 +986,11 @@ impl LookupContext {\n \n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n-        let all_substs = {tps: vec::append(candidate.rcvr_substs.tps,\n-                                           m_substs),\n-                          ..candidate.rcvr_substs};\n+        let all_substs = {\n+            tps: vec::append(/*bad*/copy candidate.rcvr_substs.tps,\n+                             m_substs),\n+            ../*bad*/copy candidate.rcvr_substs\n+        };\n \n         self.fcx.write_ty_substs(self.callee_id, fty, all_substs);\n         return {self_arg: {mode: ast::expl(candidate.self_mode),\n@@ -1072,7 +1075,7 @@ impl LookupContext {\n                                 trait_did: def_id,\n                                 method_num: uint) -> ty::t {\n             let trait_methods = ty::trait_methods(tcx, trait_did);\n-            ty::mk_fn(tcx, trait_methods[method_num].fty)\n+            ty::mk_fn(tcx, /*bad*/copy trait_methods[method_num].fty)\n         }\n     }\n \n@@ -1147,7 +1150,7 @@ impl LookupContext {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(&self, s: ~str) -> ! {\n+    fn bug(&self, +s: ~str) -> ! {\n         self.tcx().sess.bug(s)\n     }\n }"}, {"sha": "3086b2e72278af2da7673d8f1ec9d3bc92a15180", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 84, "deletions": 48, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -76,6 +76,7 @@ type parameter).\n \n */\n \n+\n use middle::capture;\n use middle::const_eval;\n use middle::pat_util;\n@@ -349,7 +350,8 @@ fn check_fn(ccx: @crate_ctxt,\n         }\n     };\n \n-    gather_locals(fcx, decl, body, arg_tys, self_info);\n+    // XXX: Bad copy.\n+    gather_locals(fcx, decl, body, copy arg_tys, self_info);\n     check_block(fcx, body);\n \n     // We unify the tail expr's type with the\n@@ -546,13 +548,16 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n \n-    match it.node {\n+    match /*bad*/copy it.node {\n       ast::item_const(_, e) => check_const(ccx, it.span, e, it.id),\n       ast::item_enum(ref enum_definition, _) => {\n-        check_enum_variants(ccx, it.span, (*enum_definition).variants, it.id);\n+        check_enum_variants(ccx,\n+                            it.span,\n+                            /*bad*/copy (*enum_definition).variants,\n+                            it.id);\n       }\n-      ast::item_fn(decl, _, _, ref body) => {\n-        check_bare_fn(ccx, decl, (*body), it.id, None);\n+      ast::item_fn(ref decl, _, _, ref body) => {\n+        check_bare_fn(ccx, *decl, (*body), it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(it.id);\n@@ -743,7 +748,7 @@ impl @fn_ctxt {\n     }\n     fn node_ty_substs(id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(id) {\n-            Some(ref ts) => (*ts),\n+            Some(ref ts) => (/*bad*/copy *ts),\n             None => {\n                 self.tcx().sess.bug(\n                     fmt!(\"no type substs for node %d: %s in fcx %s\",\n@@ -973,13 +978,13 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n         let region_param = tcx.region_paramd_items.find(did.node);\n         match tcx.items.find(did.node) {\n-          Some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n+          Some(ast_map::node_item(@{node: ast::item_impl(ref ts, _, st, _),\n                                   _}, _)) => {\n             {n_tps: ts.len(),\n              region_param: region_param,\n              raw_ty: vcx.ccx.to_ty(rscope::type_rscope(region_param), st)}\n           }\n-          Some(ast_map::node_item(@{node: ast::item_struct(_, ts),\n+          Some(ast_map::node_item(@{node: ast::item_struct(_, ref ts),\n                                     id: class_id, _},_)) => {\n               /* If the impl is a class, the self ty is just the class ty\n                  (doing a no-op subst for the ty params; in the next step,\n@@ -990,7 +995,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                raw_ty: ty::mk_struct(tcx, local_def(class_id),\n                       {self_r: rscope::bound_self_region(region_param),\n                        self_ty: None,\n-                       tps: ty::ty_params_to_tys(tcx, ts)})}\n+                       tps: ty::ty_params_to_tys(tcx, /*bad*/copy *ts)})}\n           }\n           _ => { tcx.sess.bug(~\"impl_self_ty: unbound item or item that \\\n                doesn't have a self_ty\"); }\n@@ -1036,6 +1041,10 @@ pub enum DerefArgs {\n     DoDerefArgs\n }\n \n+fn break_here() {\n+    debug!(\"break here!\");\n+}\n+\n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n                            expected: Option<ty::t>,\n@@ -1072,7 +1081,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let fty =\n             match structure_of(fcx, sp, in_fty) {\n               ty::ty_fn(ref fn_ty) => {\n-                  let fn_ty = replace_bound_regions_in_fn_ty(tcx, @Nil,\n+                  let fn_ty =\n+                    /*bad*/copy replace_bound_regions_in_fn_ty(tcx, @Nil,\n                       None, fn_ty, |_br| fcx.infcx().next_region_var(sp,\n                                                       call_expr_id)).fn_ty;\n \n@@ -1189,7 +1199,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                             call_expr_id: ast::node_id,\n                             fn_ty: ty::t,\n                             expr: @ast::expr,\n-                            args: ~[@ast::expr],\n+                            +args: ~[@ast::expr],\n                             bot: bool)\n                          -> bool {\n         let mut bot = bot;\n@@ -1220,11 +1230,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n-                  f: @ast::expr, args: ~[@ast::expr]) -> bool {\n-\n+                  f: @ast::expr, +args: ~[@ast::expr]) -> bool {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        let mut bot = match f.node {\n+        let mut bot = match /*bad*/copy f.node {\n             ast::expr_field(base, field, tys) => {\n                 check_field(fcx, f, true, base, field, tys)\n             }\n@@ -1245,7 +1254,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                          expr: @ast::expr,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n-                         args: ~[@ast::expr],\n+                         +args: ~[@ast::expr],\n                          tps: ~[@ast::Ty])\n                       -> bool {\n         let bot = check_expr(fcx, rcvr, None);\n@@ -1331,7 +1340,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n-                        opname: ast::ident, args: ~[@ast::expr],\n+                        opname: ast::ident, +args: ~[@ast::expr],\n                         +deref_args: DerefArgs)\n         -> Option<(ty::t, bool)>\n     {\n@@ -1509,7 +1518,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         replace_bound_regions_in_fn_ty(\n                             tcx, @Nil, None, fn_ty,\n                             |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n-                    (Some({inputs: fn_ty.sig.inputs,\n+                    (Some({inputs: /*bad*/copy fn_ty.sig.inputs,\n                            output: fn_ty.sig.output}),\n                      fn_ty.meta.purity,\n                      fn_ty.meta.proto,\n@@ -1535,7 +1544,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             /*bounds:*/ @~[], /*opt_region:*/ None,\n             decl, expected_tys, expr.span);\n \n-        let fty = ty::mk_fn(tcx, fn_ty);\n+        // XXX: Bad copy.\n+        let fty = ty::mk_fn(tcx, copy fn_ty);\n \n         debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n                expr_to_str(expr, tcx.sess.intr()),\n@@ -1724,7 +1734,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 tcx.region_paramd_items.find(class_id.node);\n             match tcx.items.find(class_id.node) {\n                 Some(ast_map::node_item(@{\n-                        node: ast::item_struct(_, type_parameters),\n+                        node: ast::item_struct(_, ref type_parameters),\n                         _\n                     }, _)) => {\n \n@@ -1736,7 +1746,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     raw_type = ty::mk_struct(tcx, class_id, {\n                         self_r: self_region,\n                         self_ty: None,\n-                        tps: ty::ty_params_to_tys(tcx, type_parameters)\n+                        tps: ty::ty_params_to_tys(\n+                            tcx,\n+                            /*bad*/copy *type_parameters)\n                     });\n                 }\n                 _ => {\n@@ -1805,7 +1817,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 tcx.region_paramd_items.find(enum_id.node);\n             match tcx.items.find(enum_id.node) {\n                 Some(ast_map::node_item(@{\n-                        node: ast::item_enum(_, type_parameters),\n+                        node: ast::item_enum(_, ref type_parameters),\n                         _\n                     }, _)) => {\n \n@@ -1817,7 +1829,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     raw_type = ty::mk_enum(tcx, enum_id, {\n                         self_r: self_region,\n                         self_ty: None,\n-                        tps: ty::ty_params_to_tys(tcx, type_parameters)\n+                        tps: ty::ty_params_to_tys(\n+                            tcx,\n+                            /*bad*/copy *type_parameters)\n                     });\n                 }\n                 _ => {\n@@ -1864,9 +1878,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n-    match expr.node {\n+    match /*bad*/copy expr.node {\n       ast::expr_vstore(ev, vst) => {\n-        let typ = match ev.node {\n+        let typ = match /*bad*/copy ev.node {\n           ast::expr_lit(@{node: ast::lit_str(s), span:_}) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n@@ -2108,16 +2122,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = !may_break(tcx, expr.id, (*body));\n       }\n       ast::expr_match(discrim, ref arms) => {\n-        bot = alt::check_alt(fcx, expr, discrim, (*arms));\n+        bot = alt::check_alt(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n-      ast::expr_fn(proto, decl, ref body, cap_clause) => {\n+      ast::expr_fn(proto, ref decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, Some(proto),\n-                      decl, (*body), Vanilla, expected);\n+                      *decl, (*body), Vanilla, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n-      ast::expr_fn_block(decl, ref body, cap_clause) => {\n+      ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, None,\n-                      decl, (*body), Vanilla, expected);\n+                      *decl, (*body), Vanilla, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_loop_body(b) => {\n@@ -2148,7 +2162,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             ty::mk_fn(tcx, FnTyBase {\n                 meta: (*fty).meta,\n                 sig: FnSig {output: ty::mk_nil(tcx),\n-                            ..(*fty).sig}\n+                            ../*bad*/copy (*fty).sig}\n             })\n           }\n           _ =>\n@@ -2171,9 +2185,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-          ast::expr_fn_block(decl, ref body, cap_clause) => {\n+          ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, (*body), ForLoop, Some(inner_ty));\n+                          *decl, (*body), ForLoop, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n@@ -2188,7 +2202,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                   fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n                       meta: (*fty).meta,\n                       sig: FnSig {output: ty::mk_bool(tcx),\n-                                  ..(*fty).sig}\n+                                  ../*bad*/copy (*fty).sig}\n                   }));\n               }\n               else {\n@@ -2202,7 +2216,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(x));\n         let inner_ty = match expected_sty {\n           Some(ty::ty_fn(ref fty)) => {\n-              ty::mk_fn(tcx, (*fty))\n+              ty::mk_fn(tcx, (/*bad*/copy *fty))\n           }\n           _ => match expected {\n                   Some(expected_t) => {\n@@ -2220,9 +2234,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-          ast::expr_fn_block(decl, ref body, cap_clause) => {\n+          ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, (*body), DoBlock, Some(inner_ty));\n+                          *decl, (*body), DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n@@ -2233,7 +2247,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx, expr.span, fcx.node_ty(b.id));\n         match ty::get(block_ty).sty {\n           ty::ty_fn(ref fty) => {\n-            fcx.write_ty(expr.id, ty::mk_fn(tcx, (*fty)));\n+            fcx.write_ty(expr.id, ty::mk_fn(tcx, (/*bad*/copy *fty)));\n           }\n           _ => fail ~\"expected fn ty\"\n         }\n@@ -2315,7 +2329,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_tup(elts) => {\n         let flds = unpack_expected(fcx, expected, |sty| {\n-            match sty { ty::ty_tup(flds) => Some(flds), _ => None }\n+            // XXX: Beware! If you remove `copy` below, the borrow checker\n+            // will NOT complain, but you will get a segfault at runtime! This\n+            // is because the mode computation is currently unaware of\n+            // argument modes.\n+            match copy sty { ty::ty_tup(flds) => Some(flds), _ => None }\n         });\n         let elt_ts = do elts.mapi |i, e| {\n             check_expr(fcx, *e, flds.map(|fs| fs[i]));\n@@ -2330,7 +2348,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             Some(fcx.expr_ty(base.get()))\n         } else { expected };\n         let flds = unpack_expected(fcx, expected, |sty|\n-            match sty { ty::ty_rec(flds) => Some(flds), _ => None }\n+            // XXX: Beware! If you remove `copy` below, the borrow checker\n+            // will NOT complain, but you will get a segfault at runtime! This\n+            // is because the mode computation is currently unaware of\n+            // argument modes.\n+            match copy sty {\n+                ty::ty_rec(flds) => Some(flds),\n+                _ => None\n+            }\n         );\n         let fields_t = vec::map((*fields), |f| {\n             bot |= check_expr(fcx, f.node.expr, flds.chain_ref(|flds|\n@@ -2392,11 +2417,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match tcx.def_map.find(id) {\n             Some(ast::def_struct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n-                                         (*fields), base_expr);\n+                                         (/*bad*/copy *fields), base_expr);\n             }\n             Some(ast::def_variant(enum_id, variant_id)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, (*fields));\n+                                          variant_id, (/*bad*/copy *fields));\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n@@ -2441,8 +2466,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n     if bot { fcx.write_bot(expr.id); }\n \n-    debug!(\"type of expr %s is %s, expected is %s\",\n-           syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()),\n+    debug!(\"type of expr %s is...\",\n+           syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()));\n+    debug!(\"... %s, expected is %s\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n@@ -2502,7 +2528,7 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     match stmt.node {\n       ast::stmt_decl(decl, id) => {\n         node_id = id;\n-        match decl.node {\n+        match /*bad*/copy decl.node {\n           ast::decl_local(ls) => for ls.each |l| {\n             bot |= check_decl_local(fcx, *l);\n           },\n@@ -2614,7 +2640,7 @@ fn check_instantiable(tcx: ty::ctxt,\n \n fn check_enum_variants(ccx: @crate_ctxt,\n                        sp: span,\n-                       vs: ~[ast::variant],\n+                       +vs: ~[ast::variant],\n                        id: ast::node_id) {\n     fn do_check(ccx: @crate_ctxt, sp: span, vs: ~[ast::variant],\n                 id: ast::node_id, disr_vals: &mut ~[int], disr_val: &mut int,\n@@ -2659,7 +2685,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n             *disr_val += 1;\n \n             match v.node.kind {\n-                ast::tuple_variant_kind(args) if args.len() > 0u => {\n+                ast::tuple_variant_kind(ref args) if args.len() > 0u => {\n                     arg_tys = Some(ty::ty_fn_args(ctor_ty).map(|a| a.ty));\n                 }\n                 ast::tuple_variant_kind(_) => {\n@@ -2672,7 +2698,13 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                 }\n                 ast::enum_variant_kind(_) => {\n                     arg_tys = None;\n-                    do_check(ccx, sp, vs, id, disr_vals, disr_val, variants);\n+                    do_check(ccx,\n+                             sp,\n+                             /*bad*/copy vs,\n+                             id,\n+                             disr_vals,\n+                             disr_val,\n+                             variants);\n                 }\n             }\n \n@@ -2809,6 +2841,8 @@ fn instantiate_path(fcx: @fn_ctxt,\n                     span: span,\n                     node_id: ast::node_id,\n                     region_lb: ty::Region) {\n+    debug!(\">>> instantiate_path\");\n+\n     let ty_param_count = vec::len(*tpt.bounds);\n     let ty_substs_len = vec::len(pth.types);\n \n@@ -2855,6 +2889,8 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n     let substs = {self_r: self_r, self_ty: None, tps: tps};\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n+\n+    debug!(\"<<<\");\n }\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n@@ -2873,7 +2909,7 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n \n // Returns the one-level-deep structure of the given type.\n fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n-    ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n+    /*bad*/copy ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {"}, {"sha": "c74b5789075e86dcd245ad602e8813ac0bf023fa", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -27,6 +27,7 @@ this point a bit better.\n \n */\n \n+\n use middle::freevars::get_freevars;\n use middle::pat_util::pat_bindings;\n use middle::ty::{encl_region, re_scope};\n@@ -168,7 +169,7 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\",\n            pprust::expr_to_str(expr, rcx.fcx.tcx().sess.intr()));\n \n-    match expr.node {\n+    match /*bad*/copy expr.node {\n         ast::expr_path(*) => {\n             // Avoid checking the use of local variables, as we\n             // already check their definitions.  The def'n always"}, {"sha": "c7000bb7e70ba06fe097c3d16119da4f85af90ec", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // #[warn(deprecated_mode)];\n-// #[warn(deprecated_pattern)];\n \n use middle::ty;\n use util::ppaux;\n@@ -60,7 +59,7 @@ fn replace_bound_regions_in_fn_ty(\n         debug!(\"br=%?\", br);\n         mapf(br)\n     };\n-    let ty_fn = ty::ty_fn(*fn_ty);\n+    let ty_fn = ty::ty_fn(/*bad*/copy *fn_ty);\n     let t_fn = ty::fold_sty_to_ty(tcx, &ty_fn, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n@@ -80,7 +79,7 @@ fn replace_bound_regions_in_fn_ty(\n \n     return {isr: isr,\n          self_info: new_self_info,\n-         fn_ty: match ty::get(t_fn).sty { ty::ty_fn(ref o) => (*o),\n+         fn_ty: match ty::get(t_fn).sty { ty::ty_fn(ref o) => /*bad*/copy *o,\n           _ => tcx.sess.bug(~\"replace_bound_regions_in_fn_ty: impossible\")}};\n \n "}, {"sha": "0872b1445c3e95eadd58f6185b0f7670942667b7", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::resolve;\n use middle::ty;\n use middle::typeck::check::{fn_ctxt, impl_self_ty};\n@@ -95,7 +96,7 @@ fn lookup_vtables(vcx: &VtableContext,\n                    ppaux::ty_to_str(tcx, trait_ty),\n                    ty::substs_to_str(tcx, substs));\n \n-            let new_substs = {self_ty: Some(*ty), ..*substs};\n+            let new_substs = {self_ty: Some(*ty), ../*bad*/copy *substs};\n             let trait_ty = ty::subst(tcx, &new_substs, trait_ty);\n \n             debug!(\"after subst: %?\",\n@@ -129,14 +130,14 @@ fn lookup_vtables(vcx: &VtableContext,\n }\n \n fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                id: ast::def_id, substs: ty::substs,\n+                id: ast::def_id, +substs: ty::substs,\n                 is_early: bool) -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n-          ty::ty_trait(_, ref substs_f, _) => (*substs_f),\n+          ty::ty_trait(_, ref substs_f, _) => (/*bad*/copy *substs_f),\n           _ => fail ~\"t_f should be a trait\"\n         }\n     }\n@@ -162,7 +163,8 @@ fn lookup_vtable(vcx: &VtableContext,\n \n     let tcx = vcx.tcx();\n     let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n-        ty::ty_trait(did, ref substs, vstore) => (did, (*substs), vstore),\n+        ty::ty_trait(did, ref substs, vstore) =>\n+            (did, (/*bad*/copy *substs), vstore),\n         _ => tcx.sess.impossible_case(location_info.span,\n                                       \"lookup_vtable: \\\n                                        don't know how to handle a non-trait\")\n@@ -221,7 +223,7 @@ fn lookup_vtable(vcx: &VtableContext,\n             relate_trait_tys(vcx, location_info, trait_ty, ty);\n             if !allow_unsafe && !is_early {\n                 for vec::each(*ty::trait_methods(tcx, did)) |m| {\n-                    if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n+                    if ty::type_has_self(ty::mk_fn(tcx, /*bad*/copy m.fty)) {\n                         tcx.sess.span_err(\n                             location_info.span,\n                             ~\"a boxed trait with self types may not be \\\n@@ -235,7 +237,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                     }\n                 }\n             }\n-            return Some(vtable_trait(did, (*substs).tps));\n+            return Some(vtable_trait(did, /*bad*/copy (*substs).tps));\n         }\n \n         _ => {\n@@ -349,7 +351,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                             // trait_substs. Now we extract out the\n                             // types themselves from trait_substs.\n \n-                            let trait_tps = trait_substs.tps;\n+                            let trait_tps = /*bad*/copy trait_substs.tps;\n \n                             debug!(\"Casting to a trait ty whose substs \\\n                                     (trait_tps) are %s\",\n@@ -368,7 +370,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                                                               trait_id,\n                                                               substs,\n                                                               is_early) {\n-                                Some(ref substs) => (*substs),\n+                                Some(ref substs) => (/*bad*/copy *substs),\n                                 None => {\n                                     assert is_early;\n                                     // Bail out with a bogus answer\n@@ -393,7 +395,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                                                              im.did).bounds;\n                             connect_trait_tps(vcx,\n                                               location_info,\n-                                              substs_f.tps,\n+                                              /*bad*/copy substs_f.tps,\n                                               trait_tps,\n                                               im.did,\n                                               trait_vstore);\n@@ -407,7 +409,8 @@ fn lookup_vtable(vcx: &VtableContext,\n                             // of type substitutions for the target\n                             // trait.\n                             found.push(\n-                                vtable_static(im.did, substs_f.tps,\n+                                vtable_static(im.did,\n+                                              /*bad*/copy substs_f.tps,\n                                               subres));\n                         }\n                     }\n@@ -416,14 +419,14 @@ fn lookup_vtable(vcx: &VtableContext,\n \n             match found.len() {\n                 0 => { /* fallthrough */ }\n-                1 => { return Some(found[0]); }\n+                1 => { return Some(/*bad*/copy found[0]); }\n                 _ => {\n                     if !is_early {\n                         vcx.tcx().sess.span_err(\n                             location_info.span,\n                             ~\"multiple applicable methods in scope\");\n                     }\n-                    return Some(found[0]);\n+                    return Some(/*bad*/copy found[0]);\n                 }\n             }\n         }\n@@ -518,7 +521,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n-            if has_trait_bounds(*item_ty.bounds) {\n+            if has_trait_bounds(/*bad*/copy *item_ty.bounds) {\n                 for item_ty.bounds.each |bounds| {\n                     debug!(\"early_resolve_expr: looking up vtables for bound \\\n                             %s\",\n@@ -545,7 +548,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       ast::expr_index(*) | ast::expr_method_call(*) => {\n         match ty::method_call_bounds(cx.tcx, cx.method_map, ex.id) {\n           Some(bounds) => {\n-            if has_trait_bounds(*bounds) {\n+            if has_trait_bounds(/*bad*/copy *bounds) {\n                 let callee_id = match ex.node {\n                   ast::expr_field(_, _, _) => ex.id,\n                   _ => ex.callee_id"}, {"sha": "623c280ac226ba12ccc3f7449663c65333e4c8d2", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -12,6 +12,7 @@\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n \n+\n use middle::pat_util;\n use middle::ty;\n use middle::typeck::check::{fn_ctxt, lookup_local};\n@@ -154,7 +155,7 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n-    match e.node {\n+    match /*bad*/copy e.node {\n       ast::expr_fn(_, decl, _, _) |\n       ast::expr_fn_block(decl, _, _) => {\n           for vec::each(decl.inputs) |input| {"}, {"sha": "0116214b5f9e6c0e80fe7c2c028d030e6da5bf39", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -14,6 +14,7 @@\n // has at most one implementation for each type. Then we build a mapping from\n // each trait in the system to its implementations.\n \n+\n use driver;\n use metadata::csearch::{ProvidedTraitMethodInfo, each_path, get_impl_traits};\n use metadata::csearch::{get_impls_for_mod};\n@@ -510,10 +511,13 @@ impl CoherenceChecker {\n             self_ty: None,\n             tps: type_parameters\n         };\n-\n         let monotype = subst(self.crate_context.tcx,\n                              &substitutions,\n                              polytype.ty);\n+\n+        // Get our type parameters back.\n+        let { self_r: _, self_ty: _, tps: type_parameters } = substitutions;\n+\n         UniversalQuantificationResult {\n             monotype: monotype,\n             type_variables: move type_parameters,\n@@ -583,7 +587,7 @@ impl CoherenceChecker {\n     fn check_privileged_scopes(crate: @crate) {\n         visit_crate(*crate, (), mk_vt(@{\n             visit_item: |item, _context, visitor| {\n-                match item.node {\n+                match /*bad*/copy item.node {\n                     item_mod(module_) => {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n@@ -717,7 +721,7 @@ impl CoherenceChecker {\n             }\n         }\n \n-        match item.node {\n+        match /*bad*/copy item.node {\n             item_impl(_, trait_refs, _, ast_methods) => {\n                 let mut methods = ~[];\n                 for ast_methods.each |ast_method| {"}, {"sha": "48c16a94212823fdcef7c989dba0f88f1287c9b1", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -62,7 +62,7 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n         if crate_item.ident\n             == ::syntax::parse::token::special_idents::intrinsic {\n \n-            match crate_item.node {\n+            match /*bad*/copy crate_item.node {\n               ast::item_mod(m) => {\n                 for m.items.each |intrinsic_item| {\n                     let def_id = { crate: ast::local_crate,\n@@ -150,7 +150,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n         // constructors get turned into functions.\n         let result_ty;\n         match variant.node.kind {\n-            ast::tuple_variant_kind(args) if args.len() > 0 => {\n+            ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(rp);\n                 let args = args.map(|va| {\n                     let arg_ty = ccx.to_ty(rs, va.ty);\n@@ -172,11 +172,18 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n             }\n             ast::struct_variant_kind(struct_def) => {\n                 // XXX: Merge with computation of the the same value below?\n-                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                           region_param: rp,\n-                           ty: enum_ty};\n+                let tpt = {\n+                    bounds: ty_param_bounds(ccx, /*bad*/copy ty_params),\n+                    region_param: rp,\n+                    ty: enum_ty\n+                };\n                 convert_struct(\n-                    ccx, rp, struct_def, ty_params, tpt, variant.node.id);\n+                    ccx,\n+                    rp,\n+                    struct_def,\n+                    /*bad*/copy ty_params,\n+                    tpt,\n+                    variant.node.id);\n                 // Compute the ctor arg types from the struct fields\n                 let struct_fields = do struct_def.fields.map |struct_field| {\n                     {mode: ast::expl(ast::by_val),\n@@ -195,8 +202,8 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n             ast::enum_variant_kind(ref enum_definition) => {\n                 get_enum_variant_types(ccx,\n                                        enum_ty,\n-                                       enum_definition.variants,\n-                                       ty_params,\n+                                       /*bad*/copy enum_definition.variants,\n+                                       /*bad*/copy ty_params,\n                                        rp);\n                 result_ty = None;\n             }\n@@ -205,9 +212,11 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n         match result_ty {\n             None => {}\n             Some(result_ty) => {\n-                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                           region_param: rp,\n-                           ty: result_ty};\n+                let tpt = {\n+                    bounds: ty_param_bounds(ccx, /*bad*/copy ty_params),\n+                    region_param: rp,\n+                    ty: result_ty\n+                };\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n                 write_ty_to_tcx(tcx, variant.node.id, result_ty);\n             }\n@@ -217,7 +226,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n \n fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n-                        stuff: ~[T], f: fn@(v: &T) -> ty::method) {\n+                        stuff: ~[T], f: &fn(v: &T) -> ty::method) {\n         ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n     }\n \n@@ -250,7 +259,9 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n \n         let substs = { self_r: None, self_ty: Some(self_param),\n                        tps: non_shifted_trait_tps + shifted_method_tps };\n-        let ty = ty::subst(ccx.tcx, &substs, ty::mk_fn(ccx.tcx, m.fty));\n+        let ty = ty::subst(ccx.tcx,\n+                           &substs,\n+                           ty::mk_fn(ccx.tcx, /*bad*/copy m.fty));\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n         ccx.tcx.tcache.insert(local_def(am.id),\n@@ -264,10 +275,10 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     let region_paramd = tcx.region_paramd_items.find(id);\n     match tcx.items.get(id) {\n       ast_map::node_item(@{\n-                node: ast::item_trait(params, _, ref ms),\n+                node: ast::item_trait(ref params, _, ref ms),\n                 _\n             }, _) => {\n-        store_methods::<ast::trait_method>(ccx, id, (*ms), |m| {\n+        store_methods::<ast::trait_method>(ccx, id, (/*bad*/copy *ms), |m| {\n             let def_id;\n             match *m {\n                 ast::required(ref ty_method) => {\n@@ -276,7 +287,7 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n                 ast::provided(method) => def_id = local_def(method.id)\n             }\n \n-            let trait_bounds = ty_param_bounds(ccx, params);\n+            let trait_bounds = ty_param_bounds(ccx, copy *params);\n             let ty_m = trait_method_to_ty_method(*m);\n             let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n             if ty_m.self_ty.node == ast::sty_static {\n@@ -430,7 +441,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        let impl_fty = ty::mk_fn(tcx, /*bad*/copy impl_m.fty);\n         debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n@@ -448,7 +459,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        let trait_fty = ty::mk_fn(tcx, trait_m.fty);\n+        let trait_fty = ty::mk_fn(tcx, /*bad*/copy trait_m.fty);\n         debug!(\"trait_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, trait_fty));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n@@ -554,15 +565,15 @@ fn convert_methods(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n-        let bounds = ty_param_bounds(ccx, m.tps);\n+        let bounds = ty_param_bounds(ccx, /*bad*/copy m.tps);\n         let mty = ty_of_method(ccx, *m, rp);\n-        let fty = ty::mk_fn(tcx, mty.fty);\n+        let fty = ty::mk_fn(tcx, /*bad*/copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n \n             // n.b.: the type of a method is parameterized by both\n             // the tps on the receiver and those on the method itself\n-            {bounds: @(vec::append(*rcvr_bounds, *bounds)),\n+            {bounds: @(vec::append(/*bad*/copy *rcvr_bounds, *bounds)),\n              region_param: rp,\n              ty: fty});\n         write_ty_to_tcx(tcx, m.id, fty);\n@@ -576,39 +587,44 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let rp = tcx.region_paramd_items.find(it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n-    match it.node {\n+    match /*bad*/copy it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-      ast::item_enum(ref enum_definition, ty_params) => {\n+      ast::item_enum(ref enum_definition, ref ty_params) => {\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx, tpt.ty, (*enum_definition).variants,\n-                               ty_params, rp);\n+        get_enum_variant_types(ccx,\n+                               tpt.ty,\n+                               /*bad*/copy (*enum_definition).variants,\n+                               /*bad*/copy *ty_params, rp);\n       }\n-      ast::item_impl(tps, trait_ref, selfty, ms) => {\n-        let i_bounds = ty_param_bounds(ccx, tps);\n+      ast::item_impl(ref tps, trait_ref, selfty, ref ms) => {\n+        let i_bounds = ty_param_bounds(ccx, /*bad*/copy *tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           {bounds: i_bounds,\n                            region_param: rp,\n                            ty: selfty});\n \n-        let cms = convert_methods(ccx, ms, rp, i_bounds);\n+        // XXX: Bad copy of `ms` below.\n+        let cms = convert_methods(ccx, /*bad*/copy *ms, rp, i_bounds);\n         for trait_ref.each |t| {\n-            check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n+            check_methods_against_trait(ccx, /*bad*/copy *tps, rp, selfty,\n+                                        *t, /*bad*/copy cms);\n         }\n       }\n-      ast::item_trait(tps, supertraits, ref trait_methods) => {\n+      ast::item_trait(ref tps, ref supertraits, ref trait_methods) => {\n         let tpt = ty_of_item(ccx, it);\n         debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n                it.id, ppaux::ty_to_str(tcx, tpt.ty));\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id, tpt.ty);\n-        ensure_supertraits(ccx, it.id, it.span, rp, supertraits);\n+        ensure_supertraits(ccx, it.id, it.span, rp, *supertraits);\n \n-        let (_, provided_methods) = split_trait_methods((*trait_methods));\n-        let {bounds, _} = mk_substs(ccx, tps, rp);\n+        let (_, provided_methods) =\n+            split_trait_methods(/*bad*/copy *trait_methods);\n+        let {bounds, _} = mk_substs(ccx, /*bad*/copy *tps, rp);\n         let _cms = convert_methods(ccx, provided_methods, rp, bounds);\n         // FIXME (#2616): something like this, when we start having\n         // trait inheritance?\n@@ -637,7 +653,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n fn convert_struct(ccx: @crate_ctxt,\n                   rp: Option<ty::region_variance>,\n                   struct_def: @ast::struct_def,\n-                  tps: ~[ast::ty_param],\n+                  +tps: ~[ast::ty_param],\n                   tpt: ty::ty_param_bounds_and_ty,\n                   id: ast::node_id) {\n     let tcx = ccx.tcx;\n@@ -720,7 +736,7 @@ fn ty_of_method(ccx: @crate_ctxt,\n                 m: @ast::method,\n                 rp: Option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n-     tps: ty_param_bounds(ccx, m.tps),\n+     tps: ty_param_bounds(ccx, /*bad*/copy m.tps),\n      fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::ProtoBare,\n                         m.purity, ast::Many,\n                         /*bounds:*/ @~[], /*opt_region:*/ None,\n@@ -735,7 +751,7 @@ fn ty_of_ty_method(self: @crate_ctxt,\n                    rp: Option<ty::region_variance>,\n                    id: ast::def_id) -> ty::method {\n     {ident: m.ident,\n-     tps: ty_param_bounds(self, m.tps),\n+     tps: ty_param_bounds(self, /*bad*/copy m.tps),\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::ProtoBare,\n                         m.purity, ast::Many,\n                         /*bounds:*/ @~[], /*opt_region:*/ None,\n@@ -785,7 +801,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       _ => {}\n     }\n     let rp = tcx.region_paramd_items.find(it.id);\n-    match it.node {\n+    match /*bad*/copy it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(empty_rscope, t);\n         let tpt = no_params(typ);\n@@ -870,7 +886,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n \n fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n-    match it.node {\n+    match /*bad*/copy it.node {\n       ast::foreign_item_fn(fn_decl, purity, params) => {\n         return ty_of_foreign_fn_decl(ccx, fn_decl, purity, params,\n                                      local_def(it.id));\n@@ -939,9 +955,8 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n                          decl: ast::fn_decl,\n                          purity: ast::purity,\n-                         ty_params: ~[ast::ty_param],\n+                         +ty_params: ~[ast::ty_param],\n                          def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-\n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n@@ -966,7 +981,8 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n     -> {bounds: @~[ty::param_bounds], params: ~[ty::t]} {\n \n     let mut i = 0u;\n-    let bounds = ty_param_bounds(ccx, atps);\n+    // XXX: Bad copy.\n+    let bounds = ty_param_bounds(ccx, copy atps);\n     {bounds: bounds,\n      params: vec::map(atps, |atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n@@ -975,10 +991,10 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n      })}\n }\n \n-fn mk_substs(ccx: @crate_ctxt, atps: ~[ast::ty_param],\n+fn mk_substs(ccx: @crate_ctxt,\n+             +atps: ~[ast::ty_param],\n              rp: Option<ty::region_variance>)\n-    -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n-\n+          -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n     let {bounds, params} = mk_ty_params(ccx, atps);\n     let self_r = rscope::bound_self_region(rp);\n     {bounds: bounds, substs: {self_r: self_r, self_ty: None, tps: params}}"}, {"sha": "9de71d22a3108770946df92135e694f6617f511b", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -58,6 +58,7 @@\n // A.  But this upper-bound might be stricter than what is truly\n // needed.\n \n+\n use middle::ty;\n use middle::typeck::infer::combine::combine_fields;\n use middle::typeck::infer::to_str::ToStr;\n@@ -84,7 +85,13 @@ impl Assign {\n                b.to_str(self.infcx));\n         let _r = indenter();\n \n-        match (ty::get(a).sty, ty::get(b).sty) {\n+        debug!(\"Assign.tys: copying first type\");\n+        let copy_a = copy ty::get(a).sty;\n+        debug!(\"Assign.tys: copying second type\");\n+        let copy_b = copy ty::get(b).sty;\n+        debug!(\"Assign.tys: performing match\");\n+\n+        let r = match (copy_a, copy_b) {\n             (ty::ty_bot, _) => {\n                 Ok(None)\n             }\n@@ -119,7 +126,11 @@ impl Assign {\n             (_, _) => {\n                 self.assign_tys_or_sub(a, b, Some(a), Some(b))\n             }\n-        }\n+        };\n+\n+        debug!(\"Assign.tys end\");\n+\n+        move r\n     }\n }\n \n@@ -150,7 +161,8 @@ priv impl Assign {\n \n         match (a_bnd, b_bnd) {\n             (Some(a_bnd), Some(b_bnd)) => {\n-                match (ty::get(a_bnd).sty, ty::get(b_bnd).sty) {\n+                match (/*bad*/copy ty::get(a_bnd).sty,\n+                       /*bad*/copy ty::get(b_bnd).sty) {\n                     // check for a case where a non-region pointer (@, ~) is\n                     // being assigned to a region pointer:\n                     (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n@@ -192,7 +204,7 @@ priv impl Assign {\n                         let nr_b = ty::mk_fn(self.infcx.tcx, ty::FnTyBase {\n                             meta: ty::FnMeta {proto: a_f.meta.proto,\n                                               ..b_f.meta},\n-                            sig: b_f.sig\n+                            sig: /*bad*/copy b_f.sig\n                         });\n                         self.try_assign(0, ty::AutoBorrowFn,\n                                         a, nr_b, m_imm, b_f.meta.region)"}, {"sha": "e612a76b92d8d739b5ffa80dba81a856d2995711", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -54,8 +54,6 @@\n // terms of error reporting, although we do not do that properly right\n // now.\n \n-#[warn(vecs_implicitly_copyable)];\n-\n use middle::ty;\n use middle::ty::{FnTyBase, FnMeta, FnSig};\n use middle::typeck::infer::sub::Sub;\n@@ -226,7 +224,7 @@ fn super_substs<C:combine>(\n             do relate_region_param(self, did,\n                                    a.self_r, b.self_r).chain |self_r|\n             {\n-                Ok({self_r: self_r, self_ty: self_ty, tps: tps})\n+                Ok({self_r: self_r, self_ty: self_ty, tps: /*bad*/copy tps})\n             }\n         }\n     }\n@@ -345,10 +343,10 @@ fn super_fn_metas<C:combine>(\n }\n \n fn super_fn_sigs<C:combine>(\n-    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n-{\n-    fn argvecs<C:combine>(self: &C, a_args: ~[ty::arg],\n-                          b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n+    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn argvecs<C:combine>(self: &C,\n+                          +a_args: ~[ty::arg],\n+                          +b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n \n         if vec::same_length(a_args, b_args) {\n             map_vec2(a_args, b_args, |a, b| self.args(*a, *b))\n@@ -357,9 +355,10 @@ fn super_fn_sigs<C:combine>(\n         }\n     }\n \n-    do argvecs(self, a_f.inputs, b_f.inputs).chain |inputs| {\n+    do argvecs(self, /*bad*/copy a_f.inputs, /*bad*/copy b_f.inputs)\n+            .chain |inputs| {\n         do self.tys(a_f.output, b_f.output).chain |output| {\n-            Ok(FnSig {inputs: inputs, output: output})\n+            Ok(FnSig {inputs: /*bad*/copy inputs, output: output})\n         }\n     }\n }\n@@ -378,7 +377,7 @@ fn super_tys<C:combine>(\n     self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = self.infcx().tcx;\n-    match (ty::get(a).sty, ty::get(b).sty) {\n+    match (/*bad*/copy ty::get(a).sty, /*bad*/copy ty::get(b).sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (ty::ty_bot, _) |\n       (_, ty::ty_bot) |\n@@ -418,8 +417,8 @@ fn super_tys<C:combine>(\n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n       (ty::ty_float(_), _) => {\n-        let as_ = ty::get(a).sty;\n-        let bs = ty::get(b).sty;\n+        let as_ = /*bad*/copy ty::get(a).sty;\n+        let bs = /*bad*/copy ty::get(b).sty;\n         if as_ == bs {\n             Ok(a)\n         } else {\n@@ -454,7 +453,7 @@ fn super_tys<C:combine>(\n       if a_id == b_id => {\n         do self.substs(a_id, a_substs, b_substs).chain |substs| {\n             do self.vstores(ty::terr_trait, a_vstore, b_vstore).chain |vs| {\n-                Ok(ty::mk_trait(tcx, a_id, substs, vs))\n+                Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, vs))\n             }\n         }\n       }"}, {"sha": "85a11a598e9081ea3e1d20f7ca2570b7ecaec6f3", "filename": "src/librustc/middle/typeck/infer/floating.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -14,6 +14,7 @@ Code related to floating-point type inference.\n \n */\n \n+\n use middle::ty;\n use middle::ty::ty_float;\n use middle::typeck::infer::to_str::ToStr;"}, {"sha": "f4139c4cf4974655ecbc9cc7452f7c99551b1417", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;"}, {"sha": "fae5feb369ef1fb66452cf0721bab287cbeccffd", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::unify::*;"}, {"sha": "53c9b2630341808f0586a0d7abad785edeba15a1", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;"}, {"sha": "8cccf75d6dc4ef092284b6e1d11839deca676f98", "filename": "src/librustc/middle/typeck/infer/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -19,4 +19,4 @@ macro_rules! if_ok(\n     )\n );\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "da4c02b9e35074a385359c9b85a1f5bf0bb6e6b5", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -46,6 +46,7 @@\n // future).  If you want to resolve everything but one type, you are\n // probably better off writing `resolve_all - resolve_ivar`.\n \n+\n use middle::ty;\n use middle::typeck::infer::floating::*;\n use middle::typeck::infer::floating;\n@@ -110,7 +111,8 @@ impl resolve_state {\n         assert vec::is_empty(self.v_seen);\n         match self.err {\n           None => {\n-            debug!(\"Resolved to %s (modes=%x)\",\n+            debug!(\"Resolved to %s + %s (modes=%x)\",\n+                   ty_to_str(self.infcx.tcx, rty),\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.modes);\n             return Ok(rty);\n@@ -133,7 +135,7 @@ impl resolve_state {\n         indent(fn&() -> ty::t {\n             if !ty::type_needs_infer(typ) { return typ; }\n \n-            match ty::get(typ).sty {\n+            match copy ty::get(typ).sty {\n               ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n               }"}, {"sha": "cc7733231ed6ee1cee79617ea01acbb5d7701cd9", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::to_str::ToStr;"}, {"sha": "c3d2c8e99f7a2e0fa1edec720b56aa3fdecd9334", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -16,6 +16,7 @@ Note: This module is only compiled when doing unit testing.\n \n */\n \n+\n use std::getopts;\n use std::map::HashMap;\n use std::getopts;"}, {"sha": "73352b802d64e9470b1b709d9136c4fb3656421e", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::infer::integral::int_ty_set;\n use middle::typeck::infer::floating::float_ty_set;"}, {"sha": "8056c2c6bb31ee426bb48d5f8197f82b4dfaad41", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::typeck::infer::combine::combine;\n use middle::typeck::infer::floating::*;"}, {"sha": "adb6fc8baf79a7528e0357528dda37d65f1d378a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -347,7 +347,8 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n             match tcx.items.find(main_id) {\n                 Some(ast_map::node_item(it,_)) => {\n                     match it.node {\n-                        ast::item_fn(_,_,ps,_) if vec::is_not_empty(ps) => {\n+                        ast::item_fn(_, _, ref ps, _)\n+                        if vec::is_not_empty(*ps) => {\n                             tcx.sess.span_err(\n                                 main_span,\n                                 ~\"main function is not allowed \\"}, {"sha": "ecd73b4783a2a34015375dc2315ef1c823057ecb", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n \n use core::result::Result;"}, {"sha": "271d43087f38edae454f815c32cca6797a6c4078", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -22,7 +22,7 @@\n #[legacy_modes];\n #[legacy_exports];\n \n-#[allow(vecs_implicitly_copyable)];\n+#[allow(non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n #[warn(deprecated_pattern)];\n@@ -262,7 +262,7 @@ Available lint options:\n fn describe_debug_flags() {\n     io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n     for session::debugging_opts_map().each |pair| {\n-        let (name, desc, _) = *pair;\n+        let (name, desc, _) = /*bad*/copy *pair;\n         io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n     }\n }\n@@ -271,7 +271,7 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n-    let mut args = *args;\n+    let mut args = /*bad*/copy *args;\n     let binary = args.shift();\n \n     if args.is_empty() { usage(binary); return; }\n@@ -308,7 +308,7 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     let input = match vec::len(matches.free) {\n       0u => early_error(demitter, ~\"no input filename given\"),\n       1u => {\n-        let ifile = matches.free[0];\n+        let ifile = /*bad*/copy matches.free[0];\n         if ifile == ~\"-\" {\n             let src = str::from_bytes(io::stdin().read_whole_stream());\n             str_input(src)\n@@ -319,7 +319,8 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n       _ => early_error(demitter, ~\"multiple input filenames provided\")\n     };\n \n-    let sopts = build_session_options(binary, matches, demitter);\n+    // XXX: Bad copy.\n+    let sopts = build_session_options(copy binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n     let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n     let odir = odir.map(|o| Path(*o));"}, {"sha": "cd71bb099fe655698ef3026b059fd2b7faaeefb1", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use syntax::ast;\n use syntax::codemap::{span};\n use syntax::visit;\n@@ -101,7 +102,7 @@ fn is_main_name(path: syntax::ast_map::path) -> bool {\n     )\n }\n \n-fn pluralize(n: uint, s: ~str) -> ~str {\n+fn pluralize(n: uint, +s: ~str) -> ~str {\n     if n == 1 { s }\n     else { str::concat([s, ~\"s\"]) }\n }"}, {"sha": "b5609f7252352a4164c9b262487acf6d3dfa97e1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f41f07ce2811a975ea6362d6a07b070d4bdf77/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=53f41f07ce2811a975ea6362d6a07b070d4bdf77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n use middle::ty;\n use middle::ty::{arg, canon_mode};\n use middle::ty::{bound_copy, bound_const, bound_durable, bound_owned,\n@@ -354,14 +355,14 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    for ty::type_def_id(typ).each |def_id| {\n+    /*for ty::type_def_id(typ).each |def_id| {\n         // note that this typedef cannot have type parameters\n         return ast_map::path_to_str(ty::item_path(cx, *def_id),\n                                     cx.sess.intr());\n-    }\n+    }*/\n \n     // pretty print the structural type representation:\n-    return match ty::get(typ).sty {\n+    return match /*bad*/copy ty::get(typ).sty {\n       ty_nil => ~\"()\",\n       ty_bot => ~\"_|_\",\n       ty_bool => ~\"bool\",\n@@ -395,7 +396,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                   f.meta.purity,\n                   f.meta.onceness,\n                   None,\n-                  f.sig.inputs,\n+                  /*bad*/copy f.sig.inputs,\n                   f.sig.output,\n                   f.meta.ret_style)\n       }\n@@ -408,12 +409,15 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n-        parameterized(cx, base, (*substs).self_r, (*substs).tps)\n+        parameterized(cx, base, (*substs).self_r, /*bad*/copy (*substs).tps)\n       }\n       ty_trait(did, ref substs, vs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n-        let result = parameterized(cx, base, (*substs).self_r, (*substs).tps);\n+        let result = parameterized(cx,\n+                                   base,\n+                                   substs.self_r,\n+                                   /*bad*/copy substs.tps);\n         vstore_ty_to_str(cx, result, vs)\n       }\n       ty_evec(mt, vs) => {"}]}