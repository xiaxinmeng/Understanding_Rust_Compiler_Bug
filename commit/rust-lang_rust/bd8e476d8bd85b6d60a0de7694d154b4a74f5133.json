{"sha": "bd8e476d8bd85b6d60a0de7694d154b4a74f5133", "node_id": "C_kwDOAAsO6NoAKGJkOGU0NzZkOGJkODViNmQ2MGEwZGU3Njk0ZDE1NGI0YTc0ZjUxMzM", "commit": {"author": {"name": "Alex Gaynor", "email": "alex.gaynor@gmail.com", "date": "2022-12-03T18:46:14Z"}, "committer": {"name": "Alex Gaynor", "email": "alex.gaynor@gmail.com", "date": "2022-12-03T19:02:35Z"}, "message": "Avoid a temporary file when processing macOS fat archives", "tree": {"sha": "d46db7dce2ad077c3e794d35f1a9ea90e1427ff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d46db7dce2ad077c3e794d35f1a9ea90e1427ff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd8e476d8bd85b6d60a0de7694d154b4a74f5133", "comment_count": 0, "verification": {"verified": false, "reason": "bad_cert", "signature": "-----BEGIN SIGNED MESSAGE-----\nMIIEBgYJKoZIhvcNAQcCoIID9zCCA/MCAQExDTALBglghkgBZQMEAgEwCwYJKoZI\nhvcNAQcBoIICpzCCAqMwggIqoAMCAQICFACFy2dNT1IpVZ5UpcAHAgMMCezSMAoG\nCCqGSM49BAMDMDcxFTATBgNVBAoTDHNpZ3N0b3JlLmRldjEeMBwGA1UEAxMVc2ln\nc3RvcmUtaW50ZXJtZWRpYXRlMB4XDTIyMTIwMzE5MDIzOVoXDTIyMTIwMzE5MTIz\nOVowADBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEM+YMiKHt9R5ApqM4HQJKHy\nHQ5m0p5UBhvL6IuRzhoxbHtpcS2L1Mka3pmU51FOrxgIWAJ8Q0onO4HPR70c0Byj\nggFJMIIBRTAOBgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYBBQUHAwMwHQYD\nVR0OBBYEFIwHtAesrCzZnRPQ9t6agKee8J64MB8GA1UdIwQYMBaAFN/T6c9WJBGW\n+ajY6ShVosYuGGQ/MCMGA1UdEQEB/wQZMBeBFWFsZXguZ2F5bm9yQGdtYWlsLmNv\nbTAsBgorBgEEAYO/MAEBBB5odHRwczovL2dpdGh1Yi5jb20vbG9naW4vb2F1dGgw\ngYoGCisGAQQB1nkCBAIEfAR6AHgAdgDdPTBqxscRMmMZHhyZZzcCokpeuN48rf+H\ninKALynujgAAAYTZXn95AAAEAwBHMEUCIQD+d8SPmAcIwOTPF+igqzIWBQF70nUo\n643xSBfKumI5DgIgC5ZQxFjQWJm123AyIGNg1KMDyYmxxALDvF2nYZS9J2AwCgYI\nKoZIzj0EAwMDZwAwZAIwUTMbEELKbdf9a7v8e1amHuJzI5Wm3Z1eOP4r2NTs+aj/\nraPkJsqA8hEq/1YCDGrCAjB50G1zTBEUP4bwfn6r462MH9WizeZPeL3DguU36yFf\nZUmur49MIIBEFuppoTD2zKAxggElMIIBIQIBATBPMDcxFTATBgNVBAoTDHNpZ3N0\nb3JlLmRldjEeMBwGA1UEAxMVc2lnc3RvcmUtaW50ZXJtZWRpYXRlAhQAhctnTU9S\nKVWeVKXABwIDDAns0jALBglghkgBZQMEAgGgaTAYBgkqhkiG9w0BCQMxCwYJKoZI\nhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0yMjEyMDMxOTAyMzlaMC8GCSqGSIb3DQEJ\nBDEiBCBru4NhtIUXYOgWeXHxxxrsVddqPCzAXo/QMILSj9kRITAKBggqhkjOPQQD\nAgRHMEUCIFfGtLeHKnyT2o0Q5IV6Af3Yf87dbupxFrnBqUPx1cvIAiEAy+de7Fl9\nuXmEcccC02Vxw3AVvztbYgr61roVrwpsw2c=\n-----END SIGNED MESSAGE-----", "payload": "tree d46db7dce2ad077c3e794d35f1a9ea90e1427ff0\nparent 047c7cc60c05e2cf182c6f578581cf2a67b1d0ff\nauthor Alex Gaynor <alex.gaynor@gmail.com> 1670093174 -0500\ncommitter Alex Gaynor <alex.gaynor@gmail.com> 1670094155 -0500\n\nAvoid a temporary file when processing macOS fat archives\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8e476d8bd85b6d60a0de7694d154b4a74f5133", "html_url": "https://github.com/rust-lang/rust/commit/bd8e476d8bd85b6d60a0de7694d154b4a74f5133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd8e476d8bd85b6d60a0de7694d154b4a74f5133/comments", "author": {"login": "alex", "id": 772, "node_id": "MDQ6VXNlcjc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alex", "html_url": "https://github.com/alex", "followers_url": "https://api.github.com/users/alex/followers", "following_url": "https://api.github.com/users/alex/following{/other_user}", "gists_url": "https://api.github.com/users/alex/gists{/gist_id}", "starred_url": "https://api.github.com/users/alex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alex/subscriptions", "organizations_url": "https://api.github.com/users/alex/orgs", "repos_url": "https://api.github.com/users/alex/repos", "events_url": "https://api.github.com/users/alex/events{/privacy}", "received_events_url": "https://api.github.com/users/alex/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alex", "id": 772, "node_id": "MDQ6VXNlcjc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alex", "html_url": "https://github.com/alex", "followers_url": "https://api.github.com/users/alex/followers", "following_url": "https://api.github.com/users/alex/following{/other_user}", "gists_url": "https://api.github.com/users/alex/gists{/gist_id}", "starred_url": "https://api.github.com/users/alex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alex/subscriptions", "organizations_url": "https://api.github.com/users/alex/orgs", "repos_url": "https://api.github.com/users/alex/repos", "events_url": "https://api.github.com/users/alex/events{/privacy}", "received_events_url": "https://api.github.com/users/alex/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "047c7cc60c05e2cf182c6f578581cf2a67b1d0ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/047c7cc60c05e2cf182c6f578581cf2a67b1d0ff", "html_url": "https://github.com/rust-lang/rust/commit/047c7cc60c05e2cf182c6f578581cf2a67b1d0ff"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "5266d8858d47d35dcc9c12e0e935bb9327b1d4f0", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bd8e476d8bd85b6d60a0de7694d154b4a74f5133/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8e476d8bd85b6d60a0de7694d154b4a74f5133/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=bd8e476d8bd85b6d60a0de7694d154b4a74f5133", "patch": "@@ -14,7 +14,7 @@ use tempfile::Builder as TempFileBuilder;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io::{self, Write};\n+use std::io;\n use std::path::{Path, PathBuf};\n \n // Re-exporting for rustc_codegen_llvm::back::archive\n@@ -116,51 +116,42 @@ impl<'a> ArArchiveBuilder<'a> {\n     }\n }\n \n-fn try_filter_fat_archs(\n+fn try_filter_fat_archs<'a>(\n     archs: object::read::Result<&[impl FatArch]>,\n     target_arch: object::Architecture,\n-    archive_path: &Path,\n-    archive_map_data: &[u8],\n-) -> io::Result<Option<PathBuf>> {\n+    archive_map_data: &'a [u8],\n+) -> io::Result<Option<(&'a [u8], u64)>> {\n     let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n \n     let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n         Some(a) => a,\n         None => return Ok(None),\n     };\n \n-    let (mut new_f, extracted_path) = tempfile::Builder::new()\n-        .suffix(archive_path.file_name().unwrap())\n-        .tempfile()?\n-        .keep()\n-        .unwrap();\n-\n-    new_f.write_all(\n+    Ok(Some((\n         desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-    )?;\n-\n-    Ok(Some(extracted_path))\n+        desired.offset().into(),\n+    )))\n }\n \n-pub fn try_extract_macho_fat_archive(\n+pub fn try_extract_macho_fat_archive<'a>(\n     sess: &Session,\n-    archive_path: &Path,\n-) -> io::Result<Option<PathBuf>> {\n-    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+    archive_bytes: &'a [u8],\n+) -> io::Result<Option<(&'a [u8], u64)>> {\n     let target_arch = match sess.target.arch.as_ref() {\n         \"aarch64\" => object::Architecture::Aarch64,\n         \"x86_64\" => object::Architecture::X86_64,\n         _ => return Ok(None),\n     };\n \n-    match object::macho::FatHeader::parse(&*archive_map) {\n+    match object::macho::FatHeader::parse(archive_bytes) {\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+            let archs = object::macho::FatHeader::parse_arch32(archive_bytes);\n+            try_filter_fat_archs(archs, target_arch, archive_bytes)\n         }\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+            let archs = object::macho::FatHeader::parse_arch64(archive_bytes);\n+            try_filter_fat_archs(archs, target_arch, archive_bytes)\n         }\n         // Not a FatHeader at all, just return None.\n         _ => Ok(None),\n@@ -173,21 +164,24 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         archive_path: &Path,\n         mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let mut archive_path = archive_path.to_path_buf();\n-        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n-            if let Some(new_archive_path) =\n-                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n-            {\n-                archive_path = new_archive_path\n-            }\n-        }\n-\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n         if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n             return Ok(());\n         }\n \n-        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n-        let archive = ArchiveFile::parse(&*archive_map)\n+        let (archive_bytes, offset) = if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some((sub_archive, archive_offset)) =\n+                try_extract_macho_fat_archive(&self.sess, &*archive_map)?\n+            {\n+                (sub_archive, Some(archive_offset))\n+            } else {\n+                (&*archive_map, None)\n+            }\n+        } else {\n+            (&*archive_map, None)\n+        };\n+\n+        let archive = ArchiveFile::parse(&*archive_bytes)\n             .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n         let archive_index = self.src_archives.len();\n \n@@ -196,9 +190,13 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.name().to_vec())\n                 .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n+                let mut range = entry.file_range();\n+                if let Some(offset) = offset {\n+                    range.0 += offset;\n+                }\n                 self.entries.push((\n                     file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n+                    ArchiveEntry::FromArchive { archive_index, file_range: range },\n                 ));\n             }\n         }"}]}