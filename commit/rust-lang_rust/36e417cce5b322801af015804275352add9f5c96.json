{"sha": "36e417cce5b322801af015804275352add9f5c96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZTQxN2NjZTViMzIyODAxYWYwMTU4MDQyNzUzNTJhZGQ5ZjVjOTY=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-24T07:09:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-24T07:09:56Z"}, "message": "Merge pull request #1982 from rust-lang-nursery/bytecount\n\nnew lint: naive_bytecount", "tree": {"sha": "d65ee38318baa1e5de02438df4d5ae32aa60f8e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d65ee38318baa1e5de02438df4d5ae32aa60f8e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36e417cce5b322801af015804275352add9f5c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36e417cce5b322801af015804275352add9f5c96", "html_url": "https://github.com/rust-lang/rust/commit/36e417cce5b322801af015804275352add9f5c96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36e417cce5b322801af015804275352add9f5c96/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7715f00592738b0e4d16ff2e191a632ef03e8962", "url": "https://api.github.com/repos/rust-lang/rust/commits/7715f00592738b0e4d16ff2e191a632ef03e8962", "html_url": "https://github.com/rust-lang/rust/commit/7715f00592738b0e4d16ff2e191a632ef03e8962"}, {"sha": "6d989c729d03f5f9900d153417488b5eaf1e2f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d989c729d03f5f9900d153417488b5eaf1e2f2f", "html_url": "https://github.com/rust-lang/rust/commit/6d989c729d03f5f9900d153417488b5eaf1e2f2f"}], "stats": {"total": 236, "additions": 208, "deletions": 28}, "files": [{"sha": "7b72a6c1be7abed891e325c28dd83a22cc068241", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -1,6 +1,8 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+* New lint: [`naive_bytecount`]\n+\n ## 0.0.154\n * Fix [`use_self`] triggering inside derives\n * Add support for linting an entire workspace with `cargo clippy --all`\n@@ -516,6 +518,7 @@ All notable changes to this project will be documented in this file.\n [`mut_mut`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#mut_mut\n [`mutex_atomic`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#mutex_atomic\n [`mutex_integer`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#mutex_integer\n+[`naive_bytecount`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#naive_bytecount\n [`needless_bool`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#needless_bool\n [`needless_borrow`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#needless_borrow\n [`needless_borrowed_reference`]: https://github.com/rust-lang-nursery/rust-clippy/wiki#needless_borrowed_reference"}, {"sha": "bc043ec62d3b13b2726887417b96eb1b69904e2d", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -180,7 +180,7 @@ transparently:\n \n ## Lints\n \n-There are 205 lints included in this crate:\n+There are 206 lints included in this crate:\n \n name                                                                                                                         | default | triggers on\n -----------------------------------------------------------------------------------------------------------------------------|---------|----------------------------------------------------------------------------------------------------------------------------------\n@@ -290,6 +290,7 @@ name\n [mut_mut](https://github.com/rust-lang-nursery/rust-clippy/wiki#mut_mut)                                                     | allow   | usage of double-mut refs, e.g. `&mut &mut ...`\n [mutex_atomic](https://github.com/rust-lang-nursery/rust-clippy/wiki#mutex_atomic)                                           | warn    | using a mutex where an atomic value could be used instead\n [mutex_integer](https://github.com/rust-lang-nursery/rust-clippy/wiki#mutex_integer)                                         | allow   | using a mutex for an integer type\n+[naive_bytecount](https://github.com/rust-lang-nursery/rust-clippy/wiki#naive_bytecount)                                     | warn    | use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\n [needless_bool](https://github.com/rust-lang-nursery/rust-clippy/wiki#needless_bool)                                         | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n [needless_borrow](https://github.com/rust-lang-nursery/rust-clippy/wiki#needless_borrow)                                     | warn    | taking a reference that is going to be automatically dereferenced\n [needless_borrowed_reference](https://github.com/rust-lang-nursery/rust-clippy/wiki#needless_borrowed_reference)             | warn    | taking a needless borrowed reference"}, {"sha": "cbd0c6d20d50ad880c149f3f05ae12181333a273", "filename": "clippy_lints/src/bytecount.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -0,0 +1,115 @@\n+use rustc::hir::*;\n+use rustc::lint::*;\n+use rustc::ty;\n+use syntax::ast::{Name, UintTy};\n+use utils::{contains_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+\n+/// **What it does:** Checks for naive byte counts\n+///\n+/// **Why is this bad?** The [`bytecount`](https://crates.io/crates/bytecount)\n+/// crate has methods to count your bytes faster, especially for large slices.\n+///\n+/// **Known problems:** If you have predominantly small slices, the\n+/// `bytecount::count(..)` method may actually be slower. However, if you can\n+/// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+/// faster in those cases.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// &my_data.filter(|&x| x == 0u8).count() // use bytecount::count instead\n+/// ```\n+declare_lint! {\n+    pub NAIVE_BYTECOUNT,\n+    Warn,\n+    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct ByteCount;\n+\n+impl LintPass for ByteCount {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NAIVE_BYTECOUNT)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if_let_chain!([\n+            let ExprMethodCall(ref count, _, ref count_args) = expr.node,\n+            count.name == \"count\",\n+            count_args.len() == 1,\n+            let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node,\n+            filter.name == \"filter\",\n+            filter_args.len() == 2,\n+            let ExprClosure(_, _, body_id, _) = filter_args[1].node,\n+        ], {\n+            let body = cx.tcx.hir.body(body_id);\n+            if_let_chain!([\n+                body.arguments.len() == 1,\n+                let Some(argname) = get_pat_name(&body.arguments[0].pat),\n+                let ExprBinary(ref op, ref l, ref r) = body.value.node,\n+                op.node == BiEq,\n+                match_type(cx,\n+                           walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n+                           &paths::SLICE_ITER),\n+            ], {\n+                let needle = match get_path_name(l) {\n+                    Some(name) if check_arg(name, argname, r) => r,\n+                    _ => match get_path_name(r) {\n+                        Some(name) if check_arg(name, argname, l) => l,\n+                        _ => { return; }\n+                    }\n+                };\n+                if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n+                    return;\n+                }\n+                let haystack = if let ExprMethodCall(ref path, _, ref args) =\n+                        filter_args[0].node {\n+                    let p = path.name;\n+                    if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n+                        &args[0]\n+                    } else {\n+                        &filter_args[0]\n+                    }\n+                } else {\n+                    &filter_args[0]\n+                };\n+                span_lint_and_sugg(cx,\n+                                   NAIVE_BYTECOUNT,\n+                                   expr.span,\n+                                   \"You appear to be counting bytes the naive way\",\n+                                   \"Consider using the bytecount crate\",\n+                                   format!(\"bytecount::count({}, {})\",\n+                                            snippet(cx, haystack.span, \"..\"),\n+                                            snippet(cx, needle.span, \"..\")));\n+            });\n+        });\n+    }\n+}\n+\n+fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n+    name == arg && !contains_name(name, needle)\n+}\n+\n+fn get_pat_name(pat: &Pat) -> Option<Name> {\n+    match pat.node {\n+        PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n+        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        _ => None\n+    }\n+}\n+\n+fn get_path_name(expr: &Expr) -> Option<Name> {\n+    match expr.node {\n+        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprBlock(ref b) => if b.stmts.is_empty() {\n+            b.expr.as_ref().and_then(|p| get_path_name(p))\n+        } else { None },\n+        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        _ => None\n+    }\n+}\n+"}, {"sha": "c4c949c792e55c6c53c5a092f8c6af2a74ff303e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -74,6 +74,7 @@ pub mod bit_mask;\n pub mod blacklisted_name;\n pub mod block_in_if_condition;\n pub mod booleans;\n+pub mod bytecount;\n pub mod collapsible_if;\n pub mod copies;\n pub mod cyclomatic_complexity;\n@@ -321,6 +322,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box needless_pass_by_value::NeedlessPassByValue);\n     reg.register_early_lint_pass(box literal_digit_grouping::LiteralDigitGrouping);\n     reg.register_late_lint_pass(box use_self::UseSelf);\n+    reg.register_late_lint_pass(box bytecount::ByteCount);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -388,6 +390,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         booleans::LOGIC_BUG,\n+        bytecount::NAIVE_BYTECOUNT,\n         collapsible_if::COLLAPSIBLE_IF,\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,"}, {"sha": "ccb339390b1e83e0ee3e27f1f06e77aa08b3e78d", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -1,10 +1,10 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n+use rustc::hir::intravisit::FnKind;\n use rustc::ty;\n use syntax::codemap::Span;\n-use utils::{higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n+use utils::{contains_name, higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -261,7 +261,7 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                 ),\n                 |db| { db.span_note(prev_span, \"previous binding is here\"); },\n             );\n-        } else if contains_self(name, expr) {\n+        } else if contains_name(name, expr) {\n             span_lint_and_then(\n                 cx,\n                 SHADOW_REUSE,\n@@ -391,27 +391,3 @@ fn path_eq_name(name: Name, path: &Path) -> bool {\n     !path.is_global() && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n-struct ContainsSelf {\n-    name: Name,\n-    result: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ContainsSelf {\n-    fn visit_name(&mut self, _: Span, name: Name) {\n-        if self.name == name {\n-            self.result = true;\n-        }\n-    }\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-fn contains_self(name: Name, expr: &Expr) -> bool {\n-    let mut cs = ContainsSelf {\n-        name: name,\n-        result: false,\n-    };\n-    cs.visit_expr(expr);\n-    cs.result\n-}"}, {"sha": "c24ccd5d57342612796059583739212fee0b5287", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -3,6 +3,7 @@ use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::Def;\n+use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, Level, LateContext, Lint};\n use rustc::session::Session;\n@@ -393,6 +394,33 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n+struct ContainsName {\n+    name: Name,\n+    result: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ContainsName {\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        if self.name == name {\n+            self.result = true;\n+        }\n+    }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// check if an `Expr` contains a certain name\n+pub fn contains_name(name: Name, expr: &Expr) -> bool {\n+    let mut cn = ContainsName {\n+        name: name,\n+        result: false,\n+    };\n+    cn.visit_expr(expr);\n+    cn.result\n+}\n+\n+\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example"}, {"sha": "060cf4f978efbc340947461be5805579234ff426", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -69,6 +69,7 @@ pub const RESULT_ERR: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n pub const SERDE_DE_VISITOR: [&'static str; 3] = [\"serde\", \"de\", \"Visitor\"];\n pub const SLICE_INTO_VEC: [&'static str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n+pub const SLICE_ITER: [&str; 3] = [\"core\", \"slice\", \"Iter\"];\n pub const STRING: [&'static str; 3] = [\"alloc\", \"string\", \"String\"];\n pub const TO_OWNED: [&'static str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n pub const TO_STRING: [&'static str; 3] = [\"alloc\", \"string\", \"ToString\"];"}, {"sha": "8fc27c49f34b4da2475345926bbd7b9a8d3cd8ba", "filename": "tests/ui/bytecount.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/tests%2Fui%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/tests%2Fui%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.rs?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -0,0 +1,27 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(naive_bytecount)]\n+fn main() {\n+    let x = vec![0_u8; 16];\n+\n+    let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n+\n+    let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n+\n+    let _ = x.iter().filter(|a| **a > 0).count(); // not an equality count, OK.\n+\n+    let _ = x.iter().map(|a| a + 1).filter(|&a| a < 15).count(); // not a slice\n+\n+    let b = 0;\n+\n+    let _ = x.iter().filter(|_| b > 0).count(); // woah there\n+\n+    let _ = x.iter().filter(|_a| b == b + 1).count(); // nothing to see here, move along\n+\n+    let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n+\n+    let y = vec![0_u16; 3];\n+\n+    let _ = y.iter().filter(|&&a| a == 0).count(); // naive count, but not bytes\n+}"}, {"sha": "307edecfde1a097b5ed07b9536bc61f77b562213", "filename": "tests/ui/bytecount.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/36e417cce5b322801af015804275352add9f5c96/tests%2Fui%2Fbytecount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36e417cce5b322801af015804275352add9f5c96/tests%2Fui%2Fbytecount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.stderr?ref=36e417cce5b322801af015804275352add9f5c96", "patch": "@@ -0,0 +1,26 @@\n+error: You appear to be counting bytes the naive way\n+ --> $DIR/bytecount.rs:8:13\n+  |\n+8 |     let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n+  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count(x, 0)`\n+  |\n+note: lint level defined here\n+ --> $DIR/bytecount.rs:4:8\n+  |\n+4 | #[deny(naive_bytecount)]\n+  |        ^^^^^^^^^^^^^^^\n+\n+error: You appear to be counting bytes the naive way\n+  --> $DIR/bytecount.rs:10:13\n+   |\n+10 |     let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n+\n+error: You appear to be counting bytes the naive way\n+  --> $DIR/bytecount.rs:22:13\n+   |\n+22 |     let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count(x, b + 1)`\n+\n+error: aborting due to 3 previous errors\n+"}]}