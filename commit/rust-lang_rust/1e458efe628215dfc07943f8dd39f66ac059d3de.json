{"sha": "1e458efe628215dfc07943f8dd39f66ac059d3de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNDU4ZWZlNjI4MjE1ZGZjMDc5NDNmOGRkMzlmNjZhYzA1OWQzZGU=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-11-10T10:00:42Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-11-16T19:19:06Z"}, "message": "Add braces to functions and macros", "tree": {"sha": "4ad588f859be9cad26fb281dcfe3b39ad18ae099", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ad588f859be9cad26fb281dcfe3b39ad18ae099"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e458efe628215dfc07943f8dd39f66ac059d3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e458efe628215dfc07943f8dd39f66ac059d3de", "html_url": "https://github.com/rust-lang/rust/commit/1e458efe628215dfc07943f8dd39f66ac059d3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e458efe628215dfc07943f8dd39f66ac059d3de/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ab97244b88b180c1cafd5b47533bd4366a09177", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab97244b88b180c1cafd5b47533bd4366a09177", "html_url": "https://github.com/rust-lang/rust/commit/6ab97244b88b180c1cafd5b47533bd4366a09177"}], "stats": {"total": 138, "additions": 99, "deletions": 39}, "files": [{"sha": "4cf21e19df0fff7dd1f01ebf80258b4cd58ff578", "filename": "crates/completion/src/completions/complete_magic.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1e458efe628215dfc07943f8dd39f66ac059d3de/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fcomplete_magic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e458efe628215dfc07943f8dd39f66ac059d3de/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fcomplete_magic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fcomplete_magic.rs?ref=1e458efe628215dfc07943f8dd39f66ac059d3de", "patch": "@@ -1,7 +1,8 @@\n //! TODO kb move this into the complete_unqualified_path when starts to work properly\n \n use assists::utils::{insert_use, mod_path_to_ast, ImportScope, MergeBehaviour};\n-use hir::Query;\n+use either::Either;\n+use hir::{db::HirDatabase, MacroDef, ModuleDef, Query};\n use itertools::Itertools;\n use syntax::{algo, AstNode};\n use text_edit::TextEdit;\n@@ -28,14 +29,23 @@ pub(crate) fn complete_magic(acc: &mut Completions, ctx: &CompletionContext) ->\n         // TODO kb use imports_locator instead?\n         .query_external_importables(ctx.db, Query::new(&potential_import_name).limit(40))\n         .unique()\n-        .filter_map(|import_candidate| match import_candidate {\n-            either::Either::Left(module_def) => current_module.find_use_path(ctx.db, module_def),\n-            either::Either::Right(macro_def) => current_module.find_use_path(ctx.db, macro_def),\n+        .filter_map(|import_candidate| {\n+            let use_path = match import_candidate {\n+                Either::Left(module_def) => current_module.find_use_path(ctx.db, module_def),\n+                Either::Right(macro_def) => current_module.find_use_path(ctx.db, macro_def),\n+            }?;\n+            // TODO kb need to omit braces when there are some already.\n+            // maybe remove braces completely?\n+            Some((use_path, additional_completion(ctx.db, import_candidate)))\n         })\n-        .filter_map(|mod_path| {\n+        .filter_map(|(mod_path, additional_completion)| {\n             let mut builder = TextEdit::builder();\n \n-            let correct_qualifier = mod_path.segments.last()?.to_string();\n+            let correct_qualifier = format!(\n+                \"{}{}\",\n+                mod_path.segments.last()?,\n+                additional_completion.unwrap_or_default()\n+            );\n             builder.replace(anchor.syntax().text_range(), correct_qualifier);\n \n             // TODO kb: assists already have the merge behaviour setting, need to unite both\n@@ -60,6 +70,21 @@ pub(crate) fn complete_magic(acc: &mut Completions, ctx: &CompletionContext) ->\n     Some(())\n }\n \n+fn additional_completion(\n+    db: &dyn HirDatabase,\n+    import_candidate: Either<ModuleDef, MacroDef>,\n+) -> Option<String> {\n+    match import_candidate {\n+        Either::Left(ModuleDef::Function(_)) => Some(\"()\".to_string()),\n+        Either::Right(macro_def) => {\n+            let (left_brace, right_brace) =\n+                crate::render::macro_::guess_macro_braces(db, macro_def);\n+            Some(format!(\"!{}{}\", left_brace, right_brace))\n+        }\n+        _ => None,\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::test_utils::check_edit;\n@@ -83,7 +108,34 @@ fn main() {\n use dep::io::stdin;\n \n fn main() {\n-    stdin\n+    stdin()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_magic_completion() {\n+        check_edit(\n+            \"dep::macro_with_curlies\",\n+            r#\"\n+//- /lib.rs crate:dep\n+/// Please call me as macro_with_curlies! {}\n+#[macro_export]\n+macro_rules! macro_with_curlies {\n+    () => {}\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    curli<|>\n+}\n+\"#,\n+            r#\"\n+use dep::macro_with_curlies;\n+\n+fn main() {\n+    macro_with_curlies! {}\n }\n \"#,\n         );"}, {"sha": "b41c00b987d6c3cb101176cef2c9f4a189c54d11", "filename": "crates/completion/src/render/macro_.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1e458efe628215dfc07943f8dd39f66ac059d3de/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e458efe628215dfc07943f8dd39f66ac059d3de/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs?ref=1e458efe628215dfc07943f8dd39f66ac059d3de", "patch": "@@ -1,6 +1,6 @@\n //! Renderer for macro invocations.\n \n-use hir::{Documentation, HasSource};\n+use hir::{db::HirDatabase, Documentation, HasAttrs, HasSource};\n use syntax::display::macro_label;\n use test_utils::mark;\n \n@@ -27,12 +27,48 @@ struct MacroRender<'a> {\n     ket: &'static str,\n }\n \n+pub fn guess_macro_braces(\n+    db: &dyn HirDatabase,\n+    macro_: hir::MacroDef,\n+) -> (&'static str, &'static str) {\n+    let macro_name = match macro_.name(db) {\n+        Some(name) => name.to_string(),\n+        None => return (\"(\", \")\"),\n+    };\n+    let macro_docs = macro_.docs(db);\n+    let macro_docs = macro_docs.as_ref().map(Documentation::as_str).unwrap_or(\"\");\n+\n+    let mut votes = [0, 0, 0];\n+    for (idx, s) in macro_docs.match_indices(&macro_name) {\n+        let (before, after) = (&macro_docs[..idx], &macro_docs[idx + s.len()..]);\n+        // Ensure to match the full word\n+        if after.starts_with('!')\n+            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n+        {\n+            // It may have spaces before the braces like `foo! {}`\n+            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n+                Some('{') => votes[0] += 1,\n+                Some('[') => votes[1] += 1,\n+                Some('(') => votes[2] += 1,\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    // Insert a space before `{}`.\n+    // We prefer the last one when some votes equal.\n+    let (_vote, (bra, ket)) = votes\n+        .iter()\n+        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n+        .max_by_key(|&(&vote, _)| vote)\n+        .unwrap();\n+    (*bra, *ket)\n+}\n+\n impl<'a> MacroRender<'a> {\n     fn new(ctx: RenderContext<'a>, name: String, macro_: hir::MacroDef) -> MacroRender<'a> {\n         let docs = ctx.docs(macro_);\n-        let docs_str = docs.as_ref().map_or(\"\", |s| s.as_str());\n-        let (bra, ket) = guess_macro_braces(&name, docs_str);\n-\n+        let (bra, ket) = guess_macro_braces(ctx.db(), macro_);\n         MacroRender { ctx, name, macro_, docs, bra, ket }\n     }\n \n@@ -97,34 +133,6 @@ impl<'a> MacroRender<'a> {\n     }\n }\n \n-fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n-    let mut votes = [0, 0, 0];\n-    for (idx, s) in docs.match_indices(&macro_name) {\n-        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n-        // Ensure to match the full word\n-        if after.starts_with('!')\n-            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n-        {\n-            // It may have spaces before the braces like `foo! {}`\n-            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n-                Some('{') => votes[0] += 1,\n-                Some('[') => votes[1] += 1,\n-                Some('(') => votes[2] += 1,\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    // Insert a space before `{}`.\n-    // We prefer the last one when some votes equal.\n-    let (_vote, (bra, ket)) = votes\n-        .iter()\n-        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n-        .max_by_key(|&(&vote, _)| vote)\n-        .unwrap();\n-    (*bra, *ket)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::mark;"}]}