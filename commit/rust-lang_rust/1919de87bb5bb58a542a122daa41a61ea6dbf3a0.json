{"sha": "1919de87bb5bb58a542a122daa41a61ea6dbf3a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MTlkZTg3YmI1YmI1OGE1NDJhMTIyZGFhNDFhNjFlYTZkYmYzYTA=", "commit": {"author": {"name": "Kevin Yap", "email": "me@kevinyap.ca", "date": "2014-12-13T22:36:53Z"}, "committer": {"name": "Kevin Yap", "email": "me@kevinyap.ca", "date": "2014-12-19T18:23:06Z"}, "message": "Miscellaneous changes to Rust Guide\n\n- Various grammatical changes\n- Place punctuation outside of key term quotes\n- Change comment placement in 17.2 code block\n- Replace double hyphens with en dashes", "tree": {"sha": "314b47146b3690b3992d456bb0ec5bc13a4f285c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314b47146b3690b3992d456bb0ec5bc13a4f285c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1919de87bb5bb58a542a122daa41a61ea6dbf3a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1919de87bb5bb58a542a122daa41a61ea6dbf3a0", "html_url": "https://github.com/rust-lang/rust/commit/1919de87bb5bb58a542a122daa41a61ea6dbf3a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1919de87bb5bb58a542a122daa41a61ea6dbf3a0/comments", "author": {"login": "iKevinY", "id": 2434728, "node_id": "MDQ6VXNlcjI0MzQ3Mjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2434728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iKevinY", "html_url": "https://github.com/iKevinY", "followers_url": "https://api.github.com/users/iKevinY/followers", "following_url": "https://api.github.com/users/iKevinY/following{/other_user}", "gists_url": "https://api.github.com/users/iKevinY/gists{/gist_id}", "starred_url": "https://api.github.com/users/iKevinY/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iKevinY/subscriptions", "organizations_url": "https://api.github.com/users/iKevinY/orgs", "repos_url": "https://api.github.com/users/iKevinY/repos", "events_url": "https://api.github.com/users/iKevinY/events{/privacy}", "received_events_url": "https://api.github.com/users/iKevinY/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iKevinY", "id": 2434728, "node_id": "MDQ6VXNlcjI0MzQ3Mjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2434728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iKevinY", "html_url": "https://github.com/iKevinY", "followers_url": "https://api.github.com/users/iKevinY/followers", "following_url": "https://api.github.com/users/iKevinY/following{/other_user}", "gists_url": "https://api.github.com/users/iKevinY/gists{/gist_id}", "starred_url": "https://api.github.com/users/iKevinY/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iKevinY/subscriptions", "organizations_url": "https://api.github.com/users/iKevinY/orgs", "repos_url": "https://api.github.com/users/iKevinY/repos", "events_url": "https://api.github.com/users/iKevinY/events{/privacy}", "received_events_url": "https://api.github.com/users/iKevinY/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bfb64e5252179b5bd6d8a2e96664ca97a2496f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bfb64e5252179b5bd6d8a2e96664ca97a2496f3", "html_url": "https://github.com/rust-lang/rust/commit/2bfb64e5252179b5bd6d8a2e96664ca97a2496f3"}], "stats": {"total": 154, "additions": 76, "deletions": 78}, "files": [{"sha": "6dfc19e7294b5de763149f143690104b39755154", "filename": "src/doc/guide.md", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/1919de87bb5bb58a542a122daa41a61ea6dbf3a0/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/1919de87bb5bb58a542a122daa41a61ea6dbf3a0/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=1919de87bb5bb58a542a122daa41a61ea6dbf3a0", "patch": "@@ -1156,7 +1156,7 @@ enum StringResult {\n     ErrorReason(String),\n }\n ```\n-Where a `StringResult` is either an `StringOK`, with the result of a computation, or an\n+Where a `StringResult` is either a `StringOK`, with the result of a computation, or an\n `ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n `enum`s are actually very useful and are even part of the standard library.\n \n@@ -1178,7 +1178,7 @@ fn respond(greeting: &str) -> StringResult {\n ```\n \n Notice that we need both the enum name and the variant name: `StringResult::StringOK`, but\n-we didn't need to with `Ordering`, we just said `Greater` rather than `Ordering::Greater`.\n+we didn't need to with `Ordering` \u2013 we just said `Greater` rather than `Ordering::Greater`.\n There's a reason: the Rust prelude imports the variants of `Ordering` as well as the enum\n itself. We can use the `use` keyword to do something similar with `StringResult`:\n \n@@ -1209,16 +1209,16 @@ now, rather than the full `StringResult::StringOK`. Importing variants can be co\n also cause name conflicts, so do this with caution. It's considered good style to rarely import\n variants for this reason.\n \n-As you can see `enum`s with values are quite a powerful tool for data representation,\n-and can be even more useful when they're generic across types. But before we get to\n-generics, let's talk about how to use them with pattern matching, a tool that will\n+As you can see, `enum`s with values are quite a powerful tool for data representation,\n+and can be even more useful when they're generic across types. Before we get to generics,\n+though, let's talk about how to use them with pattern matching, a tool that will\n let us deconstruct this sum type (the type theory term for enums) in a very elegant\n way and avoid all these messy `if`/`else`s.\n \n # Match\n \n Often, a simple `if`/`else` isn't enough, because you have more than two\n-possible options. And `else` conditions can get incredibly complicated. So\n+possible options. Also, `else` conditions can get incredibly complicated, so\n what's the solution?\n \n Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n@@ -1237,25 +1237,25 @@ match x {\n }\n ```\n \n-`match` takes an expression, and then branches based on its value. Each 'arm' of\n+`match` takes an expression and then branches based on its value. Each 'arm' of\n the branch is of the form `val => expression`. When the value matches, that arm's\n expression will be evaluated. It's called `match` because of the term 'pattern\n-matching,' which `match` is an implementation of.\n+matching', which `match` is an implementation of.\n \n So what's the big advantage here? Well, there are a few. First of all, `match`\n-enforces 'exhaustiveness checking.' Do you see that last arm, the one with the\n+enforces 'exhaustiveness checking'. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n ```{notrust}\n error: non-exhaustive patterns: `_` not covered\n ```\n \n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values. For example,\n-`6i`. But without the `_`, there is no arm that could match, and so Rust refuses\n-to compile. `_` is sort of like a catch-all arm. If none of the other arms match,\n-the arm with `_` will. And since we have this catch-all arm, we now have an arm\n-for every possible value of `x`, and so our program will now compile.\n+integer, Rust knows that it can have a number of different values \u2013 for example,\n+`6i`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n+to compile. `_` acts like a 'catch-all arm'. If none of the other arms match,\n+the arm with `_` will, and since we have this catch-all arm, we now have an arm\n+for every possible value of `x`, and so our program will compile successfully.\n \n `match` statements also destructure enums, as well. Remember this code from the\n section on enums?\n@@ -1336,14 +1336,14 @@ fn main() {\n ```\n \n That is how you can get and use the values contained in `enum`s.\n-It can also allow us to treat errors or unexpected computations, for example, a\n-function that is not guaranteed to be able to compute a result (an `int` here),\n+It can also allow us to handle errors or unexpected computations; for example, a\n+function that is not guaranteed to be able to compute a result (an `int` here)\n could return an `OptionalInt`, and we would handle that value with a `match`.\n As you can see, `enum` and `match` used together are quite useful!\n \n-`match` is also an expression, which means we can use it on the right\n-hand side of a `let` binding or directly where an expression is\n-used. We could also implement the previous line like this:\n+`match` is also an expression, which means we can use it on the right-hand\n+side of a `let` binding or directly where an expression is used. We could\n+also implement the previous line like this:\n \n ```{rust}\n fn cmp(a: int, b: int) -> Ordering {\n@@ -1375,7 +1375,7 @@ two main looping constructs: `for` and `while`.\n \n The `for` loop is used to loop a particular number of times. Rust's `for` loops\n work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C style\" `for` loop:\n+loop doesn't look like this \"C-style\" `for` loop:\n \n ```{c}\n for (x = 0; x < 10; x++) {\n@@ -1410,7 +1410,7 @@ In our example, `range` is a function that takes a start and an end position,\n and gives an iterator over those values. The upper bound is exclusive, though,\n so our loop will print `0` through `9`, not `10`.\n \n-Rust does not have the \"C style\" `for` loop on purpose. Manually controlling\n+Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n developers.\n \n@@ -1441,7 +1441,7 @@ If you need an infinite loop, you may be tempted to write this:\n while true {\n ```\n \n-Rust has a dedicated keyword, `loop`, to handle this case:\n+However, Rust has a dedicated keyword, `loop`, to handle this case:\n \n ```{rust,ignore}\n loop {\n@@ -1451,7 +1451,7 @@ Rust's control-flow analysis treats this construct differently than a\n `while true`, since we know that it will always loop. The details of what\n that _means_ aren't super important to understand at this stage, but in\n general, the more information we can give to the compiler, the better it\n-can do with safety and code generation. So you should always prefer\n+can do with safety and code generation, so you should always prefer\n `loop` when you plan to loop infinitely.\n \n ## Ending iteration early\n@@ -1470,7 +1470,7 @@ while !done {\n ```\n \n We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n-when we should skip out of the loop. Rust has two keywords to help us with\n+when we should exit out of the loop. Rust has two keywords to help us with\n modifying iteration: `break` and `continue`.\n \n In this case, we can write the loop in a better way with `break`:\n@@ -1485,10 +1485,10 @@ loop {\n }\n ```\n \n-We now loop forever with `loop`, and use `break` to break out early.\n+We now loop forever with `loop` and use `break` to break out early.\n \n `continue` is similar, but instead of ending the loop, goes to the next\n-iteration: This will only print the odd numbers:\n+iteration. This will only print the odd numbers:\n \n ```{rust}\n for x in range(0i, 10i) {\n@@ -1505,8 +1505,8 @@ Both `continue` and `break` are valid in both kinds of loops.\n Strings are an important concept for any programmer to master. Rust's string\n handling system is a bit different from other languages, due to its systems\n focus. Any time you have a data structure of variable size, things can get\n-tricky, and strings are a re-sizable data structure. That said, Rust's strings\n-also work differently than in some other systems languages, such as C.\n+tricky, and strings are a re-sizable data structure. That being said, Rust's\n+strings also work differently than in some other systems languages, such as C.\n \n Let's dig into the details. A **string** is a sequence of Unicode scalar values\n encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n@@ -1774,22 +1774,22 @@ fn main() {\n }\n ```\n \n-We had to match each time, to see if we had a value or not. In this case,\n-though, we _know_ that `x` has a `Value`. But `match` forces us to handle\n+We had to match each time to see if we had a value or not. In this case,\n+though, we _know_ that `x` has a `Value`, but `match` forces us to handle\n the `missing` case. This is what we want 99% of the time, but sometimes, we\n know better than the compiler.\n \n Likewise, `read_line()` does not return a line of input. It _might_ return a\n-line of input. It might also fail to do so. This could happen if our program\n+line of input, though it might also fail to do so. This could happen if our program\n isn't running in a terminal, but as part of a cron job, or some other context\n where there's no standard input. Because of this, `read_line` returns a type\n very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n `IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n-Until then, you can think of it as being the same thing, just for any type, not\n-just `int`s.\n+Until then, you can think of it as being the same thing, just for any type \u2013\n+not just `int`s.\n \n Rust provides a method on these `IoResult<T>`s called `ok()`, which does the\n-same thing as our `match` statement, but assuming that we have a valid value.\n+same thing as our `match` statement but assumes that we have a valid value.\n We then call `expect()` on the result, which will terminate our program if we\n don't have a valid value. In this case, if we can't get input, our program\n doesn't work, so we're okay with that. In most cases, we would want to handle\n@@ -1831,7 +1831,7 @@ fn main() {\n }\n ```\n \n-Sometimes, this makes things more readable. Sometimes, less. Use your judgment\n+Sometimes, this makes things more readable \u2013 sometimes, less. Use your judgement\n here.\n \n That's all you need to get basic input from the standard input! It's not too\n@@ -1951,10 +1951,8 @@ You can find that page [here](std/index.html). There's a lot of information on\n that page, but the best part is the search bar. Right up at the top, there's\n a box that you can enter in a search term. The search is pretty primitive\n right now, but is getting better all the time. If you type 'random' in that\n-box, the page will update to [this\n-one](std/index.html?search=random). The very first\n-result is a link to\n-[std::rand::random](std/rand/fn.random.html). If we\n+box, the page will update to [this one](std/index.html?search=random). The very\n+first result is a link to [`std::rand::random`](std/rand/fn.random.html). If we\n click on that result, we'll be taken to its documentation page.\n \n This page shows us a few things: the type signature of the function, some\n@@ -2018,7 +2016,7 @@ rand::random::<int>();\n ```\n \n This says \"please give me a random `int` value.\" We can change our code to use\n-this hint...\n+this hint:\n \n ```{rust,no_run}\n use std::io;\n@@ -2359,7 +2357,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n }\n ```\n \n-We use a `match` to either give us the `uint` inside of the `Option`, or we\n+We use a `match` to either give us the `uint` inside of the `Option`, or else\n print an error message and return. Let's give this a shot:\n \n ```{notrust}\n@@ -2377,8 +2375,8 @@ Uh, what? But we did!\n \n ... actually, we didn't. See, when you get a line of input from `stdin()`,\n you get all the input. Including the `\\n` character from you pressing Enter.\n-So, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a number,\n-there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n+Therefore, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a\n+number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n method we can use defined on them: `trim()`. One small modification, and our\n code looks like this:\n \n@@ -2444,16 +2442,16 @@ out that I guessed 76. Run the program a few times, and verify that guessing\n the number works, as well as guessing a number too small.\n \n The Rust compiler helped us out quite a bit there! This technique is called\n-\"lean on the compiler,\" and it's often useful when working on some code. Let\n+\"lean on the compiler\", and it's often useful when working on some code. Let\n the error messages help guide you towards the correct types.\n \n Now we've got most of the game working, but we can only make one guess. Let's\n change that by adding loops!\n \n ## Looping\n \n-As we already discussed, the `loop` keyword gives us an infinite loop. So\n-let's add that in:\n+As we already discussed, the `loop` keyword gives us an infinite loop.\n+Let's add that in:\n \n ```{rust,no_run}\n use std::io;\n@@ -2759,12 +2757,11 @@ $ cargo run\n Hello, world!\n ```\n \n-Excellent! So, we already have a single crate here: our `src/main.rs` is a crate.\n+Excellent! We already have a single crate here: our `src/main.rs` is a crate.\n Everything in that file is in the crate root. A crate that generates an executable\n defines a `main` function inside its root, as we've done here.\n \n-Let's define a new module inside our crate. Edit `src/main.rs` to look\n-like this:\n+Let's define a new module inside our crate. Edit `src/main.rs` to look like this:\n \n ```\n fn main() {\n@@ -2782,7 +2779,7 @@ We now have a module named `hello` inside of our crate root. Modules use\n `snake_case` naming, like functions and variable bindings.\n \n Inside the `hello` module, we've defined a `print_hello` function. This will\n-also print out our hello world message. Modules allow you to split up your\n+also print out our \"hello world\" message. Modules allow you to split up your\n program into nice neat boxes of functionality, grouping common things together,\n and keeping different things apart. It's kinda like having a set of shelves:\n a place for everything and everything in its place.\n@@ -2942,7 +2939,7 @@ You'll get a warning if you use something marked unstable.\n \n You may have noticed an exclamation point in the `warn` attribute declaration.\n The `!` in this attribute means that this attribute applies to the enclosing\n-item, rather than to the item that follows the attribute. So this `warn`\n+item, rather than to the item that follows the attribute. This `warn`\n attribute declaration applies to the enclosing crate itself, rather than\n to whatever item statement follows it:\n \n@@ -2982,9 +2979,9 @@ Hello, world!\n Great. Rust's infrastructure supports tests in two sorts of places, and they're\n for two kinds of tests: you include **unit test**s inside of the crate itself,\n and you place **integration test**s inside a `tests` directory. \"Unit tests\"\n-are small tests that test one focused unit, \"integration tests\" tests multiple\n-units in integration. That said, this is a social convention, they're no different\n-in syntax. Let's make a `tests` directory:\n+are small tests that test one focused unit; \"integration tests\" test multiple\n+units in integration. That being said, this is a social convention \u2013 they're no\n+different in syntax. Let's make a `tests` directory:\n \n ```{bash,ignore}\n $ mkdir tests\n@@ -3064,7 +3061,7 @@ test foo ... FAILED\n \n Now we're getting somewhere. Remember when we talked about naming our tests\n with good names? This is why. Here, it says 'test foo' because we called our\n-test 'foo.' If we had given it a good name, it'd be more clear which test\n+test 'foo'. If we had given it a good name, it'd be more clear which test\n failed, especially as we accumulate more tests.\n \n ```{notrust}\n@@ -3135,7 +3132,7 @@ our tests, it sets things up so that `cfg(test)` is true. But we want to only\n include `main` when it's _not_ true. So we use `not` to negate things:\n `cfg(not(test))` will only compile our code when the `cfg(test)` is false.\n \n-With this attribute we won't get the warning (even\n+With this attribute, we won't get the warning (even\n though `src/main.rs` gets recompiled this time):\n \n ```{ignore}\n@@ -3179,15 +3176,15 @@ error: aborting due to previous error\n Build failed, waiting for other jobs to finish...\n Could not compile `testing`.\n \n-To learn more, run the command again with --verbose.\n+To learn more, run the command again with `--verbose`.\n ```\n \n Rust can't find this function. That makes sense, as we didn't write it yet!\n \n In order to share this code with our tests, we'll need to make a library crate.\n This is also just good software design: as we mentioned before, it's a good idea\n to put most of your functionality into a library crate, and have your executable\n-crate use that library. This allows for code re-use.\n+crate use that library. This allows for code reuse.\n \n To do that, we'll need to make a new module. Make a new file, `src/lib.rs`,\n and put this in it:\n@@ -3261,8 +3258,8 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n Great! One test passed. We've got an integration test showing that our public\n method works, but maybe we want to test some of the internal logic as well.\n While this function is simple, if it were more complicated, you can imagine\n-we'd need more tests. So let's break it up into two helper functions, and\n-write some unit tests to test those.\n+we'd need more tests. Let's break it up into two helper functions and write\n+some unit tests to test those.\n \n Change your `src/lib.rs` to look like this:\n \n@@ -3511,7 +3508,7 @@ error: cannot borrow immutable local variable `x` as mutable\n ```\n \n We don't want a mutable reference to immutable data! This error message uses a\n-term we haven't talked about yet, 'borrow.' We'll get to that in just a moment.\n+term we haven't talked about yet, 'borrow'. We'll get to that in just a moment.\n \n This simple example actually illustrates a lot of Rust's power: Rust has\n prevented us, at compile time, from breaking our own rules. Because Rust's\n@@ -3632,9 +3629,10 @@ all of Rust. Let's see this syntax in action:\n fn foo(x: &int) -> &int { x }\n \n {\n-    let x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    // x is the owner of the integer, which is memory on the stack.\n+    let x = 5i;\n \n-    // privilege 2: you may lend that resource, to as many borrowers as you'd like\n+    // privilege 2: you may lend that resource to as many borrowers as you like\n     let y = &x;\n     let z = &x;\n \n@@ -3644,10 +3642,11 @@ fn foo(x: &int) -> &int { x }\n }\n \n {\n-    let mut x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    // x is the owner of this integer, which is memory on the stack.\n+    let mut x = 5i;\n \n-    let y = &mut x; // privilege 3: you may lend that resource to a single borrower,\n-                    // mutably\n+    // privilege 3: you may lend that resource to a single borrower, mutably\n+    let y = &mut x;\n }\n ```\n \n@@ -3663,7 +3662,7 @@ This last requirement can seem odd, but it also makes sense. If you have to\n return something, and you've lent it to someone, they need to give it back to\n you for you to give it back! If we didn't, then the owner could deallocate\n the memory, and the person we've loaned it out to would have a pointer to\n-invalid memory. This is called a 'dangling pointer.'\n+invalid memory. This is called a 'dangling pointer'.\n \n Let's re-examine the error that led us to talk about all of this, which was a\n violation of the restrictions placed on owners who lend something out mutably.\n@@ -3786,8 +3785,8 @@ an integer `5` and makes `x` a pointer to it:\n ```\n \n The great thing about boxes is that we don't have to manually free this\n-allocation! Instead, when `x` reaches the end of its lifetime -- in this case,\n-when it goes out of scope at the end of the block -- Rust `free`s `x`. This\n+allocation! Instead, when `x` reaches the end of its lifetime \u2013 in this case,\n+when it goes out of scope at the end of the block \u2013 Rust `free`s `x`. This\n isn't because Rust has a garbage collector (it doesn't). Instead, by tracking\n the ownership and lifetime of a variable (with a little help from you, the\n programmer), the compiler knows precisely when it is no longer used.\n@@ -3852,12 +3851,12 @@ Sometimes you need a variable that is referenced from multiple places\n (immutably!), lasting as long as any of those places, and disappearing when it\n is no longer referenced. For instance, in a graph-like data structure, a node\n might be referenced from all of its neighbors. In this case, it is not possible\n-for the compiler to determine ahead of time when the value can be freed -- it\n+for the compiler to determine ahead of time when the value can be freed \u2013 it\n needs a little run-time support.\n \n Rust's **Rc** type provides shared ownership of a dynamically allocated value\n that is automatically freed at the end of its last owner's lifetime. (`Rc`\n-stands for 'reference counted,' referring to the way these library types are\n+stands for 'reference counted', referring to the way these library types are\n implemented.) This provides more flexibility than single-owner boxes, but has\n some runtime overhead.\n \n@@ -4299,7 +4298,7 @@ This line is more interesting. Here, we call our function, `twice`, and we pass\n it two arguments: an integer, `5`, and our closure, `square`. This is just like\n passing any other two variable bindings to a function, but if you've never\n worked with closures before, it can seem a little complex. Just think: \"I'm\n-passing two variables, one is an int, and one is a function.\"\n+passing two variables: one is an int, and one is a function.\"\n \n Next, let's look at how `twice` is defined:\n \n@@ -4335,7 +4334,7 @@ fn twice(x: int, f: |int| -> int) -> int {\n ```\n \n Since our closure is named `f`, we can call it just like we called our closures\n-before. And we pass in our `x` argument to each one. Hence 'twice.'\n+before, and we pass in our `x` argument to each one, hence the name `twice`.\n \n If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n \n@@ -4806,7 +4805,7 @@ enum Result<H, N> {\n ```\n \n if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+`T`, for 'type,' and that we use `E` for 'error'. Rust doesn't care, however.\n \n The `Result<T, E>` type is intended to\n be used to return the result of a computation, and to have the ability to\n@@ -5211,7 +5210,7 @@ fn main() {\n \n The names don't actually change to this, it's just for illustration. But\n as you can see, there's no overhead of deciding which version to call here,\n-hence 'statically dispatched.' The downside is that we have two copies of\n+hence 'statically dispatched'. The downside is that we have two copies of\n the same function, so our binary is a little bit larger.\n \n # Tasks\n@@ -5406,7 +5405,7 @@ fn main() {\n }\n ```\n \n-You can have the macros expanded like this: `rustc print.rs --pretty=expanded` \u2013 which will\n+You can have the macros expanded like this: `rustc print.rs --pretty=expanded`, which will\n give us this huge result:\n \n ```{rust,ignore}\n@@ -5492,7 +5491,6 @@ We covered a lot of ground here. When you've mastered everything in this Guide,\n you will have a firm grasp of basic Rust development. There's a whole lot more\n out there, we've just covered the surface. There's tons of topics that you can\n dig deeper into, and we've built specialized guides for many of them. To learn\n-more, dig into the [full documentation\n-index](index.html).\n+more, dig into the [full documentation index](index.html).\n \n Happy hacking!"}]}