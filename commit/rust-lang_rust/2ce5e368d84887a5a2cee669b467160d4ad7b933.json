{"sha": "2ce5e368d84887a5a2cee669b467160d4ad7b933", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZTVlMzY4ZDg0ODg3YTVhMmNlZTY2OWI0NjcxNjBkNGFkN2I5MzM=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-03-01T11:25:14Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection: Refining the implementation", "tree": {"sha": "01a86c81134e496d79ddf3624de9fcd846d7790d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a86c81134e496d79ddf3624de9fcd846d7790d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ce5e368d84887a5a2cee669b467160d4ad7b933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce5e368d84887a5a2cee669b467160d4ad7b933", "html_url": "https://github.com/rust-lang/rust/commit/2ce5e368d84887a5a2cee669b467160d4ad7b933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ce5e368d84887a5a2cee669b467160d4ad7b933/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "html_url": "https://github.com/rust-lang/rust/commit/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c"}], "stats": {"total": 5982, "additions": 5809, "deletions": 173}, "files": [{"sha": "565327a7f839cc2cebfbf81b6ed2b02ef30d445f", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ce5e368d84887a5a2cee669b467160d4ad7b933/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/2ce5e368d84887a5a2cee669b467160d4ad7b933/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=2ce5e368d84887a5a2cee669b467160d4ad7b933", "patch": "@@ -29,7 +29,7 @@ out\n \n # gh pages docs\n util/gh-pages/lints.json\n-**/metadata_collection.json\n+# **/metadata_collection.json\n \n # rustfmt backups\n *.rs.bk"}, {"sha": "a9ae2b77119bcaa1bda2f9d9d6bfa4264c2b2899", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ce5e368d84887a5a2cee669b467160d4ad7b933/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce5e368d84887a5a2cee669b467160d4ad7b933/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=2ce5e368d84887a5a2cee669b467160d4ad7b933", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath, Stmt, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;"}, {"sha": "b2cc63722779003eb762b8ca9c5c5f8f67d3673f", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 109, "deletions": 171, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/2ce5e368d84887a5a2cee669b467160d4ad7b933/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce5e368d84887a5a2cee669b467160d4ad7b933/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=2ce5e368d84887a5a2cee669b467160d4ad7b933", "patch": "@@ -33,7 +33,7 @@\n \n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{self as hir, intravisit, ExprKind, Item, ItemKind, Mutability, QPath};\n+use rustc_hir::{self as hir, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -52,19 +52,18 @@ use crate::utils::{\n const OUTPUT_FILE: &str = \"metadata_collection.json\";\n /// These lints are excluded from the export.\n const BLACK_LISTED_LINTS: [&str; 2] = [\"lint_author\", \"deep_code_inspection\"];\n-/// These groups will be ignored by the lint group matcher\n-const BLACK_LISTED_LINT_GROUP: [&str; 1] = [\"clippy::all\", \"clippy::internal\"];\n+/// These groups will be ignored by the lint group matcher. This is useful for collections like\n+/// `clippy::all`\n+const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];\n+/// Lints within this group will be excluded from the collection\n+const EXCLUDED_LINT_GROUPS: [&str; 1] = [\"clippy::internal\"];\n \n-// TODO xFrednet 2021-02-15: `span_lint_and_then` & `span_lint_hir_and_then` requires special\n-// handling\n-const SIMPLE_LINT_EMISSION_FUNCTIONS: [&[&str]; 5] = [\n+const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n-];\n-const COMPLEX_LINT_EMISSION_FUNCTIONS: [&[&str]; 2] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir_and_then\"],\n ];\n@@ -270,18 +269,11 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// );\n     /// ```\n     fn check_expr(&mut self, cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) {\n-        if let Some(args) = match_simple_lint_emission(cx, expr) {\n-            if let Some((lint_name, applicability)) = extract_emission_info(cx, args) {\n+        if let Some(args) = match_lint_emission(cx, expr) {\n+            if let Some((lint_name, applicability, is_multi_part)) = extract_complex_emission_info(cx, args) {\n                 let app_info = self.applicability_into.entry(lint_name).or_default();\n                 app_info.applicability = applicability;\n-            } else {\n-                lint_collection_error_span(cx, expr.span, \"I found this but I can't get the lint or applicability\");\n-            }\n-        } else if let Some(args) = match_complex_lint_emission(cx, expr) {\n-            if let Some((lint_name, applicability, is_multi_span)) = extract_complex_emission_info(cx, args) {\n-                let app_info = self.applicability_into.entry(lint_name).or_default();\n-                app_info.applicability = applicability;\n-                app_info.is_multi_suggestion = is_multi_span;\n+                app_info.is_multi_suggestion = is_multi_part;\n             } else {\n                 lint_collection_error_span(cx, expr.span, \"Look, here ... I have no clue what todo with it\");\n             }\n@@ -292,7 +284,6 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n // ==================================================================\n // Lint definition extraction\n // ==================================================================\n-\n fn sym_to_string(sym: Symbol) -> String {\n     sym.as_str().to_string()\n }\n@@ -328,10 +319,12 @@ fn extract_attr_docs(item: &Item<'_>) -> Option<String> {\n fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Item<'_>) -> Option<String> {\n     let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n-        get_lint_group(cx, lint_lst[0]).or_else(|| {\n-            lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n-            None\n-        })\n+        get_lint_group(cx, lint_lst[0])\n+            .or_else(|| {\n+                lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n+                None\n+            })\n+            .filter(|group| !EXCLUDED_LINT_GROUPS.contains(&group.as_str()))\n     } else {\n         lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n         None\n@@ -340,7 +333,7 @@ fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Ite\n \n fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n     for (group_name, lints, _) in &cx.lint_store.get_lint_groups() {\n-        if BLACK_LISTED_LINT_GROUP.contains(group_name) {\n+        if IGNORED_LINT_GROUPS.contains(group_name) {\n             continue;\n         }\n \n@@ -378,55 +371,19 @@ fn lint_collection_error_span(cx: &LateContext<'_>, span: Span, message: &str) {\n // ==================================================================\n /// This function checks if a given expression is equal to a simple lint emission function call.\n /// It will return the function arguments if the emission matched any function.\n-fn match_simple_lint_emission<'hir>(\n-    cx: &LateContext<'hir>,\n-    expr: &'hir hir::Expr<'_>,\n-) -> Option<&'hir [hir::Expr<'hir>]> {\n-    SIMPLE_LINT_EMISSION_FUNCTIONS\n-        .iter()\n-        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n-}\n-\n-fn match_complex_lint_emission<'hir>(\n-    cx: &LateContext<'hir>,\n-    expr: &'hir hir::Expr<'_>,\n-) -> Option<&'hir [hir::Expr<'hir>]> {\n-    COMPLEX_LINT_EMISSION_FUNCTIONS\n+fn match_lint_emission<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) -> Option<&'hir [hir::Expr<'hir>]> {\n+    LINT_EMISSION_FUNCTIONS\n         .iter()\n         .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n }\n \n-/// This returns the lint name and the possible applicability of this emission\n-fn extract_emission_info<'hir>(\n-    cx: &LateContext<'hir>,\n-    args: &'hir [hir::Expr<'hir>],\n-) -> Option<(String, Option<String>)> {\n-    let mut lint_name = None;\n-    let mut applicability = None;\n-\n-    for arg in args {\n-        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n-\n-        if match_type(cx, arg_ty, &paths::LINT) {\n-            // If we found the lint arg, extract the lint name\n-            if let ExprKind::Path(ref lint_path) = arg.kind {\n-                lint_name = Some(last_path_segment(lint_path).ident.name);\n-            }\n-        } else if match_type(cx, arg_ty, &paths::APPLICABILITY) {\n-            applicability = resolve_applicability(cx, arg);\n-        }\n-    }\n-\n-    lint_name.map(|lint_name| (sym_to_string(lint_name).to_ascii_lowercase(), applicability))\n-}\n-\n fn extract_complex_emission_info<'hir>(\n     cx: &LateContext<'hir>,\n     args: &'hir [hir::Expr<'hir>],\n ) -> Option<(String, Option<String>, bool)> {\n     let mut lint_name = None;\n     let mut applicability = None;\n-    let mut multi_span = false;\n+    let mut multi_part = false;\n \n     for arg in args {\n         let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n@@ -436,87 +393,47 @@ fn extract_complex_emission_info<'hir>(\n             if let ExprKind::Path(ref lint_path) = arg.kind {\n                 lint_name = Some(last_path_segment(lint_path).ident.name);\n             }\n+        } else if match_type(cx, arg_ty, &paths::APPLICABILITY) {\n+            applicability = resolve_applicability(cx, arg);\n         } else if arg_ty.is_closure() {\n-            if let ExprKind::Closure(_, _, body_id, _, _) = arg.kind {\n-                let mut visitor = EmissionClosureVisitor::new(cx);\n-                intravisit::walk_body(&mut visitor, cx.tcx.hir().body(body_id));\n-                multi_span = visitor.found_multi_span();\n-                applicability = visitor.complete();\n-            } else {\n-                // TODO xfrednet 2021-02-28: linked closures, see: needless_pass_by_value.rs:292\n-                return None;\n-            }\n+            multi_part |= check_is_multi_part(cx, arg);\n+            // TODO xFrednet 2021-03-01: don't use or_else but rather a comparison\n+            applicability = applicability.or_else(|| resolve_applicability(cx, arg));\n         }\n     }\n \n-    lint_name.map(|lint_name| (sym_to_string(lint_name).to_ascii_lowercase(), applicability, multi_span))\n+    lint_name.map(|lint_name| (sym_to_string(lint_name).to_ascii_lowercase(), applicability, multi_part))\n }\n \n /// This function tries to resolve the linked applicability to the given expression.\n fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<String> {\n-    match expr.kind {\n-        // We can ignore ifs without an else block because those can't be used as an assignment\n-        ExprKind::If(_con, if_block, Some(else_block)) => {\n-            let mut visitor = ApplicabilityVisitor::new(cx);\n-            intravisit::walk_expr(&mut visitor, if_block);\n-            intravisit::walk_expr(&mut visitor, else_block);\n-            visitor.complete()\n-        },\n-        ExprKind::Match(_expr, arms, _) => {\n-            let mut visitor = ApplicabilityVisitor::new(cx);\n-            arms.iter()\n-                .for_each(|arm| intravisit::walk_expr(&mut visitor, arm.body));\n-            visitor.complete()\n-        },\n-        ExprKind::Loop(block, ..) | ExprKind::Block(block, ..) => {\n-            let mut visitor = ApplicabilityVisitor::new(cx);\n-            intravisit::walk_block(&mut visitor, block);\n-            visitor.complete()\n-        },\n-        ExprKind::Path(QPath::Resolved(_, path)) => {\n-            // direct applicabilities are simple:\n-            for enum_value in &paths::APPLICABILITY_VALUES {\n-                if match_path(path, enum_value) {\n-                    return Some(enum_value[APPLICABILITY_NAME_INDEX].to_string());\n-                }\n-            }\n-\n-            // Values yay\n-            if let hir::def::Res::Local(local_hir) = path.res {\n-                if let Some(local) = get_parent_local(cx, local_hir) {\n-                    if let Some(local_init) = local.init {\n-                        return resolve_applicability(cx, local_init);\n-                    }\n-                }\n-            }\n-\n-            // This is true for paths that are linked to function parameters. They might be a bit more work so\n-            // not today :)\n-            None\n-        },\n-        _ => None,\n-    }\n+    let mut resolver = ApplicabilityResolver::new(cx);\n+    resolver.visit_expr(expr);\n+    resolver.complete()\n }\n \n-fn get_parent_local(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n-    let map = cx.tcx.hir();\n-\n-    match map.find(map.get_parent_node(hir_id)) {\n-        Some(hir::Node::Local(local)) => Some(local),\n-        Some(hir::Node::Pat(pattern)) => get_parent_local(cx, pattern.hir_id),\n-        _ => None,\n+fn check_is_multi_part(cx: &LateContext<'hir>, closure_expr: &'hir hir::Expr<'hir>) -> bool {\n+    if let ExprKind::Closure(_, _, body_id, _, _) = closure_expr.kind {\n+        let mut scanner = IsMultiSpanScanner::new(cx);\n+        intravisit::walk_body(&mut scanner, cx.tcx.hir().body(body_id));\n+        return scanner.is_multi_part();\n+    } else if let Some(local) = get_parent_local(cx, closure_expr) {\n+        if let Some(local_init) = local.init {\n+            return check_is_multi_part(cx, local_init);\n+        }\n     }\n+\n+    false\n }\n \n /// This visitor finds the highest applicability value in the visited expressions\n-struct ApplicabilityVisitor<'a, 'hir> {\n+struct ApplicabilityResolver<'a, 'hir> {\n     cx: &'a LateContext<'hir>,\n-    /// This is the index of hightest `Applicability` for\n-    /// `clippy_utils::paths::APPLICABILITY_VALUES`\n+    /// This is the index of hightest `Applicability` for `paths::APPLICABILITY_VALUES`\n     applicability_index: Option<usize>,\n }\n \n-impl<'a, 'hir> ApplicabilityVisitor<'a, 'hir> {\n+impl<'a, 'hir> ApplicabilityResolver<'a, 'hir> {\n     fn new(cx: &'a LateContext<'hir>) -> Self {\n         Self {\n             cx,\n@@ -537,105 +454,126 @@ impl<'a, 'hir> ApplicabilityVisitor<'a, 'hir> {\n     }\n }\n \n-impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityVisitor<'a, 'hir> {\n+impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n     type Map = Map<'hir>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n         intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path<'_>, _id: hir::HirId) {\n+    fn visit_path(&mut self, path: &'hir hir::Path<'hir>, _id: hir::HirId) {\n         for (index, enum_value) in paths::APPLICABILITY_VALUES.iter().enumerate() {\n             if match_path(path, enum_value) {\n                 self.add_new_index(index);\n-                break;\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+\n+        if_chain! {\n+            if match_type(self.cx, expr_ty, &paths::APPLICABILITY);\n+            if let Some(local) = get_parent_local(self.cx, expr);\n+            if let Some(local_init) = local.init;\n+            then {\n+                intravisit::walk_expr(self, local_init);\n             }\n+        };\n+\n+        // TODO xFrednet 2021-03-01: support function arguments?\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// This returns the parent local node if the expression is a reference to\n+fn get_parent_local(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<&'hir hir::Local<'hir>> {\n+    if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind {\n+        if let hir::def::Res::Local(local_hir) = path.res {\n+            return get_parent_local_hir_id(cx, local_hir);\n         }\n     }\n+\n+    None\n+}\n+\n+fn get_parent_local_hir_id(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n+    let map = cx.tcx.hir();\n+\n+    match map.find(map.get_parent_node(hir_id)) {\n+        Some(hir::Node::Local(local)) => Some(local),\n+        Some(hir::Node::Pat(pattern)) => get_parent_local_hir_id(cx, pattern.hir_id),\n+        _ => None,\n+    }\n }\n \n /// This visitor finds the highest applicability value in the visited expressions\n-struct EmissionClosureVisitor<'a, 'hir> {\n+struct IsMultiSpanScanner<'a, 'hir> {\n     cx: &'a LateContext<'hir>,\n-    /// This is the index of hightest `Applicability` for\n-    /// `clippy_utils::paths::APPLICABILITY_VALUES`\n-    applicability_index: Option<usize>,\n     suggestion_count: usize,\n }\n \n-impl<'a, 'hir> EmissionClosureVisitor<'a, 'hir> {\n+impl<'a, 'hir> IsMultiSpanScanner<'a, 'hir> {\n     fn new(cx: &'a LateContext<'hir>) -> Self {\n         Self {\n             cx,\n-            applicability_index: None,\n             suggestion_count: 0,\n         }\n     }\n \n-    fn add_new_index(&mut self, new_index: usize) {\n-        self.applicability_index = self\n-            .applicability_index\n-            .map_or(new_index, |old_index| old_index.min(new_index))\n-            .into();\n+    /// Add a new single expression suggestion to the counter\n+    fn add_singe_span_suggestion(&mut self) {\n+        self.suggestion_count += 1;\n     }\n \n-    fn found_multi_span(&self) -> bool {\n-        self.suggestion_count > 1\n+    /// Signals that a suggestion with possible multiple spans was found\n+    fn add_multi_part_suggestion(&mut self) {\n+        self.suggestion_count += 2;\n     }\n \n-    fn complete(self) -> Option<String> {\n-        self.applicability_index\n-            .map(|index| paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX].to_string())\n+    /// Checks if the suggestions include multiple spanns\n+    fn is_multi_part(&self) -> bool {\n+        self.suggestion_count > 1\n     }\n }\n \n-impl<'a, 'hir> intravisit::Visitor<'hir> for EmissionClosureVisitor<'a, 'hir> {\n+impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n     type Map = Map<'hir>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n         intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path<'_>, _id: hir::HirId) {\n-        for (index, enum_value) in paths::APPLICABILITY_VALUES.iter().enumerate() {\n-            if match_path(path, enum_value) {\n-                self.add_new_index(index);\n-                break;\n-            }\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        // Early return if the lint is already multi span\n+        if self.is_multi_part() {\n+            return;\n         }\n-    }\n \n-    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n         match &expr.kind {\n             ExprKind::Call(fn_expr, _args) => {\n                 let found_function = SUGGESTION_FUNCTIONS\n                     .iter()\n                     .any(|func_path| match_function_call(self.cx, fn_expr, func_path).is_some());\n                 if found_function {\n                     // These functions are all multi part suggestions\n-                    self.suggestion_count += 2;\n+                    self.add_singe_span_suggestion()\n                 }\n             },\n             ExprKind::MethodCall(path, _path_span, arg, _arg_span) => {\n                 let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n                 if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n                     let called_method = path.ident.name.as_str().to_string();\n-                    let found_suggestion =\n-                        SUGGESTION_DIAGNOSTIC_BUILDER_METHODS\n-                            .iter()\n-                            .find_map(|(method_name, is_multi_part)| {\n-                                if *method_name == called_method {\n-                                    Some(*is_multi_part)\n-                                } else {\n-                                    None\n-                                }\n-                            });\n-                    if let Some(multi_part) = found_suggestion {\n-                        if multi_part {\n-                            // two is enough to have it marked as a multipart suggestion\n-                            self.suggestion_count += 2;\n-                        } else {\n-                            self.suggestion_count += 1;\n+                    for (method_name, is_multi_part) in &SUGGESTION_DIAGNOSTIC_BUILDER_METHODS {\n+                        if *method_name == called_method {\n+                            if *is_multi_part {\n+                                self.add_multi_part_suggestion();\n+                            } else {\n+                                self.add_singe_span_suggestion();\n+                            }\n+                            break;\n                         }\n                     }\n                 }"}, {"sha": "507752a782cf3eabe355d2fe5b0911cc5e7c0856", "filename": "metadata_collection.json", "status": "added", "additions": 5698, "deletions": 0, "changes": 5698, "blob_url": "https://github.com/rust-lang/rust/blob/2ce5e368d84887a5a2cee669b467160d4ad7b933/metadata_collection.json", "raw_url": "https://github.com/rust-lang/rust/raw/2ce5e368d84887a5a2cee669b467160d4ad7b933/metadata_collection.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/metadata_collection.json?ref=2ce5e368d84887a5a2cee669b467160d4ad7b933"}]}