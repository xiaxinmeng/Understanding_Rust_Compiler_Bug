{"sha": "40079ac42df61958ce6b719df08f08b9799c1be4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMDc5YWM0MmRmNjE5NThjZTZiNzE5ZGYwOGYwOGI5Nzk5YzFiZTQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-29T13:56:24Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-29T13:56:24Z"}, "message": "Take advantage of impl Iterator in (transitive/elaborate)_bounds", "tree": {"sha": "fe5d9fac53930f13f3d7e6c0013d3e50fdab186e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe5d9fac53930f13f3d7e6c0013d3e50fdab186e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40079ac42df61958ce6b719df08f08b9799c1be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40079ac42df61958ce6b719df08f08b9799c1be4", "html_url": "https://github.com/rust-lang/rust/commit/40079ac42df61958ce6b719df08f08b9799c1be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40079ac42df61958ce6b719df08f08b9799c1be4/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e88b7363b7858960ccfd87326ece9d00bf4d973", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e88b7363b7858960ccfd87326ece9d00bf4d973", "html_url": "https://github.com/rust-lang/rust/commit/4e88b7363b7858960ccfd87326ece9d00bf4d973"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "940cf736012ec0c0e2a9bde0ffdce2c34b5a0270", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40079ac42df61958ce6b719df08f08b9799c1be4/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40079ac42df61958ce6b719df08f08b9799c1be4/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=40079ac42df61958ce6b719df08f08b9799c1be4", "patch": "@@ -103,11 +103,10 @@ pub fn elaborate_trait_ref<'cx, 'gcx, 'tcx>(\n \n pub fn elaborate_trait_refs<'cx, 'gcx, 'tcx>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    trait_refs: &[ty::PolyTraitRef<'tcx>])\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n     -> Elaborator<'cx, 'gcx, 'tcx>\n {\n-    let predicates = trait_refs.iter()\n-                               .map(|trait_ref| trait_ref.to_predicate())\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate())\n                                .collect();\n     elaborate_predicates(tcx, predicates)\n }\n@@ -271,7 +270,7 @@ pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n }\n \n pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-                                          bounds: &[ty::PolyTraitRef<'tcx>])\n+                                          bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n                                           -> Supertraits<'cx, 'gcx, 'tcx>\n {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()"}, {"sha": "7ddc56974d816157abbf594c8c15c24f7d52765e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40079ac42df61958ce6b719df08f08b9799c1be4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40079ac42df61958ce6b719df08f08b9799c1be4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=40079ac42df61958ce6b719df08f08b9799c1be4", "patch": "@@ -1112,12 +1112,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     {\n         let tcx = self.tcx();\n \n-        let bounds: Vec<_> = self.get_type_parameter_bounds(span, ty_param_def_id)\n-            .predicates.into_iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()).collect();\n+        let bounds = self.get_type_parameter_bounds(span, ty_param_def_id)\n+            .predicates.into_iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref());\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n-        let suitable_bounds = traits::transitive_bounds(tcx, &bounds)\n+        let suitable_bounds = traits::transitive_bounds(tcx, bounds)\n             .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n         let param_node_id = tcx.hir.as_local_node_id(ty_param_def_id).unwrap();"}, {"sha": "2202c1d78476b81b95e526238591972e7b2a5a68", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40079ac42df61958ce6b719df08f08b9799c1be4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40079ac42df61958ce6b719df08f08b9799c1be4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=40079ac42df61958ce6b719df08f08b9799c1be4", "patch": "@@ -31,6 +31,7 @@ use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n use syntax_pos::{Span, symbol::Symbol};\n+use std::iter;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -627,7 +628,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n-        self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n+        self.elaborate_bounds(iter::once(trait_ref), |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n@@ -645,7 +646,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n-        let bounds: Vec<_> = self.param_env\n+        let bounds = self.param_env\n             .caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n@@ -667,10 +668,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     ty::Predicate::TypeOutlives(..) |\n                     ty::Predicate::ConstEvaluatable(..) => None,\n                 }\n-            })\n-            .collect();\n+            });\n \n-        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item| {\n+        self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n@@ -693,15 +693,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn elaborate_bounds<F>(&mut self, bounds: &[ty::PolyTraitRef<'tcx>], mut mk_cand: F)\n+    fn elaborate_bounds<F>(&mut self,\n+                           bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+                           mut mk_cand: F)\n         where F: for<'b> FnMut(&mut ProbeContext<'b, 'gcx, 'tcx>,\n                                ty::PolyTraitRef<'tcx>,\n                                ty::AssociatedItem)\n     {\n-        debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n-\n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n+            debug!(\"elaborate_bounds(bound_trait_ref={:?})\", bound_trait_ref);\n             for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 if !self.has_applicable_self(&item) {\n                     self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));"}]}