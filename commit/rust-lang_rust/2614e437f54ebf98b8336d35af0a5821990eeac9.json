{"sha": "2614e437f54ebf98b8336d35af0a5821990eeac9", "node_id": "C_kwDOAAsO6NoAKDI2MTRlNDM3ZjU0ZWJmOThiODMzNmQzNWFmMGE1ODIxOTkwZWVhYzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-26T10:35:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-26T10:35:25Z"}, "message": "Auto merge of #99753 - Dylan-DPC:rollup-k046940, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #99618 (handle consts with param/infer in `const_eval_resolve` better)\n - #99666 (Restore `Opaque` behavior to coherence check)\n - #99692 (interpret, ptr_offset_from: refactor and test too-far-apart check)\n - #99739 (Remove erroneous E0133 code from an error message.)\n - #99748 (Use full type name instead of just saying `impl Trait` in \"captures lifetime\" error)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "03ae7bcb2165dcc6cbfc20ef65f25f94a6e58bcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03ae7bcb2165dcc6cbfc20ef65f25f94a6e58bcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2614e437f54ebf98b8336d35af0a5821990eeac9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2614e437f54ebf98b8336d35af0a5821990eeac9", "html_url": "https://github.com/rust-lang/rust/commit/2614e437f54ebf98b8336d35af0a5821990eeac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2614e437f54ebf98b8336d35af0a5821990eeac9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b", "html_url": "https://github.com/rust-lang/rust/commit/96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b"}, {"sha": "ad32667bc8bb6ca96e3591ccc1f4daef4bf67028", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad32667bc8bb6ca96e3591ccc1f4daef4bf67028", "html_url": "https://github.com/rust-lang/rust/commit/ad32667bc8bb6ca96e3591ccc1f4daef4bf67028"}], "stats": {"total": 519, "additions": 349, "deletions": 170}, "files": [{"sha": "176090c3b7a14e9dd78caccfad7a10bca07c4d66", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -78,6 +78,8 @@ pub(crate) enum RegionErrorKind<'tcx> {\n         span: Span,\n         /// The hidden type.\n         hidden_ty: Ty<'tcx>,\n+        /// The opaque type.\n+        key: ty::OpaqueTypeKey<'tcx>,\n         /// The unexpected region.\n         member_region: ty::Region<'tcx>,\n     },\n@@ -205,14 +207,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                RegionErrorKind::UnexpectedHiddenRegion { span, hidden_ty, member_region } => {\n+                RegionErrorKind::UnexpectedHiddenRegion { span, hidden_ty, key, member_region } => {\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n+                    let named_key = self.regioncx.name_regions(self.infcx.tcx, key);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n                     self.buffer_error(unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n                         span,\n                         named_ty,\n                         named_region,\n+                        named_key,\n                     ));\n                 }\n "}, {"sha": "43253a2aab00cfdd52515ff260643c096acda344", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -38,6 +38,8 @@ pub(crate) struct NllMemberConstraint<'tcx> {\n     /// The hidden type in which `R0` appears. (Used in error reporting.)\n     pub(crate) hidden_ty: Ty<'tcx>,\n \n+    pub(crate) key: ty::OpaqueTypeKey<'tcx>,\n+\n     /// The region `R0`.\n     pub(crate) member_region_vid: ty::RegionVid,\n \n@@ -90,6 +92,7 @@ impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n             member_region_vid,\n             definition_span: m_c.definition_span,\n             hidden_ty: m_c.hidden_ty,\n+            key: m_c.key,\n             start_index,\n             end_index,\n         });"}, {"sha": "2894c6d29ec43978ec1e5fac7ee3de67e8e1cb56", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1763,6 +1763,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer.push(RegionErrorKind::UnexpectedHiddenRegion {\n                 span: m_c.definition_span,\n                 hidden_ty: m_c.hidden_ty,\n+                key: m_c.key,\n                 member_region,\n             });\n         }"}, {"sha": "d6712b6a4799c9cc1fbe6e885b7e86461f89c3b8", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // after producing an error for each of them.\n         let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n             self.tcx,\n-            def_id,\n+            opaque_type_key,\n             map,\n             instantiated_ty.ty,\n             instantiated_ty.span,\n@@ -429,7 +429,7 @@ fn check_opaque_type_parameter_valid(\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    opaque_type_def_id: LocalDefId,\n+    key: ty::OpaqueTypeKey<'tcx>,\n     map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n     map_missing_regions_to_empty: bool,\n \n@@ -443,14 +443,14 @@ struct ReverseMapper<'tcx> {\n impl<'tcx> ReverseMapper<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        opaque_type_def_id: LocalDefId,\n+        key: ty::OpaqueTypeKey<'tcx>,\n         map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n         Self {\n             tcx,\n-            opaque_type_def_id,\n+            key,\n             map,\n             map_missing_regions_to_empty: false,\n             hidden_ty: Some(hidden_ty),\n@@ -504,7 +504,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             }\n         }\n \n-        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n+        let generics = self.tcx().generics_of(self.key.def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n@@ -513,9 +513,10 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n                         self.tcx,\n-                        self.tcx.def_span(self.opaque_type_def_id),\n+                        self.tcx.def_span(self.key.def_id),\n                         hidden_ty,\n                         r,\n+                        self.key,\n                     )\n                     .emit();\n                 }"}, {"sha": "08209eb793216543453e86a23a3a15d08d3bec80", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -7,7 +7,7 @@ use std::convert::TryFrom;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n-    interpret::{ConstValue, GlobalId, InterpResult, Scalar},\n+    interpret::{ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar},\n     BinOp,\n };\n use rustc_middle::ty;\n@@ -328,15 +328,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             // We managed to find a valid allocation for one pointer, but not the other.\n                             // That means they are definitely not pointing to the same allocation.\n                             throw_ub_format!(\n-                                \"{} called on pointers into different allocations\",\n+                                \"`{}` called on pointers into different allocations\",\n                                 intrinsic_name\n                             );\n                         }\n                         (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n                             // Found allocation for both. They must be into the same allocation.\n                             if a_alloc_id != b_alloc_id {\n                                 throw_ub_format!(\n-                                    \"{} called on pointers into different allocations\",\n+                                    \"`{}` called on pointers into different allocations\",\n                                     intrinsic_name\n                                 );\n                             }\n@@ -346,47 +346,71 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     };\n \n                 // Compute distance.\n-                let distance = {\n-                    // The subtraction is always done in `isize` to enforce\n-                    // the \"no more than `isize::MAX` apart\" requirement.\n-                    let a_offset = ImmTy::from_uint(a_offset, isize_layout);\n-                    let b_offset = ImmTy::from_uint(b_offset, isize_layout);\n-                    let (val, overflowed, _ty) =\n-                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n+                let dist = {\n+                    // Addresses are unsigned, so this is a `usize` computation. We have to do the\n+                    // overflow check separately anyway.\n+                    let (val, overflowed, _ty) = {\n+                        let a_offset = ImmTy::from_uint(a_offset, usize_layout);\n+                        let b_offset = ImmTy::from_uint(b_offset, usize_layout);\n+                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?\n+                    };\n                     if overflowed {\n-                        throw_ub_format!(\"pointers were too far apart for {}\", intrinsic_name);\n+                        // a < b\n+                        if intrinsic_name == sym::ptr_offset_from_unsigned {\n+                            throw_ub_format!(\n+                                \"`{}` called when first pointer has smaller offset than second: {} < {}\",\n+                                intrinsic_name,\n+                                a_offset,\n+                                b_offset,\n+                            );\n+                        }\n+                        // The signed form of the intrinsic allows this. If we interpret the\n+                        // difference as isize, we'll get the proper signed difference. If that\n+                        // seems *positive*, they were more than isize::MAX apart.\n+                        let dist = val.to_machine_isize(self)?;\n+                        if dist >= 0 {\n+                            throw_ub_format!(\n+                                \"`{}` called when first pointer is too far before second\",\n+                                intrinsic_name\n+                            );\n+                        }\n+                        dist\n+                    } else {\n+                        // b >= a\n+                        let dist = val.to_machine_isize(self)?;\n+                        // If converting to isize produced a *negative* result, we had an overflow\n+                        // because they were more than isize::MAX apart.\n+                        if dist < 0 {\n+                            throw_ub_format!(\n+                                \"`{}` called when first pointer is too far ahead of second\",\n+                                intrinsic_name\n+                            );\n+                        }\n+                        dist\n                     }\n-                    val.to_machine_isize(self)?\n                 };\n \n                 // Check that the range between them is dereferenceable (\"in-bounds or one past the\n                 // end of the same allocation\"). This is like the check in ptr_offset_inbounds.\n-                let min_ptr = if distance >= 0 { b } else { a };\n+                let min_ptr = if dist >= 0 { b } else { a };\n                 self.check_ptr_access_align(\n                     min_ptr,\n-                    Size::from_bytes(distance.unsigned_abs()),\n+                    Size::from_bytes(dist.unsigned_abs()),\n                     Align::ONE,\n                     CheckInAllocMsg::OffsetFromTest,\n                 )?;\n \n-                if intrinsic_name == sym::ptr_offset_from_unsigned && distance < 0 {\n-                    throw_ub_format!(\n-                        \"{} called when first pointer has smaller offset than second: {} < {}\",\n-                        intrinsic_name,\n-                        a_offset,\n-                        b_offset,\n-                    );\n-                }\n-\n                 // Perform division by size to compute return value.\n                 let ret_layout = if intrinsic_name == sym::ptr_offset_from_unsigned {\n+                    assert!(0 <= dist && dist <= self.machine_isize_max());\n                     usize_layout\n                 } else {\n+                    assert!(self.machine_isize_min() <= dist && dist <= self.machine_isize_max());\n                     isize_layout\n                 };\n                 let pointee_layout = self.layout_of(substs.type_at(0))?;\n                 // If ret_layout is unsigned, we checked that so is the distance, so we are good.\n-                let val = ImmTy::from_int(distance, ret_layout);\n+                let val = ImmTy::from_int(dist, ret_layout);\n                 let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n                 self.exact_div(&val, &size, dest)?;\n             }"}, {"sha": "be764cfe83bc3eceea37cc88803a5709423a524f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -237,12 +237,14 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n+    opaque_ty: ty::OpaqueTypeKey<'tcx>,\n ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+    let opaque_ty = tcx.mk_opaque(opaque_ty.def_id.to_def_id(), opaque_ty.substs);\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,\n         E0700,\n-        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n+        \"hidden type for `{opaque_ty}` captures lifetime that does not appear in bounds\",\n     );\n \n     // Explain the region we are capturing."}, {"sha": "0ac6e8c541b5511e9c81cad62e10ae5456f5f519", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::traits::select;\n-use rustc_middle::ty::abstract_const::AbstractConst;\n+use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::relate::RelateResult;\n@@ -966,14 +966,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn member_constraint(\n         &self,\n-        opaque_type_def_id: LocalDefId,\n+        key: ty::OpaqueTypeKey<'tcx>,\n         definition_span: Span,\n         hidden_ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n         in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n         self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n-            opaque_type_def_id,\n+            key,\n             definition_span,\n             hidden_ty,\n             region,\n@@ -1675,7 +1675,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_resolve(\n         &self,\n-        param_env: ty::ParamEnv<'tcx>,\n+        mut param_env: ty::ParamEnv<'tcx>,\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToValTreeResult<'tcx> {\n@@ -1686,10 +1686,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // variables\n         if substs.has_infer_types_or_consts() {\n             let ac = AbstractConst::new(self.tcx, unevaluated.shrink());\n-            if let Ok(None) = ac {\n-                substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n-            } else {\n-                return Err(ErrorHandled::TooGeneric);\n+            match ac {\n+                Ok(None) => {\n+                    substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n+                    param_env = self.tcx.param_env(unevaluated.def.did);\n+                }\n+                Ok(Some(ct)) => {\n+                    if ct.unify_failure_kind(self.tcx) == FailureKind::Concrete {\n+                        substs = replace_param_and_infer_substs_with_placeholder(self.tcx, substs);\n+                    } else {\n+                        return Err(ErrorHandled::TooGeneric);\n+                    }\n+                }\n+                Err(guar) => return Err(ErrorHandled::Reported(guar)),\n             }\n         }\n \n@@ -2000,3 +2009,43 @@ impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n         )\n     }\n }\n+\n+/// Replaces substs that reference param or infer variables with suitable\n+/// placeholders. This function is meant to remove these param and infer\n+/// substs when they're not actually needed to evaluate a constant.\n+fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+) -> SubstsRef<'tcx> {\n+    tcx.mk_substs(substs.iter().enumerate().map(|(idx, arg)| {\n+        match arg.unpack() {\n+            GenericArgKind::Type(_)\n+                if arg.has_param_types_or_consts() || arg.has_infer_types_or_consts() =>\n+            {\n+                tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                    universe: ty::UniverseIndex::ROOT,\n+                    name: ty::BoundVar::from_usize(idx),\n+                }))\n+                .into()\n+            }\n+            GenericArgKind::Const(ct)\n+                if ct.has_infer_types_or_consts() || ct.has_param_types_or_consts() =>\n+            {\n+                let ty = ct.ty();\n+                // If the type references param or infer, replace that too...\n+                if ty.has_param_types_or_consts() || ty.has_infer_types_or_consts() {\n+                    bug!(\"const `{ct}`'s type should not reference params or types\");\n+                }\n+                tcx.mk_const(ty::ConstS {\n+                    ty,\n+                    kind: ty::ConstKind::Placeholder(ty::PlaceholderConst {\n+                        universe: ty::UniverseIndex::ROOT,\n+                        name: ty::BoundConst { ty, var: ty::BoundVar::from_usize(idx) },\n+                    }),\n+                })\n+                .into()\n+            }\n+            _ => arg,\n+        }\n+    }))\n+}"}, {"sha": "a6c5ed579c73656f6a157136bbb7da86f4920504", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -394,15 +394,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-            op: |r| {\n-                self.member_constraint(\n-                    opaque_type_key.def_id,\n-                    span,\n-                    concrete_ty,\n-                    r,\n-                    &choice_regions,\n-                )\n-            },\n+            op: |r| self.member_constraint(opaque_type_key, span, concrete_ty, r, &choice_regions),\n         });\n     }\n "}, {"sha": "0d4472a1cfd9c11944821f2992dca524e9458c39", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify as ut;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::infer::unify_key::{RegionVidKey, UnifiedRegion};\n use rustc_middle::ty::ReStatic;\n@@ -533,7 +532,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n \n     pub fn member_constraint(\n         &mut self,\n-        opaque_type_def_id: LocalDefId,\n+        key: ty::OpaqueTypeKey<'tcx>,\n         definition_span: Span,\n         hidden_ty: Ty<'tcx>,\n         member_region: ty::Region<'tcx>,\n@@ -546,7 +545,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         }\n \n         self.data.member_constraints.push(MemberConstraint {\n-            opaque_type_def_id,\n+            key,\n             definition_span,\n             hidden_ty,\n             member_region,"}, {"sha": "38868c210495374dacfdec9431410001cad04000", "filename": "compiler/rustc_middle/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -2,9 +2,8 @@ pub mod canonical;\n pub mod unify_key;\n \n use crate::ty::Region;\n-use crate::ty::Ty;\n+use crate::ty::{OpaqueTypeKey, Ty};\n use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_span::Span;\n \n /// Requires that `region` must be equal to one of the regions in `choice_regions`.\n@@ -15,8 +14,9 @@ use rustc_span::Span;\n /// ```\n #[derive(Debug, Clone, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct MemberConstraint<'tcx> {\n-    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n-    pub opaque_type_def_id: LocalDefId,\n+    /// The `DefId` and substs of the opaque type causing this constraint.\n+    /// Used for error reporting.\n+    pub key: OpaqueTypeKey<'tcx>,\n \n     /// The span where the hidden type was instantiated.\n     pub definition_span: Span,"}, {"sha": "3b7ba3f9a67ac97096d1dd166aff9992babc1aee", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -42,7 +42,7 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             \"that does not derive `Copy`\"\n         };\n         let message = format!(\n-            \"`{}` can't be derived on this `#[repr(packed)]` struct {} (error E0133)\",\n+            \"`{}` can't be derived on this `#[repr(packed)]` struct {}\",\n             tcx.item_name(tcx.trait_id_of_impl(def_id.to_def_id()).expect(\"derived trait name\")),\n             extra\n         );"}, {"sha": "fa94aa19abda594386bf61b758c515621a5a3ec6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -703,13 +703,42 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n                 }\n             }\n             ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n-            ty::Opaque(..) | ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n+            ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n                 self.tcx.sess.delay_span_bug(\n                     DUMMY_SP,\n                     format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n                 );\n                 ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n             }\n+            ty::Opaque(..) => {\n+                // This merits some explanation.\n+                // Normally, opaque types are not involved when performing\n+                // coherence checking, since it is illegal to directly\n+                // implement a trait on an opaque type. However, we might\n+                // end up looking at an opaque type during coherence checking\n+                // if an opaque type gets used within another type (e.g. as\n+                // the type of a field) when checking for auto trait or `Sized`\n+                // impls. This requires us to decide whether or not an opaque\n+                // type should be considered 'local' or not.\n+                //\n+                // We choose to treat all opaque types as non-local, even\n+                // those that appear within the same crate. This seems\n+                // somewhat surprising at first, but makes sense when\n+                // you consider that opaque types are supposed to hide\n+                // the underlying type *within the same crate*. When an\n+                // opaque type is used from outside the module\n+                // where it is declared, it should be impossible to observe\n+                // anything about it other than the traits that it implements.\n+                //\n+                // The alternative would be to look at the underlying type\n+                // to determine whether or not the opaque type itself should\n+                // be considered local. However, this could make it a breaking change\n+                // to switch the underlying ('defining') type from a local type\n+                // to a remote type. This would violate the rule that opaque\n+                // types should be completely opaque apart from the traits\n+                // that they implement, so we don't use this behavior.\n+                self.found_non_local_ty(ty)\n+            }\n         };\n         // A bit of a hack, the `OrphanChecker` is only used to visit a `TraitRef`, so\n         // the first type we visit is always the self type."}, {"sha": "254bc4ab66386bbf345a630e5ec306741b6701e5", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -185,21 +185,12 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n         }\n         let concrete = infcx.const_eval_resolve(param_env, uv.expand(), Some(span));\n         match concrete {\n-            Err(ErrorHandled::TooGeneric) => Err(if uv.has_infer_types_or_consts() {\n-                NotConstEvaluatable::MentionsInfer\n-            } else if uv.has_param_types_or_consts() {\n-                infcx\n-                    .tcx\n-                    .sess\n-                    .delay_span_bug(span, &format!(\"unexpected `TooGeneric` for {:?}\", uv));\n-                NotConstEvaluatable::MentionsParam\n-            } else {\n-                let guar = infcx.tcx.sess.delay_span_bug(\n+            Err(ErrorHandled::TooGeneric) => {\n+                Err(NotConstEvaluatable::Error(infcx.tcx.sess.delay_span_bug(\n                     span,\n                     format!(\"Missing value for constant, but no error reported?\"),\n-                );\n-                NotConstEvaluatable::Error(guar)\n-            }),\n+                )))\n+            }\n             Err(ErrorHandled::Linted) => {\n                 let reported = infcx\n                     .tcx"}, {"sha": "e0655d68d2cfa7922d2504cc830c4194d42fa5c3", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -730,7 +730,7 @@ impl<T: ?Sized> *const T {\n     /// }\n     ///\n     /// // This would be incorrect, as the pointers are not correctly ordered:\n-    /// // ptr1.offset_from(ptr2)\n+    /// // ptr1.sub_ptr(ptr2)\n     /// ```\n     #[unstable(feature = \"ptr_sub_ptr\", issue = \"95892\")]\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]"}, {"sha": "3128b4df4e2d1248874d54199e1ab66f109d9095", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -13,7 +13,7 @@ LL | | }\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Trait<'a>` captures lifetime that does not appear in bounds\n   --> $DIR/ret-impl-trait-one.rs:16:80\n    |\n LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {"}, {"sha": "10a0a568849bff343f500fccf4046f07cf9a4092", "filename": "src/test/ui/coherence/issue-99663-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fcoherence%2Fissue-99663-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fcoherence%2Fissue-99663-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-99663-2.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+struct Outer<T: ?Sized> {\n+    i: InnerSend<T>,\n+}\n+\n+type InnerSend<T: ?Sized> = impl Send;\n+\n+fn constrain<T: ?Sized>() -> InnerSend<T> {\n+    ()\n+}\n+\n+trait SendMustNotImplDrop {}\n+\n+#[allow(drop_bounds)]\n+impl<T: ?Sized + Send + Drop> SendMustNotImplDrop for T {}\n+\n+impl<T: ?Sized> SendMustNotImplDrop for Outer<T> {}\n+\n+fn main() {}"}, {"sha": "a2d4d398ce1d58c59485644cb747f9d2d9f08330", "filename": "src/test/ui/coherence/issue-99663.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fcoherence%2Fissue-99663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fcoherence%2Fissue-99663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-99663.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+struct Send<T> {\n+    i: InnerSend<T>,\n+}\n+\n+type InnerSend<T> = impl Sized;\n+\n+fn constrain<T>() -> InnerSend<T> {\n+    ()\n+}\n+\n+trait SendMustNotImplDrop {}\n+\n+#[allow(drop_bounds)]\n+impl<T: Drop> SendMustNotImplDrop for T {}\n+\n+impl<T> SendMustNotImplDrop for Send<T> {}\n+\n+fn main() {}"}, {"sha": "5874625adff61e1ca35d95416fae6af120f30b81", "filename": "src/test/ui/const-generics/generic_const_exprs/const_eval_resolve_canonical.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n \n@@ -21,11 +23,6 @@ where\n }\n \n fn main() {\n-    // FIXME(generic_const_exprs): We can't correctly infer `T` which requires\n-    // evaluating `{ N + 1 }` which has substs containing an inference var\n     let mut _q = Default::default();\n-    //~^ ERROR type annotations needed\n-\n     _q = foo::<_, 2>(_q);\n-    //~^ ERROR type annotations needed\n }"}, {"sha": "9e8328d37017ea0ee92fd90ed4de5f2064761ecb", "filename": "src/test/ui/const-generics/generic_const_exprs/const_eval_resolve_canonical.stderr", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.stderr?ref=96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b", "patch": "@@ -1,38 +0,0 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/const_eval_resolve_canonical.rs:26:9\n-   |\n-LL |     let mut _q = Default::default();\n-   |         ^^^^^^\n-   |\n-help: consider giving `_q` an explicit type\n-   |\n-LL |     let mut _q: _ = Default::default();\n-   |               +++\n-\n-error[E0283]: type annotations needed\n-  --> $DIR/const_eval_resolve_canonical.rs:29:10\n-   |\n-LL |     _q = foo::<_, 2>(_q);\n-   |          ^^^^^^^^^^^ cannot infer the value of the constant `{ N + 1 }`\n-   |\n-note: multiple `impl`s satisfying `(): Foo<{ N + 1 }>` found\n-  --> $DIR/const_eval_resolve_canonical.rs:8:1\n-   |\n-LL | impl Foo<0> for () {\n-   | ^^^^^^^^^^^^^^^^^^\n-...\n-LL | impl Foo<3> for () {\n-   | ^^^^^^^^^^^^^^^^^^\n-note: required by a bound in `foo`\n-  --> $DIR/const_eval_resolve_canonical.rs:18:9\n-   |\n-LL | fn foo<T, const N: usize>(_: T) -> <() as Foo<{ N + 1 }>>::Assoc\n-   |    --- required by a bound in this\n-LL | where\n-LL |     (): Foo<{ N + 1 }>,\n-   |         ^^^^^^^^^^^^^^ required by this bound in `foo`\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0282, E0283.\n-For more information about an error, try `rustc --explain E0282`."}, {"sha": "f3bf9c496da7b2aa12aca64b2d53dd8ec7aa7349", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -222,7 +222,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -241,7 +241,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "5f2821a91937baa712e7ed4d81449b244cce8b5e", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -222,7 +222,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -241,7 +241,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "1f29a690550bc2368f7125daf94caddc868d02dd", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -2,6 +2,7 @@\n #![feature(core_intrinsics)]\n \n use std::intrinsics::{ptr_offset_from, ptr_offset_from_unsigned};\n+use std::ptr;\n \n #[repr(C)]\n struct Struct {\n@@ -75,9 +76,21 @@ pub const DIFFERENT_ALLOC_UNSIGNED: usize = {\n     let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n-    let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n+    unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) } //~ERROR evaluation of constant value failed\n     //~| pointers into different allocations\n-    offset as usize\n+};\n+\n+pub const TOO_FAR_APART1: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_add(isize::MAX as usize + 42);\n+    unsafe { ptr_offset_from(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n+    //~| too far ahead\n+};\n+pub const TOO_FAR_APART2: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_add(isize::MAX as usize + 42);\n+    unsafe { ptr_offset_from(ptr1, ptr2) } //~ERROR evaluation of constant value failed\n+    //~| too far before\n };\n \n const WRONG_ORDER_UNSIGNED: usize = {\n@@ -86,5 +99,27 @@ const WRONG_ORDER_UNSIGNED: usize = {\n     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) } //~ERROR evaluation of constant value failed\n     //~| first pointer has smaller offset than second: 0 < 8\n };\n+pub const TOO_FAR_APART_UNSIGNED: usize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_add(isize::MAX as usize + 42);\n+    // This would fit into a `usize` but we still don't allow it.\n+    unsafe { ptr_offset_from_unsigned(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n+    //~| too far ahead\n+};\n+\n+// These do NOT complain that pointers are too far apart; they pass that check (to then fail the\n+// next one).\n+pub const OFFSET_VERY_FAR1: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_offset(isize::MAX);\n+    unsafe { ptr2.offset_from(ptr1) }\n+    //~^ inside\n+};\n+pub const OFFSET_VERY_FAR2: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_offset(isize::MAX);\n+    unsafe { ptr1.offset_from(ptr2.wrapping_offset(1)) }\n+    //~^ inside\n+};\n \n fn main() {}"}, {"sha": "62a087d94d3565894d4043cff00b66526097b54b", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,71 +1,117 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:17:27\n+  --> $DIR/offset_from_ub.rs:18:27\n    |\n LL |     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from called on pointers into different allocations\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from called on pointers into different allocations\n+   |                  `ptr_offset_from` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/offset_from_ub.rs:23:14\n+  ::: $DIR/offset_from_ub.rs:24:14\n    |\n LL |     unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n-   |              ----------------------------------- inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n+   |              ----------------------------------- inside `NOT_PTR` at $DIR/offset_from_ub.rs:24:14\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:30:14\n+  --> $DIR/offset_from_ub.rs:31:14\n    |\n LL |     unsafe { ptr_offset_from(field_ptr, base_ptr as *const u16) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ exact_div: 1_isize cannot be divided by 2_isize without remainder\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:36:14\n+  --> $DIR/offset_from_ub.rs:37:14\n    |\n LL |     unsafe { ptr_offset_from(ptr, ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:43:14\n+  --> $DIR/offset_from_ub.rs:44:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x8[noalloc] is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:52:14\n+  --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:61:14\n+  --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:69:14\n+  --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:78:27\n+  --> $DIR/offset_from_ub.rs:79:14\n    |\n-LL |     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called on pointers into different allocations\n+LL |     unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:86:14\n    |\n+LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called when first pointer is too far ahead of second\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:92:14\n+   |\n+LL |     unsafe { ptr_offset_from(ptr1, ptr2) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called when first pointer is too far before second\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:99:14\n+   |\n LL |     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called when first pointer has smaller offset than second: 0 < 8\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called when first pointer has smaller offset than second: 0 < 8\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:106:14\n+   |\n+LL |     unsafe { ptr_offset_from_unsigned(ptr2, ptr1) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called when first pointer is too far ahead of second\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/offset_from_ub.rs:115:14\n+   |\n+LL |     unsafe { ptr2.offset_from(ptr1) }\n+   |              ---------------------- inside `OFFSET_VERY_FAR1` at $DIR/offset_from_ub.rs:115:14\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/offset_from_ub.rs:121:14\n+   |\n+LL |     unsafe { ptr1.offset_from(ptr2.wrapping_offset(1)) }\n+   |              ----------------------------------------- inside `OFFSET_VERY_FAR2` at $DIR/offset_from_ub.rs:121:14\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "d3fe550c3e48f738d929c0c9b919a13c3bb31af9", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n   --> $DIR/deriving-with-repr-packed.rs:11:16\n    |\n LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n@@ -13,7 +13,7 @@ LL | #![deny(unaligned_references)]\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n   --> $DIR/deriving-with-repr-packed.rs:11:32\n    |\n LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n@@ -23,7 +23,7 @@ LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n   --> $DIR/deriving-with-repr-packed.rs:19:19\n    |\n LL | #[derive(Default, Hash)]\n@@ -33,7 +33,7 @@ LL | #[derive(Default, Hash)]\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n   --> $DIR/deriving-with-repr-packed.rs:39:10\n    |\n LL | #[derive(Debug, Default)]\n@@ -46,7 +46,7 @@ LL | #[derive(Debug, Default)]\n error: aborting due to 4 previous errors\n \n Future incompatibility report: Future breakage diagnostic:\n-error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+error: `Clone` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n   --> $DIR/deriving-with-repr-packed.rs:11:16\n    |\n LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n@@ -62,7 +62,7 @@ LL | #![deny(unaligned_references)]\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n Future breakage diagnostic:\n-error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters (error E0133)\n+error: `PartialEq` can't be derived on this `#[repr(packed)]` struct with type or const parameters\n   --> $DIR/deriving-with-repr-packed.rs:11:32\n    |\n LL | #[derive(Copy, Clone, Default, PartialEq, Eq)]\n@@ -78,7 +78,7 @@ LL | #![deny(unaligned_references)]\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n Future breakage diagnostic:\n-error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+error: `Hash` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n   --> $DIR/deriving-with-repr-packed.rs:19:19\n    |\n LL | #[derive(Default, Hash)]\n@@ -94,7 +94,7 @@ LL | #![deny(unaligned_references)]\n    = note: this error originates in the derive macro `Hash` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n Future breakage diagnostic:\n-error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy` (error E0133)\n+error: `Debug` can't be derived on this `#[repr(packed)]` struct that does not derive `Copy`\n   --> $DIR/deriving-with-repr-packed.rs:39:10\n    |\n LL | #[derive(Debug, Default)]"}, {"sha": "efc228de58be5d482c231114cc102698ea53366b", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Swap` captures lifetime that does not appear in bounds\n   --> $DIR/hidden-lifetimes.rs:29:5\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n@@ -11,7 +11,7 @@ help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Swap` captures lifetime that does not appear in bounds\n   --> $DIR/hidden-lifetimes.rs:46:5\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {"}, {"sha": "2a2be6b7429926c9604f9e102f439f3cffb6942a", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -20,7 +20,7 @@ fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n         let _: &'b i32 = *u.0;\n     }\n     u.0\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    //~^ ERROR hidden type for `E<'b, 'c>` captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "90875708094049b19c3d45e6aa547e81a8c418a1", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `E<'b, 'c>` captures lifetime that does not appear in bounds\n   --> $DIR/error-handling-2.rs:22:5\n    |\n LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {"}, {"sha": "c6eea5323fd80f521780625cf3092fef5fbda1e9", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -26,7 +26,7 @@ where\n     // 'a in ['d, 'e]\n     // ```\n     if condition() { a } else { b }\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    //~^ ERROR hidden type for `impl Trait<'d, 'e>` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "cb1dc0b7d50ae3cf7061270fb5eec23bf2c7fdc5", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Trait<'d, 'e>` captures lifetime that does not appear in bounds\n   --> $DIR/ordinary-bounds-unrelated.rs:28:33\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>"}, {"sha": "adcbca2a438b4132d12c5b2e31e11e6f983b2ce9", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -29,7 +29,7 @@ fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n     //\n     // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n     if condition() { a } else { b }\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    //~^ ERROR hidden type for `impl Trait<'a, 'b>` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "4388e6601a6cf3d5cb092f506555c89364395af6", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Trait<'a, 'b>` captures lifetime that does not appear in bounds\n   --> $DIR/ordinary-bounds-unsuited.rs:31:33\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>"}, {"sha": "16767abd72241be5988d25e8dc2593e51aa5aa5a", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Copy` captures lifetime that does not appear in bounds\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n@@ -11,7 +11,7 @@ help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Copy` captures lifetime that does not appear in bounds\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n@@ -96,7 +96,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      ~~~~~~~~~~~~\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Fn(&'a u32)` captures lifetime that does not appear in bounds\n   --> $DIR/must_outlive_least_region_or_bound.rs:38:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {"}, {"sha": "479b451855d5517fb2a7fe6edf8358d15130874c", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n LL | impl AnotherTrait for D<OpaqueType> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n    |\n-   = note: downstream crates may implement trait `std::fmt::Debug` for type `OpaqueType`\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n \n error: cannot implement trait on type alias impl trait\n   --> $DIR/negative-reasoning.rs:19:25"}, {"sha": "fe60c76ca1755049314923ecddb553e30b05c77b", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -15,7 +15,7 @@ fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n where 'x: 'y\n {\n     x\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n+    //~^ ERROR hidden type for `impl Trait<'y>` captures lifetime that does not appear in bounds [E0700]\n }\n \n fn main() { }"}, {"sha": "fdb2fe022b4d250d77cd044dda70677cfe347983", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Trait<'y>` captures lifetime that does not appear in bounds\n   --> $DIR/region-escape-via-bound.rs:17:5\n    |\n LL | fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>"}, {"sha": "b86815231550367968001756baaf66b79fafe9c3", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Iterator<Item = u32>` captures lifetime that does not appear in bounds\n   --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n@@ -11,7 +11,7 @@ help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Iterator<Item = u32>` captures lifetime that does not appear in bounds\n   --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n@@ -24,7 +24,7 @@ help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Iterator<Item = u32>` captures lifetime that does not appear in bounds\n   --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n@@ -37,7 +37,7 @@ help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Iterator<Item = u32>` captures lifetime that does not appear in bounds\n   --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {"}, {"sha": "260b9b59772ef789dce466859d8b913896e7ec65", "filename": "src/test/ui/nll/issue-73159-rpit-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Iterator<Item = u8>` captures lifetime that does not appear in bounds\n   --> $DIR/issue-73159-rpit-static.rs:8:9\n    |\n LL | impl<'a> Foo<'a> {"}, {"sha": "330c6fafa2d61a86eec9139b953d195909120a1c", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `Opaque(DefId(0:11 ~ impl_trait_captures[1afc]::foo::{opaque#0}), [ReStatic, T, ReEarlyBound(0, 'a)])` captures lifetime that does not appear in bounds\n   --> $DIR/impl-trait-captures.rs:11:5\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {"}, {"sha": "7e7d60d0ff90aef2027871ce6ede64c0200cbab6", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Clone` captures lifetime that does not appear in bounds\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }"}, {"sha": "30d2250c0c81df7df862e1a5cef0def48e0f6377", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Clone` captures lifetime that does not appear in bounds\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }"}, {"sha": "b641f5941dcef64708f90cc6cdc2843bf40489cf", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -17,7 +17,7 @@ where\n     G: Get<T>,\n {\n     move || {\n-        //~^ ERROR hidden type for `impl Trait` captures lifetime\n+        //~^ ERROR hidden type for `impl FnOnce()` captures lifetime\n         *dest = g.get();\n     }\n }"}, {"sha": "0d749f04bea770154c7c43b7b1b85e4de6a8cef3", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2614e437f54ebf98b8336d35af0a5821990eeac9/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=2614e437f54ebf98b8336d35af0a5821990eeac9", "patch": "@@ -6,7 +6,7 @@ LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |        |\n    |        help: consider introducing lifetime `'a` here: `'a,`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl FnOnce()` captures lifetime that does not appear in bounds\n   --> $DIR/missing-lifetimes-in-signature.rs:19:5\n    |\n LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()"}]}