{"sha": "e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZGE2YTcxYTZhMGI0NmRkMzYzMGZjODMyNmU2ZDU5MDZhMWZkZTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-24T02:10:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-26T20:12:20Z"}, "message": "std: Stabilize unit, bool, ty, tuple, arc, any\n\nThis commit applies stability attributes to the contents of these modules,\nsummarized here:\n\n* The `unit` and `bool` modules have become #[unstable] as they are purely meant\n  for documentation purposes and are candidates for removal.\n\n* The `ty` module has been deprecated, and the inner `Unsafe` type has been\n  renamed to `UnsafeCell` and moved to the `cell` module. The `marker1` field\n  has been removed as the compiler now always infers `UnsafeCell` to be\n  invariant. The `new` method i stable, but the `value` field, `get` and\n  `unwrap` methods are all unstable.\n\n* The `tuple` module has its name as stable, the naming of the `TupleN` traits\n  as stable while the methods are all #[unstable]. The other impls in the module\n  have appropriate stability for the corresponding trait.\n\n* The `arc` module has received the exact same treatment as the `rc` module\n  previously did.\n\n* The `any` module has its name as stable. The `Any` trait is also stable, with\n  a new private supertrait which now contains the `get_type_id` method. This is\n  to make the method a private implementation detail rather than a public-facing\n  detail.\n\n  The two extension traits in the module are marked #[unstable] as they will not\n  be necessary with DST. The `is` method is #[stable], the as_{mut,ref} methods\n  have been renamed to downcast_{mut,ref} and are #[unstable].\n\n  The extension trait `BoxAny` has been clarified as to why it is unstable as it\n  will not be necessary with DST.\n\nThis is a breaking change because the `marker1` field was removed from the\n`UnsafeCell` type. To deal with this change, you can simply delete the field and\nonly specify the value of the `data` field in static initializers.\n\n[breaking-change]", "tree": {"sha": "9ec196a49577039b0800125f2cef1f8afa925ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ec196a49577039b0800125f2cef1f8afa925ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "html_url": "https://github.com/rust-lang/rust/commit/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7aa407958b8ab2aec16b0182f0103ad92380b5dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa407958b8ab2aec16b0182f0103ad92380b5dc", "html_url": "https://github.com/rust-lang/rust/commit/7aa407958b8ab2aec16b0182f0103ad92380b5dc"}], "stats": {"total": 635, "additions": 310, "deletions": 325}, "files": [{"sha": "1ac2c9fc6bec60520e0c1268350df722d7975dac", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n- * between tasks.\n- */\n+#![stable]\n+\n+//! Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n+//! between tasks.\n \n use core::atomics;\n use core::clone::Clone;\n@@ -51,6 +51,7 @@ use heap::deallocate;\n /// }\n /// ```\n #[unsafe_no_drop_flag]\n+#[stable]\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -62,6 +63,7 @@ pub struct Arc<T> {\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n+#[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -77,6 +79,7 @@ struct ArcInner<T> {\n impl<T: Share + Send> Arc<T> {\n     /// Create an atomically reference counted wrapper.\n     #[inline]\n+    #[stable]\n     pub fn new(data: T) -> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n@@ -103,14 +106,15 @@ impl<T: Share + Send> Arc<T> {\n     /// Weak pointers will not keep the data alive. Once all strong references\n     /// to the underlying data have been dropped, the data itself will be\n     /// destroyed.\n+    #[experimental = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, atomics::Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n }\n \n-#[unstable]\n+#[unstable = \"waiting on stability of Clone\"]\n impl<T: Share + Send> Clone for Arc<T> {\n     /// Duplicate an atomically reference counted wrapper.\n     ///\n@@ -135,6 +139,7 @@ impl<T: Share + Send> Clone for Arc<T> {\n     }\n }\n \n+#[experimental = \"Deref is experimental.\"]\n impl<T: Send + Share> Deref<T> for Arc<T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n@@ -169,6 +174,7 @@ impl<T: Send + Share + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n+#[experimental = \"waiting on stability of Drop\"]\n impl<T: Share + Send> Drop for Arc<T> {\n     fn drop(&mut self) {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n@@ -212,6 +218,7 @@ impl<T: Share + Send> Drop for Arc<T> {\n     }\n }\n \n+#[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Share + Send> Weak<T> {\n     /// Attempts to upgrade this weak reference to a strong reference.\n     ///\n@@ -237,7 +244,7 @@ impl<T: Share + Send> Weak<T> {\n     }\n }\n \n-#[unstable]\n+#[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Share + Send> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n@@ -248,6 +255,7 @@ impl<T: Share + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n+#[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Share + Send> Drop for Weak<T> {\n     fn drop(&mut self) {\n         // see comments above for why this check is here"}, {"sha": "58278d5664e5e2a6d47d180cc7c5c2325edce556", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -87,10 +87,12 @@ impl<T: Ord> Ord for Box<T> {\n impl<T: Eq> Eq for Box<T> {}\n \n /// Extension methods for an owning `Any` trait object\n-#[unstable = \"post-DST, the signature of `downcast` will change to take `Box<Self>`\"]\n+#[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n+              rather a direct `impl` on `Box<Any>`\"]\n pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n+    #[unstable = \"naming conventions around accessing innards may change\"]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n \n     /// Deprecated; this method has been renamed to `downcast`.\n@@ -100,6 +102,7 @@ pub trait BoxAny {\n     }\n }\n \n+#[stable]\n impl BoxAny for Box<Any> {\n     #[inline]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {"}, {"sha": "b31931c6de3bc86be1eee077244516157a82769e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -379,7 +379,6 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n-#[unstable]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Clone for Weak<T> {\n     #[inline]"}, {"sha": "1809988847bc7ce9ee5c39659356026b38d9c7d9", "filename": "src/libcore/any.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -44,7 +44,7 @@\n //!     // try to convert our value to a String.  If successful, we want to\n //!     // output the String's length as well as its value.  If not, it's a\n //!     // different type: just print it out unadorned.\n-//!     match value_any.as_ref::<String>() {\n+//!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {\n //!             println!(\"String ({}): {}\", as_string.len(), as_string);\n //!         }\n@@ -69,51 +69,72 @@\n //! }\n //! ```\n \n+#![stable]\n+\n use mem::{transmute, transmute_copy};\n use option::{Option, Some, None};\n use raw::TraitObject;\n use intrinsics::TypeId;\n \n /// A type with no inhabitants\n+#[deprecated = \"this type is being removed, define a type locally if \\\n+                necessary\"]\n pub enum Void { }\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// The `Any` trait is implemented by all `'static` types, and can be used for dynamic typing\n+/// The `Any` trait is implemented by all `'static` types, and can be used for\n+/// dynamic typing\n ///\n-/// Every type with no non-`'static` references implements `Any`, so `Any` can be used as a trait\n-/// object to emulate the effects dynamic typing.\n-pub trait Any {\n+/// Every type with no non-`'static` references implements `Any`, so `Any` can\n+/// be used as a trait object to emulate the effects dynamic typing.\n+#[stable]\n+pub trait Any: AnyPrivate {}\n+\n+/// An inner trait to ensure that only this module can call `get_type_id()`.\n+trait AnyPrivate {\n     /// Get the `TypeId` of `self`\n     fn get_type_id(&self) -> TypeId;\n }\n \n-impl<T: 'static> Any for T {\n-    /// Get the `TypeId` of `self`\n-    fn get_type_id(&self) -> TypeId {\n-        TypeId::of::<T>()\n-    }\n+impl<T: 'static> AnyPrivate for T {\n+    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n+impl<T: 'static + AnyPrivate> Any for T {}\n+\n ///////////////////////////////////////////////////////////////////////////////\n // Extension methods for Any trait objects.\n // Implemented as three extension traits so that the methods can be generic.\n ///////////////////////////////////////////////////////////////////////////////\n \n /// Extension methods for a referenced `Any` trait object\n+#[unstable = \"this trait will not be necessary once DST lands, it will be a \\\n+              part of `impl Any`\"]\n pub trait AnyRefExt<'a> {\n     /// Returns true if the boxed type is the same as `T`\n+    #[stable]\n     fn is<T: 'static>(self) -> bool;\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_ref<T: 'static>(self) -> Option<&'a T>;\n+    #[unstable = \"naming conventions around acquiring references may change\"]\n+    fn downcast_ref<T: 'static>(self) -> Option<&'a T>;\n+\n+    /// Returns some reference to the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    #[deprecated = \"this function has been renamed to `downcast_ref`\"]\n+    fn as_ref<T: 'static>(self) -> Option<&'a T> {\n+        self.downcast_ref::<T>()\n+    }\n }\n \n+#[stable]\n impl<'a> AnyRefExt<'a> for &'a Any {\n     #[inline]\n+    #[stable]\n     fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n@@ -126,7 +147,8 @@ impl<'a> AnyRefExt<'a> for &'a Any {\n     }\n \n     #[inline]\n-    fn as_ref<T: 'static>(self) -> Option<&'a T> {\n+    #[unstable = \"naming conventions around acquiring references may change\"]\n+    fn downcast_ref<T: 'static>(self) -> Option<&'a T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -142,15 +164,27 @@ impl<'a> AnyRefExt<'a> for &'a Any {\n }\n \n /// Extension methods for a mutable referenced `Any` trait object\n+#[unstable = \"this trait will not be necessary once DST lands, it will be a \\\n+              part of `impl Any`\"]\n pub trait AnyMutRefExt<'a> {\n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_mut<T: 'static>(self) -> Option<&'a mut T>;\n+    #[unstable = \"naming conventions around acquiring references may change\"]\n+    fn downcast_mut<T: 'static>(self) -> Option<&'a mut T>;\n+\n+    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    #[deprecated = \"this function has been renamed to `downcast_mut`\"]\n+    fn as_mut<T: 'static>(self) -> Option<&'a mut T> {\n+        self.downcast_mut::<T>()\n+    }\n }\n \n+#[stable]\n impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n     #[inline]\n-    fn as_mut<T: 'static>(self) -> Option<&'a mut T> {\n+    #[unstable = \"naming conventions around acquiring references may change\"]\n+    fn downcast_mut<T: 'static>(self) -> Option<&'a mut T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object"}, {"sha": "466a1738e828858274826cf146d6f89680d8bc8c", "filename": "src/libcore/atomics.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -12,29 +12,29 @@\n \n use intrinsics;\n use std::kinds::marker;\n-use ty::Unsafe;\n+use cell::UnsafeCell;\n \n /// An atomic boolean type.\n pub struct AtomicBool {\n-    v: Unsafe<uint>,\n+    v: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n /// A signed atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicInt {\n-    v: Unsafe<int>,\n+    v: UnsafeCell<int>,\n     nocopy: marker::NoCopy\n }\n \n /// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicUint {\n-    v: Unsafe<uint>,\n+    v: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n /// An unsafe atomic pointer. Only supports basic atomic operations\n pub struct AtomicPtr<T> {\n-    p: Unsafe<uint>,\n+    p: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n@@ -69,17 +69,14 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`\n-pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n+pub static INIT_ATOMIC_BOOL: AtomicBool =\n+        AtomicBool { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n /// An `AtomicInt` initialized to `0`\n-pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n+pub static INIT_ATOMIC_INT: AtomicInt =\n+        AtomicInt { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n /// An `AtomicUint` initialized to `0`\n-pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n+pub static INIT_ATOMIC_UINT: AtomicUint =\n+        AtomicUint { v: UnsafeCell { value: 0, }, nocopy: marker::NoCopy };\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n static UINT_TRUE: uint = -1;\n@@ -88,7 +85,7 @@ impl AtomicBool {\n     /// Create a new `AtomicBool`\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: Unsafe::new(val), nocopy: marker::NoCopy }\n+        AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n     }\n \n     /// Load the value\n@@ -289,7 +286,7 @@ impl AtomicBool {\n impl AtomicInt {\n     /// Create a new `AtomicInt`\n     pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: Unsafe::new(v), nocopy: marker::NoCopy}\n+        AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n     }\n \n     /// Load the value\n@@ -401,7 +398,7 @@ impl AtomicInt {\n impl AtomicUint {\n     /// Create a new `AtomicUint`\n     pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: Unsafe::new(v), nocopy: marker::NoCopy }\n+        AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n     }\n \n     /// Load the value\n@@ -513,7 +510,7 @@ impl AtomicUint {\n impl<T> AtomicPtr<T> {\n     /// Create a new `AtomicPtr`\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: Unsafe::new(p as uint), nocopy: marker::NoCopy }\n+        AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n     }\n \n     /// Load the value"}, {"sha": "9d2ea816fdfd42cc67efc4c013d2aa5cb1143cfb", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -11,4 +11,6 @@\n //! The boolean type\n \n #![doc(primitive = \"bool\")]\n+#![unstable = \"this module is purely for documentation and it will likely be \\\n+               removed from the public api\"]\n "}, {"sha": "24ea3480c4397ae1633c00dbfe467e3597700e87", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 82, "deletions": 5, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -160,12 +160,11 @@ use cmp::PartialEq;\n use kinds::{marker, Copy};\n use ops::{Deref, DerefMut, Drop};\n use option::{None, Option, Some};\n-use ty::Unsafe;\n \n /// A mutable memory location that admits only `Copy` data.\n #[unstable = \"likely to be renamed; otherwise stable\"]\n pub struct Cell<T> {\n-    value: Unsafe<T>,\n+    value: UnsafeCell<T>,\n     noshare: marker::NoShare,\n }\n \n@@ -174,7 +173,7 @@ impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n-            value: Unsafe::new(value),\n+            value: UnsafeCell::new(value),\n             noshare: marker::NoShare,\n         }\n     }\n@@ -211,7 +210,7 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n /// A mutable memory location with dynamically checked borrow rules\n #[unstable = \"likely to be renamed; otherwise stable\"]\n pub struct RefCell<T> {\n-    value: Unsafe<T>,\n+    value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n     nocopy: marker::NoCopy,\n     noshare: marker::NoShare,\n@@ -228,7 +227,7 @@ impl<T> RefCell<T> {\n     #[stable]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n-            value: Unsafe::new(value),\n+            value: UnsafeCell::new(value),\n             borrow: Cell::new(UNUSED),\n             nocopy: marker::NoCopy,\n             noshare: marker::NoShare,\n@@ -401,3 +400,81 @@ impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n         unsafe { &mut *self._parent.value.get() }\n     }\n }\n+\n+/// The core primitive for interior mutability in Rust.\n+///\n+/// `UnsafeCell` type that wraps a type T and indicates unsafe interior\n+/// operations on the wrapped type. Types with an `UnsafeCell<T>` field are\n+/// considered to have an *unsafe interior*. The `UnsafeCell` type is the only\n+/// legal way to obtain aliasable data that is considered mutable. In general,\n+/// transmuting an &T type into an &mut T is considered undefined behavior.\n+///\n+/// Although it is possible to put an `UnsafeCell<T>` into static item, it is\n+/// not permitted to take the address of the static item if the item is not\n+/// declared as mutable. This rule exists because immutable static items are\n+/// stored in read-only memory, and thus any attempt to mutate their interior\n+/// can cause segfaults. Immutable static items containing `UnsafeCell<T>`\n+/// instances are still useful as read-only initializers, however, so we do not\n+/// forbid them altogether.\n+///\n+/// Types like `Cell` and `RefCell` use this type to wrap their internal data.\n+///\n+/// `UnsafeCell` doesn't opt-out from any kind, instead, types with an\n+/// `UnsafeCell` interior are expected to opt-out from kinds themselves.\n+///\n+/// # Example:\n+///\n+/// ```rust\n+/// use std::cell::UnsafeCell;\n+/// use std::kinds::marker;\n+///\n+/// struct NotThreadSafe<T> {\n+///     value: UnsafeCell<T>,\n+///     marker: marker::NoShare\n+/// }\n+/// ```\n+///\n+/// **NOTE:** `UnsafeCell<T>` fields are public to allow static initializers. It\n+/// is not recommended to access its fields directly, `get` should be used\n+/// instead.\n+#[lang=\"unsafe\"]\n+#[unstable = \"this type may be renamed in the future\"]\n+pub struct UnsafeCell<T> {\n+    /// Wrapped value\n+    ///\n+    /// This field should not be accessed directly, it is made public for static\n+    /// initializers.\n+    #[unstable]\n+    pub value: T,\n+}\n+\n+impl<T> UnsafeCell<T> {\n+    /// Construct a new instance of `UnsafeCell` which will wrapp the specified\n+    /// value.\n+    ///\n+    /// All access to the inner value through methods is `unsafe`, and it is\n+    /// highly discouraged to access the fields directly.\n+    #[stable]\n+    pub fn new(value: T) -> UnsafeCell<T> {\n+        UnsafeCell { value: value }\n+    }\n+\n+    /// Gets a mutable pointer to the wrapped value.\n+    ///\n+    /// This function is unsafe as the pointer returned is an unsafe pointer and\n+    /// no guarantees are made about the aliasing of the pointers being handed\n+    /// out in this or other tasks.\n+    #[inline]\n+    #[unstable = \"conventions around acquiring an inner reference are still \\\n+                  under development\"]\n+    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n+\n+    /// Unwraps the value\n+    ///\n+    /// This function is unsafe because there is no guarantee that this or other\n+    /// tasks are currently inspecting the inner value.\n+    #[inline]\n+    #[unstable = \"conventions around the name `unwrap` are still under \\\n+                  development\"]\n+    pub unsafe fn unwrap(self) -> T { self.value }\n+}"}, {"sha": "5277b473828fc81f7c47e5b92a392f2c5b1003b6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -98,13 +98,15 @@ pub struct Formatter<'a> {\n     args: &'a [Argument<'a>],\n }\n \n+enum Void {}\n+\n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n pub struct Argument<'a> {\n-    formatter: extern \"Rust\" fn(&any::Void, &mut Formatter) -> Result,\n-    value: &'a any::Void,\n+    formatter: extern \"Rust\" fn(&Void, &mut Formatter) -> Result,\n+    value: &'a Void,\n }\n \n impl<'a> Arguments<'a> {"}, {"sha": "f6a88b341960791fcee7964a58d34912d9500473", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -79,7 +79,7 @@ pub trait Copy {\n /// else that is not thread-safe) should use the `NoShare` marker type\n /// (from `std::kinds::marker`) to ensure that the compiler doesn't\n /// consider the user-defined type to be `Share`.  Any types with\n-/// interior mutability must also use the `std::ty::Unsafe` wrapper\n+/// interior mutability must also use the `std::cell::UnsafeCell` wrapper\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal)."}, {"sha": "2809bda4f6ed60b07138d0542e4abbd3b44ac8cc", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -98,12 +98,18 @@ pub mod ptr;\n \n pub mod kinds;\n pub mod ops;\n-pub mod ty;\n pub mod cmp;\n pub mod clone;\n pub mod default;\n pub mod collections;\n \n+#[deprecated = \"all functionality now lives in `std::cell`\"]\n+/// Deprecated module in favor of `std::cell`\n+pub mod ty {\n+    #[deprecated = \"this type has been renamed to `UnsafeCell`\"]\n+    pub use Unsafe = cell::UnsafeCell;\n+}\n+\n /* Core types and methods on primitives */\n \n pub mod any;"}, {"sha": "ed6b73df38d4d42ebb25feaac70186b6a316d2ca", "filename": "src/libcore/should_not_exist.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -1,95 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// As noted by this file name, this file should not exist. This file should not\n-// exist because it performs allocations which libcore is not allowed to do. The\n-// reason for this file's existence is that the `~[T]` type is a language-\n-// defined type. Traits are defined in libcore, such as `Clone`, which these\n-// types need to implement, but the implementation can only be found in\n-// libcore.\n-//\n-// Plan of attack for solving this problem:\n-//\n-//      1. Implement DST\n-//      2. Make `Box<T>` not a language feature\n-//      3. Move `Box<T>` to a separate crate, liballoc.\n-//      4. Implement relevant traits in liballoc, not libcore\n-//\n-// Currently, no progress has been made on this list.\n-\n-use clone::Clone;\n-use collections::Collection;\n-use finally::try_finally;\n-use intrinsics;\n-use iter::{range, Iterator};\n-use mem;\n-use num::{CheckedMul, CheckedAdd};\n-use option::{Some, None};\n-use ptr::RawPtr;\n-use ptr;\n-use raw::Vec;\n-use slice::ImmutableVector;\n-\n-#[allow(ctypes)]\n-extern {\n-    fn rust_allocate(size: uint, align: uint) -> *u8;\n-    fn rust_deallocate(ptr: *u8, size: uint, align: uint);\n-}\n-\n-unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n-    let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n-    // this should use the real alignment, but the new representation will take care of that\n-    let ret = rust_allocate(cap, 8) as *mut Vec<()>;\n-    if ret.is_null() {\n-        intrinsics::abort();\n-    }\n-    (*ret).fill = 0;\n-    (*ret).alloc = cap;\n-    ret\n-}\n-\n-// Arrays\n-\n-impl<A: Clone> Clone for ~[A] {\n-    #[inline]\n-    fn clone(&self) -> ~[A] {\n-        let len = self.len();\n-        let data_size = len.checked_mul(&mem::size_of::<A>()).unwrap();\n-        let size = mem::size_of::<Vec<()>>().checked_add(&data_size).unwrap();\n-\n-        unsafe {\n-            let ret = alloc(size) as *mut Vec<A>;\n-\n-            let a_size = mem::size_of::<A>();\n-            let a_size = if a_size == 0 {1} else {a_size};\n-            (*ret).fill = len * a_size;\n-            (*ret).alloc = len * a_size;\n-\n-            let mut i = 0;\n-            let p = &mut (*ret).data as *mut _ as *mut A;\n-            try_finally(\n-                &mut i, (),\n-                |i, ()| while *i < len {\n-                    ptr::write(\n-                        &mut(*p.offset(*i as int)),\n-                        self.unsafe_ref(*i).clone());\n-                    *i += 1;\n-                },\n-                |i| if *i < len {\n-                    // we must be failing, clean up after ourselves\n-                    for j in range(0, *i as int) {\n-                        ptr::read(&*p.offset(j));\n-                    }\n-                    rust_deallocate(ret as *u8, 0, 8);\n-                });\n-            mem::transmute(ret)\n-        }\n-    }\n-}"}, {"sha": "ead3564718018f1eac50e77f8d457d98c496a8aa", "filename": "src/libcore/tuple/mod.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Ftuple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Ftuple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Fmod.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -60,7 +60,10 @@\n //! ```\n \n #![doc(primitive = \"tuple\")]\n+#![stable]\n \n+#[unstable = \"this is just a documentation module and should not be part \\\n+              of the public api\"]\n pub use unit;\n \n use clone::Clone;\n@@ -79,41 +82,51 @@ macro_rules! tuple_impls {\n     )+) => {\n         $(\n             #[allow(missing_doc)]\n+            #[stable]\n             pub trait $Tuple<$($T),+> {\n-                $(fn $valN(self) -> $T;)+\n-                $(fn $refN<'a>(&'a self) -> &'a $T;)+\n-                $(fn $mutN<'a>(&'a mut self) -> &'a mut $T;)+\n+                $(\n+                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    fn $valN(self) -> $T;\n+                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    fn $refN<'a>(&'a self) -> &'a $T;\n+                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    fn $mutN<'a>(&'a mut self) -> &'a mut $T;\n+                 )+\n             }\n \n             impl<$($T),+> $Tuple<$($T),+> for ($($T,)+) {\n                 $(\n                     #[inline]\n                     #[allow(unused_variable)]\n+                    #[unstable = \"may rename pending accessor naming conventions\"]\n                     fn $valN(self) -> $T {\n                         let ($($x,)+) = self; $ret\n                     }\n \n                     #[inline]\n                     #[allow(unused_variable)]\n+                    #[unstable = \"may rename pending accessor naming conventions\"]\n                     fn $refN<'a>(&'a self) -> &'a $T {\n                         let ($(ref $x,)+) = *self; $ret\n                     }\n \n                     #[inline]\n                     #[allow(unused_variable)]\n+                    #[unstable = \"may rename pending accessor naming conventions\"]\n                     fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n                         let ($(ref mut $x,)+) = *self; $ret\n                     }\n                 )+\n             }\n \n-            #[unstable]\n+            #[unstable = \"waiting for Clone to stabilize\"]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(self.$refN().clone(),)+)\n                 }\n             }\n \n+            #[unstable = \"waiting for PartialEq to stabilize\"]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -125,8 +138,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n+            #[unstable = \"waiting for Eq to stabilize\"]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n+            #[unstable = \"waiting for PartialOrd to stabilize\"]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -150,13 +165,15 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n+            #[unstable = \"waiting for Ord to stabilize\"]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n+            #[stable]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n                 #[inline]\n                 fn default() -> ($($T,)+) {"}, {"sha": "7f89f0e5ae399256ebf9f090fa466d6d2164c099", "filename": "src/libcore/tuple/unit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Ftuple%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Ftuple%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Funit.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #![doc(primitive = \"unit\")]\n+#![unstable = \"this module is purely for documentation and it will likely be \\\n+               removed from the public api\"]\n \n //! The `()` type, sometimes called \"unit\" or \"nil\".\n //!"}, {"sha": "f8e03662b00eca4bc29dff6d320b777dd2fce3cf", "filename": "src/libcore/ty.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -11,60 +11,3 @@\n //! Types dealing with unsafe actions.\n \n use kinds::marker;\n-\n-/// Unsafe type that wraps a type T and indicates unsafe interior operations on the\n-/// wrapped type. Types with an `Unsafe<T>` field are considered to have an *unsafe\n-/// interior*. The Unsafe type is the only legal way to obtain aliasable data that is\n-/// considered mutable. In general, transmuting an &T type into an &mut T is considered\n-/// undefined behavior.\n-///\n-/// Although it is possible to put an Unsafe<T> into static item, it is not permitted to\n-/// take the address of the static item if the item is not declared as mutable. This rule\n-/// exists because immutable static items are stored in read-only memory, and thus any\n-/// attempt to mutate their interior can cause segfaults. Immutable static items containing\n-/// Unsafe<T> instances are still useful as read-only initializers, however, so we do not\n-/// forbid them altogether.\n-///\n-/// Types like `Cell` and `RefCell` use this type to wrap their internal data.\n-///\n-/// Unsafe doesn't opt-out from any kind, instead, types with an `Unsafe` interior\n-/// are expected to opt-out from kinds themselves.\n-///\n-/// # Example:\n-///\n-/// ```rust\n-/// use std::ty::Unsafe;\n-/// use std::kinds::marker;\n-///\n-/// struct NotThreadSafe<T> {\n-///     value: Unsafe<T>,\n-///     marker1: marker::NoShare\n-/// }\n-/// ```\n-///\n-/// **NOTE:** Unsafe<T> fields are public to allow static initializers. It is not recommended\n-/// to access its fields directly, `get` should be used instead.\n-#[lang=\"unsafe\"]\n-pub struct Unsafe<T> {\n-    /// Wrapped value\n-    pub value: T,\n-\n-    /// Invariance marker\n-    pub marker1: marker::InvariantType<T>\n-}\n-\n-impl<T> Unsafe<T> {\n-\n-    /// Static constructor\n-    pub fn new(value: T) -> Unsafe<T> {\n-        Unsafe{value: value, marker1: marker::InvariantType}\n-    }\n-\n-    /// Gets a mutable pointer to the wrapped value\n-    #[inline]\n-    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n-\n-    /// Unwraps the value\n-    #[inline]\n-    pub unsafe fn unwrap(self) -> T { self.value }\n-}"}, {"sha": "8e92aa56d3c8fd083438463671c5d4b7757db4af", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -26,7 +26,7 @@ use std::mem;\n use std::rt::bookkeeping;\n use std::rt::mutex::StaticNativeMutex;\n use std::rt;\n-use std::ty::Unsafe;\n+use std::cell::UnsafeCell;\n \n use task;\n \n@@ -41,35 +41,26 @@ pub struct Helper<M> {\n     /// Internal lock which protects the remaining fields\n     pub lock: StaticNativeMutex,\n \n-    // You'll notice that the remaining fields are Unsafe<T>, and this is\n+    // You'll notice that the remaining fields are UnsafeCell<T>, and this is\n     // because all helper thread operations are done through &self, but we need\n     // these to be mutable (once `lock` is held).\n \n     /// Lazily allocated channel to send messages to the helper thread.\n-    pub chan: Unsafe<*mut Sender<M>>,\n+    pub chan: UnsafeCell<*mut Sender<M>>,\n \n     /// OS handle used to wake up a blocked helper thread\n-    pub signal: Unsafe<uint>,\n+    pub signal: UnsafeCell<uint>,\n \n     /// Flag if this helper thread has booted and been initialized yet.\n-    pub initialized: Unsafe<bool>,\n+    pub initialized: UnsafeCell<bool>,\n }\n \n macro_rules! helper_init( (static mut $name:ident: Helper<$m:ty>) => (\n     static mut $name: Helper<$m> = Helper {\n         lock: ::std::rt::mutex::NATIVE_MUTEX_INIT,\n-        chan: ::std::ty::Unsafe {\n-            value: 0 as *mut Sender<$m>,\n-            marker1: ::std::kinds::marker::InvariantType,\n-        },\n-        signal: ::std::ty::Unsafe {\n-            value: 0,\n-            marker1: ::std::kinds::marker::InvariantType,\n-        },\n-        initialized: ::std::ty::Unsafe {\n-            value: false,\n-            marker1: ::std::kinds::marker::InvariantType,\n-        },\n+        chan: ::std::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::std::cell::UnsafeCell { value: 0 },\n+        initialized: ::std::cell::UnsafeCell { value: false },\n     };\n ) )\n "}, {"sha": "4a8bc97183ace9254349e06e662155d78d876c76", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -268,7 +268,7 @@ struct TermsContext<'a> {\n     inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n-#[deriving(Show)]\n+#[deriving(Show, PartialEq)]\n enum ParamKind {\n     TypeParam,\n     RegionParam\n@@ -412,6 +412,7 @@ struct ConstraintContext<'a> {\n     invariant_lang_items: [Option<ast::DefId>, ..2],\n     covariant_lang_items: [Option<ast::DefId>, ..2],\n     contravariant_lang_items: [Option<ast::DefId>, ..2],\n+    unsafe_lang_item: Option<ast::DefId>,\n \n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n@@ -451,6 +452,8 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n     invariant_lang_items[RegionParam as uint] =\n         terms_cx.tcx.lang_items.invariant_lifetime();\n \n+    let unsafe_lang_item = terms_cx.tcx.lang_items.unsafe_type();\n+\n     let covariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Contravariant));\n     let invariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Invariant));\n@@ -461,6 +464,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n         invariant_lang_items: invariant_lang_items,\n         covariant_lang_items: covariant_lang_items,\n         contravariant_lang_items: contravariant_lang_items,\n+        unsafe_lang_item: unsafe_lang_item,\n \n         covariant: covariant,\n         contravariant: contravariant,\n@@ -637,6 +641,8 @@ impl<'a> ConstraintContext<'a> {\n             self.covariant\n         } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n             self.contravariant\n+        } else if kind == TypeParam && Some(item_def_id) == self.unsafe_lang_item {\n+            self.invariant\n         } else if param_def_id.krate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic"}, {"sha": "179d050f598bfb1f63bdff86a3377c02c7210275", "filename": "src/librustrt/exclusive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n use mutex;\n \n /// An OS mutex over some data.\n@@ -23,7 +23,7 @@ use mutex;\n /// >           as part of `libsync` should almost always be favored.\n pub struct Exclusive<T> {\n     lock: mutex::NativeMutex,\n-    data: Unsafe<T>,\n+    data: UnsafeCell<T>,\n }\n \n /// An RAII guard returned via `lock`\n@@ -39,7 +39,7 @@ impl<T: Send> Exclusive<T> {\n     pub fn new(user_data: T) -> Exclusive<T> {\n         Exclusive {\n             lock: unsafe { mutex::NativeMutex::new() },\n-            data: Unsafe::new(user_data),\n+            data: UnsafeCell::new(user_data),\n         }\n     }\n "}, {"sha": "c999a08eb93b65269faa82dc5b038200b1598d84", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -341,8 +341,7 @@ mod imp {\n     use libc;\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n-    use core::ty::Unsafe;\n-    use core::kinds::marker;\n+    use core::cell::UnsafeCell;\n \n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n@@ -466,19 +465,13 @@ mod imp {\n     }\n \n     pub struct Mutex {\n-        lock: Unsafe<pthread_mutex_t>,\n-        cond: Unsafe<pthread_cond_t>,\n+        lock: UnsafeCell<pthread_mutex_t>,\n+        cond: UnsafeCell<pthread_cond_t>,\n     }\n \n     pub static MUTEX_INIT: Mutex = Mutex {\n-        lock: Unsafe {\n-            value: PTHREAD_MUTEX_INITIALIZER,\n-            marker1: marker::InvariantType,\n-        },\n-        cond: Unsafe {\n-            value: PTHREAD_COND_INITIALIZER,\n-            marker1: marker::InvariantType,\n-        },\n+        lock: UnsafeCell { value: PTHREAD_MUTEX_INITIALIZER },\n+        cond: UnsafeCell { value: PTHREAD_COND_INITIALIZER },\n     };\n \n     impl Mutex {\n@@ -487,8 +480,8 @@ mod imp {\n             // is better to avoid initialization of potentially\n             // opaque OS data before it landed\n             let m = Mutex {\n-                lock: Unsafe::new(PTHREAD_MUTEX_INITIALIZER),\n-                cond: Unsafe::new(PTHREAD_COND_INITIALIZER),\n+                lock: UnsafeCell::new(PTHREAD_MUTEX_INITIALIZER),\n+                cond: UnsafeCell::new(PTHREAD_COND_INITIALIZER),\n             };\n \n             return m;"}, {"sha": "9bd8af6419e0b9165f333050901a2e0561312c88", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -18,12 +18,12 @@ use alloc::arc::Arc;\n use std::mem;\n use std::rt::local::Local;\n use std::rt::task::{BlockedTask, Task};\n-use std::ty::Unsafe;\n+use std::cell::UnsafeCell;\n \n use homing::HomingMissile;\n \n pub struct Access {\n-    inner: Arc<Unsafe<Inner>>,\n+    inner: Arc<UnsafeCell<Inner>>,\n }\n \n pub struct Guard<'a> {\n@@ -40,7 +40,7 @@ struct Inner {\n impl Access {\n     pub fn new() -> Access {\n         Access {\n-            inner: Arc::new(Unsafe::new(Inner {\n+            inner: Arc::new(UnsafeCell::new(Inner {\n                 queue: vec![],\n                 held: false,\n                 closed: false,"}, {"sha": "7016ece642725033313458afc6650c07c2eed8af", "filename": "src/librustuv/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustuv%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibrustuv%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Frc.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -17,16 +17,16 @@\n /// should suffice.\n \n use alloc::arc::Arc;\n-use std::ty::Unsafe;\n+use std::cell::UnsafeCell;\n \n pub struct Refcount {\n-    rc: Arc<Unsafe<uint>>,\n+    rc: Arc<UnsafeCell<uint>>,\n }\n \n impl Refcount {\n     /// Creates a new refcount of 1\n     pub fn new() -> Refcount {\n-        Refcount { rc: Arc::new(Unsafe::new(1)) }\n+        Refcount { rc: Arc::new(UnsafeCell::new(1)) }\n     }\n \n     fn increment(&self) {"}, {"sha": "eff4cea1c43f0c394e9bd0c5cd35aa26e6b3448c", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -324,7 +324,7 @@ use alloc::boxed::Box;\n use core::cell::Cell;\n use core::kinds::marker;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n use rustrt::local::Local;\n use rustrt::task::{Task, BlockedTask};\n \n@@ -372,7 +372,7 @@ static RESCHED_FREQ: int = 256;\n /// one task\n #[unstable]\n pub struct Receiver<T> {\n-    inner: Unsafe<Flavor<T>>,\n+    inner: UnsafeCell<Flavor<T>>,\n     receives: Cell<uint>,\n     // can't share in an arc\n     marker: marker::NoShare,\n@@ -390,7 +390,7 @@ pub struct Messages<'a, T> {\n /// owned by one task, but it can be cloned to send to other tasks.\n #[unstable]\n pub struct Sender<T> {\n-    inner: Unsafe<Flavor<T>>,\n+    inner: UnsafeCell<Flavor<T>>,\n     sends: Cell<uint>,\n     // can't share in an arc\n     marker: marker::NoShare,\n@@ -400,7 +400,7 @@ pub struct Sender<T> {\n /// owned by one task, but it can be cloned to send to other tasks.\n #[unstable = \"this type may be renamed, but it will always exist\"]\n pub struct SyncSender<T> {\n-    inner: Arc<Unsafe<sync::Packet<T>>>,\n+    inner: Arc<UnsafeCell<sync::Packet<T>>>,\n     // can't share in an arc\n     marker: marker::NoShare,\n }\n@@ -436,15 +436,15 @@ pub enum TrySendError<T> {\n }\n \n enum Flavor<T> {\n-    Oneshot(Arc<Unsafe<oneshot::Packet<T>>>),\n-    Stream(Arc<Unsafe<stream::Packet<T>>>),\n-    Shared(Arc<Unsafe<shared::Packet<T>>>),\n-    Sync(Arc<Unsafe<sync::Packet<T>>>),\n+    Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n+    Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n+    Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n+    Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n }\n \n #[doc(hidden)]\n trait UnsafeFlavor<T> {\n-    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>>;\n+    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>>;\n     unsafe fn mut_inner<'a>(&'a self) -> &'a mut Flavor<T> {\n         &mut *self.inner_unsafe().get()\n     }\n@@ -453,12 +453,12 @@ trait UnsafeFlavor<T> {\n     }\n }\n impl<T> UnsafeFlavor<T> for Sender<T> {\n-    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>> {\n+    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n         &self.inner\n     }\n }\n impl<T> UnsafeFlavor<T> for Receiver<T> {\n-    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>> {\n+    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n         &self.inner\n     }\n }\n@@ -486,7 +486,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// ```\n #[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(Unsafe::new(oneshot::Packet::new()));\n+    let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n     (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n }\n \n@@ -524,7 +524,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n #[unstable = \"this function may be renamed to more accurately reflect the type \\\n               of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(Unsafe::new(sync::Packet::new(bound)));\n+    let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n }\n \n@@ -534,7 +534,11 @@ pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n \n impl<T: Send> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n-        Sender { inner: Unsafe::new(inner), sends: Cell::new(0), marker: marker::NoShare }\n+        Sender {\n+            inner: UnsafeCell::new(inner),\n+            sends: Cell::new(0),\n+            marker: marker::NoShare,\n+        }\n     }\n \n     /// Sends a value along this channel to be received by the corresponding\n@@ -618,7 +622,7 @@ impl<T: Send> Sender<T> {\n                     if !(*p).sent() {\n                         return (*p).send(t);\n                     } else {\n-                        let a = Arc::new(Unsafe::new(stream::Packet::new()));\n+                        let a = Arc::new(UnsafeCell::new(stream::Packet::new()));\n                         match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n@@ -655,7 +659,7 @@ impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n-                let a = Arc::new(Unsafe::new(shared::Packet::new()));\n+                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n                     (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n@@ -665,7 +669,7 @@ impl<T: Send> Clone for Sender<T> {\n                 }\n             }\n             Stream(ref p) => {\n-                let a = Arc::new(Unsafe::new(shared::Packet::new()));\n+                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n                     (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n@@ -708,7 +712,7 @@ impl<T: Send> Drop for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> SyncSender<T> {\n-    fn new(inner: Arc<Unsafe<sync::Packet<T>>>) -> SyncSender<T> {\n+    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner, marker: marker::NoShare }\n     }\n \n@@ -797,7 +801,7 @@ impl<T: Send> Drop for SyncSender<T> {\n \n impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: Unsafe::new(inner), receives: Cell::new(0), marker: marker::NoShare }\n+        Receiver { inner: UnsafeCell::new(inner), receives: Cell::new(0), marker: marker::NoShare }\n     }\n \n     /// Blocks waiting for a value on this receiver"}, {"sha": "e872952d9ee60b98aef89a74ff7c309e08a4fc08", "filename": "src/libsync/comm/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -39,7 +39,7 @@ use alloc::boxed::Box;\n use collections::Vec;\n use collections::Collection;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n use rustrt::local::Local;\n use rustrt::mutex::{NativeMutex, LockGuard};\n use rustrt::task::{Task, BlockedTask};\n@@ -53,7 +53,7 @@ pub struct Packet<T> {\n \n     /// The state field is protected by this mutex\n     lock: NativeMutex,\n-    state: Unsafe<State<T>>,\n+    state: UnsafeCell<State<T>>,\n }\n \n struct State<T> {\n@@ -133,7 +133,7 @@ impl<T: Send> Packet<T> {\n         Packet {\n             channels: atomics::AtomicUint::new(1),\n             lock: unsafe { NativeMutex::new() },\n-            state: Unsafe::new(State {\n+            state: UnsafeCell::new(State {\n                 disconnected: false,\n                 blocker: NoneBlocked,\n                 cap: cap,"}, {"sha": "e8418f9668f2a80d1fded58981cee230b6589a63", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -21,7 +21,7 @@\n \n use core::prelude::*;\n \n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n use rustrt::local::Local;\n use rustrt::task::Task;\n \n@@ -174,8 +174,8 @@ impl<'a> Condvar<'a> {\n /// ```\n pub struct Mutex<T> {\n     lock: raw::Mutex,\n-    failed: Unsafe<bool>,\n-    data: Unsafe<T>,\n+    failed: UnsafeCell<bool>,\n+    data: UnsafeCell<T>,\n }\n \n /// An guard which is created by locking a mutex. Through this guard the\n@@ -203,8 +203,8 @@ impl<T: Send> Mutex<T> {\n     pub fn new_with_condvars(user_data: T, num_condvars: uint) -> Mutex<T> {\n         Mutex {\n             lock: raw::Mutex::new_with_condvars(num_condvars),\n-            failed: Unsafe::new(false),\n-            data: Unsafe::new(user_data),\n+            failed: UnsafeCell::new(false),\n+            data: UnsafeCell::new(user_data),\n         }\n     }\n \n@@ -274,8 +274,8 @@ impl<'a, T: Send> DerefMut<T> for MutexGuard<'a, T> {\n /// ```\n pub struct RWLock<T> {\n     lock: raw::RWLock,\n-    failed: Unsafe<bool>,\n-    data: Unsafe<T>,\n+    failed: UnsafeCell<bool>,\n+    data: UnsafeCell<T>,\n }\n \n /// A guard which is created by locking an rwlock in write mode. Through this\n@@ -309,8 +309,8 @@ impl<T: Send + Share> RWLock<T> {\n     pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWLock<T> {\n         RWLock {\n             lock: raw::RWLock::new_with_condvars(num_condvars),\n-            failed: Unsafe::new(false),\n-            data: Unsafe::new(user_data),\n+            failed: UnsafeCell::new(false),\n+            data: UnsafeCell::new(user_data),\n         }\n     }\n "}, {"sha": "d54186dc22103f1a87425cec8ecba372cfd88646", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -35,7 +35,7 @@ use core::prelude::*;\n use alloc::arc::Arc;\n use collections::Vec;\n use core::num::next_power_of_two;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n \n use atomics::{AtomicUint,Relaxed,Release,Acquire};\n \n@@ -46,7 +46,7 @@ struct Node<T> {\n \n struct State<T> {\n     pad0: [u8, ..64],\n-    buffer: Vec<Unsafe<Node<T>>>,\n+    buffer: Vec<UnsafeCell<Node<T>>>,\n     mask: uint,\n     pad1: [u8, ..64],\n     enqueue_pos: AtomicUint,\n@@ -72,7 +72,7 @@ impl<T: Send> State<T> {\n             capacity\n         };\n         let buffer = Vec::from_fn(capacity, |i| {\n-            Unsafe::new(Node { sequence:AtomicUint::new(i), value: None })\n+            UnsafeCell::new(Node { sequence:AtomicUint::new(i), value: None })\n         });\n         State{\n             pad0: [0, ..64],"}, {"sha": "11f124293b12413590c2ecbaafd8637210a6e4c2", "filename": "src/libsync/mpsc_intrusive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -39,7 +39,7 @@ use core::prelude::*;\n \n use core::atomics;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n \n // NB: all links are done as AtomicUint instead of AtomicPtr to allow for static\n // initialization.\n@@ -55,15 +55,15 @@ pub struct DummyNode {\n \n pub struct Queue<T> {\n     pub head: atomics::AtomicUint,\n-    pub tail: Unsafe<*mut Node<T>>,\n+    pub tail: UnsafeCell<*mut Node<T>>,\n     pub stub: DummyNode,\n }\n \n impl<T: Send> Queue<T> {\n     pub fn new() -> Queue<T> {\n         Queue {\n             head: atomics::AtomicUint::new(0),\n-            tail: Unsafe::new(0 as *mut Node<T>),\n+            tail: UnsafeCell::new(0 as *mut Node<T>),\n             stub: DummyNode {\n                 next: atomics::AtomicUint::new(0),\n             },"}, {"sha": "4f5dd07a6e59eb2b367c9661abc5c5bf8c5cc301", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -44,7 +44,7 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n \n use atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n \n@@ -71,7 +71,7 @@ struct Node<T> {\n /// popper at a time (many pushers are allowed).\n pub struct Queue<T> {\n     head: AtomicPtr<Node<T>>,\n-    tail: Unsafe<*mut Node<T>>,\n+    tail: UnsafeCell<*mut Node<T>>,\n }\n \n impl<T> Node<T> {\n@@ -90,7 +90,7 @@ impl<T: Send> Queue<T> {\n         let stub = unsafe { Node::new(None) };\n         Queue {\n             head: AtomicPtr::new(stub),\n-            tail: Unsafe::new(stub),\n+            tail: UnsafeCell::new(stub),\n         }\n     }\n "}, {"sha": "1aa84e8f8d149cb86dd53dd5de3b2e9e8819b8bd", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -61,9 +61,8 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::atomics;\n-use core::kinds::marker;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n use rustrt::local::Local;\n use rustrt::mutex;\n use rustrt::task::{BlockedTask, Task};\n@@ -143,11 +142,11 @@ pub struct StaticMutex {\n     lock: mutex::StaticNativeMutex,\n \n     /// Type of locking operation currently on this mutex\n-    flavor: Unsafe<Flavor>,\n+    flavor: UnsafeCell<Flavor>,\n     /// uint-cast of the green thread waiting for this mutex\n-    green_blocker: Unsafe<uint>,\n+    green_blocker: UnsafeCell<uint>,\n     /// uint-cast of the native thread waiting for this mutex\n-    native_blocker: Unsafe<uint>,\n+    native_blocker: UnsafeCell<uint>,\n \n     /// A concurrent mpsc queue used by green threads, along with a count used\n     /// to figure out when to dequeue and enqueue.\n@@ -167,16 +166,13 @@ pub struct Guard<'a> {\n pub static MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: mutex::NATIVE_MUTEX_INIT,\n     state: atomics::INIT_ATOMIC_UINT,\n-    flavor: Unsafe { value: Unlocked, marker1: marker::InvariantType },\n-    green_blocker: Unsafe { value: 0, marker1: marker::InvariantType },\n-    native_blocker: Unsafe { value: 0, marker1: marker::InvariantType },\n+    flavor: UnsafeCell { value: Unlocked },\n+    green_blocker: UnsafeCell { value: 0 },\n+    native_blocker: UnsafeCell { value: 0 },\n     green_cnt: atomics::INIT_ATOMIC_UINT,\n     q: q::Queue {\n         head: atomics::INIT_ATOMIC_UINT,\n-        tail: Unsafe {\n-            value: 0 as *mut q::Node<uint>,\n-            marker1: marker::InvariantType,\n-        },\n+        tail: UnsafeCell { value: 0 as *mut q::Node<uint> },\n         stub: q::DummyNode {\n             next: atomics::INIT_ATOMIC_UINT,\n         }\n@@ -467,9 +463,9 @@ impl Mutex {\n         Mutex {\n             lock: box StaticMutex {\n                 state: atomics::AtomicUint::new(0),\n-                flavor: Unsafe::new(Unlocked),\n-                green_blocker: Unsafe::new(0),\n-                native_blocker: Unsafe::new(0),\n+                flavor: UnsafeCell::new(Unlocked),\n+                green_blocker: UnsafeCell::new(0),\n+                native_blocker: UnsafeCell::new(0),\n                 green_cnt: atomics::AtomicUint::new(0),\n                 q: q::Queue::new(),\n                 lock: unsafe { mutex::StaticNativeMutex::new() },"}, {"sha": "e7a2d3e0639963151b9dff14b5851b690897ad69", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -21,7 +21,7 @@ use core::atomics;\n use core::finally::Finally;\n use core::kinds::marker;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n use collections::{Vec, MutableSeq};\n \n use mutex;\n@@ -91,7 +91,7 @@ struct Sem<Q> {\n     //      (for good reason). We have an internal invariant on this semaphore,\n     //      however, that the queue is never accessed outside of a locked\n     //      context.\n-    inner: Unsafe<SemInner<Q>>\n+    inner: UnsafeCell<SemInner<Q>>\n }\n \n struct SemInner<Q> {\n@@ -113,7 +113,7 @@ impl<Q: Send> Sem<Q> {\n                 \"semaphores cannot be initialized with negative values\");\n         Sem {\n             lock: mutex::Mutex::new(),\n-            inner: Unsafe::new(SemInner {\n+            inner: UnsafeCell::new(SemInner {\n                 waiters: WaitQueue::new(),\n                 count: count,\n                 blocked: q,"}, {"sha": "0cda1098ab447a695f707c481101b0d1cfdf967e", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -39,7 +39,7 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::mem;\n-use core::ty::Unsafe;\n+use core::cell::UnsafeCell;\n \n use atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n \n@@ -58,13 +58,13 @@ struct Node<T> {\n /// time.\n pub struct Queue<T> {\n     // consumer fields\n-    tail: Unsafe<*mut Node<T>>, // where to pop from\n+    tail: UnsafeCell<*mut Node<T>>, // where to pop from\n     tail_prev: AtomicPtr<Node<T>>, // where to pop from\n \n     // producer fields\n-    head: Unsafe<*mut Node<T>>,      // where to push to\n-    first: Unsafe<*mut Node<T>>,     // where to get new nodes from\n-    tail_copy: Unsafe<*mut Node<T>>, // between first/tail\n+    head: UnsafeCell<*mut Node<T>>,      // where to push to\n+    first: UnsafeCell<*mut Node<T>>,     // where to get new nodes from\n+    tail_copy: UnsafeCell<*mut Node<T>>, // between first/tail\n \n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n@@ -103,11 +103,11 @@ impl<T: Send> Queue<T> {\n         let n2 = Node::new();\n         unsafe { (*n1).next.store(n2, Relaxed) }\n         Queue {\n-            tail: Unsafe::new(n2),\n+            tail: UnsafeCell::new(n2),\n             tail_prev: AtomicPtr::new(n1),\n-            head: Unsafe::new(n2),\n-            first: Unsafe::new(n1),\n-            tail_copy: Unsafe::new(n1),\n+            head: UnsafeCell::new(n2),\n+            first: UnsafeCell::new(n1),\n+            tail_copy: UnsafeCell::new(n1),\n             cache_bound: bound,\n             cache_additions: AtomicUint::new(0),\n             cache_subtractions: AtomicUint::new(0),"}, {"sha": "5928ded1e39c788bc0335027ab5588b2163ecd99", "filename": "src/test/compile-fail/borrowck-forbid-static-unsafe-interior.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -12,10 +12,10 @@\n // static items with usnafe interior.\n \n use std::kinds::marker;\n-use std::ty::Unsafe;\n+use std::cell::UnsafeCell;\n \n struct MyUnsafe<T> {\n-    value: Unsafe<T>\n+    value: UnsafeCell<T>\n }\n \n impl<T> MyUnsafe<T> {\n@@ -24,23 +24,23 @@ impl<T> MyUnsafe<T> {\n \n enum UnsafeEnum<T> {\n     VariantSafe,\n-    VariantUnsafe(Unsafe<T>)\n+    VariantUnsafe(UnsafeCell<T>)\n }\n \n static STATIC1: UnsafeEnum<int> = VariantSafe;\n \n-static STATIC2: Unsafe<int> = Unsafe{value: 1, marker1: marker::InvariantType};\n+static STATIC2: UnsafeCell<int> = UnsafeCell { value: 1 };\n static STATIC3: MyUnsafe<int> = MyUnsafe{value: STATIC2};\n \n-static STATIC4: &'static Unsafe<int> = &STATIC2;\n+static STATIC4: &'static UnsafeCell<int> = &STATIC2;\n //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n struct Wrap<T> {\n     value: T\n }\n \n-static UNSAFE: Unsafe<int> = Unsafe{value: 1, marker1: marker::InvariantType};\n-static WRAPPED_UNSAFE: Wrap<&'static Unsafe<int>> = Wrap { value: &UNSAFE };\n+static UNSAFE: UnsafeCell<int> = UnsafeCell{value: 1};\n+static WRAPPED_UNSAFE: Wrap<&'static UnsafeCell<int>> = Wrap { value: &UNSAFE };\n //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n fn main() {"}, {"sha": "a57654b029d164a5bf498dca660f0ed1bc2c979f", "filename": "src/test/compile-fail/typeck-unsafe-always-share.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs?ref=e5da6a71a6a0b46dd3630fc8326e6d5906a1fde6", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Verify that Unsafe is *always* share regardles `T` is share.\n+// Verify that UnsafeCell is *always* share regardles `T` is share.\n \n // ignore-tidy-linelength\n \n-use std::ty::Unsafe;\n+use std::cell::UnsafeCell;\n use std::kinds::marker;\n \n struct MyShare<T> {\n-    u: Unsafe<T>\n+    u: UnsafeCell<T>\n }\n \n struct NoShare {\n@@ -28,10 +28,10 @@ fn test<T: Share>(s: T){\n }\n \n fn main() {\n-    let us = Unsafe::new(MyShare{u: Unsafe::new(0i)});\n+    let us = UnsafeCell::new(MyShare{u: UnsafeCell::new(0i)});\n     test(us);\n \n-    let uns = Unsafe::new(NoShare{m: marker::NoShare});\n+    let uns = UnsafeCell::new(NoShare{m: marker::NoShare});\n     test(uns);\n \n     let ms = MyShare{u: uns};"}]}