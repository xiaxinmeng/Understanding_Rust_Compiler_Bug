{"sha": "d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "node_id": "C_kwDOAAsO6NoAKGQ5N2Q0ZWJlY2M1MDJiY2I1ZWRhMmNkYWE1MTNlMGU3OTIyYTM3N2U", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-16T02:10:10Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-17T03:32:46Z"}, "message": "Remove even more redundant builtin candidates", "tree": {"sha": "d30e65674b87510c2b93cf2860102d54738b5d6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d30e65674b87510c2b93cf2860102d54738b5d6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "html_url": "https://github.com/rust-lang/rust/commit/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "url": "https://api.github.com/repos/rust-lang/rust/commits/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "html_url": "https://github.com/rust-lang/rust/commit/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282"}], "stats": {"total": 234, "additions": 96, "deletions": 138}, "files": [{"sha": "106cf1114749a48d5781023e6ac3ac91de452e43", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "patch": "@@ -781,7 +781,11 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             );\n                             return;\n                         }\n-                        Ok(Some(ImplSource::Closure(_))) => {\n+                        // Closure: Fn{Once|Mut}\n+                        Ok(Some(ImplSource::Builtin(_)))\n+                            if poly_trait_pred.self_ty().skip_binder().is_closure()\n+                                && tcx.fn_trait_kind_from_def_id(trait_id).is_some() =>\n+                        {\n                             let ty::Closure(closure_def_id, substs) =\n                                 *poly_trait_pred.self_ty().no_bound_vars().unwrap().kind()\n                             else {"}, {"sha": "492b7228488fd6de19196969fcddccc016f0b9e8", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "patch": "@@ -661,20 +661,6 @@ pub enum ImplSource<'tcx, N> {\n     /// ImplSource for trait upcasting coercion\n     TraitUpcasting(ImplSourceTraitUpcastingData<N>),\n \n-    /// ImplSource automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is an `ImplSource::UserDefined` in spirit, but the\n-    /// impl is generated by the compiler and does not appear in the source.\n-    Closure(Vec<N>),\n-\n-    /// Same as above, but for a function pointer type with the given signature.\n-    FnPointer(Vec<N>),\n-\n-    /// ImplSource automatically generated for a generator.\n-    Generator(Vec<N>),\n-\n-    /// ImplSource automatically generated for a generator backing an async future.\n-    Future(Vec<N>),\n-\n     /// ImplSource for a trait alias.\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n }\n@@ -683,12 +669,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n             ImplSource::UserDefined(i) => i.nested,\n-            ImplSource::Param(n, _)\n-            | ImplSource::Builtin(n)\n-            | ImplSource::FnPointer(n)\n-            | ImplSource::Closure(n)\n-            | ImplSource::Generator(n)\n-            | ImplSource::Future(n) => n,\n+            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n             ImplSource::Object(d) => d.nested,\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n@@ -698,12 +679,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match self {\n             ImplSource::UserDefined(i) => &i.nested,\n-            ImplSource::Param(n, _)\n-            | ImplSource::Builtin(n)\n-            | ImplSource::FnPointer(n)\n-            | ImplSource::Closure(n)\n-            | ImplSource::Generator(n)\n-            | ImplSource::Future(n) => &n,\n+            ImplSource::Param(n, _) | ImplSource::Builtin(n) => &n,\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n@@ -713,12 +689,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn borrow_nested_obligations_mut(&mut self) -> &mut [N] {\n         match self {\n             ImplSource::UserDefined(i) => &mut i.nested,\n-            ImplSource::Param(n, _)\n-            | ImplSource::Builtin(n)\n-            | ImplSource::FnPointer(n)\n-            | ImplSource::Closure(n)\n-            | ImplSource::Generator(n)\n-            | ImplSource::Future(n) => n,\n+            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n             ImplSource::Object(d) => &mut d.nested,\n             ImplSource::TraitAlias(d) => &mut d.nested,\n             ImplSource::TraitUpcasting(d) => &mut d.nested,\n@@ -742,10 +713,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSource::Closure(n) => ImplSource::Closure(n.into_iter().map(f).collect()),\n-            ImplSource::Generator(n) => ImplSource::Generator(n.into_iter().map(f).collect()),\n-            ImplSource::Future(n) => ImplSource::Future(n.into_iter().map(f).collect()),\n-            ImplSource::FnPointer(n) => ImplSource::FnPointer(n.into_iter().map(f).collect()),\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,"}, {"sha": "ac02d6ed62f2e03c745a139c3672193b0053fb10", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "patch": "@@ -9,22 +9,14 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n         match *self {\n             super::ImplSource::UserDefined(ref v) => write!(f, \"{:?}\", v),\n \n-            super::ImplSource::Closure(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::Generator(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::Future(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n+            super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Param(ref n, ct) => {\n                 write!(f, \"ImplSourceParamData({:?}, {:?})\", n, ct)\n             }\n \n-            super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n-\n             super::ImplSource::TraitAlias(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::TraitUpcasting(ref d) => write!(f, \"{:?}\", d),"}, {"sha": "8399fbfc5be624ab411cdb2bfb8e9180cfc2fb01", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "patch": "@@ -1717,11 +1717,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n         };\n \n         let eligible = match &impl_source {\n-            super::ImplSource::Closure(_)\n-            | super::ImplSource::Generator(_)\n-            | super::ImplSource::Future(_)\n-            | super::ImplSource::FnPointer(_)\n-            | super::ImplSource::TraitAlias(_) => true,\n+            super::ImplSource::TraitAlias(_) => true,\n             super::ImplSource::UserDefined(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n@@ -1779,7 +1775,11 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 let self_ty = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n \n                 let lang_items = selcx.tcx().lang_items();\n-                if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n+                if [lang_items.gen_trait(), lang_items.future_trait()].contains(&Some(poly_trait_ref.def_id()))\n+                    || selcx.tcx().fn_trait_kind_from_def_id(poly_trait_ref.def_id()).is_some()\n+                {\n+                    true\n+                } else if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n                     match self_ty.kind() {\n                         ty::Bool\n                         | ty::Char\n@@ -1990,11 +1990,23 @@ fn confirm_select_candidate<'cx, 'tcx>(\n ) -> Progress<'tcx> {\n     match impl_source {\n         super::ImplSource::UserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n-        super::ImplSource::Generator(data) => confirm_generator_candidate(selcx, obligation, data),\n-        super::ImplSource::Future(data) => confirm_future_candidate(selcx, obligation, data),\n-        super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n-        super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::ImplSource::Builtin(data) => confirm_builtin_candidate(selcx, obligation, data),\n+        super::ImplSource::Builtin(data) => {\n+            let trait_def_id = obligation.predicate.trait_def_id(selcx.tcx());\n+            let lang_items = selcx.tcx().lang_items();\n+            if lang_items.gen_trait() == Some(trait_def_id) {\n+                confirm_generator_candidate(selcx, obligation, data)\n+            } else if lang_items.future_trait() == Some(trait_def_id) {\n+                confirm_future_candidate(selcx, obligation, data)\n+            } else if selcx.tcx().fn_trait_kind_from_def_id(trait_def_id).is_some() {\n+                if obligation.predicate.self_ty().is_closure() {\n+                    confirm_closure_candidate(selcx, obligation, data)\n+                } else {\n+                    confirm_fn_pointer_candidate(selcx, obligation, data)\n+                }\n+            } else {\n+                confirm_builtin_candidate(selcx, obligation, data)\n+            }\n+        }\n         super::ImplSource::Object(_)\n         | super::ImplSource::Param(..)\n         | super::ImplSource::TraitUpcasting(_)"}, {"sha": "3c356978d5ca80931efbf52b4a0bb68f5ca538a8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "patch": "@@ -85,22 +85,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ClosureCandidate { .. } => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n-                ImplSource::Closure(vtable_closure)\n+                ImplSource::Builtin(vtable_closure)\n             }\n \n             GeneratorCandidate => {\n                 let vtable_generator = self.confirm_generator_candidate(obligation)?;\n-                ImplSource::Generator(vtable_generator)\n+                ImplSource::Builtin(vtable_generator)\n             }\n \n             FutureCandidate => {\n                 let vtable_future = self.confirm_future_candidate(obligation)?;\n-                ImplSource::Future(vtable_future)\n+                ImplSource::Builtin(vtable_future)\n             }\n \n             FnPointerCandidate { is_const } => {\n                 let data = self.confirm_fn_pointer_candidate(obligation, is_const)?;\n-                ImplSource::FnPointer(data)\n+                ImplSource::Builtin(data)\n             }\n \n             TraitAliasCandidate => {"}, {"sha": "45b1075b6023af5529037b591f11ac20c9dba48f", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 60, "deletions": 77, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97d4ebecc502bcb5eda2cdaa513e0e7922a377e/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=d97d4ebecc502bcb5eda2cdaa513e0e7922a377e", "patch": "@@ -177,83 +177,6 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSource::Generator(_) => {\n-            let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n-                unreachable!()\n-            };\n-            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n-                // For compiler developers who'd like to add new items to `Generator`,\n-                // you either need to generate a shim body, or perhaps return\n-                // `InstanceDef::Item` pointing to a trait default method body if\n-                // it is given a default implementation by the trait.\n-                span_bug!(\n-                    tcx.def_span(generator_def_id),\n-                    \"no definition for `{trait_ref}::{}` for built-in generator type\",\n-                    tcx.item_name(trait_item_id)\n-                )\n-            }\n-            Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs })\n-        }\n-        traits::ImplSource::Future(_) => {\n-            let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n-                unreachable!()\n-            };\n-            if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n-                // `Future::poll` is generated by the compiler.\n-                Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs: substs })\n-            } else {\n-                // All other methods are default methods of the `Future` trait.\n-                // (this assumes that `ImplSource::Future` is only used for methods on `Future`)\n-                debug_assert!(tcx.defaultness(trait_item_id).has_value());\n-                Some(Instance::new(trait_item_id, rcvr_substs))\n-            }\n-        }\n-        traits::ImplSource::Closure(_) => {\n-            let ty::Closure(closure_def_id, substs) = *rcvr_substs.type_at(0).kind() else {\n-                unreachable!()\n-            };\n-            if cfg!(debug_assertions)\n-                && ![sym::call, sym::call_mut, sym::call_once]\n-                    .contains(&tcx.item_name(trait_item_id))\n-            {\n-                // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n-                // you either need to generate a shim body, or perhaps return\n-                // `InstanceDef::Item` pointing to a trait default method body if\n-                // it is given a default implementation by the trait.\n-                span_bug!(\n-                    tcx.def_span(closure_def_id),\n-                    \"no definition for `{trait_ref}::{}` for built-in closure type\",\n-                    tcx.item_name(trait_item_id)\n-                )\n-            }\n-            let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n-            Instance::resolve_closure(tcx, closure_def_id, substs, trait_closure_kind)\n-        }\n-        traits::ImplSource::FnPointer(_) => match rcvr_substs.type_at(0).kind() {\n-            ty::FnDef(..) | ty::FnPtr(..) => {\n-                if cfg!(debug_assertions)\n-                    && ![sym::call, sym::call_mut, sym::call_once]\n-                        .contains(&tcx.item_name(trait_item_id))\n-                {\n-                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n-                    // you either need to generate a shim body, or perhaps return\n-                    // `InstanceDef::Item` pointing to a trait default method body if\n-                    // it is given a default implementation by the trait.\n-                    bug!(\n-                        \"no definition for `{trait_ref}::{}` for built-in fn type\",\n-                        tcx.item_name(trait_item_id)\n-                    )\n-                }\n-                Some(Instance {\n-                    def: ty::InstanceDef::FnPtrShim(trait_item_id, rcvr_substs.type_at(0)),\n-                    substs: rcvr_substs,\n-                })\n-            }\n-            _ => bug!(\n-                \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n-                tcx.item_name(trait_item_id)\n-            ),\n-        },\n         traits::ImplSource::Object(ref data) => {\n             traits::get_vtable_index_of_object_method(tcx, data, trait_item_id).map(|index| {\n                 Instance {\n@@ -306,6 +229,66 @@ fn resolve_associated_item<'tcx>(\n                         span: tcx.def_span(trait_item_id),\n                     })\n                 }\n+            } else if Some(trait_ref.def_id) == lang_items.future_trait() {\n+                let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n+                    bug!()\n+                };\n+                if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n+                    // `Future::poll` is generated by the compiler.\n+                    Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs: substs })\n+                } else {\n+                    // All other methods are default methods of the `Future` trait.\n+                    // (this assumes that `ImplSource::Builtin` is only used for methods on `Future`)\n+                    debug_assert!(tcx.defaultness(trait_item_id).has_value());\n+                    Some(Instance::new(trait_item_id, rcvr_substs))\n+                }\n+            } else if Some(trait_ref.def_id) == lang_items.gen_trait() {\n+                let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n+                    bug!()\n+                };\n+                if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n+                    // For compiler developers who'd like to add new items to `Generator`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    span_bug!(\n+                        tcx.def_span(generator_def_id),\n+                        \"no definition for `{trait_ref}::{}` for built-in generator type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs })\n+            } else if tcx.fn_trait_kind_from_def_id(trait_ref.def_id).is_some() {\n+                // FIXME: This doesn't check for malformed libcore that defines, e.g.,\n+                // `trait Fn { fn call_once(&self) { .. } }`. This is mostly for extension\n+                // methods.\n+                if cfg!(debug_assertions)\n+                    && ![sym::call, sym::call_mut, sym::call_once]\n+                        .contains(&tcx.item_name(trait_item_id))\n+                {\n+                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    bug!(\n+                        \"no definition for `{trait_ref}::{}` for built-in callable type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                match *rcvr_substs.type_at(0).kind() {\n+                    ty::Closure(closure_def_id, substs) => {\n+                        let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n+                        Instance::resolve_closure(tcx, closure_def_id, substs, trait_closure_kind)\n+                    }\n+                    ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n+                        def: ty::InstanceDef::FnPtrShim(trait_item_id, rcvr_substs.type_at(0)),\n+                        substs: rcvr_substs,\n+                    }),\n+                    _ => bug!(\n+                        \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n+                        tcx.item_name(trait_item_id)\n+                    ),\n+                }\n             } else {\n                 None\n             }"}]}