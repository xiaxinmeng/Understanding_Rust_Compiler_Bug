{"sha": "5a8c1eb61ab5f82dc9a328c025aca7394db45751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOGMxZWI2MWFiNWY4MmRjOWEzMjhjMDI1YWNhNzM5NGRiNDU3NTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-07T18:18:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:51Z"}, "message": "leak the affects of closures on the free-region-map, like we used to\n\nThis restores the behavior of regionck with respect to the\nfree-region-map: that is, it collects all the relations from the fn\nand its closures. This feels a bit fishy but it's the behavior we've\nhad for some time, and it will go away with NLL, so seems best to just\nkeep it.", "tree": {"sha": "7887df7815c985527a51fdf7e955cbd9d45f5dd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7887df7815c985527a51fdf7e955cbd9d45f5dd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a8c1eb61ab5f82dc9a328c025aca7394db45751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8c1eb61ab5f82dc9a328c025aca7394db45751", "html_url": "https://github.com/rust-lang/rust/commit/5a8c1eb61ab5f82dc9a328c025aca7394db45751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a8c1eb61ab5f82dc9a328c025aca7394db45751/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7c2603e2c7440d4ef2e8ab5fc570d1dab2b0cbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7c2603e2c7440d4ef2e8ab5fc570d1dab2b0cbb", "html_url": "https://github.com/rust-lang/rust/commit/c7c2603e2c7440d4ef2e8ab5fc570d1dab2b0cbb"}], "stats": {"total": 94, "additions": 92, "deletions": 2}, "files": [{"sha": "2099e923e0959fb23788649c4b63a10f1f014a35", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a8c1eb61ab5f82dc9a328c025aca7394db45751/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8c1eb61ab5f82dc9a328c025aca7394db45751/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=5a8c1eb61ab5f82dc9a328c025aca7394db45751", "patch": "@@ -89,6 +89,52 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         self.free_region_map\n     }\n \n+    /// This is a hack to support the old-skool regionck, which\n+    /// processes region constraints from the main function and the\n+    /// closure together. In that context, when we enter a closure, we\n+    /// want to be able to \"save\" the state of the surrounding a\n+    /// function. We can then add implied bounds and the like from the\n+    /// closure arguments into the environment -- these should only\n+    /// apply in the closure body, so once we exit, we invoke\n+    /// `pop_snapshot_post_closure` to remove them.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// fn foo<T>() {\n+    ///    callback(for<'a> |x: &'a T| {\n+    ///         // ^^^^^^^ not legal syntax, but probably should be\n+    ///         // within this closure body, `T: 'a` holds\n+    ///    })\n+    /// }\n+    /// ```\n+    ///\n+    /// This \"containment\" of closure's effects only works so well. In\n+    /// particular, we (intentionally) leak relationships between free\n+    /// regions that are created by the closure's bounds. The case\n+    /// where this is useful is when you have (e.g.) a closure with a\n+    /// signature like `for<'a, 'b> fn(x: &'a &'b u32)` -- in this\n+    /// case, we want to keep the relationship `'b: 'a` in the\n+    /// free-region-map, so that later if we have to take `LUB('b,\n+    /// 'a)` we can get the result `'b`.\n+    ///\n+    /// I have opted to keep **all modifications** to the\n+    /// free-region-map, however, and not just those that concern free\n+    /// variables bound in the closure. The latter seems more correct,\n+    /// but it is not the existing behavior, and I could not find a\n+    /// case where the existing behavior went wrong. In any case, it\n+    /// seems like it'd be readily fixed if we wanted. There are\n+    /// similar leaks around givens that seem equally suspicious, to\n+    /// be honest. --nmatsakis\n+    pub fn push_snapshot_pre_closure(&self) -> usize {\n+        self.region_bound_pairs.len()\n+    }\n+\n+    /// See `push_snapshot_pre_closure`.\n+    pub fn pop_snapshot_post_closure(&mut self, len: usize) {\n+        self.region_bound_pairs.truncate(len);\n+    }\n+\n     /// This method adds \"implied bounds\" into the outlives environment.\n     /// Implied bounds are outlives relationships that we can deduce\n     /// on the basis that certain types must be well-formed -- these are"}, {"sha": "a17133d412c7a2b2f8b1f62fc4eedfd3a834d95e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a8c1eb61ab5f82dc9a328c025aca7394db45751/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8c1eb61ab5f82dc9a328c025aca7394db45751/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5a8c1eb61ab5f82dc9a328c025aca7394db45751", "patch": "@@ -428,17 +428,17 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // Save state of current function before invoking\n         // `visit_fn_body`.  We will restore afterwards.\n-        let outlives_environment = self.outlives_environment.clone();\n         let old_body_id = self.body_id;\n         let old_call_site_scope = self.call_site_scope;\n+        let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n         let body = self.tcx.hir.body(body_id);\n         self.visit_fn_body(id, body, span);\n \n         // Restore state from previous function.\n+        self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n         self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n-        self.outlives_environment = outlives_environment;\n     }\n \n     //visit_pat: visit_pat, // (..) see above"}, {"sha": "0e5cc574f002272aedc1fcfd21a0a81f30e89dee", "filename": "src/test/run-pass/implied-bounds-closure-arg-outlives.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a8c1eb61ab5f82dc9a328c025aca7394db45751/src%2Ftest%2Frun-pass%2Fimplied-bounds-closure-arg-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8c1eb61ab5f82dc9a328c025aca7394db45751/src%2Ftest%2Frun-pass%2Fimplied-bounds-closure-arg-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimplied-bounds-closure-arg-outlives.rs?ref=5a8c1eb61ab5f82dc9a328c025aca7394db45751", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to handle the relationships between free\n+// regions bound in a closure callback.\n+\n+#[derive(Copy, Clone)]\n+struct MyCx<'short, 'long: 'short> {\n+    short: &'short u32,\n+    long: &'long u32,\n+}\n+\n+impl<'short, 'long> MyCx<'short, 'long> {\n+    fn short(self) -> &'short u32 { self.short }\n+    fn long(self) -> &'long u32 { self.long }\n+    fn set_short(&mut self, v: &'short u32) { self.short = v; }\n+}\n+\n+fn with<F, R>(op: F) -> R\n+where\n+    F: for<'short, 'long> FnOnce(MyCx<'short, 'long>) -> R,\n+{\n+    op(MyCx {\n+        short: &22,\n+        long: &22,\n+    })\n+}\n+\n+fn main() {\n+    with(|mut cx| {\n+        // For this to type-check, we need to be able to deduce that\n+        // the lifetime of `l` can be `'short`, even though it has\n+        // input from `'long`.\n+        let l = if true { cx.long() } else { cx.short() };\n+        cx.set_short(l);\n+    });\n+}"}]}