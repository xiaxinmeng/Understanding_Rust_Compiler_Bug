{"sha": "b890237e798030ce337933b14f777a1c3810d1ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4OTAyMzdlNzk4MDMwY2UzMzc5MzNiMTRmNzc3YTFjMzgxMGQxZWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-31T02:46:19Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:48Z"}, "message": "libsyntax: Fix tests.", "tree": {"sha": "1032b8f875b000cb68829eb2861962b506b5efb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1032b8f875b000cb68829eb2861962b506b5efb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b890237e798030ce337933b14f777a1c3810d1ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b890237e798030ce337933b14f777a1c3810d1ea", "html_url": "https://github.com/rust-lang/rust/commit/b890237e798030ce337933b14f777a1c3810d1ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b890237e798030ce337933b14f777a1c3810d1ea/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52eeed2f73652014cde448b5dc969c7299a1fbcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/52eeed2f73652014cde448b5dc969c7299a1fbcb", "html_url": "https://github.com/rust-lang/rust/commit/52eeed2f73652014cde448b5dc969c7299a1fbcb"}], "stats": {"total": 102, "additions": 52, "deletions": 50}, "files": [{"sha": "2704e828ea4632f5b6e67708d1b7dbd3da76756d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -134,7 +134,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             if !cx.sess.building_library.get() {\n                 @ast::Item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n-                        if attr.name().equiv(&(\"main\")) {\n+                        if !attr.name().equiv(&(\"main\")) {\n                             Some(*attr)\n                         } else {\n                             None"}, {"sha": "2ada3ac16ea6674dea57f361caeda55cc26232a8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -468,7 +468,7 @@ mod test {\n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(@\"blork.rs\",@\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n         fm.next_line(BytePos(0));\n         assert_eq!(&fm.get_line(0),&~\"first line.\");\n         // TESTING BROKEN BEHAVIOR:\n@@ -480,7 +480,7 @@ mod test {\n     #[should_fail]\n     fn t2 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(@\"blork.rs\",@\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n         fm.next_line(BytePos(10));"}, {"sha": "0372be689a7287d7cba2fadcf1d1f522fb227995", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -1021,11 +1021,11 @@ mod test {\n     // make sure that macros can leave scope\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n-        let src = @\"fn bogus() {macro_rules! z (() => (3+4))}\\\n+        let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n+            ~\"<test>\",\n             src,\n             ~[],sess);\n         // should fail:\n@@ -1036,11 +1036,11 @@ mod test {\n     // make sure that macros can leave scope for modules\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n-        let src = @\"mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n+            ~\"<test>\",\n             src,\n             ~[],sess);\n         // should fail:\n@@ -1050,11 +1050,11 @@ mod test {\n \n     // macro_escape modules shouldn't cause macros to leave scope\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = @\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n+            ~\"<test>\",\n             src,\n             ~[], sess);\n         // should fail:\n@@ -1063,23 +1063,23 @@ mod test {\n     }\n \n     #[test] fn test_contains_flatten (){\n-        let attr1 = make_dummy_attr (@\"foo\");\n-        let attr2 = make_dummy_attr (@\"bar\");\n-        let escape_attr = make_dummy_attr (@\"macro_escape\");\n+        let attr1 = make_dummy_attr (\"foo\");\n+        let attr2 = make_dummy_attr (\"bar\");\n+        let escape_attr = make_dummy_attr (\"macro_escape\");\n         let attrs1 = ~[attr1, escape_attr, attr2];\n         assert_eq!(contains_macro_escape (attrs1),true);\n         let attrs2 = ~[attr1,attr2];\n         assert_eq!(contains_macro_escape (attrs2),false);\n     }\n \n     // make a MetaWord outer attribute with the given name\n-    fn make_dummy_attr(s: @str) -> ast::Attribute {\n+    fn make_dummy_attr(s: &str) -> ast::Attribute {\n         Spanned {\n             span:codemap::DUMMY_SP,\n             node: Attribute_ {\n                 style: AttrOuter,\n                 value: @Spanned {\n-                    node: MetaWord(s),\n+                    node: MetaWord(token::intern_and_get_ident(s)),\n                     span: codemap::DUMMY_SP,\n                 },\n                 is_sugared_doc: false,\n@@ -1089,7 +1089,7 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let item_ast = string_to_crate(@\"fn f() -> int { a }\");\n+        let item_ast = string_to_crate(~\"fn f() -> int { a }\");\n         let a_name = intern(\"a\");\n         let a2_name = gensym(\"a2\");\n         let mut renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n@@ -1128,7 +1128,7 @@ mod test {\n     //    pprust::print_crate_(&mut s, crate);\n     //}\n \n-    fn expand_crate_str(crate_str: @str) -> ast::Crate {\n+    fn expand_crate_str(crate_str: ~str) -> ast::Crate {\n         let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n         // the cfg argument actually does matter, here...\n         let mut loader = ErrLoader;\n@@ -1146,7 +1146,7 @@ mod test {\n     //}\n \n     #[test] fn macro_tokens_should_match(){\n-        expand_crate_str(@\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\");\n+        expand_crate_str(~\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\");\n     }\n \n     // renaming tests expand a crate and then check that the bindings match\n@@ -1222,7 +1222,7 @@ mod test {\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_managed(), conns.clone(), bic)\n         };\n-        let cr = expand_crate_str(teststr.to_managed());\n+        let cr = expand_crate_str(teststr.to_owned());\n         // find the bindings:\n         let mut name_finder = new_name_finder(~[]);\n         visit::walk_crate(&mut name_finder,&cr,());\n@@ -1285,7 +1285,7 @@ mod test {\n     }\n \n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n+        let crate_str = ~\"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n foo_module!()\n \";\n@@ -1335,7 +1335,7 @@ foo_module!()\n \n     #[test]\n     fn pat_idents(){\n-        let pat = string_to_pat(@\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n+        let pat = string_to_pat(~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n         let mut pat_idents = new_name_finder(~[]);\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(pat_idents.ident_accumulator,"}, {"sha": "8f5bbc2cdad186d38669561de4843ad3a2f4c5be", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -899,7 +899,8 @@ mod test {\n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n         let mut zz_fold = ToZzIdentFolder;\n-        let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        let ast = string_to_crate(\n+            ~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n@@ -910,8 +911,9 @@ mod test {\n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n         let mut zz_fold = ToZzIdentFolder;\n-        let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n-=> (g $(d $d $e)+))} \");\n+        let ast = string_to_crate(\n+            ~\"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n+              (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,"}, {"sha": "8c55990289aa8067eb7f1a47328629eb85caaa40", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -972,9 +972,9 @@ mod test {\n     }\n \n     // open a string reader for the given string\n-    fn setup(teststr: @str) -> Env {\n+    fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(@\"zebra.rs\", teststr);\n+        let fm = cm.new_filemap(~\"zebra.rs\", teststr);\n         let span_handler =\n             diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n         Env {\n@@ -984,7 +984,7 @@ mod test {\n \n     #[test] fn t1 () {\n         let Env {string_reader} =\n-            setup(@\"/* my source file */ \\\n+            setup(~\"/* my source file */ \\\n                     fn main() { println!(\\\"zebra\\\"); }\\n\");\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n@@ -1020,67 +1020,67 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        let env = setup (@\"a b\");\n+        let env = setup (~\"a b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n-        let env = setup (@\"a::b\");\n+        let env = setup (~\"a::b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n-        let env = setup (@\"a ::b\");\n+        let env = setup (~\"a ::b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n-        let env = setup (@\"a:: b\");\n+        let env = setup (~\"a:: b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn character_a() {\n-        let env = setup(@\"'a'\");\n+        let env = setup(~\"'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok,token::LIT_CHAR('a' as u32));\n     }\n \n     #[test] fn character_space() {\n-        let env = setup(@\"' '\");\n+        let env = setup(~\"' '\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok, token::LIT_CHAR(' ' as u32));\n     }\n \n     #[test] fn character_escaped() {\n-        let env = setup(@\"'\\\\n'\");\n+        let env = setup(~\"'\\\\n'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok, token::LIT_CHAR('\\n' as u32));\n     }\n \n     #[test] fn lifetime_name() {\n-        let env = setup(@\"'abc\");\n+        let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = token::str_to_ident(\"abc\");\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n \n     #[test] fn raw_string() {\n-        let env = setup(@\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\");\n+        let env = setup(~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\");\n@@ -1094,7 +1094,7 @@ mod test {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let env = setup(@\"/* /* */ */'a'\");\n+        let env = setup(~\"/* /* */ */'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok,token::LIT_CHAR('a' as u32));"}, {"sha": "cec9f7c2d9f11333c4f3f5f1421d10dda688bcef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -314,7 +314,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_1() {\n-        assert_eq!(string_to_expr(@\"a\"),\n+        assert_eq!(string_to_expr(~\"a\"),\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -333,7 +333,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_2 () {\n-        assert_eq!(string_to_expr(@\"::a::b\"),\n+        assert_eq!(string_to_expr(~\"::a::b\"),\n                    @ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -358,12 +358,12 @@ mod test {\n \n     #[should_fail]\n     #[test] fn bad_path_expr_1() {\n-        string_to_expr(@\"::abc::def::return\");\n+        string_to_expr(~\"::abc::def::return\");\n     }\n \n     // check the token-tree-ization of macros\n     #[test] fn string_to_tts_macro () {\n-        let tts = string_to_tts(@\"macro_rules! zip (($a)=>($a))\");\n+        let tts = string_to_tts(~\"macro_rules! zip (($a)=>($a))\");\n         match tts {\n             [ast::TTTok(_,_),\n              ast::TTTok(_,token::NOT),\n@@ -407,7 +407,7 @@ mod test {\n     }\n \n     #[test] fn string_to_tts_1 () {\n-        let tts = string_to_tts(@\"fn a (b : int) { b; }\");\n+        let tts = string_to_tts(~\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(&tts),\n         ~\"[\\\n     {\\\n@@ -536,7 +536,7 @@ mod test {\n     }\n \n     #[test] fn ret_expr() {\n-        assert_eq!(string_to_expr(@\"return d\"),\n+        assert_eq!(string_to_expr(~\"return d\"),\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(@ast::Expr{\n@@ -559,7 +559,7 @@ mod test {\n     }\n \n     #[test] fn parse_stmt_1 () {\n-        assert_eq!(string_to_stmt(@\"b;\"),\n+        assert_eq!(string_to_stmt(~\"b;\"),\n                    @Spanned{\n                        node: ast::StmtExpr(@ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n@@ -585,7 +585,7 @@ mod test {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let mut parser = string_to_parser(@\"b\");\n+        let mut parser = string_to_parser(~\"b\");\n         assert_eq!(parser.parse_pat(),\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n@@ -609,7 +609,7 @@ mod test {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\"\n-        assert_eq!(string_to_item(@\"fn a (b : int) { b; }\"),\n+        assert_eq!(string_to_item(~\"fn a (b : int) { b; }\"),\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n@@ -701,12 +701,12 @@ mod test {\n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n-        string_to_expr(@\"3 + 4\");\n-        string_to_expr(@\"a::z.froob(b,@(987+3))\");\n+        string_to_expr(~\"3 + 4\");\n+        string_to_expr(~\"a::z.froob(b,@(987+3))\");\n     }\n \n     #[test] fn attrs_fix_bug () {\n-        string_to_item(@\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+        string_to_item(~\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n     #[cfg(windows)]\n     fn wb() -> c_int {"}, {"sha": "58c2bed7a45a73b60703d5bfc1b38389c570df0c", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890237e798030ce337933b14f777a1c3810d1ea/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=b890237e798030ce337933b14f777a1c3810d1ea", "patch": "@@ -19,7 +19,7 @@ use parse::token;\n // and the ParseSess\n pub fn string_to_tts_and_sess (source_str : ~str) -> (~[ast::TokenTree], @ParseSess) {\n     let ps = new_parse_sess(None);\n-    (filemap_to_tts(ps,string_to_filemap(ps,source_str,@\"bogofile\")),ps)\n+    (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n }\n \n // map a string to tts, using a made-up filename:\n@@ -30,7 +30,7 @@ pub fn string_to_tts(source_str : ~str) -> ~[ast::TokenTree] {\n \n pub fn string_to_parser_and_sess(source_str: ~str) -> (Parser,@ParseSess) {\n     let ps = new_parse_sess(None);\n-    (new_parser_from_source_str(ps,~[],@\"bogofile\",source_str),ps)\n+    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n }\n \n // map string to parser (via tts)"}]}