{"sha": "9d9d5910afb7e94a995def430ce7b9e55c36897d", "node_id": "C_kwDOAAsO6NoAKDlkOWQ1OTEwYWZiN2U5NGE5OTVkZWY0MzBjZTdiOWU1NWMzNjg5N2Q", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-19T20:57:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-19T20:57:43Z"}, "message": "Rollup merge of #96165 - RalfJung:miri-provenance-cleanup, r=oli-obk\n\nMiri provenance cleanup\n\nReviewing https://github.com/rust-lang/rust/pull/95826 by ``@carbotaniuman`` made me realize that we could clean things up a little here.\n\n``@carbotaniuman`` please let me know if you're okay with landing this (it will create a lot of conflicts with your PR), or if you'd prefer incorporating the ideas from this PR into yours. I think we want to end up in a situation where the function you called `ptr_reify_alloc` returns just two things, a concrete tag and an offset. Getting an `AllocId` from a concrete tag should be infallible like now. However a concrete tag and `Tag` don't have to be the same type.\n\nr? ``@oli-obk``", "tree": {"sha": "bef355e33e3dd0b65b86a076458ae67b1aae6d47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bef355e33e3dd0b65b86a076458ae67b1aae6d47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d9d5910afb7e94a995def430ce7b9e55c36897d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiXyJHCRBK7hj4Ov3rIwAA4k8IAEdhl3Pc37xk7WRNnNxcR6xr\npR/xWTn3ZpZGxrxVHupscIXI9kKhjVgPTEyXf5ca6GrC+IwUgIBdtoVS3Qi5Z4F4\nfmnmt2WEygmhPAsGj+jUd1maeBfR39kmmGnGfS4EmVAIpDDyHdb2ByptGBEwj39n\nIkSj2rWONis1XOuN7cbetClQnIU0GM/Cmkxdsb5daD/5czY5l9LPb5np72BN3h+0\nBIH3E2B88OH2hLiuOVdjTGdpfTJlZ8gNwy5OT+L+cjn0Xqbz+47tq+5hGMhBtBBb\nkHonjxmDLQJQ4Aq7TrkGfXjr0PvdCVH4x4P0oItAgsBmNzjwERKLhl6/jfYlCZw=\n=j8xD\n-----END PGP SIGNATURE-----\n", "payload": "tree bef355e33e3dd0b65b86a076458ae67b1aae6d47\nparent f7d8f5b1e19f0f8cb45f8085ab3a3933359aa4d5\nparent 55f0977a6baee4a3469826a45ee1308a65498129\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650401863 +0200\ncommitter GitHub <noreply@github.com> 1650401863 +0200\n\nRollup merge of #96165 - RalfJung:miri-provenance-cleanup, r=oli-obk\n\nMiri provenance cleanup\n\nReviewing https://github.com/rust-lang/rust/pull/95826 by ``@carbotaniuman`` made me realize that we could clean things up a little here.\n\n``@carbotaniuman`` please let me know if you're okay with landing this (it will create a lot of conflicts with your PR), or if you'd prefer incorporating the ideas from this PR into yours. I think we want to end up in a situation where the function you called `ptr_reify_alloc` returns just two things, a concrete tag and an offset. Getting an `AllocId` from a concrete tag should be infallible like now. However a concrete tag and `Tag` don't have to be the same type.\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9d5910afb7e94a995def430ce7b9e55c36897d", "html_url": "https://github.com/rust-lang/rust/commit/9d9d5910afb7e94a995def430ce7b9e55c36897d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d9d5910afb7e94a995def430ce7b9e55c36897d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7d8f5b1e19f0f8cb45f8085ab3a3933359aa4d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7d8f5b1e19f0f8cb45f8085ab3a3933359aa4d5", "html_url": "https://github.com/rust-lang/rust/commit/f7d8f5b1e19f0f8cb45f8085ab3a3933359aa4d5"}, {"sha": "55f0977a6baee4a3469826a45ee1308a65498129", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f0977a6baee4a3469826a45ee1308a65498129", "html_url": "https://github.com/rust-lang/rust/commit/55f0977a6baee4a3469826a45ee1308a65498129"}], "stats": {"total": 122, "additions": 76, "deletions": 46}, "files": [{"sha": "68f9bee593f65ea0f8b04da55f60ef657b0670f8", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=9d9d5910afb7e94a995def430ce7b9e55c36897d", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn const_caller_location(\n     if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n-    ConstValue::Scalar(Scalar::from_pointer(loc_place.ptr.into_pointer_or_addr().unwrap(), &tcx))\n+    ConstValue::Scalar(Scalar::from_maybe_pointer(loc_place.ptr, &tcx))\n }\n \n /// Convert an evaluated constant to a type level constant"}, {"sha": "7721485771b3b0a121ea08e321b326889869d982", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=9d9d5910afb7e94a995def430ce7b9e55c36897d", "patch": "@@ -88,6 +88,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n     type PointerTag: Provenance + Eq + Hash + 'static;\n \n+    /// When getting the AllocId of a pointer, some extra data is also obtained from the tag\n+    /// that is passed to memory access hooks so they can do things with it.\n+    type TagExtra: Copy + 'static;\n+\n     /// Machines can define extra (non-instance) things that represent values of function pointers.\n     /// For example, Miri uses this to return a function pointer from `dlsym`\n     /// that can later be called to execute the right thing.\n@@ -122,6 +126,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Whether, when checking alignment, we should `force_int` and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n+    ///\n+    /// Requires PointerTag::OFFSET_IS_ADDR to be true.\n     fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n@@ -285,11 +291,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>>;\n \n-    /// Convert a pointer with provenance into an allocation-offset pair.\n+    /// Convert a pointer with provenance into an allocation-offset pair\n+    /// and extra provenance info.\n+    ///\n+    /// The returned `AllocId` must be the same as `ptr.provenance.get_alloc_id()`.\n     fn ptr_get_alloc(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n-    ) -> (AllocId, Size);\n+    ) -> (AllocId, Size, Self::TagExtra);\n \n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n@@ -321,7 +330,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_extra: &Self::AllocExtra,\n-        _tag: Self::PointerTag,\n+        _tag: (AllocId, Self::TagExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -333,7 +342,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _tag: Self::PointerTag,\n+        _tag: (AllocId, Self::TagExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -345,7 +354,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _tag: Self::PointerTag,\n+        _tag: (AllocId, Self::TagExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -397,6 +406,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n // (CTFE and ConstProp) use the same instance.  Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type PointerTag = AllocId;\n+    type TagExtra = ();\n+\n     type ExtraFnVal = !;\n \n     type MemoryMap =\n@@ -474,9 +485,12 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn ptr_get_alloc(_ecx: &InterpCx<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n+    fn ptr_get_alloc(\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n+        ptr: Pointer<AllocId>,\n+    ) -> (AllocId, Size, Self::TagExtra) {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n-        (alloc_id, offset)\n+        (alloc_id, offset, ())\n     }\n }"}, {"sha": "e8ee0fe6ea6ee16a79af4fa6252e9f5f9ab2b448", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=9d9d5910afb7e94a995def430ce7b9e55c36897d", "patch": "@@ -158,8 +158,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<AllocId>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-        let (alloc_id, offset) = ptr.into_parts();\n+        let alloc_id = ptr.provenance;\n         // We need to handle `extern static`.\n         match self.tcx.get_global_alloc(alloc_id) {\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n@@ -171,7 +170,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => {}\n         }\n         // And we need to get the tag.\n-        Ok(M::tag_alloc_base_pointer(self, Pointer::new(alloc_id, offset)))\n+        Ok(M::tag_alloc_base_pointer(self, ptr))\n     }\n \n     pub fn create_fn_alloc_ptr(\n@@ -238,7 +237,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -255,14 +254,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         // This will also call the access hooks.\n         self.mem_copy(\n-            ptr.into(),\n+            ptr,\n             Align::ONE,\n             new_ptr.into(),\n             Align::ONE,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate_ptr(ptr.into(), old_size_and_align, kind)?;\n+        self.deallocate_ptr(ptr, old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n@@ -274,7 +273,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -330,7 +329,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             *self.tcx,\n             &mut self.machine,\n             &mut alloc.extra,\n-            ptr.provenance,\n+            (alloc_id, tag),\n             alloc_range(Size::ZERO, size),\n         )?;\n \n@@ -350,17 +349,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<(AllocId, Size, Pointer<M::PointerTag>)>> {\n+    ) -> InterpResult<'tcx, Option<(AllocId, Size, M::TagExtra)>> {\n         let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, ptr| {\n+            |alloc_id, offset, tag| {\n                 let (size, align) =\n                     self.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n-                Ok((size, align, (alloc_id, offset, ptr)))\n+                Ok((size, align, (alloc_id, offset, tag)))\n             },\n         )\n     }\n@@ -401,11 +400,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Option<Align>,\n         msg: CheckInAllocMsg,\n-        alloc_size: impl FnOnce(\n-            AllocId,\n-            Size,\n-            Pointer<M::PointerTag>,\n-        ) -> InterpResult<'tcx, (Size, Align, T)>,\n+        alloc_size: impl FnOnce(AllocId, Size, M::TagExtra) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n             if offset % align.bytes() == 0 {\n@@ -433,8 +428,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 None\n             }\n-            Ok((alloc_id, offset, ptr)) => {\n-                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, ptr)?;\n+            Ok((alloc_id, offset, tag)) => {\n+                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, tag)?;\n                 // Test bounds. This also ensures non-null.\n                 // It is sufficient to check this for the end pointer. Also check for overflow!\n                 if offset.checked_add(size, &self.tcx).map_or(true, |end| end > alloc_size) {\n@@ -450,10 +445,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n                     if M::force_int_for_alignment_check(self) {\n-                        let addr = Scalar::from_pointer(ptr, &self.tcx)\n-                            .to_machine_usize(&self.tcx)\n-                            .expect(\"ptr-to-int cast for align check should never fail\");\n-                        check_offset_align(addr, align)?;\n+                        // `force_int_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n+                        check_offset_align(ptr.addr().bytes(), align)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n@@ -569,14 +562,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, ptr| {\n+            |alloc_id, offset, tag| {\n                 let alloc = self.get_alloc_raw(alloc_id)?;\n-                Ok((alloc.size(), alloc.align, (alloc_id, offset, ptr, alloc)))\n+                Ok((alloc.size(), alloc.align, (alloc_id, offset, tag, alloc)))\n             },\n         )?;\n-        if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n+        if let Some((alloc_id, offset, tag, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(*self.tcx, &self.machine, &alloc.extra, ptr.provenance, range)?;\n+            M::memory_read(*self.tcx, &self.machine, &alloc.extra, (alloc_id, tag), range)?;\n             Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n@@ -631,13 +624,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n-        if let Some((alloc_id, offset, ptr)) = parts {\n+        if let Some((alloc_id, offset, tag)) = parts {\n             let tcx = *self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(tcx, machine, &mut alloc.extra, ptr.provenance, range)?;\n+            M::memory_written(tcx, machine, &mut alloc.extra, (alloc_id, tag), range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -732,7 +725,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n@@ -1012,16 +1005,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let Some((src_alloc_id, src_offset, src)) = src_parts else {\n+        let Some((src_alloc_id, src_offset, src_tag)) = src_parts else {\n             // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n         let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(*tcx, &self.machine, &src_alloc.extra, src.provenance, src_range)?;\n+        M::memory_read(*tcx, &self.machine, &src_alloc.extra, (src_alloc_id, src_tag), src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n+        let Some((dest_alloc_id, dest_offset, dest_tag)) = dest_parts else {\n             // Zero-sized *destination*.\n             return Ok(());\n         };\n@@ -1043,7 +1036,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n-        M::memory_written(*tcx, extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n+        M::memory_written(\n+            *tcx,\n+            extra,\n+            &mut dest_alloc.extra,\n+            (dest_alloc_id, dest_tag),\n+            dest_range,\n+        )?;\n         let dest_bytes = dest_alloc\n             .get_bytes_mut_ptr(&tcx, dest_range)\n             .map_err(|e| e.to_interp_error(dest_alloc_id))?\n@@ -1164,11 +1163,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn ptr_try_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n+    ) -> Result<(AllocId, Size, M::TagExtra), u64> {\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => {\n-                let (alloc_id, offset) = M::ptr_get_alloc(self, ptr);\n-                Ok((alloc_id, offset, ptr))\n+                let (alloc_id, offset, extra) = M::ptr_get_alloc(self, ptr);\n+                Ok((alloc_id, offset, extra))\n             }\n             Err(addr) => Err(addr.bytes()),\n         }\n@@ -1179,7 +1178,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn ptr_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n+    ) -> InterpResult<'tcx, (AllocId, Size, M::TagExtra)> {\n         self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })"}, {"sha": "71d29be97d5ec38e99b544bee0532d2c58ad4400", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=9d9d5910afb7e94a995def430ce7b9e55c36897d", "patch": "@@ -432,7 +432,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n+            if let Ok((alloc_id, _offset, _tag)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {"}, {"sha": "c71aea417eca0143279c565a813ed0da9203dabc", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9d5910afb7e94a995def430ce7b9e55c36897d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=9d9d5910afb7e94a995def430ce7b9e55c36897d", "patch": "@@ -163,6 +163,9 @@ pub struct Pointer<Tag = AllocId> {\n }\n \n static_assert_size!(Pointer, 16);\n+// `Option<Tag>` pointers are also passed around quite a bit\n+// (but not stored in permanent machine state).\n+static_assert_size!(Pointer<Option<AllocId>>, 16);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n@@ -198,12 +201,26 @@ impl<Tag> From<Pointer<Tag>> for Pointer<Option<Tag>> {\n }\n \n impl<Tag> Pointer<Option<Tag>> {\n+    /// Convert this pointer that *might* have a tag into a pointer that *definitely* has a tag, or\n+    /// an absolute address.\n+    ///\n+    /// This is rarely what you want; call `ptr_try_get_alloc_id` instead.\n     pub fn into_pointer_or_addr(self) -> Result<Pointer<Tag>, Size> {\n         match self.provenance {\n             Some(tag) => Ok(Pointer::new(tag, self.offset)),\n             None => Err(self.offset),\n         }\n     }\n+\n+    /// Returns the absolute address the pointer points to.\n+    /// Only works if Tag::OFFSET_IS_ADDR is true!\n+    pub fn addr(self) -> Size\n+    where\n+        Tag: Provenance,\n+    {\n+        assert!(Tag::OFFSET_IS_ADDR);\n+        self.offset\n+    }\n }\n \n impl<Tag> Pointer<Option<Tag>> {"}]}