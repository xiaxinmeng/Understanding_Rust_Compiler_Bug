{"sha": "a4ec8af4c549bd806522826b756e18fbf0b5c47b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZWM4YWY0YzU0OWJkODA2NTIyODI2Yjc1NmUxOGZiZjBiNWM0N2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-23T15:31:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-23T15:31:21Z"}, "message": "auto merge of #9810 : huonw/rust/rand3, r=alexcrichton\n\n- Adds the `Sample` and `IndependentSample` traits for generating numbers where there are parameters (e.g. a list of elements to draw from, or the mean/variance of a normal distribution). The former takes `&mut self` and the latter takes `&self` (this is the only difference).\r\n- Adds proper `Normal` and `Exp`-onential distributions\r\n- Adds `Range` which generates `[lo, hi)` generically & properly (via a new trait) replacing the incorrect behaviour of `Rng.gen_integer_range` (this has become `Rng.gen_range` for convenience, it's far more efficient to use `Range` itself)\r\n- Move the `Weighted` struct from `std::rand` to `std::rand::distributions` & improve it\r\n- optimisations and docs", "tree": {"sha": "94b419a959409c8616e95645aefe4f73cd619294", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94b419a959409c8616e95645aefe4f73cd619294"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4ec8af4c549bd806522826b756e18fbf0b5c47b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ec8af4c549bd806522826b756e18fbf0b5c47b", "html_url": "https://github.com/rust-lang/rust/commit/a4ec8af4c549bd806522826b756e18fbf0b5c47b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4ec8af4c549bd806522826b756e18fbf0b5c47b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de50a3f7135329d862c9265f5749ab7de865873", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de50a3f7135329d862c9265f5749ab7de865873", "html_url": "https://github.com/rust-lang/rust/commit/5de50a3f7135329d862c9265f5749ab7de865873"}, {"sha": "0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "html_url": "https://github.com/rust-lang/rust/commit/0bba73c0d156df8f22c64ef4f4c50910fe31cf31"}], "stats": {"total": 1087, "additions": 840, "deletions": 247}, "files": [{"sha": "032de0b5f4a7f9ca0bf2752179d0616799e0a9ac", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -318,7 +318,7 @@ mod test {\n         use std::vec;\n \n         do 1000.times {\n-            let times = task_rng().gen_integer_range(1u, 100);\n+            let times = task_rng().gen_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }"}, {"sha": "bb3524a7d490263f0c138e02266886f91505deed", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -365,7 +365,7 @@ pub mod test {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_integer_range(0, 2 * blocksize + 1);\n+            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(buffer.slice_to(size));"}, {"sha": "3f3b588e8bc183a04701a81ba76d1a0932b38dff", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -113,7 +113,7 @@ mod tests {\n         let mut r = rand::rng();\n         let mut words = ~[];\n         do 20.times {\n-            let range = r.gen_integer_range(1u, 10);\n+            let range = r.gen_range(1u, 10);\n             words.push(r.gen_vec::<u8>(range));\n         }\n         do 20.times {"}, {"sha": "2a456f8de3ebe42c58d1da94af58369fcfc229fe", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -1069,8 +1069,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_integer_range(0u, n);\n-                let i2 = rng.gen_integer_range(0u, n);\n+                let i1 = rng.gen_range(0u, n);\n+                let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_integer_range(0u, n);\n+                let idx = rng.gen_range(0u, n);\n                 arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n@@ -1141,8 +1141,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_integer_range(0u, n);\n-                let i2 = rng.gen_integer_range(0u, n);\n+                let i1 = rng.gen_range(0u, n);\n+                let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_integer_range(0u, n);\n+                let idx = rng.gen_range(0u, n);\n                 arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);"}, {"sha": "7ef9ba76b995d481e57edd6507b790457f91ac13", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -1028,7 +1028,7 @@ mod test_treemap {\n             }\n \n             do 30.times {\n-                let r = rng.gen_integer_range(0, ctrl.len());\n+                let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);"}, {"sha": "e7bcf8ce5d3a71d0c0d14e41b6199cc0a1093c3a", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 481, "deletions": 41, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -8,38 +8,226 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Sampling from random distributions\n+/*!\n+Sampling from random distributions.\n \n-// Some implementations use the Ziggurat method\n-// https://en.wikipedia.org/wiki/Ziggurat_algorithm\n-//\n-// The version used here is ZIGNOR [Doornik 2005, \"An Improved\n-// Ziggurat Method to Generate Normal Random Samples\"] which is slower\n-// (about double, it generates an extra random number) than the\n-// canonical version [Marsaglia & Tsang 2000, \"The Ziggurat Method for\n-// Generating Random Variables\"], but more robust. If one wanted, one\n-// could implement VIZIGNOR the ZIGNOR paper for more speed.\n+This is a generalization of `Rand` to allow parameters to control the\n+exact properties of the generated values, e.g. the mean and standard\n+deviation of a normal distribution. The `Sample` trait is the most\n+general, and allows for generating values that change some state\n+internally. The `IndependentSample` trait is for generating values\n+that do not need to record state.\n+\n+*/\n \n+use iter::range;\n+use option::{Some, None};\n use num;\n use rand::{Rng,Rand};\n+use clone::Clone;\n+\n+pub use self::range::Range;\n+\n+pub mod range;\n+\n+/// Types that can be used to create a random instance of `Support`.\n+pub trait Sample<Support> {\n+    /// Generate a random value of `Support`, using `rng` as the\n+    /// source of randomness.\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Support;\n+}\n+\n+/// `Sample`s that do not require keeping track of state.\n+///\n+/// Since no state is recored, each sample is (statistically)\n+/// independent of all others, assuming the `Rng` used has this\n+/// property.\n+// XXX maybe having this separate is overkill (the only reason is to\n+// take &self rather than &mut self)? or maybe this should be the\n+// trait called `Sample` and the other should be `DependentSample`.\n+pub trait IndependentSample<Support>: Sample<Support> {\n+    /// Generate a random value.\n+    fn ind_sample<R: Rng>(&self, &mut R) -> Support;\n+}\n+\n+/// A wrapper for generating types that implement `Rand` via the\n+/// `Sample` & `IndependentSample` traits.\n+pub struct RandSample<Sup>;\n+\n+impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+}\n+\n+impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n+        rng.gen()\n+    }\n+}\n+\n+/// A value with a particular weight for use with `WeightedChoice`.\n+pub struct Weighted<T> {\n+    /// The numerical weight of this item\n+    weight: uint,\n+    /// The actual item which is being weighted\n+    item: T,\n+}\n+\n+/// A distribution that selects from a finite collection of weighted items.\n+///\n+/// Each item has an associated weight that influences how likely it\n+/// is to be chosen: higher weight is more likely.\n+///\n+/// The `Clone` restriction is a limitation of the `Sample` and\n+/// `IndepedentSample` traits. Note that `&T` is (cheaply) `Clone` for\n+/// all `T`, as is `uint`, so one can store references or indices into\n+/// another vector.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{Weighted, WeightedChoice, IndepedentSample};\n+///\n+/// fn main() {\n+///     let wc = WeightedChoice::new(~[Weighted { weight: 2, item: 'a' },\n+///                                    Weighted { weight: 4, item: 'b' },\n+///                                    Weighted { weight: 1, item: 'c' }]);\n+///     let rng = rand::task_rng();\n+///     for _ in range(0, 16) {\n+///          // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n+///          println!(\"{}\", wc.ind_sample(rng));\n+///     }\n+/// }\n+/// ```\n+pub struct WeightedChoice<T> {\n+    priv items: ~[Weighted<T>],\n+    priv weight_range: Range<uint>\n+}\n+\n+impl<T: Clone> WeightedChoice<T> {\n+    /// Create a new `WeightedChoice`.\n+    ///\n+    /// Fails if:\n+    /// - `v` is empty\n+    /// - the total weight is 0\n+    /// - the total weight is larger than a `uint` can contain.\n+    pub fn new(mut items: ~[Weighted<T>]) -> WeightedChoice<T> {\n+        // strictly speaking, this is subsumed by the total weight == 0 case\n+        assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n+\n+        let mut running_total = 0u;\n+\n+        // we convert the list from individual weights to cumulative\n+        // weights so we can binary search. This *could* drop elements\n+        // with weight == 0 as an optimisation.\n+        for item in items.mut_iter() {\n+            running_total = running_total.checked_add(&item.weight)\n+                .expect(\"WeightedChoice::new called with a total weight larger \\\n+                        than a uint can contain\");\n+\n+            item.weight = running_total;\n+        }\n+        assert!(running_total != 0, \"WeightedChoice::new called with a total weight of 0\");\n+\n+        WeightedChoice {\n+            items: items,\n+            // we're likely to be generating numbers in this range\n+            // relatively often, so might as well cache it\n+            weight_range: Range::new(0, running_total)\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Sample<T> for WeightedChoice<T> {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> T { self.ind_sample(rng) }\n+}\n+\n+impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {\n+        // we want to find the first element that has cumulative\n+        // weight > sample_weight, which we do by binary since the\n+        // cumulative weights of self.items are sorted.\n+\n+        // choose a weight in [0, total_weight)\n+        let sample_weight = self.weight_range.ind_sample(rng);\n+\n+        // short circuit when it's the first item\n+        if sample_weight < self.items[0].weight {\n+            return self.items[0].item.clone();\n+        }\n+\n+        let mut idx = 0;\n+        let mut modifier = self.items.len();\n+\n+        // now we know that every possibility has an element to the\n+        // left, so we can just search for the last element that has\n+        // cumulative weight <= sample_weight, then the next one will\n+        // be \"it\". (Note that this greatest element will never be the\n+        // last element of the vector, since sample_weight is chosen\n+        // in [0, total_weight) and the cumulative weight of the last\n+        // one is exactly the total weight.)\n+        while modifier > 1 {\n+            let i = idx + modifier / 2;\n+            if self.items[i].weight <= sample_weight {\n+                // we're small, so look to the right, but allow this\n+                // exact element still.\n+                idx = i;\n+                // we need the `/ 2` to round up otherwise we'll drop\n+                // the trailing elements when `modifier` is odd.\n+                modifier += 1;\n+            } else {\n+                // otherwise we're too big, so go left. (i.e. do\n+                // nothing)\n+            }\n+            modifier /= 2;\n+        }\n+        return self.items[idx + 1].item.clone();\n+    }\n+}\n \n mod ziggurat_tables;\n \n-// inlining should mean there is no performance penalty for this\n-#[inline]\n+/// Sample a random number using the Ziggurat method (specifically the\n+/// ZIGNOR variant from Doornik 2005). Most of the arguments are\n+/// directly from the paper:\n+///\n+/// * `rng`: source of randomness\n+/// * `symmetric`: whether this is a symmetric distribution, or one-sided with P(x < 0) = 0.\n+/// * `X`: the $x_i$ abscissae.\n+/// * `F`: precomputed values of the PDF at the $x_i$, (i.e. $f(x_i)$)\n+/// * `F_DIFF`: precomputed values of $f(x_i) - f(x_{i+1})$\n+/// * `pdf`: the probability density function\n+/// * `zero_case`: manual sampling from the tail when we chose the\n+///    bottom box (i.e. i == 0)\n+\n+// the perf improvement (25-50%) is definitely worth the extra code\n+// size from force-inlining.\n+#[inline(always)]\n fn ziggurat<R:Rng>(rng: &mut R,\n-                   center_u: bool,\n+                   symmetric: bool,\n                    X: ziggurat_tables::ZigTable,\n                    F: ziggurat_tables::ZigTable,\n                    F_DIFF: ziggurat_tables::ZigTable,\n-                   pdf: &'static fn(f64) -> f64, // probability density function\n+                   pdf: &'static fn(f64) -> f64,\n                    zero_case: &'static fn(&mut R, f64) -> f64) -> f64 {\n+    static SCALE: f64 = (1u64 << 53) as f64;\n     loop {\n-        let u = if center_u {2.0 * rng.gen() - 1.0} else {rng.gen()};\n-        let i: uint = rng.gen::<uint>() & 0xff;\n+        // reimplement the f64 generation as an optimisation suggested\n+        // by the Doornik paper: we have a lot of precision-space\n+        // (i.e. there are 11 bits of the 64 of a u64 to use after\n+        // creating a f64), so we might as well reuse some to save\n+        // generating a whole extra random number. (Seems to be 15%\n+        // faster.)\n+        let bits: u64 = rng.gen();\n+        let i = (bits & 0xff) as uint;\n+        let f = (bits >> 11) as f64 / SCALE;\n+\n+        // u is either U(-1, 1) or U(0, 1) depending on if this is a\n+        // symmetric distribution or not.\n+        let u = if symmetric {2.0 * f - 1.0} else {f};\n         let x = u * X[i];\n \n-        let test_x = if center_u {num::abs(x)} else {x};\n+        let test_x = if symmetric {num::abs(x)} else {x};\n \n         // algebraically equivalent to |u| < X[i+1]/X[i] (or u < X[i+1]/X[i])\n         if test_x < X[i + 1] {\n@@ -49,30 +237,25 @@ fn ziggurat<R:Rng>(rng: &mut R,\n             return zero_case(rng, u);\n         }\n         // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n-        if F[i+1] + F_DIFF[i+1] * rng.gen() < pdf(x) {\n+        if F[i + 1] + F_DIFF[i + 1] * rng.gen() < pdf(x) {\n             return x;\n         }\n     }\n }\n \n-/// A wrapper around an `f64` to generate N(0, 1) random numbers (a.k.a.  a\n-/// standard normal, or Gaussian). Multiplying the generated values by the\n-/// desired standard deviation `sigma` then adding the desired mean `mu` will\n-/// give N(mu, sigma^2) distributed random numbers.\n+/// A wrapper around an `f64` to generate N(0, 1) random numbers\n+/// (a.k.a.  a standard normal, or Gaussian).\n ///\n-/// Note that this has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n+/// See `Normal` for the general normal distribution. That this has to\n+/// be unwrapped before use as an `f64` (using either `*` or\n+/// `cast::transmute` is safe).\n ///\n-/// # Example\n+/// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n ///\n-/// ```\n-/// use std::rand::distributions::StandardNormal;\n-///\n-/// fn main() {\n-///     let normal = 2.0 + (*rand::random::<StandardNormal>()) * 3.0;\n-///     println!(\"{} is from a N(2, 9) distribution\", normal)\n-/// }\n-/// ```\n+/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n+/// Generate Normal Random\n+/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n+/// College, Oxford\n pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n@@ -110,23 +293,62 @@ impl Rand for StandardNormal {\n     }\n }\n \n-/// A wrapper around an `f64` to generate Exp(1) random numbers. Dividing by\n-/// the desired rate `lambda` will give Exp(lambda) distributed random\n-/// numbers.\n+/// The normal distribution `N(mean, std_dev**2)`.\n ///\n-/// Note that this has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n+/// This uses the ZIGNOR variant of the Ziggurat method, see\n+/// `StandardNormal` for more details.\n ///\n /// # Example\n ///\n /// ```\n-/// use std::rand::distributions::Exp1;\n+/// use std::rand;\n+/// use std::rand::distributions::{Normal, IndependentSample};\n ///\n /// fn main() {\n-///     let exp2 = (*rand::random::<Exp1>()) * 0.5;\n-///     println!(\"{} is from a Exp(2) distribution\", exp2);\n+///     let normal = Normal::new(2.0, 3.0);\n+///     let v = normal.ind_sample(rand::task_rng());\n+///     println!(\"{} is from a N(2, 9) distribution\", v)\n /// }\n /// ```\n+pub struct Normal {\n+    priv mean: f64,\n+    priv std_dev: f64\n+}\n+\n+impl Normal {\n+    /// Construct a new `Normal` distribution with the given mean and\n+    /// standard deviation. Fails if `std_dev < 0`.\n+    pub fn new(mean: f64, std_dev: f64) -> Normal {\n+        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n+        Normal {\n+            mean: mean,\n+            std_dev: std_dev\n+        }\n+    }\n+}\n+impl Sample<f64> for Normal {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Normal {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        self.mean + self.std_dev * (*rng.gen::<StandardNormal>())\n+    }\n+}\n+\n+/// A wrapper around an `f64` to generate Exp(1) random numbers.\n+///\n+/// See `Exp` for the general exponential distribution.Note that this\n+ // has to be unwrapped before use as an `f64` (using either\n+/// `*` or `cast::transmute` is safe).\n+///\n+/// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n+/// exact description in the paper was adjusted to use tables for the\n+/// exponential distribution rather than normal.\n+///\n+/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n+/// Generate Normal Random\n+/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n+/// College, Oxford\n pub struct Exp1(f64);\n \n // This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n@@ -148,3 +370,221 @@ impl Rand for Exp1 {\n                       pdf, zero_case))\n     }\n }\n+\n+/// The exponential distribution `Exp(lambda)`.\n+///\n+/// This distribution has density function: `f(x) = lambda *\n+/// exp(-lambda * x)` for `x > 0`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::rand;\n+/// use std::rand::distributions::{Exp, IndependentSample};\n+///\n+/// fn main() {\n+///     let exp = Exp::new(2.0);\n+///     let v = exp.ind_sample(rand::task_rng());\n+///     println!(\"{} is from a Exp(2) distribution\", v);\n+/// }\n+/// ```\n+pub struct Exp {\n+    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n+    priv lambda_inverse: f64\n+}\n+\n+impl Exp {\n+    /// Construct a new `Exp` with the given shape parameter\n+    /// `lambda`. Fails if `lambda <= 0`.\n+    pub fn new(lambda: f64) -> Exp {\n+        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n+        Exp { lambda_inverse: 1.0 / lambda }\n+    }\n+}\n+\n+impl Sample<f64> for Exp {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Exp {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        (*rng.gen::<Exp1>()) * self.lambda_inverse\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    struct ConstRand(uint);\n+    impl Rand for ConstRand {\n+        fn rand<R: Rng>(_: &mut R) -> ConstRand {\n+            ConstRand(0)\n+        }\n+    }\n+\n+    // 0, 1, 2, 3, ...\n+    struct CountingRng { i: u32 }\n+    impl Rng for CountingRng {\n+        fn next_u32(&mut self) -> u32 {\n+            self.i += 1;\n+            self.i - 1\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            self.next_u32() as u64\n+        }\n+    }\n+\n+    #[test]\n+    fn test_rand_sample() {\n+        let mut rand_sample = RandSample::<ConstRand>;\n+\n+        assert_eq!(*rand_sample.sample(task_rng()), 0);\n+        assert_eq!(*rand_sample.ind_sample(task_rng()), 0);\n+    }\n+\n+    #[test]\n+    fn test_normal() {\n+        let mut norm = Normal::new(10.0, 10.0);\n+        let rng = task_rng();\n+        for _ in range(0, 1000) {\n+            norm.sample(rng);\n+            norm.ind_sample(rng);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_normal_invalid_sd() {\n+        Normal::new(10.0, -1.0);\n+    }\n+\n+    #[test]\n+    fn test_exp() {\n+        let mut exp = Exp::new(10.0);\n+        let rng = task_rng();\n+        for _ in range(0, 1000) {\n+            assert!(exp.sample(rng) >= 0.0);\n+            assert!(exp.ind_sample(rng) >= 0.0);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_zero() {\n+        Exp::new(0.0);\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_neg() {\n+        Exp::new(-10.0);\n+    }\n+\n+    #[test]\n+    fn test_weighted_choice() {\n+        // this makes assumptions about the internal implementation of\n+        // WeightedChoice, specifically: it doesn't reorder the items,\n+        // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n+        // 1, internally; modulo a modulo operation).\n+\n+        macro_rules! t (\n+            ($items:expr, $expected:expr) => {{\n+                let wc = WeightedChoice::new($items);\n+                let expected = $expected;\n+\n+                let mut rng = CountingRng { i: 0 };\n+\n+                for &val in expected.iter() {\n+                    assert_eq!(wc.ind_sample(&mut rng), val)\n+                }\n+            }}\n+        );\n+\n+        t!(~[Weighted { weight: 1, item: 10}], ~[10]);\n+\n+        // skip some\n+        t!(~[Weighted { weight: 0, item: 20},\n+             Weighted { weight: 2, item: 21},\n+             Weighted { weight: 0, item: 22},\n+             Weighted { weight: 1, item: 23}],\n+           ~[21,21, 23]);\n+\n+        // different weights\n+        t!(~[Weighted { weight: 4, item: 30},\n+             Weighted { weight: 3, item: 31}],\n+           ~[30,30,30,30, 31,31,31]);\n+\n+        // check that we're binary searching\n+        // correctly with some vectors of odd\n+        // length.\n+        t!(~[Weighted { weight: 1, item: 40},\n+             Weighted { weight: 1, item: 41},\n+             Weighted { weight: 1, item: 42},\n+             Weighted { weight: 1, item: 43},\n+             Weighted { weight: 1, item: 44}],\n+           ~[40, 41, 42, 43, 44]);\n+        t!(~[Weighted { weight: 1, item: 50},\n+             Weighted { weight: 1, item: 51},\n+             Weighted { weight: 1, item: 52},\n+             Weighted { weight: 1, item: 53},\n+             Weighted { weight: 1, item: 54},\n+             Weighted { weight: 1, item: 55},\n+             Weighted { weight: 1, item: 56}],\n+           ~[50, 51, 52, 53, 54, 55, 56]);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_no_items() {\n+        WeightedChoice::<int>::new(~[]);\n+    }\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_zero_weight() {\n+        WeightedChoice::new(~[Weighted { weight: 0, item: 0},\n+                              Weighted { weight: 0, item: 1}]);\n+    }\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_weight_overflows() {\n+        let x = (-1) as uint / 2; // x + x + 2 is the overflow\n+        WeightedChoice::new(~[Weighted { weight: x, item: 0 },\n+                              Weighted { weight: 1, item: 1 },\n+                              Weighted { weight: x, item: 2 },\n+                              Weighted { weight: 1, item: 3 }]);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+    use mem::size_of;\n+\n+    static N: u64 = 100;\n+\n+    #[bench]\n+    fn rand_normal(bh: &mut BenchHarness) {\n+        let mut rng = XorShiftRng::new();\n+        let mut normal = Normal::new(-2.71828, 3.14159);\n+\n+        do bh.iter {\n+            for _ in range(0, N) {\n+                normal.sample(&mut rng);\n+            }\n+        }\n+        bh.bytes = size_of::<f64>() as u64 * N;\n+    }\n+    #[bench]\n+    fn rand_exp(bh: &mut BenchHarness) {\n+        let mut rng = XorShiftRng::new();\n+        let mut exp = Exp::new(2.71828 * 3.14159);\n+\n+        do bh.iter {\n+            for _ in range(0, N) {\n+                exp.sample(&mut rng);\n+            }\n+        }\n+        bh.bytes = size_of::<f64>() as u64 * N;\n+    }\n+}"}, {"sha": "42254b211a17c1318749ff772a08cca3b25c8323", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -19,10 +19,15 @@ use mem;\n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n-/// A random number generator that uses the [ISAAC\n-/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+/// A random number generator that uses the ISAAC algorithm[1].\n ///\n-/// The ISAAC algorithm is suitable for cryptographic purposes.\n+/// The ISAAC algorithm is generally accepted as suitable for\n+/// cryptographic purposes, but this implementation has not be\n+/// verified as such. Prefer a generator like `OSRng` that defers to\n+/// the operating system for cases that need high security.\n+///\n+/// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n+/// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n pub struct IsaacRng {\n     priv cnt: u32,\n     priv rsl: [u32, .. RAND_SIZE],\n@@ -216,11 +221,16 @@ impl<'self> SeedableRng<&'self [u32]> for IsaacRng {\n static RAND_SIZE_64_LEN: uint = 8;\n static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n \n-/// A random number generator that uses the 64-bit variant of the\n-/// [ISAAC\n-/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+/// A random number generator that uses ISAAC-64[1], the 64-bit\n+/// variant of the ISAAC algorithm.\n+///\n+/// The ISAAC algorithm is generally accepted as suitable for\n+/// cryptographic purposes, but this implementation has not be\n+/// verified as such. Prefer a generator like `OSRng` that defers to\n+/// the operating system for cases that need high security.\n ///\n-/// The ISAAC algorithm is suitable for cryptographic purposes.\n+/// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n+/// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n pub struct Isaac64Rng {\n     priv cnt: uint,\n     priv rsl: [u64, .. RAND_SIZE_64],"}, {"sha": "a6efdfc66db2e2f66bc5aed36f2f914abc779b44", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 78, "deletions": 180, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -28,6 +28,23 @@ from an operating-system source of randomness, e.g. `/dev/urandom` on\n Unix systems, and will automatically reseed itself from this source\n after generating 32 KiB of random data.\n \n+# Cryptographic security\n+\n+An application that requires random numbers for cryptographic purposes\n+should prefer `OSRng`, which reads randomness from one of the source\n+that the operating system provides (e.g. `/dev/urandom` on\n+Unixes). The other random number generators provided by this module\n+are either known to be insecure (`XorShiftRng`), or are not verified\n+to be secure (`IsaacRng`, `Isaac64Rng` and `StdRng`).\n+\n+*Note*: on Linux, `/dev/random` is more secure than `/dev/urandom`,\n+but it is a blocking RNG, and will wait until it has determined that\n+it has collected enough entropy to fulfill a request for random\n+data. It can be used with the `Rng` trait provided by this module by\n+opening the file and passing it to `reader::ReaderRng`. Since it\n+blocks, `/dev/random` should only be used to retrieve small amounts of\n+randomness.\n+\n # Examples\n \n ```rust\n@@ -53,17 +70,20 @@ fn main () {\n */\n \n use cast;\n+use cmp::Ord;\n use container::Container;\n use iter::{Iterator, range};\n use local_data;\n use prelude::*;\n use str;\n-use u64;\n use vec;\n \n pub use self::isaac::{IsaacRng, Isaac64Rng};\n pub use self::os::OSRng;\n \n+use self::distributions::{Range, IndependentSample};\n+use self::distributions::range::SampleRange;\n+\n pub mod distributions;\n pub mod isaac;\n pub mod os;\n@@ -78,14 +98,6 @@ pub trait Rand {\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n-/// A value with a particular weight compared to other values\n-pub struct Weighted<T> {\n-    /// The numerical weight of this item\n-    weight: uint,\n-    /// The actual item which is being weighted\n-    item: T,\n-}\n-\n /// A random number generator\n pub trait Rng {\n     /// Return the next random u32. This rarely needs to be called\n@@ -196,14 +208,14 @@ pub trait Rng {\n         vec::from_fn(len, |_| self.gen())\n     }\n \n-    /// Generate a random primitive integer in the range [`low`,\n-    /// `high`). Fails if `low >= high`.\n+    /// Generate a random value in the range [`low`, `high`). Fails if\n+    /// `low >= high`.\n     ///\n-    /// This gives a uniform distribution (assuming this RNG is itself\n-    /// uniform), even for edge cases like `gen_integer_range(0u8,\n-    /// 170)`, which a naive modulo operation would return numbers\n-    /// less than 85 with double the probability to those greater than\n-    /// 85.\n+    /// This is a convenience wrapper around\n+    /// `distributions::Range`. If this function will be called\n+    /// repeatedly with the same arguments, one should use `Range`, as\n+    /// that will amortize the computations that allow for perfect\n+    /// uniformity, as they only happen on initialization.\n     ///\n     /// # Example\n     ///\n@@ -213,22 +225,15 @@ pub trait Rng {\n     ///\n     /// fn main() {\n     ///    let mut rng = rand::task_rng();\n-    ///    let n: uint = rng.gen_integer_range(0u, 10);\n+    ///    let n: uint = rng.gen_range(0u, 10);\n     ///    println!(\"{}\", n);\n-    ///    let m: int = rng.gen_integer_range(-40, 400);\n+    ///    let m: float = rng.gen_range(-40.0, 1.3e5);\n     ///    println!(\"{}\", m);\n     /// }\n     /// ```\n-    fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n-        assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n-        let range = (high - low).to_u64().unwrap();\n-        let accept_zone = u64::max_value - u64::max_value % range;\n-        loop {\n-            let rand = self.gen::<u64>();\n-            if rand < accept_zone {\n-                return low + NumCast::from(rand % range).unwrap();\n-            }\n-        }\n+    fn gen_range<T: Ord + SampleRange>(&mut self, low: T, high: T) -> T {\n+        assert!(low < high, \"Rng.gen_range called with low >= high\");\n+        Range::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n@@ -245,7 +250,7 @@ pub trait Rng {\n     /// }\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n-        n == 0 || self.gen_integer_range(0, n) == 0\n+        n == 0 || self.gen_range(0, n) == 0\n     }\n \n     /// Return a random string of the specified length composed of\n@@ -295,93 +300,8 @@ pub trait Rng {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(&values[self.gen_integer_range(0u, values.len())])\n-        }\n-    }\n-\n-    /// Choose an item respecting the relative weights, failing if the sum of\n-    /// the weights is 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{}\", rng.choose_weighted(x));\n-    /// }\n-    /// ```\n-    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).expect(\"Rng.choose_weighted: total weight is 0\")\n-    }\n-\n-    /// Choose Some(item) respecting the relative weights, returning none if\n-    /// the sum of the weights is 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{:?}\", rng.choose_weighted_option(x));\n-    /// }\n-    /// ```\n-    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n-                                       -> Option<T> {\n-        let mut total = 0u;\n-        for item in v.iter() {\n-            total += item.weight;\n-        }\n-        if total == 0u {\n-            return None;\n-        }\n-        let chosen = self.gen_integer_range(0u, total);\n-        let mut so_far = 0u;\n-        for item in v.iter() {\n-            so_far += item.weight;\n-            if so_far > chosen {\n-                return Some(item.item.clone());\n-            }\n-        }\n-        unreachable!();\n-    }\n-\n-    /// Return a vec containing copies of the items, in order, where\n-    /// the weight of the item determines how many copies there are\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{}\", rng.weighted_vec(x));\n-    /// }\n-    /// ```\n-    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n-        let mut r = ~[];\n-        for item in v.iter() {\n-            for _ in range(0u, item.weight) {\n-                r.push(item.item.clone());\n-            }\n+            Some(&values[self.gen_range(0u, values.len())])\n         }\n-        r\n     }\n \n     /// Shuffle a vec\n@@ -425,7 +345,7 @@ pub trait Rng {\n             // invariant: elements with index >= i have been locked in place.\n             i -= 1u;\n             // lock element i in place.\n-            values.swap(i, self.gen_integer_range(0u, i + 1u));\n+            values.swap(i, self.gen_range(0u, i + 1u));\n         }\n     }\n \n@@ -451,7 +371,7 @@ pub trait Rng {\n                 continue\n             }\n \n-            let k = self.gen_integer_range(0, i + 1);\n+            let k = self.gen_range(0, i + 1);\n             if k < reservoir.len() {\n                 reservoir[k] = elem\n             }\n@@ -498,8 +418,8 @@ pub trait SeedableRng<Seed>: Rng {\n \n /// Create a random number generator with a default algorithm and seed.\n ///\n-/// It returns the cryptographically-safest `Rng` algorithm currently\n-/// available in Rust. If you require a specifically seeded `Rng` for\n+/// It returns the strongest `Rng` algorithm currently implemented in\n+/// pure Rust. If you require a specifically seeded `Rng` for\n /// consistency over time you should pick one algorithm and create the\n /// `Rng` yourself.\n ///\n@@ -574,12 +494,16 @@ pub fn weak_rng() -> XorShiftRng {\n     XorShiftRng::new()\n }\n \n-/// An [Xorshift random number\n-/// generator](http://en.wikipedia.org/wiki/Xorshift).\n+/// An Xorshift[1] random number\n+/// generator.\n ///\n /// The Xorshift algorithm is not suitable for cryptographic purposes\n /// but is very fast. If you do not know for sure that it fits your\n-/// requirements, use a more secure one such as `IsaacRng`.\n+/// requirements, use a more secure one such as `IsaacRng` or `OSRng`.\n+///\n+/// [1]: Marsaglia, George (July 2003). [\"Xorshift\n+/// RNGs\"](http://www.jstatsoft.org/v08/i14/paper). *Journal of\n+/// Statistical Software*. Vol. 8 (Issue 14).\n pub struct XorShiftRng {\n     priv x: u32,\n     priv y: u32,\n@@ -759,36 +683,36 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_integer_range() {\n+    fn test_gen_range() {\n         let mut r = rng();\n         for _ in range(0, 1000) {\n-            let a = r.gen_integer_range(-3i, 42);\n+            let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_integer_range(0, 1), 0);\n-            assert_eq!(r.gen_integer_range(-12, -11), -12);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(-12, -11), -12);\n         }\n \n         for _ in range(0, 1000) {\n-            let a = r.gen_integer_range(10, 42);\n+            let a = r.gen_range(10, 42);\n             assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_integer_range(0, 1), 0);\n-            assert_eq!(r.gen_integer_range(3_000_000u, 3_000_001), 3_000_000);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n         }\n \n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_integer_range_fail_int() {\n+    fn test_gen_range_fail_int() {\n         let mut r = rng();\n-        r.gen_integer_range(5i, -2);\n+        r.gen_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_integer_range_fail_uint() {\n+    fn test_gen_range_fail_uint() {\n         let mut r = rng();\n-        r.gen_integer_range(5u, 2u);\n+        r.gen_range(5u, 2u);\n     }\n \n     #[test]\n@@ -842,44 +766,6 @@ mod test {\n         assert_eq!(r.choose_option(v), Some(&i));\n     }\n \n-    #[test]\n-    fn test_choose_weighted() {\n-        let mut r = rng();\n-        assert!(r.choose_weighted([\n-            Weighted { weight: 1u, item: 42 },\n-        ]) == 42);\n-        assert!(r.choose_weighted([\n-            Weighted { weight: 0u, item: 42 },\n-            Weighted { weight: 1u, item: 43 },\n-        ]) == 43);\n-    }\n-\n-    #[test]\n-    fn test_choose_weighted_option() {\n-        let mut r = rng();\n-        assert!(r.choose_weighted_option([\n-            Weighted { weight: 1u, item: 42 },\n-        ]) == Some(42));\n-        assert!(r.choose_weighted_option([\n-            Weighted { weight: 0u, item: 42 },\n-            Weighted { weight: 1u, item: 43 },\n-        ]) == Some(43));\n-        let v: Option<int> = r.choose_weighted_option([]);\n-        assert!(v.is_none());\n-    }\n-\n-    #[test]\n-    fn test_weighted_vec() {\n-        let mut r = rng();\n-        let empty: ~[int] = ~[];\n-        assert_eq!(r.weighted_vec([]), empty);\n-        assert!(r.weighted_vec([\n-            Weighted { weight: 0u, item: 3u },\n-            Weighted { weight: 1u, item: 2u },\n-            Weighted { weight: 2u, item: 1u },\n-        ]) == ~[2u, 1u, 1u]);\n-    }\n-\n     #[test]\n     fn test_shuffle() {\n         let mut r = rng();\n@@ -893,7 +779,7 @@ mod test {\n         let mut r = task_rng();\n         r.gen::<int>();\n         assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n-        assert_eq!(r.gen_integer_range(0u, 1u), 0u);\n+        assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n \n     #[test]\n@@ -952,41 +838,53 @@ mod bench {\n     use extra::test::BenchHarness;\n     use rand::*;\n     use mem::size_of;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    static N: u64 = 100;\n \n     #[bench]\n     fn rand_xorshift(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]\n     fn rand_isaac(bh: &mut BenchHarness) {\n         let mut rng = IsaacRng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]\n     fn rand_isaac64(bh: &mut BenchHarness) {\n         let mut rng = Isaac64Rng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]\n     fn rand_std(bh: &mut BenchHarness) {\n         let mut rng = StdRng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]"}, {"sha": "5ed8d6b10d1be2f364eafde183d59b37ce936f30", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -30,17 +30,25 @@ type HCRYPTPROV = c_long;\n // assume they work when we call them.\n \n /// A random number generator that retrieves randomness straight from\n-/// the operating system. On Unix-like systems this reads from\n-/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+/// the operating system. Platform sources:\n+///\n+/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+///   `/dev/urandom`.\n+/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+///   service provider with the `PROV_RSA_FULL` type.\n ///\n /// This does not block.\n #[cfg(unix)]\n pub struct OSRng {\n     priv inner: ReaderRng<file::FileStream>\n }\n /// A random number generator that retrieves randomness straight from\n-/// the operating system. On Unix-like systems this reads from\n-/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+/// the operating system. Platform sources:\n+///\n+/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+///   `/dev/urandom`.\n+/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+///   service provider with the `PROV_RSA_FULL` type.\n ///\n /// This does not block.\n #[cfg(windows)]"}, {"sha": "1b805a0b8f7638a57fb71c9f500651d112df1572", "filename": "src/libstd/rand/range.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frand%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frange.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generating numbers between two others.\n+\n+// this is surprisingly complicated to be both generic & correct\n+\n+use cmp::Ord;\n+use num::Bounded;\n+use rand::Rng;\n+use rand::distributions::{Sample, IndependentSample};\n+\n+/// Sample values uniformly between two bounds.\n+///\n+/// This gives a uniform distribution (assuming the RNG used to sample\n+/// it is itself uniform & the `SampleRange` implementation for the\n+/// given type is correct), even for edge cases like `low = 0u8`,\n+/// `high = 170u8`, for which a naive modulo operation would return\n+/// numbers less than 85 with double the probability to those greater\n+/// than 85.\n+///\n+/// Types should attempt to sample in `[low, high)`, i.e., not\n+/// including `high`, but this may be very difficult. All the\n+/// primitive integer types satisfy this property, and the float types\n+/// normally satisfy it, but rounding may mean `high` can occur.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{IndependentSample, Range};\n+///\n+/// fn main() {\n+///     let between = Range::new(10u, 10000u);\n+///     let rng = rand::task_rng();\n+///     let mut sum = 0;\n+///     for _ in range(0, 1000) {\n+///         sum += between.ind_sample(rng);\n+///     }\n+///     println!(\"{}\", sum);\n+/// }\n+/// ```\n+pub struct Range<X> {\n+    priv low: X,\n+    priv range: X,\n+    priv accept_zone: X\n+}\n+\n+impl<X: SampleRange + Ord> Range<X> {\n+    /// Create a new `Range` instance that samples uniformly from\n+    /// `[low, high)`. Fails if `low >= high`.\n+    pub fn new(low: X, high: X) -> Range<X> {\n+        assert!(low < high, \"Range::new called with `low >= high`\");\n+        SampleRange::construct_range(low, high)\n+    }\n+}\n+\n+impl<Sup: SampleRange> Sample<Sup> for Range<Sup> {\n+    #[inline]\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+}\n+impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n+        SampleRange::sample_range(self, rng)\n+    }\n+}\n+\n+/// The helper trait for types that have a sensible way to sample\n+/// uniformly between two values. This should not be used directly,\n+/// and is only to facilitate `Range`.\n+pub trait SampleRange {\n+    /// Construct the `Range` object that `sample_range`\n+    /// requires. This should not ever be called directly, only via\n+    /// `Range::new`, which will check that `low < high`, so this\n+    /// function doesn't have to repeat the check.\n+    fn construct_range(low: Self, high: Self) -> Range<Self>;\n+\n+    /// Sample a value from the given `Range` with the given `Rng` as\n+    /// a source of randomness.\n+    fn sample_range<R: Rng>(r: &Range<Self>, rng: &mut R) -> Self;\n+}\n+\n+macro_rules! integer_impl {\n+    ($ty:ty, $unsigned:ty) => {\n+        impl SampleRange for $ty {\n+            // we play free and fast with unsigned vs signed here\n+            // (when $ty is signed), but that's fine, since the\n+            // contract of this macro is for $ty and $unsigned to be\n+            // \"bit-equal\", so casting between them is a no-op & a\n+            // bijection.\n+\n+            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n+                let range = high as $unsigned - low as $unsigned;\n+                let unsigned_max: $unsigned = Bounded::max_value();\n+\n+                // this is the largest number that fits into $unsigned\n+                // that `range` divides evenly, so, if we've sampled\n+                // `n` uniformly from this region, then `n % range` is\n+                // uniform in [0, range)\n+                let zone = unsigned_max - unsigned_max % range;\n+\n+                Range {\n+                    low: low,\n+                    range: range as $ty,\n+                    accept_zone: zone as $ty\n+                }\n+            }\n+            #[inline]\n+            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n+                loop {\n+                    // rejection sample\n+                    let v = rng.gen::<$unsigned>();\n+                    // until we find something that fits into the\n+                    // region which r.range evenly divides (this will\n+                    // be uniformly distributed)\n+                    if v < r.accept_zone as $unsigned {\n+                        // and return it, with some adjustments\n+                        return r.low + (v % r.range as $unsigned) as $ty;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+integer_impl! { i8, u8 }\n+integer_impl! { i16, u16 }\n+integer_impl! { i32, u32 }\n+integer_impl! { i64, u64 }\n+integer_impl! { int, uint }\n+integer_impl! { u8, u8 }\n+integer_impl! { u16, u16 }\n+integer_impl! { u32, u32 }\n+integer_impl! { u64, u64 }\n+integer_impl! { uint, uint }\n+\n+macro_rules! float_impl {\n+    ($ty:ty) => {\n+        impl SampleRange for $ty {\n+            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n+                Range {\n+                    low: low,\n+                    range: high - low,\n+                    accept_zone: 0.0 // unused\n+                }\n+            }\n+            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n+                r.low + r.range * rng.gen()\n+            }\n+        }\n+    }\n+}\n+\n+float_impl! { f32 }\n+float_impl! { f64 }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use rand::*;\n+    use num::Bounded;\n+    use iter::range;\n+    use option::{Some, None};\n+    use vec::ImmutableVector;\n+\n+    #[should_fail]\n+    #[test]\n+    fn test_range_bad_limits_equal() {\n+        Range::new(10, 10);\n+    }\n+    #[should_fail]\n+    #[test]\n+    fn test_range_bad_limits_flipped() {\n+        Range::new(10, 5);\n+    }\n+\n+    #[test]\n+    fn test_integers() {\n+        let rng = task_rng();\n+        macro_rules! t (\n+            ($($ty:ty),*) => {{\n+                $(\n+                   let v: &[($ty, $ty)] = [(0, 10),\n+                                           (10, 127),\n+                                           (Bounded::min_value(), Bounded::max_value())];\n+                   for &(low, high) in v.iter() {\n+                        let mut sampler: Range<$ty> = Range::new(low, high);\n+                        for _ in range(0, 1000) {\n+                            let v = sampler.sample(rng);\n+                            assert!(low <= v && v < high);\n+                            let v = sampler.ind_sample(rng);\n+                            assert!(low <= v && v < high);\n+                        }\n+                    }\n+                 )*\n+            }}\n+        );\n+        t!(i8, i16, i32, i64, int,\n+           u8, u16, u32, u64, uint)\n+    }\n+\n+    #[test]\n+    fn test_floats() {\n+        let rng = task_rng();\n+        macro_rules! t (\n+            ($($ty:ty),*) => {{\n+                $(\n+                   let v: &[($ty, $ty)] = [(0.0, 100.0),\n+                                           (-1e35, -1e25),\n+                                           (1e-35, 1e-25),\n+                                           (-1e35, 1e35)];\n+                   for &(low, high) in v.iter() {\n+                        let mut sampler: Range<$ty> = Range::new(low, high);\n+                        for _ in range(0, 1000) {\n+                            let v = sampler.sample(rng);\n+                            assert!(low <= v && v < high);\n+                            let v = sampler.ind_sample(rng);\n+                            assert!(low <= v && v < high);\n+                        }\n+                    }\n+                 )*\n+            }}\n+        );\n+\n+        t!(f32, f64)\n+    }\n+\n+}"}, {"sha": "6319fdead17da442e186c925838ad12d06bfb6f0", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -1117,7 +1117,7 @@ mod test {\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n             do total.times {\n-                let msgs = rng.gen_integer_range(0u, 10);\n+                let msgs = rng.gen_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {"}, {"sha": "ee163bab3c062c8a8beead2016ab55604423a243", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -431,7 +431,7 @@ impl Scheduler {\n     fn try_steals(&mut self) -> Option<~Task> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n-        let start_index = self.rng.gen_integer_range(0, len);\n+        let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n             match work_queues[index].steal() {\n                 Some(task) => {"}, {"sha": "77020537661600115a4e2565895f243257626c53", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -672,6 +672,8 @@ extern \"C\" CDECL void\n rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n     win32_require\n         (_T(\"CryptAcquireContext\"),\n+         // changes to the parameters here should be reflected in the docs of\n+         // std::rand::os::OSRng\n          CryptAcquireContext(phProv, NULL, NULL, PROV_RSA_FULL,\n                              CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n "}, {"sha": "dbd1edffe7827ce09960d51bd631814574ad70e7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ec8af4c549bd806522826b756e18fbf0b5c47b/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=a4ec8af4c549bd806522826b756e18fbf0b5c47b", "patch": "@@ -90,7 +90,7 @@ fn vec_plus() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n@@ -106,7 +106,7 @@ fn vec_append() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v = vec::append(v, rv);\n         }\n@@ -122,7 +122,7 @@ fn vec_push_all() {\n \n     let mut v = ~[];\n     for i in range(0u, 1500) {\n-        let mut rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let mut rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n         }"}]}