{"sha": "fe8f02690804d5ee696bd3bca9515f5f71857e3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOGYwMjY5MDgwNGQ1ZWU2OTZiZDNiY2E5NTE1ZjVmNzE4NTdlM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-09T00:36:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-09T00:36:58Z"}, "message": "Auto merge of #78889 - Dylan-DPC:rollup-6zjhahf, r=Dylan-DPC\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #77640 (Refactor IntErrorKind to avoid \"underflow\" terminology)\n - #78026 (Define `fs::hard_link` to not follow symlinks.)\n - #78114 (Recognize `private_intra_doc_links` as a lint)\n - #78228 (Promote aarch64-unknown-linux-gnu to Tier 1)\n - #78345 (Fix handling of item names for HIR)\n - #78437 (BTreeMap: stop mistaking node for an orderly place)\n - #78476 (fix some incorrect aliasing in the BTree)\n - #78674 (inliner: Use substs_for_mir_body)\n - #78748 (Implement destructuring assignment for tuples)\n - #78868 (Fix tab focus on restyled switches)\n - #78878 (Avoid overlapping cfg attributes when both macOS and aarch64)\n - #78882 (Nicer hunk headers for rust files)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9cc07f8445977fac41e92110426c83ae0a8b7aa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cc07f8445977fac41e92110426c83ae0a8b7aa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe8f02690804d5ee696bd3bca9515f5f71857e3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8f02690804d5ee696bd3bca9515f5f71857e3b", "html_url": "https://github.com/rust-lang/rust/commit/fe8f02690804d5ee696bd3bca9515f5f71857e3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe8f02690804d5ee696bd3bca9515f5f71857e3b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "html_url": "https://github.com/rust-lang/rust/commit/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1"}, {"sha": "92adac9b10e4890124b80eecbcf44dd22e9c92e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/92adac9b10e4890124b80eecbcf44dd22e9c92e6", "html_url": "https://github.com/rust-lang/rust/commit/92adac9b10e4890124b80eecbcf44dd22e9c92e6"}], "stats": {"total": 1188, "additions": 797, "deletions": 391}, "files": [{"sha": "2c5c37007d5bc1c2dc03adaeff3ba6399ba67fa1", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -3,7 +3,7 @@\n * text=auto eol=lf\n *.cpp rust\n *.h rust\n-*.rs rust\n+*.rs rust diff=rust\n *.fixed linguist-language=Rust\n src/etc/installer/gfx/* binary\n *.woff binary"}, {"sha": "0d4e0e5b06b237f56cb0b0159d22f444cdb61522", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 5, "deletions": 110, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -154,6 +154,11 @@ jobs:\n     strategy:\n       matrix:\n         include:\n+          - name: aarch64-gnu\n+            os:\n+              - self-hosted\n+              - ARM64\n+              - linux\n           - name: arm-android\n             os: ubuntu-latest-xl\n             env: {}\n@@ -497,116 +502,6 @@ jobs:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n-  auto-fallible:\n-    name: auto-fallible\n-    env:\n-      CI_JOB_NAME: \"${{ matrix.name }}\"\n-      SCCACHE_BUCKET: rust-lang-gha-caches\n-      DEPLOY_BUCKET: rust-lang-gha\n-      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n-      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n-      TOOLSTATE_PUBLISH: 1\n-      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n-      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n-      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n-    if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n-    strategy:\n-      fail-fast: false\n-      matrix:\n-        include:\n-          - name: aarch64-gnu\n-            os:\n-              - self-hosted\n-              - ARM64\n-              - linux\n-    timeout-minutes: 600\n-    runs-on: \"${{ matrix.os }}\"\n-    steps:\n-      - name: disable git crlf conversion\n-        run: git config --global core.autocrlf false\n-      - name: checkout the source code\n-        uses: actions/checkout@v2\n-        with:\n-          fetch-depth: 2\n-      - name: configure the PR in which the error message will be posted\n-        run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n-        env:\n-          num: \"${{ github.event.number }}\"\n-        if: \"success() && !env.SKIP_JOBS && github.event_name == 'pull_request'\"\n-      - name: add extra environment variables\n-        run: src/ci/scripts/setup-environment.sh\n-        env:\n-          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: decide whether to skip this job\n-        run: src/ci/scripts/should-skip-this.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: configure GitHub Actions to kill the build when outdated\n-        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n-        with:\n-          github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n-      - name: collect CPU statistics\n-        run: src/ci/scripts/collect-cpu-stats.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: show the current environment\n-        run: src/ci/scripts/dump-environment.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install sccache\n-        run: src/ci/scripts/install-sccache.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: select Xcode\n-        run: src/ci/scripts/select-xcode.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install clang\n-        run: src/ci/scripts/install-clang.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install WIX\n-        run: src/ci/scripts/install-wix.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: ensure the build happens on a partition with enough space\n-        run: src/ci/scripts/symlink-build-dir.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: disable git crlf conversion\n-        run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install MSYS2\n-        run: src/ci/scripts/install-msys2.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install MinGW\n-        run: src/ci/scripts/install-mingw.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: install ninja\n-        run: src/ci/scripts/install-ninja.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: enable ipv6 on Docker\n-        run: src/ci/scripts/enable-docker-ipv6.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: disable git crlf conversion\n-        run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: checkout submodules\n-        run: src/ci/scripts/checkout-submodules.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: ensure line endings are correct\n-        run: src/ci/scripts/verify-line-endings.sh\n-        if: success() && !env.SKIP_JOB\n-      - name: run the build\n-        run: src/ci/scripts/run-build-from-ci.sh\n-        env:\n-          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n-          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n-          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: upload artifacts to S3\n-        run: src/ci/scripts/upload-artifacts.sh\n-        env:\n-          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n-          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n-        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n   try:\n     name: try\n     env:"}, {"sha": "1f2aba2b27e685a8acc74cf6dbdd093cfa895fcd", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_session::parse::feature_err;\n use rustc_span::hygiene::ForLoopLoc;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -146,7 +147,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n                 }\n                 ExprKind::Assign(ref el, ref er, span) => {\n-                    hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n+                    self.lower_expr_assign(el, er, span, e.span)\n                 }\n                 ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                     self.lower_binop(op),\n@@ -840,6 +841,134 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         })\n     }\n \n+    /// Destructure the LHS of complex assignments.\n+    /// For instance, lower `(a, b) = t` to `{ let (lhs1, lhs2) = t; a = lhs1; b = lhs2; }`.\n+    fn lower_expr_assign(\n+        &mut self,\n+        lhs: &Expr,\n+        rhs: &Expr,\n+        eq_sign_span: Span,\n+        whole_span: Span,\n+    ) -> hir::ExprKind<'hir> {\n+        // Return early in case of an ordinary assignment.\n+        fn is_ordinary(lhs: &Expr) -> bool {\n+            match &lhs.kind {\n+                ExprKind::Tup(..) => false,\n+                ExprKind::Paren(e) => {\n+                    match e.kind {\n+                        // We special-case `(..)` for consistency with patterns.\n+                        ExprKind::Range(None, None, RangeLimits::HalfOpen) => false,\n+                        _ => is_ordinary(e),\n+                    }\n+                }\n+                _ => true,\n+            }\n+        }\n+        if is_ordinary(lhs) {\n+            return hir::ExprKind::Assign(self.lower_expr(lhs), self.lower_expr(rhs), eq_sign_span);\n+        }\n+        if !self.sess.features_untracked().destructuring_assignment {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::destructuring_assignment,\n+                eq_sign_span,\n+                \"destructuring assignments are unstable\",\n+            )\n+            .span_label(lhs.span, \"cannot assign to this expression\")\n+            .emit();\n+        }\n+\n+        let mut assignments = vec![];\n+\n+        // The LHS becomes a pattern: `(lhs1, lhs2)`.\n+        let pat = self.destructure_assign(lhs, eq_sign_span, &mut assignments);\n+        let rhs = self.lower_expr(rhs);\n+\n+        // Introduce a `let` for destructuring: `let (lhs1, lhs2) = t`.\n+        let destructure_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            whole_span,\n+            Some(rhs),\n+            pat,\n+            hir::LocalSource::AssignDesugar(eq_sign_span),\n+        );\n+\n+        // `a = lhs1; b = lhs2;`.\n+        let stmts = self\n+            .arena\n+            .alloc_from_iter(std::iter::once(destructure_let).chain(assignments.into_iter()));\n+\n+        // Wrap everything in a block.\n+        hir::ExprKind::Block(&self.block_all(whole_span, stmts, None), None)\n+    }\n+\n+    /// Convert the LHS of a destructuring assignment to a pattern.\n+    /// Each sub-assignment is recorded in `assignments`.\n+    fn destructure_assign(\n+        &mut self,\n+        lhs: &Expr,\n+        eq_sign_span: Span,\n+        assignments: &mut Vec<hir::Stmt<'hir>>,\n+    ) -> &'hir hir::Pat<'hir> {\n+        match &lhs.kind {\n+            // Tuples.\n+            ExprKind::Tup(elements) => {\n+                let (pats, rest) =\n+                    self.destructure_sequence(elements, \"tuple\", eq_sign_span, assignments);\n+                let tuple_pat = hir::PatKind::Tuple(pats, rest.map(|r| r.0));\n+                return self.pat_without_dbm(lhs.span, tuple_pat);\n+            }\n+            ExprKind::Paren(e) => {\n+                // We special-case `(..)` for consistency with patterns.\n+                if let ExprKind::Range(None, None, RangeLimits::HalfOpen) = e.kind {\n+                    let tuple_pat = hir::PatKind::Tuple(&[], Some(0));\n+                    return self.pat_without_dbm(lhs.span, tuple_pat);\n+                } else {\n+                    return self.destructure_assign(e, eq_sign_span, assignments);\n+                }\n+            }\n+            _ => {}\n+        }\n+        // Treat all other cases as normal lvalue.\n+        let ident = Ident::new(sym::lhs, lhs.span);\n+        let (pat, binding) = self.pat_ident(lhs.span, ident);\n+        let ident = self.expr_ident(lhs.span, ident, binding);\n+        let assign = hir::ExprKind::Assign(self.lower_expr(lhs), ident, eq_sign_span);\n+        let expr = self.expr(lhs.span, assign, ThinVec::new());\n+        assignments.push(self.stmt_expr(lhs.span, expr));\n+        pat\n+    }\n+\n+    /// Destructure a sequence of expressions occurring on the LHS of an assignment.\n+    /// Such a sequence occurs in a tuple (struct)/slice.\n+    /// Return a sequence of corresponding patterns, and the index and the span of `..` if it\n+    /// exists.\n+    /// Each sub-assignment is recorded in `assignments`.\n+    fn destructure_sequence(\n+        &mut self,\n+        elements: &[AstP<Expr>],\n+        ctx: &str,\n+        eq_sign_span: Span,\n+        assignments: &mut Vec<hir::Stmt<'hir>>,\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<(usize, Span)>) {\n+        let mut rest = None;\n+        let elements =\n+            self.arena.alloc_from_iter(elements.iter().enumerate().filter_map(|(i, e)| {\n+                // Check for `..` pattern.\n+                if let ExprKind::Range(None, None, RangeLimits::HalfOpen) = e.kind {\n+                    if let Some((_, prev_span)) = rest {\n+                        self.ban_extra_rest_pat(e.span, prev_span, ctx);\n+                    } else {\n+                        rest = Some((i, e.span));\n+                    }\n+                    None\n+                } else {\n+                    Some(self.destructure_assign(e, eq_sign_span, assignments))\n+                }\n+            }));\n+        (elements, rest)\n+    }\n+\n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n     fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n         let e1 = self.lower_expr_mut(e1);"}, {"sha": "af2f96d5e62535a8e4356021627b4c1af38f4d98", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -2531,6 +2531,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir_id,\n                 kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n+                default_binding_modes: true,\n             }),\n             hir_id,\n         )\n@@ -2541,7 +2542,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.next_id(), kind, span })\n+        self.arena.alloc(hir::Pat {\n+            hir_id: self.next_id(),\n+            kind,\n+            span,\n+            default_binding_modes: true,\n+        })\n+    }\n+\n+    fn pat_without_dbm(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat {\n+            hir_id: self.next_id(),\n+            kind,\n+            span,\n+            default_binding_modes: false,\n+        })\n     }\n \n     fn ty_path("}, {"sha": "e4e7b24d29e5262b02ced0ebf7acd28b5e51451a", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -273,11 +273,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n     fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+        self.arena.alloc(hir::Pat {\n+            hir_id: self.lower_node_id(p.id),\n+            kind,\n+            span: p.span,\n+            default_binding_modes: true,\n+        })\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+    crate fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n         self.diagnostic()\n             .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n             .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))"}, {"sha": "466758f2f86f5a14613cb7d55762589ed352760d", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -361,13 +361,11 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n     where\n         T: TypeFoldable<'tcx> + Copy,\n     {\n-        if let Some(substs) = self.instance.substs_for_mir_body() {\n-            self.tcx\n-                .subst_and_normalize_erasing_regions(substs, ty::ParamEnv::reveal_all(), value)\n-        } else {\n-            self.tcx\n-                .normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n-        }\n+        self.instance.subst_mir_and_normalize_erasing_regions(\n+            self.tcx,\n+            ty::ParamEnv::reveal_all(),\n+            value\n+        )\n     }\n \n     pub(crate) fn clif_type(&self, ty: Ty<'tcx>) -> Option<Type> {"}, {"sha": "01fd1681593e885cd0b659afbb730fbd1055147e", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -92,15 +92,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         T: Copy + TypeFoldable<'tcx>,\n     {\n         debug!(\"monomorphize: self.instance={:?}\", self.instance);\n-        if let Some(substs) = self.instance.substs_for_mir_body() {\n-            self.cx.tcx().subst_and_normalize_erasing_regions(\n-                substs,\n-                ty::ParamEnv::reveal_all(),\n-                &value,\n-            )\n-        } else {\n-            self.cx.tcx().normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n-        }\n+        self.instance.subst_mir_and_normalize_erasing_regions(\n+            self.cx.tcx(),\n+            ty::ParamEnv::reveal_all(),\n+            value,\n+        )\n     }\n }\n "}, {"sha": "84114fc773533256c14d768c8fd83c06ca50abad", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -610,6 +610,9 @@ declare_features! (\n     /// Allows unsized fn parameters.\n     (active, unsized_fn_params, \"1.49.0\", Some(48055), None),\n \n+    /// Allows the use of destructuring assignments.\n+    (active, destructuring_assignment, \"1.49.0\", Some(71126), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "3c28b48795f56793dfc58ab0cab9fd3b3d3941b6", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -732,6 +732,9 @@ pub struct Pat<'hir> {\n     pub hir_id: HirId,\n     pub kind: PatKind<'hir>,\n     pub span: Span,\n+    // Whether to use default binding modes.\n+    // At present, this is false only for destructuring assignment.\n+    pub default_binding_modes: bool,\n }\n \n impl Pat<'_> {\n@@ -1680,6 +1683,9 @@ pub enum LocalSource {\n     AsyncFn,\n     /// A desugared `<expr>.await`.\n     AwaitDesugar,\n+    /// A desugared `expr = expr`, where the LHS is a tuple, struct or array.\n+    /// The span is that of the `=` sign.\n+    AssignDesugar(Span),\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n@@ -2677,6 +2683,9 @@ impl<'hir> Node<'hir> {\n             Node::TraitItem(TraitItem { ident, .. })\n             | Node::ImplItem(ImplItem { ident, .. })\n             | Node::ForeignItem(ForeignItem { ident, .. })\n+            | Node::Field(StructField { ident, .. })\n+            | Node::Variant(Variant { ident, .. })\n+            | Node::MacroDef(MacroDef { ident, .. })\n             | Node::Item(Item { ident, .. }) => Some(*ident),\n             _ => None,\n         }"}, {"sha": "1d0d6980b7a89dea87a10e1715654c9018e4cb5b", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -2801,6 +2801,7 @@ declare_lint_pass! {\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n         BROKEN_INTRA_DOC_LINKS,\n+        PRIVATE_INTRA_DOC_LINKS,\n         INVALID_CODEBLOCK_ATTRIBUTES,\n         MISSING_CRATE_LEVEL_DOCS,\n         MISSING_DOC_CODE_EXAMPLES,"}, {"sha": "d86e8987195570fb4b1c30dc1a527c37ea6d89ea", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -478,7 +478,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        id.as_local().map(|id| self.get(self.local_def_id_to_hir_id(id)))\n+        id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {"}, {"sha": "41342764ba773b299db01e39e2786280c6fef1b1", "filename": "compiler/rustc_middle/src/middle/limits.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -48,10 +48,12 @@ fn update_limit(\n                         .unwrap_or(attr.span);\n \n                     let error_str = match e.kind() {\n-                        IntErrorKind::Overflow => \"`limit` is too large\",\n+                        IntErrorKind::PosOverflow => \"`limit` is too large\",\n                         IntErrorKind::Empty => \"`limit` must be a non-negative integer\",\n                         IntErrorKind::InvalidDigit => \"not a valid integer\",\n-                        IntErrorKind::Underflow => bug!(\"`limit` should never underflow\"),\n+                        IntErrorKind::NegOverflow => {\n+                            bug!(\"`limit` should never negatively overflow\")\n+                        }\n                         IntErrorKind::Zero => bug!(\"zero is a valid `limit`\"),\n                         kind => bug!(\"unimplemented IntErrorKind variant: {:?}\", kind),\n                     };"}, {"sha": "306cebd9cb72221d54741af08d5c5103015806aa", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1,6 +1,6 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::subst::InternalSubsts;\n+use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeFoldable};\n use rustc_errors::ErrorReported;\n use rustc_hir::def::Namespace;\n@@ -470,10 +470,33 @@ impl<'tcx> Instance<'tcx> {\n     /// This function returns `Some(substs)` in the former case and `None` otherwise -- i.e., if\n     /// this function returns `None`, then the MIR body does not require substitution during\n     /// codegen.\n-    pub fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n+    fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n         if self.def.has_polymorphic_mir_body() { Some(self.substs) } else { None }\n     }\n \n+    pub fn subst_mir<T>(&self, tcx: TyCtxt<'tcx>, v: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx> + Copy,\n+    {\n+        if let Some(substs) = self.substs_for_mir_body() { v.subst(tcx, substs) } else { *v }\n+    }\n+\n+    pub fn subst_mir_and_normalize_erasing_regions<T>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        v: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx> + Clone,\n+    {\n+        if let Some(substs) = self.substs_for_mir_body() {\n+            tcx.subst_and_normalize_erasing_regions(substs, param_env, v)\n+        } else {\n+            tcx.normalize_erasing_regions(param_env, v.clone())\n+        }\n+    }\n+\n     /// Returns a new `Instance` where generic parameters in `instance.substs` are replaced by\n     /// identify parameters if they are determined to be unused in `instance.def`.\n     pub fn polymorphize(self, tcx: TyCtxt<'tcx>) -> Self {"}, {"sha": "0042b4a3a42793aa2fb545b12a182604b2aa27d6", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -2795,10 +2795,50 @@ impl<'tcx> TyCtxt<'tcx> {\n             .filter(|item| item.kind == AssocKind::Fn && item.defaultness.has_value())\n     }\n \n+    fn item_name_from_hir(self, def_id: DefId) -> Option<Ident> {\n+        self.hir().get_if_local(def_id).and_then(|node| node.ident())\n+    }\n+\n+    fn item_name_from_def_id(self, def_id: DefId) -> Option<Symbol> {\n+        if def_id.index == CRATE_DEF_INDEX {\n+            Some(self.original_crate_name(def_id.krate))\n+        } else {\n+            let def_key = self.def_key(def_id);\n+            match def_key.disambiguated_data.data {\n+                // The name of a constructor is that of its parent.\n+                rustc_hir::definitions::DefPathData::Ctor => self.item_name_from_def_id(DefId {\n+                    krate: def_id.krate,\n+                    index: def_key.parent.unwrap(),\n+                }),\n+                _ => def_key.disambiguated_data.data.get_opt_name(),\n+            }\n+        }\n+    }\n+\n+    /// Look up the name of an item across crates. This does not look at HIR.\n+    ///\n+    /// When possible, this function should be used for cross-crate lookups over\n+    /// [`opt_item_name`] to avoid invalidating the incremental cache. If you\n+    /// need to handle items without a name, or HIR items that will not be\n+    /// serialized cross-crate, or if you need the span of the item, use\n+    /// [`opt_item_name`] instead.\n+    ///\n+    /// [`opt_item_name`]: Self::opt_item_name\n+    pub fn item_name(self, id: DefId) -> Symbol {\n+        // Look at cross-crate items first to avoid invalidating the incremental cache\n+        // unless we have to.\n+        self.item_name_from_def_id(id).unwrap_or_else(|| {\n+            bug!(\"item_name: no name for {:?}\", self.def_path(id));\n+        })\n+    }\n+\n+    /// Look up the name and span of an item or [`Node`].\n+    ///\n+    /// See [`item_name`][Self::item_name] for more information.\n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n-        def_id\n-            .as_local()\n-            .and_then(|def_id| self.hir().get(self.hir().local_def_id_to_hir_id(def_id)).ident())\n+        // Look at the HIR first so the span will be correct if this is a local item.\n+        self.item_name_from_hir(def_id)\n+            .or_else(|| self.item_name_from_def_id(def_id).map(Ident::with_dummy_span))\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<&'tcx AssocItem> {\n@@ -2921,23 +2961,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn item_name(self, id: DefId) -> Symbol {\n-        if id.index == CRATE_DEF_INDEX {\n-            self.original_crate_name(id.krate)\n-        } else {\n-            let def_key = self.def_key(id);\n-            match def_key.disambiguated_data.data {\n-                // The name of a constructor is that of its parent.\n-                rustc_hir::definitions::DefPathData::Ctor => {\n-                    self.item_name(DefId { krate: id.krate, index: def_key.parent.unwrap() })\n-                }\n-                _ => def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n-                    bug!(\"item_name: no name for {:?}\", self.def_path(id));\n-                }),\n-            }\n-        }\n-    }\n-\n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {"}, {"sha": "0f86a181a55f7197acb9068e09ed116dbf4c44f7", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -505,11 +505,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         value: T,\n     ) -> T {\n-        if let Some(substs) = frame.instance.substs_for_mir_body() {\n-            self.tcx.subst_and_normalize_erasing_regions(substs, self.param_env, &value)\n-        } else {\n-            self.tcx.normalize_erasing_regions(self.param_env, value)\n-        }\n+        frame.instance.subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, &value)\n     }\n \n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env)."}, {"sha": "938181abff244cfad0ba8c1c6b613c26671143a6", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -543,11 +543,11 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         debug!(\"monomorphize: self.instance={:?}\", self.instance);\n-        if let Some(substs) = self.instance.substs_for_mir_body() {\n-            self.tcx.subst_and_normalize_erasing_regions(substs, ty::ParamEnv::reveal_all(), &value)\n-        } else {\n-            self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), value)\n-        }\n+        self.instance.subst_mir_and_normalize_erasing_regions(\n+            self.tcx,\n+            ty::ParamEnv::reveal_all(),\n+            &value,\n+        )\n     }\n }\n "}, {"sha": "a41304236b23dd5ae4fa73615a25189835a793ca", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -6,7 +6,6 @@ use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_span::{hygiene::ExpnKind, ExpnData, Span};\n use rustc_target::spec::abi::Abi;\n@@ -128,17 +127,15 @@ impl Inliner<'tcx> {\n                 self.tcx.instance_mir(callsite.callee.def)\n             };\n \n-            let callee_body: &Body<'tcx> = &*callee_body;\n-\n-            let callee_body = if self.consider_optimizing(callsite, callee_body) {\n-                self.tcx.subst_and_normalize_erasing_regions(\n-                    &callsite.callee.substs,\n-                    self.param_env,\n-                    callee_body,\n-                )\n-            } else {\n+            if !self.consider_optimizing(callsite, &callee_body) {\n                 continue;\n-            };\n+            }\n+\n+            let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n+                self.tcx,\n+                self.param_env,\n+                callee_body,\n+            );\n \n             let start = caller_body.basic_blocks().len();\n             debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n@@ -309,7 +306,7 @@ impl Inliner<'tcx> {\n                     work_list.push(target);\n                     // If the place doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.callee.substs).ty;\n+                    let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n                     if ty.needs_drop(tcx, self.param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -371,8 +368,7 @@ impl Inliner<'tcx> {\n         let ptr_size = tcx.data_layout.pointer_size.bytes();\n \n         for v in callee_body.vars_and_temps_iter() {\n-            let v = &callee_body.local_decls[v];\n-            let ty = v.ty.subst(tcx, callsite.callee.substs);\n+            let ty = callsite.callee.subst_mir(self.tcx, &callee_body.local_decls[v].ty);\n             // Cost of the var is the size in machine-words, if we know\n             // it.\n             if let Some(size) = type_size_of(tcx, self.param_env, ty) {"}, {"sha": "14ed93f112788fd3a13fb0bb16bb4c3f5ba5721b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -69,6 +69,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n             hir::LocalSource::ForLoopDesugar => (\"`for` loop binding\", None),\n             hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n+            hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n         self.check_patterns(&loc.pat);"}, {"sha": "2324dba80f543f21d56fbac76762504191ed5578", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -434,6 +434,7 @@ symbols! {\n         deref_mut,\n         deref_target,\n         derive,\n+        destructuring_assignment,\n         diagnostic,\n         direct,\n         discriminant_kind,"}, {"sha": "af19ad08c1d084602d3f217e6fcf577b2920d1cf", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -718,39 +718,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> bool {\n-        match &expr.kind {\n-            ExprKind::Array(comps) | ExprKind::Tup(comps) => {\n-                comps.iter().all(|e| self.is_destructuring_place_expr(e))\n-            }\n-            ExprKind::Struct(_path, fields, rest) => {\n-                rest.as_ref().map(|e| self.is_destructuring_place_expr(e)).unwrap_or(true)\n-                    && fields.iter().all(|f| self.is_destructuring_place_expr(&f.expr))\n-            }\n-            _ => expr.is_syntactic_place_expr(),\n-        }\n-    }\n-\n     pub(crate) fn check_lhs_assignable(\n         &self,\n         lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         expr_span: &Span,\n     ) {\n-        if !lhs.is_syntactic_place_expr() {\n-            // FIXME: Make this use SessionDiagnostic once error codes can be dynamically set.\n-            let mut err = self.tcx.sess.struct_span_err_with_code(\n-                *expr_span,\n-                \"invalid left-hand side of assignment\",\n-                DiagnosticId::Error(err_code.into()),\n-            );\n-            err.span_label(lhs.span, \"cannot assign to this expression\");\n-            if self.is_destructuring_place_expr(lhs) {\n-                err.note(\"destructuring assignments are not currently supported\");\n-                err.note(\"for more information, see https://github.com/rust-lang/rfcs/issues/372\");\n-            }\n-            err.emit();\n+        if lhs.is_syntactic_place_expr() {\n+            return;\n         }\n+\n+        // FIXME: Make this use SessionDiagnostic once error codes can be dynamically set.\n+        let mut err = self.tcx.sess.struct_span_err_with_code(\n+            *expr_span,\n+            \"invalid left-hand side of assignment\",\n+            DiagnosticId::Error(err_code.into()),\n+        );\n+        err.span_label(lhs.span, \"cannot assign to this expression\");\n+        err.emit();\n     }\n \n     /// Type check assignment expression `expr` of form `lhs = rhs`."}, {"sha": "6489b7838d63f53841ce83808c3a27a0365b472a", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -270,6 +270,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n     fn calc_adjust_mode(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> AdjustMode {\n+        // When we perform destructuring assignment, we disable default match bindings, which are\n+        // unintuitive in this context.\n+        if !pat.default_binding_modes {\n+            return AdjustMode::Reset;\n+        }\n         match &pat.kind {\n             // Type checking these product-like types successfully always require\n             // that the expected type be of those types and not reference types."}, {"sha": "7b31b9f3915f47e35ce8f20a7e128e12e14343be", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -577,7 +577,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n-            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n+            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id, .. }| {\n                 // `ref x` pattern\n                 if let PatKind::Binding(..) = kind {\n                     if let Some(ty::BindByReference(mutbl)) ="}, {"sha": "4fea6adf54107d3d7d8b34daf5038cf860286fc4", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -42,7 +42,7 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n+impl<K, V> BTreeMap<K, V> {\n     /// Panics if the map (or the code navigating it) is corrupted.\n     fn check(&self)\n     where\n@@ -54,14 +54,14 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n             assert!(root_node.ascend().is_err());\n             root_node.assert_back_pointers();\n \n-            let counted = root_node.assert_ascending();\n-            assert_eq!(self.length, counted);\n             assert_eq!(self.length, root_node.calc_length());\n \n             root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n             assert_eq!(self.length, 0);\n         }\n+\n+        self.assert_ascending();\n     }\n \n     /// Returns the height of the root, if any.\n@@ -79,10 +79,28 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n             String::from(\"not yet allocated\")\n         }\n     }\n+\n+    /// Asserts that the keys are in strictly ascending order.\n+    fn assert_ascending(&self)\n+    where\n+        K: Copy + Debug + Ord,\n+    {\n+        let mut num_seen = 0;\n+        let mut keys = self.keys();\n+        if let Some(mut previous) = keys.next() {\n+            num_seen = 1;\n+            for next in keys {\n+                assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n+                previous = next;\n+                num_seen += 1;\n+            }\n+        }\n+        assert_eq!(num_seen, self.len());\n+    }\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n-    pub fn assert_min_len(self, min_len: usize) {\n+    fn assert_min_len(self, min_len: usize) {\n         assert!(self.len() >= min_len, \"{} < {}\", self.len(), min_len);\n         if let node::ForceResult::Internal(node) = self.force() {\n             for idx in 0..=node.len() {"}, {"sha": "433074027e7f7bd661b6f125c6d8d40a532310bd", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1608,15 +1608,19 @@ pub mod marker {\n \n unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n     unsafe {\n-        ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n-        ptr::write(slice.get_unchecked_mut(idx), val);\n+        let len = slice.len();\n+        let slice_ptr = slice.as_mut_ptr();\n+        ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx);\n+        ptr::write(slice_ptr.add(idx), val);\n     }\n }\n \n unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n     unsafe {\n-        let ret = ptr::read(slice.get_unchecked(idx));\n-        ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n+        let len = slice.len();\n+        let slice_ptr = slice.as_mut_ptr();\n+        let ret = ptr::read(slice_ptr.add(idx));\n+        ptr::copy(slice_ptr.add(idx + 1), slice_ptr.add(idx), len - idx - 1);\n         ret\n     }\n }"}, {"sha": "38c75de34eeebb8a16242a04c77856467a97f284", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -17,43 +17,6 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n         }\n     }\n \n-    /// Asserts that the keys are in strictly ascending order.\n-    /// Returns how many keys it encountered.\n-    pub fn assert_ascending(self) -> usize\n-    where\n-        K: Copy + Debug + Ord,\n-    {\n-        struct SeriesChecker<T> {\n-            num_seen: usize,\n-            previous: Option<T>,\n-        }\n-        impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n-            fn is_ascending(&mut self, next: T) {\n-                if let Some(previous) = self.previous {\n-                    assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n-                }\n-                self.previous = Some(next);\n-                self.num_seen += 1;\n-            }\n-        }\n-\n-        let mut checker = SeriesChecker { num_seen: 0, previous: None };\n-        self.visit_nodes_in_order(|pos| match pos {\n-            navigate::Position::Leaf(node) => {\n-                for idx in 0..node.len() {\n-                    let key = *unsafe { node.key_at(idx) };\n-                    checker.is_ascending(key);\n-                }\n-            }\n-            navigate::Position::InternalKV(kv) => {\n-                let key = *kv.into_kv().0;\n-                checker.is_ascending(key);\n-            }\n-            navigate::Position::Internal(_) => {}\n-        });\n-        checker.num_seen\n-    }\n-\n     pub fn dump_keys(self) -> String\n     where\n         K: Debug,"}, {"sha": "41202546566a7adeff5b0e22889a70b907b7d46c", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -159,6 +159,7 @@\n #![feature(slice_ptr_get)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(int_error_matching)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n #[prelude_import]"}, {"sha": "9d8c8c862911c21bac4ce60cb482912ed41ea289", "filename": "library/core/src/num/error.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -98,15 +98,18 @@ pub enum IntErrorKind {\n     ///\n     /// Among other causes, this variant will be constructed when parsing an empty string.\n     Empty,\n-    /// Contains an invalid digit.\n+    /// Contains an invalid digit in its context.\n     ///\n     /// Among other causes, this variant will be constructed when parsing a string that\n-    /// contains a letter.\n+    /// contains a non-ASCII char.\n+    ///\n+    /// This variant is also constructed when a `+` or `-` is misplaced within a string\n+    /// either on its own or in the middle of a number.\n     InvalidDigit,\n     /// Integer is too large to store in target integer type.\n-    Overflow,\n+    PosOverflow,\n     /// Integer is too small to store in target integer type.\n-    Underflow,\n+    NegOverflow,\n     /// Value was Zero\n     ///\n     /// This variant will be emitted when the parsing string has a value of zero, which\n@@ -119,7 +122,7 @@ impl ParseIntError {\n     #[unstable(\n         feature = \"int_error_matching\",\n         reason = \"it can be useful to match errors when making error messages \\\n-                  for integer parsing\",\n+              for integer parsing\",\n         issue = \"22639\"\n     )]\n     pub fn kind(&self) -> &IntErrorKind {\n@@ -136,8 +139,8 @@ impl ParseIntError {\n         match self.kind {\n             IntErrorKind::Empty => \"cannot parse integer from empty string\",\n             IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n-            IntErrorKind::Overflow => \"number too large to fit in target type\",\n-            IntErrorKind::Underflow => \"number too small to fit in target type\",\n+            IntErrorKind::PosOverflow => \"number too large to fit in target type\",\n+            IntErrorKind::NegOverflow => \"number too small to fit in target type\",\n             IntErrorKind::Zero => \"number would be zero for non-zero type\",\n         }\n     }"}, {"sha": "9f5ae57b74adee4f8edfad538a71ba9d6239544c", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -63,7 +63,12 @@ pub use nonzero::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, No\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use error::TryFromIntError;\n \n-#[unstable(feature = \"int_error_matching\", issue = \"22639\")]\n+#[unstable(\n+    feature = \"int_error_matching\",\n+    reason = \"it can be useful to match errors when making error messages \\\n+              for integer parsing\",\n+    issue = \"22639\"\n+)]\n pub use error::IntErrorKind;\n \n macro_rules! usize_isize_to_xe_bytes_doc {\n@@ -830,15 +835,14 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     let src = src.as_bytes();\n \n     let (is_positive, digits) = match src[0] {\n+        b'+' | b'-' if src[1..].is_empty() => {\n+            return Err(PIE { kind: InvalidDigit });\n+        }\n         b'+' => (true, &src[1..]),\n         b'-' if is_signed_ty => (false, &src[1..]),\n         _ => (true, src),\n     };\n \n-    if digits.is_empty() {\n-        return Err(PIE { kind: Empty });\n-    }\n-\n     let mut result = T::from_u32(0);\n     if is_positive {\n         // The number is positive\n@@ -849,11 +853,11 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n             };\n             result = match result.checked_mul(radix) {\n                 Some(result) => result,\n-                None => return Err(PIE { kind: Overflow }),\n+                None => return Err(PIE { kind: PosOverflow }),\n             };\n             result = match result.checked_add(x) {\n                 Some(result) => result,\n-                None => return Err(PIE { kind: Overflow }),\n+                None => return Err(PIE { kind: PosOverflow }),\n             };\n         }\n     } else {\n@@ -865,11 +869,11 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n             };\n             result = match result.checked_mul(radix) {\n                 Some(result) => result,\n-                None => return Err(PIE { kind: Underflow }),\n+                None => return Err(PIE { kind: NegOverflow }),\n             };\n             result = match result.checked_sub(x) {\n                 Some(result) => result,\n-                None => return Err(PIE { kind: Underflow }),\n+                None => return Err(PIE { kind: NegOverflow }),\n             };\n         }\n     }"}, {"sha": "fb1293c99bba934748dd13362c0a994eea41d833", "filename": "library/core/tests/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnonzero.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -135,11 +135,11 @@ fn test_from_str() {\n     );\n     assert_eq!(\n         \"-129\".parse::<NonZeroI8>().err().map(|e| e.kind().clone()),\n-        Some(IntErrorKind::Underflow)\n+        Some(IntErrorKind::NegOverflow)\n     );\n     assert_eq!(\n         \"257\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()),\n-        Some(IntErrorKind::Overflow)\n+        Some(IntErrorKind::PosOverflow)\n     );\n }\n "}, {"sha": "49e5cc0eaa54484028e973667260d54e01f23d82", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -2,10 +2,11 @@ use core::cmp::PartialEq;\n use core::convert::{TryFrom, TryInto};\n use core::fmt::Debug;\n use core::marker::Copy;\n-use core::num::TryFromIntError;\n+use core::num::{IntErrorKind, ParseIntError, TryFromIntError};\n use core::ops::{Add, Div, Mul, Rem, Sub};\n use core::option::Option;\n-use core::option::Option::{None, Some};\n+use core::option::Option::None;\n+use core::str::FromStr;\n \n #[macro_use]\n mod int_macros;\n@@ -67,6 +68,15 @@ where\n     assert_eq!(ten.rem(two), ten % two);\n }\n \n+/// Helper function for asserting number parsing returns a specific error\n+fn test_parse<T>(num_str: &str, expected: Result<T, IntErrorKind>)\n+where\n+    T: FromStr<Err = ParseIntError>,\n+    Result<T, IntErrorKind>: PartialEq + Debug,\n+{\n+    assert_eq!(num_str.parse::<T>().map_err(|e| e.kind().clone()), expected)\n+}\n+\n #[test]\n fn from_str_issue7588() {\n     let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n@@ -77,49 +87,52 @@ fn from_str_issue7588() {\n \n #[test]\n fn test_int_from_str_overflow() {\n-    assert_eq!(\"127\".parse::<i8>().ok(), Some(127i8));\n-    assert_eq!(\"128\".parse::<i8>().ok(), None);\n+    test_parse::<i8>(\"127\", Ok(127));\n+    test_parse::<i8>(\"128\", Err(IntErrorKind::PosOverflow));\n \n-    assert_eq!(\"-128\".parse::<i8>().ok(), Some(-128i8));\n-    assert_eq!(\"-129\".parse::<i8>().ok(), None);\n+    test_parse::<i8>(\"-128\", Ok(-128));\n+    test_parse::<i8>(\"-129\", Err(IntErrorKind::NegOverflow));\n \n-    assert_eq!(\"32767\".parse::<i16>().ok(), Some(32_767i16));\n-    assert_eq!(\"32768\".parse::<i16>().ok(), None);\n+    test_parse::<i16>(\"32767\", Ok(32_767));\n+    test_parse::<i16>(\"32768\", Err(IntErrorKind::PosOverflow));\n \n-    assert_eq!(\"-32768\".parse::<i16>().ok(), Some(-32_768i16));\n-    assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n+    test_parse::<i16>(\"-32768\", Ok(-32_768));\n+    test_parse::<i16>(\"-32769\", Err(IntErrorKind::NegOverflow));\n \n-    assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(2_147_483_647i32));\n-    assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n+    test_parse::<i32>(\"2147483647\", Ok(2_147_483_647));\n+    test_parse::<i32>(\"2147483648\", Err(IntErrorKind::PosOverflow));\n \n-    assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(-2_147_483_648i32));\n-    assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n+    test_parse::<i32>(\"-2147483648\", Ok(-2_147_483_648));\n+    test_parse::<i32>(\"-2147483649\", Err(IntErrorKind::NegOverflow));\n \n-    assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(9_223_372_036_854_775_807i64));\n-    assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n+    test_parse::<i64>(\"9223372036854775807\", Ok(9_223_372_036_854_775_807));\n+    test_parse::<i64>(\"9223372036854775808\", Err(IntErrorKind::PosOverflow));\n \n-    assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(-9_223_372_036_854_775_808i64));\n-    assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n+    test_parse::<i64>(\"-9223372036854775808\", Ok(-9_223_372_036_854_775_808));\n+    test_parse::<i64>(\"-9223372036854775809\", Err(IntErrorKind::NegOverflow));\n }\n \n #[test]\n fn test_leading_plus() {\n-    assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));\n-    assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));\n+    test_parse::<u8>(\"+127\", Ok(127));\n+    test_parse::<i64>(\"+9223372036854775807\", Ok(9223372036854775807));\n }\n \n #[test]\n fn test_invalid() {\n-    assert_eq!(\"--129\".parse::<i8>().ok(), None);\n-    assert_eq!(\"++129\".parse::<i8>().ok(), None);\n-    assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+    test_parse::<i8>(\"--129\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<i8>(\"++129\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<u8>(\"\u0421\u044a\u0435\u0448\u044c\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<u8>(\"123Hello\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<i8>(\"--\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<i8>(\"-\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<i8>(\"+\", Err(IntErrorKind::InvalidDigit));\n+    test_parse::<u8>(\"-1\", Err(IntErrorKind::InvalidDigit));\n }\n \n #[test]\n fn test_empty() {\n-    assert_eq!(\"-\".parse::<i8>().ok(), None);\n-    assert_eq!(\"+\".parse::<i8>().ok(), None);\n-    assert_eq!(\"\".parse::<u8>().ok(), None);\n+    test_parse::<u8>(\"\", Err(IntErrorKind::Empty));\n }\n \n #[test]"}, {"sha": "c256f556b3c8f207fcc307dabf6a4b633fc492fc", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1701,10 +1701,14 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n ///\n+/// If `src` names a symbolic link, it is platform-specific whether the symbolic\n+/// link is followed. On platforms where it's possible to not follow it, it is\n+/// not followed, and the created hard link points to the symbolic link itself.\n+///\n /// # Platform-specific behavior\n ///\n-/// This function currently corresponds to the `link` function on Unix\n-/// and the `CreateHardLink` function on Windows.\n+/// This function currently corresponds to the `linkat` function with no flags\n+/// on Unix and the `CreateHardLink` function on Windows.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior"}, {"sha": "0642dca8e48a7b06ee3526e9fa3248043486c440", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1336,3 +1336,54 @@ fn metadata_access_times() {\n         }\n     }\n }\n+\n+/// Test creating hard links to symlinks.\n+#[test]\n+fn symlink_hard_link() {\n+    let tmpdir = tmpdir();\n+\n+    // Create \"file\", a file.\n+    check!(fs::File::create(tmpdir.join(\"file\")));\n+\n+    // Create \"symlink\", a symlink to \"file\".\n+    check!(symlink_file(\"file\", tmpdir.join(\"symlink\")));\n+\n+    // Create \"hard_link\", a hard link to \"symlink\".\n+    check!(fs::hard_link(tmpdir.join(\"symlink\"), tmpdir.join(\"hard_link\")));\n+\n+    // \"hard_link\" should appear as a symlink.\n+    assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n+\n+    // We sould be able to open \"file\" via any of the above names.\n+    let _ = check!(fs::File::open(tmpdir.join(\"file\")));\n+    assert!(fs::File::open(tmpdir.join(\"file.renamed\")).is_err());\n+    let _ = check!(fs::File::open(tmpdir.join(\"symlink\")));\n+    let _ = check!(fs::File::open(tmpdir.join(\"hard_link\")));\n+\n+    // Rename \"file\" to \"file.renamed\".\n+    check!(fs::rename(tmpdir.join(\"file\"), tmpdir.join(\"file.renamed\")));\n+\n+    // Now, the symlink and the hard link should be dangling.\n+    assert!(fs::File::open(tmpdir.join(\"file\")).is_err());\n+    let _ = check!(fs::File::open(tmpdir.join(\"file.renamed\")));\n+    assert!(fs::File::open(tmpdir.join(\"symlink\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"hard_link\")).is_err());\n+\n+    // The symlink and the hard link should both still point to \"file\".\n+    assert!(fs::read_link(tmpdir.join(\"file\")).is_err());\n+    assert!(fs::read_link(tmpdir.join(\"file.renamed\")).is_err());\n+    assert_eq!(check!(fs::read_link(tmpdir.join(\"symlink\"))), Path::new(\"file\"));\n+    assert_eq!(check!(fs::read_link(tmpdir.join(\"hard_link\"))), Path::new(\"file\"));\n+\n+    // Remove \"file.renamed\".\n+    check!(fs::remove_file(tmpdir.join(\"file.renamed\")));\n+\n+    // Now, we can't open the file by any name.\n+    assert!(fs::File::open(tmpdir.join(\"file\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"file.renamed\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"symlink\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"hard_link\")).is_err());\n+\n+    // \"hard_link\" should still appear as a symlink.\n+    assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n+}"}, {"sha": "96594095cc36df46d0cf69572815460a261b9b49", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1081,7 +1081,20 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     let src = cstr(src)?;\n     let dst = cstr(dst)?;\n-    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n+            // VxWorks, Redox, and old versions of Android lack `linkat`, so use\n+            // `link` instead. POSIX leaves it implementation-defined whether\n+            // `link` follows symlinks, so rely on the `symlink_hard_link` test\n+            // in library/std/src/fs/tests.rs to check the behavior.\n+            cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+        } else {\n+            // Use `linkat` with `AT_FDCWD` instead of `link` as `linkat` gives\n+            // us a flag to specify how symlinks should be handled. Pass 0 as\n+            // the flags argument, meaning don't follow symlinks.\n+            cvt(unsafe { libc::linkat(libc::AT_FDCWD, src.as_ptr(), libc::AT_FDCWD, dst.as_ptr(), 0) })?;\n+        }\n+    }\n     Ok(())\n }\n "}, {"sha": "10aa34e9443b70c4dbb866289ceedca846f0282f", "filename": "library/std/src/sys/unix/process/process_common/tests.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -14,17 +14,22 @@ macro_rules! t {\n     };\n }\n \n-// See #14232 for more information, but it appears that signal delivery to a\n-// newly spawned process may just be raced in the macOS, so to prevent this\n-// test from being flaky we ignore it on macOS.\n #[test]\n-#[cfg_attr(target_os = \"macos\", ignore)]\n-// When run under our current QEMU emulation test suite this test fails,\n-// although the reason isn't very clear as to why. For now this test is\n-// ignored there.\n-#[cfg_attr(target_arch = \"arm\", ignore)]\n-#[cfg_attr(target_arch = \"aarch64\", ignore)]\n-#[cfg_attr(target_arch = \"riscv64\", ignore)]\n+#[cfg_attr(\n+    any(\n+        // See #14232 for more information, but it appears that signal delivery to a\n+        // newly spawned process may just be raced in the macOS, so to prevent this\n+        // test from being flaky we ignore it on macOS.\n+        target_os = \"macos\",\n+        // When run under our current QEMU emulation test suite this test fails,\n+        // although the reason isn't very clear as to why. For now this test is\n+        // ignored there.\n+        target_arch = \"arm\",\n+        target_arch = \"aarch64\",\n+        target_arch = \"riscv64\",\n+    ),\n+    ignore\n+)]\n fn test_process_mask() {\n     unsafe {\n         // Test to make sure that a signal mask does not get inherited."}, {"sha": "95c54ca1abc067855bbe4fb7988723ecc21b17b8", "filename": "src/ci/docker/host-x86_64/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2FDockerfile?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -35,6 +35,5 @@ ENV HOSTS=aarch64-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-full-tools \\\n       --enable-profiler \\\n-      --enable-sanitizers \\\n-      --disable-docs\n+      --enable-sanitizers\n ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "889c98966ebc4586e03359c1218c3b8cd2307f90", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -301,6 +301,9 @@ jobs:\n           #   Linux/Docker builders   #\n           #############################\n \n+          - name: aarch64-gnu\n+            <<: *job-aarch64-linux\n+\n           - name: arm-android\n             <<: *job-linux-xl\n \n@@ -635,23 +638,6 @@ jobs:\n               SCRIPT: python x.py dist\n             <<: *job-windows-xl\n \n-  auto-fallible:\n-    <<: *base-ci-job\n-    name: auto-fallible\n-    env:\n-      <<: [*shared-ci-variables, *dummy-variables]\n-    if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n-    strategy:\n-      fail-fast: false\n-      matrix:\n-        include:\n-          #############################\n-          #   Linux/Docker builders   #\n-          #############################\n-\n-          - name: aarch64-gnu\n-            <<: *job-aarch64-linux\n-\n   try:\n     <<: *base-ci-job\n     name: try"}, {"sha": "8005a5f3563bf3a4f5a82200adb46629f6b863b1", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -34,6 +34,7 @@ Specifically they will each satisfy the following requirements:\n \n target | std | host | notes\n -------|-----|------|-------\n+`aarch64-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (kernel 4.2, glibc 2.17+) [^missing-stack-probes]\n `i686-pc-windows-gnu` | \u2713 | \u2713 | 32-bit MinGW (Windows 7+)\n `i686-pc-windows-msvc` | \u2713 | \u2713 | 32-bit MSVC (Windows 7+)\n `i686-unknown-linux-gnu` | \u2713 | \u2713 | 32-bit Linux (kernel 2.6.32+, glibc 2.11+)\n@@ -42,6 +43,12 @@ target | std | host | notes\n `x86_64-pc-windows-msvc` | \u2713 | \u2713 | 64-bit MSVC (Windows 7+)\n `x86_64-unknown-linux-gnu` | \u2713 | \u2713 | 64-bit Linux (kernel 2.6.32+, glibc 2.11+)\n \n+[^missing-stack-probes]: Stack probes support is missing on\n+  `aarch64-unknown-linux-gnu`, but it's planned to be implemented in the near\n+  future. The implementation is tracked on [issue #77071][77071].\n+\n+[77071]: https://github.com/rust-lang/rust/issues/77071\n+\n ## Tier 2\n \n Tier 2 platforms can be thought of as \"guaranteed to build\". Automated tests\n@@ -62,7 +69,6 @@ target | std | host | notes\n `aarch64-fuchsia` | \u2713 |  | ARM64 Fuchsia\n `aarch64-linux-android` | \u2713 |  | ARM64 Android\n `aarch64-pc-windows-msvc` | \u2713 | \u2713 | ARM64 Windows MSVC\n-`aarch64-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (kernel 4.2, glibc 2.17)\n `aarch64-unknown-linux-musl` | \u2713 | \u2713 | ARM64 Linux with MUSL\n `aarch64-unknown-none` | * |  | Bare ARM64, hardfloat\n `aarch64-unknown-none-softfloat` | * |  | Bare ARM64, softfloat"}, {"sha": "4cad6418d6a5a886416f4bac27981a5e90e15d38", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -322,7 +322,8 @@ pub fn run_core(\n     let cpath = Some(input.clone());\n     let input = Input::File(input);\n \n-    let intra_link_resolution_failure_name = lint::builtin::BROKEN_INTRA_DOC_LINKS.name;\n+    let broken_intra_doc_links = lint::builtin::BROKEN_INTRA_DOC_LINKS.name;\n+    let private_intra_doc_links = lint::builtin::PRIVATE_INTRA_DOC_LINKS.name;\n     let missing_docs = rustc_lint::builtin::MISSING_DOCS.name;\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n@@ -336,7 +337,8 @@ pub fn run_core(\n     // In addition to those specific lints, we also need to allow those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n     let lints_to_show = vec![\n-        intra_link_resolution_failure_name.to_owned(),\n+        broken_intra_doc_links.to_owned(),\n+        private_intra_doc_links.to_owned(),\n         missing_docs.to_owned(),\n         missing_doc_example.to_owned(),\n         private_doc_tests.to_owned(),\n@@ -349,9 +351,8 @@ pub fn run_core(\n     ];\n \n     let (lint_opts, lint_caps) = init_lints(lints_to_show, lint_opts, |lint| {\n-        if lint.name == intra_link_resolution_failure_name\n-            || lint.name == invalid_codeblock_attributes_name\n-        {\n+        // FIXME: why is this necessary?\n+        if lint.name == broken_intra_doc_links || lint.name == invalid_codeblock_attributes_name {\n             None\n         } else {\n             Some((lint.name_lower(), lint::Allow))"}, {"sha": "fb8990b30e2edc3803b3c839de85fd2f5f964a9f", "filename": "src/librustdoc/html/static/settings.css", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsettings.css?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -26,7 +26,8 @@\n }\n \n .toggle input {\n-\tdisplay: none;\n+\topacity: 0;\n+\tposition: absolute;\n }\n \n .select-wrapper {\n@@ -90,7 +91,7 @@ input:checked + .slider {\n }\n \n input:focus + .slider {\n-\tbox-shadow: 0 0 1px #2196F3;\n+\tbox-shadow: 0 0 0 2px #0a84ff, 0 0 0 6px rgba(10, 132, 255, 0.3);\n }\n \n input:checked + .slider:before {"}, {"sha": "7c8618f71e5f55cf767630e2595197a0375c92d4", "filename": "src/test/mir-opt/inline/inline-shims.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fmir-opt%2Finline%2Finline-shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fmir-opt%2Finline%2Finline-shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-shims.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,13 @@\n+// ignore-wasm32-bare compiled with panic=abort by default\n+#![crate_type = \"lib\"]\n+\n+// EMIT_MIR inline_shims.clone.Inline.diff\n+pub fn clone<A, B>(f: fn(A, B)) -> fn(A, B) {\n+    f.clone()\n+}\n+\n+// EMIT_MIR inline_shims.drop.Inline.diff\n+pub fn drop<A, B>(a: *mut Vec<A>, b: *mut Option<B>) {\n+    unsafe { std::ptr::drop_in_place(a) }\n+    unsafe { std::ptr::drop_in_place(b) }\n+}"}, {"sha": "3bdd4f4ff56cc7583aba6815e8917ef57761a416", "filename": "src/test/mir-opt/inline/inline_shims.clone.Inline.diff", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.clone.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.clone.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.clone.Inline.diff?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,26 @@\n+- // MIR for `clone` before Inline\n++ // MIR for `clone` after Inline\n+  \n+  fn clone(_1: fn(A, B)) -> fn(A, B) {\n+      debug f => _1;                       // in scope 0 at $DIR/inline-shims.rs:5:20: 5:21\n+      let mut _0: fn(A, B);                // return place in scope 0 at $DIR/inline-shims.rs:5:36: 5:44\n+      let mut _2: &fn(A, B);               // in scope 0 at $DIR/inline-shims.rs:6:5: 6:6\n++     scope 1 (inlined <fn(A, B) as Clone>::clone - shim(fn(A, B))) { // at $DIR/inline-shims.rs:6:5: 6:14\n++     }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-shims.rs:6:5: 6:6\n+          _2 = &_1;                        // scope 0 at $DIR/inline-shims.rs:6:5: 6:6\n+-         _0 = <fn(A, B) as Clone>::clone(move _2) -> bb1; // scope 0 at $DIR/inline-shims.rs:6:5: 6:14\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-shims.rs:6:7: 6:12\n+-                                          // + literal: Const { ty: for<'r> fn(&'r fn(A, B)) -> fn(A, B) {<fn(A, B) as std::clone::Clone>::clone}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb1: {\n++         _0 = (*_2);                      // scope 1 at $DIR/inline-shims.rs:6:5: 6:14\n+          StorageDead(_2);                 // scope 0 at $DIR/inline-shims.rs:6:13: 6:14\n+          return;                          // scope 0 at $DIR/inline-shims.rs:7:2: 7:2\n+      }\n+  }\n+  "}, {"sha": "503d8bc6b7a68d291de30a9c3968ef36698dbeb6", "filename": "src/test/mir-opt/inline/inline_shims.drop.Inline.diff", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.drop.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.drop.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.drop.Inline.diff?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,52 @@\n+- // MIR for `drop` before Inline\n++ // MIR for `drop` after Inline\n+  \n+  fn drop(_1: *mut Vec<A>, _2: *mut Option<B>) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/inline-shims.rs:10:19: 10:20\n+      debug b => _2;                       // in scope 0 at $DIR/inline-shims.rs:10:35: 10:36\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-shims.rs:10:54: 10:54\n+      let _3: ();                          // in scope 0 at $DIR/inline-shims.rs:11:14: 11:40\n+      let mut _4: *mut std::vec::Vec<A>;   // in scope 0 at $DIR/inline-shims.rs:11:38: 11:39\n+      let mut _5: *mut std::option::Option<B>; // in scope 0 at $DIR/inline-shims.rs:12:38: 12:39\n+      scope 1 {\n+      }\n+      scope 2 {\n++         scope 3 (inlined drop_in_place::<Option<B>> - shim(Some(Option<B>))) { // at $DIR/inline-shims.rs:12:14: 12:40\n++             let mut _6: isize;           // in scope 3 at $DIR/inline-shims.rs:12:14: 12:40\n++             let mut _7: isize;           // in scope 3 at $DIR/inline-shims.rs:12:14: 12:40\n++         }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 0 at $DIR/inline-shims.rs:11:5: 11:42\n+          StorageLive(_4);                 // scope 1 at $DIR/inline-shims.rs:11:38: 11:39\n+          _4 = _1;                         // scope 1 at $DIR/inline-shims.rs:11:38: 11:39\n+          _3 = drop_in_place::<Vec<A>>(move _4) -> bb1; // scope 1 at $DIR/inline-shims.rs:11:14: 11:40\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-shims.rs:11:14: 11:37\n+                                           // + literal: Const { ty: unsafe fn(*mut std::vec::Vec<A>) {std::intrinsics::drop_in_place::<std::vec::Vec<A>>}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 1 at $DIR/inline-shims.rs:11:39: 11:40\n+          StorageDead(_3);                 // scope 0 at $DIR/inline-shims.rs:11:41: 11:42\n+          StorageLive(_5);                 // scope 2 at $DIR/inline-shims.rs:12:38: 12:39\n+          _5 = _2;                         // scope 2 at $DIR/inline-shims.rs:12:38: 12:39\n+-         _0 = drop_in_place::<Option<B>>(move _5) -> bb2; // scope 2 at $DIR/inline-shims.rs:12:14: 12:40\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-shims.rs:12:14: 12:37\n+-                                          // + literal: Const { ty: unsafe fn(*mut std::option::Option<B>) {std::intrinsics::drop_in_place::<std::option::Option<B>>}, val: Value(Scalar(<ZST>)) }\n++         _6 = discriminant((*_5));        // scope 3 at $DIR/inline-shims.rs:12:14: 12:40\n++         switchInt(move _6) -> [0_isize: bb2, otherwise: bb3]; // scope 3 at $DIR/inline-shims.rs:12:14: 12:40\n+      }\n+  \n+      bb2: {\n+          StorageDead(_5);                 // scope 2 at $DIR/inline-shims.rs:12:39: 12:40\n+          return;                          // scope 0 at $DIR/inline-shims.rs:13:2: 13:2\n++     }\n++ \n++     bb3: {\n++         drop((((*_5) as Some).0: B)) -> bb2; // scope 3 at $DIR/inline-shims.rs:12:14: 12:40\n+      }\n+  }\n+  "}, {"sha": "39536f12e3bb5f71a9102bed75dcff2fc8c785da", "filename": "src/test/ui/bad/bad-expr-lhs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1,10 +1,12 @@\n fn main() {\n     1 = 2; //~ ERROR invalid left-hand side of assignment\n     1 += 2; //~ ERROR invalid left-hand side of assignment\n-    (1, 2) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (1, 2) = (3, 4); //~ ERROR destructuring assignments are unstable\n+    //~| ERROR invalid left-hand side of assignment\n+    //~| ERROR invalid left-hand side of assignment\n \n     let (a, b) = (1, 2);\n-    (a, b) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (a, b) = (3, 4); //~ ERROR destructuring assignments are unstable\n \n     None = Some(3); //~ ERROR invalid left-hand side of assignment\n }"}, {"sha": "d4b2193d09fc287cfc9b470289b631e2d9053590", "filename": "src/test/ui/bad/bad-expr-lhs.stderr", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1,3 +1,25 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/bad-expr-lhs.rs:4:12\n+   |\n+LL |     (1, 2) = (3, 4);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/bad-expr-lhs.rs:9:12\n+   |\n+LL |     (a, b) = (3, 4);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/bad-expr-lhs.rs:2:7\n    |\n@@ -18,30 +40,27 @@ error[E0070]: invalid left-hand side of assignment\n   --> $DIR/bad-expr-lhs.rs:4:12\n    |\n LL |     (1, 2) = (3, 4);\n-   |     ------ ^\n-   |     |\n-   |     cannot assign to this expression\n+   |      -     ^\n+   |      |\n+   |      cannot assign to this expression\n \n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/bad-expr-lhs.rs:7:12\n-   |\n-LL |     (a, b) = (3, 4);\n-   |     ------ ^\n-   |     |\n-   |     cannot assign to this expression\n+  --> $DIR/bad-expr-lhs.rs:4:12\n    |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+LL |     (1, 2) = (3, 4);\n+   |         -  ^\n+   |         |\n+   |         cannot assign to this expression\n \n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/bad-expr-lhs.rs:9:10\n+  --> $DIR/bad-expr-lhs.rs:11:10\n    |\n LL |     None = Some(3);\n    |     ---- ^\n    |     |\n    |     cannot assign to this expression\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0067, E0070.\n+Some errors have detailed explanations: E0067, E0070, E0658.\n For more information about an error, try `rustc --explain E0067`."}, {"sha": "adecd0ff291f9b29f2ee853c53a8cb423afcc8dc", "filename": "src/test/ui/destructuring-assignment/default-match-bindings-forbidden.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,7 @@\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+    let mut x = &0;\n+    let mut y = &0;\n+    (x, y) = &(1, 2); //~ ERROR mismatched types\n+}"}, {"sha": "e6161fdfa2441f882975bb0b4d2c062054a3a331", "filename": "src/test/ui/destructuring-assignment/default-match-bindings-forbidden.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.stderr?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/default-match-bindings-forbidden.rs:6:5\n+   |\n+LL |     (x, y) = &(1, 2);\n+   |     ^^^^^^   ------- this expression has type `&({integer}, {integer})`\n+   |     |\n+   |     expected reference, found tuple\n+   |\n+   = note: expected type `&({integer}, {integer})`\n+             found tuple `(_, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e0cb9dc9158e247c3c61eb623fddf39458d4d005", "filename": "src/test/ui/destructuring-assignment/note-unsupported.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -3,23 +3,24 @@ struct S { x: u8, y: u8 }\n fn main() {\n     let (a, b) = (1, 2);\n \n-    (a, b) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (a, b) = (3, 4); //~ ERROR destructuring assignments are unstable\n     (a, b) += (3, 4); //~ ERROR invalid left-hand side of assignment\n-    //~^ ERROR binary assignment operation `+=` cannot be applied\n+    //~| ERROR binary assignment operation `+=` cannot be applied\n \n     [a, b] = [3, 4]; //~ ERROR invalid left-hand side of assignment\n     [a, b] += [3, 4]; //~ ERROR invalid left-hand side of assignment\n-    //~^ ERROR binary assignment operation `+=` cannot be applied\n+    //~| ERROR binary assignment operation `+=` cannot be applied\n \n     let s = S { x: 3, y: 4 };\n \n     S { x: a, y: b } = s; //~ ERROR invalid left-hand side of assignment\n     S { x: a, y: b } += s; //~ ERROR invalid left-hand side of assignment\n-    //~^ ERROR binary assignment operation `+=` cannot be applied\n+    //~| ERROR binary assignment operation `+=` cannot be applied\n \n-    S { x: a, ..s } = S { x: 3, y: 4 }; //~ ERROR invalid left-hand side of assignment\n+    S { x: a, ..s } = S { x: 3, y: 4 };\n+    //~^ ERROR invalid left-hand side of assignment\n \n     let c = 3;\n \n-    ((a, b), c) = ((3, 4), 5); //~ ERROR invalid left-hand side of assignment\n+    ((a, b), c) = ((3, 4), 5); //~ ERROR destructuring assignments are unstable\n }"}, {"sha": "c5543fab825eb03cce20cb53a654f1dce64fa0c6", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -1,13 +1,24 @@\n-error[E0070]: invalid left-hand side of assignment\n+error[E0658]: destructuring assignments are unstable\n   --> $DIR/note-unsupported.rs:6:12\n    |\n LL |     (a, b) = (3, 4);\n    |     ------ ^\n    |     |\n    |     cannot assign to this expression\n    |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:25:17\n+   |\n+LL |     ((a, b), c) = ((3, 4), 5);\n+   |     ----------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `({integer}, {integer})`\n   --> $DIR/note-unsupported.rs:7:5\n@@ -24,9 +35,6 @@ LL |     (a, b) += (3, 4);\n    |     ------ ^^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:10:12\n@@ -35,9 +43,6 @@ LL |     [a, b] = [3, 4];\n    |     ------ ^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `[{integer}; 2]`\n   --> $DIR/note-unsupported.rs:11:5\n@@ -54,9 +59,6 @@ LL |     [a, b] += [3, 4];\n    |     ------ ^^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:16:22\n@@ -65,9 +67,6 @@ LL |     S { x: a, y: b } = s;\n    |     ---------------- ^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `S`\n   --> $DIR/note-unsupported.rs:17:5\n@@ -86,9 +85,6 @@ LL |     S { x: a, y: b } += s;\n    |     ---------------- ^^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:20:21\n@@ -97,22 +93,8 @@ LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n    |     --------------- ^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n-\n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:24:17\n-   |\n-LL |     ((a, b), c) = ((3, 4), 5);\n-   |     ----------- ^\n-   |     |\n-   |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error: aborting due to 11 previous errors\n \n-Some errors have detailed explanations: E0067, E0070, E0368.\n+Some errors have detailed explanations: E0067, E0070, E0368, E0658.\n For more information about an error, try `rustc --explain E0067`."}, {"sha": "16aafc4693f3fba324a5fcd7c02ac136834cfaee", "filename": "src/test/ui/destructuring-assignment/tuple_destructure.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,37 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+    let (mut a, mut b);\n+    (a, b) = (0, 1);\n+    assert_eq!((a, b), (0, 1));\n+    (b, a) = (a, b);\n+    assert_eq!((a, b), (1, 0));\n+    (a, .., b) = (1, 2);\n+    assert_eq!((a, b), (1, 2));\n+    (.., a) = (1, 2);\n+    assert_eq!((a, b), (2, 2));\n+    (..) = (3, 4);\n+    assert_eq!((a, b), (2, 2));\n+    (b, ..) = (5, 6, 7);\n+    assert_eq!(b, 5);\n+\n+    // Test for a non-Copy type (String):\n+    let (mut c, mut d);\n+    (c, d) = (\"c\".to_owned(), \"d\".to_owned());\n+    assert_eq!(c, \"c\");\n+    assert_eq!(d, \"d\");\n+    (d, c) = (c, d);\n+    assert_eq!(c, \"d\");\n+    assert_eq!(d, \"c\");\n+\n+    // Test nesting/parentheses:\n+    ((a, b)) = (0, 1);\n+    assert_eq!((a, b), (0, 1));\n+    (((a, b)), (c)) = ((2, 3), d);\n+    assert_eq!((a, b), (2, 3));\n+    assert_eq!(c, \"c\");\n+    ((a, .., b), .., (..)) = ((4, 5), ());\n+    assert_eq!((a, b), (4, 5));\n+}"}, {"sha": "b76f4968e6249541f9bb13ea6ede39fb66a967a1", "filename": "src/test/ui/destructuring-assignment/tuple_destructure_fail.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,10 @@\n+#![feature(destructuring_assignment)]\n+\n+const C: i32 = 1;\n+\n+fn main() {\n+    let (mut a, mut b);\n+    (a, .., b, ..) = (0, 1); //~ ERROR `..` can only be used once per tuple pattern\n+    (a, a, b) = (1, 2); //~ ERROR mismatched types\n+    (C, ..) = (0,1); //~ ERROR invalid left-hand side of assignment\n+}"}, {"sha": "a60e1cb1eec628649404821d9bc6fa84fe2669b8", "filename": "src/test/ui/destructuring-assignment/tuple_destructure_fail.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,31 @@\n+error: `..` can only be used once per tuple pattern\n+  --> $DIR/tuple_destructure_fail.rs:7:16\n+   |\n+LL |     (a, .., b, ..) = (0, 1);\n+   |         --     ^^ can only be used once per tuple pattern\n+   |         |\n+   |         previously used here\n+\n+error[E0308]: mismatched types\n+  --> $DIR/tuple_destructure_fail.rs:8:5\n+   |\n+LL |     (a, a, b) = (1, 2);\n+   |     ^^^^^^^^^   ------ this expression has type `({integer}, {integer})`\n+   |     |\n+   |     expected a tuple with 2 elements, found one with 3 elements\n+   |\n+   = note: expected type `({integer}, {integer})`\n+             found tuple `(_, _, _)`\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_destructure_fail.rs:9:13\n+   |\n+LL |     (C, ..) = (0,1);\n+   |      -      ^\n+   |      |\n+   |      cannot assign to this expression\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "c1c5c2cd3cebb524ea476e3938025c6304c2bec5", "filename": "src/test/ui/destructuring-assignment/warn-unused-duplication.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+#![warn(unused_assignments)]\n+\n+fn main() {\n+    let mut a;\n+    // Assignment occurs left-to-right.\n+    // However, we emit warnings when this happens, so it is clear that this is happening.\n+    (a, a) = (0, 1); //~ WARN value assigned to `a` is never read\n+    assert_eq!(a, 1);\n+\n+    // We can't always tell when a variable is being assigned to twice, which is why we don't try\n+    // to emit an error, which would be fallible.\n+    let mut x = 1;\n+    (*foo(&mut x), *foo(&mut x)) = (5, 6);\n+    assert_eq!(x, 6);\n+}\n+\n+fn foo<'a>(x: &'a mut u32) -> &'a mut u32 {\n+    x\n+}"}, {"sha": "b87ef6f1571c18e4d976ace9cbe2728de02ef310", "filename": "src/test/ui/destructuring-assignment/warn-unused-duplication.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.stderr?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,15 @@\n+warning: value assigned to `a` is never read\n+  --> $DIR/warn-unused-duplication.rs:11:6\n+   |\n+LL |     (a, a) = (0, 1);\n+   |      ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/warn-unused-duplication.rs:5:9\n+   |\n+LL | #![warn(unused_assignments)]\n+   |         ^^^^^^^^^^^^^^^^^^\n+   = help: maybe it is overwritten before being read?\n+\n+warning: 1 warning emitted\n+"}, {"sha": "e7801f0e8ec2b760116bb95daca1eb08e0f2ccb3", "filename": "src/test/ui/feature-gates/feature-gate-destructuring_assignment.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let (a, b) = (0, 1);\n+    (a, b) = (2, 3); //~ ERROR destructuring assignments are unstable\n+}"}, {"sha": "62e71decb32a0bab1e229e52dc196819d6a4d4e3", "filename": "src/test/ui/feature-gates/feature-gate-destructuring_assignment.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.stderr?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -0,0 +1,14 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/feature-gate-destructuring_assignment.rs:3:12\n+   |\n+LL |     (a, b) = (2, 3);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "687354dc6aee23e6740d846264d2c294aec33e36", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8f02690804d5ee696bd3bca9515f5f71857e3b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=fe8f02690804d5ee696bd3bca9515f5f71857e3b", "patch": "@@ -155,6 +155,7 @@ static TARGETS: &[&str] = &[\n ];\n \n static DOCS_TARGETS: &[&str] = &[\n+    \"aarch64-unknown-linux-gnu\",\n     \"i686-apple-darwin\",\n     \"i686-pc-windows-gnu\",\n     \"i686-pc-windows-msvc\","}]}