{"sha": "a214fee0ba115c139095d7a9105b7c3aaa2d15fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMTRmZWUwYmExMTVjMTM5MDk1ZDdhOTEwNWI3YzNhYWEyZDE1ZmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-23T03:13:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-29T21:30:54Z"}, "message": "libfuzzer: De-mode the fuzzer.", "tree": {"sha": "b94bd2344c23af089e558042c8656c1bb87777c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b94bd2344c23af089e558042c8656c1bb87777c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a214fee0ba115c139095d7a9105b7c3aaa2d15fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a214fee0ba115c139095d7a9105b7c3aaa2d15fe", "html_url": "https://github.com/rust-lang/rust/commit/a214fee0ba115c139095d7a9105b7c3aaa2d15fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a214fee0ba115c139095d7a9105b7c3aaa2d15fe/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0780b2830f06babba21dcd9f6c325576dd374183", "url": "https://api.github.com/repos/rust-lang/rust/commits/0780b2830f06babba21dcd9f6c325576dd374183", "html_url": "https://github.com/rust-lang/rust/commit/0780b2830f06babba21dcd9f6c325576dd374183"}], "stats": {"total": 301, "additions": 170, "deletions": 131}, "files": [{"sha": "fc1efd3313cbc2857b5335dcb8cd7c577d4d5781", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 170, "deletions": 131, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/a214fee0ba115c139095d7a9105b7c3aaa2d15fe/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a214fee0ba115c139095d7a9105b7c3aaa2d15fe/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=a214fee0ba115c139095d7a9105b7c3aaa2d15fe", "patch": "@@ -18,42 +18,38 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[legacy_modes];\n-\n-#[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n \n extern mod std(vers = \"0.7-pre\");\n extern mod syntax(vers = \"0.7-pre\");\n \n use core::run;\n \n-use syntax::{ast, fold, visit, codemap};\n+use syntax::diagnostic;\n+use syntax::parse::token::ident_interner;\n+use syntax::parse::token;\n use syntax::parse;\n use syntax::print::pprust;\n-use syntax::diagnostic;\n+use syntax::{ast, fold, visit, codemap};\n \n #[deriving(Eq)]\n pub enum test_mode { tm_converge, tm_run, }\n \n pub struct Context { mode: test_mode } // + rng\n \n-pub fn write_file(filename: &Path, content: ~str) {\n-    result::get(\n-        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n-        .write_str(content);\n+pub fn write_file(filename: &Path, content: &str) {\n+    result::get(&io::file_writer(filename, ~[io::Create, io::Truncate]))\n+                    .write_str(content);\n }\n \n-pub fn contains(haystack: ~str, needle: ~str) -> bool {\n+pub fn contains(haystack: &str, needle: &str) -> bool {\n     str::contains(haystack, needle)\n }\n \n pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n     if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n-        files.push(*path);\n+        files.push(path.clone());\n     } else if os::path_is_dir(path)\n         && !contains(path.to_str(), ~\"compile-fail\")\n         && !contains(path.to_str(), ~\"build\") {\n@@ -64,9 +60,9 @@ pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n }\n \n \n-pub fn common_exprs() -> ~[ast::expr] {\n-    fn dse(e: ast::expr_) -> ast::expr {\n-        ast::expr {\n+pub fn common_exprs() -> ~[@ast::expr] {\n+    fn dse(e: ast::expr_) -> @ast::expr {\n+        @ast::expr {\n             id: 0,\n             callee_id: -1,\n             node: e,\n@@ -85,17 +81,17 @@ pub fn common_exprs() -> ~[ast::expr] {\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n      dse(ast::expr_unary(ast::box(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n+                         dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n      dse(ast::expr_unary(ast::uniq(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n+                         dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n     ]\n }\n \n pub fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    safe_to_use_expr(*e, tm)\n+    safe_to_use_expr(e, tm)\n }\n \n-pub fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+pub fn safe_to_use_expr(e: @ast::expr, tm: test_mode) -> bool {\n     match tm {\n       tm_converge => {\n         match e.node {\n@@ -134,28 +130,31 @@ pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n pub fn stash_expr_if(c: @fn(@ast::expr, test_mode)->bool,\n-                     es: @mut ~[ast::expr],\n+                     es: @mut ~[@ast::expr],\n                      e: @ast::expr,\n                      tm: test_mode) {\n     if c(e, tm) {\n-        *es += ~[*e];\n+        *es += ~[e];\n     } else {\n         /* now my indices are wrong :( */\n     }\n }\n \n-pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode)->bool,\n-                   es: @mut ~[ast::Ty],\n+pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode) -> bool,\n+                   es: @mut ~[@ast::Ty],\n                    e: @ast::Ty,\n                    tm: test_mode) {\n     if c(e, tm) {\n-        es.push(*e);\n+        es.push(e);\n     } else {\n         /* now my indices are wrong :( */\n     }\n }\n \n-pub struct StolenStuff {exprs: ~[ast::expr], tys: ~[ast::Ty]}\n+pub struct StolenStuff {\n+    exprs: ~[@ast::expr],\n+    tys: ~[@ast::Ty]\n+}\n \n pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n     let exprs = @mut ~[];\n@@ -166,20 +165,23 @@ pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n         .. *visit::default_simple_visitor()\n     });\n     visit::visit_crate(crate, (), v);\n-    StolenStuff {exprs: *exprs, tys: *tys}\n+    StolenStuff {\n+        exprs: (*exprs).clone(),\n+        tys: (*tys).clone(),\n+    }\n }\n \n \n pub fn safe_to_replace_expr(e: &ast::expr_, _tm: test_mode) -> bool {\n     match *e {\n-      // https://github.com/mozilla/rust/issues/652\n-      ast::expr_if(*) => { false }\n-      ast::expr_block(_) => { false }\n+        // https://github.com/mozilla/rust/issues/652\n+        ast::expr_if(*) => false,\n+        ast::expr_block(_) => false,\n \n-      // expr_call is also missing a constraint\n-      ast::expr_fn_block(*) => { false }\n+        // expr_call is also missing a constraint\n+        ast::expr_fn_block(*) => false,\n \n-      _ => { true }\n+        _ => true,\n     }\n }\n \n@@ -194,59 +196,66 @@ pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-pub fn replace_expr_in_crate(crate: @ast::crate, i: uint,\n-                             newexpr: ast::expr, tm: test_mode) ->\n-   ast::crate {\n+pub fn replace_expr_in_crate(crate: @ast::crate,\n+                             i: uint,\n+                             newexpr: @ast::expr,\n+                             tm: test_mode)\n+                             -> @ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_expr_rep(j_: @mut uint,\n                      i_: uint,\n-                     newexpr_: ast::expr_,\n+                     newexpr_: &ast::expr_,\n                      original: &ast::expr_,\n                      fld: @fold::ast_fold,\n                      tm_: test_mode)\n-                  -> ast::expr_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n-            newexpr_\n+                     -> ast::expr_ {\n+        *j_ += 1;\n+        if i_ + 1 == *j_ && safe_to_replace_expr(original, tm_) {\n+            copy *newexpr_\n         } else {\n             fold::noop_fold_expr(original, fld)\n         }\n     }\n     let afp = @fold::AstFoldFns {\n         fold_expr: fold::wrap(|a,b| {\n-            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n+            fold_expr_rep(j, i, &newexpr.node, a, b, tm)\n         }),\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n+    crate2\n }\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-pub fn replace_ty_in_crate(crate: @ast::crate, i: uint, newty: ast::Ty,\n-                           tm: test_mode) -> ast::crate {\n+pub fn replace_ty_in_crate(crate: @ast::crate,\n+                           i: uint,\n+                           newty: @ast::Ty,\n+                           tm: test_mode)\n+                           -> @ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint,\n                    i_: uint,\n-                   newty_: ast::ty_,\n+                   newty_: &ast::ty_,\n                    original: &ast::ty_,\n                    fld: @fold::ast_fold,\n                    tm_: test_mode)\n-                -> ast::ty_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n-            newty_\n-        } else { fold::noop_fold_ty(original, fld) }\n+                   -> ast::ty_ {\n+        *j_ += 1;\n+        if i_ + 1 == *j_ && safe_to_replace_ty(original, tm_) {\n+            copy *newty_\n+        } else {\n+            fold::noop_fold_ty(original, fld)\n+        }\n     }\n     let afp = @fold::AstFoldFns {\n-        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n+        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, &newty.node, a, b, tm)),\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n+    crate2\n }\n \n pub fn under(n: uint, it: &fn(uint)) {\n@@ -258,29 +267,44 @@ pub fn as_str(f: @fn(+x: @io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n-pub fn check_variants_of_ast(crate: @ast::crate, codemap: @codemap::CodeMap,\n-                             filename: &Path, cx: Context) {\n+pub fn check_variants_of_ast(crate: @ast::crate,\n+                             codemap: @codemap::CodeMap,\n+                             filename: &Path,\n+                             cx: Context) {\n     let stolen = steal(crate, cx.mode);\n-    let extra_exprs = do common_exprs().filtered |a| {\n-        safe_to_use_expr(*a, cx.mode)\n+    let extra_exprs = do common_exprs().filtered |&a| {\n+        safe_to_use_expr(a, cx.mode)\n     };\n-    check_variants_T(crate, codemap, filename, ~\"expr\",\n-                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n-                     replace_expr_in_crate, cx);\n-    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n-                     pprust::ty_to_str, replace_ty_in_crate, cx);\n-}\n-\n-pub fn check_variants_T<T: Copy>(\n-  crate: @ast::crate,\n-  codemap: @codemap::CodeMap,\n-  filename: &Path,\n-  thing_label: ~str,\n-  things: ~[T],\n-  stringifier: @fn(@T, @syntax::parse::token::ident_interner) -> ~str,\n-  replacer: @fn(@ast::crate, uint, T, test_mode) -> ast::crate,\n-  cx: Context\n-  ) {\n+    check_variants_T(crate,\n+                     codemap,\n+                     filename,\n+                     ~\"expr\",\n+                     extra_exprs + stolen.exprs,\n+                     pprust::expr_to_str,\n+                     replace_expr_in_crate,\n+                     cx);\n+    check_variants_T(crate,\n+                     codemap,\n+                     filename,\n+                     ~\"ty\",\n+                     stolen.tys,\n+                     pprust::ty_to_str,\n+                     replace_ty_in_crate,\n+                     cx);\n+}\n+\n+pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n+                                codemap: @codemap::CodeMap,\n+                                filename: &Path,\n+                                thing_label: ~str,\n+                                things: &[T],\n+                                stringifier: @fn(T, @ident_interner) -> ~str,\n+                                replacer: @fn(@ast::crate,\n+                                              uint,\n+                                              T,\n+                                              test_mode)\n+                                              -> @ast::crate,\n+                                cx: Context) {\n     error!(\"%s contains %u %s objects\", filename.to_str(),\n            things.len(), thing_label);\n \n@@ -294,36 +318,43 @@ pub fn check_variants_T<T: Copy>(\n             error!(\"Replacing... #%?\", uint::to_str(i));\n             let fname = str::from_slice(filename.to_str());\n             do under(uint::min(L, 30)) |j| {\n-                error!(\"With... %?\", stringifier(@things[j], intr));\n-                let crate2 = @replacer(crate, i, things[j], cx.mode);\n+                let fname = fname.to_str();\n+                error!(\"With... %?\", stringifier(things[j], intr));\n+                let crate2 = replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n                 // testing the string for stability is easier and ok for now.\n                 let handler = diagnostic::mk_handler(None);\n                 let str3 = do io::with_str_reader(\"\") |rdr| {\n-                    @as_str(|a|pprust::print_crate(\n-                        codemap,\n-                        intr,\n-                        diagnostic::mk_span_handler(handler, codemap),\n-                        crate2,\n-                        fname,\n-                        rdr,\n-                        a,\n-                        pprust::no_ann(),\n-                        false))\n+                    let fname = fname.to_str();\n+                    let string = do as_str |a| {\n+                        let span_handler =\n+                            diagnostic::mk_span_handler(handler, codemap);\n+                        pprust::print_crate(codemap,\n+                                            intr,\n+                                            span_handler,\n+                                            crate2,\n+                                            fname.to_str(),\n+                                            rdr,\n+                                            a,\n+                                            pprust::no_ann(),\n+                                            false)\n+                    };\n+                    @string\n                 };\n                 match cx.mode {\n-                  tm_converge => {\n-                    check_roundtrip_convergence(str3, 1u);\n-                  }\n-                  tm_run => {\n-                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                          last_part(filename.to_str()),\n-                                          thing_label, i, j);\n-                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n-                                        || has_raw_pointers(crate2));\n-                    check_whole_compiler(*str3, &Path(file_label),\n-                                         safe_to_run);\n-                  }\n+                    tm_converge => check_roundtrip_convergence(str3, 1),\n+                    tm_run => {\n+                        let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n+                                              last_part(filename.to_str()),\n+                                              thing_label,\n+                                              i,\n+                                              j);\n+                        let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                                            || has_raw_pointers(crate2));\n+                        check_whole_compiler(*str3,\n+                                             &Path(file_label),\n+                                             safe_to_run);\n+                    }\n                 }\n             }\n         }\n@@ -347,7 +378,8 @@ pub enum happiness {\n // - that would be tricky, requiring use of tasks or serialization\n //   or randomness.\n // This seems to find plenty of bugs as it is :)\n-pub fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n+pub fn check_whole_compiler(code: &str,\n+                            suggested_filename_prefix: &Path,\n                             allow_running: bool) {\n     let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n     write_file(filename, code);\n@@ -460,20 +492,24 @@ pub fn parse_and_print(code: @~str) -> ~str {\n     let filename = Path(\"tmp.rs\");\n     let sess = parse::new_parse_sess(option::None);\n     write_file(&filename, *code);\n-    let crate = parse::parse_crate_from_source_str(\n-        filename.to_str(), code, ~[], sess);\n+    let crate = parse::parse_crate_from_source_str(filename.to_str(),\n+                                                   code,\n+                                                   ~[],\n+                                                   sess);\n     do io::with_str_reader(*code) |rdr| {\n-        as_str(|a|\n-               pprust::print_crate(\n-                   sess.cm,\n-                   // Assuming there are no token_trees\n-                   syntax::parse::token::mk_fake_ident_interner(),\n-                   copy sess.span_diagnostic,\n-                   crate,\n-                   filename.to_str(),\n-                   rdr, a,\n-                   pprust::no_ann(),\n-                   false) )\n+        let filename = filename.to_str();\n+        do as_str |a| {\n+            pprust::print_crate(sess.cm,\n+                                // Assuming there are no token_trees\n+                                token::mk_fake_ident_interner(),\n+                                copy sess.span_diagnostic,\n+                                crate,\n+                                filename.to_str(),\n+                                rdr,\n+                                a,\n+                                pprust::no_ann(),\n+                                false)\n+        }\n     }\n }\n \n@@ -493,7 +529,7 @@ pub fn has_raw_pointers(c: @ast::crate) -> bool {\n     return *has_rp;\n }\n \n-pub fn content_is_dangerous_to_run(code: ~str) -> bool {\n+pub fn content_is_dangerous_to_run(code: &str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\",\n          ~\"import\",  // espeically fs, run\n@@ -505,15 +541,15 @@ pub fn content_is_dangerous_to_run(code: ~str) -> bool {\n     return false;\n }\n \n-pub fn content_is_dangerous_to_compile(code: ~str) -> bool {\n+pub fn content_is_dangerous_to_compile(code: &str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\"];\n \n     for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n     return false;\n }\n \n-pub fn content_might_not_converge(code: ~str) -> bool {\n+pub fn content_might_not_converge(code: &str) -> bool {\n     let confusing_patterns =\n         ~[~\"xfail-test\",\n          ~\"xfail-pretty\",\n@@ -549,7 +585,6 @@ pub fn file_might_not_converge(filename: &Path) -> bool {\n }\n \n pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n-\n     let mut i = 0u;\n     let mut newv = code;\n     let mut oldv = code;\n@@ -613,23 +648,27 @@ pub fn check_variants(files: &[Path], cx: Context) {\n         let file_str = file.to_str();\n \n         error!(\"check_variants: %?\", file_str);\n-        let sess = parse::new_parse_sess(option::None);\n-        let crate =\n-            parse::parse_crate_from_source_str(\n-                file_str,\n-                s, ~[], sess);\n+        let sess = parse::new_parse_sess(None);\n+        let crate = parse::parse_crate_from_source_str(file_str.to_str(),\n+                                                       s,\n+                                                       ~[],\n+                                                       sess);\n         io::with_str_reader(*s, |rdr| {\n+            let file_str = file_str.to_str();\n             error!(\"%s\",\n-                   as_str(|a| pprust::print_crate(\n-                       sess.cm,\n-                       // Assuming no token_trees\n-                       syntax::parse::token::mk_fake_ident_interner(),\n-                       copy sess.span_diagnostic,\n-                       crate,\n-                       file_str,\n-                       rdr, a,\n-                       pprust::no_ann(),\n-                       false)))\n+                   as_str(|a| {\n+                    pprust::print_crate(\n+                        sess.cm,\n+                        // Assuming no token_trees\n+                        token::mk_fake_ident_interner(),\n+                        copy sess.span_diagnostic,\n+                        crate,\n+                        file_str.to_str(),\n+                        rdr,\n+                        a,\n+                        pprust::no_ann(),\n+                        false)\n+                    }))\n         });\n         check_variants_of_ast(crate, sess.cm, file, cx);\n     }"}]}