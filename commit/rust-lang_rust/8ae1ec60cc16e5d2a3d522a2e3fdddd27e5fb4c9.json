{"sha": "8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZTFlYzYwY2MxNmU1ZDJhM2Q1MjJhMmUzZmRkZGQyN2U1ZmI0Yzk=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-09-12T00:13:34Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-09-28T20:52:18Z"}, "message": "Spawn one subprocess per unit test when panic=abort", "tree": {"sha": "a2764361c43fe99fb568cd8c671d77883a1c7819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2764361c43fe99fb568cd8c671d77883a1c7819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "html_url": "https://github.com/rust-lang/rust/commit/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76b12bd8fdd8c512cf9685a8ec51e76643f2f86f", "url": "https://api.github.com/repos/rust-lang/rust/commits/76b12bd8fdd8c512cf9685a8ec51e76643f2f86f", "html_url": "https://github.com/rust-lang/rust/commit/76b12bd8fdd8c512cf9685a8ec51e76643f2f86f"}], "stats": {"total": 404, "additions": 304, "deletions": 100}, "files": [{"sha": "41d3b5b52b4a5e2514e474e2e75e417ad4858b93", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "patch": "@@ -440,6 +440,7 @@ fn configure_and_expand_inner<'a>(\n             &mut krate,\n             sess.diagnostic(),\n             &sess.features_untracked(),\n+            sess.panic_strategy(),\n         )\n     });\n "}, {"sha": "dcaf07341e550d5799e21aef310959c4c25fd91d", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "patch": "@@ -2,6 +2,7 @@\n \n use log::debug;\n use smallvec::{smallvec, SmallVec};\n+use rustc_target::spec::PanicStrategy;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n@@ -25,6 +26,7 @@ struct Test {\n \n struct TestCtxt<'a> {\n     ext_cx: ExtCtxt<'a>,\n+    panic_strategy: PanicStrategy,\n     def_site: Span,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n@@ -40,6 +42,7 @@ pub fn inject(\n     krate: &mut ast::Crate,\n     span_diagnostic: &errors::Handler,\n     features: &Features,\n+    panic_strategy: PanicStrategy,\n ) {\n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be\n@@ -54,7 +57,7 @@ pub fn inject(\n \n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, features, test_runner)\n+                              krate, features, panic_strategy, test_runner)\n     }\n }\n \n@@ -183,6 +186,7 @@ fn generate_test_harness(sess: &ParseSess,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: &mut ast::Crate,\n                          features: &Features,\n+                         panic_strategy: PanicStrategy,\n                          test_runner: Option<ast::Path>) {\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n@@ -203,6 +207,7 @@ fn generate_test_harness(sess: &ParseSess,\n \n     let cx = TestCtxt {\n         ext_cx,\n+        panic_strategy,\n         def_site,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n@@ -248,9 +253,14 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let ecx = &cx.ext_cx;\n     let test_id = Ident::new(sym::test, sp);\n \n+    let runner_name = match cx.panic_strategy {\n+        PanicStrategy::Unwind => \"test_main_static\",\n+        PanicStrategy::Abort => \"test_main_static_abort\",\n+    };\n+\n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![test_id, ecx.ident_of(\"test_main_static\", sp)]));\n+        ecx.path(sp, vec![test_id, ecx.ident_of(runner_name, sp)]));\n \n     test_runner.span = sp;\n "}, {"sha": "dd202fb3ab6faa0536b4843d7c4d2a6f9b8855f6", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "patch": "@@ -22,3 +22,12 @@ pub(crate) trait OutputFormatter {\n     ) -> io::Result<()>;\n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n }\n+\n+pub(crate) fn write_stderr_delimiter(test_output: &mut Vec<u8>, test_name: &TestName) {\n+    match test_output.last() {\n+        Some(b'\\n') => (),\n+        Some(_) => test_output.push(b'\\n'),\n+        None => (),\n+    }\n+    write!(test_output, \"---- {} stderr ----\\n\", test_name).unwrap();\n+}"}, {"sha": "f04d289c4ef332227b1e9ef2ef333cb8ed820cbf", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 274, "deletions": 90, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "patch": "@@ -21,7 +21,8 @@\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![feature(asm)]\n-#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc, rustc_private))]\n+#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n+#![feature(rustc_private)]\n #![feature(nll)]\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n@@ -34,16 +35,6 @@ use getopts;\n extern crate libc;\n use term;\n \n-// FIXME(#54291): rustc and/or LLVM don't yet support building with panic-unwind\n-//                on aarch64-pc-windows-msvc, or thumbv7a-pc-windows-msvc\n-//                so we don't link libtest against libunwind (for the time being)\n-//                even though it means that libtest won't be fully functional on\n-//                these platforms.\n-//\n-// See also: https://github.com/rust-lang/rust/issues/54190#issuecomment-422904437\n-#[cfg(not(all(windows, any(target_arch = \"aarch64\", target_arch = \"arm\"))))]\n-extern crate panic_unwind;\n-\n pub use self::ColorConfig::*;\n use self::NamePadding::*;\n use self::OutputLocation::*;\n@@ -61,10 +52,10 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo};\n use std::path::PathBuf;\n use std::process;\n-use std::process::Termination;\n+use std::process::{ExitStatus, Command, Termination};\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n@@ -76,13 +67,21 @@ mod tests;\n const TEST_WARN_TIMEOUT_S: u64 = 60;\n const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n \n+const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n+\n+// Return codes for secondary process.\n+// Start somewhere other than 0 so we know the return code means what we think\n+// it means.\n+const TR_OK: i32 = 50;\n+const TR_FAILED: i32 = 51;\n+\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use crate::{\n         assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n-        StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName, TestOpts,\n-        TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n+        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, RunStrategy,\n+        ShouldPanic, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n+        TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n     };\n }\n \n@@ -257,19 +256,26 @@ impl Metric {\n #[derive(Copy, Clone, Debug)]\n pub struct Options {\n     display_output: bool,\n+    panic_abort: bool,\n }\n \n impl Options {\n     pub fn new() -> Options {\n         Options {\n             display_output: false,\n+            panic_abort: false,\n         }\n     }\n \n     pub fn display_output(mut self, display_output: bool) -> Options {\n         self.display_output = display_output;\n         self\n     }\n+\n+    pub fn panic_abort(mut self, panic_abort: bool) -> Options {\n+        self.panic_abort = panic_abort;\n+        self\n+    }\n }\n \n // The default console test runner. It accepts the command line\n@@ -303,32 +309,66 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n     }\n }\n \n-// A variant optimized for invocation with a static test vector.\n-// This will panic (intentionally) when fed any dynamic tests, because\n-// it is copying the static values out into a dynamic vector and cannot\n-// copy dynamic values. It is doing this because from this point on\n-// a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n-// semantics into parallel test runners, which in turn requires a Vec<>\n-// rather than a &[].\n+/// A variant optimized for invocation with a static test vector.\n+/// This will panic (intentionally) when fed any dynamic tests.\n+///\n+/// This is the entry point for the main function generated by `rustc --test`\n+/// when panic=unwind.\n pub fn test_main_static(tests: &[&TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n-    let owned_tests = tests\n-        .iter()\n-        .map(|t| match t.testfn {\n-            StaticTestFn(f) => TestDescAndFn {\n-                testfn: StaticTestFn(f),\n-                desc: t.desc.clone(),\n-            },\n-            StaticBenchFn(f) => TestDescAndFn {\n-                testfn: StaticBenchFn(f),\n-                desc: t.desc.clone(),\n-            },\n-            _ => panic!(\"non-static tests passed to test::test_main_static\"),\n-        })\n-        .collect();\n+    let owned_tests: Vec<_> = tests.iter().map(make_owned_test).collect();\n     test_main(&args, owned_tests, None)\n }\n \n+/// A variant optimized for invocation with a static test vector.\n+/// This will panic (intentionally) when fed any dynamic tests.\n+///\n+/// Runs tests in panic=abort mode, which involves spawning subprocesses for\n+/// tests.\n+///\n+/// This is the entry point for the main function generated by `rustc --test`\n+/// when panic=abort.\n+pub fn test_main_static_abort(tests: &[&TestDescAndFn]) {\n+    // If we're being run in SpawnedSecondary mode, run the test here. run_test\n+    // will then exit the process.\n+    if let Ok(name) = env::var(SECONDARY_TEST_INVOKER_VAR) {\n+        let test = tests\n+            .iter()\n+            .filter(|test| test.desc.name.as_slice() == name)\n+            .map(make_owned_test)\n+            .next()\n+            .expect(\"couldn't find a test with the provided name\");\n+        let TestDescAndFn { desc, testfn } = test;\n+        let testfn = match testfn {\n+            StaticTestFn(f) => f,\n+            _ => panic!(\"only static tests are supported\"),\n+        };\n+        run_test_in_spawned_subprocess(desc, Box::new(testfn));\n+    }\n+\n+    let args = env::args().collect::<Vec<_>>();\n+    let owned_tests: Vec<_> = tests.iter().map(make_owned_test).collect();\n+    test_main(&args, owned_tests, Some(Options::new().panic_abort(true)))\n+}\n+\n+/// Clones static values for putting into a dynamic vector, which test_main()\n+/// needs to hand out ownership of tests to parallel test runners.\n+///\n+/// This will panic when fed any dynamic tests, because they cannot be cloned.\n+fn make_owned_test(test: &&TestDescAndFn) -> TestDescAndFn {\n+    match test.testfn {\n+        StaticTestFn(f) => TestDescAndFn {\n+            testfn: StaticTestFn(f),\n+            desc: test.desc.clone(),\n+        },\n+        StaticBenchFn(f) => TestDescAndFn {\n+            testfn: StaticBenchFn(f),\n+            desc: test.desc.clone(),\n+        },\n+        _ => panic!(\"non-static tests passed to test::test_main_static\"),\n+    }\n+}\n+\n /// Invoked when unit tests terminate. Should panic if the unit\n /// Tests is considered a failure. By default, invokes `report()`\n /// and checks for a `0` result.\n@@ -1062,6 +1102,18 @@ impl Write for Sink {\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub enum RunStrategy {\n+    /// Runs the test in the current process, and sends the result back over the\n+    /// supplied channel.\n+    InProcess,\n+\n+    /// Spawns a subprocess to run the test, and sends the result back over the\n+    /// supplied channel. Requires argv[0] to exist and point to the binary\n+    /// that's currently running.\n+    SpawnPrimary,\n+}\n+\n pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n where\n     F: FnMut(TestEvent) -> io::Result<()>,\n@@ -1109,6 +1161,11 @@ where\n     let mut pending = 0;\n \n     let (tx, rx) = channel::<MonitorMsg>();\n+    let run_strategy = if opts.options.panic_abort {\n+        RunStrategy::SpawnPrimary\n+    } else {\n+        RunStrategy::InProcess\n+    };\n \n     let mut running_tests: TestMap = HashMap::default();\n \n@@ -1145,7 +1202,7 @@ where\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n             callback(TeWait(test.desc.clone()))?;\n-            run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::No);\n+            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n             let (test, result, exec_time, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, exec_time, stdout))?;\n         }\n@@ -1156,7 +1213,7 @@ where\n                 let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n                 running_tests.insert(test.desc.clone(), timeout);\n                 callback(TeWait(test.desc.clone()))?; //here no pad\n-                run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::Yes);\n+                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n                 pending += 1;\n             }\n \n@@ -1188,7 +1245,7 @@ where\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n             callback(TeWait(b.desc.clone()))?;\n-            run_test(opts, false, b, tx.clone(), Concurrent::No);\n+            run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n             let (test, result, exec_time, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, exec_time, stdout))?;\n         }\n@@ -1415,64 +1472,38 @@ pub fn run_test(\n     opts: &TestOpts,\n     force_ignore: bool,\n     test: TestDescAndFn,\n+    strategy: RunStrategy,\n     monitor_ch: Sender<MonitorMsg>,\n     concurrency: Concurrent,\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\")\n+    let ignore_because_no_process_support = cfg!(target_arch = \"wasm32\")\n         && !cfg!(target_os = \"emscripten\")\n         && desc.should_panic != ShouldPanic::No;\n \n-    if force_ignore || desc.ignore || ignore_because_panic_abort {\n+    if force_ignore || desc.ignore || ignore_because_no_process_support {\n         monitor_ch.send((desc, TrIgnored, None, Vec::new())).unwrap();\n         return;\n     }\n \n     fn run_test_inner(\n         desc: TestDesc,\n-        monitor_ch: Sender<MonitorMsg>,\n         nocapture: bool,\n         report_time: bool,\n+        strategy: RunStrategy,\n+        monitor_ch: Sender<MonitorMsg>,\n         testfn: Box<dyn FnOnce() + Send>,\n         concurrency: Concurrent,\n     ) {\n-        // Buffer for capturing standard I/O\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let data2 = data.clone();\n-\n         let name = desc.name.clone();\n-        let runtest = move || {\n-            let oldio = if !nocapture {\n-                Some((\n-                    io::set_print(Some(Box::new(Sink(data2.clone())))),\n-                    io::set_panic(Some(Box::new(Sink(data2)))),\n-                ))\n-            } else {\n-                None\n-            };\n-\n-            let start = if report_time {\n-                Some(Instant::now())\n-            } else {\n-                None\n-            };\n-            let result = catch_unwind(AssertUnwindSafe(testfn));\n-            let exec_time = start.map(|start| {\n-                let duration = start.elapsed();\n-                TestExecTime(duration)\n-            });\n-\n-            if let Some((printio, panicio)) = oldio {\n-                io::set_print(printio);\n-                io::set_panic(panicio);\n-            };\n \n-            let test_result = calc_result(&desc, result);\n-            let stdout = data.lock().unwrap().to_vec();\n-            monitor_ch\n-                .send((desc.clone(), test_result, exec_time, stdout))\n-                .unwrap();\n+        let runtest = move || {\n+            match strategy {\n+                RunStrategy::InProcess =>\n+                    run_test_in_process(desc, nocapture, report_time, testfn, monitor_ch),\n+                RunStrategy::SpawnPrimary => spawn_test_subprocess(desc, report_time, monitor_ch),\n+            }\n         };\n \n         // If the platform is single-threaded we're just going to run\n@@ -1489,31 +1520,38 @@ pub fn run_test(\n \n     match testfn {\n         DynBenchFn(bencher) => {\n+            // Benchmarks aren't expected to panic, so we run them all in-process.\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                 bencher.run(harness)\n             });\n         }\n         StaticBenchFn(benchfn) => {\n+            // Benchmarks aren't expected to panic, so we run them all in-process.\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                 (benchfn.clone())(harness)\n             });\n         }\n         DynTestFn(f) => {\n-            let cb = move || __rust_begin_short_backtrace(f);\n+            match strategy {\n+                RunStrategy::InProcess => (),\n+                _ => panic!(\"Cannot run dynamic test fn out-of-process\"),\n+            };\n             run_test_inner(\n                 desc,\n-                monitor_ch,\n                 opts.nocapture,\n                 opts.report_time,\n-                Box::new(cb),\n-                concurrency,\n-            )\n+                strategy,\n+                monitor_ch,\n+                Box::new(move || __rust_begin_short_backtrace(f)),\n+                concurrency\n+            );\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,\n-            monitor_ch,\n             opts.nocapture,\n             opts.report_time,\n+            strategy,\n+            monitor_ch,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n             concurrency,\n         ),\n@@ -1526,7 +1564,9 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n     f()\n }\n \n-fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) -> TestResult {\n+fn calc_result<'a>(desc: &TestDesc,\n+                   task_result: Result<(), &'a (dyn Any + 'static + Send)>)\n+-> TestResult {\n     match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n@@ -1552,6 +1592,150 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) ->\n     }\n }\n \n+fn get_result_from_exit_code(desc: &TestDesc, code: i32) -> TestResult {\n+    match (desc.allow_fail, code) {\n+        (_, TR_OK) => TrOk,\n+        (true, TR_FAILED) => TrAllowedFail,\n+        (false, TR_FAILED) => TrFailed,\n+        (_, _) => TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n+    }\n+}\n+\n+fn run_test_in_process(desc: TestDesc,\n+                       nocapture: bool,\n+                       report_time: bool,\n+                       testfn: Box<dyn FnOnce() + Send>,\n+                       monitor_ch: Sender<MonitorMsg>) {\n+    // Buffer for capturing standard I/O\n+    let data = Arc::new(Mutex::new(Vec::new()));\n+\n+    let oldio = if !nocapture {\n+        Some((\n+            io::set_print(Some(Box::new(Sink(data.clone())))),\n+            io::set_panic(Some(Box::new(Sink(data.clone())))),\n+        ))\n+    } else {\n+        None\n+    };\n+\n+    let start = if report_time {\n+        Some(Instant::now())\n+    } else {\n+        None\n+    };\n+    let result = catch_unwind(AssertUnwindSafe(testfn));\n+    let exec_time = start.map(|start| {\n+        let duration = start.elapsed();\n+        TestExecTime(duration)\n+    });\n+\n+    if let Some((printio, panicio)) = oldio {\n+        io::set_print(printio);\n+        io::set_panic(panicio);\n+    }\n+\n+    let test_result = match result {\n+        Ok(()) => calc_result(&desc, Ok(())),\n+        Err(e) => calc_result(&desc, Err(e.as_ref())),\n+    };\n+    let stdout = data.lock().unwrap().to_vec();\n+    monitor_ch.send((desc.clone(), test_result, exec_time, stdout)).unwrap();\n+}\n+\n+fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<MonitorMsg>) {\n+    let (result, test_output, exec_time) = (|| {\n+        let args = env::args().collect::<Vec<_>>();\n+        let current_exe = &args[0];\n+\n+        let start = if report_time {\n+            Some(Instant::now())\n+        } else {\n+            None\n+        };\n+        let output = match Command::new(current_exe)\n+            .env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice())\n+            .output() {\n+                Ok(out) => out,\n+                Err(e) => {\n+                    let err = format!(\"Failed to spawn {} as child for test: {:?}\", args[0], e);\n+                    return (TrFailed, err.into_bytes(), None);\n+                }\n+            };\n+        let exec_time = start.map(|start| {\n+            let duration = start.elapsed();\n+            TestExecTime(duration)\n+        });\n+\n+        let std::process::Output { stdout, stderr, status } = output;\n+        let mut test_output = stdout;\n+        formatters::write_stderr_delimiter(&mut test_output, &desc.name);\n+        test_output.extend_from_slice(&stderr);\n+\n+        let result = match (|| -> Result<TestResult, String> {\n+            let exit_code = get_exit_code(status)?;\n+            Ok(get_result_from_exit_code(&desc, exit_code))\n+        })() {\n+            Ok(r) => r,\n+            Err(e) => {\n+                write!(&mut test_output, \"Unexpected error: {}\", e).unwrap();\n+                TrFailed\n+            }\n+        };\n+\n+        (result, test_output, exec_time)\n+    })();\n+\n+    monitor_ch.send((desc.clone(), result, exec_time, test_output)).unwrap();\n+}\n+\n+fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Send>) -> ! {\n+    let builtin_panic_hook = panic::take_hook();\n+    let record_result = Arc::new(move |panic_info: Option<&'_ PanicInfo<'_>>| {\n+        let test_result = match panic_info {\n+            Some(info) => calc_result(&desc, Err(info.payload())),\n+            None => calc_result(&desc, Ok(())),\n+        };\n+\n+        // We don't support serializing TrFailedMsg, so just\n+        // print the message out to stderr.\n+        if let TrFailedMsg(msg) = &test_result {\n+            eprintln!(\"{}\", msg);\n+        }\n+\n+        if let Some(info) = panic_info {\n+            builtin_panic_hook(info);\n+        }\n+\n+        if let TrOk = test_result {\n+            process::exit(TR_OK);\n+        } else {\n+            process::exit(TR_FAILED);\n+        }\n+    });\n+    let record_result2 = record_result.clone();\n+    panic::set_hook(Box::new(move |info| record_result2(Some(&info))));\n+    testfn();\n+    record_result(None);\n+    unreachable!(\"panic=abort callback should have exited the process\")\n+}\n+\n+#[cfg(not(unix))]\n+fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    status.code().ok_or(\"received no exit code from child process\".into())\n+}\n+\n+#[cfg(unix)]\n+fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    use std::os::unix::process::ExitStatusExt;\n+    match status.code() {\n+        Some(code) => Ok(code),\n+        None => match status.signal() {\n+            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n+            None => Err(\"child process exited with unknown signal\".into()),\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq)]\n pub struct MetricMap(BTreeMap<String, Metric>);\n \n@@ -1700,7 +1884,9 @@ where\n }\n \n pub mod bench {\n-    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n+    use super::{\n+        BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult\n+    };\n     use crate::stats;\n     use std::cmp;\n     use std::io;\n@@ -1718,12 +1904,10 @@ pub mod bench {\n         };\n \n         let data = Arc::new(Mutex::new(Vec::new()));\n-        let data2 = data.clone();\n-\n         let oldio = if !nocapture {\n             Some((\n-                io::set_print(Some(Box::new(Sink(data2.clone())))),\n-                io::set_panic(Some(Box::new(Sink(data2)))),\n+                io::set_print(Some(Box::new(Sink(data.clone())))),\n+                io::set_panic(Some(Box::new(Sink(data.clone())))),\n             ))\n         } else {\n             None\n@@ -1734,7 +1918,7 @@ pub mod bench {\n         if let Some((printio, panicio)) = oldio {\n             io::set_print(printio);\n             io::set_panic(panicio);\n-        };\n+        }\n \n         let test_result = match result {\n             //bs.bench(f) {"}, {"sha": "b95fb5df710d35873be882a3900c6b8c4dd97ac7", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=8ae1ec60cc16e5d2a3d522a2e3fdddd27e5fb4c9", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n use crate::test::{\n-    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored, RunStrategy,\n     ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailedMsg,\n     TrIgnored, TrOk,\n };\n@@ -67,7 +67,7 @@ pub fn do_not_run_ignored_tests() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res != TrOk);\n }\n@@ -85,7 +85,7 @@ pub fn ignored_tests_result_in_ignored() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrIgnored);\n }\n@@ -105,7 +105,7 @@ fn test_should_panic() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrOk);\n }\n@@ -125,7 +125,7 @@ fn test_should_panic_good_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrOk);\n }\n@@ -147,7 +147,7 @@ fn test_should_panic_bad_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n }\n@@ -165,7 +165,7 @@ fn test_should_panic_but_succeeds() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n@@ -186,7 +186,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n         ..TestOpts::new()\n     };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, desc, tx, Concurrent::No);\n+    run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, _, exec_time, _) = rx.recv().unwrap();\n     exec_time\n }"}]}