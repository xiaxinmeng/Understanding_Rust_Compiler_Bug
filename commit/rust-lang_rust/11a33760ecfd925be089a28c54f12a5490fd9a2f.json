{"sha": "11a33760ecfd925be089a28c54f12a5490fd9a2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYTMzNzYwZWNmZDkyNWJlMDg5YTI4YzU0ZjEyYTU0OTBmZDlhMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-15T07:04:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-15T07:04:20Z"}, "message": "Auto merge of #40212 - SimonSapin:utf8error-resume-from, r=aturon\n\nAdd Utf8Error::error_len, to help incremental and/or lossy decoding.\n\nWithout this, code outside of the standard library needs to reimplement most of the logic `from_utf8` to interpret the bytes after `valid_up_to()`.", "tree": {"sha": "1d7c44de7199f37613aa21ca17ead54e09621694", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d7c44de7199f37613aa21ca17ead54e09621694"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11a33760ecfd925be089a28c54f12a5490fd9a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11a33760ecfd925be089a28c54f12a5490fd9a2f", "html_url": "https://github.com/rust-lang/rust/commit/11a33760ecfd925be089a28c54f12a5490fd9a2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11a33760ecfd925be089a28c54f12a5490fd9a2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d7b29475225ae799f4906f3b50e06a7d323890", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d7b29475225ae799f4906f3b50e06a7d323890", "html_url": "https://github.com/rust-lang/rust/commit/71d7b29475225ae799f4906f3b50e06a7d323890"}, {"sha": "73370c543ea130a3d6d9097aa56b786c72dc6c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/73370c543ea130a3d6d9097aa56b786c72dc6c94", "html_url": "https://github.com/rust-lang/rust/commit/73370c543ea130a3d6d9097aa56b786c72dc6c94"}], "stats": {"total": 111, "additions": 89, "deletions": 22}, "files": [{"sha": "98d0b1c8e156594ab4a72570f7ac4cc033ebf56b", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11a33760ecfd925be089a28c54f12a5490fd9a2f/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a33760ecfd925be089a28c54f12a5490fd9a2f/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=11a33760ecfd925be089a28c54f12a5490fd9a2f", "patch": "@@ -28,6 +28,7 @@\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n+#![feature(utf8_error_error_len)]\n \n extern crate collections;\n extern crate test;"}, {"sha": "c9b7104fec4f0072d2256f2b0de70153fd4648a9", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/11a33760ecfd925be089a28c54f12a5490fd9a2f/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a33760ecfd925be089a28c54f12a5490fd9a2f/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=11a33760ecfd925be089a28c54f12a5490fd9a2f", "patch": "@@ -540,6 +540,36 @@ fn from_utf8_mostly_ascii() {\n     }\n }\n \n+#[test]\n+fn from_utf8_error() {\n+    macro_rules! test {\n+        ($input: expr, $expected_valid_up_to: expr, $expected_error_len: expr) => {\n+            let error = from_utf8($input).unwrap_err();\n+            assert_eq!(error.valid_up_to(), $expected_valid_up_to);\n+            assert_eq!(error.error_len(), $expected_error_len);\n+        }\n+    }\n+    test!(b\"A\\xC3\\xA9 \\xFF \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\x80 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC1 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC1\", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC2\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xC2 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC2\\xC0\", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xE0\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xE0\\x9F\", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0\\xC0\", 4, Some(2));\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0 \", 4, Some(2));\n+    test!(b\"A\\xC3\\xA9 \\xED\\xA0\\x80 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xF1\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\\x80\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80 \", 4, Some(2));\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\\x80 \", 4, Some(3));\n+}\n+\n #[test]\n fn test_as_bytes() {\n     // no null"}, {"sha": "2919adc1cbc631be284cde5884281d04113079fd", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/11a33760ecfd925be089a28c54f12a5490fd9a2f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a33760ecfd925be089a28c54f12a5490fd9a2f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=11a33760ecfd925be089a28c54f12a5490fd9a2f", "patch": "@@ -125,13 +125,14 @@ Section: Creating a string\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n     valid_up_to: usize,\n+    error_len: Option<u8>,\n }\n \n impl Utf8Error {\n     /// Returns the index in the given string up to which valid UTF-8 was\n     /// verified.\n     ///\n-    /// It is the maximum index such that `from_utf8(input[..index])`\n+    /// It is the maximum index such that `from_utf8(&input[..index])`\n     /// would return `Ok(_)`.\n     ///\n     /// # Examples\n@@ -152,6 +153,23 @@ impl Utf8Error {\n     /// ```\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n+\n+    /// Provide more information about the failure:\n+    ///\n+    /// * `None`: the end of the input was reached unexpectedly.\n+    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n+    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n+    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n+    ///\n+    /// * `Some(len)`: an unexpected byte was encountered.\n+    ///   The length provided is that of the invalid byte sequence\n+    ///   that starts at the index given by `valid_up_to()`.\n+    ///   Decoding should resume after that sequence\n+    ///   (after inserting a U+FFFD REPLACEMENT CHARACTER) in case of lossy decoding.\n+    #[unstable(feature = \"utf8_error_error_len\", reason =\"new\", issue = \"40494\")]\n+    pub fn error_len(&self) -> Option<usize> {\n+        self.error_len.map(|len| len as usize)\n+    }\n }\n \n /// Converts a slice of bytes to a string slice.\n@@ -300,7 +318,12 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"invalid utf-8: invalid byte near index {}\", self.valid_up_to)\n+        if let Some(error_len) = self.error_len {\n+            write!(f, \"invalid utf-8 sequence of {} bytes from index {}\",\n+                   error_len, self.valid_up_to)\n+        } else {\n+            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n+        }\n     }\n }\n \n@@ -1241,25 +1264,27 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n \n     while index < len {\n         let old_offset = index;\n-        macro_rules! err { () => {{\n-            return Err(Utf8Error {\n-                valid_up_to: old_offset\n-            })\n-        }}}\n+        macro_rules! err {\n+            ($error_len: expr) => {\n+                return Err(Utf8Error {\n+                    valid_up_to: old_offset,\n+                    error_len: $error_len,\n+                })\n+            }\n+        }\n \n         macro_rules! next { () => {{\n             index += 1;\n             // we needed data, but there was none: error!\n             if index >= len {\n-                err!()\n+                err!(None)\n             }\n             v[index]\n         }}}\n \n         let first = v[index];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n-            let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n             // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n@@ -1279,25 +1304,36 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n             //               %xF4 %x80-8F 2( UTF8-tail )\n             match w {\n-                2 => if second & !CONT_MASK != TAG_CONT_U8 {err!()},\n+                2 => if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                    err!(Some(1))\n+                },\n                 3 => {\n-                    match (first, second, next!() & !CONT_MASK) {\n-                        (0xE0         , 0xA0 ... 0xBF, TAG_CONT_U8) |\n-                        (0xE1 ... 0xEC, 0x80 ... 0xBF, TAG_CONT_U8) |\n-                        (0xED         , 0x80 ... 0x9F, TAG_CONT_U8) |\n-                        (0xEE ... 0xEF, 0x80 ... 0xBF, TAG_CONT_U8) => {}\n-                        _ => err!()\n+                    match (first, next!()) {\n+                        (0xE0         , 0xA0 ... 0xBF) |\n+                        (0xE1 ... 0xEC, 0x80 ... 0xBF) |\n+                        (0xED         , 0x80 ... 0x9F) |\n+                        (0xEE ... 0xEF, 0x80 ... 0xBF) => {}\n+                        _ => err!(Some(1))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n                     }\n                 }\n                 4 => {\n-                    match (first, second, next!() & !CONT_MASK, next!() & !CONT_MASK) {\n-                        (0xF0         , 0x90 ... 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF1 ... 0xF3, 0x80 ... 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF4         , 0x80 ... 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n-                        _ => err!()\n+                    match (first, next!()) {\n+                        (0xF0         , 0x90 ... 0xBF) |\n+                        (0xF1 ... 0xF3, 0x80 ... 0xBF) |\n+                        (0xF4         , 0x80 ... 0x8F) => {}\n+                        _ => err!(Some(1))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(3))\n                     }\n                 }\n-                _ => err!()\n+                _ => err!(Some(1))\n             }\n             index += 1;\n         } else {"}]}