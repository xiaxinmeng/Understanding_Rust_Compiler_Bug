{"sha": "da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMjA0ZTFkNzMzYWQxZGJlNzk0YjdkOWY1Y2UyYmFkYWI3Zjg5OTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-10T00:30:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-19T03:00:50Z"}, "message": "add swappable/dvec modules", "tree": {"sha": "0368fb21bf4156b17710d8dbcb7622c5be8832a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0368fb21bf4156b17710d8dbcb7622c5be8832a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "html_url": "https://github.com/rust-lang/rust/commit/da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "253979236e00a391fdce12943fd21b5e8c4656b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/253979236e00a391fdce12943fd21b5e8c4656b1", "html_url": "https://github.com/rust-lang/rust/commit/253979236e00a391fdce12943fd21b5e8c4656b1"}], "stats": {"total": 453, "additions": 452, "deletions": 1}, "files": [{"sha": "7253711a05f4314d352f54b8532551776a90d0b8", "filename": "src/libcore/core.rc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -41,6 +41,8 @@ export comm, task, future;\n export extfmt;\n export tuple;\n export to_str;\n+export swappable;\n+export dvec, dvec_iter;\n \n // NDM seems to be necessary for resolve to work\n export vec_iter, option_iter;\n@@ -165,7 +167,13 @@ mod option_iter {\n }\n mod result;\n mod to_str;\n-\n+mod swappable;\n+mod dvec;\n+#[path=\"iter-trait\"]\n+mod dvec_iter {\n+    #[path = \"dvec.rs\"]\n+    mod inst;\n+}\n \n // Concurrency\n mod comm;"}, {"sha": "30dbc2a71518df8d30677fb8bf00fa94d9cd4a13", "filename": "src/libcore/dvec.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -0,0 +1,237 @@\n+// Dynamic Vector\n+//\n+// A growable vector that makes use of unique pointers so that the\n+// result can be sent between tasks and so forth.\n+//\n+// Note that recursive use is not permitted.\n+\n+import dvec_iter::extensions;\n+import unsafe::reinterpret_cast;\n+import ptr::{null, extensions};\n+\n+export dvec;\n+export from_vec;\n+export extensions;\n+export unwrap;\n+\n+#[doc = \"\n+\n+A growable, modifiable vector type that accumulates elements into a\n+unique vector.\n+\n+# Limitations on recursive use\n+\n+This class works by swapping the unique vector out of the data\n+structure whenever it is to be used.  Therefore, recursive use is not\n+permitted.  That is, while iterating through a vector, you cannot\n+access the vector in any other way or else the program will fail.  If\n+you wish, you can use the `swap()` method to gain access to the raw\n+vector and transform it or use it any way you like.  Eventually, we\n+may permit read-only access during iteration or other use.\n+\n+# WARNING\n+\n+For maximum performance, this type is implemented using some rather\n+unsafe code.  In particular, this innocent looking `[mut A]` pointer\n+*may be null!*  Therefore, it is important you not reach into the\n+data structure manually but instead use the provided extensions.\n+\n+The reason that I did not use an unsafe pointer in the structure\n+itself is that I wanted to ensure that the vector would be freed when\n+the dvec is dropped.  The reason that I did not use an `option<T>`\n+instead of a nullable pointer is that I found experimentally that it\n+becomes approximately 50% slower. This can probably be improved\n+through optimization.  You can run your own experiments using\n+`src/test/bench/vec-append.rs`. My own tests found that using null\n+pointers achieved about 103 million pushes/second.  Using an option\n+type could only produce 47 million pushes/second.\n+\n+\"]\n+type dvec<A> = {\n+\n+    mut data: [mut A]\n+};\n+\n+#[doc = \"Creates a new, empty dvec\"]\n+fn dvec<A>() -> dvec<A> {\n+    {mut data: [mut]}\n+}\n+\n+#[doc = \"Creates a new dvec with the contents of a vector\"]\n+fn from_vec<A>(+v: [mut A]) -> dvec<A> {\n+    {mut data: v}\n+}\n+\n+#[doc = \"Consumes the vector and returns its contents\"]\n+fn unwrap<A>(-d: dvec<A>) -> [mut A] {\n+    let {data: v} <- d;\n+    ret v;\n+}\n+\n+impl private_methods<A> for dvec<A> {\n+    fn check_not_borrowed() {\n+        unsafe {\n+            let data: *() = unsafe::reinterpret_cast(self.data);\n+            if data.is_null() {\n+                fail \"Recursive use of dvec\";\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn borrow<B>(f: fn(-[mut A]) -> B) -> B {\n+        unsafe {\n+            let mut data = unsafe::reinterpret_cast(null::<()>());\n+            data <-> self.data;\n+            let data_ptr: *() = unsafe::reinterpret_cast(data);\n+            if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n+            ret f(data);\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn return(-data: [mut A]) {\n+        unsafe {\n+            self.data <- data;\n+        }\n+    }\n+}\n+\n+// In theory, most everything should work with any A, but in practice\n+// almost nothing works without the copy bound due to limitations\n+// around closures.\n+impl extensions<A> for dvec<A> {\n+    #[doc = \"\n+\n+    Swaps out the current vector and hands it off to a user-provided\n+    function `f`.  The function should transform it however is desired\n+    and return a new vector to replace it with.\n+\n+    \"]\n+    fn swap(f: fn(-[mut A]) -> [mut A]) {\n+        self.borrow { |v| self.return(f(v)) }\n+    }\n+\n+    #[doc = \"Returns the number of elements currently in the dvec\"]\n+    fn len() -> uint {\n+        self.borrow { |v|\n+            let l = v.len();\n+            self.return(v);\n+            l\n+        }\n+    }\n+\n+    #[doc = \"Overwrite the current contents\"]\n+    fn set(+w: [mut A]) {\n+        self.check_not_borrowed();\n+        self.data <- w; //FIXME check for recursive use\n+    }\n+}\n+\n+impl extensions<A:copy> for dvec<A> {\n+    #[doc = \"Append a single item to the end of the list\"]\n+    fn push(t: A) {\n+        self.swap { |v| v += [t]; v } // more efficient than v + [t]\n+    }\n+\n+    #[doc = \"Remove and return the last element\"]\n+    fn pop() -> A {\n+        self.borrow { |v|\n+            let result = vec::pop(v);\n+            self.return(v);\n+            result\n+        }\n+    }\n+\n+    #[doc = \"\n+        Append all elements of a vector to the end of the list\n+\n+        Equivalent to `append_iter()` but potentially more efficient.\n+    \"]\n+    fn push_all(ts: [const A]/&) {\n+        self.push_slice(ts, 0u, vec::len(ts));\n+    }\n+\n+    #[doc = \"\n+        Appends elements from `from_idx` to `to_idx` (exclusive)\n+    \"]\n+    fn push_slice(ts: [const A]/&, from_idx: uint, to_idx: uint) {\n+        self.swap { |v|\n+            let new_len = vec::len(v) + to_idx - from_idx;\n+            vec::reserve(v, new_len);\n+            let mut i = from_idx;\n+            while i < to_idx {\n+                v += [ts[i]];\n+                i += 1u;\n+            }\n+            v\n+        }\n+    }\n+\n+    //FIXME--\n+    //#[doc = \"\n+    //    Append all elements of an iterable.\n+    //\n+    //    Failure will occur if the iterable's `each()` method\n+    //    attempts to access this vector.\n+    //\"]\n+    //fn append_iter<I:iter::base<A>>(ts: I) {\n+    //    self.dvec.swap { |v|\n+    //        alt ts.size_hint() {\n+    //          none {}\n+    //          some(h) { vec::reserve(v, len(v) + h) }\n+    //        }\n+    //\n+    //        for ts.each { |t| v = v + [t] };\n+    //\n+    //        v\n+    //    }\n+    //}\n+\n+    #[doc = \"\n+        Gets a copy of the current contents.\n+\n+        See `unwrap()` if you do not wish to copy the contents.\n+    \"]\n+    fn get() -> [A] {\n+        self.borrow { |v|\n+            let w = vec::from_mut(copy v);\n+            self.return(v);\n+            w\n+        }\n+    }\n+\n+    #[doc = \"Remove and return the first element\"]\n+    fn shift() -> A {\n+        self.borrow { |v|\n+            let mut v = vec::from_mut(v);\n+            let result = vec::shift(v);\n+            self.return(vec::to_mut(v));\n+            result\n+        }\n+    }\n+\n+    #[doc = \"Copy out an individual element\"]\n+    #[inline]\n+    fn [](idx: uint) -> A {\n+        self.get_elt(idx)\n+    }\n+\n+    #[doc = \"Copy out an individual element\"]\n+    #[inline]\n+    fn get_elt(idx: uint) -> A {\n+        self.check_not_borrowed();\n+        ret self.data[idx];\n+    }\n+\n+    #[doc = \"Overwrites the contents of the element at `idx` with `a`\"]\n+    fn set_elt(idx: uint, a: A) {\n+        self.check_not_borrowed();\n+        self.data[idx] = a;\n+    }\n+\n+    #[doc = \"Overwrites the contents of the element at `idx` with `a`\"]\n+    fn grow_set_elt(idx: uint, initval: A, val: A) {\n+        self.swap { |v| vec::grow_set(v, idx, initval, val); v }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c68134153cdf3ee8e8ca9e08aaa6741c4914a94a", "filename": "src/libcore/iter-trait/dvec.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -0,0 +1,16 @@\n+type IMPL_T<A> = dvec::dvec<A>;\n+\n+#[doc = \"\n+Iterates through the current contents.\n+\n+Attempts to access this dvec during iteration will fail.\n+\"]\n+fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+    import dvec::extensions;\n+    self.swap { |v| vec::each(v, f); v }\n+}\n+\n+fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+    import dvec::extensions;\n+    some(self.len())\n+}"}, {"sha": "5df9b2c4846313d866b7b9a016eb98ac6f201632", "filename": "src/libcore/swappable.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fswappable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Flibcore%2Fswappable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fswappable.rs?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -0,0 +1,98 @@\n+export swappable;\n+export unwrap;\n+export methods;\n+\n+#[doc = \"\n+A value that may be swapped out temporarily while it is being processed\n+and then replaced.  Swappables are most useful when working with unique\n+values, which often cannot be mutated unless they are stored in the local\n+stack frame to ensure memory safety.\n+\n+The type guarantees the invariant that the value is always \\\"swapped in\\\"\n+except during the execution of the `swap()` and `with()` methods.\n+\"]\n+type swappable<A> = {\n+    mut o_t: option<A>\n+};\n+\n+#[doc = \"Create a swappable swapped in with a given initial value\"]\n+fn swappable<A>(+t: A) -> swappable<A> {\n+    {mut o_t: some(t)}\n+}\n+\n+#[doc = \"Consumes a swappable and returns its contents without copying\"]\n+fn unwrap<A>(-s: swappable<A>) -> A {\n+    let {o_t: o_t} <- s;\n+    option::unwrap(o_t)\n+}\n+\n+impl methods<A> for swappable<A> {\n+    #[doc = \"\n+         Overwrites the contents of the swappable\n+    \"]\n+    fn set(+a: A) {\n+        self.o_t <- some(a);\n+    }\n+\n+    #[doc = \"\n+         Invokes `f()` with the current value but replaces the\n+         current value when complete.  Returns the result of `f()`.\n+\n+         Attempts to read or access the receiver while `f()` is executing\n+         will fail dynamically.\n+    \"]\n+    fn with<B>(f: fn(A) -> B) -> B {\n+        let mut o_u = none;\n+        self.swap { |t| o_u <- some(f(t)); t }\n+        option::unwrap(o_u)\n+    }\n+\n+    #[doc = \"\n+         Invokes `f()` with the current value and then replaces the\n+         current value with the result of `f()`.\n+\n+         Attempts to read or access the receiver while `f()` is executing\n+         will fail dynamically.\n+    \"]\n+    fn swap(f: fn(-A) -> A) {\n+        alt self.o_t {\n+          none { fail \"no value present---already swapped?\"; }\n+          some(_) {}\n+        }\n+\n+        let mut o_t = none;\n+        o_t <-> self.o_t;\n+        self.o_t <- some(f(option::unwrap(o_t)));\n+    }\n+\n+    #[doc = \"True if there is a value present in this swappable\"]\n+    fn is_present() -> bool {\n+        alt self.o_t {\n+          none {false}\n+          some(_) {true}\n+        }\n+    }\n+\n+    #[doc = \"\n+        Removes the value from the swappable.  Any further attempts\n+        to use the swapabble without first invoking `set()` will fail.\n+    \"]\n+    fn take() -> A {\n+        alt self.o_t {\n+          none { fail \"swapped out\"; }\n+          some(_) {}\n+        }\n+\n+        let mut o_t = none;\n+        option::unwrap(o_t)\n+    }\n+}\n+\n+impl methods<A:copy> for swappable<A> {\n+    #[doc = \"\n+        Copies out the contents of the swappable\n+    \"]\n+    fn get() -> A {\n+        self.o_t.get()\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "a84c776f0cc629a48c0a3d148ef4cc71543ddbdc", "filename": "src/test/bench/vec-append.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Ftest%2Fbench%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Ftest%2Fbench%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fvec-append.rs?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -0,0 +1,53 @@\n+// A raw test of vector appending performance.\n+\n+use std;\n+import dvec::{dvec, extensions};\n+import io::writer_util;\n+\n+fn collect_raw(num: uint) -> [uint] {\n+    let mut result = [];\n+    uint::range(0u, num) { |i|\n+        result += [i];\n+    }\n+    ret result;\n+}\n+\n+fn collect_dvec(num: uint) -> [mut uint] {\n+    let result = dvec();\n+    uint::range(0u, num) { |i|\n+        result.push(i);\n+    }\n+    ret dvec::unwrap(result);\n+}\n+\n+fn main(args: [str]) {\n+    let args = if vec::len(args) <= 1u {[\"\", \"100000\"]} else {args};\n+    let max = uint::from_str(args[1]).get();\n+    let start = std::time::precise_time_s();\n+    collect_raw(max);\n+    let mid = std::time::precise_time_s();\n+    collect_dvec(max);\n+    let end = std::time::precise_time_s();\n+\n+    let raw = mid - start;\n+    let dvec = end - mid;\n+\n+    let maxf = max as float;\n+    let rawf = raw as float;\n+    let dvecf = dvec as float;\n+\n+    io::stdout().write_str(#fmt(\"Raw     : %? seconds\\n\", raw));\n+    io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/rawf));\n+    io::stdout().write_str(#fmt(\"\\n\"));\n+    io::stdout().write_str(#fmt(\"Dvec    : %? seconds\\n\", dvec));\n+    io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/dvecf));\n+    io::stdout().write_str(#fmt(\"\\n\"));\n+\n+    if dvec < raw {\n+        io::stdout().write_str(#fmt(\"Dvec is %f%% faster than raw\\n\",\n+                                    (rawf - dvecf) / rawf * 100.0));\n+    } else {\n+        io::stdout().write_str(#fmt(\"Raw is %f%% faster than dvec\\n\",\n+                                    (dvecf - rawf) / dvecf * 100.0));\n+    }\n+}"}, {"sha": "01ae5e73d9139826043adc1eafdb8a6ef0fafe0b", "filename": "src/test/run-pass/dvec-test.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-test.rs?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -0,0 +1,26 @@\n+import dvec::{dvec, extensions};\n+\n+fn main() {\n+    let d = dvec();\n+    d.push(3);\n+    d.push(4);\n+    assert d.get() == [3, 4];\n+    d.set([mut 5]);\n+    d.push(6);\n+    d.push(7);\n+    d.push(8);\n+    d.push(9);\n+    d.push(10);\n+    d.push_vec([11, 12, 13]);\n+\n+    let exp = [5, 6, 7, 8, 9, 10, 11, 12, 13];\n+    assert d.get() == exp;\n+    assert d.get() == exp;\n+    assert d.len() == exp.len();\n+\n+    for d.eachi { |i, e|\n+        assert e == exp[i];\n+    }\n+\n+    assert dvec::unwrap(d) == [5, 6, 7, 8, 9, 10, 11, 12, 13];\n+}\n\\ No newline at end of file"}, {"sha": "ee3446489017c615b15791b75f88731f8aa74a1f", "filename": "src/test/run-pass/swappable-test.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Ftest%2Frun-pass%2Fswappable-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da204e1d733ad1dbe794b7d9f5ce2badab7f8993/src%2Ftest%2Frun-pass%2Fswappable-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswappable-test.rs?ref=da204e1d733ad1dbe794b7d9f5ce2badab7f8993", "patch": "@@ -0,0 +1,13 @@\n+import swappable::{swappable, methods};\n+\n+fn main() {\n+    let d = swappable(3);\n+    assert d.get() == 3;\n+    d.set(4);\n+    assert d.get() == 4;\n+    d.swap { |i| i + 1 };\n+    assert d.get() == 5;\n+    assert d.with { |i| i + 1 } == 6;\n+    assert d.get() == 5;\n+    assert swappable::unwrap(d) == 5;\n+}\n\\ No newline at end of file"}]}