{"sha": "43c22af267fd9337bc05382b2771dde49d2e9f26", "node_id": "C_kwDOAAsO6NoAKDQzYzIyYWYyNjdmZDkzMzdiYzA1MzgyYjI3NzFkZGU0OWQyZTlmMjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-07T13:54:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-07T13:54:55Z"}, "message": "Auto merge of #101632 - camsteffen:refactor-infer-err, r=lcnr\n\nRemove `TypeckResults` from `InferCtxt`\n\n`InferCtxt` currently has `in_progress_typeck_results` which is only used for some diagnostics during typeck. It adds a lifetime which propagates through a lot of code. This PR moves that field into a new helper struct `TypeErrCtxt`.", "tree": {"sha": "50b436b4bec27a45ba6395ffb5396188a5d3611a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50b436b4bec27a45ba6395ffb5396188a5d3611a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43c22af267fd9337bc05382b2771dde49d2e9f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43c22af267fd9337bc05382b2771dde49d2e9f26", "html_url": "https://github.com/rust-lang/rust/commit/43c22af267fd9337bc05382b2771dde49d2e9f26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43c22af267fd9337bc05382b2771dde49d2e9f26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42c4d7218b2596276152c5eb1e69335621f3086", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42c4d7218b2596276152c5eb1e69335621f3086", "html_url": "https://github.com/rust-lang/rust/commit/e42c4d7218b2596276152c5eb1e69335621f3086"}, {"sha": "283abbf0e7d20176f76006825b5c52e9a4234e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/283abbf0e7d20176f76006825b5c52e9a4234e4c", "html_url": "https://github.com/rust-lang/rust/commit/283abbf0e7d20176f76006825b5c52e9a4234e4c"}], "stats": {"total": 5852, "additions": 2831, "deletions": 3021}, "files": [{"sha": "f185e402fc6dee77ea3b749fc9a4400b7d9b5094", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -14,8 +14,8 @@ use crate::{\n     places_conflict, region_infer::values::LivenessValues,\n };\n \n-pub(super) fn generate_constraints<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+pub(super) fn generate_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n@@ -37,16 +37,16 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n-struct ConstraintGeneration<'cg, 'cx, 'tcx> {\n-    infcx: &'cg InferCtxt<'cx, 'tcx>,\n+struct ConstraintGeneration<'cg, 'tcx> {\n+    infcx: &'cg InferCtxt<'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n     body: &'cg Body<'tcx>,\n }\n \n-impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n+impl<'cg, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.super_basic_block_data(bb, data);\n     }\n@@ -156,7 +156,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n+impl<'cx, 'tcx> ConstraintGeneration<'cx, 'tcx> {\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at"}, {"sha": "b162095f8a6cdf0692738aaaa1fe3d4205782ca4", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -31,9 +31,8 @@ pub fn get_body_with_borrowck_facts<'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> BodyWithBorrowckFacts<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).enter(|infcx| {\n-        let input_body: &Body<'_> = &input_body.borrow();\n-        let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n-    })\n+    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n+    let input_body: &Body<'_> = &input_body.borrow();\n+    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n }"}, {"sha": "02071ed6b36662975346651590ec08d5e74fb17a", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 58, "deletions": 94, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> UniverseInfo<'tcx> {\n     ) {\n         match self.0 {\n             UniverseInfoInner::RelateTys { expected, found } => {\n-                let err = mbcx.infcx.report_mismatched_types(\n+                let err = mbcx.infcx.err_ctxt().report_mismatched_types(\n                     &cause,\n                     expected,\n                     found,\n@@ -238,20 +238,11 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -288,37 +279,24 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-                let mut selcx = SelectionContext::new(infcx);\n-\n-                // FIXME(lqd): Unify and de-duplicate the following with the actual\n-                // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n-                // `ObligationCause`. The normalization results are currently different between\n-                // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n-                // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n-                // after #85499 lands to see if its fixes have erased this difference.\n-                let (param_env, value) = key.into_parts();\n-                let Normalized { value: _, obligations } = rustc_trait_selection::traits::normalize(\n-                    &mut selcx,\n-                    param_env,\n-                    cause,\n-                    value.value,\n-                );\n-                fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+\n+        let mut selcx = SelectionContext::new(infcx);\n+\n+        // FIXME(lqd): Unify and de-duplicate the following with the actual\n+        // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n+        // `ObligationCause`. The normalization results are currently different between\n+        // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n+        // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n+        // after #85499 lands to see if its fixes have erased this difference.\n+        let (param_env, value) = key.into_parts();\n+        let Normalized { value: _, obligations } =\n+            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n+        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -349,21 +327,11 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span))\n-                    .ok()?;\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -407,7 +375,7 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n #[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n     mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n@@ -427,7 +395,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n }\n \n fn try_extract_error_from_region_constraints<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n     region_constraints: &RegionConstraintData<'tcx>,\n@@ -449,42 +417,38 @@ fn try_extract_error_from_region_constraints<'tcx>(\n         })?;\n \n     debug!(?sub_region, \"cause = {:#?}\", cause);\n-    let nice_error = match (error_region, *sub_region) {\n-        (Some(error_region), ty::ReVar(vid)) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::SubSupConflict(\n-                vid,\n-                region_var_origin(vid),\n-                cause.clone(),\n-                error_region,\n-                cause.clone(),\n-                placeholder_region,\n-                vec![],\n-            ),\n-        ),\n-        (Some(error_region), _) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region),\n+    let error = match (error_region, *sub_region) {\n+        (Some(error_region), ty::ReVar(vid)) => RegionResolutionError::SubSupConflict(\n+            vid,\n+            region_var_origin(vid),\n+            cause.clone(),\n+            error_region,\n+            cause.clone(),\n+            placeholder_region,\n+            vec![],\n         ),\n+        (Some(error_region), _) => {\n+            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region)\n+        }\n         // Note universe here is wrong...\n-        (None, ty::ReVar(vid)) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::UpperBoundUniverseConflict(\n-                vid,\n-                region_var_origin(vid),\n-                universe_of_region(vid),\n-                cause.clone(),\n-                placeholder_region,\n-            ),\n-        ),\n-        (None, _) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region),\n+        (None, ty::ReVar(vid)) => RegionResolutionError::UpperBoundUniverseConflict(\n+            vid,\n+            region_var_origin(vid),\n+            universe_of_region(vid),\n+            cause.clone(),\n+            placeholder_region,\n         ),\n+        (None, _) => {\n+            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region)\n+        }\n     };\n-    nice_error.try_report_from_nll().or_else(|| {\n+    NiceRegionError::new(&infcx.err_ctxt(), error).try_report_from_nll().or_else(|| {\n         if let SubregionOrigin::Subtype(trace) = cause {\n-            Some(infcx.report_and_explain_type_error(*trace, TypeError::RegionsPlaceholderMismatch))\n+            Some(\n+                infcx\n+                    .err_ctxt()\n+                    .report_and_explain_type_error(*trace, TypeError::RegionsPlaceholderMismatch),\n+            )\n         } else {\n             None\n         }"}, {"sha": "2a8bd4d30abbffcd630417db567c0a273e3db6ac", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -492,11 +492,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let Some(default_trait) = tcx.get_diagnostic_item(sym::Default) else {\n                 return false;\n             };\n-            tcx.infer_ctxt().enter(|infcx| {\n-                infcx\n-                    .type_implements_trait(default_trait, ty, ty::List::empty(), param_env)\n-                    .may_apply()\n-            })\n+            tcx.infer_ctxt()\n+                .build()\n+                .type_implements_trait(default_trait, ty, ty::List::empty(), param_env)\n+                .may_apply()\n         };\n \n         let assign_value = match ty.kind() {\n@@ -606,41 +605,40 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|def_id| tcx.hir().get_generics(def_id))\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n-            let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n \n-            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n-            let cause = ObligationCause::new(\n-                span,\n-                self.mir_hir_id(),\n-                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-            );\n-            fulfill_cx.register_bound(\n-                &infcx,\n-                self.param_env,\n-                // Erase any region vids from the type, which may not be resolved\n-                infcx.tcx.erase_regions(ty),\n-                copy_did,\n-                cause,\n-            );\n-            // Select all, including ambiguous predicates\n-            let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n-            // Only emit suggestion if all required predicates are on generic\n-            errors\n-                .into_iter()\n-                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                    PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n-                        ty::Param(param_ty) => Ok((\n-                            generics.type_param(param_ty, tcx),\n-                            predicate.trait_ref.print_only_trait_path().to_string(),\n-                        )),\n-                        _ => Err(()),\n-                    },\n+        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+        let cause = ObligationCause::new(\n+            span,\n+            self.mir_hir_id(),\n+            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+        );\n+        fulfill_cx.register_bound(\n+            &infcx,\n+            self.param_env,\n+            // Erase any region vids from the type, which may not be resolved\n+            infcx.tcx.erase_regions(ty),\n+            copy_did,\n+            cause,\n+        );\n+        // Select all, including ambiguous predicates\n+        let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+        // Only emit suggestion if all required predicates are on generic\n+        let predicates: Result<Vec<_>, _> = errors\n+            .into_iter()\n+            .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n+                    ty::Param(param_ty) => Ok((\n+                        generics.type_param(param_ty, tcx),\n+                        predicate.trait_ref.print_only_trait_path().to_string(),\n+                    )),\n                     _ => Err(()),\n-                })\n-                .collect()\n-        });\n+                },\n+                _ => Err(()),\n+            })\n+            .collect();\n \n         if let Ok(predicates) = predicates {\n             suggest_constraining_type_params("}, {"sha": "534d9ecae6e6f0788d336bc7ac8b03110cc02482", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -1025,7 +1025,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n                         let suggest = match self.infcx.tcx.get_diagnostic_item(sym::IntoIterator) {\n-                            Some(def_id) => self.infcx.tcx.infer_ctxt().enter(|infcx| {\n+                            Some(def_id) => {\n+                                let infcx = self.infcx.tcx.infer_ctxt().build();\n                                 type_known_to_meet_bound_modulo_regions(\n                                     &infcx,\n                                     self.param_env,\n@@ -1036,7 +1037,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     def_id,\n                                     DUMMY_SP,\n                                 )\n-                            }),\n+                            }\n                             _ => false,\n                         };\n                         if suggest {"}, {"sha": "15230718dc0dee21f140070050507b30338714ae", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let Some(lower_bound_region) = lower_bound_region {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);\n                         let origin = RelateParamBound(type_test_span, generic_ty, None);\n-                        self.buffer_error(self.infcx.construct_generic_bound_failure(\n+                        self.buffer_error(self.infcx.err_ctxt().construct_generic_bound_failure(\n                             self.body.source.def_id().expect_local(),\n                             type_test_span,\n                             Some(origin),\n@@ -365,7 +365,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let nice = NiceRegionError::new_from_span(self.infcx, cause.span, o, f);\n+            let infer_err = self.infcx.err_ctxt();\n+            let nice = NiceRegionError::new_from_span(&infer_err, cause.span, o, f);\n             if let Some(diag) = nice.try_report_from_nll() {\n                 self.buffer_error(diag);\n                 return;"}, {"sha": "abfe253d43df7edbf41cfdbba0e7c3bd474a56ae", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -131,14 +131,11 @@ fn mir_borrowck<'tcx>(\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n-        .enter(|infcx| {\n-            let input_body: &Body<'_> = &input_body.borrow();\n-            let promoted: &IndexVec<_, _> = &promoted.borrow();\n-            do_mir_borrowck(&infcx, input_body, promoted, false).0\n-        });\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n+    let input_body: &Body<'_> = &input_body.borrow();\n+    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, false).0;\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)\n@@ -150,8 +147,8 @@ fn mir_borrowck<'tcx>(\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n #[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n-fn do_mir_borrowck<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+fn do_mir_borrowck<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n     return_body_with_facts: bool,\n@@ -474,7 +471,7 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n }\n \n struct MirBorrowckCtxt<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "08fdd28eb01b7392e5a701d0e1ffc7e0b9221871", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -55,8 +55,8 @@ pub(crate) struct NllOutput<'tcx> {\n /// regions (e.g., region parameters) declared on the function. That set will need to be given to\n /// `compute_regions`.\n #[instrument(skip(infcx, param_env, body, promoted), level = \"debug\")]\n-pub(crate) fn replace_regions_in_mir<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+pub(crate) fn replace_regions_in_mir<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n@@ -155,7 +155,7 @@ fn populate_polonius_move_facts(\n ///\n /// This may result in errors being reported.\n pub(crate) fn compute_regions<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -318,8 +318,8 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     }\n }\n \n-pub(super) fn dump_mir_results<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub(super) fn dump_mir_results<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n@@ -368,8 +368,8 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n     };\n }\n \n-pub(super) fn dump_annotation<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub(super) fn dump_annotation<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,"}, {"sha": "4cefd1ec387d6c71a1a840fcffefbfb6d61279c2", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -565,7 +565,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(skip(self, infcx, body, polonius_output), level = \"debug\")]\n     pub(super) fn solve(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n@@ -835,7 +835,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// 'a`. See `TypeTest` for more details.\n     fn check_type_tests(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n@@ -923,7 +923,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx, propagated_outlives_requirements))]\n     fn try_promote_type_test(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n@@ -1036,7 +1036,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n@@ -1212,7 +1212,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n@@ -1262,7 +1262,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn eval_if_eq(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1718,7 +1718,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn check_member_constraints(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         let member_constraints = self.member_constraints.clone();"}, {"sha": "a7c4671665f43915c4702c9859a761a75c3fd2ee", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::session_diagnostics::ConstNotUsedTraitAlias;\n@@ -63,7 +63,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx), ret)]\n     pub(crate) fn infer_opaque_types(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n     ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n@@ -194,7 +194,7 @@ pub trait InferCtxtExt<'tcx> {\n     ) -> Ty<'tcx>;\n }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an opaque type\n@@ -266,72 +266,69 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n-        if let OpaqueTyOrigin::TyAlias = origin {\n-            // This logic duplicates most of `check_opaque_meets_bounds`.\n-            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-            let param_env = self.tcx.param_env(def_id);\n-            let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n-            // HACK This bubble is required for this tests to pass:\n-            // type-alias-impl-trait/issue-67844-nested-opaque.rs\n-            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(\n-                move |infcx| {\n-                    // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                    // hidden type is well formed even without those bounds.\n-                    let predicate =\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                            .to_predicate(infcx.tcx);\n-                    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                    // the bounds that the function supplies.\n-                    match infcx.register_hidden_type(\n-                        OpaqueTypeKey { def_id, substs: id_substs },\n-                        ObligationCause::misc(instantiated_ty.span, body_id),\n-                        param_env,\n+        let OpaqueTyOrigin::TyAlias = origin else {\n+            return definition_ty;\n+        };\n+        // This logic duplicates most of `check_opaque_meets_bounds`.\n+        // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n+        let param_env = self.tcx.param_env(def_id);\n+        let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n+        // HACK This bubble is required for this tests to pass:\n+        // type-alias-impl-trait/issue-67844-nested-opaque.rs\n+        let infcx =\n+            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        // Require the hidden type to be well-formed with only the generics of the opaque type.\n+        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+        // hidden type is well formed even without those bounds.\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+            .to_predicate(infcx.tcx);\n+        let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+        // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+        // the bounds that the function supplies.\n+        match infcx.register_hidden_type(\n+            OpaqueTypeKey { def_id, substs: id_substs },\n+            ObligationCause::misc(instantiated_ty.span, body_id),\n+            param_env,\n+            definition_ty,\n+            origin,\n+        ) {\n+            Ok(infer_ok) => {\n+                for obligation in infer_ok.obligations {\n+                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                }\n+            }\n+            Err(err) => {\n+                infcx\n+                    .err_ctxt()\n+                    .report_mismatched_types(\n+                        &ObligationCause::misc(instantiated_ty.span, body_id),\n+                        self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n                         definition_ty,\n-                        origin,\n-                    ) {\n-                        Ok(infer_ok) => {\n-                            for obligation in infer_ok.obligations {\n-                                fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                            }\n-                        }\n-                        Err(err) => {\n-                            infcx\n-                                .report_mismatched_types(\n-                                    &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                    self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n-                                    definition_ty,\n-                                    err,\n-                                )\n-                                .emit();\n-                        }\n-                    }\n+                        err,\n+                    )\n+                    .emit();\n+            }\n+        }\n \n-                    fulfillment_cx.register_predicate_obligation(\n-                        &infcx,\n-                        Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                    );\n+        fulfillment_cx.register_predicate_obligation(\n+            &infcx,\n+            Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+        );\n \n-                    // Check that all obligations are satisfied by the implementation's\n-                    // version.\n-                    let errors = fulfillment_cx.select_all_or_error(&infcx);\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        let errors = fulfillment_cx.select_all_or_error(&infcx);\n \n-                    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n-                    // tests to pass\n-                    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+        // tests to pass\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-                    if errors.is_empty() {\n-                        definition_ty\n-                    } else {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n-                        self.tcx.ty_error()\n-                    }\n-                },\n-            )\n-        } else {\n+        if errors.is_empty() {\n             definition_ty\n+        } else {\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            self.tcx.ty_error()\n         }\n     }\n }"}, {"sha": "d737432f0ef6897e0f1ac91c20288ec816042a6f", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n /// inference variables, returning the number of variables created.\n #[instrument(skip(infcx, body, promoted), level = \"debug\")]\n pub fn renumber_mir<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n@@ -28,7 +28,7 @@ pub fn renumber_mir<'tcx>(\n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n #[instrument(skip(infcx), level = \"debug\")]\n-pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: T) -> T\n+pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -44,7 +44,7 @@ where\n // Once `visit_mir_constant` is removed we can also remove this function\n // and just use `renumber_regions`.\n fn renumber_regions_in_mir_constant<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     value: ConstantKind<'tcx>,\n ) -> ConstantKind<'tcx> {\n     infcx.tcx.super_fold_regions(value, |_region, _depth| {\n@@ -54,7 +54,7 @@ fn renumber_regions_in_mir_constant<'tcx>(\n }\n \n struct NllVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> NllVisitor<'a, 'tcx> {"}, {"sha": "d5bfc2f520826c7163b12fdd187a6ef6d0bfa17d", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -19,7 +19,7 @@ use crate::{\n };\n \n pub(crate) struct ConstraintConversion<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     /// Each RBP `GK: 'a` is assumed to be true. These encode\n@@ -43,7 +43,7 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n \n impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     pub(crate) fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,"}, {"sha": "7d4219d70d95b966e90b7770f955cff1c520165c", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -48,7 +48,7 @@ pub(crate) struct CreateResult<'tcx> {\n }\n \n pub(crate) fn create<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n@@ -197,7 +197,7 @@ impl UniversalRegionRelations<'_> {\n }\n \n struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n-    infcx: &'this InferCtxt<'this, 'tcx>,\n+    infcx: &'this InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n     implicit_region_bound: ty::Region<'tcx>,"}, {"sha": "3a0465ea56d13e3d9e8997fda67d9cbb56b6401b", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -123,7 +123,7 @@ mod relate_tys;\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n /// - `elements` -- MIR region map\n pub(crate) fn type_check<'mir, 'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -876,7 +876,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n struct TypeChecker<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n     body: &'a Body<'tcx>,\n@@ -946,7 +946,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n impl<'tcx> MirTypeckRegionConstraints<'tcx> {\n     fn placeholder_region(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         placeholder: ty::PlaceholderRegion,\n     ) -> ty::Region<'tcx> {\n         let placeholder_index = self.placeholder_indices.insert(placeholder);\n@@ -1030,7 +1030,7 @@ impl Locations {\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n@@ -2744,7 +2744,7 @@ impl<'tcx> TypeOp<'tcx> for InstantiateOpaqueType<'tcx> {\n     /// constraints in our `InferCtxt`\n     type ErrorInfo = InstantiateOpaqueType<'tcx>;\n \n-    fn fully_perform(mut self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+    fn fully_perform(mut self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let (mut output, region_constraints) = scrape_region_constraints(infcx, || {\n             Ok(InferOk { value: (), obligations: self.obligations.clone() })\n         })?;"}, {"sha": "51d262a881b8cbae3f2ff178b1f74591bde88623", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -219,7 +219,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// signature. This will also compute the relationships that are\n     /// known between those regions.\n     pub fn new(\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n@@ -382,7 +382,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n }\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -699,7 +699,7 @@ trait InferCtxtExt<'tcx> {\n     );\n }\n \n-impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,"}, {"sha": "5eaddf682c3481d7975a82561076d9125946d300", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n };\n@@ -737,14 +737,16 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     let obligation =\n                         Obligation::new(ObligationCause::dummy(), param_env, poly_trait_pred);\n \n-                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+                    let implsrc = {\n+                        let infcx = tcx.infer_ctxt().build();\n                         let mut selcx = SelectionContext::new(&infcx);\n                         selcx.select(&obligation)\n-                    });\n+                    };\n \n                     // do a well-formedness check on the trait method being called. This is because typeck only does a\n                     // \"non-const\" check. This is required for correctness here.\n-                    tcx.infer_ctxt().enter(|infcx| {\n+                    {\n+                        let infcx = tcx.infer_ctxt().build();\n                         let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n                         let hir_id = tcx\n@@ -775,9 +777,9 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         }\n                         let errors = fulfill_cx.select_all_or_error(&infcx);\n                         if !errors.is_empty() {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         }\n-                    });\n+                    }\n \n                     match implsrc {\n                         Ok(Some(ImplSource::Param(_, ty::BoundConstness::ConstIfConst))) => {\n@@ -835,16 +837,15 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                                 // improve diagnostics by showing what failed. Our requirements are stricter this time\n                                 // as we are going to error again anyways.\n-                                tcx.infer_ctxt().enter(|infcx| {\n-                                    if let Err(e) = implsrc {\n-                                        infcx.report_selection_error(\n-                                            obligation.clone(),\n-                                            &obligation,\n-                                            &e,\n-                                            false,\n-                                        );\n-                                    }\n-                                });\n+                                let infcx = tcx.infer_ctxt().build();\n+                                if let Err(e) = implsrc {\n+                                    infcx.err_ctxt().report_selection_error(\n+                                        obligation.clone(),\n+                                        &obligation,\n+                                        &e,\n+                                        false,\n+                                    );\n+                                }\n \n                                 self.check_op(ops::FnCallNonConst {\n                                     caller,"}, {"sha": "b28d70194917bca694981d5b90d88e0f884a6873", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -156,10 +156,9 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                         }),\n                     );\n \n-                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n-                        let mut selcx = SelectionContext::new(&infcx);\n-                        selcx.select(&obligation)\n-                    });\n+                    let infcx = tcx.infer_ctxt().build();\n+                    let mut selcx = SelectionContext::new(&infcx);\n+                    let implsrc = selcx.select(&obligation);\n \n                     if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n                         let span = tcx.def_span(data.impl_def_id);"}, {"sha": "b77b213b51a542fe4bb847a93a65ddaeaff2d5e3", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -168,30 +168,28 @@ impl Qualif for NeedsNonConstDrop {\n             }),\n         );\n \n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n-                // If we couldn't select a const destruct candidate, then it's bad\n-                return true;\n-            };\n-\n-            if !matches!(\n-                impl_src,\n-                ImplSource::ConstDestruct(_)\n-                    | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n-            ) {\n-                // If our const destruct candidate is not ConstDestruct or implied by the param env,\n-                // then it's bad\n-                return true;\n-            }\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n+            // If we couldn't select a const destruct candidate, then it's bad\n+            return true;\n+        };\n+\n+        if !matches!(\n+            impl_src,\n+            ImplSource::ConstDestruct(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n+        ) {\n+            // If our const destruct candidate is not ConstDestruct or implied by the param env,\n+            // then it's bad\n+            return true;\n+        }\n \n-            if impl_src.borrow_nested_obligations().is_empty() {\n-                return false;\n-            }\n+        if impl_src.borrow_nested_obligations().is_empty() {\n+            return false;\n+        }\n \n-            // If we had any errors, then it's bad\n-            !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n-        })\n+        // If we had any errors, then it's bad\n+        !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "23276e60982d3c9dd897e95e3f71b36fed1cfa60", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -105,7 +105,7 @@ pub fn equal_up_to_regions<'tcx>(\n             },\n         )\n     };\n-    tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n+    tcx.infer_ctxt().build().can_eq(param_env, normalize(src), normalize(dest)).is_ok()\n }\n \n struct TypeChecker<'a, 'tcx> {"}, {"sha": "47915b4bd4e6ce6ff6e3948d59d42e2e34709b01", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -83,9 +83,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 Res::Def(DefKind::TyParam, src_def_id) => {\n                     if let Some(param_local_id) = param.def_id.as_local() {\n                         let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.infer_ctxt().enter(|infcx| {\n-                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id))\n-                        });\n+                        let infcx = tcx.infer_ctxt().build();\n+                        let param_type =\n+                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id));\n                         if param_type.is_suggestable(tcx, false) {\n                             err.span_suggestion(\n                                 tcx.def_span(src_def_id),"}, {"sha": "da5d0706bc08ee6d5208c0475a845b03459f2b8e", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -29,7 +29,7 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n use rustc_ty_utils::representability::{self, Representability};\n \n@@ -78,7 +78,7 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n /// * inherited: other fields inherited from the enclosing fn (if any)\n #[instrument(skip(inherited, body), level = \"debug\")]\n pub(super) fn check_fn<'a, 'tcx>(\n-    inherited: &'a Inherited<'a, 'tcx>,\n+    inherited: &'a Inherited<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     fn_sig: ty::FnSig<'tcx>,\n     decl: &'tcx hir::FnDecl<'tcx>,\n@@ -732,52 +732,52 @@ fn check_opaque_meets_bounds<'tcx>(\n     };\n     let param_env = tcx.param_env(defining_use_anchor);\n \n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor)).enter(\n-        move |infcx| {\n-            let ocx = ObligationCtxt::new(&infcx);\n-            let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor))\n+        .build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n-            let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+    let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-            match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-                Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n-                Err(ty_err) => {\n-                    tcx.sess.delay_span_bug(\n-                        span,\n-                        &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n-                    );\n-                }\n-            }\n+    match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+        Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+        Err(ty_err) => {\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n+            );\n+        }\n+    }\n \n-            // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n-            // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-            // hidden type is well formed even without those bounds.\n-            let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into()))\n-                .to_predicate(tcx);\n-            ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n-\n-            // Check that all obligations are satisfied by the implementation's\n-            // version.\n-            let errors = ocx.select_all_or_error();\n-            if !errors.is_empty() {\n-                infcx.report_fulfillment_errors(&errors, None, false);\n-            }\n-            match origin {\n-                // Checked when type checking the function containing them.\n-                hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n-                // Can have different predicates to their defining use\n-                hir::OpaqueTyOrigin::TyAlias => {\n-                    let outlives_environment = OutlivesEnvironment::new(param_env);\n-                    infcx.check_region_obligations_and_report_errors(\n-                        defining_use_anchor,\n-                        &outlives_environment,\n-                    );\n-                }\n-            }\n-            // Clean up after ourselves\n-            let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        },\n-    );\n+    // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n+    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+    // hidden type is well formed even without those bounds.\n+    let predicate =\n+        ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into())).to_predicate(tcx);\n+    ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n+\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+    }\n+    match origin {\n+        // Checked when type checking the function containing them.\n+        hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+        // Can have different predicates to their defining use\n+        hir::OpaqueTyOrigin::TyAlias => {\n+            let outlives_environment = OutlivesEnvironment::new(param_env);\n+            infcx.check_region_obligations_and_report_errors(\n+                defining_use_anchor,\n+                &outlives_environment,\n+            );\n+        }\n+    }\n+    // Clean up after ourselves\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n }\n \n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {"}, {"sha": "cf87fe3c510a421a0e09453fe3f0de769145c655", "filename": "compiler/rustc_hir_analysis/src/check/coercion.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -61,7 +61,7 @@ use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -702,7 +702,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.report_selection_error(obligation.clone(), &obligation, &err, false);\n+                    self.err_ctxt().report_selection_error(\n+                        obligation.clone(),\n+                        &obligation,\n+                        &err,\n+                        false,\n+                    );\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later.\n@@ -1549,7 +1554,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         }\n                     }\n                     _ => {\n-                        err = fcx.report_mismatched_types(\n+                        err = fcx.err_ctxt().report_mismatched_types(\n                             cause,\n                             expected,\n                             found,\n@@ -1629,7 +1634,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         expression: Option<&'tcx hir::Expr<'tcx>>,\n         blk_id: Option<hir::HirId>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n+        let mut err = fcx.err_ctxt().report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n         let mut fn_output = None;"}, {"sha": "5e5dbedb4bd7bd67dcc31c8b198d29cba7a2ea19", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 509, "deletions": 523, "changes": 1032, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, ObligationCtxt, Reveal,\n@@ -215,224 +215,220 @@ fn compare_predicate_entailment<'tcx>(\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n \n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n \n-        debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n+    debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-        let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n-        for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n-            let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n-            let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n+    for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n+        let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n+        let traits::Normalized { value: predicate, obligations } =\n+            traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n \n-            ocx.register_obligations(obligations);\n-            let cause = ObligationCause::new(\n-                span,\n-                impl_m_hir_id,\n-                ObligationCauseCode::CompareImplItemObligation {\n-                    impl_item_def_id: impl_m.def_id.expect_local(),\n-                    trait_item_def_id: trait_m.def_id,\n-                    kind: impl_m.kind,\n-                },\n-            );\n-            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n-        }\n-\n-        // We now need to check that the signature of the impl method is\n-        // compatible with that of the trait method. We do this by\n-        // checking that `impl_fty <: trait_fty`.\n-        //\n-        // FIXME. Unfortunately, this doesn't quite work right now because\n-        // associated type normalization is not integrated into subtype\n-        // checks. For the comparison to be valid, we need to\n-        // normalize the associated types in the impl/trait methods\n-        // first. However, because function types bind regions, just\n-        // calling `normalize_associated_types_in` would have no effect on\n-        // any associated types appearing in the fn arguments or return\n-        // type.\n-\n-        // Compute placeholder form of impl and trait method tys.\n-        let tcx = infcx.tcx;\n-\n-        let mut wf_tys = FxHashSet::default();\n-\n-        let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n-            impl_m_span,\n-            infer::HigherRankedType,\n-            tcx.fn_sig(impl_m.def_id),\n+        ocx.register_obligations(obligations);\n+        let cause = ObligationCause::new(\n+            span,\n+            impl_m_hir_id,\n+            ObligationCauseCode::CompareImplItemObligation {\n+                impl_item_def_id: impl_m.def_id.expect_local(),\n+                trait_item_def_id: trait_m.def_id,\n+                kind: impl_m.kind,\n+            },\n         );\n+        ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n+    }\n \n-        let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n-        let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n-        debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n-\n-        let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n-        let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n-\n-        // Next, add all inputs and output as well-formed tys. Importantly,\n-        // we have to do this before normalization, since the normalized ty may\n-        // not contain the input parameters. See issue #87748.\n-        wf_tys.extend(trait_sig.inputs_and_output.iter());\n-        let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n-        // We also have to add the normalized trait signature\n-        // as we don't normalize during implied bounds computation.\n-        wf_tys.extend(trait_sig.inputs_and_output.iter());\n-        let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n-\n-        debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n-\n-        // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n-        // processing the comparison between the trait and impl fn, but we sadly lose them\n-        // and point at the whole signature when a trait bound or specific input or output\n-        // type would be more appropriate. In other places we have a `Vec<Span>`\n-        // corresponding to their `Vec<Predicate>`, but we don't have that here.\n-        // Fixing this would improve the output of test `issue-83765.rs`.\n-        let mut result = infcx\n-            .at(&cause, param_env)\n-            .sup(trait_fty, impl_fty)\n-            .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n-\n-        // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n-        // RPITITs, we need to equate the output tys instead of just subtyping. If\n-        // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n-        // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n-        // fixed up to `ReEmpty`, and which is certainly not what we want.\n-        if trait_fty.has_infer_types() {\n-            result = result.and_then(|()| {\n-                infcx\n-                    .at(&cause, param_env)\n-                    .eq(trait_sig.output(), impl_sig.output())\n-                    .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n-            });\n-        }\n+    // We now need to check that the signature of the impl method is\n+    // compatible with that of the trait method. We do this by\n+    // checking that `impl_fty <: trait_fty`.\n+    //\n+    // FIXME. Unfortunately, this doesn't quite work right now because\n+    // associated type normalization is not integrated into subtype\n+    // checks. For the comparison to be valid, we need to\n+    // normalize the associated types in the impl/trait methods\n+    // first. However, because function types bind regions, just\n+    // calling `normalize_associated_types_in` would have no effect on\n+    // any associated types appearing in the fn arguments or return\n+    // type.\n+\n+    // Compute placeholder form of impl and trait method tys.\n+    let tcx = infcx.tcx;\n \n-        if let Err(terr) = result {\n-            debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n+    let mut wf_tys = FxHashSet::default();\n \n-            let (impl_err_span, trait_err_span) =\n-                extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+    let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n+        impl_m_span,\n+        infer::HigherRankedType,\n+        tcx.fn_sig(impl_m.def_id),\n+    );\n \n-            cause.span = impl_err_span;\n+    let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+    let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n+    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+    debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n+\n+    let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n+    let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n+\n+    // Next, add all inputs and output as well-formed tys. Importantly,\n+    // we have to do this before normalization, since the normalized ty may\n+    // not contain the input parameters. See issue #87748.\n+    wf_tys.extend(trait_sig.inputs_and_output.iter());\n+    let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n+    // We also have to add the normalized trait signature\n+    // as we don't normalize during implied bounds computation.\n+    wf_tys.extend(trait_sig.inputs_and_output.iter());\n+    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n+\n+    debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n+\n+    // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n+    // processing the comparison between the trait and impl fn, but we sadly lose them\n+    // and point at the whole signature when a trait bound or specific input or output\n+    // type would be more appropriate. In other places we have a `Vec<Span>`\n+    // corresponding to their `Vec<Predicate>`, but we don't have that here.\n+    // Fixing this would improve the output of test `issue-83765.rs`.\n+    let mut result = infcx\n+        .at(&cause, param_env)\n+        .sup(trait_fty, impl_fty)\n+        .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n+\n+    // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n+    // RPITITs, we need to equate the output tys instead of just subtyping. If\n+    // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n+    // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n+    // fixed up to `ReEmpty`, and which is certainly not what we want.\n+    if trait_fty.has_infer_types() {\n+        result = result.and_then(|()| {\n+            infcx\n+                .at(&cause, param_env)\n+                .eq(trait_sig.output(), impl_sig.output())\n+                .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n+        });\n+    }\n \n-            let mut diag = struct_span_err!(\n-                tcx.sess,\n-                cause.span(),\n-                E0053,\n-                \"method `{}` has an incompatible type for trait\",\n-                trait_m.name\n-            );\n-            match &terr {\n-                TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n-                    if trait_m.fn_has_self_parameter =>\n-                {\n-                    let ty = trait_sig.inputs()[0];\n-                    let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty())\n-                    {\n-                        ExplicitSelf::ByValue => \"self\".to_owned(),\n-                        ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                        ExplicitSelf::ByReference(_, hir::Mutability::Mut) => {\n-                            \"&mut self\".to_owned()\n-                        }\n-                        _ => format!(\"self: {ty}\"),\n-                    };\n+    if let Err(terr) = result {\n+        debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-                    // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n-                    // span points only at the type `Box<Self`>, but we want to cover the whole\n-                    // argument pattern and type.\n-                    let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                        ImplItemKind::Fn(ref sig, body) => tcx\n-                            .hir()\n-                            .body_param_names(body)\n-                            .zip(sig.decl.inputs.iter())\n-                            .map(|(param, ty)| param.span.to(ty.span))\n-                            .next()\n-                            .unwrap_or(impl_err_span),\n-                        _ => bug!(\"{:?} is not a method\", impl_m),\n-                    };\n+        let (impl_err_span, trait_err_span) =\n+            extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+\n+        cause.span = impl_err_span;\n \n+        let mut diag = struct_span_err!(\n+            tcx.sess,\n+            cause.span(),\n+            E0053,\n+            \"method `{}` has an incompatible type for trait\",\n+            trait_m.name\n+        );\n+        match &terr {\n+            TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+                if trait_m.fn_has_self_parameter =>\n+            {\n+                let ty = trait_sig.inputs()[0];\n+                let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+                    ExplicitSelf::ByValue => \"self\".to_owned(),\n+                    ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                    ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+                    _ => format!(\"self: {ty}\"),\n+                };\n+\n+                // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+                // span points only at the type `Box<Self`>, but we want to cover the whole\n+                // argument pattern and type.\n+                let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                    ImplItemKind::Fn(ref sig, body) => tcx\n+                        .hir()\n+                        .body_param_names(body)\n+                        .zip(sig.decl.inputs.iter())\n+                        .map(|(param, ty)| param.span.to(ty.span))\n+                        .next()\n+                        .unwrap_or(impl_err_span),\n+                    _ => bug!(\"{:?} is not a method\", impl_m),\n+                };\n+\n+                diag.span_suggestion(\n+                    span,\n+                    \"change the self-receiver type to match the trait\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+                if trait_sig.inputs().len() == *i {\n+                    // Suggestion to change output type. We do not suggest in `async` functions\n+                    // to avoid complex logic or incorrect output.\n+                    match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                        ImplItemKind::Fn(ref sig, _)\n+                            if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                        {\n+                            let msg = \"change the output type to match the trait\";\n+                            let ap = Applicability::MachineApplicable;\n+                            match sig.decl.output {\n+                                hir::FnRetTy::DefaultReturn(sp) => {\n+                                    let sugg = format!(\"-> {} \", trait_sig.output());\n+                                    diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                                }\n+                                hir::FnRetTy::Return(hir_ty) => {\n+                                    let sugg = trait_sig.output();\n+                                    diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                                }\n+                            };\n+                        }\n+                        _ => {}\n+                    };\n+                } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n                     diag.span_suggestion(\n-                        span,\n-                        \"change the self-receiver type to match the trait\",\n-                        sugg,\n+                        impl_err_span,\n+                        \"change the parameter type to match the trait\",\n+                        trait_ty,\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-                TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n-                    if trait_sig.inputs().len() == *i {\n-                        // Suggestion to change output type. We do not suggest in `async` functions\n-                        // to avoid complex logic or incorrect output.\n-                        match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                            ImplItemKind::Fn(ref sig, _)\n-                                if sig.header.asyncness == hir::IsAsync::NotAsync =>\n-                            {\n-                                let msg = \"change the output type to match the trait\";\n-                                let ap = Applicability::MachineApplicable;\n-                                match sig.decl.output {\n-                                    hir::FnRetTy::DefaultReturn(sp) => {\n-                                        let sugg = format!(\"-> {} \", trait_sig.output());\n-                                        diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                                    }\n-                                    hir::FnRetTy::Return(hir_ty) => {\n-                                        let sugg = trait_sig.output();\n-                                        diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                                    }\n-                                };\n-                            }\n-                            _ => {}\n-                        };\n-                    } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n-                        diag.span_suggestion(\n-                            impl_err_span,\n-                            \"change the parameter type to match the trait\",\n-                            trait_ty,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n \n-            infcx.note_type_err(\n-                &mut diag,\n-                &cause,\n-                trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-                Some(infer::ValuePairs::Terms(ExpectedFound {\n-                    expected: trait_fty.into(),\n-                    found: impl_fty.into(),\n-                })),\n-                terr,\n-                false,\n-                false,\n-            );\n+        infcx.err_ctxt().note_type_err(\n+            &mut diag,\n+            &cause,\n+            trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n+            Some(infer::ValuePairs::Terms(ExpectedFound {\n+                expected: trait_fty.into(),\n+                found: impl_fty.into(),\n+            })),\n+            terr,\n+            false,\n+            false,\n+        );\n \n-            return Err(diag.emit());\n-        }\n+        return Err(diag.emit());\n+    }\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n-        }\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let outlives_environment = OutlivesEnvironment::with_bounds(\n-            param_env,\n-            Some(infcx),\n-            infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n-        );\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_m.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_environment = OutlivesEnvironment::with_bounds(\n+        param_env,\n+        Some(infcx),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+    );\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_m.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n \n-        Ok(())\n-    })\n+    Ok(())\n }\n \n pub fn collect_trait_impl_trait_tys<'tcx>(\n@@ -465,125 +461,120 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let trait_to_placeholder_substs =\n         impl_to_placeholder_substs.rebase_onto(tcx, impl_m.container_id(tcx), trait_to_impl_substs);\n \n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n \n-        let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n-        let impl_return_ty = ocx.normalize(\n-            norm_cause.clone(),\n-            param_env,\n-            infcx\n-                .replace_bound_vars_with_fresh_vars(\n-                    return_span,\n-                    infer::HigherRankedType,\n-                    tcx.fn_sig(impl_m.def_id),\n-                )\n-                .output(),\n-        );\n-\n-        let mut collector =\n-            ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n-        let unnormalized_trait_return_ty = tcx\n-            .liberate_late_bound_regions(\n-                impl_m.def_id,\n-                tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n+    let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n+    let impl_return_ty = ocx.normalize(\n+        norm_cause.clone(),\n+        param_env,\n+        infcx\n+            .replace_bound_vars_with_fresh_vars(\n+                return_span,\n+                infer::HigherRankedType,\n+                tcx.fn_sig(impl_m.def_id),\n             )\n-            .output()\n-            .fold_with(&mut collector);\n-        let trait_return_ty =\n-            ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_return_ty);\n+            .output(),\n+    );\n \n-        let wf_tys = FxHashSet::from_iter([unnormalized_trait_return_ty, trait_return_ty]);\n+    let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n+    let unnormalized_trait_return_ty = tcx\n+        .liberate_late_bound_regions(\n+            impl_m.def_id,\n+            tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n+        )\n+        .output()\n+        .fold_with(&mut collector);\n+    let trait_return_ty =\n+        ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_return_ty);\n \n-        match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n-            Ok(infer::InferOk { value: (), obligations }) => {\n-                ocx.register_obligations(obligations);\n-            }\n-            Err(terr) => {\n-                let mut diag = struct_span_err!(\n-                    tcx.sess,\n-                    cause.span(),\n-                    E0053,\n-                    \"method `{}` has an incompatible return type for trait\",\n-                    trait_m.name\n-                );\n-                let hir = tcx.hir();\n-                infcx.note_type_err(\n-                    &mut diag,\n-                    &cause,\n-                    hir.get_if_local(impl_m.def_id)\n-                        .and_then(|node| node.fn_decl())\n-                        .map(|decl| (decl.output.span(), \"return type in trait\".to_owned())),\n-                    Some(infer::ValuePairs::Terms(ExpectedFound {\n-                        expected: trait_return_ty.into(),\n-                        found: impl_return_ty.into(),\n-                    })),\n-                    terr,\n-                    false,\n-                    false,\n-                );\n-                return Err(diag.emit());\n-            }\n-        }\n+    let wf_tys = FxHashSet::from_iter([unnormalized_trait_return_ty, trait_return_ty]);\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // RPITs.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n+    match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n+        Ok(infer::InferOk { value: (), obligations }) => {\n+            ocx.register_obligations(obligations);\n         }\n+        Err(terr) => {\n+            let mut diag = struct_span_err!(\n+                tcx.sess,\n+                cause.span(),\n+                E0053,\n+                \"method `{}` has an incompatible return type for trait\",\n+                trait_m.name\n+            );\n+            let hir = tcx.hir();\n+            infcx.err_ctxt().note_type_err(\n+                &mut diag,\n+                &cause,\n+                hir.get_if_local(impl_m.def_id)\n+                    .and_then(|node| node.fn_decl())\n+                    .map(|decl| (decl.output.span(), \"return type in trait\".to_owned())),\n+                Some(infer::ValuePairs::Terms(ExpectedFound {\n+                    expected: trait_return_ty.into(),\n+                    found: impl_return_ty.into(),\n+                })),\n+                terr,\n+                false,\n+                false,\n+            );\n+            return Err(diag.emit());\n+        }\n+    }\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let outlives_environment = OutlivesEnvironment::with_bounds(\n-            param_env,\n-            Some(infcx),\n-            infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n-        );\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_m.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n+    // Check that all obligations are satisfied by the implementation's\n+    // RPITs.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n \n-        let mut collected_tys = FxHashMap::default();\n-        for (def_id, (ty, substs)) in collector.types {\n-            match infcx.fully_resolve(ty) {\n-                Ok(ty) => {\n-                    // `ty` contains free regions that we created earlier while liberating the\n-                    // trait fn signature.  However, projection normalization expects `ty` to\n-                    // contains `def_id`'s early-bound regions.\n-                    let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    debug!(?id_substs, ?substs);\n-                    let map: FxHashMap<ty::GenericArg<'tcx>, ty::GenericArg<'tcx>> = substs\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(index, arg)| (arg, id_substs[index]))\n-                        .collect();\n-                    debug!(?map);\n-\n-                    let ty = tcx.fold_regions(ty, |region, _| {\n-                        if let ty::ReFree(_) = region.kind() {\n-                            map[&region.into()].expect_region()\n-                        } else {\n-                            region\n-                        }\n-                    });\n-                    debug!(%ty);\n-                    collected_tys.insert(def_id, ty);\n-                }\n-                Err(err) => {\n-                    tcx.sess.delay_span_bug(\n-                        return_span,\n-                        format!(\"could not fully resolve: {ty} => {err:?}\"),\n-                    );\n-                    collected_tys.insert(def_id, tcx.ty_error());\n-                }\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_environment = OutlivesEnvironment::with_bounds(\n+        param_env,\n+        Some(infcx),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+    );\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_m.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n+\n+    let mut collected_tys = FxHashMap::default();\n+    for (def_id, (ty, substs)) in collector.types {\n+        match infcx.fully_resolve(ty) {\n+            Ok(ty) => {\n+                // `ty` contains free regions that we created earlier while liberating the\n+                // trait fn signature.  However, projection normalization expects `ty` to\n+                // contains `def_id`'s early-bound regions.\n+                let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                debug!(?id_substs, ?substs);\n+                let map: FxHashMap<ty::GenericArg<'tcx>, ty::GenericArg<'tcx>> =\n+                    substs.iter().enumerate().map(|(index, arg)| (arg, id_substs[index])).collect();\n+                debug!(?map);\n+\n+                let ty = tcx.fold_regions(ty, |region, _| {\n+                    if let ty::ReFree(_) = region.kind() {\n+                        map[&region.into()].expect_region()\n+                    } else {\n+                        region\n+                    }\n+                });\n+                debug!(%ty);\n+                collected_tys.insert(def_id, ty);\n+            }\n+            Err(err) => {\n+                tcx.sess.delay_span_bug(\n+                    return_span,\n+                    format!(\"could not fully resolve: {ty} => {err:?}\"),\n+                );\n+                collected_tys.insert(def_id, tcx.ty_error());\n             }\n         }\n+    }\n \n-        Ok(&*tcx.arena.alloc(collected_tys))\n-    })\n+    Ok(&*tcx.arena.alloc(collected_tys))\n }\n \n struct ImplTraitInTraitCollector<'a, 'tcx> {\n@@ -712,8 +703,8 @@ fn check_region_bounds_on_impl_item<'tcx>(\n }\n \n #[instrument(level = \"debug\", skip(infcx))]\n-fn extract_spans_for_error_reporting<'a, 'tcx>(\n-    infcx: &infer::InferCtxt<'a, 'tcx>,\n+fn extract_spans_for_error_reporting<'tcx>(\n+    infcx: &infer::InferCtxt<'tcx>,\n     terr: TypeError<'_>,\n     cause: &ObligationCause<'tcx>,\n     impl_m: &ty::AssocItem,\n@@ -768,16 +759,15 @@ fn compare_self_type<'tcx>(\n         let self_arg_ty = tcx.fn_sig(method.def_id).input(0);\n         let param_env = ty::ParamEnv::reveal_all();\n \n-        tcx.infer_ctxt().enter(|infcx| {\n-            let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n-            let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n-            match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n-                ExplicitSelf::ByValue => \"self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                _ => format!(\"self: {self_arg_ty}\"),\n-            }\n-        })\n+        let infcx = tcx.infer_ctxt().build();\n+        let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n+        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n+        match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n+            ExplicitSelf::ByValue => \"self\".to_owned(),\n+            ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+            ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+            _ => format!(\"self: {self_arg_ty}\"),\n+        }\n     };\n \n     match (trait_m.fn_has_self_parameter, impl_m.fn_has_self_parameter) {\n@@ -1312,104 +1302,102 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n \n     let impl_c_span = tcx.def_span(impl_const_item_def.to_def_id());\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = tcx.param_env(impl_const_item_def.to_def_id());\n-        let ocx = ObligationCtxt::new(&infcx);\n-\n-        // The below is for the most part highly similar to the procedure\n-        // for methods above. It is simpler in many respects, especially\n-        // because we shouldn't really have to deal with lifetimes or\n-        // predicates. In fact some of this should probably be put into\n-        // shared functions because of DRY violations...\n-        let trait_to_impl_substs = impl_trait_ref.substs;\n-\n-        // Create a parameter environment that represents the implementation's\n-        // method.\n-        let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n-\n-        // Compute placeholder form of impl and trait const tys.\n-        let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n-        let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n-        let mut cause = ObligationCause::new(\n-            impl_c_span,\n-            impl_c_hir_id,\n-            ObligationCauseCode::CompareImplItemObligation {\n-                impl_item_def_id: impl_const_item_def,\n-                trait_item_def_id: trait_const_item_def,\n-                kind: impl_const_item.kind,\n-            },\n-        );\n+    let infcx = tcx.infer_ctxt().build();\n+    let param_env = tcx.param_env(impl_const_item_def.to_def_id());\n+    let ocx = ObligationCtxt::new(&infcx);\n \n-        // There is no \"body\" here, so just pass dummy id.\n-        let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n+    // The below is for the most part highly similar to the procedure\n+    // for methods above. It is simpler in many respects, especially\n+    // because we shouldn't really have to deal with lifetimes or\n+    // predicates. In fact some of this should probably be put into\n+    // shared functions because of DRY violations...\n+    let trait_to_impl_substs = impl_trait_ref.substs;\n \n-        debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n+    // Create a parameter environment that represents the implementation's\n+    // method.\n+    let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n \n-        let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n+    // Compute placeholder form of impl and trait const tys.\n+    let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n+    let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n+    let mut cause = ObligationCause::new(\n+        impl_c_span,\n+        impl_c_hir_id,\n+        ObligationCauseCode::CompareImplItemObligation {\n+            impl_item_def_id: impl_const_item_def,\n+            trait_item_def_id: trait_const_item_def,\n+            kind: impl_const_item.kind,\n+        },\n+    );\n \n-        debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n+    // There is no \"body\" here, so just pass dummy id.\n+    let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n \n-        let err = infcx\n-            .at(&cause, param_env)\n-            .sup(trait_ty, impl_ty)\n-            .map(|ok| ocx.register_infer_ok_obligations(ok));\n+    debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-        if let Err(terr) = err {\n-            debug!(\n-                \"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n-                impl_ty, trait_ty\n-            );\n+    let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n \n-            // Locate the Span containing just the type of the offending impl\n-            match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n-                ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-                _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n-            }\n+    debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-            let mut diag = struct_span_err!(\n-                tcx.sess,\n-                cause.span,\n-                E0326,\n-                \"implemented const `{}` has an incompatible type for trait\",\n-                trait_const_item.name\n-            );\n-\n-            let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n-                // Add a label to the Span containing just the type of the const\n-                match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n-                    TraitItemKind::Const(ref ty, _) => ty.span,\n-                    _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n-                }\n-            });\n+    let err = infcx\n+        .at(&cause, param_env)\n+        .sup(trait_ty, impl_ty)\n+        .map(|ok| ocx.register_infer_ok_obligations(ok));\n \n-            infcx.note_type_err(\n-                &mut diag,\n-                &cause,\n-                trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n-                Some(infer::ValuePairs::Terms(ExpectedFound {\n-                    expected: trait_ty.into(),\n-                    found: impl_ty.into(),\n-                })),\n-                terr,\n-                false,\n-                false,\n-            );\n-            return Err(diag.emit());\n-        };\n+    if let Err(terr) = err {\n+        debug!(\n+            \"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n+            impl_ty, trait_ty\n+        );\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            return Err(infcx.report_fulfillment_errors(&errors, None, false));\n+        // Locate the Span containing just the type of the offending impl\n+        match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n+            ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n+            _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n         }\n \n-        // FIXME return `ErrorReported` if region obligations error?\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx\n-            .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n-        Ok(())\n-    })\n+        let mut diag = struct_span_err!(\n+            tcx.sess,\n+            cause.span,\n+            E0326,\n+            \"implemented const `{}` has an incompatible type for trait\",\n+            trait_const_item.name\n+        );\n+\n+        let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n+            // Add a label to the Span containing just the type of the const\n+            match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n+                TraitItemKind::Const(ref ty, _) => ty.span,\n+                _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n+            }\n+        });\n+\n+        infcx.err_ctxt().note_type_err(\n+            &mut diag,\n+            &cause,\n+            trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n+            Some(infer::ValuePairs::Terms(ExpectedFound {\n+                expected: trait_ty.into(),\n+                found: impl_ty.into(),\n+            })),\n+            terr,\n+            false,\n+            false,\n+        );\n+        return Err(diag.emit());\n+    };\n+\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n+    }\n+\n+    // FIXME return `ErrorReported` if region obligations error?\n+    let outlives_environment = OutlivesEnvironment::new(param_env);\n+    infcx.check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n+    Ok(())\n }\n \n pub(crate) fn compare_ty_impl<'tcx>(\n@@ -1490,52 +1478,50 @@ fn compare_type_predicate_entailment<'tcx>(\n         hir::Constness::NotConst,\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let ocx = ObligationCtxt::new(&infcx);\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n \n-        debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n+    debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n-        let mut selcx = traits::SelectionContext::new(&infcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n-        for (span, predicate) in\n-            std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n-        {\n-            let cause = ObligationCause::misc(span, impl_ty_hir_id);\n-            let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, cause, predicate);\n-\n-            let cause = ObligationCause::new(\n-                span,\n-                impl_ty_hir_id,\n-                ObligationCauseCode::CompareImplItemObligation {\n-                    impl_item_def_id: impl_ty.def_id.expect_local(),\n-                    trait_item_def_id: trait_ty.def_id,\n-                    kind: impl_ty.kind,\n-                },\n-            );\n-            ocx.register_obligations(obligations);\n-            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n-        }\n-\n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n-        }\n+    assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n+    for (span, predicate) in std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n+    {\n+        let cause = ObligationCause::misc(span, impl_ty_hir_id);\n+        let traits::Normalized { value: predicate, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, predicate);\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_ty.def_id.expect_local(),\n-            &outlives_environment,\n+        let cause = ObligationCause::new(\n+            span,\n+            impl_ty_hir_id,\n+            ObligationCauseCode::CompareImplItemObligation {\n+                impl_item_def_id: impl_ty.def_id.expect_local(),\n+                trait_item_def_id: trait_ty.def_id,\n+                kind: impl_ty.kind,\n+            },\n         );\n+        ocx.register_obligations(obligations);\n+        ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n+    }\n \n-        Ok(())\n-    })\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n+\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_environment = OutlivesEnvironment::new(param_env);\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_ty.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n+\n+    Ok(())\n }\n \n /// Validate that `ProjectionCandidate`s created for this associated type will\n@@ -1695,94 +1681,94 @@ pub fn check_type_bounds<'tcx>(\n     let impl_ty_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n \n-    tcx.infer_ctxt().enter(move |infcx| {\n-        let ocx = ObligationCtxt::new(&infcx);\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n \n-        let assumed_wf_types =\n-            ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n+    let assumed_wf_types =\n+        ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n \n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-        let normalize_cause = ObligationCause::new(\n-            impl_ty_span,\n-            impl_ty_hir_id,\n-            ObligationCauseCode::CheckAssociatedTypeBounds {\n-                impl_item_def_id: impl_ty.def_id.expect_local(),\n-                trait_item_def_id: trait_ty.def_id,\n-            },\n-        );\n-        let mk_cause = |span: Span| {\n-            let code = if span.is_dummy() {\n-                traits::ItemObligation(trait_ty.def_id)\n-            } else {\n-                traits::BindingObligation(trait_ty.def_id, span)\n-            };\n-            ObligationCause::new(impl_ty_span, impl_ty_hir_id, code)\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let normalize_cause = ObligationCause::new(\n+        impl_ty_span,\n+        impl_ty_hir_id,\n+        ObligationCauseCode::CheckAssociatedTypeBounds {\n+            impl_item_def_id: impl_ty.def_id.expect_local(),\n+            trait_item_def_id: trait_ty.def_id,\n+        },\n+    );\n+    let mk_cause = |span: Span| {\n+        let code = if span.is_dummy() {\n+            traits::ItemObligation(trait_ty.def_id)\n+        } else {\n+            traits::BindingObligation(trait_ty.def_id, span)\n         };\n+        ObligationCause::new(impl_ty_span, impl_ty_hir_id, code)\n+    };\n \n-        let obligations = tcx\n-            .bound_explicit_item_bounds(trait_ty.def_id)\n-            .transpose_iter()\n-            .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-            .map(|(bound, span)| {\n-                debug!(?bound);\n-                // this is where opaque type is found\n-                let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n-                debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n-\n-                traits::Obligation::new(mk_cause(span.0), param_env, concrete_ty_bound)\n-            })\n-            .collect();\n-        debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n-\n-        for mut obligation in util::elaborate_obligations(tcx, obligations) {\n-            let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n-                &mut selcx,\n-                normalize_param_env,\n-                normalize_cause.clone(),\n-                obligation.predicate,\n-            );\n-            debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n-            obligation.predicate = normalized_predicate;\n+    let obligations = tcx\n+        .bound_explicit_item_bounds(trait_ty.def_id)\n+        .transpose_iter()\n+        .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n+        .map(|(bound, span)| {\n+            debug!(?bound);\n+            // this is where opaque type is found\n+            let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n+            debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n+\n+            traits::Obligation::new(mk_cause(span.0), param_env, concrete_ty_bound)\n+        })\n+        .collect();\n+    debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n+\n+    for mut obligation in util::elaborate_obligations(tcx, obligations) {\n+        let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n+            &mut selcx,\n+            normalize_param_env,\n+            normalize_cause.clone(),\n+            obligation.predicate,\n+        );\n+        debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n+        obligation.predicate = normalized_predicate;\n \n-            ocx.register_obligations(obligations);\n-            ocx.register_obligation(obligation);\n-        }\n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n-        }\n+        ocx.register_obligations(obligations);\n+        ocx.register_obligation(obligation);\n+    }\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n-        let outlives_environment =\n-            OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n+    let outlives_environment =\n+        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n \n-        infcx.check_region_obligations_and_report_errors(\n-            impl_ty.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_ty.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n \n-        let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        for (key, value) in constraints {\n-            infcx\n-                .report_mismatched_types(\n-                    &ObligationCause::misc(\n-                        value.hidden_type.span,\n-                        tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local()),\n-                    ),\n-                    tcx.mk_opaque(key.def_id.to_def_id(), key.substs),\n-                    value.hidden_type.ty,\n-                    TypeError::Mismatch,\n-                )\n-                .emit();\n-        }\n+    let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    for (key, value) in constraints {\n+        infcx\n+            .err_ctxt()\n+            .report_mismatched_types(\n+                &ObligationCause::misc(\n+                    value.hidden_type.span,\n+                    tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local()),\n+                ),\n+                tcx.mk_opaque(key.def_id.to_def_id(), key.substs),\n+                value.hidden_type.ty,\n+                TypeError::Mismatch,\n+            )\n+            .emit();\n+    }\n \n-        Ok(())\n-    })\n+    Ok(())\n }\n \n fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {"}, {"sha": "a5222c92331a9c6ebf8fc30ef9e97d884beb3264", "filename": "compiler/rustc_hir_analysis/src/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_predicates(obligations);\n                 None\n             }\n-            Err(e) => Some(self.report_mismatched_types(&cause, expected, actual, e)),\n+            Err(e) => Some(self.err_ctxt().report_mismatched_types(&cause, expected, actual, e)),\n         }\n     }\n \n@@ -109,7 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_predicates(obligations);\n                 None\n             }\n-            Err(e) => Some(self.report_mismatched_types(cause, expected, actual, e)),\n+            Err(e) => Some(self.err_ctxt().report_mismatched_types(cause, expected, actual, e)),\n         }\n     }\n \n@@ -153,7 +153,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n         let expr_ty = self.resolve_vars_with_obligations(checked_ty);\n-        let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e.clone());\n+        let mut err = self.err_ctxt().report_mismatched_types(&cause, expected, expr_ty, e.clone());\n \n         let is_insufficiently_polymorphic =\n             matches!(e, TypeError::RegionsInsufficientlyPolymorphic(..));"}, {"sha": "375c13d922bc7386677f182094c415cf49281019", "filename": "compiler/rustc_hir_analysis/src/check/expr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -1649,13 +1649,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Err(_) => {\n                                         // This should never happen, since we're just subtyping the\n                                         // remaining_fields, but it's fine to emit this, I guess.\n-                                        self.report_mismatched_types(\n-                                            &cause,\n-                                            target_ty,\n-                                            fru_ty,\n-                                            FieldMisMatch(variant.name, ident.name),\n-                                        )\n-                                        .emit();\n+                                        self.err_ctxt()\n+                                            .report_mismatched_types(\n+                                                &cause,\n+                                                target_ty,\n+                                                fru_ty,\n+                                                FieldMisMatch(variant.name, ident.name),\n+                                            )\n+                                            .emit();\n                                     }\n                                 }\n                             }\n@@ -1942,7 +1943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.set_tainted_by_errors();\n             return;\n         }\n-        let mut err = self.type_error_struct_with_diag(\n+        let mut err = self.err_ctxt().type_error_struct_with_diag(\n             field.ident.span,\n             |actual| match ty.kind() {\n                 ty::Adt(adt, ..) if adt.is_enum() => struct_span_err!("}, {"sha": "d140c3a0989900e26914cfdf5c676edc952a4979", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -32,7 +32,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n };\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n-            self.report_fulfillment_errors(&errors, self.inh.body_id, false);\n+            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id, false);\n         }\n     }\n \n@@ -629,7 +629,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !result.is_empty() {\n             mutate_fulfillment_errors(&mut result);\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut result);\n-            self.report_fulfillment_errors(&result, self.inh.body_id, fallback_has_occurred);\n+            self.err_ctxt().report_fulfillment_errors(\n+                &result,\n+                self.inh.body_id,\n+                fallback_has_occurred,\n+            );\n         }\n     }\n \n@@ -1466,7 +1470,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n+                self.err_ctxt()\n+                    .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n                     .emit();\n             }\n             let err = self.tcx.ty_error();"}, {"sha": "285db90a9df55a69226cd9a1a16a63d847f808b5", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -650,7 +650,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if tys.len() == 1 {\n                         // A tuple wrap suggestion actually occurs within,\n                         // so don't do anything special here.\n-                        err = self.report_and_explain_type_error(\n+                        err = self.err_ctxt().report_and_explain_type_error(\n                             TypeTrace::types(\n                                 &self.misc(*lo),\n                                 true,\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let cause = &self.misc(provided_span);\n                 let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                 if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n-                    self.report_and_explain_type_error(trace, *e).emit();\n+                    self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                     return true;\n                 }\n                 false\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (provided_ty, provided_arg_span) = provided_arg_tys[*provided_idx];\n             let cause = &self.misc(provided_arg_span);\n             let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-            let mut err = self.report_and_explain_type_error(trace, *err);\n+            let mut err = self.err_ctxt().report_and_explain_type_error(trace, *err);\n             self.emit_coerce_suggestions(\n                 &mut err,\n                 &provided_args[*provided_idx],\n@@ -840,7 +840,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let cause = &self.misc(provided_span);\n                         let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                         if let Some(e) = error {\n-                            self.note_type_err(\n+                            self.err_ctxt().note_type_err(\n                                 &mut err,\n                                 &trace.cause,\n                                 None,\n@@ -1474,7 +1474,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &mut |err| {\n                             if let Some(expected_ty) = expected.only_has_type(self) {\n                                 if !self.consider_removing_semicolon(blk, expected_ty, err) {\n-                                    self.consider_returning_binding(blk, expected_ty, err);\n+                                    self.err_ctxt().consider_returning_binding(\n+                                        blk,\n+                                        expected_ty,\n+                                        err,\n+                                    );\n                                 }\n                                 if expected_ty == self.tcx.types.bool {\n                                     // If this is caused by a missing `let` in a `while let`,"}, {"sha": "51f4cb7e0ebfa227b11c58b2c4d91cecf1da43d2", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -13,6 +13,7 @@ use crate::check::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer;\n+use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -117,7 +118,7 @@ pub struct FnCtxt<'a, 'tcx> {\n \n     pub(super) enclosing_breakables: RefCell<EnclosingBreakables<'tcx>>,\n \n-    pub(super) inh: &'a Inherited<'a, 'tcx>,\n+    pub(super) inh: &'a Inherited<'tcx>,\n \n     /// True if the function or closure's return type is known before\n     /// entering the function/closure, i.e. if the return type is\n@@ -131,7 +132,7 @@ pub struct FnCtxt<'a, 'tcx> {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn new(\n-        inh: &'a Inherited<'a, 'tcx>,\n+        inh: &'a Inherited<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n     ) -> FnCtxt<'a, 'tcx> {\n@@ -168,13 +169,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self.tcx.sess\n     }\n \n+    /// Creates an `TypeErrCtxt` with a reference to the in-progress\n+    /// `TypeckResults` which is used for diagnostics.\n+    /// Use [`InferCtxt::err_ctxt`] to start one without a `TypeckResults`.\n+    ///\n+    /// [`InferCtxt::err_ctxt`]: infer::InferCtxt::err_ctxt\n+    pub fn err_ctxt(&'a self) -> TypeErrCtxt<'a, 'tcx> {\n+        TypeErrCtxt { infcx: &self.infcx, typeck_results: Some(self.typeck_results.borrow()) }\n+    }\n+\n     pub fn errors_reported_since_creation(&self) -> bool {\n         self.tcx.sess.err_count() > self.err_count_on_creation\n     }\n }\n \n impl<'a, 'tcx> Deref for FnCtxt<'a, 'tcx> {\n-    type Target = Inherited<'a, 'tcx>;\n+    type Target = Inherited<'tcx>;\n     fn deref(&self) -> &Self::Target {\n         &self.inh\n     }"}, {"sha": "7a40def177ac9d85c813aa55e2a13ca5cce6b34f", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -876,18 +876,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n-                hir::IsAsync::Async => self\n-                    .tcx\n-                    .infer_ctxt()\n-                    .enter(|infcx| {\n-                        infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                hir::IsAsync::Async => {\n+                    let infcx = self.tcx.infer_ctxt().build();\n+                    infcx\n+                        .get_impl_future_output_ty(ty)\n+                        .unwrap_or_else(|| {\n                             span_bug!(\n                                 fn_decl.output.span(),\n                                 \"failed to get output type of async function\"\n                             )\n                         })\n-                    })\n-                    .skip_binder(),\n+                        .skip_binder()\n+                }\n                 hir::IsAsync::NotAsync => ty,\n             };\n             if self.can_coerce(found, ty) {\n@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We'll later suggest `.as_ref` when noting the type error,\n         // so skip if we will suggest that instead.\n-        if self.should_suggest_as_ref(expected_ty, expr_ty).is_some() {\n+        if self.err_ctxt().should_suggest_as_ref(expected_ty, expr_ty).is_some() {\n             return false;\n         }\n \n@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n         err: &mut Diagnostic,\n     ) -> bool {\n-        if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n+        if let Some((span_semi, boxed)) = self.err_ctxt().could_remove_semicolon(blk, expected_ty) {\n             if let StatementAsExpression::NeedsBoxing = boxed {\n                 err.span_suggestion_verbose(\n                     span_semi,"}, {"sha": "0fb7651b3a1e1decbabc188f605e718ed56367c8", "filename": "compiler/rustc_hir_analysis/src/check/inherited.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n-use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -29,10 +29,10 @@ use std::ops::Deref;\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited<'a, 'tcx> {\n-    pub(super) infcx: InferCtxt<'a, 'tcx>,\n+pub struct Inherited<'tcx> {\n+    pub(super) infcx: InferCtxt<'tcx>,\n \n-    pub(super) typeck_results: &'a RefCell<ty::TypeckResults<'tcx>>,\n+    pub(super) typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n \n     pub(super) locals: RefCell<HirIdMap<super::LocalTy<'tcx>>>,\n \n@@ -70,30 +70,31 @@ pub struct Inherited<'a, 'tcx> {\n     pub(super) diverging_type_vars: RefCell<FxHashSet<Ty<'tcx>>>,\n }\n \n-impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n-    type Target = InferCtxt<'a, 'tcx>;\n+impl<'tcx> Deref for Inherited<'tcx> {\n+    type Target = InferCtxt<'tcx>;\n     fn deref(&self) -> &Self::Target {\n         &self.infcx\n     }\n }\n \n /// A temporary returned by `Inherited::build(...)`. This is necessary\n-/// for multiple `InferCtxt` to share the same `in_progress_typeck_results`\n+/// for multiple `InferCtxt` to share the same `typeck_results`\n /// without using `Rc` or something similar.\n pub struct InheritedBuilder<'tcx> {\n     infcx: infer::InferCtxtBuilder<'tcx>,\n     def_id: LocalDefId,\n+    typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n }\n \n-impl<'tcx> Inherited<'_, 'tcx> {\n+impl<'tcx> Inherited<'tcx> {\n     pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n         InheritedBuilder {\n             infcx: tcx\n                 .infer_ctxt()\n                 .ignoring_regions()\n-                .with_fresh_in_progress_typeck_results(hir_owner)\n+                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n                 .with_normalize_fn_sig_for_diagnostic(Lrc::new(move |infcx, fn_sig| {\n                     if fn_sig.has_escaping_bound_vars() {\n                         return fn_sig;\n@@ -117,26 +118,29 @@ impl<'tcx> Inherited<'_, 'tcx> {\n                     })\n                 })),\n             def_id,\n+            typeck_results: RefCell::new(ty::TypeckResults::new(hir_owner)),\n         }\n     }\n }\n \n impl<'tcx> InheritedBuilder<'tcx> {\n-    pub fn enter<F, R>(&mut self, f: F) -> R\n+    pub fn enter<F, R>(mut self, f: F) -> R\n     where\n-        F: for<'a> FnOnce(Inherited<'a, 'tcx>) -> R,\n+        F: FnOnce(&Inherited<'tcx>) -> R,\n     {\n         let def_id = self.def_id;\n-        self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n+        f(&Inherited::new(self.infcx.build(), def_id, self.typeck_results))\n     }\n }\n \n-impl<'a, 'tcx> Inherited<'a, 'tcx> {\n-    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n+impl<'tcx> Inherited<'tcx> {\n+    fn new(\n+        infcx: InferCtxt<'tcx>,\n+        def_id: LocalDefId,\n+        typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n+    ) -> Self {\n         let tcx = infcx.tcx;\n         let body_id = tcx.hir().maybe_body_owned_by(def_id);\n-        let typeck_results =\n-            infcx.in_progress_typeck_results.expect(\"building `FnCtxt` without typeck results\");\n \n         Inherited {\n             typeck_results,"}, {"sha": "ba078ad0abbd9d1cff09d25a725c91352991a56f", "filename": "compiler/rustc_hir_analysis/src/check/method/probe.rs", "status": "modified", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -472,69 +472,65 @@ fn method_autoderef_steps<'tcx>(\n ) -> MethodAutoderefStepsResult<'tcx> {\n     debug!(\"method_autoderef_steps({:?})\", goal);\n \n-    tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n-        let ParamEnvAnd { param_env, value: self_ty } = goal;\n-\n-        let mut autoderef =\n-            Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n-                .include_raw_pointers()\n-                .silence_errors();\n-        let mut reached_raw_pointer = false;\n-        let mut steps: Vec<_> = autoderef\n-            .by_ref()\n-            .map(|(ty, d)| {\n-                let step = CandidateStep {\n-                    self_ty: infcx.make_query_response_ignoring_pending_obligations(\n-                        inference_vars.clone(),\n-                        ty,\n-                    ),\n-                    autoderefs: d,\n-                    from_unsafe_deref: reached_raw_pointer,\n-                    unsize: false,\n-                };\n-                if let ty::RawPtr(_) = ty.kind() {\n-                    // all the subsequent steps will be from_unsafe_deref\n-                    reached_raw_pointer = true;\n-                }\n-                step\n-            })\n-            .collect();\n-\n-        let final_ty = autoderef.final_ty(true);\n-        let opt_bad_ty = match final_ty.kind() {\n-            ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n-                reached_raw_pointer,\n-                ty: infcx\n-                    .make_query_response_ignoring_pending_obligations(inference_vars, final_ty),\n-            }),\n-            ty::Array(elem_ty, _) => {\n-                let dereferences = steps.len() - 1;\n-\n-                steps.push(CandidateStep {\n-                    self_ty: infcx.make_query_response_ignoring_pending_obligations(\n-                        inference_vars,\n-                        infcx.tcx.mk_slice(*elem_ty),\n-                    ),\n-                    autoderefs: dereferences,\n-                    // this could be from an unsafe deref if we had\n-                    // a *mut/const [T; N]\n-                    from_unsafe_deref: reached_raw_pointer,\n-                    unsize: true,\n-                });\n-\n-                None\n+    let (ref infcx, goal, inference_vars) = tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+    let ParamEnvAnd { param_env, value: self_ty } = goal;\n+\n+    let mut autoderef =\n+        Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n+            .include_raw_pointers()\n+            .silence_errors();\n+    let mut reached_raw_pointer = false;\n+    let mut steps: Vec<_> = autoderef\n+        .by_ref()\n+        .map(|(ty, d)| {\n+            let step = CandidateStep {\n+                self_ty: infcx\n+                    .make_query_response_ignoring_pending_obligations(inference_vars.clone(), ty),\n+                autoderefs: d,\n+                from_unsafe_deref: reached_raw_pointer,\n+                unsize: false,\n+            };\n+            if let ty::RawPtr(_) = ty.kind() {\n+                // all the subsequent steps will be from_unsafe_deref\n+                reached_raw_pointer = true;\n             }\n-            _ => None,\n-        };\n-\n-        debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n+            step\n+        })\n+        .collect();\n+\n+    let final_ty = autoderef.final_ty(true);\n+    let opt_bad_ty = match final_ty.kind() {\n+        ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n+            reached_raw_pointer,\n+            ty: infcx.make_query_response_ignoring_pending_obligations(inference_vars, final_ty),\n+        }),\n+        ty::Array(elem_ty, _) => {\n+            let dereferences = steps.len() - 1;\n+\n+            steps.push(CandidateStep {\n+                self_ty: infcx.make_query_response_ignoring_pending_obligations(\n+                    inference_vars,\n+                    infcx.tcx.mk_slice(*elem_ty),\n+                ),\n+                autoderefs: dereferences,\n+                // this could be from an unsafe deref if we had\n+                // a *mut/const [T; N]\n+                from_unsafe_deref: reached_raw_pointer,\n+                unsize: true,\n+            });\n \n-        MethodAutoderefStepsResult {\n-            steps: tcx.arena.alloc_from_iter(steps),\n-            opt_bad_ty: opt_bad_ty.map(|ty| &*tcx.arena.alloc(ty)),\n-            reached_recursion_limit: autoderef.reached_recursion_limit(),\n+            None\n         }\n-    })\n+        _ => None,\n+    };\n+\n+    debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n+\n+    MethodAutoderefStepsResult {\n+        steps: tcx.arena.alloc_from_iter(steps),\n+        opt_bad_ty: opt_bad_ty.map(|ty| &*tcx.arena.alloc(ty)),\n+        reached_recursion_limit: autoderef.reached_recursion_limit(),\n+    }\n }\n \n impl<'a, 'tcx> ProbeContext<'a, 'tcx> {"}, {"sha": "e276c4f7d84c4ab3a2844a4fb5e9dbd34af24fc3", "filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n-use rustc_trait_selection::traits::error_reporting::on_unimplemented::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     FulfillmentError, Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedNote,\n@@ -855,8 +855,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             // Avoid crashing.\n                                             return (None, None);\n                                         }\n-                                        let OnUnimplementedNote { message, label, .. } =\n-                                            self.on_unimplemented_note(trait_ref, &obligation);\n+                                        let OnUnimplementedNote { message, label, .. } = self\n+                                            .err_ctxt()\n+                                            .on_unimplemented_note(trait_ref, &obligation);\n                                         (message, label)\n                                     })\n                                     .unwrap_or((None, None))"}, {"sha": "5e498a92ec20315fc44c1a46d2e88e3749f39d54", "filename": "compiler/rustc_hir_analysis/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -18,7 +18,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n use rustc_type_ir::sty::TyKind::*;\n \n@@ -512,7 +512,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         _ => None,\n                                     };\n \n-                                    self.suggest_restricting_param_bound(\n+                                    self.err_ctxt().suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n                                         output_associated_item,\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             error.obligation.predicate.to_opt_poly_trait_pred()\n                         });\n                         for pred in predicates {\n-                            self.suggest_restricting_param_bound(\n+                            self.err_ctxt().suggest_restricting_param_bound(\n                                 &mut err,\n                                 pred,\n                                 None,"}, {"sha": "441eac03b50aeb3d3d8aafe30a9559c572f5367f", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -22,7 +22,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::autoderef::Autoderef;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -91,29 +91,28 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n {\n     let param_env = tcx.param_env(body_def_id);\n     let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n \n-        let assumed_wf_types = ocx.assumed_wf_types(param_env, span, body_def_id);\n+    let assumed_wf_types = ocx.assumed_wf_types(param_env, span, body_def_id);\n \n-        let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n+    let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n \n-        if !tcx.features().trivial_bounds {\n-            wfcx.check_false_global_bounds()\n-        }\n-        f(&mut wfcx);\n-        let errors = wfcx.select_all_or_error();\n-        if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n-            return;\n-        }\n+    if !tcx.features().trivial_bounds {\n+        wfcx.check_false_global_bounds()\n+    }\n+    f(&mut wfcx);\n+    let errors = wfcx.select_all_or_error();\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return;\n+    }\n \n-        let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n-        let outlives_environment =\n-            OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n+    let outlives_environment =\n+        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n-        infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n-    })\n+    infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n@@ -699,29 +698,28 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxHashSet<Ty<'tcx>>,\n-    add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'a, 'tcx>, &'a RegionBoundPairs<'tcx>),\n+    add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'tcx>, &'a RegionBoundPairs<'tcx>),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n     // region constraints get added and solved there and we need to test each\n     // call individually.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let outlives_environment = OutlivesEnvironment::with_bounds(\n-            param_env,\n-            Some(&infcx),\n-            infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n-        );\n-        let region_bound_pairs = outlives_environment.region_bound_pairs();\n+    let infcx = tcx.infer_ctxt().build();\n+    let outlives_environment = OutlivesEnvironment::with_bounds(\n+        param_env,\n+        Some(&infcx),\n+        infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n+    );\n+    let region_bound_pairs = outlives_environment.region_bound_pairs();\n \n-        add_constraints(&infcx, region_bound_pairs);\n+    add_constraints(&infcx, region_bound_pairs);\n \n-        let errors = infcx.resolve_regions(&outlives_environment);\n+    let errors = infcx.resolve_regions(&outlives_environment);\n \n-        debug!(?errors, \"errors\");\n+    debug!(?errors, \"errors\");\n \n-        // If we were able to prove that the type outlives the region without\n-        // an error, it must be because of the implied or explicit bounds...\n-        errors.is_empty()\n-    })\n+    // If we were able to prove that the type outlives the region without\n+    // an error, it must be because of the implied or explicit bounds...\n+    errors.is_empty()\n }\n \n /// TypeVisitor that looks for uses of GATs like\n@@ -1677,7 +1675,7 @@ fn receiver_is_valid<'tcx>(\n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n         if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n-            infcx.report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n+            infcx.err_ctxt().report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n     }\n@@ -1709,7 +1707,10 @@ fn receiver_is_valid<'tcx>(\n                 if let Err(err) =\n                     wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n                 {\n-                    infcx.report_mismatched_types(&cause, self_ty, potential_self_ty, err).emit();\n+                    infcx\n+                        .err_ctxt()\n+                        .report_mismatched_types(&cause, self_ty, potential_self_ty, err)\n+                        .emit();\n                 }\n \n                 break;"}, {"sha": "3583769b7cd646c068c8ce477f51ea9848cf517b", "filename": "compiler/rustc_hir_analysis/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -700,7 +700,7 @@ impl Locatable for hir::HirId {\n /// unresolved types and so forth.\n struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     span: &'cx dyn Locatable,\n     body: &'tcx hir::Body<'tcx>,\n \n@@ -720,6 +720,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) {\n         if !self.tcx.sess.has_errors().is_some() {\n             self.infcx\n+                .err_ctxt()\n                 .emit_inference_failure_err(\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),"}, {"sha": "b6c91d425dff4bfd6ee4b788b5af7413962a10cd", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 315, "deletions": 331, "changes": 646, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitable};\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::{self, ObligationCause};\n@@ -108,43 +108,42 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 // why this field does not implement Copy. This is useful because sometimes\n                 // it is not immediately clear why Copy is not implemented for a field, since\n                 // all we point at is the field itself.\n-                tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-                    for error in traits::fully_solve_bound(\n-                        &infcx,\n-                        traits::ObligationCause::dummy_with_span(field_ty_span),\n-                        param_env,\n-                        ty,\n-                        tcx.lang_items().copy_trait().unwrap(),\n-                    ) {\n-                        let error_predicate = error.obligation.predicate;\n-                        // Only note if it's not the root obligation, otherwise it's trivial and\n-                        // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n-\n-                        // FIXME: This error could be more descriptive, especially if the error_predicate\n-                        // contains a foreign type or if it's a deeply nested type...\n-                        if error_predicate != error.root_obligation.predicate {\n-                            errors\n-                                .entry((ty.to_string(), error_predicate.to_string()))\n-                                .or_default()\n-                                .push(error.obligation.cause.span);\n-                        }\n-                        if let ty::PredicateKind::Trait(ty::TraitPredicate {\n-                            trait_ref,\n-                            polarity: ty::ImplPolarity::Positive,\n-                            ..\n-                        }) = error_predicate.kind().skip_binder()\n-                        {\n-                            let ty = trait_ref.self_ty();\n-                            if let ty::Param(_) = ty.kind() {\n-                                bounds.push((\n-                                    format!(\"{ty}\"),\n-                                    trait_ref.print_only_trait_path().to_string(),\n-                                    Some(trait_ref.def_id),\n-                                ));\n-                            }\n+                let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+                for error in traits::fully_solve_bound(\n+                    &infcx,\n+                    traits::ObligationCause::dummy_with_span(field_ty_span),\n+                    param_env,\n+                    ty,\n+                    tcx.lang_items().copy_trait().unwrap(),\n+                ) {\n+                    let error_predicate = error.obligation.predicate;\n+                    // Only note if it's not the root obligation, otherwise it's trivial and\n+                    // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n+\n+                    // FIXME: This error could be more descriptive, especially if the error_predicate\n+                    // contains a foreign type or if it's a deeply nested type...\n+                    if error_predicate != error.root_obligation.predicate {\n+                        errors\n+                            .entry((ty.to_string(), error_predicate.to_string()))\n+                            .or_default()\n+                            .push(error.obligation.cause.span);\n+                    }\n+                    if let ty::PredicateKind::Trait(ty::TraitPredicate {\n+                        trait_ref,\n+                        polarity: ty::ImplPolarity::Positive,\n+                        ..\n+                    }) = error_predicate.kind().skip_binder()\n+                    {\n+                        let ty = trait_ref.self_ty();\n+                        if let ty::Param(_) = ty.kind() {\n+                            bounds.push((\n+                                format!(\"{ty}\"),\n+                                trait_ref.print_only_trait_path().to_string(),\n+                                Some(trait_ref.def_id),\n+                            ));\n                         }\n                     }\n-                });\n+                }\n             }\n             for ((ty, error_predicate), spans) in errors {\n                 let span: MultiSpan = spans.into();\n@@ -205,91 +204,89 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n \n     let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::misc(span, impl_hir_id);\n-\n-        use rustc_type_ir::sty::TyKind::*;\n-        match (source.kind(), target.kind()) {\n-            (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n-            (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n-            (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n-                if def_a.is_struct() && def_b.is_struct() =>\n-            {\n-                if def_a != def_b {\n-                    let source_path = tcx.def_path_str(def_a.did());\n-                    let target_path = tcx.def_path_str(def_b.did());\n-\n-                    create_err(&format!(\n-                        \"the trait `DispatchFromDyn` may only be implemented \\\n-                                for a coercion between structures with the same \\\n-                                definition; expected `{}`, found `{}`\",\n-                        source_path, target_path,\n-                    ))\n-                    .emit();\n+    let infcx = tcx.infer_ctxt().build();\n+    let cause = ObligationCause::misc(span, impl_hir_id);\n+\n+    use rustc_type_ir::sty::TyKind::*;\n+    match (source.kind(), target.kind()) {\n+        (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n+            if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+        (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n+        (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n+            if def_a.is_struct() && def_b.is_struct() =>\n+        {\n+            if def_a != def_b {\n+                let source_path = tcx.def_path_str(def_a.did());\n+                let target_path = tcx.def_path_str(def_b.did());\n+\n+                create_err(&format!(\n+                    \"the trait `DispatchFromDyn` may only be implemented \\\n+                            for a coercion between structures with the same \\\n+                            definition; expected `{}`, found `{}`\",\n+                    source_path, target_path,\n+                ))\n+                .emit();\n \n-                    return;\n-                }\n+                return;\n+            }\n \n-                if def_a.repr().c() || def_a.repr().packed() {\n-                    create_err(\n-                        \"structs implementing `DispatchFromDyn` may not have \\\n-                             `#[repr(packed)]` or `#[repr(C)]`\",\n-                    )\n-                    .emit();\n-                }\n+            if def_a.repr().c() || def_a.repr().packed() {\n+                create_err(\n+                    \"structs implementing `DispatchFromDyn` may not have \\\n+                         `#[repr(packed)]` or `#[repr(C)]`\",\n+                )\n+                .emit();\n+            }\n \n-                let fields = &def_a.non_enum_variant().fields;\n+            let fields = &def_a.non_enum_variant().fields;\n \n-                let coerced_fields = fields\n-                    .iter()\n-                    .filter(|field| {\n-                        let ty_a = field.ty(tcx, substs_a);\n-                        let ty_b = field.ty(tcx, substs_b);\n+            let coerced_fields = fields\n+                .iter()\n+                .filter(|field| {\n+                    let ty_a = field.ty(tcx, substs_a);\n+                    let ty_b = field.ty(tcx, substs_b);\n \n-                        if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n-                            if layout.is_zst() && layout.align.abi.bytes() == 1 {\n-                                // ignore ZST fields with alignment of 1 byte\n-                                return false;\n-                            }\n+                    if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n+                        if layout.is_zst() && layout.align.abi.bytes() == 1 {\n+                            // ignore ZST fields with alignment of 1 byte\n+                            return false;\n                         }\n+                    }\n \n-                        if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n-                            if ok.obligations.is_empty() {\n-                                create_err(\n-                                    \"the trait `DispatchFromDyn` may only be implemented \\\n-                                     for structs containing the field being coerced, \\\n-                                     ZST fields with 1 byte alignment, and nothing else\",\n-                                )\n-                                .note(&format!(\n-                                    \"extra field `{}` of type `{}` is not allowed\",\n-                                    field.name, ty_a,\n-                                ))\n-                                .emit();\n-\n-                                return false;\n-                            }\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                        if ok.obligations.is_empty() {\n+                            create_err(\n+                                \"the trait `DispatchFromDyn` may only be implemented \\\n+                                 for structs containing the field being coerced, \\\n+                                 ZST fields with 1 byte alignment, and nothing else\",\n+                            )\n+                            .note(&format!(\n+                                \"extra field `{}` of type `{}` is not allowed\",\n+                                field.name, ty_a,\n+                            ))\n+                            .emit();\n+\n+                            return false;\n                         }\n+                    }\n \n-                        return true;\n-                    })\n-                    .collect::<Vec<_>>();\n+                    return true;\n+                })\n+                .collect::<Vec<_>>();\n \n-                if coerced_fields.is_empty() {\n-                    create_err(\n-                        \"the trait `DispatchFromDyn` may only be implemented \\\n-                            for a coercion between structures with a single field \\\n-                            being coerced, none found\",\n-                    )\n-                    .emit();\n-                } else if coerced_fields.len() > 1 {\n-                    create_err(\n-                        \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n-                    )\n+            if coerced_fields.is_empty() {\n+                create_err(\n+                    \"the trait `DispatchFromDyn` may only be implemented \\\n+                        for a coercion between structures with a single field \\\n+                        being coerced, none found\",\n+                )\n+                .emit();\n+            } else if coerced_fields.len() > 1 {\n+                create_err(\"implementing the `DispatchFromDyn` trait requires multiple coercions\")\n                     .note(\n                         \"the trait `DispatchFromDyn` may only be implemented \\\n-                                for a coercion between structures with a single field \\\n-                                being coerced\",\n+                            for a coercion between structures with a single field \\\n+                            being coerced\",\n                     )\n                     .note(&format!(\n                         \"currently, {} fields need coercions: {}\",\n@@ -308,39 +305,38 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                             .join(\", \")\n                     ))\n                     .emit();\n-                } else {\n-                    let errors = traits::fully_solve_obligations(\n-                        &infcx,\n-                        coerced_fields.into_iter().map(|field| {\n-                            predicate_for_trait_def(\n-                                tcx,\n-                                param_env,\n-                                cause.clone(),\n-                                dispatch_from_dyn_trait,\n-                                0,\n-                                field.ty(tcx, substs_a),\n-                                &[field.ty(tcx, substs_b).into()],\n-                            )\n-                        }),\n-                    );\n-                    if !errors.is_empty() {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n-                    }\n-\n-                    // Finally, resolve all regions.\n-                    let outlives_env = OutlivesEnvironment::new(param_env);\n-                    infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+            } else {\n+                let errors = traits::fully_solve_obligations(\n+                    &infcx,\n+                    coerced_fields.into_iter().map(|field| {\n+                        predicate_for_trait_def(\n+                            tcx,\n+                            param_env,\n+                            cause.clone(),\n+                            dispatch_from_dyn_trait,\n+                            0,\n+                            field.ty(tcx, substs_a),\n+                            &[field.ty(tcx, substs_b).into()],\n+                        )\n+                    }),\n+                );\n+                if !errors.is_empty() {\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                 }\n-            }\n-            _ => {\n-                create_err(\n-                    \"the trait `DispatchFromDyn` may only be implemented \\\n-                        for a coercion between structures\",\n-                )\n-                .emit();\n+\n+                // Finally, resolve all regions.\n+                let outlives_env = OutlivesEnvironment::new(param_env);\n+                infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n-    })\n+        _ => {\n+            create_err(\n+                \"the trait `DispatchFromDyn` may only be implemented \\\n+                    for a coercion between structures\",\n+            )\n+            .emit();\n+        }\n+    }\n }\n \n pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n@@ -369,220 +365,208 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\", source, target);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-        let cause = ObligationCause::misc(span, impl_hir_id);\n-        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n-                           mt_b: ty::TypeAndMut<'tcx>,\n-                           mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n-                infcx\n-                    .report_mismatched_types(\n-                        &cause,\n-                        mk_ptr(mt_b.ty),\n-                        target,\n-                        ty::error::TypeError::Mutability,\n-                    )\n-                    .emit();\n-            }\n-            (mt_a.ty, mt_b.ty, unsize_trait, None)\n-        };\n-        let (source, target, trait_def_id, kind) = match (source.kind(), target.kind()) {\n-            (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n-                infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-            }\n+    let infcx = tcx.infer_ctxt().build();\n+    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n+    let cause = ObligationCause::misc(span, impl_hir_id);\n+    let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n+                       mt_b: ty::TypeAndMut<'tcx>,\n+                       mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+        if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n+            infcx\n+                .err_ctxt()\n+                .report_mismatched_types(\n+                    &cause,\n+                    mk_ptr(mt_b.ty),\n+                    target,\n+                    ty::error::TypeError::Mutability,\n+                )\n+                .emit();\n+        }\n+        (mt_a.ty, mt_b.ty, unsize_trait, None)\n+    };\n+    let (source, target, trait_def_id, kind) = match (source.kind(), target.kind()) {\n+        (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n+            infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+            let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+            let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n+            check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+        }\n \n-            (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n-                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n-            }\n+        (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n+            let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+            check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+        }\n+\n+        (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty)),\n \n-            (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+        (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b))\n+            if def_a.is_struct() && def_b.is_struct() =>\n+        {\n+            if def_a != def_b {\n+                let source_path = tcx.def_path_str(def_a.did());\n+                let target_path = tcx.def_path_str(def_b.did());\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0377,\n+                    \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures with the same \\\n+                           definition; expected `{}`, found `{}`\",\n+                    source_path,\n+                    target_path\n+                )\n+                .emit();\n+                return err_info;\n             }\n \n-            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b))\n-                if def_a.is_struct() && def_b.is_struct() =>\n-            {\n-                if def_a != def_b {\n-                    let source_path = tcx.def_path_str(def_a.did());\n-                    let target_path = tcx.def_path_str(def_b.did());\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0377,\n-                        \"the trait `CoerceUnsized` may only be implemented \\\n-                               for a coercion between structures with the same \\\n-                               definition; expected `{}`, found `{}`\",\n-                        source_path,\n-                        target_path\n-                    )\n-                    .emit();\n-                    return err_info;\n-                }\n+            // Here we are considering a case of converting\n+            // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+            // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n+            //\n+            //     struct Foo<T, U> {\n+            //         extra: T,\n+            //         ptr: *mut U,\n+            //     }\n+            //\n+            // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n+            // to `Foo<T, [i32]>`. That impl would look like:\n+            //\n+            //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n+            //\n+            // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n+            // when this coercion occurs, we would be changing the\n+            // field `ptr` from a thin pointer of type `*mut [i32;\n+            // 3]` to a fat pointer of type `*mut [i32]` (with\n+            // extra data `3`).  **The purpose of this check is to\n+            // make sure that we know how to do this conversion.**\n+            //\n+            // To check if this impl is legal, we would walk down\n+            // the fields of `Foo` and consider their types with\n+            // both substitutes. We are looking to find that\n+            // exactly one (non-phantom) field has changed its\n+            // type, which we will expect to be the pointer that\n+            // is becoming fat (we could probably generalize this\n+            // to multiple thin pointers of the same type becoming\n+            // fat, but we don't). In this case:\n+            //\n+            // - `extra` has type `T` before and type `T` after\n+            // - `ptr` has type `*mut U` before and type `*mut V` after\n+            //\n+            // Since just one field changed, we would then check\n+            // that `*mut U: CoerceUnsized<*mut V>` is implemented\n+            // (in other words, that we know how to do this\n+            // conversion). This will work out because `U:\n+            // Unsize<V>`, and we have a builtin rule that `*mut\n+            // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n+            let fields = &def_a.non_enum_variant().fields;\n+            let diff_fields = fields\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(i, f)| {\n+                    let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                    if tcx.type_of(f.did).is_phantom_data() {\n+                        // Ignore PhantomData fields\n+                        return None;\n+                    }\n \n-                // Here we are considering a case of converting\n-                // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n-                // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n-                //\n-                //     struct Foo<T, U> {\n-                //         extra: T,\n-                //         ptr: *mut U,\n-                //     }\n-                //\n-                // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n-                // to `Foo<T, [i32]>`. That impl would look like:\n-                //\n-                //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n-                //\n-                // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n-                // when this coercion occurs, we would be changing the\n-                // field `ptr` from a thin pointer of type `*mut [i32;\n-                // 3]` to a fat pointer of type `*mut [i32]` (with\n-                // extra data `3`).  **The purpose of this check is to\n-                // make sure that we know how to do this conversion.**\n-                //\n-                // To check if this impl is legal, we would walk down\n-                // the fields of `Foo` and consider their types with\n-                // both substitutes. We are looking to find that\n-                // exactly one (non-phantom) field has changed its\n-                // type, which we will expect to be the pointer that\n-                // is becoming fat (we could probably generalize this\n-                // to multiple thin pointers of the same type becoming\n-                // fat, but we don't). In this case:\n-                //\n-                // - `extra` has type `T` before and type `T` after\n-                // - `ptr` has type `*mut U` before and type `*mut V` after\n-                //\n-                // Since just one field changed, we would then check\n-                // that `*mut U: CoerceUnsized<*mut V>` is implemented\n-                // (in other words, that we know how to do this\n-                // conversion). This will work out because `U:\n-                // Unsize<V>`, and we have a builtin rule that `*mut\n-                // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n-                let fields = &def_a.non_enum_variant().fields;\n-                let diff_fields = fields\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                        if tcx.type_of(f.did).is_phantom_data() {\n-                            // Ignore PhantomData fields\n+                    // Ignore fields that aren't changed; it may\n+                    // be that we could get away with subtyping or\n+                    // something more accepting, but we use\n+                    // equality because we want to be able to\n+                    // perform this check without computing\n+                    // variance where possible. (This is because\n+                    // we may have to evaluate constraint\n+                    // expressions in the course of execution.)\n+                    // See e.g., #41936.\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n+                        if ok.obligations.is_empty() {\n                             return None;\n                         }\n+                    }\n \n-                        // Ignore fields that aren't changed; it may\n-                        // be that we could get away with subtyping or\n-                        // something more accepting, but we use\n-                        // equality because we want to be able to\n-                        // perform this check without computing\n-                        // variance where possible. (This is because\n-                        // we may have to evaluate constraint\n-                        // expressions in the course of execution.)\n-                        // See e.g., #41936.\n-                        if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n-                            if ok.obligations.is_empty() {\n-                                return None;\n-                            }\n-                        }\n+                    // Collect up all fields that were significantly changed\n+                    // i.e., those that contain T in coerce_unsized T -> U\n+                    Some((i, a, b))\n+                })\n+                .collect::<Vec<_>>();\n \n-                        // Collect up all fields that were significantly changed\n-                        // i.e., those that contain T in coerce_unsized T -> U\n-                        Some((i, a, b))\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                if diff_fields.is_empty() {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0374,\n-                        \"the trait `CoerceUnsized` may only be implemented \\\n-                               for a coercion between structures with one field \\\n-                               being coerced, none found\"\n-                    )\n-                    .emit();\n-                    return err_info;\n-                } else if diff_fields.len() > 1 {\n-                    let item = tcx.hir().expect_item(impl_did);\n-                    let span = if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) =\n-                        item.kind\n-                    {\n+            if diff_fields.is_empty() {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0374,\n+                    \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures with one field \\\n+                           being coerced, none found\"\n+                )\n+                .emit();\n+                return err_info;\n+            } else if diff_fields.len() > 1 {\n+                let item = tcx.hir().expect_item(impl_did);\n+                let span =\n+                    if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) = item.kind {\n                         t.path.span\n                     } else {\n                         tcx.def_span(impl_did)\n                     };\n \n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0375,\n-                        \"implementing the trait \\\n-                                                    `CoerceUnsized` requires multiple \\\n-                                                    coercions\"\n-                    )\n-                    .note(\n-                        \"`CoerceUnsized` may only be implemented for \\\n-                              a coercion between structures with one field being coerced\",\n-                    )\n-                    .note(&format!(\n-                        \"currently, {} fields need coercions: {}\",\n-                        diff_fields.len(),\n-                        diff_fields\n-                            .iter()\n-                            .map(|&(i, a, b)| {\n-                                format!(\"`{}` (`{}` to `{}`)\", fields[i].name, a, b)\n-                            })\n-                            .collect::<Vec<_>>()\n-                            .join(\", \")\n-                    ))\n-                    .span_label(span, \"requires multiple coercions\")\n-                    .emit();\n-                    return err_info;\n-                }\n-\n-                let (i, a, b) = diff_fields[0];\n-                let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                (a, b, coerce_unsized_trait, Some(kind))\n-            }\n-\n-            _ => {\n                 struct_span_err!(\n                     tcx.sess,\n                     span,\n-                    E0376,\n-                    \"the trait `CoerceUnsized` may only be implemented \\\n-                           for a coercion between structures\"\n+                    E0375,\n+                    \"implementing the trait \\\n+                                                `CoerceUnsized` requires multiple \\\n+                                                coercions\"\n+                )\n+                .note(\n+                    \"`CoerceUnsized` may only be implemented for \\\n+                          a coercion between structures with one field being coerced\",\n                 )\n+                .note(&format!(\n+                    \"currently, {} fields need coercions: {}\",\n+                    diff_fields.len(),\n+                    diff_fields\n+                        .iter()\n+                        .map(|&(i, a, b)| { format!(\"`{}` (`{}` to `{}`)\", fields[i].name, a, b) })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                ))\n+                .span_label(span, \"requires multiple coercions\")\n                 .emit();\n                 return err_info;\n             }\n-        };\n-\n-        // Register an obligation for `A: Trait<B>`.\n-        let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = predicate_for_trait_def(\n-            tcx,\n-            param_env,\n-            cause,\n-            trait_def_id,\n-            0,\n-            source,\n-            &[target.into()],\n-        );\n-        let errors = traits::fully_solve_obligation(&infcx, predicate);\n-        if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n+\n+            let (i, a, b) = diff_fields[0];\n+            let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+            (a, b, coerce_unsized_trait, Some(kind))\n         }\n \n-        // Finally, resolve all regions.\n-        let outlives_env = OutlivesEnvironment::new(param_env);\n-        infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+        _ => {\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0376,\n+                \"the trait `CoerceUnsized` may only be implemented \\\n+                       for a coercion between structures\"\n+            )\n+            .emit();\n+            return err_info;\n+        }\n+    };\n+\n+    // Register an obligation for `A: Trait<B>`.\n+    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    let predicate =\n+        predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, source, &[target.into()]);\n+    let errors = traits::fully_solve_obligation(&infcx, predicate);\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+    }\n+\n+    // Finally, resolve all regions.\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n \n-        CoerceUnsizedInfo { custom_kind: kind }\n-    })\n+    CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "cbc3769901d724daf22d6955f61fb30ea5105bf8", "filename": "compiler/rustc_hir_analysis/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - `typeck_results` --- typeck results for the code being analyzed\n     pub fn new(\n         delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         body_owner: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,"}, {"sha": "53f636d19b41a1551aa11c6aa690ccd52a1c4357", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -64,38 +64,36 @@ fn diagnostic_hir_wf_check<'tcx>(\n \n     impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-            self.tcx.infer_ctxt().enter(|infcx| {\n-                let tcx_ty =\n-                    self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n-                let cause = traits::ObligationCause::new(\n-                    ty.span,\n-                    self.hir_id,\n-                    traits::ObligationCauseCode::WellFormed(None),\n-                );\n-                let errors = traits::fully_solve_obligation(\n-                    &infcx,\n-                    traits::Obligation::new(\n-                        cause,\n-                        self.param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(tcx_ty.into()))\n-                            .to_predicate(self.tcx),\n-                    ),\n-                );\n-                if !errors.is_empty() {\n-                    debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n-                    for error in errors {\n-                        if error.obligation.predicate == self.predicate {\n-                            // Save the cause from the greatest depth - this corresponds\n-                            // to picking more-specific types (e.g. `MyStruct<u8>`)\n-                            // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n-                            if self.depth >= self.cause_depth {\n-                                self.cause = Some(error.obligation.cause);\n-                                self.cause_depth = self.depth\n-                            }\n+            let infcx = self.tcx.infer_ctxt().build();\n+            let tcx_ty = self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n+            let cause = traits::ObligationCause::new(\n+                ty.span,\n+                self.hir_id,\n+                traits::ObligationCauseCode::WellFormed(None),\n+            );\n+            let errors = traits::fully_solve_obligation(\n+                &infcx,\n+                traits::Obligation::new(\n+                    cause,\n+                    self.param_env,\n+                    ty::Binder::dummy(ty::PredicateKind::WellFormed(tcx_ty.into()))\n+                        .to_predicate(self.tcx),\n+                ),\n+            );\n+            if !errors.is_empty() {\n+                debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n+                for error in errors {\n+                    if error.obligation.predicate == self.predicate {\n+                        // Save the cause from the greatest depth - this corresponds\n+                        // to picking more-specific types (e.g. `MyStruct<u8>`)\n+                        // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n+                        if self.depth >= self.cause_depth {\n+                            self.cause = Some(error.obligation.cause);\n+                            self.cause_depth = self.depth\n                         }\n                     }\n                 }\n-            });\n+            }\n             self.depth += 1;\n             intravisit::walk_ty(self, ty);\n             self.depth -= 1;"}, {"sha": "bfe5d4751e08f5eb489feaa05b4e249040873e0f", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -77,7 +77,7 @@ use rustc_middle::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n \n@@ -139,34 +139,33 @@ fn get_impl_substs<'tcx>(\n     impl1_def_id: LocalDefId,\n     impl2_node: Node,\n ) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n-        let param_env = tcx.param_env(impl1_def_id);\n-        let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n+    let param_env = tcx.param_env(impl1_def_id);\n+    let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n \n-        let assumed_wf_types =\n-            ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n+    let assumed_wf_types =\n+        ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n \n-        let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n-        let impl2_substs =\n-            translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n+    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n+    let impl2_substs =\n+        translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n \n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            ocx.infcx.report_fulfillment_errors(&errors, None, false);\n-            return None;\n-        }\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return None;\n+    }\n \n-        let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n-        let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n-        infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n-        let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n-            let span = tcx.def_span(impl1_def_id);\n-            tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n-            return None;\n-        };\n-        Some((impl1_substs, impl2_substs))\n-    })\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n+        let span = tcx.def_span(impl1_def_id);\n+        tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n+        return None;\n+    };\n+    Some((impl1_substs, impl2_substs))\n }\n \n /// Returns a list of all of the unconstrained subst of the given impl.\n@@ -344,23 +343,21 @@ fn check_predicates<'tcx>(\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n-        tcx.infer_ctxt().enter(|ref infcx| {\n-            let obligations = wf::obligations(\n-                infcx,\n-                tcx.param_env(impl1_def_id),\n-                tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n-                0,\n-                arg,\n-                span,\n-            )\n-            .unwrap();\n+        let infcx = &tcx.infer_ctxt().build();\n+        let obligations = wf::obligations(\n+            infcx,\n+            tcx.param_env(impl1_def_id),\n+            tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+            0,\n+            arg,\n+            span,\n+        )\n+        .unwrap();\n \n-            assert!(!obligations.needs_infer());\n-            impl2_predicates.extend(\n-                traits::elaborate_obligations(tcx, obligations)\n-                    .map(|obligation| obligation.predicate),\n-            )\n-        })\n+        assert!(!obligations.needs_infer());\n+        impl2_predicates.extend(\n+            traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n+        )\n     }\n     impl2_predicates.extend(\n         traits::elaborate_predicates_with_span(tcx, always_applicable_traits)"}, {"sha": "b7d9fc8a2fe272b71b7af99f9254708950300687", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -110,7 +110,7 @@ use rustc_middle::util;\n use rustc_session::config::EntryFnType;\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n@@ -141,24 +141,23 @@ fn require_same_types<'tcx>(\n     expected: Ty<'tcx>,\n     actual: Ty<'tcx>,\n ) -> bool {\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let param_env = ty::ParamEnv::empty();\n-        let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n-            Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n-            Err(err) => {\n-                infcx.report_mismatched_types(cause, expected, actual, err).emit();\n-                return false;\n-            }\n-        };\n+    let infcx = &tcx.infer_ctxt().build();\n+    let param_env = ty::ParamEnv::empty();\n+    let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+        Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n+        Err(err) => {\n+            infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();\n+            return false;\n+        }\n+    };\n \n-        match &errors[..] {\n-            [] => true,\n-            errors => {\n-                infcx.report_fulfillment_errors(errors, None, false);\n-                false\n-            }\n+    match &errors[..] {\n+        [] => true,\n+        errors => {\n+            infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n+            false\n         }\n-    })\n+    }\n }\n \n fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n@@ -305,23 +304,22 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n             error = true;\n         }\n         let return_ty = return_ty.skip_binder();\n-        tcx.infer_ctxt().enter(|infcx| {\n-            // Main should have no WC, so empty param env is OK here.\n-            let param_env = ty::ParamEnv::empty();\n-            let cause = traits::ObligationCause::new(\n-                return_ty_span,\n-                main_diagnostics_hir_id,\n-                ObligationCauseCode::MainFunctionType,\n-            );\n-            let ocx = traits::ObligationCtxt::new(&infcx);\n-            let norm_return_ty = ocx.normalize(cause.clone(), param_env, return_ty);\n-            ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n-            let errors = ocx.select_all_or_error();\n-            if !errors.is_empty() {\n-                infcx.report_fulfillment_errors(&errors, None, false);\n-                error = true;\n-            }\n-        });\n+        let infcx = tcx.infer_ctxt().build();\n+        // Main should have no WC, so empty param env is OK here.\n+        let param_env = ty::ParamEnv::empty();\n+        let cause = traits::ObligationCause::new(\n+            return_ty_span,\n+            main_diagnostics_hir_id,\n+            ObligationCauseCode::MainFunctionType,\n+        );\n+        let ocx = traits::ObligationCtxt::new(&infcx);\n+        let norm_return_ty = ocx.normalize(cause.clone(), param_env, return_ty);\n+        ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n+        let errors = ocx.select_all_or_error();\n+        if !errors.is_empty() {\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            error = true;\n+        }\n         // now we can take the return type of the given main function\n         expected_return_type = main_fnsig.output();\n     } else {"}, {"sha": "a6880c7e77ac3ebc645cd844865e4cdf19de6f0d", "filename": "compiler/rustc_hir_analysis/src/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -92,7 +92,7 @@ impl HirNode for hir::Pat<'_> {\n #[derive(Clone)]\n pub(crate) struct MemCategorizationContext<'a, 'tcx> {\n     pub(crate) typeck_results: &'a ty::TypeckResults<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_owner: LocalDefId,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n@@ -103,7 +103,7 @@ pub(crate) type McResult<T> = Result<T, ()>;\n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Creates a `MemCategorizationContext`.\n     pub(crate) fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_owner: LocalDefId,\n         typeck_results: &'a ty::TypeckResults<'tcx>,"}, {"sha": "5ff3779fa1438ba11aff507786ce3de4ed0bbaa5", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n pub struct At<'a, 'tcx> {\n-    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+    pub infcx: &'a InferCtxt<'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     /// Whether we should define opaque types\n@@ -48,9 +48,9 @@ pub struct Trace<'a, 'tcx> {\n     trace: TypeTrace<'tcx>,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     #[inline]\n-    pub fn at(\n+    pub fn at<'a>(\n         &'a self,\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -66,7 +66,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             tcx: self.tcx,\n             defining_use_anchor: self.defining_use_anchor,\n             considering_regions: self.considering_regions,\n-            in_progress_typeck_results: self.in_progress_typeck_results,\n             inner: self.inner.clone(),\n             skip_leak_check: self.skip_leak_check.clone(),\n             lexical_region_resolutions: self.lexical_region_resolutions.clone(),"}, {"sha": "a3ff703634037b83ce8e254c30aeae5ca377665b", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n use smallvec::SmallVec;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Canonicalizes a query value `V`. When we canonicalize a query,\n     /// we not only canonicalize unbound inference variables, but we\n     /// *also* replace all free regions whatsoever. So for example a\n@@ -316,7 +316,7 @@ impl CanonicalizeMode for CanonicalizeFreeRegionsOtherThanStatic {\n }\n \n struct Canonicalizer<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     variables: SmallVec<[CanonicalVarInfo<'tcx>; 8]>,\n     query_state: &'cx mut OriginalQueryValues<'tcx>,\n@@ -521,7 +521,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     /// `canonicalize_query` and `canonicalize_response`.\n     fn canonicalize<V>(\n         value: V,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeMode,\n         query_state: &mut OriginalQueryValues<'tcx>,"}, {"sha": "06ca2534d5c3f0f610d3c43e27d156e1e80f1cd0", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -36,7 +36,7 @@ mod canonicalizer;\n pub mod query_response;\n mod substitute;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n     /// inference variables and applies it to the canonical value.\n     /// Returns both the instantiated result *and* the substitution S."}, {"sha": "eb0135d76f1e406e6f56a4ccf6cbe4c232cf8787", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -32,7 +32,7 @@ use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// This method is meant to be invoked as the final step of a canonical query\n     /// implementation. It is given:\n     ///\n@@ -677,7 +677,7 @@ pub fn make_query_region_constraints<'tcx>(\n }\n \n struct QueryTypeRelatingDelegate<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: &'a ObligationCause<'tcx>,"}, {"sha": "b5427f639c13ca7cd9b5a4167ea28e5ab715f76c", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -43,7 +43,7 @@ use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'tcx> {\n-    pub infcx: &'infcx InferCtxt<'infcx, 'tcx>,\n+    pub infcx: &'infcx InferCtxt<'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -63,7 +63,7 @@ pub enum RelationDir {\n     EqTo,\n }\n \n-impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     pub fn super_combine_tys<R>(\n         &self,\n         relation: &mut R,\n@@ -452,7 +452,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n }\n \n struct Generalizer<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n \n     /// The span, used when creating new type variables and things.\n     cause: &'cx ObligationCause<'tcx>,\n@@ -775,7 +775,7 @@ fn float_unification_error<'tcx>(\n }\n \n struct ConstInferUnifier<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n \n     span: Span,\n "}, {"sha": "dd6b85c39509262e94160c523e86bd172b73b8dc", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 78, "deletions": 47, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -75,7 +75,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n-use std::ops::ControlFlow;\n+use std::ops::{ControlFlow, Deref};\n use std::{cmp, fmt, iter};\n \n mod note;\n@@ -85,6 +85,31 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n+/// A helper for building type related errors. The `typeck_results`\n+/// field is only populated during an in-progress typeck.\n+/// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n+pub struct TypeErrCtxt<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'tcx>,\n+    pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n+}\n+\n+impl TypeErrCtxt<'_, '_> {\n+    /// This is just to avoid a potential footgun of accidentally\n+    /// dropping `typeck_results` by calling `InferCtxt::err_ctxt`\n+    #[deprecated(note = \"you already have a `TypeErrCtxt`\")]\n+    #[allow(unused)]\n+    pub fn err_ctxt(&self) -> ! {\n+        bug!(\"called `err_ctxt` on `TypeErrCtxt`. Try removing the call\");\n+    }\n+}\n+\n+impl<'tcx> Deref for TypeErrCtxt<'_, 'tcx> {\n+    type Target = InferCtxt<'tcx>;\n+    fn deref(&self) -> &InferCtxt<'tcx> {\n+        &self.infcx\n+    }\n+}\n+\n pub(super) fn note_and_explain_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     err: &mut Diagnostic,\n@@ -304,7 +329,39 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     err\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n+        if let ty::Opaque(def_id, substs) = ty.kind() {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n+\n+            let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n+\n+            for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n+                let predicate = predicate.subst(self.tcx, substs);\n+                let output = predicate\n+                    .kind()\n+                    .map_bound(|kind| match kind {\n+                        ty::PredicateKind::Projection(projection_predicate)\n+                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n+                        {\n+                            projection_predicate.term.ty()\n+                        }\n+                        _ => None,\n+                    })\n+                    .transpose();\n+                if output.is_some() {\n+                    // We don't account for multiple `Future::Output = Ty` constraints.\n+                    return output;\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n         generic_param_scope: LocalDefId,\n@@ -578,13 +635,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 {\n                     // don't show type `_`\n                     if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n-                    && let ty::Adt(def, substs) = ty.kind()\n-                    && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n+                        && let ty::Adt(def, substs) = ty.kind()\n+                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n                     {\n                         err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n                     } else {\n-                        err.span_label(span, format!(\"this expression has type `{}`\", ty));\n-                    }\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n+                }\n                 }\n                 if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n                     && ty.is_box() && ty.boxed_ty() == found\n@@ -620,8 +677,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n                         let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n-                            self.in_progress_typeck_results.and_then(|typeck_results| {\n-                                typeck_results.borrow().expr_ty_opt(arg_expr)\n+                            self.typeck_results.as_ref().and_then(|typeck_results| {\n+                                typeck_results.expr_ty_opt(arg_expr)\n                             })\n                         } else {\n                             bug!(\"try desugaring w/out call expr as scrutinee\");\n@@ -727,10 +784,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => {\n                 if let ObligationCauseCode::BindingObligation(_, span)\n                 | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n-                    = cause.code().peel_derives()\n+                = cause.code().peel_derives()\n                     && let TypeError::RegionsPlaceholderMismatch = terr\n                 {\n-                    err.span_note(*span, \"the lifetime requirement is introduced here\");\n+                    err.span_note( * span,\n+                    \"the lifetime requirement is introduced here\");\n                 }\n             }\n         }\n@@ -1954,36 +2012,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n-        if let ty::Opaque(def_id, substs) = ty.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n-\n-            let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n-\n-            for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-                let predicate = predicate.subst(self.tcx, substs);\n-                let output = predicate\n-                    .kind()\n-                    .map_bound(|kind| match kind {\n-                        ty::PredicateKind::Projection(projection_predicate)\n-                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n-                        {\n-                            projection_predicate.term.ty()\n-                        }\n-                        _ => None,\n-                    })\n-                    .transpose();\n-                if output.is_some() {\n-                    // We don't account for multiple `Future::Output = Ty` constraints.\n-                    return output;\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     /// A possible error is to forget to add `.await` when using futures:\n     ///\n     /// ```compile_fail,E0308\n@@ -2431,7 +2459,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let generics = self.tcx.generics_of(generic_param_scope);\n@@ -2809,7 +2837,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-struct SameTypeModuloInfer<'a, 'tcx>(&'a InferCtxt<'a, 'tcx>);\n+struct SameTypeModuloInfer<'a, 'tcx>(&'a InferCtxt<'tcx>);\n \n impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -2896,7 +2924,7 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     fn report_inference_failure(\n         &self,\n         var_origin: RegionVariableOrigin,\n@@ -3084,7 +3112,7 @@ impl TyCategory {\n     }\n }\n \n-impl<'tcx> InferCtxt<'_, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Given a [`hir::Block`], get the span of its last expression or\n     /// statement, peeling off any inner blocks.\n     pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n@@ -3111,7 +3139,9 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n             _ => rustc_span::DUMMY_SP,\n         }\n     }\n+}\n \n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n     /// is enough to fix the error.\n     pub fn could_remove_semicolon(\n@@ -3128,7 +3158,7 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n         let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n             return None;\n         };\n-        let last_expr_ty = self.in_progress_typeck_results?.borrow().expr_ty_opt(*last_expr)?;\n+        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n         let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n             _ if last_expr_ty.references_error() => return None,\n             _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n@@ -3211,8 +3241,9 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n         let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n             if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n                 && let Some(pat_ty) = self\n-                    .in_progress_typeck_results\n-                    .and_then(|typeck_results| typeck_results.borrow().node_type_opt(*hir_id))\n+                    .typeck_results\n+                    .as_ref()\n+                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n             {\n                 let pat_ty = self.resolve_vars_if_possible(pat_ty);\n                 if self.same_type_modulo_infer(pat_ty, expected_ty)"}, {"sha": "f4b3ded53b030ff2349e568f147c37de41f5ff18", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -2,6 +2,7 @@ use crate::errors::{\n     AmbigousImpl, AmbigousReturn, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n     SourceKindMultiSuggestion, SourceKindSubdiag,\n };\n+use crate::infer::error_reporting::TypeErrCtxt;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::InferCtxt;\n use rustc_errors::IntoDiagnostic;\n@@ -151,7 +152,7 @@ impl UnderspecifiedArgKind {\n     }\n }\n \n-fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'_, 'tcx>, ns: Namespace) -> FmtPrinter<'a, 'tcx> {\n+fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'tcx>, ns: Namespace) -> FmtPrinter<'a, 'tcx> {\n     let mut printer = FmtPrinter::new(infcx.tcx, ns);\n     let ty_getter = move |ty_vid| {\n         if infcx.probe_ty_var(ty_vid).is_ok() {\n@@ -182,7 +183,7 @@ fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'_, 'tcx>, ns: Namespace) -> FmtPr\n     printer\n }\n \n-fn ty_to_string<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n+fn ty_to_string<'tcx>(infcx: &InferCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n     let printer = fmt_printer(infcx, Namespace::TypeNS);\n     let ty = infcx.resolve_vars_if_possible(ty);\n     match ty.kind() {\n@@ -201,7 +202,7 @@ fn ty_to_string<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n /// We don't want to directly use `ty_to_string` for closures as their type isn't really\n /// something users are familiar with. Directly printing the `fn_sig` of closures also\n /// doesn't work as they actually use the \"rust-call\" API.\n-fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n+fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n     let ty::Closure(_, substs) = ty.kind() else { unreachable!() };\n     let fn_sig = substs.as_closure().sig();\n     let args = fn_sig\n@@ -225,7 +226,7 @@ fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String\n     format!(\"fn({}){}\", args, ret)\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Extracts data used by diagnostic for either types or constants\n     /// which were stuck during inference.\n     pub fn extract_inference_diagnostics_data(\n@@ -317,7 +318,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Used as a fallback in [InferCtxt::emit_inference_failure_err]\n+    /// Used as a fallback in [TypeErrCtxt::emit_inference_failure_err]\n     /// in case we weren't able to get a better error.\n     fn bad_inference_failure_err(\n         &self,\n@@ -364,7 +365,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n+}\n \n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -376,14 +379,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n \n-        let Some(typeck_results) = self.in_progress_typeck_results else {\n+        let Some(typeck_results) = &self.typeck_results else {\n             // If we don't have any typeck results we're outside\n             // of a body, so we won't be able to get better info\n             // here.\n             return self.bad_inference_failure_err(failure_span, arg_data, error_code);\n         };\n-        let typeck_results = typeck_results.borrow();\n-        let typeck_results = &typeck_results;\n \n         let mut local_visitor = FindInferSourceVisitor::new(&self, typeck_results, arg);\n         if let Some(body_id) = body_id {\n@@ -563,7 +564,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n+}\n \n+impl<'tcx> InferCtxt<'tcx> {\n     pub fn need_type_info_err_in_generator(\n         &self,\n         kind: hir::GeneratorKind,\n@@ -654,7 +657,7 @@ impl<'tcx> InferSource<'tcx> {\n }\n \n impl<'tcx> InferSourceKind<'tcx> {\n-    fn ty_localized_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> (&'static str, String) {\n+    fn ty_localized_msg(&self, infcx: &InferCtxt<'tcx>) -> (&'static str, String) {\n         match *self {\n             InferSourceKind::LetBinding { ty, .. }\n             | InferSourceKind::ClosureArg { ty, .. }\n@@ -691,7 +694,7 @@ struct InsertableGenericArgs<'tcx> {\n /// While doing so, the currently best spot is stored in `infer_source`.\n /// For details on how we rank spots, see [Self::source_cost]\n struct FindInferSourceVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     typeck_results: &'a TypeckResults<'tcx>,\n \n     target: GenericArg<'tcx>,\n@@ -703,7 +706,7 @@ struct FindInferSourceVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         typeck_results: &'a TypeckResults<'tcx>,\n         target: GenericArg<'tcx>,\n     ) -> Self {"}, {"sha": "aaf5a7af00afaaa246e491bdc53af45ffec85163", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -1,6 +1,6 @@\n+use crate::infer::error_reporting::TypeErrCtxt;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n-use crate::infer::InferCtxt;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -19,34 +19,34 @@ pub use find_anon_type::find_anon_type;\n pub use static_impl_trait::{suggest_new_region_bound, HirTraitObjectVisitor, TraitObjectVisitor};\n pub use util::find_param_with_region;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n-    pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n+impl<'cx, 'tcx> TypeErrCtxt<'cx, 'tcx> {\n+    pub fn try_report_nice_region_error(&'cx self, error: &RegionResolutionError<'tcx>) -> bool {\n         NiceRegionError::new(self, error.clone()).try_report().is_some()\n     }\n }\n \n pub struct NiceRegionError<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    cx: &'cx TypeErrCtxt<'cx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,\n }\n \n impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>, error: RegionResolutionError<'tcx>) -> Self {\n-        Self { infcx, error: Some(error), regions: None }\n+    pub fn new(cx: &'cx TypeErrCtxt<'cx, 'tcx>, error: RegionResolutionError<'tcx>) -> Self {\n+        Self { cx, error: Some(error), regions: None }\n     }\n \n     pub fn new_from_span(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n+        cx: &'cx TypeErrCtxt<'cx, 'tcx>,\n         span: Span,\n         sub: ty::Region<'tcx>,\n         sup: ty::Region<'tcx>,\n     ) -> Self {\n-        Self { infcx, error: None, regions: Some((span, sub, sup)) }\n+        Self { cx, error: None, regions: Some((span, sub, sup)) }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n+        self.cx.tcx\n     }\n \n     pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {"}, {"sha": "a585168294a29994d116a835796ca451b4bfcbc3", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -226,12 +226,12 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             false\n         };\n \n-        let expected_trait_ref = self.infcx.resolve_vars_if_possible(ty::TraitRef {\n+        let expected_trait_ref = self.cx.resolve_vars_if_possible(ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n         });\n         let actual_trait_ref = self\n-            .infcx\n+            .cx\n             .resolve_vars_if_possible(ty::TraitRef { def_id: trait_def_id, substs: actual_substs });\n \n         // Search the expected and actual trait references to see (a)"}, {"sha": "6bb736687d6e511bb091f1ded49533429f65d264", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             tcx,\n             ctxt.param_env,\n             ctxt.assoc_item.def_id,\n-            self.infcx.resolve_vars_if_possible(ctxt.substs),\n+            self.cx.resolve_vars_if_possible(ctxt.substs),\n         ) else {\n             return false;\n         };"}, {"sha": "5d536e982ed028af28d6cb4b50e3b3f9d96b2cee", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -84,12 +84,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         let expected_highlight = HighlightBuilder::build(self.tcx(), expected);\n         let expected = self\n-            .infcx\n+            .cx\n             .extract_inference_diagnostics_data(expected.into(), Some(expected_highlight))\n             .name;\n         let found_highlight = HighlightBuilder::build(self.tcx(), found);\n         let found =\n-            self.infcx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n+            self.cx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n \n         err.span_label(sp, &format!(\"found `{}`\", found));\n         err.span_label(trait_sp, &format!(\"expected `{}`\", expected));"}, {"sha": "f1461d7010d5b41aab675347de2fa296e200c7a5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let ret_ty = fn_ty.fn_sig(self.tcx()).output();\n             let span = hir_sig.decl.output.span();\n             let future_output = if hir_sig.header.is_async() {\n-                ret_ty.map_bound(|ty| self.infcx.get_impl_future_output_ty(ty)).transpose()\n+                ret_ty.map_bound(|ty| self.cx.get_impl_future_output_ty(ty)).transpose()\n             } else {\n                 None\n             };"}, {"sha": "a04245a23a211942856ef0a2622f8c25feff8c97", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -1,6 +1,6 @@\n use crate::errors::RegionOriginNote;\n-use crate::infer::error_reporting::note_and_explain_region;\n-use crate::infer::{self, InferCtxt, SubregionOrigin};\n+use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n+use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n     fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n };\n@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, Region};\n \n use super::ObligationCauseAsDiagArg;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {"}, {"sha": "ff5d1a05a7062a4c7e6d8faa58e2e96a3c66d138", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -38,7 +38,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVi\n use std::collections::hash_map::Entry;\n \n pub struct TypeFreshener<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     ty_freshen_count: u32,\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n@@ -47,7 +47,7 @@ pub struct TypeFreshener<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>, keep_static: bool) -> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>, keep_static: bool) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,"}, {"sha": "6dd6c4e1f5ee846d54c4fb1ef79d986376266304", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -43,7 +43,7 @@ struct VariableLengths {\n     region_constraints_len: usize,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     fn variable_lengths(&self) -> VariableLengths {\n         let mut inner = self.inner.borrow_mut();\n         VariableLengths {\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n }\n \n pub struct InferenceFudger<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     type_vars: (Range<TyVid>, Vec<TypeVariableOrigin>),\n     int_vars: Range<IntVid>,\n     float_vars: Range<FloatVid>,"}, {"sha": "6ffefcb7a286a5aac0eef3f4db47a26c328ff2ef", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n }\n \n impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx, 'tcx> {\n-    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n+    fn infcx(&self) -> &'infcx InferCtxt<'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "28c87a1159f344e9fda6a8f06c2deab873098a97", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Replaces all bound variables (lifetimes, types, and constants) bound by\n     /// `binder` with placeholder variables in a new universe. This means that the\n     /// new placeholders can only be named by inference variables created after\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn leak_check(\n         &self,\n         overly_polymorphic: bool,\n-        snapshot: &CombinedSnapshot<'_, 'tcx>,\n+        snapshot: &CombinedSnapshot<'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n         // If the user gave `-Zno-leak-check`, or we have been\n         // configured to skip the leak check, then skip the leak check"}, {"sha": "eba65361ae6b2b923ec5e8f100b41e4dc904aea1", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::{self, Ty};\n /// GLB moves \"down\" the lattice (to smaller values); LUB moves\n /// \"up\" the lattice (to bigger values).\n pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n-    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n+    fn infcx(&self) -> &'f InferCtxt<'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n "}, {"sha": "d6e56fcb7fd274d6805654aee0544470d64f92bf", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> ConstEquateRelation<'tcx> for Lub<'_, '_, 'tcx> {\n }\n \n impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx, 'tcx> {\n-    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'tcx> {\n+    fn infcx(&self) -> &'infcx InferCtxt<'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "441dc3c7e888cb486ad78a3c7ace7562bec6c085", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 117, "deletions": 142, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::undo_log::Rollback;\n use rustc_data_structures::unify as ut;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::hir_id::OwnerId;\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n@@ -36,10 +35,11 @@ use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n-use std::cell::{Cell, Ref, RefCell};\n+use std::cell::{Cell, RefCell};\n use std::fmt;\n \n use self::combine::CombineFields;\n+use self::error_reporting::TypeErrCtxt;\n use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n@@ -253,7 +253,7 @@ pub enum DefiningAnchor {\n     Error,\n }\n \n-pub struct InferCtxt<'a, 'tcx> {\n+pub struct InferCtxt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n     /// The `DefId` of the item in whose context we are performing inference or typeck.\n@@ -273,12 +273,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// solving is left to borrowck instead.\n     pub considering_regions: bool,\n \n-    /// During type-checking/inference of a body, `in_progress_typeck_results`\n-    /// contains a reference to the typeck results being built up, which are\n-    /// used for reading closure kinds/signatures as they are inferred,\n-    /// and for error reporting logic to read arbitrary node types.\n-    pub in_progress_typeck_results: Option<&'a RefCell<ty::TypeckResults<'tcx>>>,\n-\n     pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n     /// If set, this flag causes us to skip the 'leak check' during\n@@ -341,7 +335,7 @@ pub struct InferCtxt<'a, 'tcx> {\n     universe: Cell<ty::UniverseIndex>,\n \n     normalize_fn_sig_for_diagnostic:\n-        Option<Lrc<dyn Fn(&InferCtxt<'_, 'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+        Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -552,16 +546,13 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n     }\n }\n \n-/// A temporary returned by `tcx.infer_ctxt()`. This is necessary\n-/// for multiple `InferCtxt` to share the same `in_progress_typeck_results`\n-/// without using `Rc` or something similar.\n+/// Used to configure inference contexts before their creation\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n-    fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     normalize_fn_sig_for_diagnostic:\n-        Option<Lrc<dyn Fn(&InferCtxt<'_, 'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+        Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -574,26 +565,17 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             tcx: self,\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n-            fresh_typeck_results: None,\n             normalize_fn_sig_for_diagnostic: None,\n         }\n     }\n }\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n-    /// Used only by `rustc_hir_analysis` during body type-checking/inference,\n-    /// will initialize `in_progress_typeck_results` with fresh `TypeckResults`.\n-    /// Will also change the scope for opaque type defining use checks to the given owner.\n-    pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: OwnerId) -> Self {\n-        self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));\n-        self.with_opaque_type_inference(DefiningAnchor::Bind(table_owner.def_id))\n-    }\n-\n     /// Whenever the `InferCtxt` should be able to handle defining uses of opaque types,\n     /// you need to call this function. Otherwise the opaque type will be treated opaquely.\n     ///\n     /// It is only meant to be called in two places, for typeck\n-    /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n+    /// (via `Inherited::build`) and for the inference context used\n     /// in mir borrowck.\n     pub fn with_opaque_type_inference(mut self, defining_use_anchor: DefiningAnchor) -> Self {\n         self.defining_use_anchor = defining_use_anchor;\n@@ -607,7 +589,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n \n     pub fn with_normalize_fn_sig_for_diagnostic(\n         mut self,\n-        fun: Lrc<dyn Fn(&InferCtxt<'_, 'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>,\n+        fun: Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>,\n     ) -> Self {\n         self.normalize_fn_sig_for_diagnostic = Some(fun);\n         self\n@@ -620,36 +602,30 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// `V` and a substitution `S`. This substitution `S` maps from\n     /// the bound values in `C` to their instantiated values in `V`\n     /// (in other words, `S(C) = V`).\n-    pub fn enter_with_canonical<T, R>(\n+    pub fn build_with_canonical<T>(\n         &mut self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n-        f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n-    ) -> R\n+    ) -> (InferCtxt<'tcx>, T, CanonicalVarValues<'tcx>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.enter(|infcx| {\n-            let (value, subst) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n-            f(infcx, value, subst)\n-        })\n+        let infcx = self.build();\n+        let (value, subst) = infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n+        (infcx, value, subst)\n     }\n \n-    pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n+    pub fn build(&mut self) -> InferCtxt<'tcx> {\n         let InferCtxtBuilder {\n             tcx,\n             defining_use_anchor,\n             considering_regions,\n-            ref fresh_typeck_results,\n             ref normalize_fn_sig_for_diagnostic,\n         } = *self;\n-        let in_progress_typeck_results = fresh_typeck_results.as_ref();\n-        f(InferCtxt {\n+        InferCtxt {\n             tcx,\n             defining_use_anchor,\n             considering_regions,\n-            in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: Default::default(),\n@@ -664,7 +640,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n-        })\n+        }\n     }\n }\n \n@@ -676,7 +652,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     /// Extracts `value`, registering any obligations into `fulfill_cx`.\n     pub fn into_value_registering_obligations(\n         self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> T {\n         let InferOk { value, obligations } = self;\n@@ -692,15 +668,20 @@ impl<'tcx> InferOk<'tcx, ()> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx> {\n+pub struct CombinedSnapshot<'tcx> {\n     undo_snapshot: Snapshot<'tcx>,\n     region_constraints_snapshot: RegionSnapshot,\n     universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n-    _in_progress_typeck_results: Option<Ref<'a, ty::TypeckResults<'tcx>>>,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n+    /// Creates a `TypeErrCtxt` for emitting various inference errors.\n+    /// During typeck, use `FnCtxt::infer_err` instead.\n+    pub fn err_ctxt(&self) -> TypeErrCtxt<'_, 'tcx> {\n+        TypeErrCtxt { infcx: self, typeck_results: None }\n+    }\n+\n     /// calls `tcx.try_unify_abstract_consts` after\n     /// canonicalizing the consts.\n     #[instrument(skip(self), level = \"debug\")]\n@@ -739,7 +720,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// if this is not a type variable.\n     ///\n     /// No attempt is made to resolve `ty`.\n-    pub fn type_var_origin(&'a self, ty: Ty<'tcx>) -> Option<TypeVariableOrigin> {\n+    pub fn type_var_origin(&self, ty: Ty<'tcx>) -> Option<TypeVariableOrigin> {\n         match *ty.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 Some(*self.inner.borrow_mut().type_variables().var_origin(vid))\n@@ -780,7 +761,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         vars\n     }\n \n-    fn combine_fields(\n+    fn combine_fields<'a>(\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -822,7 +803,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         result\n     }\n \n-    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n+    fn start_snapshot(&self) -> CombinedSnapshot<'tcx> {\n         debug!(\"start_snapshot()\");\n \n         let in_snapshot = self.in_snapshot.replace(true);\n@@ -834,22 +815,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n-            // Borrow typeck results \"in progress\" (i.e., during typeck)\n-            // to ban writes from within a snapshot to them.\n-            _in_progress_typeck_results: self\n-                .in_progress_typeck_results\n-                .map(|typeck_results| typeck_results.borrow()),\n         }\n     }\n \n     #[instrument(skip(self, snapshot), level = \"debug\")]\n-    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'tcx>) {\n         let CombinedSnapshot {\n             undo_snapshot,\n             region_constraints_snapshot,\n             universe,\n             was_in_snapshot,\n-            _in_progress_typeck_results,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n@@ -861,13 +836,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self, snapshot), level = \"debug\")]\n-    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n+    fn commit_from(&self, snapshot: CombinedSnapshot<'tcx>) {\n         let CombinedSnapshot {\n             undo_snapshot,\n             region_constraints_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n-            _in_progress_typeck_results,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n@@ -879,7 +853,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self, f), level = \"debug\")]\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n+        F: FnOnce(&CombinedSnapshot<'tcx>) -> Result<T, E>,\n     {\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n@@ -899,7 +873,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self, f), level = \"debug\")]\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+        F: FnOnce(&CombinedSnapshot<'tcx>) -> R,\n     {\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n@@ -911,7 +885,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self, f), level = \"debug\")]\n     pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n     where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+        F: FnOnce(&CombinedSnapshot<'tcx>) -> R,\n     {\n         let snapshot = self.start_snapshot();\n         let was_skip_leak_check = self.skip_leak_check.get();\n@@ -931,15 +905,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n     pub fn region_constraints_added_in_snapshot(\n         &self,\n-        snapshot: &CombinedSnapshot<'a, 'tcx>,\n+        snapshot: &CombinedSnapshot<'tcx>,\n     ) -> Option<bool> {\n         self.inner\n             .borrow_mut()\n             .unwrap_region_constraints()\n             .region_constraints_added_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n-    pub fn opaque_types_added_in_snapshot(&self, snapshot: &CombinedSnapshot<'a, 'tcx>) -> bool {\n+    pub fn opaque_types_added_in_snapshot(&self, snapshot: &CombinedSnapshot<'tcx>) -> bool {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n@@ -1343,32 +1317,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         errors\n     }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    ///\n-    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`InferCtxt::check_region_obligations_and_report_errors`]\n-    /// to do both of these operations together.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        let errors = self.resolve_regions(outlives_env);\n-\n-        if !self.is_tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use.  This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(generic_param_scope, &errors);\n-        }\n-    }\n-\n     /// Obtains (and clears) the current set of region\n     /// constraints. The inference context is still usable: further\n     /// unifications will simply add new constraints.\n@@ -1524,59 +1472,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         resolve::fully_resolve(self, value)\n     }\n \n-    // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is Error (the special\n-    // error type, meaning that an error occurred when typechecking this expression),\n-    // this is a derived error. The error cascaded from another error (that was already\n-    // reported), so it's not useful to display it to the user.\n-    // The following methods implement this logic.\n-    // They check if either the actual or expected type is Error, and don't print the error\n-    // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these methods, and should not call span_err directly for such\n-    // errors.\n-\n-    pub fn type_error_struct_with_diag<M>(\n-        &self,\n-        sp: Span,\n-        mk_diag: M,\n-        actual_ty: Ty<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>\n-    where\n-        M: FnOnce(String) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n-    {\n-        let actual_ty = self.resolve_vars_if_possible(actual_ty);\n-        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n-\n-        let mut err = mk_diag(self.ty_to_string(actual_ty));\n-\n-        // Don't report an error if actual type is `Error`.\n-        if actual_ty.references_error() {\n-            err.downgrade_to_delayed_bug();\n-        }\n-\n-        err\n-    }\n-\n-    pub fn report_mismatched_types(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        self.report_and_explain_type_error(TypeTrace::types(cause, true, expected, actual), err)\n-    }\n-\n-    pub fn report_mismatched_consts(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        expected: ty::Const<'tcx>,\n-        actual: ty::Const<'tcx>,\n-        err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        self.report_and_explain_type_error(TypeTrace::consts(cause, true, expected, actual), err)\n-    }\n-\n     pub fn replace_bound_vars_with_fresh_vars<T>(\n         &self,\n         span: Span,\n@@ -1591,7 +1486,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         struct ToFreshVars<'a, 'tcx> {\n-            infcx: &'a InferCtxt<'a, 'tcx>,\n+            infcx: &'a InferCtxt<'tcx>,\n             span: Span,\n             lbrct: LateBoundRegionConversionTime,\n             map: FxHashMap<ty::BoundVar, ty::GenericArg<'tcx>>,\n@@ -1816,6 +1711,86 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Process the region constraints and report any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    ///\n+    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n+    /// first, or preferably use [`InferCtxt::check_region_obligations_and_report_errors`]\n+    /// to do both of these operations together.\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) {\n+        let errors = self.resolve_regions(outlives_env);\n+\n+        if !self.is_tainted_by_errors() {\n+            // As a heuristic, just skip reporting region errors\n+            // altogether if other errors have been reported while\n+            // this infcx was in use.  This is totally hokey but\n+            // otherwise we have a hard time separating legit region\n+            // errors from silly ones.\n+            self.report_region_errors(generic_param_scope, &errors);\n+        }\n+    }\n+\n+    // [Note-Type-error-reporting]\n+    // An invariant is that anytime the expected or actual type is Error (the special\n+    // error type, meaning that an error occurred when typechecking this expression),\n+    // this is a derived error. The error cascaded from another error (that was already\n+    // reported), so it's not useful to display it to the user.\n+    // The following methods implement this logic.\n+    // They check if either the actual or expected type is Error, and don't print the error\n+    // in this case. The typechecker should only ever report type errors involving mismatched\n+    // types using one of these methods, and should not call span_err directly for such\n+    // errors.\n+\n+    pub fn type_error_struct_with_diag<M>(\n+        &self,\n+        sp: Span,\n+        mk_diag: M,\n+        actual_ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>\n+    where\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+    {\n+        let actual_ty = self.resolve_vars_if_possible(actual_ty);\n+        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n+\n+        let mut err = mk_diag(self.ty_to_string(actual_ty));\n+\n+        // Don't report an error if actual type is `Error`.\n+        if actual_ty.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n+        err\n+    }\n+\n+    pub fn report_mismatched_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        self.report_and_explain_type_error(TypeTrace::types(cause, true, expected, actual), err)\n+    }\n+\n+    pub fn report_mismatched_consts(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: ty::Const<'tcx>,\n+        actual: ty::Const<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        self.report_and_explain_type_error(TypeTrace::consts(cause, true, expected, actual), err)\n+    }\n+}\n+\n /// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n /// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n #[derive(Copy, Clone, Debug)]\n@@ -1885,7 +1860,7 @@ impl<'tcx> TypeFolder<'tcx> for InferenceLiteralEraser<'tcx> {\n }\n \n struct ShallowResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {"}, {"sha": "7c186ae947065f3e9a7e5db12566eab6b4946e36", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -44,7 +44,7 @@ pub struct TypeRelating<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n+    infcx: &'me InferCtxt<'tcx>,\n \n     /// Callback to use when we deduce an outlives relationship.\n     delegate: D,\n@@ -149,11 +149,7 @@ impl<'me, 'tcx, D> TypeRelating<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    pub fn new(\n-        infcx: &'me InferCtxt<'me, 'tcx>,\n-        delegate: D,\n-        ambient_variance: ty::Variance,\n-    ) -> Self {\n+    pub fn new(infcx: &'me InferCtxt<'tcx>, delegate: D, ambient_variance: ty::Variance) -> Self {\n         Self {\n             infcx,\n             delegate,\n@@ -867,7 +863,7 @@ struct TypeGeneralizer<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n+    infcx: &'me InferCtxt<'tcx>,\n \n     delegate: &'me mut D,\n "}, {"sha": "77e8f72aefac09a9e8f2b9f522d548c34b5689db", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -41,7 +41,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     pub origin: hir::OpaqueTyOrigin,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// This is a backwards compatibility hack to prevent breaking changes from\n     /// lazy TAIT around RPIT handling.\n     pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<'tcx>>(\n@@ -511,7 +511,7 @@ impl UseKind {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn register_hidden_type(\n         &self,"}, {"sha": "33543135ddb0ef68a3f3a92369ca3b629a6d948c", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -87,9 +87,9 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n-    pub fn with_bounds<'a>(\n+    pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n-        infcx: Option<&InferCtxt<'a, 'tcx>>,\n+        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n@@ -108,7 +108,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n+impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     #[inline]\n     #[instrument(level = \"debug\")]\n     fn build(self) -> OutlivesEnvironment<'tcx> {\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     /// contain inference variables, it must be supplied, in which\n     /// case we will register \"givens\" on the inference context. (See\n     /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'a, 'tcx>>, outlives_bounds: I)\n+    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {"}, {"sha": "6ca884799aa6fb3b77b5891c6ff20175f9aab922", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -75,7 +75,7 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Registers that the given region obligation must be resolved\n     /// from within the scope of `body_id`. These regions are enqueued\n     /// and later processed by regionck, when full type information is\n@@ -183,7 +183,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             outlives_env.param_env,\n         );\n \n-        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n+        self.err_ctxt().resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n     }\n }\n \n@@ -523,7 +523,7 @@ where\n     }\n }\n \n-impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {\n+impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'tcx> {\n     fn push_sub_region_constraint(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,"}, {"sha": "9f12bc972a816d1e939405a66f9d1d4c200d13cd", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -6,7 +6,7 @@ use crate::traits::{Obligation, PredicateObligation};\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     /// Instead of normalizing an associated type projection,\n     /// this function generates an inference variable and registers\n     /// an obligation that this inference variable must be the result"}, {"sha": "90858e3072ac028db31427fd05cbf69889086570", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         overly_polymorphic: bool,\n         max_universe: ty::UniverseIndex,\n-        snapshot: &CombinedSnapshot<'_, 'tcx>,\n+        snapshot: &CombinedSnapshot<'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n         debug!(\n             \"leak_check(max_universe={:?}, snapshot.universe={:?}, overly_polymorphic={:?})\","}, {"sha": "069f96000918faf082b30f5d44be94e9f4a1c5ae", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -16,12 +16,12 @@ use std::ops::ControlFlow;\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n pub struct OpportunisticVarResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> OpportunisticVarResolver<'a, 'tcx> {\n     #[inline]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n         OpportunisticVarResolver { infcx }\n     }\n }\n@@ -62,11 +62,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n /// If you want to resolve type and const variables as well, call\n /// [InferCtxt::resolve_vars_if_possible] first.\n pub struct OpportunisticRegionResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> OpportunisticRegionResolver<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n         OpportunisticRegionResolver { infcx }\n     }\n }\n@@ -116,11 +116,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n /// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n pub struct UnresolvedTypeFinder<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n         UnresolvedTypeFinder { infcx }\n     }\n }\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: T) -> FixupResult<'tcx, T>\n+pub fn fully_resolve<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> FixupResult<'tcx, T>\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -177,7 +177,7 @@ where\n // N.B. This type is not public because the protocol around checking the\n // `err` field is not enforceable otherwise.\n struct FullTypeResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> FallibleTypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {"}, {"sha": "a4b55dfa691df9a35346731228aa9a9a51d25a22", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -12,8 +12,8 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'combine, 'infcx, 'tcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'tcx>,\n+pub struct Sub<'combine, 'a, 'tcx> {\n+    fields: &'combine mut CombineFields<'a, 'tcx>,\n     a_is_expected: bool,\n }\n "}, {"sha": "b2b985a22ac0147f4fc6abd855142bd2fac93938", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -10,7 +10,7 @@ use super::{ObligationCause, PredicateObligation};\n pub trait TraitEngine<'tcx>: 'tcx {\n     fn normalize_projection_type(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n@@ -21,7 +21,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     /// parameters (except for `Self`).\n     fn register_bound(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n@@ -41,14 +41,13 @@ pub trait TraitEngine<'tcx>: 'tcx {\n \n     fn register_predicate_obligation(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     );\n \n-    fn select_all_or_error(&mut self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<FulfillmentError<'tcx>>;\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n-    fn select_where_possible(&mut self, infcx: &InferCtxt<'_, 'tcx>)\n-    -> Vec<FulfillmentError<'tcx>>;\n+    fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n \n@@ -58,15 +57,15 @@ pub trait TraitEngine<'tcx>: 'tcx {\n pub trait TraitEngineExt<'tcx> {\n     fn register_predicate_obligations(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     );\n }\n \n impl<'tcx, T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n     fn register_predicate_obligations(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     ) {\n         for obligation in obligations {"}, {"sha": "f8b5009a58d4bf9acf2506fab24b038a39fdce76", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -10,7 +10,7 @@ use rustc_span::Span;\n use std::fmt;\n use std::iter;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxt<'tcx> {\n     pub fn report_extra_impl_obligation(\n         &self,\n         error_span: Span,"}, {"sha": "886b686e5e8d885dcddbdf659264b05c2eab29fa", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -151,21 +151,19 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 Some(ty_def) if cx.tcx.is_diagnostic_item(sym::String, ty_def.did()),\n             );\n \n-            let (suggest_display, suggest_debug) = cx.tcx.infer_ctxt().enter(|infcx| {\n-                let display = is_str\n-                    || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n-                        infcx\n-                            .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n-                            .may_apply()\n-                    }) == Some(true);\n-                let debug = !display\n-                    && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n-                        infcx\n-                            .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n-                            .may_apply()\n-                    }) == Some(true);\n-                (display, debug)\n-            });\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            let suggest_display = is_str\n+                || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n+                    infcx\n+                        .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n+                        .may_apply()\n+                }) == Some(true);\n+            let suggest_debug = !suggest_display\n+                && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n+                    infcx\n+                        .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n+                        .may_apply()\n+                }) == Some(true);\n \n             let suggest_panic_any = !is_str && panic == sym::std_panic_macro;\n "}, {"sha": "81b9f55e7033aceffab179cc9789213e73aed64e", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -62,85 +62,81 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n         let def_id = item.def_id.def_id.to_def_id();\n-        cx.tcx.infer_ctxt().enter(|ref infcx| {\n-            // For every projection predicate in the opaque type's explicit bounds,\n-            // check that the type that we're assigning actually satisfies the bounds\n-            // of the associated type.\n-            for &(pred, pred_span) in cx.tcx.explicit_item_bounds(def_id) {\n-                // Liberate bound regions in the predicate since we\n-                // don't actually care about lifetimes in this check.\n-                let predicate = cx.tcx.liberate_late_bound_regions(\n-                    def_id,\n-                    pred.kind(),\n-                );\n-                let ty::PredicateKind::Projection(proj) = predicate else {\n-                    continue;\n-                };\n-                // Only check types, since those are the only things that may\n-                // have opaques in them anyways.\n-                let Some(proj_term) = proj.term.ty() else { continue };\n+        let infcx = &cx.tcx.infer_ctxt().build();\n+        // For every projection predicate in the opaque type's explicit bounds,\n+        // check that the type that we're assigning actually satisfies the bounds\n+        // of the associated type.\n+        for &(pred, pred_span) in cx.tcx.explicit_item_bounds(def_id) {\n+            // Liberate bound regions in the predicate since we\n+            // don't actually care about lifetimes in this check.\n+            let predicate = cx.tcx.liberate_late_bound_regions(def_id, pred.kind());\n+            let ty::PredicateKind::Projection(proj) = predicate else {\n+                continue;\n+            };\n+            // Only check types, since those are the only things that may\n+            // have opaques in them anyways.\n+            let Some(proj_term) = proj.term.ty() else { continue };\n \n-                let proj_ty =\n-                    cx\n-                    .tcx\n-                    .mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n-                // For every instance of the projection type in the bounds,\n-                // replace them with the term we're assigning to the associated\n-                // type in our opaque type.\n-                let proj_replacer = &mut BottomUpFolder {\n-                    tcx: cx.tcx,\n-                    ty_op: |ty| if ty == proj_ty { proj_term } else { ty },\n-                    lt_op: |lt| lt,\n-                    ct_op: |ct| ct,\n+            let proj_ty =\n+                cx.tcx.mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n+            // For every instance of the projection type in the bounds,\n+            // replace them with the term we're assigning to the associated\n+            // type in our opaque type.\n+            let proj_replacer = &mut BottomUpFolder {\n+                tcx: cx.tcx,\n+                ty_op: |ty| if ty == proj_ty { proj_term } else { ty },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            };\n+            // For example, in `impl Trait<Assoc = impl Send>`, for all of the bounds on `Assoc`,\n+            // e.g. `type Assoc: OtherTrait`, replace `<impl Trait as Trait>::Assoc: OtherTrait`\n+            // with `impl Send: OtherTrait`.\n+            for assoc_pred_and_span in\n+                cx.tcx.bound_explicit_item_bounds(proj.projection_ty.item_def_id).transpose_iter()\n+            {\n+                let assoc_pred_span = assoc_pred_and_span.0.1;\n+                let assoc_pred = assoc_pred_and_span\n+                    .map_bound(|(pred, _)| *pred)\n+                    .subst(cx.tcx, &proj.projection_ty.substs)\n+                    .fold_with(proj_replacer);\n+                let Ok(assoc_pred) = traits::fully_normalize(infcx, traits::ObligationCause::dummy(), cx.param_env, assoc_pred) else {\n+                    continue;\n                 };\n-                // For example, in `impl Trait<Assoc = impl Send>`, for all of the bounds on `Assoc`,\n-                // e.g. `type Assoc: OtherTrait`, replace `<impl Trait as Trait>::Assoc: OtherTrait`\n-                // with `impl Send: OtherTrait`.\n-                for assoc_pred_and_span in cx\n-                    .tcx\n-                    .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n-                    .transpose_iter()\n-                {\n-                    let assoc_pred_span = assoc_pred_and_span.0.1;\n-                    let assoc_pred = assoc_pred_and_span\n-                        .map_bound(|(pred, _)| *pred)\n-                        .subst(cx.tcx, &proj.projection_ty.substs)\n-                        .fold_with(proj_replacer);\n-                    let Ok(assoc_pred) = traits::fully_normalize(infcx, traits::ObligationCause::dummy(), cx.param_env, assoc_pred) else {\n-                        continue;\n+                // If that predicate doesn't hold modulo regions (but passed during type-check),\n+                // then we must've taken advantage of the hack in `project_and_unify_types` where\n+                // we replace opaques with inference vars. Emit a warning!\n+                if !infcx.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n+                    traits::ObligationCause::dummy(),\n+                    cx.param_env,\n+                    assoc_pred,\n+                )) {\n+                    // If it's a trait bound and an opaque that doesn't satisfy it,\n+                    // then we can emit a suggestion to add the bound.\n+                    let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n+                        (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => {\n+                            Some(AddBound {\n+                                suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n+                                trait_ref: trait_pred.print_modifiers_and_trait_path(),\n+                            })\n+                        }\n+                        _ => None,\n                     };\n-                    // If that predicate doesn't hold modulo regions (but passed during type-check),\n-                    // then we must've taken advantage of the hack in `project_and_unify_types` where\n-                    // we replace opaques with inference vars. Emit a warning!\n-                    if !infcx.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n-                        traits::ObligationCause::dummy(),\n-                        cx.param_env,\n-                        assoc_pred,\n-                    )) {\n-                        // If it's a trait bound and an opaque that doesn't satisfy it,\n-                        // then we can emit a suggestion to add the bound.\n-                        let add_bound =\n-                            match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n-                                (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => Some(AddBound {\n-                                    suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n-                                    trait_ref: trait_pred.print_modifiers_and_trait_path(),\n-                                }),\n-                                _ => None,\n-                            };\n-                        cx.emit_spanned_lint(\n-                            OPAQUE_HIDDEN_INFERRED_BOUND,\n-                            pred_span,\n-                            OpaqueHiddenInferredBoundLint {\n-                                ty: cx.tcx.mk_opaque(def_id, ty::InternalSubsts::identity_for_item(cx.tcx, def_id)),\n-                                proj_ty: proj_term,\n-                                assoc_pred_span,\n-                                add_bound,\n-                            },\n-                        );\n-                    }\n+                    cx.emit_spanned_lint(\n+                        OPAQUE_HIDDEN_INFERRED_BOUND,\n+                        pred_span,\n+                        OpaqueHiddenInferredBoundLint {\n+                            ty: cx.tcx.mk_opaque(\n+                                def_id,\n+                                ty::InternalSubsts::identity_for_item(cx.tcx, def_id),\n+                            ),\n+                            proj_ty: proj_term,\n+                            assoc_pred_span,\n+                            add_bound,\n+                        },\n+                    );\n                 }\n             }\n-        });\n+        }\n     }\n }\n "}, {"sha": "cbcf9cd129f3f76c8886127cd9c10a167670c0de", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 63, "deletions": 69, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -157,7 +157,7 @@ struct BlockContext(Vec<BlockFrame>);\n \n struct Builder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    infcx: InferCtxt<'a, 'tcx>,\n+    infcx: InferCtxt<'tcx>,\n     typeck_results: &'tcx TypeckResults<'tcx>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -481,54 +481,49 @@ fn construct_fn<'tcx>(\n         (None, fn_sig.output())\n     };\n \n-    let mut body = tcx.infer_ctxt().enter(|infcx| {\n-        let mut builder = Builder::new(\n-            thir,\n-            infcx,\n-            fn_def,\n-            fn_id,\n-            span_with_body,\n-            arguments.len(),\n-            safety,\n-            return_ty,\n-            return_ty_span,\n-            generator_kind,\n-        );\n+    let infcx = tcx.infer_ctxt().build();\n+    let mut builder = Builder::new(\n+        thir,\n+        infcx,\n+        fn_def,\n+        fn_id,\n+        span_with_body,\n+        arguments.len(),\n+        safety,\n+        return_ty,\n+        return_ty_span,\n+        generator_kind,\n+    );\n \n-        let call_site_scope =\n-            region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::CallSite };\n-        let arg_scope =\n-            region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::Arguments };\n-        let source_info = builder.source_info(span);\n-        let call_site_s = (call_site_scope, source_info);\n-        unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n-            let arg_scope_s = (arg_scope, source_info);\n-            // Attribute epilogue to function's closing brace\n-            let fn_end = span_with_body.shrink_to_hi();\n-            let return_block = unpack!(builder.in_breakable_scope(\n-                None,\n-                Place::return_place(),\n-                fn_end,\n-                |builder| {\n-                    Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                        builder.args_and_body(\n-                            START_BLOCK,\n-                            fn_def.did,\n-                            arguments,\n-                            arg_scope,\n-                            &thir[expr],\n-                        )\n-                    }))\n-                }\n-            ));\n-            let source_info = builder.source_info(fn_end);\n-            builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-            builder.build_drop_trees();\n-            return_block.unit()\n-        }));\n-\n-        builder.finish()\n-    });\n+    let call_site_scope =\n+        region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::CallSite };\n+    let arg_scope =\n+        region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::Arguments };\n+    let source_info = builder.source_info(span);\n+    let call_site_s = (call_site_scope, source_info);\n+    unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n+        let arg_scope_s = (arg_scope, source_info);\n+        // Attribute epilogue to function's closing brace\n+        let fn_end = span_with_body.shrink_to_hi();\n+        let return_block =\n+            unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n+                Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n+                    builder.args_and_body(\n+                        START_BLOCK,\n+                        fn_def.did,\n+                        arguments,\n+                        arg_scope,\n+                        &thir[expr],\n+                    )\n+                }))\n+            }));\n+        let source_info = builder.source_info(fn_end);\n+        builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n+        builder.build_drop_trees();\n+        return_block.unit()\n+    }));\n+\n+    let mut body = builder.finish();\n \n     body.spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n@@ -584,30 +579,29 @@ fn construct_const<'a, 'tcx>(\n     let typeck_results = tcx.typeck_opt_const_arg(def);\n     let const_ty = typeck_results.node_type(hir_id);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut builder = Builder::new(\n-            thir,\n-            infcx,\n-            def,\n-            hir_id,\n-            span,\n-            0,\n-            Safety::Safe,\n-            const_ty,\n-            const_ty_span,\n-            None,\n-        );\n+    let infcx = tcx.infer_ctxt().build();\n+    let mut builder = Builder::new(\n+        thir,\n+        infcx,\n+        def,\n+        hir_id,\n+        span,\n+        0,\n+        Safety::Safe,\n+        const_ty,\n+        const_ty_span,\n+        None,\n+    );\n \n-        let mut block = START_BLOCK;\n-        unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n+    let mut block = START_BLOCK;\n+    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n \n-        let source_info = builder.source_info(span);\n-        builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n+    let source_info = builder.source_info(span);\n+    builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n \n-        builder.build_drop_trees();\n+    builder.build_drop_trees();\n \n-        builder.finish()\n-    })\n+    builder.finish()\n }\n \n /// Construct MIR for an item that has had errors in type checking.\n@@ -683,7 +677,7 @@ fn construct_error<'tcx>(\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n         thir: &'a Thir<'tcx>,\n-        infcx: InferCtxt<'a, 'tcx>,\n+        infcx: InferCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n         hir_id: hir::HirId,\n         span: Span,"}, {"sha": "cf8ae776be969ce8d4812ebe089ed273e229d40f", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -28,14 +28,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         span: Span,\n         mir_structural_match_violation: bool,\n     ) -> Box<Pat<'tcx>> {\n-        self.tcx.infer_ctxt().enter(|infcx| {\n-            let mut convert = ConstToPat::new(self, id, span, infcx);\n-            convert.to_pat(cv, mir_structural_match_violation)\n-        })\n+        let infcx = self.tcx.infer_ctxt().build();\n+        let mut convert = ConstToPat::new(self, id, span, infcx);\n+        convert.to_pat(cv, mir_structural_match_violation)\n     }\n }\n \n-struct ConstToPat<'a, 'tcx> {\n+struct ConstToPat<'tcx> {\n     id: hir::HirId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -55,7 +54,7 @@ struct ConstToPat<'a, 'tcx> {\n     behind_reference: Cell<bool>,\n \n     // inference context used for checking `T: Structural` bounds.\n-    infcx: InferCtxt<'a, 'tcx>,\n+    infcx: InferCtxt<'tcx>,\n \n     include_lint_checks: bool,\n \n@@ -71,21 +70,19 @@ mod fallback_to_const_ref {\n     /// hoops to get a reference to the value.\n     pub(super) struct FallbackToConstRef(());\n \n-    pub(super) fn fallback_to_const_ref<'a, 'tcx>(\n-        c2p: &super::ConstToPat<'a, 'tcx>,\n-    ) -> FallbackToConstRef {\n+    pub(super) fn fallback_to_const_ref<'tcx>(c2p: &super::ConstToPat<'tcx>) -> FallbackToConstRef {\n         assert!(c2p.behind_reference.get());\n         FallbackToConstRef(())\n     }\n }\n use fallback_to_const_ref::{fallback_to_const_ref, FallbackToConstRef};\n \n-impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n+impl<'tcx> ConstToPat<'tcx> {\n     fn new(\n         pat_ctxt: &PatCtxt<'_, 'tcx>,\n         id: hir::HirId,\n         span: Span,\n-        infcx: InferCtxt<'a, 'tcx>,\n+        infcx: InferCtxt<'tcx>,\n     ) -> Self {\n         trace!(?pat_ctxt.typeck_results.hir_owner);\n         ConstToPat {"}, {"sha": "61cfeec4bbb6ef5301569304686a760010306df9", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -25,7 +25,7 @@ struct AutoderefSnapshot<'tcx> {\n \n pub struct Autoderef<'a, 'tcx> {\n     // Meta infos:\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     span: Span,\n     overloaded_span: Span,\n     body_id: hir::HirId,\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n \n impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     pub fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n         span: Span,"}, {"sha": "1b58c9b864e4265386b13828038ee7c786a7d9cc", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -59,7 +59,7 @@ pub trait InferCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> traits::EvaluationResult;\n }\n-impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     fn type_is_copy_modulo_regions(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -142,7 +142,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n@@ -170,25 +170,17 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n-        self.enter_with_canonical(\n-            DUMMY_SP,\n-            canonical_key,\n-            |ref infcx, key, canonical_inference_vars| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                let value = operation(infcx, &mut *fulfill_cx, key)?;\n-                infcx.make_canonicalized_query_response(\n-                    canonical_inference_vars,\n-                    value,\n-                    &mut *fulfill_cx,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, canonical_inference_vars) =\n+            self.build_with_canonical(DUMMY_SP, canonical_key);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        let value = operation(infcx, &mut *fulfill_cx, key)?;\n+        infcx.make_canonicalized_query_response(canonical_inference_vars, value, &mut *fulfill_cx)\n     }\n }"}, {"sha": "c716c4b0be9051a6dddbd99b68ca83ceed1a2bce", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 93, "deletions": 131, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -10,7 +10,7 @@ use crate::traits::project::ProjectAndUnifyResult;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{Region, RegionVid};\n+use rustc_middle::ty::{PolyTraitRef, Region, RegionVid};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n@@ -90,143 +90,105 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n         let trait_pred = ty::Binder::dummy(trait_ref);\n \n-        let bail_out = tcx.infer_ctxt().enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let result = selcx.select(&Obligation::new(\n-                ObligationCause::dummy(),\n-                orig_env,\n-                trait_pred.to_poly_trait_predicate(),\n-            ));\n-\n-            match result {\n-                Ok(Some(ImplSource::UserDefined(_))) => {\n-                    debug!(\n-                        \"find_auto_trait_generics({:?}): \\\n-                         manual impl found, bailing out\",\n-                        trait_ref\n-                    );\n-                    return true;\n-                }\n-                _ => {}\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        for f in [\n+            PolyTraitRef::to_poly_trait_predicate,\n+            PolyTraitRef::to_poly_trait_predicate_negative_polarity,\n+        ] {\n+            let result =\n+                selcx.select(&Obligation::new(ObligationCause::dummy(), orig_env, f(&trait_pred)));\n+            if let Ok(Some(ImplSource::UserDefined(_))) = result {\n+                debug!(\n+                    \"find_auto_trait_generics({:?}): \\\n+                 manual impl found, bailing out\",\n+                    trait_ref\n+                );\n+                // If an explicit impl exists, it always takes priority over an auto impl\n+                return AutoTraitResult::ExplicitImpl;\n             }\n-\n-            let result = selcx.select(&Obligation::new(\n-                ObligationCause::dummy(),\n-                orig_env,\n-                trait_pred.to_poly_trait_predicate_negative_polarity(),\n-            ));\n-\n-            match result {\n-                Ok(Some(ImplSource::UserDefined(_))) => {\n-                    debug!(\n-                        \"find_auto_trait_generics({:?}): \\\n-                         manual impl found, bailing out\",\n-                        trait_ref\n-                    );\n-                    true\n-                }\n-                _ => false,\n-            }\n-        });\n-\n-        // If an explicit impl exists, it always takes priority over an auto impl\n-        if bail_out {\n-            return AutoTraitResult::ExplicitImpl;\n         }\n \n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut fresh_preds = FxHashSet::default();\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut fresh_preds = FxHashSet::default();\n+\n+        // Due to the way projections are handled by SelectionContext, we need to run\n+        // evaluate_predicates twice: once on the original param env, and once on the result of\n+        // the first evaluate_predicates call.\n+        //\n+        // The problem is this: most of rustc, including SelectionContext and traits::project,\n+        // are designed to work with a concrete usage of a type (e.g., Vec<u8>\n+        // fn<T>() { Vec<T> }. This information will generally never change - given\n+        // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n+        // If we're unable to prove that 'T' implements a particular trait, we're done -\n+        // there's nothing left to do but error out.\n+        //\n+        // However, synthesizing an auto trait impl works differently. Here, we start out with\n+        // a set of initial conditions - the ParamEnv of the struct/enum/union we're dealing\n+        // with - and progressively discover the conditions we need to fulfill for it to\n+        // implement a certain auto trait. This ends up breaking two assumptions made by trait\n+        // selection and projection:\n+        //\n+        // * We can always cache the result of a particular trait selection for the lifetime of\n+        // an InfCtxt\n+        // * Given a projection bound such as '<T as SomeTrait>::SomeItem = K', if 'T:\n+        // SomeTrait' doesn't hold, then we don't need to care about the 'SomeItem = K'\n+        //\n+        // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n+        // in between calls to SelectionContext.select. This allows us to keep all of the\n+        // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n+        // them between calls.\n+        //\n+        // We fix the second assumption by reprocessing the result of our first call to\n+        // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n+        // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,\n+        // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n+        // SelectionContext to return it back to us.\n+\n+        let Some((new_env, user_env)) = self.evaluate_predicates(\n+            &infcx,\n+            trait_did,\n+            ty,\n+            orig_env,\n+            orig_env,\n+            &mut fresh_preds,\n+            false,\n+        ) else {\n+            return AutoTraitResult::NegativeImpl;\n+        };\n+\n+        let (full_env, full_user_env) = self\n+            .evaluate_predicates(&infcx, trait_did, ty, new_env, user_env, &mut fresh_preds, true)\n+            .unwrap_or_else(|| {\n+                panic!(\"Failed to fully process: {:?} {:?} {:?}\", ty, trait_did, orig_env)\n+            });\n \n-            // Due to the way projections are handled by SelectionContext, we need to run\n-            // evaluate_predicates twice: once on the original param env, and once on the result of\n-            // the first evaluate_predicates call.\n-            //\n-            // The problem is this: most of rustc, including SelectionContext and traits::project,\n-            // are designed to work with a concrete usage of a type (e.g., Vec<u8>\n-            // fn<T>() { Vec<T> }. This information will generally never change - given\n-            // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n-            // If we're unable to prove that 'T' implements a particular trait, we're done -\n-            // there's nothing left to do but error out.\n-            //\n-            // However, synthesizing an auto trait impl works differently. Here, we start out with\n-            // a set of initial conditions - the ParamEnv of the struct/enum/union we're dealing\n-            // with - and progressively discover the conditions we need to fulfill for it to\n-            // implement a certain auto trait. This ends up breaking two assumptions made by trait\n-            // selection and projection:\n-            //\n-            // * We can always cache the result of a particular trait selection for the lifetime of\n-            // an InfCtxt\n-            // * Given a projection bound such as '<T as SomeTrait>::SomeItem = K', if 'T:\n-            // SomeTrait' doesn't hold, then we don't need to care about the 'SomeItem = K'\n-            //\n-            // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n-            // in between calls to SelectionContext.select. This allows us to keep all of the\n-            // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n-            // them between calls.\n-            //\n-            // We fix the second assumption by reprocessing the result of our first call to\n-            // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n-            // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,\n-            // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n-            // SelectionContext to return it back to us.\n-\n-            let Some((new_env, user_env)) = self.evaluate_predicates(\n-                &infcx,\n-                trait_did,\n-                ty,\n-                orig_env,\n-                orig_env,\n-                &mut fresh_preds,\n-                false,\n-            ) else {\n-                return AutoTraitResult::NegativeImpl;\n-            };\n-\n-            let (full_env, full_user_env) = self\n-                .evaluate_predicates(\n-                    &infcx,\n-                    trait_did,\n-                    ty,\n-                    new_env,\n-                    user_env,\n-                    &mut fresh_preds,\n-                    true,\n-                )\n-                .unwrap_or_else(|| {\n-                    panic!(\"Failed to fully process: {:?} {:?} {:?}\", ty, trait_did, orig_env)\n-                });\n-\n-            debug!(\n-                \"find_auto_trait_generics({:?}): fulfilling \\\n-                 with {:?}\",\n-                trait_ref, full_env\n-            );\n-            infcx.clear_caches();\n-\n-            // At this point, we already have all of the bounds we need. FulfillmentContext is used\n-            // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n-            // an additional sanity check.\n-            let errors =\n-                super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n-            if !errors.is_empty() {\n-                panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n-            }\n+        debug!(\n+            \"find_auto_trait_generics({:?}): fulfilling \\\n+             with {:?}\",\n+            trait_ref, full_env\n+        );\n+        infcx.clear_caches();\n+\n+        // At this point, we already have all of the bounds we need. FulfillmentContext is used\n+        // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n+        // an additional sanity check.\n+        let errors =\n+            super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n+        if !errors.is_empty() {\n+            panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n+        }\n \n-            infcx.process_registered_region_obligations(&Default::default(), full_env);\n+        infcx.process_registered_region_obligations(&Default::default(), full_env);\n \n-            let region_data = infcx\n-                .inner\n-                .borrow_mut()\n-                .unwrap_region_constraints()\n-                .region_constraint_data()\n-                .clone();\n+        let region_data =\n+            infcx.inner.borrow_mut().unwrap_region_constraints().region_constraint_data().clone();\n \n-            let vid_to_region = self.map_vid_to_region(&region_data);\n+        let vid_to_region = self.map_vid_to_region(&region_data);\n \n-            let info = AutoTraitInfo { full_user_env, region_data, vid_to_region };\n+        let info = AutoTraitInfo { full_user_env, region_data, vid_to_region };\n \n-            AutoTraitResult::PositiveImpl(auto_trait_callback(info))\n-        })\n+        AutoTraitResult::PositiveImpl(auto_trait_callback(info))\n     }\n }\n \n@@ -272,7 +234,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     /// user.\n     fn evaluate_predicates(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         trait_did: DefId,\n         ty: Ty<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -877,7 +839,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n     pub fn clean_pred(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         p: ty::Predicate<'tcx>,\n     ) -> ty::Predicate<'tcx> {\n         infcx.freshen(p)"}, {"sha": "81e1d64493e14f3e84e497865ad19e9a27b2e725", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -28,7 +28,7 @@ impl FulfillmentContext<'_> {\n impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn normalize_projection_type(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         _param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         _cause: ObligationCause<'tcx>,\n@@ -38,7 +38,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n     fn register_predicate_obligation(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     ) {\n         assert!(!infcx.is_in_snapshot());\n@@ -49,7 +49,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         self.obligations.insert(obligation);\n     }\n \n-    fn select_all_or_error(&mut self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         {\n             let errors = self.select_where_possible(infcx);\n \n@@ -71,10 +71,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n             .collect()\n     }\n \n-    fn select_where_possible(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Vec<FulfillmentError<'tcx>> {\n+    fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         assert!(!infcx.is_in_snapshot());\n \n         let mut errors = Vec::new();"}, {"sha": "8a62bf015674a5a392fbdc11f232ebc2cf1f4dd6", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -4,7 +4,7 @@\n // general routines.\n \n use crate::infer::{DefiningAnchor, TyCtxtInferExt};\n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::{\n     ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine, TraitEngineExt,\n     Unimplemented,\n@@ -29,60 +29,61 @@ pub fn codegen_select_candidate<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let mut infcx_builder =\n-        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n-    infcx_builder.enter(|infcx| {\n-        //~^ HACK `Bubble` is required for\n-        // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n-        let mut selcx = SelectionContext::new(&infcx);\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .ignoring_regions()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .build();\n+    //~^ HACK `Bubble` is required for\n+    // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n+    let mut selcx = SelectionContext::new(&infcx);\n \n-        let obligation_cause = ObligationCause::dummy();\n-        let obligation =\n-            Obligation::new(obligation_cause, param_env, trait_ref.to_poly_trait_predicate());\n+    let obligation_cause = ObligationCause::dummy();\n+    let obligation =\n+        Obligation::new(obligation_cause, param_env, trait_ref.to_poly_trait_predicate());\n \n-        let selection = match selcx.select(&obligation) {\n-            Ok(Some(selection)) => selection,\n-            Ok(None) => return Err(CodegenObligationError::Ambiguity),\n-            Err(Unimplemented) => return Err(CodegenObligationError::Unimplemented),\n-            Err(e) => {\n-                bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n-            }\n-        };\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(selection)) => selection,\n+        Ok(None) => return Err(CodegenObligationError::Ambiguity),\n+        Err(Unimplemented) => return Err(CodegenObligationError::Unimplemented),\n+        Err(e) => {\n+            bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n+        }\n+    };\n \n-        debug!(?selection);\n+    debug!(?selection);\n \n-        // Currently, we use a fulfillment context to completely resolve\n-        // all nested obligations. This is because they can inform the\n-        // inference of the impl's type parameters.\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n-        let impl_source = selection.map(|predicate| {\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-        });\n+    // Currently, we use a fulfillment context to completely resolve\n+    // all nested obligations. This is because they can inform the\n+    // inference of the impl's type parameters.\n+    let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n+    let impl_source = selection.map(|predicate| {\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+    });\n \n-        // In principle, we only need to do this so long as `impl_source`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n-        if !errors.is_empty() {\n-            // `rustc_monomorphize::collector` assumes there are no type errors.\n-            // Cycle errors are the only post-monomorphization errors possible; emit them now so\n-            // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n-            for err in errors {\n-                if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n-                    infcx.report_overflow_error_cycle(&cycle);\n-                }\n+    // In principle, we only need to do this so long as `impl_source`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    let errors = fulfill_cx.select_all_or_error(&infcx);\n+    if !errors.is_empty() {\n+        // `rustc_monomorphize::collector` assumes there are no type errors.\n+        // Cycle errors are the only post-monomorphization errors possible; emit them now so\n+        // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n+        for err in errors {\n+            if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n+                infcx.err_ctxt().report_overflow_error_cycle(&cycle);\n             }\n-            return Err(CodegenObligationError::FulfillmentError);\n         }\n+        return Err(CodegenObligationError::FulfillmentError);\n+    }\n \n-        let impl_source = infcx.resolve_vars_if_possible(impl_source);\n-        let impl_source = infcx.tcx.erase_regions(impl_source);\n+    let impl_source = infcx.resolve_vars_if_possible(impl_source);\n+    let impl_source = infcx.tcx.erase_regions(impl_source);\n \n-        // Opaque types may have gotten their hidden types constrained, but we can ignore them safely\n-        // as they will get constrained elsewhere, too.\n-        // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    // Opaque types may have gotten their hidden types constrained, but we can ignore them safely\n+    // as they will get constrained elsewhere, too.\n+    // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-        Ok(&*tcx.arena.alloc(impl_source))\n-    })\n+    Ok(&*tcx.arena.alloc(impl_source))\n }"}, {"sha": "7fc5c2ed0eae72408f23fb50a4bf467a53bc0683", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -100,25 +100,21 @@ where\n         return no_overlap();\n     }\n \n-    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx);\n-        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some()\n-    });\n-\n+    let infcx = tcx.infer_ctxt().build();\n+    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let overlaps =\n+        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n     if !overlaps {\n         return no_overlap();\n     }\n \n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx);\n-        selcx.enable_tracking_intercrate_ambiguity_causes();\n-        on_overlap(\n-            overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap(),\n-        )\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    selcx.enable_tracking_intercrate_ambiguity_causes();\n+    on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n }\n \n fn with_fresh_ty_vars<'cx, 'tcx>(\n@@ -167,7 +163,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     overlap_mode: OverlapMode,\n-    snapshot: &CombinedSnapshot<'_, 'tcx>,\n+    snapshot: &CombinedSnapshot<'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n     let infcx = selcx.infcx();\n \n@@ -298,37 +294,36 @@ fn negative_impl<'cx, 'tcx>(\n     let tcx = selcx.infcx().tcx;\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n-        let impl_env = tcx.param_env(impl1_def_id);\n-        let subject1 = match traits::fully_normalize(\n-            &infcx,\n-            ObligationCause::dummy(),\n-            impl_env,\n-            tcx.impl_subject(impl1_def_id),\n-        ) {\n-            Ok(s) => s,\n-            Err(err) => {\n-                tcx.sess.delay_span_bug(\n-                    tcx.def_span(impl1_def_id),\n-                    format!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n-                );\n-                return false;\n-            }\n-        };\n+    let infcx = tcx.infer_ctxt().build();\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+    let impl_env = tcx.param_env(impl1_def_id);\n+    let subject1 = match traits::fully_normalize(\n+        &infcx,\n+        ObligationCause::dummy(),\n+        impl_env,\n+        tcx.impl_subject(impl1_def_id),\n+    ) {\n+        Ok(s) => s,\n+        Err(err) => {\n+            tcx.sess.delay_span_bug(\n+                tcx.def_span(impl1_def_id),\n+                format!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n+            );\n+            return false;\n+        }\n+    };\n \n-        // Attempt to prove that impl2 applies, given all of the above.\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-        let (subject2, obligations) =\n-            impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n+    // Attempt to prove that impl2 applies, given all of the above.\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+    let (subject2, obligations) =\n+        impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n \n-        !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n-    })\n+    !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n }\n \n-fn equate<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+fn equate<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     impl_env: ty::ParamEnv<'tcx>,\n     subject1: ImplSubject<'tcx>,\n     subject2: ImplSubject<'tcx>,\n@@ -379,8 +374,8 @@ fn negative_impl_exists<'cx, 'tcx>(\n }\n \n #[instrument(level = \"debug\", skip(infcx))]\n-fn resolve_negative_obligation<'cx, 'tcx>(\n-    infcx: InferCtxt<'cx, 'tcx>,\n+fn resolve_negative_obligation<'tcx>(\n+    infcx: InferCtxt<'tcx>,\n     o: &PredicateObligation<'tcx>,\n     body_def_id: DefId,\n ) -> bool {"}, {"sha": "8ea3d0fc917c285cf336a433d6f557b5d7debb2c", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -159,8 +159,8 @@ pub fn try_unify_abstract_consts<'tcx>(\n \n /// Check if a given constant can be evaluated.\n #[instrument(skip(infcx), level = \"debug\")]\n-pub fn is_const_evaluatable<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+pub fn is_const_evaluatable<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     uv: ty::UnevaluatedConst<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,"}, {"sha": "e0c8deec91aff6cf6e3b7b2546bda8dc9f9a7df4", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -41,16 +41,16 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n /// Used if you want to have pleasant experience when dealing\n /// with obligations outside of hir or mir typeck.\n pub struct ObligationCtxt<'a, 'tcx> {\n-    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+    pub infcx: &'a InferCtxt<'tcx>,\n     engine: RefCell<Box<dyn TraitEngine<'tcx>>>,\n }\n \n impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n         Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new(infcx.tcx)) }\n     }\n \n-    pub fn new_in_snapshot(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+    pub fn new_in_snapshot(infcx: &'a InferCtxt<'tcx>) -> Self {\n         Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new_in_snapshot(infcx.tcx)) }\n     }\n "}, {"sha": "5b4fa1df426c0b82442558f663d41abd75c2b771", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 294, "deletions": 284, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -22,6 +22,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n+use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::TypeTrace;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n@@ -32,6 +33,8 @@ use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n     TypeVisitable,\n };\n+use rustc_session::Limit;\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n@@ -41,8 +44,8 @@ use std::ops::ControlFlow;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n-use on_unimplemented::InferCtxtExt as _;\n-use suggestions::InferCtxtExt as _;\n+use on_unimplemented::TypeErrCtxtExt as _;\n+use suggestions::TypeErrCtxtExt as _;\n \n pub use rustc_infer::traits::error_reporting::*;\n \n@@ -63,6 +66,37 @@ pub struct ImplCandidate<'tcx> {\n }\n \n pub trait InferCtxtExt<'tcx> {\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n+    /// in that order, and returns the generic type corresponding to the\n+    /// argument of that trait (corresponding to the closure arguments).\n+    fn type_implements_fn_trait(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: ty::Binder<'tcx, Ty<'tcx>>,\n+        constness: ty::BoundConstness,\n+        polarity: ty::ImplPolarity,\n+    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()>;\n+}\n+\n+pub trait TypeErrCtxtExt<'tcx> {\n     fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n@@ -78,6 +112,8 @@ pub trait InferCtxtExt<'tcx> {\n     where\n         T: fmt::Display + TypeFoldable<'tcx>;\n \n+    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n+\n     fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n \n     /// The `root_obligation` parameter should be the `root_obligation` field\n@@ -90,12 +126,71 @@ pub trait InferCtxtExt<'tcx> {\n         error: &SelectionError<'tcx>,\n         fallback_has_occurred: bool,\n     );\n+}\n \n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+        let sm = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n+        Some(match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }),\n+                ..\n+            }) => (\n+                fn_decl_span,\n+                hir.body(body)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            Some(ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        sm.span_to_snippet(pat.span)\n+                                            .ok()\n+                                            .map(|snippet| (snippet, \"_\".to_owned()))\n+                                    })\n+                                    .collect::<Option<Vec<_>>>()?,\n+                            ))\n+                        } else {\n+                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n+                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n+                        }\n+                    })\n+                    .collect::<Option<Vec<ArgKind>>>()?,\n+            ),\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref sig, _), .. })\n+            | Node::TraitItem(&hir::TraitItem {\n+                kind: hir::TraitItemKind::Fn(ref sig, _), ..\n+            }) => (\n+                sig.span,\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n+        })\n+    }\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -107,21 +202,175 @@ pub trait InferCtxtExt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n+        };\n+\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion_verbose(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        pluralize!(expected_args.len())\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion_verbose(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..]\n+                && fields.len() == found_args.len()\n+                && is_closure\n+            {\n+                let sugg = format!(\n+                    \"|({}){}|\",\n+                    found_args\n+                        .iter()\n+                        .map(|arg| match arg {\n+                            ArgKind::Arg(name, _) => name.to_owned(),\n+                            _ => \"_\".to_owned(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    // add type annotations if available\n+                    if found_args.iter().any(|arg| match arg {\n+                        ArgKind::Arg(_, ty) => ty != \"_\",\n+                        _ => false,\n+                    }) {\n+                        format!(\n+                            \": ({})\",\n+                            fields\n+                                .iter()\n+                                .map(|(_, ty)| ty.to_owned())\n+                                .collect::<Vec<String>>()\n+                                .join(\", \")\n+                        )\n+                    } else {\n+                        String::new()\n+                    },\n+                );\n+                err.span_suggestion_verbose(\n+                    found_span,\n+                    \"change the closure to accept a tuple instead of individual arguments\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        err\n+    }\n \n-    /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n-    /// in that order, and returns the generic type corresponding to the\n-    /// argument of that trait (corresponding to the closure arguments).\n     fn type_implements_fn_trait(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: ty::Binder<'tcx, Ty<'tcx>>,\n         constness: ty::BoundConstness,\n         polarity: ty::ImplPolarity,\n-    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()>;\n-}\n+    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()> {\n+        self.commit_if_ok(|_| {\n+            for trait_def_id in [\n+                self.tcx.lang_items().fn_trait(),\n+                self.tcx.lang_items().fn_mut_trait(),\n+                self.tcx.lang_items().fn_once_trait(),\n+            ] {\n+                let Some(trait_def_id) = trait_def_id else { continue };\n+                // Make a fresh inference variable so we can determine what the substitutions\n+                // of the trait are.\n+                let var = self.next_ty_var(TypeVariableOrigin {\n+                    span: DUMMY_SP,\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                });\n+                let substs = self.tcx.mk_substs_trait(ty.skip_binder(), &[var.into()]);\n+                let obligation = Obligation::new(\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    ty.rebind(ty::TraitPredicate {\n+                        trait_ref: ty::TraitRef::new(trait_def_id, substs),\n+                        constness,\n+                        polarity,\n+                    })\n+                    .to_predicate(self.tcx),\n+                );\n+                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n+                fulfill_cx.register_predicate_obligation(self, obligation);\n+                if fulfill_cx.select_all_or_error(self).is_empty() {\n+                    return Ok((\n+                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n+                            .expect(\"expected to map DefId to ClosureKind\"),\n+                        ty.rebind(self.resolve_vars_if_possible(var)),\n+                    ));\n+                }\n+            }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+            Err(())\n+        })\n+    }\n+}\n+impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n@@ -251,6 +500,19 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         bug!();\n     }\n \n+    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n+        let suggested_limit = match self.tcx.recursion_limit() {\n+            Limit(0) => Limit(2),\n+            limit => limit * 2,\n+        };\n+        err.help(&format!(\n+            \"consider increasing the recursion limit by adding a \\\n+             `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n+            suggested_limit,\n+            self.tcx.crate_name(LOCAL_CRATE),\n+        ));\n+    }\n+\n     /// Reports that a cycle was detected which led to overflow and halts\n     /// compilation. This is equivalent to `report_overflow_error` except\n     /// that we can give a more helpful error message (and, in particular,\n@@ -498,7 +760,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n \n                         if let ObligationCauseCode::ObjectCastObligation(concrete_ty, obj_ty) = obligation.cause.code().peel_derives() &&\n-                           Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n+                            Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n                             self.suggest_borrowing_for_object_cast(&mut err, &root_obligation, *concrete_ty, *obj_ty);\n                         }\n \n@@ -606,11 +868,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Try to report a help message\n                         if is_fn_trait\n                             && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n-                                obligation.param_env,\n-                                trait_ref.self_ty(),\n-                                trait_predicate.skip_binder().constness,\n-                                trait_predicate.skip_binder().polarity,\n-                            )\n+                            obligation.param_env,\n+                            trait_ref.self_ty(),\n+                            trait_predicate.skip_binder().constness,\n+                            trait_predicate.skip_binder().polarity,\n+                        )\n                         {\n                             // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n                             // suggestion to add trait bounds for the type, since we only typically implement\n@@ -840,12 +1102,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n-                        if let Some(typeck_results) = self.in_progress_typeck_results {\n+                        if let Some(typeck_results) = &self.typeck_results {\n                             let hir_id = self\n                                 .tcx\n                                 .hir()\n                                 .local_def_id_to_hir_id(closure_def_id.expect_local());\n-                            let typeck_results = typeck_results.borrow();\n                             match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, place))) => {\n                                     err.span_label(\n@@ -1088,250 +1349,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         err.emit();\n     }\n-\n-    /// Given some node representing a fn-like thing in the HIR map,\n-    /// returns a span and `ArgKind` information that describes the\n-    /// arguments it expects. This can be supplied to\n-    /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n-        let sm = self.tcx.sess.source_map();\n-        let hir = self.tcx.hir();\n-        Some(match node {\n-            Node::Expr(&hir::Expr {\n-                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }),\n-                ..\n-            }) => (\n-                fn_decl_span,\n-                hir.body(body)\n-                    .params\n-                    .iter()\n-                    .map(|arg| {\n-                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n-                            *arg.pat\n-                        {\n-                            Some(ArgKind::Tuple(\n-                                Some(span),\n-                                args.iter()\n-                                    .map(|pat| {\n-                                        sm.span_to_snippet(pat.span)\n-                                            .ok()\n-                                            .map(|snippet| (snippet, \"_\".to_owned()))\n-                                    })\n-                                    .collect::<Option<Vec<_>>>()?,\n-                            ))\n-                        } else {\n-                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n-                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n-                        }\n-                    })\n-                    .collect::<Option<Vec<ArgKind>>>()?,\n-            ),\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref sig, ..), .. })\n-            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref sig, _), .. })\n-            | Node::TraitItem(&hir::TraitItem {\n-                kind: hir::TraitItemKind::Fn(ref sig, _), ..\n-            }) => (\n-                sig.span,\n-                sig.decl\n-                    .inputs\n-                    .iter()\n-                    .map(|arg| match arg.kind {\n-                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n-                            Some(arg.span),\n-                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n-                        ),\n-                        _ => ArgKind::empty(),\n-                    })\n-                    .collect::<Vec<ArgKind>>(),\n-            ),\n-            Node::Ctor(ref variant_data) => {\n-                let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n-                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n-            }\n-            _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        })\n-    }\n-\n-    /// Reports an error when the number of arguments needed by a\n-    /// trait match doesn't match the number that the expression\n-    /// provides.\n-    fn report_arg_count_mismatch(\n-        &self,\n-        span: Span,\n-        found_span: Option<Span>,\n-        expected_args: Vec<ArgKind>,\n-        found_args: Vec<ArgKind>,\n-        is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let kind = if is_closure { \"closure\" } else { \"function\" };\n-\n-        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n-            let arg_length = arguments.len();\n-            let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n-            match (arg_length, arguments.get(0)) {\n-                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n-                    format!(\"a single {}-tuple as argument\", fields.len())\n-                }\n-                _ => format!(\n-                    \"{} {}argument{}\",\n-                    arg_length,\n-                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n-                    pluralize!(arg_length)\n-                ),\n-            }\n-        };\n-\n-        let expected_str = args_str(&expected_args, &found_args);\n-        let found_str = args_str(&found_args, &expected_args);\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0593,\n-            \"{} is expected to take {}, but it takes {}\",\n-            kind,\n-            expected_str,\n-            found_str,\n-        );\n-\n-        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n-\n-        if let Some(found_span) = found_span {\n-            err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-            // move |_| { ... }\n-            // ^^^^^^^^-- def_span\n-            //\n-            // move |_| { ... }\n-            // ^^^^^-- prefix\n-            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n-            // move |_| { ... }\n-            //      ^^^-- pipe_span\n-            let pipe_span =\n-                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n-\n-            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n-            // found arguments is empty (assume the user just wants to ignore args in this case).\n-            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n-            if found_args.is_empty() && is_closure {\n-                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n-                err.span_suggestion_verbose(\n-                    pipe_span,\n-                    &format!(\n-                        \"consider changing the closure to take and ignore the expected argument{}\",\n-                        pluralize!(expected_args.len())\n-                    ),\n-                    format!(\"|{}|\", underscores),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-                if fields.len() == expected_args.len() {\n-                    let sugg = fields\n-                        .iter()\n-                        .map(|(name, _)| name.to_owned())\n-                        .collect::<Vec<String>>()\n-                        .join(\", \");\n-                    err.span_suggestion_verbose(\n-                        found_span,\n-                        \"change the closure to take multiple arguments instead of a single tuple\",\n-                        format!(\"|{}|\", sugg),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..]\n-                && fields.len() == found_args.len()\n-                && is_closure\n-            {\n-                let sugg = format!(\n-                    \"|({}){}|\",\n-                    found_args\n-                        .iter()\n-                        .map(|arg| match arg {\n-                            ArgKind::Arg(name, _) => name.to_owned(),\n-                            _ => \"_\".to_owned(),\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \"),\n-                    // add type annotations if available\n-                    if found_args.iter().any(|arg| match arg {\n-                        ArgKind::Arg(_, ty) => ty != \"_\",\n-                        _ => false,\n-                    }) {\n-                        format!(\n-                            \": ({})\",\n-                            fields\n-                                .iter()\n-                                .map(|(_, ty)| ty.to_owned())\n-                                .collect::<Vec<String>>()\n-                                .join(\", \")\n-                        )\n-                    } else {\n-                        String::new()\n-                    },\n-                );\n-                err.span_suggestion_verbose(\n-                    found_span,\n-                    \"change the closure to accept a tuple instead of individual arguments\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        err\n-    }\n-\n-    fn type_implements_fn_trait(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: ty::Binder<'tcx, Ty<'tcx>>,\n-        constness: ty::BoundConstness,\n-        polarity: ty::ImplPolarity,\n-    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()> {\n-        self.commit_if_ok(|_| {\n-            for trait_def_id in [\n-                self.tcx.lang_items().fn_trait(),\n-                self.tcx.lang_items().fn_mut_trait(),\n-                self.tcx.lang_items().fn_once_trait(),\n-            ] {\n-                let Some(trait_def_id) = trait_def_id else { continue };\n-                // Make a fresh inference variable so we can determine what the substitutions\n-                // of the trait are.\n-                let var = self.next_ty_var(TypeVariableOrigin {\n-                    span: DUMMY_SP,\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                });\n-                let substs = self.tcx.mk_substs_trait(ty.skip_binder(), &[var.into()]);\n-                let obligation = Obligation::new(\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    ty.rebind(ty::TraitPredicate {\n-                        trait_ref: ty::TraitRef::new(trait_def_id, substs),\n-                        constness,\n-                        polarity,\n-                    })\n-                    .to_predicate(self.tcx),\n-                );\n-                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n-                fulfill_cx.register_predicate_obligation(self, obligation);\n-                if fulfill_cx.select_all_or_error(self).is_empty() {\n-                    return Ok((\n-                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n-                            .expect(\"expected to map DefId to ClosureKind\"),\n-                        ty.rebind(self.resolve_vars_if_possible(var)),\n-                    ));\n-                }\n-            }\n-\n-            Err(())\n-        })\n-    }\n }\n \n-trait InferCtxtPrivExt<'hir, 'tcx> {\n+trait InferCtxtPrivExt<'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool;\n@@ -1430,13 +1450,13 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n         predicate: ty::Predicate<'tcx>,\n     );\n \n-    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'hir>);\n+    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'tcx>);\n \n     fn maybe_indirection_for_unsized(\n         &self,\n         err: &mut Diagnostic,\n-        item: &'hir Item<'hir>,\n-        param: &'hir GenericParam<'hir>,\n+        item: &'tcx Item<'tcx>,\n+        param: &'tcx GenericParam<'tcx>,\n     ) -> bool;\n \n     fn is_recursive_obligation(\n@@ -1446,7 +1466,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     ) -> bool;\n }\n \n-impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool {\n@@ -1910,16 +1930,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         let normalize = |candidate| {\n-            self.tcx.infer_ctxt().enter(|ref infcx| {\n-                let normalized = infcx\n-                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                    .normalize(candidate)\n-                    .ok();\n-                match normalized {\n-                    Some(normalized) => normalized.value,\n-                    None => candidate,\n-                }\n-            })\n+            let infcx = self.tcx.infer_ctxt().build();\n+            infcx\n+                .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                .normalize(candidate)\n+                .map_or(candidate, |normalized| normalized.value)\n         };\n \n         // Sort impl candidates so that ordering is consistent for UI tests.\n@@ -2495,7 +2510,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         pred: ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n         struct ParamToVarFolder<'a, 'tcx> {\n-            infcx: &'a InferCtxt<'a, 'tcx>,\n+            infcx: &'a InferCtxt<'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n         }\n \n@@ -2581,12 +2596,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip_all)]\n-    fn maybe_suggest_unsized_generics<'hir>(\n-        &self,\n-        err: &mut Diagnostic,\n-        span: Span,\n-        node: Node<'hir>,\n-    ) {\n+    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'tcx>) {\n         let Some(generics) = node.generics() else {\n             return;\n         };\n@@ -2637,11 +2647,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn maybe_indirection_for_unsized<'hir>(\n+    fn maybe_indirection_for_unsized(\n         &self,\n         err: &mut Diagnostic,\n-        item: &'hir Item<'hir>,\n-        param: &'hir GenericParam<'hir>,\n+        item: &Item<'tcx>,\n+        param: &GenericParam<'tcx>,\n     ) -> bool {\n         // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n         // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`"}, {"sha": "0f20e02d6ecc96f91b93912677a4294210e79235", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -1,7 +1,7 @@\n use super::{\n     ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n };\n-use crate::infer::InferCtxt;\n+use crate::infer::error_reporting::TypeErrCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::SubstsRef;\n@@ -11,7 +11,7 @@ use std::iter;\n \n use super::InferCtxtPrivExt;\n \n-pub trait InferCtxtExt<'tcx> {\n+pub trait TypeErrCtxtExt<'tcx> {\n     /*private*/\n     fn impl_similar_to(\n         &self,\n@@ -29,7 +29,7 @@ pub trait InferCtxtExt<'tcx> {\n     ) -> OnUnimplementedNote;\n }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn impl_similar_to(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,"}, {"sha": "980e85b45262dc96bb8a99c4b47ec04e4e5ca8e0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -20,6 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n+use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::hir::map;\n use rustc_middle::ty::{\n@@ -28,8 +29,6 @@ use rustc_middle::ty::{\n     ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n-use rustc_session::Limit;\n-use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n@@ -62,7 +61,7 @@ impl<'tcx, 'a> GeneratorData<'tcx, 'a> {\n     // meet an obligation\n     fn try_get_upvar_span<F>(\n         &self,\n-        infer_context: &InferCtxt<'a, 'tcx>,\n+        infer_context: &InferCtxt<'tcx>,\n         generator_did: DefId,\n         ty_matches: F,\n     ) -> Option<GeneratorInteriorOrUpvar>\n@@ -168,7 +167,7 @@ impl<'tcx, 'a> GeneratorData<'tcx, 'a> {\n }\n \n // This trait is public to expose the diagnostics methods to clippy.\n-pub trait InferCtxtExt<'tcx> {\n+pub trait TypeErrCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut Diagnostic,\n@@ -296,8 +295,6 @@ pub trait InferCtxtExt<'tcx> {\n     ) where\n         T: fmt::Display;\n \n-    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n-\n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n         &self,\n@@ -461,7 +458,7 @@ fn suggest_restriction<'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut Diagnostic,\n@@ -675,9 +672,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // It only make sense when suggesting dereferences for arguments\n         let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code()\n             else { return false; };\n-        let Some(typeck_results) = self.in_progress_typeck_results\n+        let Some(typeck_results) = &self.typeck_results\n             else { return false; };\n-        let typeck_results = typeck_results.borrow();\n         let hir::Node::Expr(expr) = self.tcx.hir().get(*arg_hir_id)\n             else { return false; };\n         let Some(arg_ty) = typeck_results.expr_ty_adjusted_opt(expr)\n@@ -1176,8 +1172,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 &format!(\"this call returns `{}`\", pred.self_ty()),\n                             );\n                         }\n-                        if let Some(typeck_results) =\n-                            self.in_progress_typeck_results.map(|t| t.borrow())\n+                        if let Some(typeck_results) = &self.typeck_results\n                             && let ty = typeck_results.expr_ty_adjusted(base)\n                             && let ty::FnDef(def_id, _substs) = ty.kind()\n                             && let Some(hir::Node::Item(hir::Item { ident, span, vis_span, .. })) =\n@@ -1300,8 +1295,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             && let Some(stmt) = blk.stmts.last()\n             && let hir::StmtKind::Semi(expr) = stmt.kind\n             // Only suggest this if the expression behind the semicolon implements the predicate\n-            && let Some(typeck_results) = self.in_progress_typeck_results\n-            && let Some(ty) = typeck_results.borrow().expr_ty_opt(expr)\n+            && let Some(typeck_results) = &self.typeck_results\n+            && let Some(ty) = typeck_results.expr_ty_opt(expr)\n             && self.predicate_may_hold(&self.mk_trait_obligation_with_new_self_ty(\n                 obligation.param_env, trait_pred.map_bound(|trait_pred| (trait_pred, ty))\n             ))\n@@ -1390,7 +1385,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut visitor = ReturnsVisitor::default();\n         visitor.visit_body(&body);\n \n-        let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n+        let typeck_results = self.typeck_results.as_ref().unwrap();\n         let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n \n         let ret_types = visitor\n@@ -1573,7 +1568,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Point at all the `return`s in the function as they have failed trait bounds.\n             let mut visitor = ReturnsVisitor::default();\n             visitor.visit_body(&body);\n-            let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n+            let typeck_results = self.typeck_results.as_ref().unwrap();\n             for expr in &visitor.returns {\n                 if let Some(returned_ty) = typeck_results.node_type_opt(expr.hir_id) {\n                     let ty = self.resolve_vars_if_possible(returned_ty);\n@@ -1591,7 +1586,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         expected: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         pub(crate) fn build_fn_sig_ty<'tcx>(\n-            infcx: &InferCtxt<'_, 'tcx>,\n+            infcx: &InferCtxt<'tcx>,\n             trait_ref: ty::PolyTraitRef<'tcx>,\n         ) -> Ty<'tcx> {\n             let inputs = trait_ref.skip_binder().substs.type_at(1);\n@@ -1841,12 +1836,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let span = self.tcx.def_span(generator_did);\n \n-        let in_progress_typeck_results = self.in_progress_typeck_results.map(|t| t.borrow());\n         let generator_did_root = self.tcx.typeck_root_def_id(generator_did);\n         debug!(\n             ?generator_did,\n             ?generator_did_root,\n-            in_progress_typeck_results.hir_owner = ?in_progress_typeck_results.as_ref().map(|t| t.hir_owner),\n+            typeck_results.hir_owner = ?self.typeck_results.as_ref().map(|t| t.hir_owner),\n             ?span,\n         );\n \n@@ -1901,7 +1895,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // type-checking; otherwise, get them by performing a query.  This is needed to avoid\n         // cycles. If we can't use resolved types because the generator comes from another crate,\n         // we still provide a targeted error but without all the relevant spans.\n-        let generator_data: Option<GeneratorData<'tcx, '_>> = match &in_progress_typeck_results {\n+        let generator_data: Option<GeneratorData<'tcx, '_>> = match &self.typeck_results {\n             Some(t) if t.hir_owner.to_def_id() == generator_did_root => {\n                 Some(GeneratorData::Local(&t))\n             }\n@@ -2707,10 +2701,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let Some(Node::Expr(expr @ hir::Expr { kind: hir::ExprKind::Block(..), .. })) =\n                     hir.find(arg_hir_id)\n                 {\n-                    let in_progress_typeck_results =\n-                        self.in_progress_typeck_results.map(|t| t.borrow());\n                     let parent_id = hir.get_parent_item(arg_hir_id);\n-                    let typeck_results: &TypeckResults<'tcx> = match &in_progress_typeck_results {\n+                    let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n                         Some(t) if t.hir_owner == parent_id => t,\n                         _ => self.tcx.typeck(parent_id.def_id),\n                     };\n@@ -2797,19 +2789,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n-        let suggested_limit = match self.tcx.recursion_limit() {\n-            Limit(0) => Limit(2),\n-            limit => limit * 2,\n-        };\n-        err.help(&format!(\n-            \"consider increasing the recursion limit by adding a \\\n-             `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit,\n-            self.tcx.crate_name(LOCAL_CRATE),\n-        ));\n-    }\n-\n     #[instrument(\n         level = \"debug\", skip(self, err), fields(trait_pred.self_ty = ?trait_pred.self_ty())\n     )]"}, {"sha": "6eb023956855606289c94b3505b3175a8a6ae6db", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx, param_env, cause))]\n     fn normalize_projection_type(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n@@ -165,7 +165,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n     fn register_predicate_obligation(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     ) {\n         // this helps to reduce duplicate errors, as well as making\n@@ -182,7 +182,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n \n-    fn select_all_or_error(&mut self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         {\n             let errors = self.select_where_possible(infcx);\n             if !errors.is_empty() {\n@@ -193,10 +193,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         self.predicates.to_errors(CodeAmbiguity).into_iter().map(to_fulfillment_error).collect()\n     }\n \n-    fn select_where_possible(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Vec<FulfillmentError<'tcx>> {\n+    fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         let selcx = SelectionContext::new(infcx);\n         self.select(selcx)\n     }"}, {"sha": "be603c609cb364438f148b0a9e11342abb1e3ef6", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -7,7 +7,7 @@ use rustc_hir as hir;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n \n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n \n #[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n@@ -23,65 +23,64 @@ pub fn can_type_implement_copy<'tcx>(\n     parent_cause: ObligationCause<'tcx>,\n ) -> Result<(), CopyImplementationError<'tcx>> {\n     // FIXME: (@jroesch) float this code up\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let (adt, substs) = match self_type.kind() {\n-            // These types used to have a builtin impl.\n-            // Now libcore provides that impl.\n-            ty::Uint(_)\n-            | ty::Int(_)\n-            | ty::Bool\n-            | ty::Float(_)\n-            | ty::Char\n-            | ty::RawPtr(..)\n-            | ty::Never\n-            | ty::Ref(_, _, hir::Mutability::Not)\n-            | ty::Array(..) => return Ok(()),\n+    let infcx = tcx.infer_ctxt().build();\n+    let (adt, substs) = match self_type.kind() {\n+        // These types used to have a builtin impl.\n+        // Now libcore provides that impl.\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::Char\n+        | ty::RawPtr(..)\n+        | ty::Never\n+        | ty::Ref(_, _, hir::Mutability::Not)\n+        | ty::Array(..) => return Ok(()),\n \n-            ty::Adt(adt, substs) => (adt, substs),\n+        ty::Adt(adt, substs) => (adt, substs),\n \n-            _ => return Err(CopyImplementationError::NotAnAdt),\n-        };\n+        _ => return Err(CopyImplementationError::NotAnAdt),\n+    };\n \n-        let mut infringing = Vec::new();\n-        for variant in adt.variants() {\n-            for field in &variant.fields {\n-                let ty = field.ty(tcx, substs);\n-                if ty.references_error() {\n-                    continue;\n-                }\n-                let span = tcx.def_span(field.did);\n-                // FIXME(compiler-errors): This gives us better spans for bad\n-                // projection types like in issue-50480.\n-                // If the ADT has substs, point to the cause we are given.\n-                // If it does not, then this field probably doesn't normalize\n-                // to begin with, and point to the bad field's span instead.\n-                let cause = if field\n-                    .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n-                    .has_non_region_param()\n-                {\n-                    parent_cause.clone()\n-                } else {\n-                    ObligationCause::dummy_with_span(span)\n-                };\n-                match traits::fully_normalize(&infcx, cause, param_env, ty) {\n-                    Ok(ty) => {\n-                        if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n-                            infringing.push((field, ty));\n-                        }\n-                    }\n-                    Err(errors) => {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n-                    }\n-                };\n+    let mut infringing = Vec::new();\n+    for variant in adt.variants() {\n+        for field in &variant.fields {\n+            let ty = field.ty(tcx, substs);\n+            if ty.references_error() {\n+                continue;\n             }\n+            let span = tcx.def_span(field.did);\n+            // FIXME(compiler-errors): This gives us better spans for bad\n+            // projection types like in issue-50480.\n+            // If the ADT has substs, point to the cause we are given.\n+            // If it does not, then this field probably doesn't normalize\n+            // to begin with, and point to the bad field's span instead.\n+            let cause = if field\n+                .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n+                .has_non_region_param()\n+            {\n+                parent_cause.clone()\n+            } else {\n+                ObligationCause::dummy_with_span(span)\n+            };\n+            match traits::fully_normalize(&infcx, cause, param_env, ty) {\n+                Ok(ty) => {\n+                    if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n+                        infringing.push((field, ty));\n+                    }\n+                }\n+                Err(errors) => {\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                }\n+            };\n         }\n-        if !infringing.is_empty() {\n-            return Err(CopyImplementationError::InfrigingFields(infringing));\n-        }\n-        if adt.has_dtor(tcx) {\n-            return Err(CopyImplementationError::HasDestructor);\n-        }\n+    }\n+    if !infringing.is_empty() {\n+        return Err(CopyImplementationError::InfrigingFields(infringing));\n+    }\n+    if adt.has_dtor(tcx) {\n+        return Err(CopyImplementationError::HasDestructor);\n+    }\n \n-        Ok(())\n-    })\n+    Ok(())\n }"}, {"sha": "274a366873ce99904a83f4f918bb84e8dc2a9e0f", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 74, "deletions": 81, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -26,7 +26,7 @@ pub mod wf;\n use crate::errors::DumpVTableEntries;\n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n-use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -140,8 +140,8 @@ pub fn predicates_for_generics<'tcx>(\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n     def_id: DefId,\n@@ -234,54 +234,51 @@ fn do_normalize_predicates<'tcx>(\n     // by wfcheck anyway, so I'm not sure we have to check\n     // them here too, and we will remove this function when\n     // we move over to lazy normalization *anyway*.\n-    tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-        let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n-            Ok(predicates) => predicates,\n-            Err(errors) => {\n-                let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-                return Err(reported);\n-            }\n-        };\n+    let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+    let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n+        Ok(predicates) => predicates,\n+        Err(errors) => {\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            return Err(reported);\n+        }\n+    };\n \n-        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n+    debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n-        // We can use the `elaborated_env` here; the region code only\n-        // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+    // We can use the `elaborated_env` here; the region code only\n+    // cares about declarations like `'a: 'b`.\n+    let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+\n+    // FIXME: It's very weird that we ignore region obligations but apparently\n+    // still need to use `resolve_regions` as we need the resolved regions in\n+    // the normalized predicates.\n+    let errors = infcx.resolve_regions(&outlives_env);\n+    if !errors.is_empty() {\n+        tcx.sess.delay_span_bug(\n+            span,\n+            format!(\"failed region resolution while normalizing {elaborated_env:?}: {errors:?}\"),\n+        );\n+    }\n \n-        // FIXME: It's very weird that we ignore region obligations but apparently\n-        // still need to use `resolve_regions` as we need the resolved regions in\n-        // the normalized predicates.\n-        let errors = infcx.resolve_regions(&outlives_env);\n-        if !errors.is_empty() {\n-            tcx.sess.delay_span_bug(\n+    match infcx.fully_resolve(predicates) {\n+        Ok(predicates) => Ok(predicates),\n+        Err(fixup_err) => {\n+            // If we encounter a fixup error, it means that some type\n+            // variable wound up unconstrained. I actually don't know\n+            // if this can happen, and I certainly don't expect it to\n+            // happen often, but if it did happen it probably\n+            // represents a legitimate failure due to some kind of\n+            // unconstrained variable.\n+            //\n+            // @lcnr: Let's still ICE here for now. I want a test case\n+            // for that.\n+            span_bug!(\n                 span,\n-                format!(\n-                    \"failed region resolution while normalizing {elaborated_env:?}: {errors:?}\"\n-                ),\n+                \"inference variables in normalized parameter environment: {}\",\n+                fixup_err\n             );\n         }\n-\n-        match infcx.fully_resolve(predicates) {\n-            Ok(predicates) => Ok(predicates),\n-            Err(fixup_err) => {\n-                // If we encounter a fixup error, it means that some type\n-                // variable wound up unconstrained. I actually don't know\n-                // if this can happen, and I certainly don't expect it to\n-                // happen often, but if it did happen it probably\n-                // represents a legitimate failure due to some kind of\n-                // unconstrained variable.\n-                //\n-                // @lcnr: Let's still ICE here for now. I want a test case\n-                // for that.\n-                span_bug!(\n-                    span,\n-                    \"inference variables in normalized parameter environment: {}\",\n-                    fixup_err\n-                );\n-            }\n-        }\n-    })\n+    }\n }\n \n // FIXME: this is gonna need to be removed ...\n@@ -393,8 +390,8 @@ pub fn normalize_param_env_or_error<'tcx>(\n }\n \n /// Normalize a type and process all resulting obligations, returning any errors\n-pub fn fully_normalize<'a, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn fully_normalize<'tcx, T>(\n+    infcx: &InferCtxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     value: T,\n@@ -429,8 +426,8 @@ where\n \n /// Process an obligation (and any nested obligations that come from it) to\n /// completion, returning any errors\n-pub fn fully_solve_obligation<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn fully_solve_obligation<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     obligation: PredicateObligation<'tcx>,\n ) -> Vec<FulfillmentError<'tcx>> {\n     let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n@@ -440,8 +437,8 @@ pub fn fully_solve_obligation<'a, 'tcx>(\n \n /// Process a set of obligations (and any nested obligations that come from them)\n /// to completion\n-pub fn fully_solve_obligations<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn fully_solve_obligations<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n ) -> Vec<FulfillmentError<'tcx>> {\n     let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n@@ -452,8 +449,8 @@ pub fn fully_solve_obligations<'a, 'tcx>(\n /// Process a bound (and any nested obligations that come from it) to completion.\n /// This is a convenience function for traits that have no generic arguments, such\n /// as auto traits, and builtin traits like Copy or Sized.\n-pub fn fully_solve_bound<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn fully_solve_bound<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n@@ -473,21 +470,20 @@ pub fn impossible_predicates<'tcx>(\n ) -> bool {\n     debug!(\"impossible_predicates(predicates={:?})\", predicates);\n \n-    let result = tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::reveal_all();\n-        let ocx = ObligationCtxt::new(&infcx);\n-        let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);\n-        for predicate in predicates {\n-            let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n-            ocx.register_obligation(obligation);\n-        }\n-        let errors = ocx.select_all_or_error();\n+    let infcx = tcx.infer_ctxt().build();\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);\n+    for predicate in predicates {\n+        let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+        ocx.register_obligation(obligation);\n+    }\n+    let errors = ocx.select_all_or_error();\n \n-        // Clean up after ourselves\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    // Clean up after ourselves\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-        !errors.is_empty()\n-    });\n+    let result = !errors.is_empty();\n     debug!(\"impossible_predicates = {:?}\", result);\n     result\n }\n@@ -578,18 +574,16 @@ fn is_impossible_method<'tcx>(\n         }\n     });\n \n-    tcx.infer_ctxt().ignoring_regions().enter(|ref infcx| {\n-        for obligation in predicates_for_trait {\n-            // Ignore overflow error, to be conservative.\n-            if let Ok(result) = infcx.evaluate_obligation(&obligation)\n-                && !result.may_apply()\n-            {\n-                return true;\n-            }\n+    let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+    for obligation in predicates_for_trait {\n+        // Ignore overflow error, to be conservative.\n+        if let Ok(result) = infcx.evaluate_obligation(&obligation)\n+            && !result.may_apply()\n+        {\n+            return true;\n         }\n-\n-        false\n-    })\n+    }\n+    false\n }\n \n #[derive(Clone, Debug)]\n@@ -952,10 +946,9 @@ pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n         }),\n     );\n \n-    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n-        let mut selcx = SelectionContext::new(&infcx);\n-        selcx.select(&obligation).unwrap()\n-    });\n+    let infcx = tcx.infer_ctxt().build();\n+    let mut selcx = SelectionContext::new(&infcx);\n+    let implsrc = selcx.select(&obligation).unwrap();\n \n     let Some(ImplSource::TraitUpcasting(implsrc_traitcasting)) = implsrc else {\n         bug!();"}, {"sha": "31dd30c5c6a2b2822e71b7bd3f0ef7205eb7dea0", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -734,10 +734,9 @@ fn receiver_is_dispatchable<'tcx>(\n         Obligation::new(ObligationCause::dummy(), param_env, predicate)\n     };\n \n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        // the receiver is dispatchable iff the obligation holds\n-        infcx.predicate_must_hold_modulo_regions(&obligation)\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    // the receiver is dispatchable iff the obligation holds\n+    infcx.predicate_must_hold_modulo_regions(&obligation)\n }\n \n fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>("}, {"sha": "108dae092cfe7f922fb1eeda952d5bded82d32f3", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -26,7 +26,7 @@ pub trait InferCtxtExt<'a, 'tcx> {\n     ) -> Bounds<'a, 'tcx>;\n }\n \n-impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n+impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n     /// Implied bounds are region relationships that we deduce\n     /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before"}, {"sha": "4a2fde2cb4b06f3f9d269514d4c73e3e6ebb8f46", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -18,7 +18,7 @@ use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::select::ProjectionMatchesProjection;\n use rustc_data_structures::sso::SsoHashSet;\n@@ -513,7 +513,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.selcx.infcx().report_overflow_error(&obligation, true);\n+                            self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);\n@@ -569,7 +569,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                         self.param_env,\n                         ty,\n                     );\n-                    self.selcx.infcx().report_overflow_error(&obligation, true);\n+                    self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n                 }\n                 debug!(\n                     ?self.depth,\n@@ -663,7 +663,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n }\n \n pub struct BoundVarReplacer<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n+    infcx: &'me InferCtxt<'tcx>,\n     // These three maps track the bound variable that were replaced by placeholders. It might be\n     // nice to remove these since we already have the `kind` in the placeholder; we really just need\n     // the `var` (but we *could* bring that into scope if we were to track them as we pass them).\n@@ -691,7 +691,7 @@ pub struct BoundVarReplacer<'me, 'tcx> {\n /// FIXME(@lcnr): We may even consider experimenting with eagerly replacing bound vars during\n /// normalization as well, at which point this function will be unnecessary and can be removed.\n pub fn with_replaced_escaping_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>, R: TypeFoldable<'tcx>>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     universe_indices: &'a mut Vec<Option<ty::UniverseIndex>>,\n     value: T,\n     f: impl FnOnce(T) -> R,\n@@ -717,7 +717,7 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n     /// Returns `Some` if we *were* able to replace bound vars. If there are any bound vars that\n     /// use a binding level above `universe_indices.len()`, we fail.\n     pub fn replace_bound_vars<T: TypeFoldable<'tcx>>(\n-        infcx: &'me InferCtxt<'me, 'tcx>,\n+        infcx: &'me InferCtxt<'tcx>,\n         universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n         value: T,\n     ) -> (\n@@ -837,7 +837,7 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n \n // The inverse of `BoundVarReplacer`: replaces placeholders with the bound vars from which they came.\n pub struct PlaceholderReplacer<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n+    infcx: &'me InferCtxt<'tcx>,\n     mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n     mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n     mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n@@ -847,7 +847,7 @@ pub struct PlaceholderReplacer<'me, 'tcx> {\n \n impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n     pub fn replace_placeholders<T: TypeFoldable<'tcx>>(\n-        infcx: &'me InferCtxt<'me, 'tcx>,\n+        infcx: &'me InferCtxt<'tcx>,\n         mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n         mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n         mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,"}, {"sha": "c84f128ddf78e09310705f0027ab0fb0f26e5d86", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -31,7 +31,7 @@ pub trait InferCtxtExt<'tcx> {\n     ) -> EvaluationResult;\n }\n \n-impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)\n     /// in the given `ParamEnv`.\n     fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool {"}, {"sha": "af1029521726a41ccad1ff821ca19e00350c13bd", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -5,7 +5,7 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::{needs_normalization, BoundVarReplacer, PlaceholderReplacer};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use rustc_data_structures::sso::SsoHashMap;\n@@ -154,7 +154,7 @@ impl<'tcx> TypeVisitor<'tcx> for MaxEscapingBoundVarVisitor {\n }\n \n struct QueryNormalizer<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     cause: &'cx ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n@@ -213,7 +213,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.infcx.report_overflow_error(&obligation, true);\n+                            self.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let generic_ty = self.tcx().bound_type_of(def_id);"}, {"sha": "6bf3ed0d0e29a4305957bfcbea9cf913aa48d0f4", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -16,7 +16,7 @@ pub struct CustomTypeOp<F, G> {\n impl<F, G> CustomTypeOp<F, G> {\n     pub fn new<'tcx, R>(closure: F, description: G) -> Self\n     where\n-        F: FnOnce(&InferCtxt<'_, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n+        F: FnOnce(&InferCtxt<'tcx>) -> Fallible<InferOk<'tcx, R>>,\n         G: Fn() -> String,\n     {\n         CustomTypeOp { closure, description }\n@@ -25,7 +25,7 @@ impl<F, G> CustomTypeOp<F, G> {\n \n impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n where\n-    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n+    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'tcx>) -> Fallible<InferOk<'tcx, R>>,\n     G: Fn() -> String,\n {\n     type Output = R;\n@@ -36,7 +36,7 @@ where\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+    fn fully_perform(self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         if cfg!(debug_assertions) {\n             info!(\"fully_perform({:?})\", self);\n         }\n@@ -57,7 +57,7 @@ where\n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n     // During NLL, we expect that nobody will register region"}, {"sha": "29ae8ae6b6e555edee8244eb73091a0240c415d1", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -32,7 +32,7 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>>;\n+    fn fully_perform(self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>>;\n }\n \n /// The output from performing a type op\n@@ -78,7 +78,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n \n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n     ) -> Fallible<(\n         Self::QueryResponse,\n@@ -120,7 +120,7 @@ where\n     type Output = Q::QueryResponse;\n     type ErrorInfo = Canonical<'tcx, ParamEnvAnd<'tcx, Q>>;\n \n-    fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+    fn fully_perform(self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n         let (output, error_info, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints)?;"}, {"sha": "8cf500a466bf276f4739fd6accdbbed4a22a7f52", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::{self, ToPredicate};\n \n pub(crate) fn update<'tcx, T>(\n     engine: &mut T,\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     obligation: &PredicateObligation<'tcx>,\n ) where\n     T: TraitEngine<'tcx>,"}, {"sha": "ae811fbac027b0c9103a809b087649e81107441b", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -20,7 +20,7 @@ use super::{\n };\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n-use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n@@ -93,7 +93,7 @@ impl IntercrateAmbiguityCause {\n }\n \n pub struct SelectionContext<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n \n     /// Freshener used specifically for entries on the obligation\n     /// stack. This ensures that all entries on the stack at one time\n@@ -214,7 +214,7 @@ enum BuiltinImplConditions<'tcx> {\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener_keep_static(),\n@@ -224,12 +224,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext { intercrate: true, ..SelectionContext::new(infcx) }\n     }\n \n     pub fn with_query_mode(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n+        infcx: &'cx InferCtxt<'tcx>,\n         query_mode: TraitQueryMode,\n     ) -> SelectionContext<'cx, 'tcx> {\n         debug!(?query_mode, \"with_query_mode\");\n@@ -253,7 +253,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+    pub fn infcx(&self) -> &'cx InferCtxt<'tcx> {\n         self.infcx\n     }\n \n@@ -1095,7 +1095,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             ErrorGuaranteed::unchecked_claim_error_was_emitted(),\n                         ));\n                     }\n-                    self.infcx.report_overflow_error(error_obligation, true);\n+                    self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n                 }\n                 TraitQueryMode::Canonical => {\n                     return Err(OverflowError::Canonical);"}, {"sha": "c891658582a0a89b34222703a47894385c45a5e3", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -73,8 +73,8 @@ pub struct OverlapError {\n /// through associated type projection. We deal with such cases by using\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n-pub fn translate_substs<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn translate_substs<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     source_impl: DefId,\n     source_substs: SubstsRef<'tcx>,\n@@ -149,13 +149,9 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let impl1_trait_ref = match traits::fully_normalize(\n-            &infcx,\n-            ObligationCause::dummy(),\n-            penv,\n-            impl1_trait_ref,\n-        ) {\n+    let infcx = tcx.infer_ctxt().build();\n+    let impl1_trait_ref =\n+        match traits::fully_normalize(&infcx, ObligationCause::dummy(), penv, impl1_trait_ref) {\n             Ok(impl1_trait_ref) => impl1_trait_ref,\n             Err(_errors) => {\n                 tcx.sess.delay_span_bug(\n@@ -166,18 +162,17 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n             }\n         };\n \n-        // Attempt to prove that impl2 applies, given all of the above.\n-        fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n-    })\n+    // Attempt to prove that impl2 applies, given all of the above.\n+    fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with\n /// `source_trait_ref`. If successful, returns a substitution for *all* the\n /// generics of `target_impl`, including both those needed to unify with\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n-fn fulfill_implication<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+fn fulfill_implication<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     source_trait_ref: ty::TraitRef<'tcx>,\n     target_impl: DefId,"}, {"sha": "932dbbb81e5cc560645aaa011ec0a093fe07fba4", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -68,7 +68,7 @@ pub fn search_for_adt_const_param_violation<'tcx>(\n /// Note that this does *not* recursively check if the substructure of `adt_ty`\n /// implements the traits.\n fn type_marked_structural<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     adt_ty: Ty<'tcx>,\n     cause: ObligationCause<'tcx>,\n ) -> bool {\n@@ -265,9 +265,8 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n \n pub fn provide(providers: &mut Providers) {\n     providers.has_structural_eq_impls = |tcx, ty| {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let cause = ObligationCause::dummy();\n-            type_marked_structural(&infcx, ty, cause)\n-        })\n+        let infcx = tcx.infer_ctxt().build();\n+        let cause = ObligationCause::dummy();\n+        type_marked_structural(&infcx, ty, cause)\n     };\n }"}, {"sha": "b1fae164d8521decf6649661ab5c2dc93ac49dac", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -14,8 +14,8 @@ use std::iter;\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n-pub fn obligations<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn obligations<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n     recursion_depth: usize,\n@@ -79,8 +79,8 @@ pub fn obligations<'a, 'tcx>(\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n-pub fn trait_obligations<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn trait_obligations<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n     trait_pred: &ty::TraitPredicate<'tcx>,\n@@ -102,8 +102,8 @@ pub fn trait_obligations<'a, 'tcx>(\n }\n \n #[instrument(skip(infcx), ret)]\n-pub fn predicate_obligations<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn predicate_obligations<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n     predicate: ty::Predicate<'tcx>,\n@@ -275,7 +275,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n \n-    fn normalize(self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<traits::PredicateObligation<'tcx>> {\n+    fn normalize(self, infcx: &InferCtxt<'tcx>) -> Vec<traits::PredicateObligation<'tcx>> {\n         let cause = self.cause(traits::WellFormed(None));\n         let param_env = self.param_env;\n         let mut obligations = Vec::with_capacity(self.out.len());"}, {"sha": "d5a8ca5ea784a2508c2c569785e1aeed6344a591", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 105, "deletions": 113, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -27,128 +27,120 @@ fn dropck_outlives<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n-    tcx.infer_ctxt().enter_with_canonical(\n-        DUMMY_SP,\n-        &canonical_goal,\n-        |ref infcx, goal, canonical_inference_vars| {\n-            let tcx = infcx.tcx;\n-            let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-            let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-            // A stack of types left to process. Each round, we pop\n-            // something from the stack and invoke\n-            // `dtorck_constraint_for_ty`. This may produce new types that\n-            // have to be pushed on the stack. This continues until we have explored\n-            // all the reachable types from the type `for_ty`.\n-            //\n-            // Example: Imagine that we have the following code:\n-            //\n-            // ```rust\n-            // struct A {\n-            //     value: B,\n-            //     children: Vec<A>,\n-            // }\n-            //\n-            // struct B {\n-            //     value: u32\n-            // }\n-            //\n-            // fn f() {\n-            //   let a: A = ...;\n-            //   ..\n-            // } // here, `a` is dropped\n-            // ```\n-            //\n-            // at the point where `a` is dropped, we need to figure out\n-            // which types inside of `a` contain region data that may be\n-            // accessed by any destructors in `a`. We begin by pushing `A`\n-            // onto the stack, as that is the type of `a`. We will then\n-            // invoke `dtorck_constraint_for_ty` which will expand `A`\n-            // into the types of its fields `(B, Vec<A>)`. These will get\n-            // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-            // lead to us trying to push `A` a second time -- to prevent\n-            // infinite recursion, we notice that `A` was already pushed\n-            // once and stop.\n-            let mut ty_stack = vec![(for_ty, 0)];\n-\n-            // Set used to detect infinite recursion.\n-            let mut ty_set = FxHashSet::default();\n-\n-            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-            let cause = ObligationCause::dummy();\n-            let mut constraints = DropckConstraint::empty();\n-            while let Some((ty, depth)) = ty_stack.pop() {\n-                debug!(\n-                    \"{} kinds, {} overflows, {} ty_stack\",\n-                    result.kinds.len(),\n-                    result.overflows.len(),\n-                    ty_stack.len()\n-                );\n-                dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-                // \"outlives\" represent types/regions that may be touched\n-                // by a destructor.\n-                result.kinds.append(&mut constraints.outlives);\n-                result.overflows.append(&mut constraints.overflows);\n-\n-                // If we have even one overflow, we should stop trying to evaluate further --\n-                // chances are, the subsequent overflows for this evaluation won't provide useful\n-                // information and will just decrease the speed at which we can emit these errors\n-                // (since we'll be printing for just that much longer for the often enormous types\n-                // that result here).\n-                if !result.overflows.is_empty() {\n-                    break;\n-                }\n+    let (ref infcx, goal, canonical_inference_vars) =\n+        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+    let tcx = infcx.tcx;\n+    let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+    // A stack of types left to process. Each round, we pop\n+    // something from the stack and invoke\n+    // `dtorck_constraint_for_ty`. This may produce new types that\n+    // have to be pushed on the stack. This continues until we have explored\n+    // all the reachable types from the type `for_ty`.\n+    //\n+    // Example: Imagine that we have the following code:\n+    //\n+    // ```rust\n+    // struct A {\n+    //     value: B,\n+    //     children: Vec<A>,\n+    // }\n+    //\n+    // struct B {\n+    //     value: u32\n+    // }\n+    //\n+    // fn f() {\n+    //   let a: A = ...;\n+    //   ..\n+    // } // here, `a` is dropped\n+    // ```\n+    //\n+    // at the point where `a` is dropped, we need to figure out\n+    // which types inside of `a` contain region data that may be\n+    // accessed by any destructors in `a`. We begin by pushing `A`\n+    // onto the stack, as that is the type of `a`. We will then\n+    // invoke `dtorck_constraint_for_ty` which will expand `A`\n+    // into the types of its fields `(B, Vec<A>)`. These will get\n+    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+    // lead to us trying to push `A` a second time -- to prevent\n+    // infinite recursion, we notice that `A` was already pushed\n+    // once and stop.\n+    let mut ty_stack = vec![(for_ty, 0)];\n+\n+    // Set used to detect infinite recursion.\n+    let mut ty_set = FxHashSet::default();\n+\n+    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+\n+    let cause = ObligationCause::dummy();\n+    let mut constraints = DropckConstraint::empty();\n+    while let Some((ty, depth)) = ty_stack.pop() {\n+        debug!(\n+            \"{} kinds, {} overflows, {} ty_stack\",\n+            result.kinds.len(),\n+            result.overflows.len(),\n+            ty_stack.len()\n+        );\n+        dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+        // \"outlives\" represent types/regions that may be touched\n+        // by a destructor.\n+        result.kinds.append(&mut constraints.outlives);\n+        result.overflows.append(&mut constraints.overflows);\n+\n+        // If we have even one overflow, we should stop trying to evaluate further --\n+        // chances are, the subsequent overflows for this evaluation won't provide useful\n+        // information and will just decrease the speed at which we can emit these errors\n+        // (since we'll be printing for just that much longer for the often enormous types\n+        // that result here).\n+        if !result.overflows.is_empty() {\n+            break;\n+        }\n \n-                // dtorck types are \"types that will get dropped but which\n-                // do not themselves define a destructor\", more or less. We have\n-                // to push them onto the stack to be expanded.\n-                for ty in constraints.dtorck_types.drain(..) {\n-                    match infcx.at(&cause, param_env).normalize(ty) {\n-                        Ok(Normalized { value: ty, obligations }) => {\n-                            fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                            debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                            match ty.kind() {\n-                                // All parameters live for the duration of the\n-                                // function.\n-                                ty::Param(..) => {}\n-\n-                                // A projection that we couldn't resolve - it\n-                                // might have a destructor.\n-                                ty::Projection(..) | ty::Opaque(..) => {\n-                                    result.kinds.push(ty.into());\n-                                }\n-\n-                                _ => {\n-                                    if ty_set.insert(ty) {\n-                                        ty_stack.push((ty, depth + 1));\n-                                    }\n-                                }\n-                            }\n+        // dtorck types are \"types that will get dropped but which\n+        // do not themselves define a destructor\", more or less. We have\n+        // to push them onto the stack to be expanded.\n+        for ty in constraints.dtorck_types.drain(..) {\n+            match infcx.at(&cause, param_env).normalize(ty) {\n+                Ok(Normalized { value: ty, obligations }) => {\n+                    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+                    debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                    match ty.kind() {\n+                        // All parameters live for the duration of the\n+                        // function.\n+                        ty::Param(..) => {}\n+\n+                        // A projection that we couldn't resolve - it\n+                        // might have a destructor.\n+                        ty::Projection(..) | ty::Opaque(..) => {\n+                            result.kinds.push(ty.into());\n                         }\n \n-                        // We don't actually expect to fail to normalize.\n-                        // That implies a WF error somewhere else.\n-                        Err(NoSolution) => {\n-                            return Err(NoSolution);\n+                        _ => {\n+                            if ty_set.insert(ty) {\n+                                ty_stack.push((ty, depth + 1));\n+                            }\n                         }\n                     }\n                 }\n+\n+                // We don't actually expect to fail to normalize.\n+                // That implies a WF error somewhere else.\n+                Err(NoSolution) => {\n+                    return Err(NoSolution);\n+                }\n             }\n+        }\n+    }\n \n-            debug!(\"dropck_outlives: result = {:#?}\", result);\n+    debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-            infcx.make_canonicalized_query_response(\n-                canonical_inference_vars,\n-                result,\n-                &mut *fulfill_cx,\n-            )\n-        },\n-    )\n+    infcx.make_canonicalized_query_response(canonical_inference_vars, result, &mut *fulfill_cx)\n }\n \n /// Returns a set of constraints that needs to be satisfied in"}, {"sha": "493d5de0807a2c384315786f4bfd42c383c2992a", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -18,17 +18,15 @@ fn evaluate_obligation<'tcx>(\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter_with_canonical(\n-        DUMMY_SP,\n-        &canonical_goal,\n-        |ref infcx, goal, _canonical_inference_vars| {\n-            debug!(\"evaluate_obligation: goal={:#?}\", goal);\n-            let ParamEnvAnd { param_env, value: predicate } = goal;\n+    let (ref infcx, goal, _canonical_inference_vars) = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .build_with_canonical(DUMMY_SP, &canonical_goal);\n+    debug!(\"evaluate_obligation: goal={:#?}\", goal);\n+    let ParamEnvAnd { param_env, value: predicate } = goal;\n \n-            let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n-            let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+    let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n+    let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n \n-            selcx.evaluate_root_obligation(&obligation)\n-        },\n-    )\n+    selcx.evaluate_root_obligation(&obligation)\n }"}, {"sha": "7d36b9558d50b2a974b5432c4aa1f42e00c99d72", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -35,7 +35,7 @@ fn implied_outlives_bounds<'tcx>(\n }\n \n fn compute_implied_outlives_bounds<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Fallible<Vec<OutlivesBound<'tcx>>> {"}, {"sha": "58b718ed12766b15ac9ddd7206e64c44d1c7ab8c", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -30,30 +30,29 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n     goal: ParamEnvAnd<'tcx, T>,\n ) -> Result<T, NoSolution> {\n     let ParamEnvAnd { param_env, value } = goal;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::dummy();\n-        match infcx.at(&cause, param_env).normalize(value) {\n-            Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n-                // We don't care about the `obligations`; they are\n-                // always only region relations, and we are about to\n-                // erase those anyway:\n-                debug_assert_eq!(\n-                    normalized_obligations.iter().find(|p| not_outlives_predicate(p.predicate)),\n-                    None,\n-                );\n+    let infcx = tcx.infer_ctxt().build();\n+    let cause = ObligationCause::dummy();\n+    match infcx.at(&cause, param_env).normalize(value) {\n+        Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n+            // We don't care about the `obligations`; they are\n+            // always only region relations, and we are about to\n+            // erase those anyway:\n+            debug_assert_eq!(\n+                normalized_obligations.iter().find(|p| not_outlives_predicate(p.predicate)),\n+                None,\n+            );\n \n-                let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n-                // It's unclear when `resolve_vars` would have an effect in a\n-                // fresh `InferCtxt`. If this assert does trigger, it will give\n-                // us a test case.\n-                debug_assert_eq!(normalized_value, resolved_value);\n-                let erased = infcx.tcx.erase_regions(resolved_value);\n-                debug_assert!(!erased.needs_infer(), \"{:?}\", erased);\n-                Ok(erased)\n-            }\n-            Err(NoSolution) => Err(NoSolution),\n+            let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n+            // It's unclear when `resolve_vars` would have an effect in a\n+            // fresh `InferCtxt`. If this assert does trigger, it will give\n+            // us a test case.\n+            debug_assert_eq!(normalized_value, resolved_value);\n+            let erased = infcx.tcx.erase_regions(resolved_value);\n+            debug_assert!(!erased.needs_infer(), \"{:?}\", erased);\n+            Ok(erased)\n         }\n-    })\n+        Err(NoSolution) => Err(NoSolution),\n+    }\n }\n \n fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {"}, {"sha": "bca7458ed332b2efef8a257108acfa6784bc0b78", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -51,7 +51,7 @@ fn type_op_ascribe_user_type<'tcx>(\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n     key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n     span: Option<Span>,\n@@ -68,7 +68,7 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n+    infcx: &'me InferCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     span: Span,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n@@ -210,7 +210,7 @@ fn type_op_eq<'tcx>(\n }\n \n fn type_op_normalize<'tcx, T>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n ) -> Fallible<T>\n@@ -285,7 +285,7 @@ fn type_op_prove_predicate<'tcx>(\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n pub fn type_op_prove_predicate_with_cause<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n     key: ParamEnvAnd<'tcx, ProvePredicate<'tcx>>,\n     cause: ObligationCause<'tcx>,"}, {"sha": "f7cc94e53146afaf35e3654b33ed5312f5bd4cf9", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -80,11 +80,11 @@ mod rustc {\n     }\n \n     pub struct TransmuteTypeEnv<'cx, 'tcx> {\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n+        infcx: &'cx InferCtxt<'tcx>,\n     }\n \n     impl<'cx, 'tcx> TransmuteTypeEnv<'cx, 'tcx> {\n-        pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> Self {\n+        pub fn new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n             Self { infcx }\n         }\n "}, {"sha": "d3169b6d962ecaf0f41cb006d6f34b53227c90ee", "filename": "compiler/rustc_ty_utils/src/common_traits.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -29,15 +29,8 @@ fn is_item_raw<'tcx>(\n ) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    traits::type_known_to_meet_bound_modulo_regions(&infcx, param_env, ty, trait_def_id, DUMMY_SP)\n }\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "5ed40515d8a98b259a502505c63cb2c3a3014b5f", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -134,19 +134,17 @@ fn resolve_associated_item<'tcx>(\n                 .unwrap_or_else(|| {\n                     bug!(\"{:?} not found in {:?}\", trait_item_id, impl_data.impl_def_id);\n                 });\n-\n-            let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = param_env.with_reveal_all_normalized(tcx);\n-                let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                let substs = translate_substs(\n-                    &infcx,\n-                    param_env,\n-                    impl_data.impl_def_id,\n-                    substs,\n-                    leaf_def.defining_node,\n-                );\n-                infcx.tcx.erase_regions(substs)\n-            });\n+            let infcx = tcx.infer_ctxt().build();\n+            let param_env = param_env.with_reveal_all_normalized(tcx);\n+            let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+            let substs = translate_substs(\n+                &infcx,\n+                param_env,\n+                impl_data.impl_def_id,\n+                substs,\n+                leaf_def.defining_node,\n+            );\n+            let substs = infcx.tcx.erase_regions(substs);\n \n             // Since this is a trait item, we need to see if the item is either a trait default item\n             // or a specialization because we can't resolve those unless we can `Reveal::All`."}, {"sha": "95061ae61e3f77dd055b894f90367b95d5860619", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -27,76 +27,70 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 }\n                 // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n                 let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n-                for &impl_def_id in trait_impls.blanket_impls() {\n+                'blanket_impls: for &impl_def_id in trait_impls.blanket_impls() {\n                     trace!(\n                         \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n                         trait_def_id,\n                         impl_def_id\n                     );\n                     let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n-                    let is_param = matches!(trait_ref.0.self_ty().kind(), ty::Param(_));\n-                    let may_apply = is_param && cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n-                        let ty = ty.subst(infcx.tcx, substs);\n-                        let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n+                    if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n+                        continue;\n+                    }\n+                    let infcx = cx.tcx.infer_ctxt().build();\n+                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n+                    let impl_ty = ty.subst(infcx.tcx, substs);\n+                    let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n \n-                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                    let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n \n-                        // Require the type the impl is implemented on to match\n-                        // our type, and ignore the impl if there was a mismatch.\n-                        let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n-                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                            drop(obligations);\n+                    // Require the type the impl is implemented on to match\n+                    // our type, and ignore the impl if there was a mismatch.\n+                    let cause = traits::ObligationCause::dummy();\n+                    let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                        continue\n+                    };\n+                    let InferOk { value: (), obligations } = eq_result;\n+                    // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                    drop(obligations);\n \n-                            trace!(\n-                                \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n-                                param_env,\n-                                trait_ref,\n-                                ty\n-                            );\n-                            let predicates = cx\n-                                .tcx\n-                                .predicates_of(impl_def_id)\n-                                .instantiate(cx.tcx, impl_substs)\n-                                .predicates\n-                                .into_iter()\n-                                .chain(Some(\n-                                    ty::Binder::dummy(trait_ref)\n-                                        .to_poly_trait_predicate()\n-                                        .map_bound(ty::PredicateKind::Trait)\n-                                        .to_predicate(infcx.tcx),\n-                                ));\n-                            for predicate in predicates {\n-                                debug!(\"testing predicate {:?}\", predicate);\n-                                let obligation = traits::Obligation::new(\n-                                    traits::ObligationCause::dummy(),\n-                                    param_env,\n-                                    predicate,\n-                                );\n-                                match infcx.evaluate_obligation(&obligation) {\n-                                    Ok(eval_result) if eval_result.may_apply() => {}\n-                                    Err(traits::OverflowError::Canonical) => {}\n-                                    Err(traits::OverflowError::ErrorReporting) => {}\n-                                    _ => {\n-                                        return false;\n-                                    }\n-                                }\n-                            }\n-                            true\n-                        } else {\n-                            false\n+                    trace!(\n+                        \"invoking predicate_may_hold: param_env={:?}, impl_trait_ref={:?}, impl_ty={:?}\",\n+                        param_env,\n+                        impl_trait_ref,\n+                        impl_ty\n+                    );\n+                    let predicates = cx\n+                        .tcx\n+                        .predicates_of(impl_def_id)\n+                        .instantiate(cx.tcx, impl_substs)\n+                        .predicates\n+                        .into_iter()\n+                        .chain(Some(\n+                            ty::Binder::dummy(impl_trait_ref)\n+                                .to_poly_trait_predicate()\n+                                .map_bound(ty::PredicateKind::Trait)\n+                                .to_predicate(infcx.tcx),\n+                        ));\n+                    for predicate in predicates {\n+                        debug!(\"testing predicate {:?}\", predicate);\n+                        let obligation = traits::Obligation::new(\n+                            traits::ObligationCause::dummy(),\n+                            param_env,\n+                            predicate,\n+                        );\n+                        match infcx.evaluate_obligation(&obligation) {\n+                            Ok(eval_result) if eval_result.may_apply() => {}\n+                            Err(traits::OverflowError::Canonical) => {}\n+                            Err(traits::OverflowError::ErrorReporting) => {}\n+                            _ => continue 'blanket_impls,\n                         }\n-                    });\n+                    }\n                     debug!(\n-                        \"get_blanket_impls: found applicable impl: {} for trait_ref={:?}, ty={:?}\",\n-                        may_apply, trait_ref, ty\n+                        \"get_blanket_impls: found applicable impl for trait_ref={:?}, ty={:?}\",\n+                        trait_ref, ty\n                     );\n-                    if !may_apply {\n-                        continue;\n-                    }\n \n                     cx.generated_synthetics.insert((ty.0, trait_def_id));\n "}, {"sha": "279e762d597a0cd50f2aa443df7e93502d2b6819", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -1564,12 +1564,11 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n \n     // Try to normalize `<X as Y>::T` to a type\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n-    let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n-        infcx\n-            .at(&ObligationCause::dummy(), cx.param_env)\n-            .normalize(lifted)\n-            .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let normalized = infcx\n+        .at(&ObligationCause::dummy(), cx.param_env)\n+        .normalize(lifted)\n+        .map(|resolved| infcx.resolve_vars_if_possible(resolved.value));\n     match normalized {\n         Ok(normalized_value) => {\n             debug!(\"normalized {:?} to {:?}\", ty, normalized_value);"}, {"sha": "02a16f765b7324117fc9c9fc380b661caccc7bf9", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -831,11 +831,10 @@ fn walk_parents<'tcx>(\n                                 // Trait methods taking `self`\n                                 arg_ty\n                             } && impl_ty.is_ref()\n-                            && cx.tcx.infer_ctxt().enter(|infcx|\n-                                infcx\n-                                    .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n-                                    .must_apply_modulo_regions()\n-                            )\n+                            && let infcx = cx.tcx.infer_ctxt().build()\n+                            && infcx\n+                                .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                .must_apply_modulo_regions()\n                         {\n                             return Some(Position::MethodReceiverRefImpl)\n                         }\n@@ -1119,9 +1118,8 @@ fn needless_borrow_impl_arg_position<'tcx>(\n \n             let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n             let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n-            cx.tcx\n-                .infer_ctxt()\n-                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            infcx.predicate_must_hold_modulo_regions(&obligation)\n         })\n     };\n "}, {"sha": "eb0455ae404c1d4c9f369fe0ef70eb3bebb5d385", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -106,9 +106,8 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n         };\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n-        });\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n \n         for node in v.set {\n             span_lint_hir("}, {"sha": "0519f9ac24682f7cfda45b50228e8a1f1fdca93e", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -7,7 +7,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n-use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n use rustc_trait_selection::traits::{self, FulfillmentError};\n \n declare_clippy_lint! {\n@@ -77,29 +77,28 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             if is_future {\n                 let send_trait = cx.tcx.get_diagnostic_item(sym::Send).unwrap();\n                 let span = decl.output.span();\n-                let send_errors = cx.tcx.infer_ctxt().enter(|infcx| {\n-                    let cause = traits::ObligationCause::misc(span, hir_id);\n-                    traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait)\n-                });\n+                let infcx = cx.tcx.infer_ctxt().build();\n+                let cause = traits::ObligationCause::misc(span, hir_id);\n+                let send_errors = traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait);\n                 if !send_errors.is_empty() {\n                     span_lint_and_then(\n                         cx,\n                         FUTURE_NOT_SEND,\n                         span,\n                         \"future cannot be sent between threads safely\",\n                         |db| {\n-                            cx.tcx.infer_ctxt().enter(|infcx| {\n-                                for FulfillmentError { obligation, .. } in send_errors {\n-                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n-                                        db.note(&format!(\n-                                            \"`{}` doesn't implement `{}`\",\n-                                            trait_pred.self_ty(),\n-                                            trait_pred.trait_ref.print_only_trait_path(),\n-                                        ));\n-                                    }\n+                            for FulfillmentError { obligation, .. } in send_errors {\n+                                infcx\n+                                    .err_ctxt()\n+                                    .maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n+                                    db.note(&format!(\n+                                        \"`{}` doesn't implement `{}`\",\n+                                        trait_pred.self_ty(),\n+                                        trait_pred.trait_ref.print_only_trait_path(),\n+                                    ));\n                                 }\n-                            });\n+                            }\n                         },\n                     );\n                 }"}, {"sha": "db73ab55b37cf8fa90bc62f1975e408e6d0b3731", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -65,16 +65,15 @@ fn check_for_mutation<'tcx>(\n         span_low: None,\n         span_high: None,\n     };\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(\n-            &mut delegate,\n-            &infcx,\n-            body.hir_id.owner.def_id,\n-            cx.param_env,\n-            cx.typeck_results(),\n-        )\n-        .walk_expr(body);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    ExprUseVisitor::new(\n+        &mut delegate,\n+        &infcx,\n+        body.hir_id.owner.def_id,\n+        cx.param_env,\n+        cx.typeck_results(),\n+    )\n+    .walk_expr(body);\n \n     delegate.mutation_span()\n }"}, {"sha": "6017941452c06577873bd207be73c62512fe13da", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -420,9 +420,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                         if trait_predicates.any(|predicate| {\n                             let predicate = EarlyBinder(predicate).subst(cx.tcx, new_subst);\n                             let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n-                            !cx.tcx\n-                                .infer_ctxt()\n-                                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+                            !cx.tcx.infer_ctxt().build().predicate_must_hold_modulo_regions(&obligation)\n                         }) {\n                             return false;\n                         }"}, {"sha": "7f881e27dd27c39e542ab9b96a1a79316d6df786", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -138,10 +138,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             ..\n         } = {\n             let mut ctx = MovedVariablesCtxt::default();\n-            cx.tcx.infer_ctxt().enter(|infcx| {\n-                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-                    .consume_body(body);\n-            });\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n             ctx\n         };\n "}, {"sha": "c7e964cf23e2c00d62d7c2b7ada106b668768c11", "filename": "src/tools/clippy/clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -123,16 +123,15 @@ fn imm_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet\n     }\n \n     let mut s = S(hir::HirIdSet::default());\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        let mut v = ExprUseVisitor::new(\n-            &mut s,\n-            &infcx,\n-            cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n-            cx.param_env,\n-            cx.typeck_results(),\n-        );\n-        v.consume_expr(e);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let mut v = ExprUseVisitor::new(\n+        &mut s,\n+        &infcx,\n+        cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n+        cx.param_env,\n+        cx.typeck_results(),\n+    );\n+    v.consume_expr(e);\n     s.0\n }\n \n@@ -156,15 +155,14 @@ fn mut_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet\n     }\n \n     let mut s = S(hir::HirIdSet::default());\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        let mut v = ExprUseVisitor::new(\n-            &mut s,\n-            &infcx,\n-            cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n-            cx.param_env,\n-            cx.typeck_results(),\n-        );\n-        v.consume_expr(e);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let mut v = ExprUseVisitor::new(\n+        &mut s,\n+        &infcx,\n+        cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n+        cx.param_env,\n+        cx.typeck_results(),\n+    );\n+    v.consume_expr(e);\n     s.0\n }"}, {"sha": "3c5dd92b9cd6d050a8db203756527ef923d7a48a", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -821,10 +821,9 @@ pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'\n         };\n \n         let fn_def_id = cx.tcx.hir().local_def_id(closure.hir_id);\n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-                .consume_body(closure_body);\n-        });\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+            .consume_body(closure_body);\n \n         if !visitor.suggestion_start.is_empty() {\n             return Some(DerefClosure {"}, {"sha": "a15daec7c3ce3ed77f0a284c185c01eb5a07531d", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -172,11 +172,10 @@ pub fn implements_trait_with_env<'tcx>(\n         return false;\n     }\n     let ty_params = tcx.mk_substs(ty_params.iter());\n-    tcx.infer_ctxt().enter(|infcx| {\n-        infcx\n-            .type_implements_trait(trait_id, ty, ty_params, param_env)\n-            .must_apply_modulo_regions()\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    infcx\n+        .type_implements_trait(trait_id, ty, ty_params, param_env)\n+        .must_apply_modulo_regions()\n }\n \n /// Checks whether this type implements `Drop`.\n@@ -242,27 +241,26 @@ fn is_normalizable_helper<'tcx>(\n     }\n     // prevent recursive loops, false-negative is better than endless loop leading to stack overflow\n     cache.insert(ty, false);\n-    let result = cx.tcx.infer_ctxt().enter(|infcx| {\n-        let cause = rustc_middle::traits::ObligationCause::dummy();\n-        if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n-            match ty.kind() {\n-                ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n-                }),\n-                _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n-                    GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n-                        is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    },\n-                    _ => true, // if inner_ty == ty, we've already checked it\n-                }),\n-            }\n-        } else {\n-            false\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let cause = rustc_middle::traits::ObligationCause::dummy();\n+    let result = if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n+        match ty.kind() {\n+            ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n+                variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n+            }),\n+            _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n+                GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n+                    is_normalizable_helper(cx, param_env, inner_ty, cache)\n+                },\n+                _ => true, // if inner_ty == ty, we've already checked it\n+            }),\n         }\n-    });\n+    } else {\n+        false\n+    };\n     cache.insert(ty, result);\n     result\n }"}, {"sha": "e32bae6ed1fd44af99562cff05263351f54ea1dc", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c22af267fd9337bc05382b2771dde49d2e9f26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=43c22af267fd9337bc05382b2771dde49d2e9f26", "patch": "@@ -18,16 +18,15 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n         used_mutably: HirIdSet::default(),\n         skip: false,\n     };\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(\n-            &mut delegate,\n-            &infcx,\n-            expr.hir_id.owner.def_id,\n-            cx.param_env,\n-            cx.typeck_results(),\n-        )\n-        .walk_expr(expr);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    ExprUseVisitor::new(\n+        &mut delegate,\n+        &infcx,\n+        expr.hir_id.owner.def_id,\n+        cx.param_env,\n+        cx.typeck_results(),\n+    )\n+    .walk_expr(expr);\n \n     if delegate.skip {\n         return None;"}]}