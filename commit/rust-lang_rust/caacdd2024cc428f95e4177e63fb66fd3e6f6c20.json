{"sha": "caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYWNkZDIwMjRjYzQyOGY5NWU0MTc3ZTYzZmI2NmZkM2U2ZjZjMjA=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-02-25T08:47:07Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T09:23:54Z"}, "message": "Move region_constraint to the unified undo log", "tree": {"sha": "08fd8c6de01a160a0f202957308b62302b214b41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08fd8c6de01a160a0f202957308b62302b214b41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "html_url": "https://github.com/rust-lang/rust/commit/caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/comments", "author": null, "committer": null, "parents": [{"sha": "1506b1fc6a42dda3e56789f43587448cc5bf4a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/1506b1fc6a42dda3e56789f43587448cc5bf4a36", "html_url": "https://github.com/rust-lang/rust/commit/1506b1fc6a42dda3e56789f43587448cc5bf4a36"}], "stats": {"total": 367, "additions": 196, "deletions": 171}, "files": [{"sha": "45c298ea8bfcde783128aa4f746b20365364824e", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -987,7 +987,17 @@ dependencies = [\n [[package]]\n name = \"ena\"\n version = \"0.13.1\"\n-source = \"git+https://github.com/Marwes/ena?branch=detach_undo_log#9b977ea7f209a35f46d65d33cdd74b8f4931fb8a\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8944dc8fa28ce4a38f778bd46bf7d923fe73eed5a439398507246c8e017e6f36\"\n+dependencies = [\n+ \"log\",\n+]\n+\n+[[package]]\n+name = \"ena\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n dependencies = [\n  \"log\",\n ]\n@@ -3234,7 +3244,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena\",\n+ \"ena 0.13.1\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static 1.4.0\",\n@@ -3680,7 +3690,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena\",\n+ \"ena 0.14.0\",\n  \"graphviz\",\n  \"indexmap\",\n  \"jobserver\","}, {"sha": "7b5e0fa1c281787b2d2cff8aa6dd737fab06c228", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -65,7 +65,5 @@ rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n rustc-std-workspace-std = { path = 'src/tools/rustc-std-workspace-std' }\n \n-ena = { version = \"0.13.1\", git = \"https://github.com/Marwes/ena\", branch = \"detach_undo_log\" }\n-\n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "e257ada0629b22c39f01ecaa77c7eb01d1c0b5b7", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-ena = \"0.13.1\"\n+ena = \"0.14\"\n indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }"}, {"sha": "ed99b47f80c7c1bb86510484d38111ab0b56c531", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -45,7 +45,9 @@ use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n+use self::region_constraints::{\n+    RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n+};\n use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n@@ -161,7 +163,7 @@ pub struct InferCtxtInner<'tcx> {\n     /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n     /// -- further attempts to perform unification, etc., may fail if new\n     /// region constraints would've been added.\n-    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n+    region_constraints: Option<RegionConstraintStorage<'tcx>>,\n \n     /// A set of constraints that regionck must validate. Each\n     /// constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -206,7 +208,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n             const_unification_table: ut::UnificationStorage::new(),\n             int_unification_table: ut::UnificationStorage::new(),\n             float_unification_table: ut::UnificationStorage::new(),\n-            region_constraints: Some(RegionConstraintCollector::new()),\n+            region_constraints: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n         }\n     }\n@@ -243,8 +245,11 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         ut::UnificationTable::with_log(&mut self.const_unification_table, &mut self.undo_log)\n     }\n \n-    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n-        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n+    pub fn unwrap_region_constraints(&mut self) -> RegionConstraintCollector<'tcx, '_> {\n+        self.region_constraints\n+            .as_mut()\n+            .expect(\"region constraints already solved\")\n+            .with_log(&mut self.undo_log)\n     }\n }\n \n@@ -258,6 +263,14 @@ pub(crate) enum UndoLog<'tcx> {\n     ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n     IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n     FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n+    RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n+    RegionUnificationTable(sv::UndoLog<ut::Delegate<ty::RegionVid>>),\n+}\n+\n+impl<'tcx> From<region_constraints::UndoLog<'tcx>> for UndoLog<'tcx> {\n+    fn from(l: region_constraints::UndoLog<'tcx>) -> Self {\n+        UndoLog::RegionConstraintCollector(l)\n+    }\n }\n \n impl<'tcx> From<sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>> for UndoLog<'tcx> {\n@@ -308,6 +321,12 @@ impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::FloatVid>>> for UndoLog<'tcx> {\n     }\n }\n \n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::RegionVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::RegionVid>>) -> Self {\n+        Self::RegionUnificationTable(l)\n+    }\n+}\n+\n pub(crate) type UnificationTable<'a, 'tcx, T> =\n     ut::UnificationTable<ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut Logs<'tcx>>>;\n \n@@ -316,6 +335,7 @@ struct RollbackView<'tcx, 'a> {\n     const_unification_table: &'a mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n     int_unification_table: &'a mut ut::UnificationStorage<ty::IntVid>,\n     float_unification_table: &'a mut ut::UnificationStorage<ty::FloatVid>,\n+    region_constraints: &'a mut RegionConstraintStorage<'tcx>,\n }\n \n impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n@@ -325,6 +345,10 @@ impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n             UndoLog::ConstUnificationTable(undo) => self.const_unification_table.reverse(undo),\n             UndoLog::IntUnificationTable(undo) => self.int_unification_table.reverse(undo),\n             UndoLog::FloatUnificationTable(undo) => self.float_unification_table.reverse(undo),\n+            UndoLog::RegionConstraintCollector(undo) => self.region_constraints.reverse(undo),\n+            UndoLog::RegionUnificationTable(undo) => {\n+                self.region_constraints.unification_table.reverse(undo)\n+            }\n         }\n     }\n }\n@@ -408,6 +432,16 @@ impl<'tcx> Snapshots<UndoLog<'tcx>> for Logs<'tcx> {\n }\n \n impl<'tcx> Logs<'tcx> {\n+    pub(crate) fn region_constraints(\n+        &self,\n+        after: usize,\n+    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n+        self.logs[after..].iter().filter_map(|log| match log {\n+            UndoLog::RegionConstraintCollector(log) => Some(log),\n+            _ => None,\n+        })\n+    }\n+\n     fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n         // Failures here may indicate a failure to follow a stack discipline.\n         assert!(self.logs.len() >= snapshot.undo_len);\n@@ -1004,7 +1038,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             const_snapshot: _,\n             int_snapshot: _,\n             float_snapshot: _,\n-            region_constraints_snapshot,\n+            region_constraints_snapshot: _,\n             region_obligations_snapshot,\n             universe,\n             was_in_snapshot,\n@@ -1023,6 +1057,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             const_unification_table,\n             int_unification_table,\n             float_unification_table,\n+            region_constraints,\n             ..\n         } = inner;\n         inner.undo_log.rollback_to(\n@@ -1031,11 +1066,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 const_unification_table,\n                 int_unification_table,\n                 float_unification_table,\n+                region_constraints: region_constraints.as_mut().unwrap(),\n             },\n             undo_snapshot,\n         );\n         inner.projection_cache.rollback_to(projection_cache_snapshot);\n-        inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n         inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n \n@@ -1048,7 +1083,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             const_snapshot: _,\n             int_snapshot: _,\n             float_snapshot: _,\n-            region_constraints_snapshot,\n+            region_constraints_snapshot: _,\n             region_obligations_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n@@ -1062,7 +1097,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let mut inner = self.inner.borrow_mut();\n         inner.undo_log.commit(undo_snapshot);\n         inner.projection_cache.commit(projection_cache_snapshot);\n-        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -1135,7 +1169,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner\n             .borrow_mut()\n             .unwrap_region_constraints()\n-            .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n+            .region_constraints_added_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n     pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n@@ -1466,6 +1500,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n+            .with_log(&mut inner.undo_log)\n             .into_infos_and_data();\n \n         let region_rels = &RegionRelations::new(\n@@ -1527,12 +1562,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region variables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self\n-            .inner\n-            .borrow_mut()\n+        let mut inner = self.inner.borrow_mut();\n+        let (var_infos, data) = inner\n             .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n+            .with_log(&mut inner.undo_log)\n             .into_infos_and_data();\n         assert!(data.is_empty());\n         var_infos"}, {"sha": "0178fa2eae6ee143a2e2641f6820ef86359dad16", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -1,9 +1,10 @@\n use super::*;\n use crate::infer::{CombinedSnapshot, PlaceholderMap};\n+use rustc_data_structures::undo_log::UndoLogs;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::RelateResult;\n \n-impl<'tcx> RegionConstraintCollector<'tcx> {\n+impl<'tcx> RegionConstraintCollector<'tcx, '_> {\n     /// Searches region constraints created since `snapshot` that\n     /// affect one of the placeholders in `placeholder_map`, returning\n     /// an error if any of the placeholders are related to another\n@@ -31,7 +32,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ) -> RelateResult<'tcx, ()> {\n         debug!(\"leak_check(placeholders={:?})\", placeholder_map);\n \n-        assert!(self.in_snapshot());\n+        assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n         // Go through each placeholder that we created.\n         for &placeholder_region in placeholder_map.values() {\n@@ -45,7 +46,11 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             // in some way. This means any region that either outlives\n             // or is outlived by a placeholder.\n             let mut taint_set = TaintSet::new(TaintDirections::both(), placeholder_region);\n-            taint_set.fixed_point(tcx, &self.undo_log, &self.data.verifys);\n+            taint_set.fixed_point(\n+                tcx,\n+                self.undo_log.region_constraints(0),\n+                &self.storage.data.verifys,\n+            );\n             let tainted_regions = taint_set.into_set();\n \n             // Report an error if two placeholders in the same universe\n@@ -88,19 +93,21 @@ impl<'tcx> TaintSet<'tcx> {\n         TaintSet { directions, regions }\n     }\n \n-    fn fixed_point(\n+    fn fixed_point<'a>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        undo_log: &[UndoLog<'tcx>],\n+        undo_log: impl IntoIterator<Item = &'a UndoLog<'tcx>> + Clone,\n         verifys: &[Verify<'tcx>],\n-    ) {\n+    ) where\n+        'tcx: 'a,\n+    {\n         let mut prev_len = 0;\n         while prev_len < self.len() {\n             debug!(\"tainted: prev_len = {:?} new_len = {:?}\", prev_len, self.len());\n \n             prev_len = self.len();\n \n-            for undo_entry in undo_log {\n+            for undo_entry in undo_log.clone() {\n                 match undo_entry {\n                     &AddConstraint(Constraint::VarSubVar(a, b)) => {\n                         self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));"}, {"sha": "7b660ce436559c5e224927da4448b6d0015d0fbe", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 118, "deletions": 131, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -4,11 +4,13 @@ use self::CombineMapType::*;\n use self::UndoLog::*;\n \n use super::unify_key;\n-use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n+use super::{Logs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify as ut;\n+use rustc_data_structures::unify::UnifyKey;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::ReStatic;\n@@ -26,7 +28,7 @@ mod leak_check;\n pub use rustc_middle::infer::MemberConstraint;\n \n #[derive(Default)]\n-pub struct RegionConstraintCollector<'tcx> {\n+pub struct RegionConstraintStorage<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n     var_infos: IndexVec<RegionVid, RegionVariableInfo>,\n \n@@ -42,20 +44,6 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// exist). This prevents us from making many such regions.\n     glbs: CombineMap<'tcx>,\n \n-    /// The undo log records actions that might later be undone.\n-    ///\n-    /// Note: `num_open_snapshots` is used to track if we are actively\n-    /// snapshotting. When the `start_snapshot()` method is called, we\n-    /// increment `num_open_snapshots` to indicate that we are now actively\n-    /// snapshotting. The reason for this is that otherwise we end up adding\n-    /// entries for things like the lower bound on a variable and so forth,\n-    /// which can never be rolled back.\n-    undo_log: Vec<UndoLog<'tcx>>,\n-\n-    /// The number of open snapshots, i.e., those that haven't been committed or\n-    /// rolled back.\n-    num_open_snapshots: usize,\n-\n     /// When we add a R1 == R2 constriant, we currently add (a) edges\n     /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this\n     /// table. You can then call `opportunistic_resolve_var` early\n@@ -64,13 +52,31 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// is iterating to a fixed point, because otherwise we sometimes\n     /// would wind up with a fresh stream of region variables that\n     /// have been equated but appear distinct.\n-    unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n+    pub(super) unification_table: ut::UnificationStorage<ty::RegionVid>,\n \n     /// a flag set to true when we perform any unifications; this is used\n     /// to micro-optimize `take_and_reset_data`\n     any_unifications: bool,\n }\n \n+pub struct RegionConstraintCollector<'tcx, 'a> {\n+    storage: &'a mut RegionConstraintStorage<'tcx>,\n+    undo_log: &'a mut Logs<'tcx>,\n+}\n+\n+impl std::ops::Deref for RegionConstraintCollector<'tcx, '_> {\n+    type Target = RegionConstraintStorage<'tcx>;\n+    fn deref(&self) -> &RegionConstraintStorage<'tcx> {\n+        self.storage\n+    }\n+}\n+\n+impl std::ops::DerefMut for RegionConstraintCollector<'tcx, '_> {\n+    fn deref_mut(&mut self) -> &mut RegionConstraintStorage<'tcx> {\n+        self.storage\n+    }\n+}\n+\n pub type VarInfos = IndexVec<RegionVid, RegionVariableInfo>;\n \n /// The full set of region constraints gathered up by the collector.\n@@ -258,13 +264,13 @@ pub enum VerifyBound<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-struct TwoRegions<'tcx> {\n+pub(crate) struct TwoRegions<'tcx> {\n     a: Region<'tcx>,\n     b: Region<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum UndoLog<'tcx> {\n+pub(crate) enum UndoLog<'tcx> {\n     /// We added `RegionVid`.\n     AddVar(RegionVid),\n \n@@ -290,7 +296,7 @@ enum UndoLog<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum CombineMapType {\n+pub(crate) enum CombineMapType {\n     Lub,\n     Glb,\n }\n@@ -304,8 +310,7 @@ pub struct RegionVariableInfo {\n }\n \n pub struct RegionSnapshot {\n-    length: usize,\n-    region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n+    value_count: usize,\n     any_unifications: bool,\n }\n \n@@ -334,11 +339,48 @@ impl TaintDirections {\n     }\n }\n \n-impl<'tcx> RegionConstraintCollector<'tcx> {\n+impl<'tcx> RegionConstraintStorage<'tcx> {\n     pub fn new() -> Self {\n         Self::default()\n     }\n \n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut Logs<'tcx>,\n+    ) -> RegionConstraintCollector<'tcx, 'a> {\n+        RegionConstraintCollector { storage: self, undo_log }\n+    }\n+\n+    fn rollback_undo_entry(&mut self, undo_entry: UndoLog<'tcx>) {\n+        match undo_entry {\n+            Purged => {\n+                // nothing to do here\n+            }\n+            AddVar(vid) => {\n+                self.var_infos.pop().unwrap();\n+                assert_eq!(self.var_infos.len(), vid.index() as usize);\n+            }\n+            AddConstraint(ref constraint) => {\n+                self.data.constraints.remove(constraint);\n+            }\n+            AddVerify(index) => {\n+                self.data.verifys.pop();\n+                assert_eq!(self.data.verifys.len(), index);\n+            }\n+            AddGiven(sub, sup) => {\n+                self.data.givens.remove(&(sub, sup));\n+            }\n+            AddCombination(Glb, ref regions) => {\n+                self.glbs.remove(regions);\n+            }\n+            AddCombination(Lub, ref regions) => {\n+                self.lubs.remove(regions);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionConstraintCollector<'tcx, '_> {\n     pub fn num_region_vars(&self) -> usize {\n         self.var_infos.len()\n     }\n@@ -351,8 +393,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ///\n     /// Not legal during a snapshot.\n     pub fn into_infos_and_data(self) -> (VarInfos, RegionConstraintData<'tcx>) {\n-        assert!(!self.in_snapshot());\n-        (self.var_infos, self.data)\n+        assert!(!UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n+        (mem::take(&mut self.storage.var_infos), mem::take(&mut self.storage.data))\n     }\n \n     /// Takes (and clears) the current set of constraints. Note that\n@@ -368,21 +410,19 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ///\n     /// Not legal during a snapshot.\n     pub fn take_and_reset_data(&mut self) -> RegionConstraintData<'tcx> {\n-        assert!(!self.in_snapshot());\n+        assert!(!UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n         // If you add a new field to `RegionConstraintCollector`, you\n         // should think carefully about whether it needs to be cleared\n         // or updated in some way.\n-        let RegionConstraintCollector {\n+        let RegionConstraintStorage {\n             var_infos: _,\n             data,\n             lubs,\n             glbs,\n-            undo_log: _,\n-            num_open_snapshots: _,\n-            unification_table,\n+            unification_table: _,\n             any_unifications,\n-        } = self;\n+        } = self.storage;\n \n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n@@ -391,114 +431,48 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         lubs.clear();\n         glbs.clear();\n \n+        let data = mem::take(data);\n+\n         // Clear all unifications and recreate the variables a \"now\n         // un-unified\" state. Note that when we unify `a` and `b`, we\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n         if *any_unifications {\n-            unification_table.reset_unifications(|vid| unify_key::RegionVidKey { min_vid: vid });\n             *any_unifications = false;\n+            self.unification_table()\n+                .reset_unifications(|vid| unify_key::RegionVidKey { min_vid: vid });\n         }\n \n-        mem::take(data)\n+        data\n     }\n \n     pub fn data(&self) -> &RegionConstraintData<'tcx> {\n         &self.data\n     }\n \n-    fn in_snapshot(&self) -> bool {\n-        self.num_open_snapshots > 0\n-    }\n-\n     pub fn start_snapshot(&mut self) -> RegionSnapshot {\n-        let length = self.undo_log.len();\n-        debug!(\"RegionConstraintCollector: start_snapshot({})\", length);\n-        self.num_open_snapshots += 1;\n+        debug!(\"RegionConstraintCollector: start_snapshot\");\n         RegionSnapshot {\n-            length,\n-            region_snapshot: self.unification_table.snapshot(),\n+            value_count: self.unification_table.len(),\n             any_unifications: self.any_unifications,\n         }\n     }\n \n-    fn assert_open_snapshot(&self, snapshot: &RegionSnapshot) {\n-        assert!(self.undo_log.len() >= snapshot.length);\n-        assert!(self.num_open_snapshots > 0);\n-    }\n-\n-    pub fn commit(&mut self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionConstraintCollector: commit({})\", snapshot.length);\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if self.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n-            assert!(snapshot.length == 0);\n-            self.undo_log.clear();\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-\n-        self.unification_table.commit(snapshot.region_snapshot);\n-    }\n-\n     pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: rollback_to({:?})\", snapshot);\n-        self.assert_open_snapshot(&snapshot);\n-\n-        while self.undo_log.len() > snapshot.length {\n-            let undo_entry = self.undo_log.pop().unwrap();\n-            self.rollback_undo_entry(undo_entry);\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-\n-        self.unification_table.rollback_to(snapshot.region_snapshot);\n         self.any_unifications = snapshot.any_unifications;\n     }\n \n-    fn rollback_undo_entry(&mut self, undo_entry: UndoLog<'tcx>) {\n-        match undo_entry {\n-            Purged => {\n-                // nothing to do here\n-            }\n-            AddVar(vid) => {\n-                self.var_infos.pop().unwrap();\n-                assert_eq!(self.var_infos.len(), vid.index() as usize);\n-            }\n-            AddConstraint(ref constraint) => {\n-                self.data.constraints.remove(constraint);\n-            }\n-            AddVerify(index) => {\n-                self.data.verifys.pop();\n-                assert_eq!(self.data.verifys.len(), index);\n-            }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n-            AddCombination(Glb, ref regions) => {\n-                self.glbs.remove(regions);\n-            }\n-            AddCombination(Lub, ref regions) => {\n-                self.lubs.remove(regions);\n-            }\n-        }\n-    }\n-\n     pub fn new_region_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n         origin: RegionVariableOrigin,\n     ) -> RegionVid {\n         let vid = self.var_infos.push(RegionVariableInfo { origin, universe });\n \n-        let u_vid = self.unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n+        let u_vid = self.unification_table().new_key(unify_key::RegionVidKey { min_vid: vid });\n         assert_eq!(vid, u_vid);\n-        if self.in_snapshot() {\n-            self.undo_log.push(AddVar(vid));\n-        }\n+        self.undo_log.push(AddVar(vid));\n         debug!(\"created new region variable {:?} in {:?} with origin {:?}\", vid, universe, origin);\n         vid\n     }\n@@ -520,19 +494,30 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn pop_placeholders(&mut self, placeholders: &FxHashSet<ty::Region<'tcx>>) {\n         debug!(\"pop_placeholders(placeholders={:?})\", placeholders);\n \n-        assert!(self.in_snapshot());\n+        assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n         let constraints_to_kill: Vec<usize> = self\n             .undo_log\n+            .logs\n             .iter()\n             .enumerate()\n             .rev()\n-            .filter(|&(_, undo_entry)| kill_constraint(placeholders, undo_entry))\n+            .filter(|&(_, undo_entry)| match undo_entry {\n+                super::UndoLog::RegionConstraintCollector(undo_entry) => {\n+                    kill_constraint(placeholders, undo_entry)\n+                }\n+                _ => false,\n+            })\n             .map(|(index, _)| index)\n             .collect();\n \n         for index in constraints_to_kill {\n-            let undo_entry = mem::replace(&mut self.undo_log[index], Purged);\n+            let undo_entry = match &mut self.undo_log.logs[index] {\n+                super::UndoLog::RegionConstraintCollector(undo_entry) => {\n+                    mem::replace(undo_entry, Purged)\n+                }\n+                _ => unreachable!(),\n+            };\n             self.rollback_undo_entry(undo_entry);\n         }\n \n@@ -566,12 +551,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n         // replaced with \"less informative\" origins e.g., during calls to `can_eq`\n-        let in_snapshot = self.in_snapshot();\n         let undo_log = &mut self.undo_log;\n-        self.data.constraints.entry(constraint).or_insert_with(|| {\n-            if in_snapshot {\n-                undo_log.push(AddConstraint(constraint));\n-            }\n+        self.storage.data.constraints.entry(constraint).or_insert_with(|| {\n+            undo_log.push(AddConstraint(constraint));\n             origin\n         });\n     }\n@@ -589,19 +571,15 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         let index = self.data.verifys.len();\n         self.data.verifys.push(verify);\n-        if self.in_snapshot() {\n-            self.undo_log.push(AddVerify(index));\n-        }\n+        self.undo_log.push(AddVerify(index));\n     }\n \n     pub fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         if self.data.givens.insert((sub, sup)) {\n             debug!(\"add_given({:?} <= {:?})\", sub, sup);\n \n-            if self.in_snapshot() {\n-                self.undo_log.push(AddGiven(sub, sup));\n-            }\n+            self.undo_log.push(AddGiven(sub, sup));\n         }\n     }\n \n@@ -619,7 +597,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n             if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n                 debug!(\"make_eqregion: uniying {:?} with {:?}\", sub, sup);\n-                self.unification_table.union(sub, sup);\n+                self.unification_table().union(sub, sup);\n                 self.any_unifications = true;\n             }\n         }\n@@ -741,7 +719,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n-        let vid = self.unification_table.probe_value(rid).min_vid;\n+        let vid = self.unification_table().probe_value(rid).min_vid;\n         tcx.mk_region(ty::ReVar(vid))\n     }\n \n@@ -769,9 +747,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         let c_universe = cmp::max(a_universe, b_universe);\n         let c = self.new_region_var(c_universe, MiscVariable(origin.span()));\n         self.combine_map(t).insert(vars, c);\n-        if self.in_snapshot() {\n-            self.undo_log.push(AddCombination(t, vars));\n-        }\n+        self.undo_log.push(AddCombination(t, vars));\n         let new_r = tcx.mk_region(ReVar(c));\n         for &old_r in &[a, b] {\n             match t {\n@@ -801,7 +777,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         &self,\n         mark: &RegionSnapshot,\n     ) -> (Range<RegionVid>, Vec<RegionVariableOrigin>) {\n-        let range = self.unification_table.vars_since_snapshot(&mark.region_snapshot);\n+        let range = RegionVid::from_index(mark.value_count as u32)\n+            ..RegionVid::from_index(self.unification_table.len() as u32);\n         (\n             range.clone(),\n             (range.start.index()..range.end.index())\n@@ -810,22 +787,26 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         )\n     }\n \n-    /// See `InferCtxt::region_constraints_added_in_snapshot`.\n-    pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n-        self.undo_log[mark.length..]\n-            .iter()\n+    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n+    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'_>) -> Option<bool> {\n+        self.undo_log\n+            .region_constraints(mark.undo_len)\n             .map(|&elt| match elt {\n                 AddConstraint(constraint) => Some(constraint.involves_placeholders()),\n                 _ => None,\n             })\n             .max()\n             .unwrap_or(None)\n     }\n+\n+    fn unification_table(&mut self) -> super::UnificationTable<'_, 'tcx, ty::RegionVid> {\n+        ut::UnificationTable::with_log(&mut self.storage.unification_table, self.undo_log)\n+    }\n }\n \n impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"RegionSnapshot(length={})\", self.length)\n+        write!(f, \"RegionSnapshot\")\n     }\n }\n \n@@ -910,3 +891,9 @@ impl<'tcx> RegionConstraintData<'tcx> {\n             && givens.is_empty()\n     }\n }\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for RegionConstraintStorage<'tcx> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        self.rollback_undo_entry(undo)\n+    }\n+}"}, {"sha": "3858c50b92c6a7dbdcc0687e65d457439ee38f8b", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caacdd2024cc428f95e4177e63fb66fd3e6f6c20/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "patch": "@@ -344,23 +344,11 @@ impl<'tcx> TypeVariableTable<'tcx, '_> {\n         sv::SnapshotVec::with_log(self.values, self.undo_log)\n     }\n \n-    fn eq_relations(\n-        &mut self,\n-    ) -> ut::UnificationTable<\n-        ut::InPlace<\n-            TyVidEqKey<'tcx>,\n-            &mut ut::UnificationStorage<TyVidEqKey<'tcx>>,\n-            &mut Logs<'tcx>,\n-        >,\n-    > {\n+    fn eq_relations(&mut self) -> super::UnificationTable<'_, 'tcx, TyVidEqKey<'tcx>> {\n         ut::UnificationTable::with_log(self.eq_relations, self.undo_log)\n     }\n \n-    fn sub_relations(\n-        &mut self,\n-    ) -> ut::UnificationTable<\n-        ut::InPlace<ty::TyVid, &mut ut::UnificationStorage<ty::TyVid>, &mut Logs<'tcx>>,\n-    > {\n+    fn sub_relations(&mut self) -> super::UnificationTable<'_, 'tcx, ty::TyVid> {\n         ut::UnificationTable::with_log(self.sub_relations, self.undo_log)\n     }\n "}]}