{"sha": "8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MDRhNzRjZDVkMDJlZDRkZmU4OTdjMTIxODZhZjFjM2FjNjk3ZmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-19T11:18:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-19T11:18:09Z"}, "message": "Merge #1700\n\n1700: remove  ast::*Kind enums r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "382f5f5f5d6ba7182164c438ee5c4a1cb700fbb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382f5f5f5d6ba7182164c438ee5c4a1cb700fbb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWoVxCRBK7hj4Ov3rIwAAdHIIABEZrR+L7PmMVm/c9AeNMQcX\na9HhYkW+1+vKEDSHxBPtgJBMmeeeRXg+9cF9cXf1X46/OWCNwIgP4HxPIx3qxDqR\n054+6926Cub7CxTMdU0l5HnUVEzz+42ZVWPq0c+mofR0QQWT7lotSRHX7/e4eiNj\nO+7GByYeypga1FNb9YKgw/zlTmqD6h8mWPy9DAypcv+QFM+L1T4OHk06Yn0H5pAN\n4gQxEhPuYmonA5oancF8wsMlJJkmS8U0T3qIOfmBa+FvUoihuhkvsdNW5zv1dAOX\n5BrprL6Ons4YlyHuJlQJoslenCfAI2/iM1ShDWIAE83MP3WKuqKw8dAuodSk+Xc=\n=sKQZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 382f5f5f5d6ba7182164c438ee5c4a1cb700fbb8\nparent ba2836245b64fffd9c8107a4ed511eba90583d06\nparent df6dce23a7d1a87617939fb9bd61a4d65933cef5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1566213489 +0000\ncommitter GitHub <noreply@github.com> 1566213489 +0000\n\nMerge #1700\n\n1700: remove  ast::*Kind enums r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "html_url": "https://github.com/rust-lang/rust/commit/8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba2836245b64fffd9c8107a4ed511eba90583d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2836245b64fffd9c8107a4ed511eba90583d06", "html_url": "https://github.com/rust-lang/rust/commit/ba2836245b64fffd9c8107a4ed511eba90583d06"}, {"sha": "df6dce23a7d1a87617939fb9bd61a4d65933cef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/df6dce23a7d1a87617939fb9bd61a4d65933cef5", "html_url": "https://github.com/rust-lang/rust/commit/df6dce23a7d1a87617939fb9bd61a4d65933cef5"}], "stats": {"total": 1086, "additions": 547, "deletions": 539}, "files": [{"sha": "78f0f7f28a54c5efde3913c47bfe06075e718c69", "filename": "crates/ra_assists/src/add_explicit_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -1,6 +1,6 @@\n use hir::{db::HirDatabase, HirDisplay, Ty};\n use ra_syntax::{\n-    ast::{AstNode, LetStmt, NameOwner, PatKind},\n+    ast::{self, AstNode, LetStmt, NameOwner},\n     T,\n };\n \n@@ -12,8 +12,8 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n     let expr = stmt.initializer()?;\n     let pat = stmt.pat()?;\n     // Must be a binding\n-    let pat = match pat.kind() {\n-        PatKind::BindPat(bind_pat) => bind_pat,\n+    let pat = match pat {\n+        ast::Pat::BindPat(bind_pat) => bind_pat,\n         _ => return None,\n     };\n     let pat_range = pat.syntax().text_range();"}, {"sha": "31c7d4e804ee40192f72a79237ddd6636c251575", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -5,7 +5,7 @@ use crate::{\n \n use hir::{db::HirDatabase, HasSource};\n use ra_db::FilePosition;\n-use ra_syntax::ast::{self, AstNode, ImplItemKind, NameOwner};\n+use ra_syntax::ast::{self, AstNode, NameOwner};\n use ra_syntax::SmolStr;\n \n #[derive(PartialEq)]\n@@ -49,11 +49,11 @@ fn add_missing_impl_members_inner(\n         resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n     };\n \n-    let def_name = |kind| -> Option<SmolStr> {\n-        match kind {\n-            ast::ImplItemKind::FnDef(def) => def.name(),\n-            ast::ImplItemKind::TypeAliasDef(def) => def.name(),\n-            ast::ImplItemKind::ConstDef(def) => def.name(),\n+    let def_name = |item: &ast::ImplItem| -> Option<SmolStr> {\n+        match item {\n+            ast::ImplItem::FnDef(def) => def.name(),\n+            ast::ImplItem::TypeAliasDef(def) => def.name(),\n+            ast::ImplItem::ConstDef(def) => def.name(),\n         }\n         .map(|it| it.text().clone())\n     };\n@@ -62,24 +62,24 @@ fn add_missing_impl_members_inner(\n     let impl_items = impl_item_list.impl_items().collect::<Vec<_>>();\n \n     let missing_items: Vec<_> = trait_items\n-        .filter(|t| def_name(t.kind()).is_some())\n-        .filter(|t| match t.kind() {\n-            ImplItemKind::FnDef(def) => match mode {\n+        .filter(|t| def_name(t).is_some())\n+        .filter(|t| match t {\n+            ast::ImplItem::FnDef(def) => match mode {\n                 AddMissingImplMembersMode::DefaultMethodsOnly => def.body().is_some(),\n                 AddMissingImplMembersMode::NoDefaultMethods => def.body().is_none(),\n             },\n             _ => mode == AddMissingImplMembersMode::NoDefaultMethods,\n         })\n-        .filter(|t| impl_items.iter().all(|i| def_name(i.kind()) != def_name(t.kind())))\n+        .filter(|t| impl_items.iter().all(|i| def_name(i) != def_name(t)))\n         .collect();\n     if missing_items.is_empty() {\n         return None;\n     }\n \n     ctx.add_action(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n-        let items = missing_items.into_iter().map(|it| match it.kind() {\n-            ImplItemKind::FnDef(def) => strip_docstring(add_body(def).into()),\n+        let items = missing_items.into_iter().map(|it| match it {\n+            ast::ImplItem::FnDef(def) => strip_docstring(add_body(def).into()),\n             _ => strip_docstring(it),\n         });\n         let mut ast_editor = AstEditor::new(impl_item_list);"}, {"sha": "85ff5c052a990e785c3344cb318eb9a36e54a74c", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -7,12 +7,12 @@ use ra_syntax::ast::{self, AstNode};\n use crate::{Assist, AssistCtx, AssistId};\n \n fn is_trivial_arm(arm: &ast::MatchArm) -> bool {\n-    fn single_pattern(arm: &ast::MatchArm) -> Option<ast::PatKind> {\n+    fn single_pattern(arm: &ast::MatchArm) -> Option<ast::Pat> {\n         let (pat,) = arm.pats().collect_tuple()?;\n-        Some(pat.kind())\n+        Some(pat)\n     }\n     match single_pattern(arm) {\n-        Some(ast::PatKind::PlaceholderPat(..)) => true,\n+        Some(ast::Pat::PlaceholderPat(..)) => true,\n         _ => false,\n     }\n }"}, {"sha": "eedb2919943b9b66a6483804abe7ad0b6f375588", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -1,6 +1,6 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n-    ast::{self, AstNode, AstToken, ExprKind, PatKind},\n+    ast::{self, AstNode, AstToken},\n     TextRange,\n };\n \n@@ -9,8 +9,8 @@ use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let let_stmt = ctx.node_at_offset::<ast::LetStmt>()?;\n-    let bind_pat = match let_stmt.pat()?.kind() {\n-        PatKind::BindPat(pat) => pat,\n+    let bind_pat = match let_stmt.pat()? {\n+        ast::Pat::BindPat(pat) => pat,\n         _ => return None,\n     };\n     if bind_pat.is_mutable() {\n@@ -48,28 +48,28 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n             }\n         };\n \n-        wrap_in_parens[i] = match (initializer_expr.kind(), usage_parent.kind()) {\n-            (ExprKind::CallExpr(_), _)\n-            | (ExprKind::IndexExpr(_), _)\n-            | (ExprKind::MethodCallExpr(_), _)\n-            | (ExprKind::FieldExpr(_), _)\n-            | (ExprKind::TryExpr(_), _)\n-            | (ExprKind::RefExpr(_), _)\n-            | (ExprKind::Literal(_), _)\n-            | (ExprKind::TupleExpr(_), _)\n-            | (ExprKind::ArrayExpr(_), _)\n-            | (ExprKind::ParenExpr(_), _)\n-            | (ExprKind::PathExpr(_), _)\n-            | (ExprKind::BlockExpr(_), _)\n-            | (_, ExprKind::CallExpr(_))\n-            | (_, ExprKind::TupleExpr(_))\n-            | (_, ExprKind::ArrayExpr(_))\n-            | (_, ExprKind::ParenExpr(_))\n-            | (_, ExprKind::ForExpr(_))\n-            | (_, ExprKind::WhileExpr(_))\n-            | (_, ExprKind::BreakExpr(_))\n-            | (_, ExprKind::ReturnExpr(_))\n-            | (_, ExprKind::MatchExpr(_)) => false,\n+        wrap_in_parens[i] = match (&initializer_expr, usage_parent) {\n+            (ast::Expr::CallExpr(_), _)\n+            | (ast::Expr::IndexExpr(_), _)\n+            | (ast::Expr::MethodCallExpr(_), _)\n+            | (ast::Expr::FieldExpr(_), _)\n+            | (ast::Expr::TryExpr(_), _)\n+            | (ast::Expr::RefExpr(_), _)\n+            | (ast::Expr::Literal(_), _)\n+            | (ast::Expr::TupleExpr(_), _)\n+            | (ast::Expr::ArrayExpr(_), _)\n+            | (ast::Expr::ParenExpr(_), _)\n+            | (ast::Expr::PathExpr(_), _)\n+            | (ast::Expr::BlockExpr(_), _)\n+            | (_, ast::Expr::CallExpr(_))\n+            | (_, ast::Expr::TupleExpr(_))\n+            | (_, ast::Expr::ArrayExpr(_))\n+            | (_, ast::Expr::ParenExpr(_))\n+            | (_, ast::Expr::ForExpr(_))\n+            | (_, ast::Expr::WhileExpr(_))\n+            | (_, ast::Expr::BreakExpr(_))\n+            | (_, ast::Expr::ReturnExpr(_))\n+            | (_, ast::Expr::MatchExpr(_)) => false,\n             _ => true,\n         };\n     }"}, {"sha": "225a48d3adc60ea953a0bbfe9f0e6213780f9ccf", "filename": "crates/ra_assists/src/merge_match_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_assists%2Fsrc%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmerge_match_arms.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -30,8 +30,8 @@ pub(crate) fn merge_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<A\n \n     ctx.add_action(AssistId(\"merge_match_arms\"), \"merge match arms\", |edit| {\n         fn contains_placeholder(a: &MatchArm) -> bool {\n-            a.pats().any(|x| match x.kind() {\n-                ra_syntax::ast::PatKind::PlaceholderPat(..) => true,\n+            a.pats().any(|x| match x {\n+                ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n                 _ => false,\n             })\n         }"}, {"sha": "328d635d4580f53c7f8964c8b516d622ed86a6e6", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -602,8 +602,8 @@ where\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n-        match expr.kind() {\n-            ast::ExprKind::IfExpr(e) => {\n+        match expr {\n+            ast::Expr::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n \n                 let else_branch = e.else_branch().map(|b| match b {\n@@ -639,16 +639,16 @@ where\n \n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n-            ast::ExprKind::TryBlockExpr(e) => {\n+            ast::Expr::TryBlockExpr(e) => {\n                 let body = self.collect_block_opt(e.try_body());\n                 self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n             }\n-            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n-            ast::ExprKind::LoopExpr(e) => {\n+            ast::Expr::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n-            ast::ExprKind::WhileExpr(e) => {\n+            ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n \n                 let condition = match e.condition() {\n@@ -675,13 +675,13 @@ where\n \n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n-            ast::ExprKind::ForExpr(e) => {\n+            ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n             }\n-            ast::ExprKind::CallExpr(e) => {\n+            ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -690,7 +690,7 @@ where\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n-            ast::ExprKind::MethodCallExpr(e) => {\n+            ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -704,7 +704,7 @@ where\n                     syntax_ptr,\n                 )\n             }\n-            ast::ExprKind::MatchExpr(e) => {\n+            ast::Expr::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n@@ -723,30 +723,30 @@ where\n                 };\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n-            ast::ExprKind::PathExpr(e) => {\n+            ast::Expr::PathExpr(e) => {\n                 let path =\n                     e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::ExprKind::ContinueExpr(_e) => {\n+            ast::Expr::ContinueExpr(_e) => {\n                 // FIXME: labels\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n-            ast::ExprKind::BreakExpr(e) => {\n+            ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::ParenExpr(e) => {\n+            ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 self.source_map.expr_map.insert(syntax_ptr, inner);\n                 inner\n             }\n-            ast::ExprKind::ReturnExpr(e) => {\n+            ast::Expr::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::StructLit(e) => {\n+            ast::Expr::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n                 let mut field_ptrs = Vec::new();\n                 let struct_lit = if let Some(nfl) = e.named_field_list() {\n@@ -787,41 +787,41 @@ where\n                 }\n                 res\n             }\n-            ast::ExprKind::FieldExpr(e) => {\n+            ast::Expr::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n-            ast::ExprKind::AwaitExpr(e) => {\n+            ast::Expr::AwaitExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::TryExpr(e) => {\n+            ast::Expr::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::CastExpr(e) => {\n+            ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n-            ast::ExprKind::RefExpr(e) => {\n+            ast::Expr::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let mutability = Mutability::from_mutable(e.is_mut());\n                 self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n             }\n-            ast::ExprKind::PrefixExpr(e) => {\n+            ast::Expr::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 if let Some(op) = e.op_kind() {\n                     self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n                 } else {\n                     self.alloc_expr(Expr::Missing, syntax_ptr)\n                 }\n             }\n-            ast::ExprKind::LambdaExpr(e) => {\n+            ast::Expr::LambdaExpr(e) => {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -835,18 +835,18 @@ where\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n             }\n-            ast::ExprKind::BinExpr(e) => {\n+            ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op_kind().map(BinaryOp::from);\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n-            ast::ExprKind::TupleExpr(e) => {\n+            ast::Expr::TupleExpr(e) => {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n \n-            ast::ExprKind::ArrayExpr(e) => {\n+            ast::Expr::ArrayExpr(e) => {\n                 let kind = e.kind();\n \n                 match kind {\n@@ -865,7 +865,7 @@ where\n                 }\n             }\n \n-            ast::ExprKind::Literal(e) => {\n+            ast::Expr::Literal(e) => {\n                 let lit = match e.kind() {\n                     LiteralKind::IntNumber { suffix } => {\n                         let known_name = suffix\n@@ -895,16 +895,16 @@ where\n                 };\n                 self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n             }\n-            ast::ExprKind::IndexExpr(e) => {\n+            ast::Expr::IndexExpr(e) => {\n                 let base = self.collect_expr_opt(e.base());\n                 let index = self.collect_expr_opt(e.index());\n                 self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n             }\n \n             // FIXME implement HIR for these:\n-            ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::MacroCall(e) => {\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::MacroCall(e) => {\n                 let ast_id = self\n                     .db\n                     .ast_id_map(self.current_file_id)\n@@ -945,16 +945,14 @@ where\n     fn collect_block(&mut self, block: ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n-            .map(|s| match s.kind() {\n-                ast::StmtKind::LetStmt(stmt) => {\n+            .map(|s| match s {\n+                ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }\n-                ast::StmtKind::ExprStmt(stmt) => {\n-                    Statement::Expr(self.collect_expr_opt(stmt.expr()))\n-                }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -970,33 +968,33 @@ where\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pattern = match pat.kind() {\n-            ast::PatKind::BindPat(bp) => {\n+        let pattern = match &pat {\n+            ast::Pat::BindPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n                 let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n                 Pat::Bind { name, mode: annotation, subpat }\n             }\n-            ast::PatKind::TupleStructPat(p) => {\n+            ast::Pat::TupleStructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::TupleStruct { path, args }\n             }\n-            ast::PatKind::RefPat(p) => {\n+            ast::Pat::RefPat(p) => {\n                 let pat = self.collect_pat_opt(p.pat());\n                 let mutability = Mutability::from_mutable(p.is_mut());\n                 Pat::Ref { pat, mutability }\n             }\n-            ast::PatKind::PathPat(p) => {\n+            ast::Pat::PathPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n-            ast::PatKind::TuplePat(p) => {\n+            ast::Pat::TuplePat(p) => {\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::Tuple(args)\n             }\n-            ast::PatKind::PlaceholderPat(_) => Pat::Wild,\n-            ast::PatKind::StructPat(p) => {\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n+            ast::Pat::StructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 let field_pat_list =\n                     p.field_pat_list().expect(\"every struct should have a field list\");\n@@ -1022,8 +1020,8 @@ where\n             }\n \n             // FIXME: implement\n-            ast::PatKind::LiteralPat(_) => Pat::Missing,\n-            ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n+            ast::Pat::LiteralPat(_) => Pat::Missing,\n+            ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n         };\n         let ptr = AstPtr::new(&pat);\n         self.alloc_pat(pattern, Either::A(ptr))"}, {"sha": "e6482180d5cbacd4304829e3971583fd32125511", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -137,8 +137,8 @@ impl GenericParams {\n     fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n         let path = bound\n             .type_ref()\n-            .and_then(|tr| match tr.kind() {\n-                ast::TypeRefKind::PathType(path) => path.path(),\n+            .and_then(|tr| match tr {\n+                ast::TypeRef::PathType(path) => path.path(),\n                 _ => None,\n             })\n             .and_then(Path::from_ast);"}, {"sha": "62a41719a424a7d7ee59bfb88663c205ede43d99", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -131,10 +131,10 @@ impl ImplData {\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n-                .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {"}, {"sha": "2f973359fe02438f190d54d50a0eecfad7cecfae", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -207,24 +207,24 @@ impl RawItemsCollector {\n     }\n \n     fn add_item(&mut self, current_module: Option<Module>, item: ast::ModuleItem) {\n-        let (kind, name) = match item.kind() {\n-            ast::ModuleItemKind::Module(module) => {\n+        let (kind, name) = match item {\n+            ast::ModuleItem::Module(module) => {\n                 self.add_module(current_module, module);\n                 return;\n             }\n-            ast::ModuleItemKind::UseItem(use_item) => {\n+            ast::ModuleItem::UseItem(use_item) => {\n                 self.add_use_item(current_module, use_item);\n                 return;\n             }\n-            ast::ModuleItemKind::ExternCrateItem(extern_crate) => {\n+            ast::ModuleItem::ExternCrateItem(extern_crate) => {\n                 self.add_extern_crate_item(current_module, extern_crate);\n                 return;\n             }\n-            ast::ModuleItemKind::ImplBlock(_) => {\n+            ast::ModuleItem::ImplBlock(_) => {\n                 // impls don't participate in name resolution\n                 return;\n             }\n-            ast::ModuleItemKind::StructDef(it) => {\n+            ast::ModuleItem::StructDef(it) => {\n                 let id = self.source_ast_id_map.ast_id(&it);\n                 let name = it.name();\n                 if it.is_union() {\n@@ -233,22 +233,22 @@ impl RawItemsCollector {\n                     (DefKind::Struct(id), name)\n                 }\n             }\n-            ast::ModuleItemKind::EnumDef(it) => {\n+            ast::ModuleItem::EnumDef(it) => {\n                 (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::FnDef(it) => {\n+            ast::ModuleItem::FnDef(it) => {\n                 (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::TraitDef(it) => {\n+            ast::ModuleItem::TraitDef(it) => {\n                 (DefKind::Trait(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::TypeAliasDef(it) => {\n+            ast::ModuleItem::TypeAliasDef(it) => {\n                 (DefKind::TypeAlias(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::ConstDef(it) => {\n+            ast::ModuleItem::ConstDef(it) => {\n                 (DefKind::Const(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::StaticDef(it) => {\n+            ast::ModuleItem::StaticDef(it) => {\n                 (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n         };"}, {"sha": "6cdd3020afdd441b908bed629179d9f8d6fa61ba", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -30,10 +30,10 @@ impl TraitData {\n         let items = if let Some(item_list) = src.ast.item_list() {\n             item_list\n                 .impl_items()\n-                .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {"}, {"sha": "b92a0b55acdaaddb6b934ce258b8ea64d015ae5a", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -57,28 +57,33 @@ pub enum TypeRef {\n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n     pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n-        use ra_syntax::ast::TypeRefKind::*;\n-        match node.kind() {\n-            ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            TupleType(inner) => TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect()),\n-            NeverType(..) => TypeRef::Never,\n-            PathType(inner) => {\n+        match node {\n+            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::TupleType(inner) => {\n+                TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect())\n+            }\n+            ast::TypeRef::NeverType(..) => TypeRef::Never,\n+            ast::TypeRef::PathType(inner) => {\n                 inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n             }\n-            PointerType(inner) => {\n+            ast::TypeRef::PointerType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.is_mut());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n-            ArrayType(inner) => TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref()))),\n-            SliceType(inner) => TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref()))),\n-            ReferenceType(inner) => {\n+            ast::TypeRef::ArrayType(inner) => {\n+                TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+            }\n+            ast::TypeRef::SliceType(inner) => {\n+                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+            }\n+            ast::TypeRef::ReferenceType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.is_mut());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n-            PlaceholderType(_inner) => TypeRef::Placeholder,\n-            FnPointerType(inner) => {\n+            ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n+            ast::TypeRef::FnPointerType(inner) => {\n                 let ret_ty = TypeRef::from_ast_opt(inner.ret_type().and_then(|rt| rt.type_ref()));\n                 let mut params = if let Some(pl) = inner.param_list() {\n                     pl.params().map(|p| p.ascribed_type()).map(TypeRef::from_ast_opt).collect()\n@@ -89,9 +94,9 @@ impl TypeRef {\n                 TypeRef::Fn(params)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            ImplTraitType(_inner) => TypeRef::Error,\n-            DynTraitType(_inner) => TypeRef::Error,\n+            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ImplTraitType(_inner) => TypeRef::Error,\n+            ast::TypeRef::DynTraitType(_inner) => TypeRef::Error,\n         }\n     }\n "}, {"sha": "d5e11652663490ecb686c628edff658fb4582303", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -91,8 +91,8 @@ impl FnCallNode {\n \n     fn name_ref(&self) -> Option<ast::NameRef> {\n         match self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n-                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n+            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()? {\n+                ast::Expr::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n                 _ => return None,\n             }),\n "}, {"sha": "c5620dd522f6578ef17116b9e5d314b2ca76a3ff", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -33,13 +33,11 @@ fn impls_for_def(\n     node: &ast::NominalDef,\n     module: hir::Module,\n ) -> Option<Vec<NavigationTarget>> {\n-    let ty = match node.kind() {\n-        ast::NominalDefKind::StructDef(def) => {\n+    let ty = match node {\n+        ast::NominalDef::StructDef(def) => {\n             source_binder::struct_from_module(db, module, &def).ty(db)\n         }\n-        ast::NominalDefKind::EnumDef(def) => {\n-            source_binder::enum_from_module(db, module, &def).ty(db)\n-        }\n+        ast::NominalDef::EnumDef(def) => source_binder::enum_from_module(db, module, &def).ty(db),\n     };\n \n     let krate = module.krate(db)?;"}, {"sha": "058cd68e291a3a3e66aa8fe7bd773bdd05353fed", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -3,7 +3,7 @@ use hir::{HirDisplay, SourceAnalyzer, Ty};\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n     ast::{\n-        AstNode, ForExpr, IfExpr, LambdaExpr, LetStmt, MatchArmList, Pat, PatKind, SourceFile,\n+        self, AstNode, ForExpr, IfExpr, LambdaExpr, LetStmt, MatchArmList, SourceFile,\n         TypeAscriptionOwner, WhileExpr,\n     },\n     SmolStr, SyntaxKind, SyntaxNode, TextRange,\n@@ -88,7 +88,7 @@ fn get_inlay_hints(\n fn get_pat_type_hints(\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n-    root_pat: Pat,\n+    root_pat: ast::Pat,\n     skip_root_pat_hint: bool,\n ) -> Vec<InlayHint> {\n     let original_pat = &root_pat.clone();\n@@ -108,27 +108,27 @@ fn get_pat_type_hints(\n         .collect()\n }\n \n-fn get_leaf_pats(root_pat: Pat) -> Vec<Pat> {\n-    let mut pats_to_process = std::collections::VecDeque::<Pat>::new();\n+fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n+    let mut pats_to_process = std::collections::VecDeque::<ast::Pat>::new();\n     pats_to_process.push_back(root_pat);\n \n     let mut leaf_pats = Vec::new();\n \n     while let Some(maybe_leaf_pat) = pats_to_process.pop_front() {\n-        match maybe_leaf_pat.kind() {\n-            PatKind::BindPat(bind_pat) => {\n+        match &maybe_leaf_pat {\n+            ast::Pat::BindPat(bind_pat) => {\n                 if let Some(pat) = bind_pat.pat() {\n                     pats_to_process.push_back(pat);\n                 } else {\n                     leaf_pats.push(maybe_leaf_pat);\n                 }\n             }\n-            PatKind::TuplePat(tuple_pat) => {\n+            ast::Pat::TuplePat(tuple_pat) => {\n                 for arg_pat in tuple_pat.args() {\n                     pats_to_process.push_back(arg_pat);\n                 }\n             }\n-            PatKind::StructPat(struct_pat) => {\n+            ast::Pat::StructPat(struct_pat) => {\n                 if let Some(pat_list) = struct_pat.field_pat_list() {\n                     pats_to_process.extend(\n                         pat_list\n@@ -139,12 +139,12 @@ fn get_leaf_pats(root_pat: Pat) -> Vec<Pat> {\n                                     .filter(|pat| pat.syntax().kind() != SyntaxKind::BIND_PAT)\n                             })\n                             .chain(pat_list.bind_pats().map(|bind_pat| {\n-                                bind_pat.pat().unwrap_or_else(|| Pat::from(bind_pat))\n+                                bind_pat.pat().unwrap_or_else(|| ast::Pat::from(bind_pat))\n                             })),\n                     );\n                 }\n             }\n-            PatKind::TupleStructPat(tuple_struct_pat) => {\n+            ast::Pat::TupleStructPat(tuple_struct_pat) => {\n                 for arg_pat in tuple_struct_pat.args() {\n                     pats_to_process.push_back(arg_pat);\n                 }\n@@ -158,7 +158,7 @@ fn get_leaf_pats(root_pat: Pat) -> Vec<Pat> {\n fn get_node_displayable_type(\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n-    node_pat: &Pat,\n+    node_pat: &ast::Pat,\n ) -> Option<Ty> {\n     analyzer.type_of_pat(db, node_pat).and_then(|resolved_type| {\n         if let Ty::Apply(_) = resolved_type {"}, {"sha": "342e73fd344e55076ad7c7e3abe28af6feb040f4", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn find_all_refs(\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n         let resolved = analyzer.resolve_local_name(&name_ref)?;\n         if let Either::A(ptr) = resolved.ptr() {\n-            if let ast::PatKind::BindPat(binding) = ptr.to_node(source_file.syntax()).kind() {\n+            if let ast::Pat::BindPat(binding) = ptr.to_node(source_file.syntax()) {\n                 return Some((binding, analyzer));\n             }\n         }"}, {"sha": "9ea96909e7355d3dc29d37ff16471b7d4bcbe075", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -54,8 +54,8 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n     let has_test_function = module\n         .item_list()?\n         .items()\n-        .filter_map(|it| match it.kind() {\n-            ast::ModuleItemKind::FnDef(it) => Some(it),\n+        .filter_map(|it| match it {\n+            ast::ModuleItem::FnDef(it) => Some(it),\n             _ => None,\n         })\n         .any(|f| f.has_atom_attr(\"test\"));"}, {"sha": "9c57897013eeabcdaf83ceae00cec119228b3fe3", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 339, "deletions": 345, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -591,34 +591,7 @@ impl EnumVariantList {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Expr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for Expr {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n-            | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n-            | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | STRUCT_LIT | CALL_EXPR | INDEX_EXPR\n-            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | TRY_BLOCK_EXPR\n-            | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL => {\n-                true\n-            }\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum ExprKind {\n+pub enum Expr {\n     TupleExpr(TupleExpr),\n     ArrayExpr(ArrayExpr),\n     ParenExpr(ParenExpr),\n@@ -652,189 +625,235 @@ pub enum ExprKind {\n }\n impl From<TupleExpr> for Expr {\n     fn from(node: TupleExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::TupleExpr(node)\n     }\n }\n impl From<ArrayExpr> for Expr {\n     fn from(node: ArrayExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ArrayExpr(node)\n     }\n }\n impl From<ParenExpr> for Expr {\n     fn from(node: ParenExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ParenExpr(node)\n     }\n }\n impl From<PathExpr> for Expr {\n     fn from(node: PathExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::PathExpr(node)\n     }\n }\n impl From<LambdaExpr> for Expr {\n     fn from(node: LambdaExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::LambdaExpr(node)\n     }\n }\n impl From<IfExpr> for Expr {\n     fn from(node: IfExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::IfExpr(node)\n     }\n }\n impl From<LoopExpr> for Expr {\n     fn from(node: LoopExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::LoopExpr(node)\n     }\n }\n impl From<ForExpr> for Expr {\n     fn from(node: ForExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ForExpr(node)\n     }\n }\n impl From<WhileExpr> for Expr {\n     fn from(node: WhileExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::WhileExpr(node)\n     }\n }\n impl From<ContinueExpr> for Expr {\n     fn from(node: ContinueExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ContinueExpr(node)\n     }\n }\n impl From<BreakExpr> for Expr {\n     fn from(node: BreakExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::BreakExpr(node)\n     }\n }\n impl From<Label> for Expr {\n     fn from(node: Label) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::Label(node)\n     }\n }\n impl From<BlockExpr> for Expr {\n     fn from(node: BlockExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::BlockExpr(node)\n     }\n }\n impl From<ReturnExpr> for Expr {\n     fn from(node: ReturnExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ReturnExpr(node)\n     }\n }\n impl From<MatchExpr> for Expr {\n     fn from(node: MatchExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::MatchExpr(node)\n     }\n }\n impl From<StructLit> for Expr {\n     fn from(node: StructLit) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::StructLit(node)\n     }\n }\n impl From<CallExpr> for Expr {\n     fn from(node: CallExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::CallExpr(node)\n     }\n }\n impl From<IndexExpr> for Expr {\n     fn from(node: IndexExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::IndexExpr(node)\n     }\n }\n impl From<MethodCallExpr> for Expr {\n     fn from(node: MethodCallExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::MethodCallExpr(node)\n     }\n }\n impl From<FieldExpr> for Expr {\n     fn from(node: FieldExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::FieldExpr(node)\n     }\n }\n impl From<AwaitExpr> for Expr {\n     fn from(node: AwaitExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::AwaitExpr(node)\n     }\n }\n impl From<TryExpr> for Expr {\n     fn from(node: TryExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::TryExpr(node)\n     }\n }\n impl From<TryBlockExpr> for Expr {\n     fn from(node: TryBlockExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::TryBlockExpr(node)\n     }\n }\n impl From<CastExpr> for Expr {\n     fn from(node: CastExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::CastExpr(node)\n     }\n }\n impl From<RefExpr> for Expr {\n     fn from(node: RefExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::RefExpr(node)\n     }\n }\n impl From<PrefixExpr> for Expr {\n     fn from(node: PrefixExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::PrefixExpr(node)\n     }\n }\n impl From<RangeExpr> for Expr {\n     fn from(node: RangeExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::RangeExpr(node)\n     }\n }\n impl From<BinExpr> for Expr {\n     fn from(node: BinExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::BinExpr(node)\n     }\n }\n impl From<Literal> for Expr {\n     fn from(node: Literal) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::Literal(node)\n     }\n }\n impl From<MacroCall> for Expr {\n     fn from(node: MacroCall) -> Expr {\n-        Expr { syntax: node.syntax }\n-    }\n-}\n-impl Expr {\n-    pub fn kind(&self) -> ExprKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            TUPLE_EXPR => ExprKind::TupleExpr(TupleExpr { syntax }),\n-            ARRAY_EXPR => ExprKind::ArrayExpr(ArrayExpr { syntax }),\n-            PAREN_EXPR => ExprKind::ParenExpr(ParenExpr { syntax }),\n-            PATH_EXPR => ExprKind::PathExpr(PathExpr { syntax }),\n-            LAMBDA_EXPR => ExprKind::LambdaExpr(LambdaExpr { syntax }),\n-            IF_EXPR => ExprKind::IfExpr(IfExpr { syntax }),\n-            LOOP_EXPR => ExprKind::LoopExpr(LoopExpr { syntax }),\n-            FOR_EXPR => ExprKind::ForExpr(ForExpr { syntax }),\n-            WHILE_EXPR => ExprKind::WhileExpr(WhileExpr { syntax }),\n-            CONTINUE_EXPR => ExprKind::ContinueExpr(ContinueExpr { syntax }),\n-            BREAK_EXPR => ExprKind::BreakExpr(BreakExpr { syntax }),\n-            LABEL => ExprKind::Label(Label { syntax }),\n-            BLOCK_EXPR => ExprKind::BlockExpr(BlockExpr { syntax }),\n-            RETURN_EXPR => ExprKind::ReturnExpr(ReturnExpr { syntax }),\n-            MATCH_EXPR => ExprKind::MatchExpr(MatchExpr { syntax }),\n-            STRUCT_LIT => ExprKind::StructLit(StructLit { syntax }),\n-            CALL_EXPR => ExprKind::CallExpr(CallExpr { syntax }),\n-            INDEX_EXPR => ExprKind::IndexExpr(IndexExpr { syntax }),\n-            METHOD_CALL_EXPR => ExprKind::MethodCallExpr(MethodCallExpr { syntax }),\n-            FIELD_EXPR => ExprKind::FieldExpr(FieldExpr { syntax }),\n-            AWAIT_EXPR => ExprKind::AwaitExpr(AwaitExpr { syntax }),\n-            TRY_EXPR => ExprKind::TryExpr(TryExpr { syntax }),\n-            TRY_BLOCK_EXPR => ExprKind::TryBlockExpr(TryBlockExpr { syntax }),\n-            CAST_EXPR => ExprKind::CastExpr(CastExpr { syntax }),\n-            REF_EXPR => ExprKind::RefExpr(RefExpr { syntax }),\n-            PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr { syntax }),\n-            RANGE_EXPR => ExprKind::RangeExpr(RangeExpr { syntax }),\n-            BIN_EXPR => ExprKind::BinExpr(BinExpr { syntax }),\n-            LITERAL => ExprKind::Literal(Literal { syntax }),\n-            MACRO_CALL => ExprKind::MacroCall(MacroCall { syntax }),\n-            _ => unreachable!(),\n+        Expr::MacroCall(node)\n+    }\n+}\n+impl AstNode for Expr {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n+            | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n+            | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | STRUCT_LIT | CALL_EXPR | INDEX_EXPR\n+            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | TRY_BLOCK_EXPR\n+            | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n+            ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),\n+            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n+            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),\n+            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),\n+            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),\n+            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n+            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),\n+            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n+            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),\n+            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),\n+            LABEL => Expr::Label(Label { syntax }),\n+            BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),\n+            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),\n+            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n+            STRUCT_LIT => Expr::StructLit(StructLit { syntax }),\n+            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),\n+            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),\n+            METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n+            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n+            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n+            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n+            TRY_BLOCK_EXPR => Expr::TryBlockExpr(TryBlockExpr { syntax }),\n+            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n+            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n+            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),\n+            RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),\n+            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),\n+            LITERAL => Expr::Literal(Literal { syntax }),\n+            MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Expr::TupleExpr(it) => &it.syntax,\n+            Expr::ArrayExpr(it) => &it.syntax,\n+            Expr::ParenExpr(it) => &it.syntax,\n+            Expr::PathExpr(it) => &it.syntax,\n+            Expr::LambdaExpr(it) => &it.syntax,\n+            Expr::IfExpr(it) => &it.syntax,\n+            Expr::LoopExpr(it) => &it.syntax,\n+            Expr::ForExpr(it) => &it.syntax,\n+            Expr::WhileExpr(it) => &it.syntax,\n+            Expr::ContinueExpr(it) => &it.syntax,\n+            Expr::BreakExpr(it) => &it.syntax,\n+            Expr::Label(it) => &it.syntax,\n+            Expr::BlockExpr(it) => &it.syntax,\n+            Expr::ReturnExpr(it) => &it.syntax,\n+            Expr::MatchExpr(it) => &it.syntax,\n+            Expr::StructLit(it) => &it.syntax,\n+            Expr::CallExpr(it) => &it.syntax,\n+            Expr::IndexExpr(it) => &it.syntax,\n+            Expr::MethodCallExpr(it) => &it.syntax,\n+            Expr::FieldExpr(it) => &it.syntax,\n+            Expr::AwaitExpr(it) => &it.syntax,\n+            Expr::TryExpr(it) => &it.syntax,\n+            Expr::TryBlockExpr(it) => &it.syntax,\n+            Expr::CastExpr(it) => &it.syntax,\n+            Expr::RefExpr(it) => &it.syntax,\n+            Expr::PrefixExpr(it) => &it.syntax,\n+            Expr::RangeExpr(it) => &it.syntax,\n+            Expr::BinExpr(it) => &it.syntax,\n+            Expr::Literal(it) => &it.syntax,\n+            Expr::MacroCall(it) => &it.syntax,\n         }\n     }\n }\n@@ -1167,55 +1186,47 @@ impl ImplBlock {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ImplItem {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for ImplItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            FN_DEF | TYPE_ALIAS_DEF | CONST_DEF => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum ImplItemKind {\n+pub enum ImplItem {\n     FnDef(FnDef),\n     TypeAliasDef(TypeAliasDef),\n     ConstDef(ConstDef),\n }\n impl From<FnDef> for ImplItem {\n     fn from(node: FnDef) -> ImplItem {\n-        ImplItem { syntax: node.syntax }\n+        ImplItem::FnDef(node)\n     }\n }\n impl From<TypeAliasDef> for ImplItem {\n     fn from(node: TypeAliasDef) -> ImplItem {\n-        ImplItem { syntax: node.syntax }\n+        ImplItem::TypeAliasDef(node)\n     }\n }\n impl From<ConstDef> for ImplItem {\n     fn from(node: ConstDef) -> ImplItem {\n-        ImplItem { syntax: node.syntax }\n+        ImplItem::ConstDef(node)\n     }\n }\n-impl ImplItem {\n-    pub fn kind(&self) -> ImplItemKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            FN_DEF => ImplItemKind::FnDef(FnDef { syntax }),\n-            TYPE_ALIAS_DEF => ImplItemKind::TypeAliasDef(TypeAliasDef { syntax }),\n-            CONST_DEF => ImplItemKind::ConstDef(ConstDef { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for ImplItem {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FN_DEF | TYPE_ALIAS_DEF | CONST_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            FN_DEF => ImplItem::FnDef(FnDef { syntax }),\n+            TYPE_ALIAS_DEF => ImplItem::TypeAliasDef(TypeAliasDef { syntax }),\n+            CONST_DEF => ImplItem::ConstDef(ConstDef { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            ImplItem::FnDef(it) => &it.syntax,\n+            ImplItem::TypeAliasDef(it) => &it.syntax,\n+            ImplItem::ConstDef(it) => &it.syntax,\n         }\n     }\n }\n@@ -1774,29 +1785,7 @@ impl Module {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ModuleItem {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for ModuleItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM\n-            | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum ModuleItemKind {\n+pub enum ModuleItem {\n     StructDef(StructDef),\n     EnumDef(EnumDef),\n     FnDef(FnDef),\n@@ -1811,75 +1800,97 @@ pub enum ModuleItemKind {\n }\n impl From<StructDef> for ModuleItem {\n     fn from(node: StructDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::StructDef(node)\n     }\n }\n impl From<EnumDef> for ModuleItem {\n     fn from(node: EnumDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::EnumDef(node)\n     }\n }\n impl From<FnDef> for ModuleItem {\n     fn from(node: FnDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::FnDef(node)\n     }\n }\n impl From<TraitDef> for ModuleItem {\n     fn from(node: TraitDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::TraitDef(node)\n     }\n }\n impl From<TypeAliasDef> for ModuleItem {\n     fn from(node: TypeAliasDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::TypeAliasDef(node)\n     }\n }\n impl From<ImplBlock> for ModuleItem {\n     fn from(node: ImplBlock) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::ImplBlock(node)\n     }\n }\n impl From<UseItem> for ModuleItem {\n     fn from(node: UseItem) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::UseItem(node)\n     }\n }\n impl From<ExternCrateItem> for ModuleItem {\n     fn from(node: ExternCrateItem) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::ExternCrateItem(node)\n     }\n }\n impl From<ConstDef> for ModuleItem {\n     fn from(node: ConstDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::ConstDef(node)\n     }\n }\n impl From<StaticDef> for ModuleItem {\n     fn from(node: StaticDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::StaticDef(node)\n     }\n }\n impl From<Module> for ModuleItem {\n     fn from(node: Module) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::Module(node)\n     }\n }\n-impl ModuleItem {\n-    pub fn kind(&self) -> ModuleItemKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            STRUCT_DEF => ModuleItemKind::StructDef(StructDef { syntax }),\n-            ENUM_DEF => ModuleItemKind::EnumDef(EnumDef { syntax }),\n-            FN_DEF => ModuleItemKind::FnDef(FnDef { syntax }),\n-            TRAIT_DEF => ModuleItemKind::TraitDef(TraitDef { syntax }),\n-            TYPE_ALIAS_DEF => ModuleItemKind::TypeAliasDef(TypeAliasDef { syntax }),\n-            IMPL_BLOCK => ModuleItemKind::ImplBlock(ImplBlock { syntax }),\n-            USE_ITEM => ModuleItemKind::UseItem(UseItem { syntax }),\n-            EXTERN_CRATE_ITEM => ModuleItemKind::ExternCrateItem(ExternCrateItem { syntax }),\n-            CONST_DEF => ModuleItemKind::ConstDef(ConstDef { syntax }),\n-            STATIC_DEF => ModuleItemKind::StaticDef(StaticDef { syntax }),\n-            MODULE => ModuleItemKind::Module(Module { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for ModuleItem {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM\n+            | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            STRUCT_DEF => ModuleItem::StructDef(StructDef { syntax }),\n+            ENUM_DEF => ModuleItem::EnumDef(EnumDef { syntax }),\n+            FN_DEF => ModuleItem::FnDef(FnDef { syntax }),\n+            TRAIT_DEF => ModuleItem::TraitDef(TraitDef { syntax }),\n+            TYPE_ALIAS_DEF => ModuleItem::TypeAliasDef(TypeAliasDef { syntax }),\n+            IMPL_BLOCK => ModuleItem::ImplBlock(ImplBlock { syntax }),\n+            USE_ITEM => ModuleItem::UseItem(UseItem { syntax }),\n+            EXTERN_CRATE_ITEM => ModuleItem::ExternCrateItem(ExternCrateItem { syntax }),\n+            CONST_DEF => ModuleItem::ConstDef(ConstDef { syntax }),\n+            STATIC_DEF => ModuleItem::StaticDef(StaticDef { syntax }),\n+            MODULE => ModuleItem::Module(Module { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            ModuleItem::StructDef(it) => &it.syntax,\n+            ModuleItem::EnumDef(it) => &it.syntax,\n+            ModuleItem::FnDef(it) => &it.syntax,\n+            ModuleItem::TraitDef(it) => &it.syntax,\n+            ModuleItem::TypeAliasDef(it) => &it.syntax,\n+            ModuleItem::ImplBlock(it) => &it.syntax,\n+            ModuleItem::UseItem(it) => &it.syntax,\n+            ModuleItem::ExternCrateItem(it) => &it.syntax,\n+            ModuleItem::ConstDef(it) => &it.syntax,\n+            ModuleItem::StaticDef(it) => &it.syntax,\n+            ModuleItem::Module(it) => &it.syntax,\n         }\n     }\n }\n@@ -2069,48 +2080,39 @@ impl AstNode for NeverType {\n }\n impl NeverType {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct NominalDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for NominalDef {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            STRUCT_DEF | ENUM_DEF => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum NominalDefKind {\n+pub enum NominalDef {\n     StructDef(StructDef),\n     EnumDef(EnumDef),\n }\n impl From<StructDef> for NominalDef {\n     fn from(node: StructDef) -> NominalDef {\n-        NominalDef { syntax: node.syntax }\n+        NominalDef::StructDef(node)\n     }\n }\n impl From<EnumDef> for NominalDef {\n     fn from(node: EnumDef) -> NominalDef {\n-        NominalDef { syntax: node.syntax }\n+        NominalDef::EnumDef(node)\n     }\n }\n-impl NominalDef {\n-    pub fn kind(&self) -> NominalDefKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            STRUCT_DEF => NominalDefKind::StructDef(StructDef { syntax }),\n-            ENUM_DEF => NominalDefKind::EnumDef(EnumDef { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for NominalDef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_DEF | ENUM_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            STRUCT_DEF => NominalDef::StructDef(StructDef { syntax }),\n+            ENUM_DEF => NominalDef::EnumDef(EnumDef { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            NominalDef::StructDef(it) => &it.syntax,\n+            NominalDef::EnumDef(it) => &it.syntax,\n         }\n     }\n }\n@@ -2232,29 +2234,7 @@ impl ParenType {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pat {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for Pat {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            REF_PAT | BIND_PAT | PLACEHOLDER_PAT | PATH_PAT | STRUCT_PAT | TUPLE_STRUCT_PAT\n-            | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum PatKind {\n+pub enum Pat {\n     RefPat(RefPat),\n     BindPat(BindPat),\n     PlaceholderPat(PlaceholderPat),\n@@ -2268,69 +2248,90 @@ pub enum PatKind {\n }\n impl From<RefPat> for Pat {\n     fn from(node: RefPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::RefPat(node)\n     }\n }\n impl From<BindPat> for Pat {\n     fn from(node: BindPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::BindPat(node)\n     }\n }\n impl From<PlaceholderPat> for Pat {\n     fn from(node: PlaceholderPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::PlaceholderPat(node)\n     }\n }\n impl From<PathPat> for Pat {\n     fn from(node: PathPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::PathPat(node)\n     }\n }\n impl From<StructPat> for Pat {\n     fn from(node: StructPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::StructPat(node)\n     }\n }\n impl From<TupleStructPat> for Pat {\n     fn from(node: TupleStructPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::TupleStructPat(node)\n     }\n }\n impl From<TuplePat> for Pat {\n     fn from(node: TuplePat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::TuplePat(node)\n     }\n }\n impl From<SlicePat> for Pat {\n     fn from(node: SlicePat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::SlicePat(node)\n     }\n }\n impl From<RangePat> for Pat {\n     fn from(node: RangePat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::RangePat(node)\n     }\n }\n impl From<LiteralPat> for Pat {\n     fn from(node: LiteralPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::LiteralPat(node)\n     }\n }\n-impl Pat {\n-    pub fn kind(&self) -> PatKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            REF_PAT => PatKind::RefPat(RefPat { syntax }),\n-            BIND_PAT => PatKind::BindPat(BindPat { syntax }),\n-            PLACEHOLDER_PAT => PatKind::PlaceholderPat(PlaceholderPat { syntax }),\n-            PATH_PAT => PatKind::PathPat(PathPat { syntax }),\n-            STRUCT_PAT => PatKind::StructPat(StructPat { syntax }),\n-            TUPLE_STRUCT_PAT => PatKind::TupleStructPat(TupleStructPat { syntax }),\n-            TUPLE_PAT => PatKind::TuplePat(TuplePat { syntax }),\n-            SLICE_PAT => PatKind::SlicePat(SlicePat { syntax }),\n-            RANGE_PAT => PatKind::RangePat(RangePat { syntax }),\n-            LITERAL_PAT => PatKind::LiteralPat(LiteralPat { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for Pat {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            REF_PAT | BIND_PAT | PLACEHOLDER_PAT | PATH_PAT | STRUCT_PAT | TUPLE_STRUCT_PAT\n+            | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            REF_PAT => Pat::RefPat(RefPat { syntax }),\n+            BIND_PAT => Pat::BindPat(BindPat { syntax }),\n+            PLACEHOLDER_PAT => Pat::PlaceholderPat(PlaceholderPat { syntax }),\n+            PATH_PAT => Pat::PathPat(PathPat { syntax }),\n+            STRUCT_PAT => Pat::StructPat(StructPat { syntax }),\n+            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),\n+            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),\n+            SLICE_PAT => Pat::SlicePat(SlicePat { syntax }),\n+            RANGE_PAT => Pat::RangePat(RangePat { syntax }),\n+            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Pat::RefPat(it) => &it.syntax,\n+            Pat::BindPat(it) => &it.syntax,\n+            Pat::PlaceholderPat(it) => &it.syntax,\n+            Pat::PathPat(it) => &it.syntax,\n+            Pat::StructPat(it) => &it.syntax,\n+            Pat::TupleStructPat(it) => &it.syntax,\n+            Pat::TuplePat(it) => &it.syntax,\n+            Pat::SlicePat(it) => &it.syntax,\n+            Pat::RangePat(it) => &it.syntax,\n+            Pat::LiteralPat(it) => &it.syntax,\n         }\n     }\n }\n@@ -2951,48 +2952,39 @@ impl StaticDef {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Stmt {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for Stmt {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            EXPR_STMT | LET_STMT => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum StmtKind {\n+pub enum Stmt {\n     ExprStmt(ExprStmt),\n     LetStmt(LetStmt),\n }\n impl From<ExprStmt> for Stmt {\n     fn from(node: ExprStmt) -> Stmt {\n-        Stmt { syntax: node.syntax }\n+        Stmt::ExprStmt(node)\n     }\n }\n impl From<LetStmt> for Stmt {\n     fn from(node: LetStmt) -> Stmt {\n-        Stmt { syntax: node.syntax }\n+        Stmt::LetStmt(node)\n     }\n }\n-impl Stmt {\n-    pub fn kind(&self) -> StmtKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            EXPR_STMT => StmtKind::ExprStmt(ExprStmt { syntax }),\n-            LET_STMT => StmtKind::LetStmt(LetStmt { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for Stmt {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            EXPR_STMT | LET_STMT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),\n+            LET_STMT => Stmt::LetStmt(LetStmt { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Stmt::ExprStmt(it) => &it.syntax,\n+            Stmt::LetStmt(it) => &it.syntax,\n         }\n     }\n }\n@@ -3508,30 +3500,7 @@ impl TypeParamList {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeRef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for TypeRef {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n-            | SLICE_TYPE | REFERENCE_TYPE | PLACEHOLDER_TYPE | FN_POINTER_TYPE | FOR_TYPE\n-            | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum TypeRefKind {\n+pub enum TypeRef {\n     ParenType(ParenType),\n     TupleType(TupleType),\n     NeverType(NeverType),\n@@ -3548,87 +3517,112 @@ pub enum TypeRefKind {\n }\n impl From<ParenType> for TypeRef {\n     fn from(node: ParenType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ParenType(node)\n     }\n }\n impl From<TupleType> for TypeRef {\n     fn from(node: TupleType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::TupleType(node)\n     }\n }\n impl From<NeverType> for TypeRef {\n     fn from(node: NeverType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::NeverType(node)\n     }\n }\n impl From<PathType> for TypeRef {\n     fn from(node: PathType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::PathType(node)\n     }\n }\n impl From<PointerType> for TypeRef {\n     fn from(node: PointerType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::PointerType(node)\n     }\n }\n impl From<ArrayType> for TypeRef {\n     fn from(node: ArrayType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ArrayType(node)\n     }\n }\n impl From<SliceType> for TypeRef {\n     fn from(node: SliceType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::SliceType(node)\n     }\n }\n impl From<ReferenceType> for TypeRef {\n     fn from(node: ReferenceType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ReferenceType(node)\n     }\n }\n impl From<PlaceholderType> for TypeRef {\n     fn from(node: PlaceholderType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::PlaceholderType(node)\n     }\n }\n impl From<FnPointerType> for TypeRef {\n     fn from(node: FnPointerType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::FnPointerType(node)\n     }\n }\n impl From<ForType> for TypeRef {\n     fn from(node: ForType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ForType(node)\n     }\n }\n impl From<ImplTraitType> for TypeRef {\n     fn from(node: ImplTraitType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ImplTraitType(node)\n     }\n }\n impl From<DynTraitType> for TypeRef {\n     fn from(node: DynTraitType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n-    }\n-}\n-impl TypeRef {\n-    pub fn kind(&self) -> TypeRefKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            PAREN_TYPE => TypeRefKind::ParenType(ParenType { syntax }),\n-            TUPLE_TYPE => TypeRefKind::TupleType(TupleType { syntax }),\n-            NEVER_TYPE => TypeRefKind::NeverType(NeverType { syntax }),\n-            PATH_TYPE => TypeRefKind::PathType(PathType { syntax }),\n-            POINTER_TYPE => TypeRefKind::PointerType(PointerType { syntax }),\n-            ARRAY_TYPE => TypeRefKind::ArrayType(ArrayType { syntax }),\n-            SLICE_TYPE => TypeRefKind::SliceType(SliceType { syntax }),\n-            REFERENCE_TYPE => TypeRefKind::ReferenceType(ReferenceType { syntax }),\n-            PLACEHOLDER_TYPE => TypeRefKind::PlaceholderType(PlaceholderType { syntax }),\n-            FN_POINTER_TYPE => TypeRefKind::FnPointerType(FnPointerType { syntax }),\n-            FOR_TYPE => TypeRefKind::ForType(ForType { syntax }),\n-            IMPL_TRAIT_TYPE => TypeRefKind::ImplTraitType(ImplTraitType { syntax }),\n-            DYN_TRAIT_TYPE => TypeRefKind::DynTraitType(DynTraitType { syntax }),\n-            _ => unreachable!(),\n+        TypeRef::DynTraitType(node)\n+    }\n+}\n+impl AstNode for TypeRef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n+            | SLICE_TYPE | REFERENCE_TYPE | PLACEHOLDER_TYPE | FN_POINTER_TYPE | FOR_TYPE\n+            | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            PAREN_TYPE => TypeRef::ParenType(ParenType { syntax }),\n+            TUPLE_TYPE => TypeRef::TupleType(TupleType { syntax }),\n+            NEVER_TYPE => TypeRef::NeverType(NeverType { syntax }),\n+            PATH_TYPE => TypeRef::PathType(PathType { syntax }),\n+            POINTER_TYPE => TypeRef::PointerType(PointerType { syntax }),\n+            ARRAY_TYPE => TypeRef::ArrayType(ArrayType { syntax }),\n+            SLICE_TYPE => TypeRef::SliceType(SliceType { syntax }),\n+            REFERENCE_TYPE => TypeRef::ReferenceType(ReferenceType { syntax }),\n+            PLACEHOLDER_TYPE => TypeRef::PlaceholderType(PlaceholderType { syntax }),\n+            FN_POINTER_TYPE => TypeRef::FnPointerType(FnPointerType { syntax }),\n+            FOR_TYPE => TypeRef::ForType(ForType { syntax }),\n+            IMPL_TRAIT_TYPE => TypeRef::ImplTraitType(ImplTraitType { syntax }),\n+            DYN_TRAIT_TYPE => TypeRef::DynTraitType(DynTraitType { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            TypeRef::ParenType(it) => &it.syntax,\n+            TypeRef::TupleType(it) => &it.syntax,\n+            TypeRef::NeverType(it) => &it.syntax,\n+            TypeRef::PathType(it) => &it.syntax,\n+            TypeRef::PointerType(it) => &it.syntax,\n+            TypeRef::ArrayType(it) => &it.syntax,\n+            TypeRef::SliceType(it) => &it.syntax,\n+            TypeRef::ReferenceType(it) => &it.syntax,\n+            TypeRef::PlaceholderType(it) => &it.syntax,\n+            TypeRef::FnPointerType(it) => &it.syntax,\n+            TypeRef::ForType(it) => &it.syntax,\n+            TypeRef::ImplTraitType(it) => &it.syntax,\n+            TypeRef::DynTraitType(it) => &it.syntax,\n         }\n     }\n }"}, {"sha": "2bced18678afd063c6c06d533b2cb5a64d809145", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -186,8 +186,8 @@ fn api_walkthrough() {\n     // Let's fetch the `foo` function.\n     let mut func = None;\n     for item in file.items() {\n-        match item.kind() {\n-            ast::ModuleItemKind::FnDef(f) => func = Some(f),\n+        match item {\n+            ast::ModuleItem::FnDef(f) => func = Some(f),\n             _ => unreachable!(),\n         }\n     }\n@@ -206,12 +206,12 @@ fn api_walkthrough() {\n     let block: ast::Block = func.body().unwrap();\n     let expr: ast::Expr = block.expr().unwrap();\n \n-    // \"Enum\"-like nodes are represented using the \"kind\" pattern. It allows us\n-    // to match exhaustively against all flavors of nodes, while maintaining\n-    // internal representation flexibility. The drawback is that one can't write\n-    // nested matches as one pattern.\n-    let bin_expr: ast::BinExpr = match expr.kind() {\n-        ast::ExprKind::BinExpr(e) => e,\n+    // Enums are used to group related ast nodes together, and can be used for\n+    // matching. However, because there are no public fields, it's possible to\n+    // match only the top level enum: that is the price we pay for increased API\n+    // flexibility\n+    let bin_expr: &ast::BinExpr = match &expr {\n+        ast::Expr::BinExpr(e) => e,\n         _ => unreachable!(),\n     };\n "}, {"sha": "01d092d4844a0a1d495a04b6bf90ba64a68cd60d", "filename": "crates/ra_tools/src/boilerplate_gen.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_tools%2Fsrc%2Fboilerplate_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8704a74cd5d02ed4dfe897c12186af1c3ac697fa/crates%2Fra_tools%2Fsrc%2Fboilerplate_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tools%2Fsrc%2Fboilerplate_gen.rs?ref=8704a74cd5d02ed4dfe897c12186af1c3ac697fa", "patch": "@@ -37,41 +37,72 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n             ast_node.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n         let name = format_ident!(\"{}\", name);\n \n-        let kinds = if variants.is_empty() { vec![name.clone()] } else { variants.clone() }\n-            .into_iter()\n-            .map(|name| format_ident!(\"{}\", name.to_string().to_shouty_snake_case()))\n-            .collect::<Vec<_>>();\n+        let adt = if variants.is_empty() {\n+            let kind = format_ident!(\"{}\", name.to_string().to_shouty_snake_case());\n+            quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub struct #name {\n+                    pub(crate) syntax: SyntaxNode,\n+                }\n \n-        let variants = if variants.is_empty() {\n-            None\n+                impl AstNode for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #kind => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                    }\n+                    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+                }\n+            }\n         } else {\n-            let kind_enum = format_ident!(\"{}Kind\", name);\n-            Some(quote!(\n-                pub enum #kind_enum {\n+            let kinds = variants\n+                .iter()\n+                .map(|name| format_ident!(\"{}\", name.to_string().to_shouty_snake_case()))\n+                .collect::<Vec<_>>();\n+\n+            quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub enum #name {\n                     #(#variants(#variants),)*\n                 }\n \n                 #(\n                 impl From<#variants> for #name {\n                     fn from(node: #variants) -> #name {\n-                        #name { syntax: node.syntax }\n+                        #name::#variants(node)\n                     }\n                 }\n                 )*\n \n-                impl #name {\n-                    pub fn kind(&self) -> #kind_enum {\n-                        let syntax = self.syntax.clone();\n-                        match syntax.kind() {\n+                impl AstNode for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                        let res = match syntax.kind() {\n                             #(\n-                            #kinds =>\n-                                #kind_enum::#variants(#variants { syntax }),\n+                            #kinds => #name::#variants(#variants { syntax }),\n+                            )*\n+                            _ => return None,\n+                        };\n+                        Some(res)\n+                    }\n+                    fn syntax(&self) -> &SyntaxNode {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => &it.syntax,\n                             )*\n-                            _ => unreachable!(),\n                         }\n                     }\n                 }\n-            ))\n+            }\n         };\n \n         let traits = ast_node.traits.iter().map(|trait_name| {\n@@ -105,25 +136,7 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n         });\n \n         quote! {\n-            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub struct #name {\n-                pub(crate) syntax: SyntaxNode,\n-            }\n-\n-            impl AstNode for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #(#kinds)|* => true,\n-                        _ => false,\n-                    }\n-                }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n-                }\n-                fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-            }\n-\n-            #variants\n+            #adt\n \n             #(#traits)*\n "}]}