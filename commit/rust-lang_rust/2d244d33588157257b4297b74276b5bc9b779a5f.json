{"sha": "2d244d33588157257b4297b74276b5bc9b779a5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjQ0ZDMzNTg4MTU3MjU3YjQyOTdiNzQyNzZiNWJjOWI3NzlhNWY=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:19Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:19Z"}, "message": "literal representation restructure 4\n\nSimplify `grouping_hint` by splitting digits into parts and handling\none at a time.\n\nFixes #4762", "tree": {"sha": "b687dc552146401f3714dd5373a338956bd55ff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b687dc552146401f3714dd5373a338956bd55ff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d244d33588157257b4297b74276b5bc9b779a5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d244d33588157257b4297b74276b5bc9b779a5f", "html_url": "https://github.com/rust-lang/rust/commit/2d244d33588157257b4297b74276b5bc9b779a5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d244d33588157257b4297b74276b5bc9b779a5f/comments", "author": null, "committer": null, "parents": [{"sha": "2e8946a6de9dba222e1af8419bbb6f739b63eeea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8946a6de9dba222e1af8419bbb6f739b63eeea", "html_url": "https://github.com/rust-lang/rust/commit/2e8946a6de9dba222e1af8419bbb6f739b63eeea"}], "stats": {"total": 202, "additions": 136, "deletions": 66}, "files": [{"sha": "fe1ade60ca003a380059639adde4c83b3a4fd298", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 86, "deletions": 64, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -190,89 +190,111 @@ impl<'a> DigitInfo<'a> {\n         }\n     }\n \n+    fn split_digit_parts(&self) -> (&str, Option<&str>, Option<(char, &str)>) {\n+        let digits = self.digits;\n+\n+        let mut integer = digits;\n+        let mut fraction = None;\n+        let mut exponent = None;\n+\n+        if self.float {\n+            for (i, c) in digits.char_indices() {\n+                match c {\n+                    '.' => {\n+                        integer = &digits[..i];\n+                        fraction = Some(&digits[i + 1..]);\n+                    },\n+                    'e' | 'E' => {\n+                        if integer.len() > i {\n+                            integer = &digits[..i];\n+                        } else {\n+                            fraction = Some(&digits[integer.len() + 1..i]);\n+                        };\n+                        exponent = Some((c, &digits[i + 1..]));\n+                        break;\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+\n+        (integer, fraction, exponent)\n+    }\n+\n     /// Returns literal formatted in a sensible way.\n     crate fn grouping_hint(&self) -> String {\n+        let mut output = String::new();\n+\n+        if let Some(prefix) = self.prefix {\n+            output.push_str(prefix);\n+        }\n+\n         let group_size = self.radix.suggest_grouping();\n-        if self.digits.contains('.') {\n-            let mut parts = self.digits.split('.');\n-            let int_part_hint = parts\n-                .next()\n-                .expect(\"split always returns at least one element\")\n+\n+        let (integer, fraction, exponent) = &self.split_digit_parts();\n+\n+        let int_digits: Vec<_> = integer.chars().rev().filter(|&c| c != '_').collect();\n+        let int_part_hint = int_digits\n+            .chunks(group_size)\n+            .map(|chunk| chunk.iter().rev().collect())\n+            .rev()\n+            .collect::<Vec<String>>()\n+            .join(\"_\");\n+\n+        // Pad leading hexidecimal group with zeros\n+        if self.radix == Radix::Hexadecimal {\n+            debug_assert!(group_size > 0);\n+            let first_group_size = (int_digits.len() + group_size - 1) % group_size + 1;\n+            for _ in 0..group_size - first_group_size {\n+                output.push('0');\n+            }\n+        }\n+\n+        output.push_str(&int_part_hint);\n+\n+        if let Some(fraction) = fraction {\n+            let frac_part_hint = fraction\n                 .chars()\n-                .rev()\n                 .filter(|&c| c != '_')\n                 .collect::<Vec<_>>()\n                 .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n+                .map(|chunk| chunk.iter().collect())\n                 .collect::<Vec<String>>()\n                 .join(\"_\");\n-            let frac_part_hint = parts\n-                .next()\n-                .expect(\"already checked that there is a `.`\")\n+\n+            output.push('.');\n+            output.push_str(&frac_part_hint);\n+        }\n+\n+        if let Some((separator, exponent)) = exponent {\n+            let after_e_hint = exponent\n                 .chars()\n+                .rev()\n                 .filter(|&c| c != '_')\n                 .collect::<Vec<_>>()\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().collect())\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            let suffix_hint = match self.suffix {\n-                Some(suffix) if is_mistyped_float_suffix(suffix) => format!(\"_f{}\", &suffix[1..]),\n-                Some(suffix) => suffix.to_string(),\n-                None => String::new(),\n-            };\n-            format!(\"{}.{}{}\", int_part_hint, frac_part_hint, suffix_hint)\n-        } else if self.float && (self.digits.contains('E') || self.digits.contains('e')) {\n-            let which_e = if self.digits.contains('E') { 'E' } else { 'e' };\n-            let parts: Vec<&str> = self.digits.split(which_e).collect();\n-            let filtered_digits_vec_0 = parts[0].chars().filter(|&c| c != '_').rev().collect::<Vec<_>>();\n-            let filtered_digits_vec_1 = parts[1].chars().filter(|&c| c != '_').rev().collect::<Vec<_>>();\n-            let before_e_hint = filtered_digits_vec_0\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            let after_e_hint = filtered_digits_vec_1\n                 .chunks(group_size)\n                 .map(|chunk| chunk.iter().rev().collect())\n                 .rev()\n                 .collect::<Vec<String>>()\n                 .join(\"_\");\n-            let suffix_hint = match self.suffix {\n-                Some(suffix) if is_mistyped_float_suffix(suffix) => format!(\"_f{}\", &suffix[1..]),\n-                Some(suffix) => suffix.to_string(),\n-                None => String::new(),\n-            };\n-            format!(\n-                \"{}{}{}{}{}\",\n-                self.prefix.unwrap_or(\"\"),\n-                before_e_hint,\n-                which_e,\n-                after_e_hint,\n-                suffix_hint\n-            )\n-        } else {\n-            let filtered_digits_vec = self.digits.chars().filter(|&c| c != '_').rev().collect::<Vec<_>>();\n-            let mut hint = filtered_digits_vec\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            // Forces hexadecimal values to be grouped by 4 being filled with zeroes (e.g 0x00ab_cdef)\n-            let nb_digits_to_fill = filtered_digits_vec.len() % 4;\n-            if self.radix == Radix::Hexadecimal && nb_digits_to_fill != 0 {\n-                hint = format!(\"{:0>4}{}\", &hint[..nb_digits_to_fill], &hint[nb_digits_to_fill..]);\n+\n+            output.push(*separator);\n+            output.push_str(&after_e_hint);\n+        }\n+\n+        if let Some(suffix) = self.suffix {\n+            if self.float && is_mistyped_float_suffix(suffix) {\n+                output.push_str(\"_f\");\n+                output.push_str(&suffix[1..]);\n+            } else if is_mistyped_suffix(suffix) {\n+                output.push_str(\"_i\");\n+                output.push_str(&suffix[1..]);\n+            } else {\n+                output.push_str(suffix);\n             }\n-            let suffix_hint = match self.suffix {\n-                Some(suffix) if is_mistyped_suffix(suffix) => format!(\"_i{}\", &suffix[1..]),\n-                Some(suffix) => suffix.to_string(),\n-                None => String::new(),\n-            };\n-            format!(\"{}{}{}\", self.prefix.unwrap_or(\"\"), hint, suffix_hint)\n         }\n+\n+        output\n     }\n }\n "}, {"sha": "a95b7e0392d764d5188aa6b74f0ea8319fe59243", "filename": "tests/ui/inconsistent_digit_grouping.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Finconsistent_digit_grouping.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Finconsistent_digit_grouping.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_digit_grouping.fixed?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -12,4 +12,10 @@ fn main() {\n         1.123_456_7_f32,\n     );\n     let bad = (123_456, 12_345_678, 1_234_567, 1_234.567_8_f32, 1.234_567_8_f32);\n+\n+    // Test padding\n+    let _ = 0x0010_0000;\n+    let _ = 0x0100_0000;\n+    let _ = 0x1000_0000;\n+    let _ = 0x0001_0000_0000_u64;\n }"}, {"sha": "e316e140de86882dd68a7e052f58dc5c3f0a84b3", "filename": "tests/ui/inconsistent_digit_grouping.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Finconsistent_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Finconsistent_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_digit_grouping.rs?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -12,4 +12,10 @@ fn main() {\n         1.123_456_7_f32,\n     );\n     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+\n+    // Test padding\n+    let _ = 0x100000;\n+    let _ = 0x1000000;\n+    let _ = 0x10000000;\n+    let _ = 0x100000000_u64;\n }"}, {"sha": "31acea2c5e0afe6ac0ad2c2410bdd2f30a6cea1c", "filename": "tests/ui/inconsistent_digit_grouping.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Finconsistent_digit_grouping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Finconsistent_digit_grouping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_digit_grouping.stderr?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -30,5 +30,31 @@ error: digits grouped inconsistently by underscores\n LL |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n    |                                                                ^^^^^^^^^^^^^^ help: consider: `1.234_567_8_f32`\n \n-error: aborting due to 5 previous errors\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:17:13\n+   |\n+LL |     let _ = 0x100000;\n+   |             ^^^^^^^^ help: consider: `0x0010_0000`\n+   |\n+   = note: `-D clippy::unreadable-literal` implied by `-D warnings`\n+\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:18:13\n+   |\n+LL |     let _ = 0x1000000;\n+   |             ^^^^^^^^^ help: consider: `0x0100_0000`\n+\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:19:13\n+   |\n+LL |     let _ = 0x10000000;\n+   |             ^^^^^^^^^^ help: consider: `0x1000_0000`\n+\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:20:13\n+   |\n+LL |     let _ = 0x100000000_u64;\n+   |             ^^^^^^^^^^^^^^^ help: consider: `0x0001_0000_0000_u64`\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "baee77357303814e749dbc3c9909368b4e531125", "filename": "tests/ui/mistyped_literal_suffix.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Fmistyped_literal_suffix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Fmistyped_literal_suffix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.fixed?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -19,4 +19,6 @@ fn main() {\n     #[allow(overflowing_literals)]\n     let fail28 = 241_251_235E723_f64;\n     let fail29 = 42_279.911_f32;\n+\n+    let _ = 1.123_45E1_f32;\n }"}, {"sha": "6de447f40214b527083054f64874989a93c984f5", "filename": "tests/ui/mistyped_literal_suffix.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Fmistyped_literal_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Fmistyped_literal_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.rs?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -19,4 +19,6 @@ fn main() {\n     #[allow(overflowing_literals)]\n     let fail28 = 241251235E723_64;\n     let fail29 = 42279.911_32;\n+\n+    let _ = 1.12345E1_32;\n }"}, {"sha": "48a7ae904948c279c8c121e04526ce991e48888d", "filename": "tests/ui/mistyped_literal_suffix.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Fmistyped_literal_suffix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d244d33588157257b4297b74276b5bc9b779a5f/tests%2Fui%2Fmistyped_literal_suffix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.stderr?ref=2d244d33588157257b4297b74276b5bc9b779a5f", "patch": "@@ -72,5 +72,11 @@ error: mistyped literal suffix\n LL |     let fail29 = 42279.911_32;\n    |                  ^^^^^^^^^^^^ help: did you mean to write: `42_279.911_f32`\n \n-error: aborting due to 12 previous errors\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:23:13\n+   |\n+LL |     let _ = 1.12345E1_32;\n+   |             ^^^^^^^^^^^^ help: did you mean to write: `1.123_45E1_f32`\n+\n+error: aborting due to 13 previous errors\n "}]}