{"sha": "ea31b9cca1e63a01fa75874cebca3f72f46ae029", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMzFiOWNjYTFlNjNhMDFmYTc1ODc0Y2ViY2EzZjcyZjQ2YWUwMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-03T08:07:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-03T08:07:55Z"}, "message": "auto merge of #7474 : Seldaek/rust/clean-iter, r=thestinger\n\nI think it's WIP - but I wanted to ask for feedback (/cc @thestinger)\r\n\r\nI had to move the impl of FromIter for vec into extra::iter because I don't think std can depend on extra, but that's a bit messed up. Similarly some FromIter uses are gone now, not sure if this is fixable or if I made a complete mess here..", "tree": {"sha": "5d8646f3851236de2822d05fded96c75fe75a43b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d8646f3851236de2822d05fded96c75fe75a43b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea31b9cca1e63a01fa75874cebca3f72f46ae029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea31b9cca1e63a01fa75874cebca3f72f46ae029", "html_url": "https://github.com/rust-lang/rust/commit/ea31b9cca1e63a01fa75874cebca3f72f46ae029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea31b9cca1e63a01fa75874cebca3f72f46ae029/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "025dc6e64ef364e0978c7a7b07ce1aeedf9810e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/025dc6e64ef364e0978c7a7b07ce1aeedf9810e5", "html_url": "https://github.com/rust-lang/rust/commit/025dc6e64ef364e0978c7a7b07ce1aeedf9810e5"}, {"sha": "3fe05a987c0d1684b1172ca29c9a9ad79852419e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe05a987c0d1684b1172ca29c9a9ad79852419e", "html_url": "https://github.com/rust-lang/rust/commit/3fe05a987c0d1684b1172ca29c9a9ad79852419e"}], "stats": {"total": 743, "additions": 418, "deletions": 325}, "files": [{"sha": "ad8dcf98317a45dcec1b6cf4b60dec65178d709d", "filename": "src/libextra/iter.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=ea31b9cca1e63a01fa75874cebca3f72f46ae029", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Composable internal iterators\n+\n+Internal iterators are functions implementing the protocol used by the `for` loop.\n+\n+An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n+breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n+tied to specific traits. For example:\n+\n+~~~ {.rust}\n+println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n+~~~\n+\n+An external iterator object implementing the interface in the `iterator` module can be used as an\n+internal iterator by calling the `advance` method. For example:\n+\n+~~~ {.rust}\n+let xs = [0u, 1, 2, 3, 4, 5];\n+let ys = [30, 40, 50, 60];\n+let mut it = xs.iter().chain(ys.iter());\n+for it.advance |&x: &uint| {\n+    println(x.to_str());\n+}\n+~~~\n+\n+Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n+to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n+much easier to implement.\n+\n+*/\n+\n+use std::vec;\n+use std::cmp::Ord;\n+use std::option::{Option, Some, None};\n+use std::num::{One, Zero};\n+use std::ops::{Add, Mul};\n+\n+#[allow(missing_doc)]\n+pub trait FromIter<T> {\n+    /// Build a container with elements from an internal iterator.\n+    ///\n+    /// # Example:\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = ~[1, 2, 3];\n+    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n+    /// assert_eq!(xs, ys);\n+    /// ~~~\n+    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for any values yielded by an internal iterator.\n+ *\n+ * Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[1u, 2, 3, 4, 5];\n+ * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+ * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n+ * ~~~\n+ */\n+#[inline]\n+pub fn any<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    for iter |x| {\n+        if predicate(x) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for all values yielded by an internal iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n+ * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n+ * ~~~\n+ */\n+#[inline]\n+pub fn all<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    // If we ever break, iter will return false, so this will only return true\n+    // if predicate returns true for everything.\n+    iter(|x| predicate(x))\n+}\n+\n+/**\n+ * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[1u, 2, 3, 4, 5, 6];\n+ * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn find<T>(predicate: &fn(&T) -> bool,\n+               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    for iter |x| {\n+        if predicate(&x) {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+/**\n+ * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x > *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x < *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n+ * forces the iterator to yield borrowed pointers.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+ *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+ * }\n+ * ~~~\n+ */\n+#[inline]\n+pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the sum of the items yielding by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n+}\n+\n+/**\n+ * Return the product of the items yielded by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+}\n+\n+impl<T> FromIter<T> for ~[T]{\n+    #[inline]\n+    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n+        let mut v = ~[];\n+        for iter |x| { v.push(x) }\n+        v\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    use int;\n+    use uint;\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[1, 2, 3];\n+        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n+        assert_eq!(xs, ys);\n+    }\n+\n+    #[test]\n+    fn test_any() {\n+        let xs = ~[1u, 2, 3, 4, 5];\n+        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n+    }\n+\n+    #[test]\n+    fn test_all() {\n+        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n+        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        let xs = ~[1u, 2, 3, 4, 5, 6];\n+        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n+    }\n+\n+    #[test]\n+    fn test_min() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n+    }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+    }\n+\n+    #[test]\n+    fn test_sum() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n+    }\n+\n+    #[test]\n+    fn test_empty_sum() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n+    }\n+\n+    #[test]\n+    fn test_product() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n+    }\n+\n+    #[test]\n+    fn test_empty_product() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n+    }\n+}"}, {"sha": "0beb2b3f64d83e77daf4486f233d30c2f233cf54", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ea31b9cca1e63a01fa75874cebca3f72f46ae029", "patch": "@@ -29,7 +29,6 @@ use util::enum_set::{EnumSet, CLike};\n use std::cast;\n use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n-use std::iter;\n use std::ops;\n use std::ptr::to_unsafe_ptr;\n use std::to_bytes;\n@@ -1752,7 +1751,7 @@ pub struct TypeContents {\n \n impl TypeContents {\n     pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n-        iter::all(|bb| self.meets_bound(cx, bb), |f| bbs.each(f))\n+        bbs.iter().all(|bb| self.meets_bound(cx, bb))\n     }\n \n     pub fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {"}, {"sha": "f9bd7a3508edbe09b52665d7ab9c9ff28a66b4e3", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=ea31b9cca1e63a01fa75874cebca3f72f46ae029", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iterator::Iterator;\n \n #[deriving(Eq, IterBytes)]\n pub struct EnumSet<E> {\n@@ -73,6 +74,10 @@ impl<E:CLike> EnumSet<E> {\n         }\n         return true;\n     }\n+\n+    pub fn iter(&self) -> EnumSetIterator<E> {\n+        EnumSetIterator::new(self.bits)\n+    }\n }\n \n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n@@ -93,11 +98,43 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     }\n }\n \n+pub struct EnumSetIterator<E> {\n+    priv index: uint,\n+    priv bits: uint,\n+}\n+\n+impl<E:CLike> EnumSetIterator<E> {\n+    fn new(bits: uint) -> EnumSetIterator<E> {\n+        EnumSetIterator { index: 0, bits: bits }\n+    }\n+}\n+\n+impl<E:CLike> Iterator<E> for EnumSetIterator<E> {\n+    fn next(&mut self) -> Option<E> {\n+        if (self.bits == 0) {\n+            return None;\n+        }\n+\n+        while (self.bits & 1) == 0 {\n+            self.index += 1;\n+            self.bits >>= 1;\n+        }\n+        let elem = CLike::from_uint(self.index);\n+        self.index += 1;\n+        self.bits >>= 1;\n+        Some(elem)\n+    }\n+\n+    fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n+        let exact = Some(self.bits.population_count());\n+        (exact, exact)\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n \n     use std::cast;\n-    use std::iter;\n \n     use util::enum_set::*;\n \n@@ -199,25 +236,58 @@ mod test {\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n-    // each\n+    // iter / each\n+\n+    #[test]\n+    fn test_iterator() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[], elems)\n+\n+        e1.add(A);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A], elems)\n+\n+        e1.add(C);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A,C], elems)\n+\n+        e1.add(C);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A,C], elems)\n+\n+        e1.add(B);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A,B,C], elems)\n+    }\n \n     #[test]\n     fn test_each() {\n         let mut e1: EnumSet<Foo> = EnumSet::empty();\n \n-        assert_eq!(~[], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[], collect(e1))\n \n         e1.add(A);\n-        assert_eq!(~[A], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A], collect(e1))\n \n         e1.add(C);\n-        assert_eq!(~[A,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A,C], collect(e1))\n \n         e1.add(C);\n-        assert_eq!(~[A,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A,C], collect(e1))\n \n         e1.add(B);\n-        assert_eq!(~[A,B,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A,B,C], collect(e1))\n+    }\n+\n+    fn collect(e: EnumSet<Foo>) -> ~[Foo] {\n+        let mut elems = ~[];\n+        e.each(|elem| {\n+           elems.push(elem);\n+           true\n+        });\n+        elems\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -234,12 +304,15 @@ mod test {\n         e2.add(C);\n \n         let e_union = e1 | e2;\n-        assert_eq!(~[A,B,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e_union.each(f)))\n+        let elems: ~[Foo] = e_union.iter().collect();\n+        assert_eq!(~[A,B,C], elems)\n \n         let e_intersection = e1 & e2;\n-        assert_eq!(~[C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e_intersection.each(f)))\n+        let elems: ~[Foo] = e_intersection.iter().collect();\n+        assert_eq!(~[C], elems)\n \n         let e_subtract = e1 - e2;\n-        assert_eq!(~[A], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e_subtract.each(f)))\n+        let elems: ~[Foo] = e_subtract.iter().collect();\n+        assert_eq!(~[A], elems)\n     }\n }"}, {"sha": "2092ae588d01db64436ea01643c2da91198bba83", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 5, "deletions": 302, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=ea31b9cca1e63a01fa75874cebca3f72f46ae029", "patch": "@@ -8,316 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Composable internal iterators\n-\n-Internal iterators are functions implementing the protocol used by the `for` loop.\n-\n-An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n-breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n-tied to specific traits. For example:\n+/*! Times trait\n \n ~~~ {.rust}\n-println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n+use iter::Times;\n+let ten = 10 as uint;\n+let mut accum = 0;\n+for ten.times { accum += 1; }\n ~~~\n \n-An external iterator object implementing the interface in the `iterator` module can be used as an\n-internal iterator by calling the `advance` method. For example:\n-\n-~~~ {.rust}\n-let xs = [0u, 1, 2, 3, 4, 5];\n-let ys = [30, 40, 50, 60];\n-let mut it = xs.iter().chain(ys.iter());\n-for it.advance |&x: &uint| {\n-    println(x.to_str());\n-}\n-~~~\n-\n-Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n-to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n-much easier to implement.\n-\n */\n \n-use cmp::Ord;\n-use option::{Option, Some, None};\n-use num::{One, Zero};\n-use ops::{Add, Mul};\n-\n #[allow(missing_doc)]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool) -> bool;\n }\n \n-#[allow(missing_doc)]\n-pub trait FromIter<T> {\n-    /// Build a container with elements from an internal iterator.\n-    ///\n-    /// # Example:\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-    /// assert_eq!(xs, ys);\n-    /// ~~~\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n-}\n-\n-/**\n- * Return true if `predicate` is true for any values yielded by an internal iterator.\n- *\n- * Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn any<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    for iter |x| {\n-        if predicate(x) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    // If we ever break, iter will return false, so this will only return true\n-    // if predicate returns true for everything.\n-    iter(|x| predicate(x))\n-}\n-\n-/**\n- * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n- * ~~~\n- */\n-#[inline]\n-pub fn find<T>(predicate: &fn(&T) -> bool,\n-               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    for iter |x| {\n-        if predicate(&x) {\n-            return Some(x);\n-        }\n-    }\n-    None\n-}\n-\n-/**\n- * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n- * ~~~\n- */\n-#[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    for iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x > *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n- * ~~~\n- */\n-#[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    for iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x < *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n-    let mut result = start;\n-    for iter |x| {\n-        f(&mut result, x);\n-    }\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n- * forces the iterator to yield borrowed pointers.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n- *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n-    let mut result = start;\n-    for iter |x| {\n-        f(&mut result, x);\n-    }\n-    result\n-}\n-\n-/**\n- * Return the sum of the items yielding by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n-}\n-\n-/**\n- * Return the product of the items yielded by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n- * ~~~\n- */\n-#[inline]\n-pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use int;\n-    use uint;\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-        assert_eq!(xs, ys);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n-        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n-    }\n-\n-    #[test]\n-    fn test_sum() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n-    }\n-\n-    #[test]\n-    fn test_empty_sum() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n-    }\n-\n-    #[test]\n-    fn test_product() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n-    }\n-\n-    #[test]\n-    fn test_empty_product() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n-    }\n-}"}, {"sha": "9d50520996093b26a68a14112f53c57fa9bee535", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=ea31b9cca1e63a01fa75874cebca3f72f46ae029", "patch": "@@ -47,7 +47,7 @@ pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Great\n pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{Times, FromIter};\n+pub use iter::{Times};\n pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};"}, {"sha": "28532bd54e36f0d50556c159b66cbcc2fd2255b6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea31b9cca1e63a01fa75874cebca3f72f46ae029/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ea31b9cca1e63a01fa75874cebca3f72f46ae029", "patch": "@@ -19,7 +19,6 @@ use cmp;\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n-use iter::FromIter;\n use kinds::Copy;\n use libc;\n use libc::c_void;\n@@ -2168,15 +2167,6 @@ pub struct VecMutRevIterator<'self, T> {\n }\n iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n-impl<T> FromIter<T> for ~[T]{\n-    #[inline]\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n-        let mut v = ~[];\n-        for iter |x| { v.push(x) }\n-        v\n-    }\n-}\n-\n #[cfg(stage0)]\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {"}]}