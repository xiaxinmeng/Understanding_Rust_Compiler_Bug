{"sha": "d4daca9f02ec46be1beef79e9ed647a3a24e2434", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZGFjYTlmMDJlYzQ2YmUxYmVlZjc5ZTllZDY0N2EzYTI0ZTI0MzQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-22T18:16:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-22T18:16:28Z"}, "message": "Merge #4573\n\n4573: Chalk cleanups r=matklad a=flodiebold\n\n - split off the `Interner` impl and the conversion code into their own modules\r\n - use `TypeCtorId` as `AdtId` directly (instead of raw `InternId`s), and rename the type alias `StructId` -> `AdtId`\r\n - provide missing Chalk debug impls\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "f9875be8e240fd2d339e00b77035713f85660a4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9875be8e240fd2d339e00b77035713f85660a4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4daca9f02ec46be1beef79e9ed647a3a24e2434", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeyBb8CRBK7hj4Ov3rIwAAdHIIAEKL10//ax3Wpbrl27yQZ/lZ\nNs8vnSRqMjiaVhuvcOysXvoGIduJjo3pCryjTrVZK4/wClD0tXFKpl4h1EhcpDMe\nNQIB4fVGl8ODXj6rKKms2IXnWp3gSkL/G96Xba5DeUBYQNs9lV4BjDhuqDjA5yiW\nM/yzXWgBP/8TBzpWJLNrEGk2KDOEMmYnvZtSDsnVpQUy2flAh2X1TmsMffzIGNJ9\nv1wfiO5QOLr25wVYbnJB49i2DeOXnH2fBfk/JcdS1rqTBXpp1xD5G0D9GynxZd1Y\n45U7crOh7dgpSzAMvLkkDynCWS9oqLIkG7AMlgmPyJDNCxNlJUIPXEHEZlqQ7LY=\n=2eiI\n-----END PGP SIGNATURE-----\n", "payload": "tree f9875be8e240fd2d339e00b77035713f85660a4e\nparent b38f9a5810f28563c45acb1ae8b82438649227c9\nparent ea265aad64366340fa7986f7f93488300631168c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1590171388 +0000\ncommitter GitHub <noreply@github.com> 1590171388 +0000\n\nMerge #4573\n\n4573: Chalk cleanups r=matklad a=flodiebold\n\n - split off the `Interner` impl and the conversion code into their own modules\r\n - use `TypeCtorId` as `AdtId` directly (instead of raw `InternId`s), and rename the type alias `StructId` -> `AdtId`\r\n - provide missing Chalk debug impls\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4daca9f02ec46be1beef79e9ed647a3a24e2434", "html_url": "https://github.com/rust-lang/rust/commit/d4daca9f02ec46be1beef79e9ed647a3a24e2434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4daca9f02ec46be1beef79e9ed647a3a24e2434/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38f9a5810f28563c45acb1ae8b82438649227c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b38f9a5810f28563c45acb1ae8b82438649227c9", "html_url": "https://github.com/rust-lang/rust/commit/b38f9a5810f28563c45acb1ae8b82438649227c9"}, {"sha": "ea265aad64366340fa7986f7f93488300631168c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea265aad64366340fa7986f7f93488300631168c", "html_url": "https://github.com/rust-lang/rust/commit/ea265aad64366340fa7986f7f93488300631168c"}], "stats": {"total": 2074, "additions": 1105, "deletions": 969}, "files": [{"sha": "dfc6c7dd682a038a245dedf08f5b36ebb8beb822", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=d4daca9f02ec46be1beef79e9ed647a3a24e2434", "patch": "@@ -89,7 +89,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_datum(&self, krate: CrateId, trait_id: chalk::TraitId) -> Arc<chalk::TraitDatum>;\n \n     #[salsa::invoke(chalk::struct_datum_query)]\n-    fn struct_datum(&self, krate: CrateId, struct_id: chalk::StructId) -> Arc<chalk::StructDatum>;\n+    fn struct_datum(&self, krate: CrateId, struct_id: chalk::AdtId) -> Arc<chalk::StructDatum>;\n \n     #[salsa::invoke(crate::traits::chalk::impl_datum_query)]\n     fn impl_datum(&self, krate: CrateId, impl_id: chalk::ImplId) -> Arc<chalk::ImplDatum>;"}, {"sha": "e91c9be040a628df8a67fdc772d7581d3d8d041a", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=d4daca9f02ec46be1beef79e9ed647a3a24e2434", "patch": "@@ -155,7 +155,7 @@ pub enum TypeCtor {\n /// This exists just for Chalk, because Chalk just has a single `StructId` where\n /// we have different kinds of ADTs, primitive types and special type\n /// constructors like tuples and function pointers.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub struct TypeCtorId(salsa::InternId);\n impl_intern_key!(TypeCtorId);\n "}, {"sha": "e2f2a9ccbc64384ea62370fa71087688d2e140e7", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 20, "deletions": 966, "changes": 986, "blob_url": "https://github.com/rust-lang/rust/blob/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=d4daca9f02ec46be1beef79e9ed647a3a24e2434", "patch": "@@ -1,325 +1,29 @@\n //! Conversion code from/to Chalk.\n-use std::{fmt, sync::Arc};\n+use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{\n-    cast::Cast, fold::shift::Shift, interner::HasInterner, GenericArg, Goal, GoalData,\n-    PlaceholderIndex, Scalar, TypeName, UniverseIndex,\n-};\n+use chalk_ir::{fold::shift::Shift, GenericArg, TypeName};\n \n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n-    type_ref::Mutability,\n-    AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId,\n-};\n-use ra_db::{\n-    salsa::{InternId, InternKey},\n-    CrateId,\n+    AssocContainerId, AssocItemId, HasModule, Lookup, TypeAliasId,\n };\n+use ra_db::{salsa::InternKey, CrateId};\n \n-use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n+use super::{builtin, AssocTyValue, ChalkContext, Impl};\n use crate::{\n-    db::HirDatabase,\n-    display::HirDisplay,\n-    method_resolution::TyFingerprint,\n-    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n-    utils::generics,\n-    ApplicationTy, DebruijnIndex, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n+    DebruijnIndex, GenericPredicate, Substs, Ty, TypeCtor,\n };\n use chalk_rust_ir::WellKnownTrait;\n+use mapping::{convert_where_clauses, generic_predicate_to_inline_bound, make_binders};\n \n-pub(super) mod tls;\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n-pub struct Interner;\n-\n-impl chalk_ir::interner::Interner for Interner {\n-    type InternedType = Box<chalk_ir::TyData<Self>>; // FIXME use Arc?\n-    type InternedLifetime = chalk_ir::LifetimeData<Self>;\n-    type InternedConst = Arc<chalk_ir::ConstData<Self>>;\n-    type InternedConcreteConst = ();\n-    type InternedGenericArg = chalk_ir::GenericArgData<Self>;\n-    type InternedGoal = Arc<GoalData<Self>>;\n-    type InternedGoals = Vec<Goal<Self>>;\n-    type InternedSubstitution = Vec<GenericArg<Self>>;\n-    type InternedProgramClause = chalk_ir::ProgramClauseData<Self>;\n-    type InternedProgramClauses = Arc<[chalk_ir::ProgramClause<Self>]>;\n-    type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n-    type InternedVariableKinds = Vec<chalk_ir::VariableKind<Self>>;\n-    type InternedCanonicalVarKinds = Vec<chalk_ir::CanonicalVarKind<Self>>;\n-    type DefId = InternId;\n-    type InternedAdtId = InternId;\n-    type Identifier = TypeAliasId;\n-\n-    fn debug_adt_id(type_kind_id: StructId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_struct_id(type_kind_id, fmt)))\n-    }\n-\n-    fn debug_trait_id(type_kind_id: TraitId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_trait_id(type_kind_id, fmt)))\n-    }\n-\n-    fn debug_assoc_type_id(id: AssocTypeId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_assoc_type_id(id, fmt)))\n-    }\n-\n-    fn debug_alias(\n-        alias: &chalk_ir::AliasTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_alias(alias, fmt)))\n-    }\n-\n-    fn debug_projection_ty(\n-        proj: &chalk_ir::ProjectionTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_projection_ty(proj, fmt)))\n-    }\n-\n-    fn debug_opaque_ty(\n-        opaque_ty: &chalk_ir::OpaqueTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty(opaque_ty, fmt)))\n-    }\n-\n-    fn debug_opaque_ty_id(\n-        opaque_ty_id: chalk_ir::OpaqueTyId<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty_id(opaque_ty_id, fmt)))\n-    }\n-\n-    fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_ty(ty, fmt)))\n-    }\n-\n-    fn debug_lifetime(\n-        lifetime: &chalk_ir::Lifetime<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_lifetime(lifetime, fmt)))\n-    }\n-\n-    fn debug_generic_arg(\n-        parameter: &GenericArg<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_generic_arg(parameter, fmt)))\n-    }\n-\n-    fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_goal(goal, fmt)))\n-    }\n-\n-    fn debug_goals(\n-        goals: &chalk_ir::Goals<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_goals(goals, fmt)))\n-    }\n-\n-    fn debug_program_clause_implication(\n-        pci: &chalk_ir::ProgramClauseImplication<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_program_clause_implication(pci, fmt)))\n-    }\n-\n-    fn debug_application_ty(\n-        application_ty: &chalk_ir::ApplicationTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_application_ty(application_ty, fmt)))\n-    }\n-\n-    fn debug_substitution(\n-        substitution: &chalk_ir::Substitution<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_substitution(substitution, fmt)))\n-    }\n-\n-    fn debug_separator_trait_ref(\n-        separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| {\n-            Some(prog?.debug_separator_trait_ref(separator_trait_ref, fmt))\n-        })\n-    }\n-\n-    fn intern_ty(&self, ty: chalk_ir::TyData<Self>) -> Box<chalk_ir::TyData<Self>> {\n-        Box::new(ty)\n-    }\n-\n-    fn ty_data<'a>(&self, ty: &'a Box<chalk_ir::TyData<Self>>) -> &'a chalk_ir::TyData<Self> {\n-        ty\n-    }\n-\n-    fn intern_lifetime(\n-        &self,\n-        lifetime: chalk_ir::LifetimeData<Self>,\n-    ) -> chalk_ir::LifetimeData<Self> {\n-        lifetime\n-    }\n-\n-    fn lifetime_data<'a>(\n-        &self,\n-        lifetime: &'a chalk_ir::LifetimeData<Self>,\n-    ) -> &'a chalk_ir::LifetimeData<Self> {\n-        lifetime\n-    }\n-\n-    fn intern_const(&self, constant: chalk_ir::ConstData<Self>) -> Arc<chalk_ir::ConstData<Self>> {\n-        Arc::new(constant)\n-    }\n-\n-    fn const_data<'a>(\n-        &self,\n-        constant: &'a Arc<chalk_ir::ConstData<Self>>,\n-    ) -> &'a chalk_ir::ConstData<Self> {\n-        constant\n-    }\n-\n-    fn const_eq(&self, _ty: &Box<chalk_ir::TyData<Self>>, _c1: &(), _c2: &()) -> bool {\n-        true\n-    }\n-\n-    fn intern_generic_arg(\n-        &self,\n-        parameter: chalk_ir::GenericArgData<Self>,\n-    ) -> chalk_ir::GenericArgData<Self> {\n-        parameter\n-    }\n-\n-    fn generic_arg_data<'a>(\n-        &self,\n-        parameter: &'a chalk_ir::GenericArgData<Self>,\n-    ) -> &'a chalk_ir::GenericArgData<Self> {\n-        parameter\n-    }\n-\n-    fn intern_goal(&self, goal: GoalData<Self>) -> Arc<GoalData<Self>> {\n-        Arc::new(goal)\n-    }\n-\n-    fn intern_goals<E>(\n-        &self,\n-        data: impl IntoIterator<Item = Result<Goal<Self>, E>>,\n-    ) -> Result<Self::InternedGoals, E> {\n-        data.into_iter().collect()\n-    }\n-\n-    fn goal_data<'a>(&self, goal: &'a Arc<GoalData<Self>>) -> &'a GoalData<Self> {\n-        goal\n-    }\n-\n-    fn goals_data<'a>(&self, goals: &'a Vec<Goal<Interner>>) -> &'a [Goal<Interner>] {\n-        goals\n-    }\n-\n-    fn intern_substitution<E>(\n-        &self,\n-        data: impl IntoIterator<Item = Result<GenericArg<Self>, E>>,\n-    ) -> Result<Vec<GenericArg<Self>>, E> {\n-        data.into_iter().collect()\n-    }\n-\n-    fn substitution_data<'a>(\n-        &self,\n-        substitution: &'a Vec<GenericArg<Self>>,\n-    ) -> &'a [GenericArg<Self>] {\n-        substitution\n-    }\n-\n-    fn intern_program_clause(\n-        &self,\n-        data: chalk_ir::ProgramClauseData<Self>,\n-    ) -> chalk_ir::ProgramClauseData<Self> {\n-        data\n-    }\n-\n-    fn program_clause_data<'a>(\n-        &self,\n-        clause: &'a chalk_ir::ProgramClauseData<Self>,\n-    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n-        clause\n-    }\n-\n-    fn intern_program_clauses<E>(\n-        &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::ProgramClause<Self>, E>>,\n-    ) -> Result<Arc<[chalk_ir::ProgramClause<Self>]>, E> {\n-        data.into_iter().collect()\n-    }\n-\n-    fn program_clauses_data<'a>(\n-        &self,\n-        clauses: &'a Arc<[chalk_ir::ProgramClause<Self>]>,\n-    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n-        &clauses\n-    }\n-\n-    fn intern_quantified_where_clauses<E>(\n-        &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::QuantifiedWhereClause<Self>, E>>,\n-    ) -> Result<Self::InternedQuantifiedWhereClauses, E> {\n-        data.into_iter().collect()\n-    }\n-\n-    fn quantified_where_clauses_data<'a>(\n-        &self,\n-        clauses: &'a Self::InternedQuantifiedWhereClauses,\n-    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n-        clauses\n-    }\n-\n-    fn intern_generic_arg_kinds<E>(\n-        &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::VariableKind<Self>, E>>,\n-    ) -> Result<Self::InternedVariableKinds, E> {\n-        data.into_iter().collect()\n-    }\n-\n-    fn variable_kinds_data<'a>(\n-        &self,\n-        parameter_kinds: &'a Self::InternedVariableKinds,\n-    ) -> &'a [chalk_ir::VariableKind<Self>] {\n-        &parameter_kinds\n-    }\n-\n-    fn intern_canonical_var_kinds<E>(\n-        &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::CanonicalVarKind<Self>, E>>,\n-    ) -> Result<Self::InternedCanonicalVarKinds, E> {\n-        data.into_iter().collect()\n-    }\n-\n-    fn canonical_var_kinds_data<'a>(\n-        &self,\n-        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n-    ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n-        &canonical_var_kinds\n-    }\n-}\n+pub use self::interner::*;\n \n-impl chalk_ir::interner::HasInterner for Interner {\n-    type Interner = Self;\n-}\n-\n-pub type AssocTypeId = chalk_ir::AssocTypeId<Interner>;\n-pub type AssociatedTyDatum = chalk_rust_ir::AssociatedTyDatum<Interner>;\n-pub type TraitId = chalk_ir::TraitId<Interner>;\n-pub type TraitDatum = chalk_rust_ir::TraitDatum<Interner>;\n-pub type StructId = chalk_ir::AdtId<Interner>;\n-pub type StructDatum = chalk_rust_ir::AdtDatum<Interner>;\n-pub type ImplId = chalk_ir::ImplId<Interner>;\n-pub type ImplDatum = chalk_rust_ir::ImplDatum<Interner>;\n-pub type AssociatedTyValueId = chalk_rust_ir::AssociatedTyValueId<Interner>;\n-pub type AssociatedTyValue = chalk_rust_ir::AssociatedTyValue<Interner>;\n+pub(super) mod tls;\n+mod interner;\n+mod mapping;\n \n pub(super) trait ToChalk {\n     type Chalk;\n@@ -334,664 +38,14 @@ where\n     T::from_chalk(db, chalk)\n }\n \n-impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty<Interner>;\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n-        match self {\n-            Ty::Apply(apply_ty) => {\n-                if let TypeCtor::Ref(m) = apply_ty.ctor {\n-                    return ref_to_chalk(db, m, apply_ty.parameters);\n-                }\n-                let name = apply_ty.ctor.to_chalk(db);\n-                let substitution = apply_ty.parameters.to_chalk(db);\n-                chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n-            }\n-            Ty::Projection(proj_ty) => {\n-                let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n-                let substitution = proj_ty.parameters.to_chalk(db);\n-                chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n-                    associated_ty_id,\n-                    substitution,\n-                })\n-                .cast(&Interner)\n-                .intern(&Interner)\n-            }\n-            Ty::Placeholder(id) => {\n-                let interned_id = db.intern_type_param_id(id);\n-                PlaceholderIndex {\n-                    ui: UniverseIndex::ROOT,\n-                    idx: interned_id.as_intern_id().as_usize(),\n-                }\n-                .to_ty::<Interner>(&Interner)\n-            }\n-            Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx).intern(&Interner),\n-            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n-            Ty::Dyn(predicates) => {\n-                let where_clauses = chalk_ir::QuantifiedWhereClauses::from(\n-                    &Interner,\n-                    predicates.iter().filter(|p| !p.is_error()).cloned().map(|p| p.to_chalk(db)),\n-                );\n-                let bounded_ty = chalk_ir::DynTy { bounds: make_binders(where_clauses, 1) };\n-                chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n-            }\n-            Ty::Opaque(_) | Ty::Unknown => {\n-                let substitution = chalk_ir::Substitution::empty(&Interner);\n-                let name = TypeName::Error;\n-                chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n-            }\n-        }\n-    }\n-    fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n-        match chalk.data(&Interner).clone() {\n-            chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n-                TypeName::Error => Ty::Unknown,\n-                TypeName::Ref(m) => ref_from_chalk(db, m, apply_ty.substitution),\n-                _ => {\n-                    let ctor = from_chalk(db, apply_ty.name);\n-                    let parameters = from_chalk(db, apply_ty.substitution);\n-                    Ty::Apply(ApplicationTy { ctor, parameters })\n-                }\n-            },\n-            chalk_ir::TyData::Placeholder(idx) => {\n-                assert_eq!(idx.ui, UniverseIndex::ROOT);\n-                let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n-                    crate::salsa::InternId::from(idx.idx),\n-                );\n-                Ty::Placeholder(db.lookup_intern_type_param_id(interned_id))\n-            }\n-            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n-                let associated_ty = from_chalk(db, proj.associated_ty_id);\n-                let parameters = from_chalk(db, proj.substitution);\n-                Ty::Projection(ProjectionTy { associated_ty, parameters })\n-            }\n-            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(_)) => unimplemented!(),\n-            chalk_ir::TyData::Function(_) => unimplemented!(),\n-            chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx),\n-            chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n-            chalk_ir::TyData::Dyn(where_clauses) => {\n-                assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n-                let predicates = where_clauses\n-                    .bounds\n-                    .skip_binders()\n-                    .iter(&Interner)\n-                    .map(|c| from_chalk(db, c.clone()))\n-                    .collect();\n-                Ty::Dyn(predicates)\n-            }\n-        }\n-    }\n-}\n-\n-const LIFETIME_PLACEHOLDER: PlaceholderIndex =\n-    PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::MAX };\n-\n-/// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n-/// fake lifetime here, because Chalks built-in logic may expect it to be there.\n-fn ref_to_chalk(\n-    db: &dyn HirDatabase,\n-    mutability: Mutability,\n-    subst: Substs,\n-) -> chalk_ir::Ty<Interner> {\n-    let arg = subst[0].clone().to_chalk(db);\n-    let lifetime = LIFETIME_PLACEHOLDER.to_lifetime(&Interner);\n-    chalk_ir::ApplicationTy {\n-        name: TypeName::Ref(mutability.to_chalk(db)),\n-        substitution: chalk_ir::Substitution::from(\n-            &Interner,\n-            vec![lifetime.cast(&Interner), arg.cast(&Interner)],\n-        ),\n-    }\n-    .intern(&Interner)\n-}\n-\n-/// Here we remove the lifetime from the type we got from Chalk.\n-fn ref_from_chalk(\n-    db: &dyn HirDatabase,\n-    mutability: chalk_ir::Mutability,\n-    subst: chalk_ir::Substitution<Interner>,\n-) -> Ty {\n-    let tys = subst\n-        .iter(&Interner)\n-        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n-        .collect();\n-    Ty::apply(TypeCtor::Ref(from_chalk(db, mutability)), Substs(tys))\n-}\n-\n-impl ToChalk for Substs {\n-    type Chalk = chalk_ir::Substitution<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n-        chalk_ir::Substitution::from(&Interner, self.iter().map(|ty| ty.clone().to_chalk(db)))\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, parameters: chalk_ir::Substitution<Interner>) -> Substs {\n-        let tys = parameters\n-            .iter(&Interner)\n-            .map(|p| match p.ty(&Interner) {\n-                Some(ty) => from_chalk(db, ty.clone()),\n-                None => unimplemented!(),\n-            })\n-            .collect();\n-        Substs(tys)\n-    }\n-}\n-\n-impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef<Interner>;\n-\n-    fn to_chalk(self: TraitRef, db: &dyn HirDatabase) -> chalk_ir::TraitRef<Interner> {\n-        let trait_id = self.trait_.to_chalk(db);\n-        let substitution = self.substs.to_chalk(db);\n-        chalk_ir::TraitRef { trait_id, substitution }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, trait_ref: chalk_ir::TraitRef<Interner>) -> Self {\n-        let trait_ = from_chalk(db, trait_ref.trait_id);\n-        let substs = from_chalk(db, trait_ref.substitution);\n-        TraitRef { trait_, substs }\n-    }\n-}\n-\n-impl ToChalk for hir_def::TraitId {\n-    type Chalk = TraitId;\n-\n-    fn to_chalk(self, _db: &dyn HirDatabase) -> TraitId {\n-        chalk_ir::TraitId(self.as_intern_id())\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, trait_id: TraitId) -> hir_def::TraitId {\n-        InternKey::from_intern_id(trait_id.0)\n-    }\n-}\n-\n-impl ToChalk for TypeCtor {\n-    type Chalk = TypeName<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> TypeName<Interner> {\n-        match self {\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let type_id = type_alias.to_chalk(db);\n-                TypeName::AssociatedType(type_id)\n-            }\n-\n-            TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n-            TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n-            TypeCtor::Int(Uncertain::Known(int_ty)) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n-            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 })) => {\n-                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n-            }\n-            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 })) => {\n-                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n-            }\n-\n-            TypeCtor::Tuple { cardinality } => TypeName::Tuple(cardinality.into()),\n-            TypeCtor::RawPtr(mutability) => TypeName::Raw(mutability.to_chalk(db)),\n-            TypeCtor::Slice => TypeName::Slice,\n-            TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n-            TypeCtor::Str => TypeName::Str,\n-\n-            TypeCtor::Int(Uncertain::Unknown)\n-            | TypeCtor::Float(Uncertain::Unknown)\n-            | TypeCtor::Adt(_)\n-            | TypeCtor::Array\n-            | TypeCtor::FnDef(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Never\n-            | TypeCtor::Closure { .. } => {\n-                // other TypeCtors get interned and turned into a chalk StructId\n-                let struct_id = db.intern_type_ctor(self).into();\n-                TypeName::Adt(struct_id)\n-            }\n-        }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, type_name: TypeName<Interner>) -> TypeCtor {\n-        match type_name {\n-            TypeName::Adt(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n-            TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n-            TypeName::OpaqueType(_) => unreachable!(),\n-\n-            TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n-            TypeName::Scalar(Scalar::Char) => TypeCtor::Char,\n-            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n-                signedness: Signedness::Signed,\n-                bitness: bitness_from_chalk_int(int_ty),\n-            })),\n-            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n-                signedness: Signedness::Unsigned,\n-                bitness: bitness_from_chalk_uint(uint_ty),\n-            })),\n-            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n-                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 }))\n-            }\n-            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n-                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 }))\n-            }\n-            TypeName::Tuple(cardinality) => TypeCtor::Tuple { cardinality: cardinality as u16 },\n-            TypeName::Raw(mutability) => TypeCtor::RawPtr(from_chalk(db, mutability)),\n-            TypeName::Slice => TypeCtor::Slice,\n-            TypeName::Ref(mutability) => TypeCtor::Ref(from_chalk(db, mutability)),\n-            TypeName::Str => TypeCtor::Str,\n-\n-            TypeName::FnDef(_) => unreachable!(),\n-\n-            TypeName::Error => {\n-                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n-                unreachable!()\n-            }\n-        }\n-    }\n-}\n-\n-fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n-    use chalk_ir::UintTy;\n-\n-    match uint_ty {\n-        UintTy::Usize => IntBitness::Xsize,\n-        UintTy::U8 => IntBitness::X8,\n-        UintTy::U16 => IntBitness::X16,\n-        UintTy::U32 => IntBitness::X32,\n-        UintTy::U64 => IntBitness::X64,\n-        UintTy::U128 => IntBitness::X128,\n-    }\n-}\n-\n-fn bitness_from_chalk_int(int_ty: chalk_ir::IntTy) -> IntBitness {\n-    use chalk_ir::IntTy;\n-\n-    match int_ty {\n-        IntTy::Isize => IntBitness::Xsize,\n-        IntTy::I8 => IntBitness::X8,\n-        IntTy::I16 => IntBitness::X16,\n-        IntTy::I32 => IntBitness::X32,\n-        IntTy::I64 => IntBitness::X64,\n-        IntTy::I128 => IntBitness::X128,\n-    }\n-}\n-\n-fn int_ty_to_chalk(int_ty: IntTy) -> Scalar {\n-    use chalk_ir::{IntTy, UintTy};\n-\n-    match int_ty.signedness {\n-        Signedness::Signed => Scalar::Int(match int_ty.bitness {\n-            IntBitness::Xsize => IntTy::Isize,\n-            IntBitness::X8 => IntTy::I8,\n-            IntBitness::X16 => IntTy::I16,\n-            IntBitness::X32 => IntTy::I32,\n-            IntBitness::X64 => IntTy::I64,\n-            IntBitness::X128 => IntTy::I128,\n-        }),\n-        Signedness::Unsigned => Scalar::Uint(match int_ty.bitness {\n-            IntBitness::Xsize => UintTy::Usize,\n-            IntBitness::X8 => UintTy::U8,\n-            IntBitness::X16 => UintTy::U16,\n-            IntBitness::X32 => UintTy::U32,\n-            IntBitness::X64 => UintTy::U64,\n-            IntBitness::X128 => UintTy::U128,\n-        }),\n-    }\n-}\n-\n-impl ToChalk for Mutability {\n-    type Chalk = chalk_ir::Mutability;\n-    fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {\n-        match self {\n-            Mutability::Shared => chalk_ir::Mutability::Not,\n-            Mutability::Mut => chalk_ir::Mutability::Mut,\n-        }\n-    }\n-    fn from_chalk(_db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        match chalk {\n-            chalk_ir::Mutability::Mut => Mutability::Mut,\n-            chalk_ir::Mutability::Not => Mutability::Shared,\n-        }\n-    }\n-}\n-\n-impl ToChalk for Impl {\n-    type Chalk = ImplId;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> ImplId {\n-        db.intern_chalk_impl(self).into()\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, impl_id: ImplId) -> Impl {\n-        db.lookup_intern_chalk_impl(impl_id.into())\n-    }\n-}\n-\n-impl ToChalk for TypeAliasId {\n-    type Chalk = AssocTypeId;\n-\n-    fn to_chalk(self, _db: &dyn HirDatabase) -> AssocTypeId {\n-        chalk_ir::AssocTypeId(self.as_intern_id())\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, type_alias_id: AssocTypeId) -> TypeAliasId {\n-        InternKey::from_intern_id(type_alias_id.0)\n-    }\n-}\n-\n-impl ToChalk for AssocTyValue {\n-    type Chalk = AssociatedTyValueId;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValueId {\n-        db.intern_assoc_ty_value(self).into()\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, assoc_ty_value_id: AssociatedTyValueId) -> AssocTyValue {\n-        db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n-    }\n-}\n-\n-impl ToChalk for GenericPredicate {\n-    type Chalk = chalk_ir::QuantifiedWhereClause<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::QuantifiedWhereClause<Interner> {\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => {\n-                let chalk_trait_ref = trait_ref.to_chalk(db);\n-                let chalk_trait_ref = chalk_trait_ref.shifted_in(&Interner);\n-                make_binders(chalk_ir::WhereClause::Implemented(chalk_trait_ref), 0)\n-            }\n-            GenericPredicate::Projection(projection_pred) => {\n-                let ty = projection_pred.ty.to_chalk(db).shifted_in(&Interner);\n-                let projection = projection_pred.projection_ty.to_chalk(db).shifted_in(&Interner);\n-                let alias = chalk_ir::AliasTy::Projection(projection);\n-                make_binders(chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq { alias, ty }), 0)\n-            }\n-            GenericPredicate::Error => panic!(\"tried passing GenericPredicate::Error to Chalk\"),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        where_clause: chalk_ir::QuantifiedWhereClause<Interner>,\n-    ) -> GenericPredicate {\n-        // we don't produce any where clauses with binders and can't currently deal with them\n-        match where_clause\n-            .skip_binders()\n-            .shifted_out(&Interner)\n-            .expect(\"unexpected bound vars in where clause\")\n-        {\n-            chalk_ir::WhereClause::Implemented(tr) => {\n-                GenericPredicate::Implemented(from_chalk(db, tr))\n-            }\n-            chalk_ir::WhereClause::AliasEq(projection_eq) => {\n-                let projection_ty = from_chalk(\n-                    db,\n-                    match projection_eq.alias {\n-                        chalk_ir::AliasTy::Projection(p) => p,\n-                        _ => unimplemented!(),\n-                    },\n-                );\n-                let ty = from_chalk(db, projection_eq.ty);\n-                GenericPredicate::Projection(super::ProjectionPredicate { projection_ty, ty })\n-            }\n-        }\n-    }\n-}\n-\n-impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::ProjectionTy<Interner> {\n-        chalk_ir::ProjectionTy {\n-            associated_ty_id: self.associated_ty.to_chalk(db),\n-            substitution: self.parameters.to_chalk(db),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        projection_ty: chalk_ir::ProjectionTy<Interner>,\n-    ) -> ProjectionTy {\n-        ProjectionTy {\n-            associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n-            parameters: from_chalk(db, projection_ty.substitution),\n-        }\n-    }\n-}\n-\n-impl ToChalk for super::ProjectionPredicate {\n-    type Chalk = chalk_ir::AliasEq<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n-        chalk_ir::AliasEq {\n-            alias: chalk_ir::AliasTy::Projection(self.projection_ty.to_chalk(db)),\n-            ty: self.ty.to_chalk(db),\n-        }\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::AliasEq<Interner>) -> Self {\n-        unimplemented!()\n-    }\n-}\n-\n-impl ToChalk for Obligation {\n-    type Chalk = chalk_ir::DomainGoal<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::DomainGoal<Interner> {\n-        match self {\n-            Obligation::Trait(tr) => tr.to_chalk(db).cast(&Interner),\n-            Obligation::Projection(pr) => pr.to_chalk(db).cast(&Interner),\n-        }\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, _goal: chalk_ir::DomainGoal<Interner>) -> Self {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<T> ToChalk for Canonical<T>\n-where\n-    T: ToChalk,\n-    T::Chalk: HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::Canonical<T::Chalk>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n-        let parameter = chalk_ir::CanonicalVarKind::new(\n-            chalk_ir::VariableKind::Ty,\n-            chalk_ir::UniverseIndex::ROOT,\n-        );\n-        let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical {\n-            value,\n-            binders: chalk_ir::CanonicalVarKinds::from(&Interner, vec![parameter; self.num_vars]),\n-        }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n-        Canonical {\n-            num_vars: canonical.binders.len(&Interner),\n-            value: from_chalk(db, canonical.value),\n-        }\n-    }\n-}\n-\n-impl ToChalk for Arc<super::TraitEnvironment> {\n-    type Chalk = chalk_ir::Environment<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Environment<Interner> {\n-        let mut clauses = Vec::new();\n-        for pred in &self.predicates {\n-            if pred.is_error() {\n-                // for env, we just ignore errors\n-                continue;\n-            }\n-            let program_clause: chalk_ir::ProgramClause<Interner> =\n-                pred.clone().to_chalk(db).cast(&Interner);\n-            clauses.push(program_clause.into_from_env_clause(&Interner));\n-        }\n-        chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses)\n-    }\n-\n-    fn from_chalk(\n-        _db: &dyn HirDatabase,\n-        _env: chalk_ir::Environment<Interner>,\n-    ) -> Arc<super::TraitEnvironment> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<T: ToChalk> ToChalk for super::InEnvironment<T>\n-where\n-    T::Chalk: chalk_ir::interner::HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n-        chalk_ir::InEnvironment {\n-            environment: self.environment.to_chalk(db),\n-            goal: self.value.to_chalk(db),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        in_env: chalk_ir::InEnvironment<T::Chalk>,\n-    ) -> super::InEnvironment<T> {\n-        super::InEnvironment {\n-            environment: from_chalk(db, in_env.environment),\n-            value: from_chalk(db, in_env.goal),\n-        }\n-    }\n-}\n-\n-impl ToChalk for builtin::BuiltinImplData {\n-    type Chalk = ImplDatum;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> ImplDatum {\n-        let impl_type = chalk_rust_ir::ImplType::External;\n-        let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n-\n-        let impl_datum_bound =\n-            chalk_rust_ir::ImplDatumBound { trait_ref: self.trait_ref.to_chalk(db), where_clauses };\n-        let associated_ty_value_ids =\n-            self.assoc_ty_values.into_iter().map(|v| v.to_chalk(db)).collect();\n-        chalk_rust_ir::ImplDatum {\n-            binders: make_binders(impl_datum_bound, self.num_vars),\n-            impl_type,\n-            polarity: chalk_rust_ir::Polarity::Positive,\n-            associated_ty_value_ids,\n-        }\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, _data: ImplDatum) -> Self {\n-        unimplemented!()\n-    }\n-}\n-\n-impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n-    type Chalk = AssociatedTyValue;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValue {\n-        let ty = self.value.to_chalk(db);\n-        let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty };\n-\n-        chalk_rust_ir::AssociatedTyValue {\n-            associated_ty_id: self.assoc_ty_id.to_chalk(db),\n-            impl_id: self.impl_.to_chalk(db),\n-            value: make_binders(value_bound, self.num_vars),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        _db: &dyn HirDatabase,\n-        _data: AssociatedTyValue,\n-    ) -> builtin::BuiltinImplAssocTyValueData {\n-        unimplemented!()\n-    }\n-}\n-\n-fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n-where\n-    T: HasInterner<Interner = Interner>,\n-{\n-    chalk_ir::Binders::new(\n-        chalk_ir::VariableKinds::from(\n-            &Interner,\n-            std::iter::repeat(chalk_ir::VariableKind::Ty).take(num_vars),\n-        ),\n-        value,\n-    )\n-}\n-\n-fn convert_where_clauses(\n-    db: &dyn HirDatabase,\n-    def: GenericDefId,\n-    substs: &Substs,\n-) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n-    let generic_predicates = db.generic_predicates(def);\n-    let mut result = Vec::with_capacity(generic_predicates.len());\n-    for pred in generic_predicates.iter() {\n-        if pred.value.is_error() {\n-            // skip errored predicates completely\n-            continue;\n-        }\n-        result.push(pred.clone().subst(substs).to_chalk(db));\n-    }\n-    result\n-}\n-\n-fn generic_predicate_to_inline_bound(\n-    db: &dyn HirDatabase,\n-    pred: &GenericPredicate,\n-    self_ty: &Ty,\n-) -> Option<chalk_rust_ir::InlineBound<Interner>> {\n-    // An InlineBound is like a GenericPredicate, except the self type is left out.\n-    // We don't have a special type for this, but Chalk does.\n-    match pred {\n-        GenericPredicate::Implemented(trait_ref) => {\n-            if &trait_ref.substs[0] != self_ty {\n-                // we can only convert predicates back to type bounds if they\n-                // have the expected self type\n-                return None;\n-            }\n-            let args_no_self = trait_ref.substs[1..]\n-                .iter()\n-                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n-                .collect();\n-            let trait_bound =\n-                chalk_rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n-            Some(chalk_rust_ir::InlineBound::TraitBound(trait_bound))\n-        }\n-        GenericPredicate::Projection(proj) => {\n-            if &proj.projection_ty.parameters[0] != self_ty {\n-                return None;\n-            }\n-            let trait_ = match proj.projection_ty.associated_ty.lookup(db.upcast()).container {\n-                AssocContainerId::TraitId(t) => t,\n-                _ => panic!(\"associated type not in trait\"),\n-            };\n-            let args_no_self = proj.projection_ty.parameters[1..]\n-                .iter()\n-                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n-                .collect();\n-            let alias_eq_bound = chalk_rust_ir::AliasEqBound {\n-                value: proj.ty.clone().to_chalk(db),\n-                trait_bound: chalk_rust_ir::TraitBound {\n-                    trait_id: trait_.to_chalk(db),\n-                    args_no_self,\n-                },\n-                associated_ty_id: proj.projection_ty.associated_ty.to_chalk(db),\n-                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n-            };\n-            Some(chalk_rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n-        }\n-        GenericPredicate::Error => None,\n-    }\n-}\n-\n impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_data(&self, id: AssocTypeId) -> Arc<AssociatedTyDatum> {\n         self.db.associated_ty_data(id)\n     }\n     fn trait_datum(&self, trait_id: TraitId) -> Arc<TraitDatum> {\n         self.db.trait_datum(self.krate, trait_id)\n     }\n-    fn adt_datum(&self, struct_id: StructId) -> Arc<StructDatum> {\n+    fn adt_datum(&self, struct_id: AdtId) -> Arc<StructDatum> {\n         self.db.struct_datum(self.krate, struct_id)\n     }\n     fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n@@ -1040,7 +94,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n     }\n-    fn impl_provided_for(&self, auto_trait_id: TraitId, struct_id: StructId) -> bool {\n+    fn impl_provided_for(&self, auto_trait_id: TraitId, struct_id: AdtId) -> bool {\n         debug!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n         false // FIXME\n     }\n@@ -1203,7 +257,7 @@ fn lang_attr_from_well_known_trait(attr: WellKnownTrait) -> &'static str {\n pub(crate) fn struct_datum_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n-    struct_id: StructId,\n+    struct_id: AdtId,\n ) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n     let type_ctor: TypeCtor = from_chalk(db, TypeName::Adt(struct_id));\n@@ -1351,15 +405,15 @@ fn type_alias_associated_ty_value(\n     Arc::new(value)\n }\n \n-impl From<StructId> for crate::TypeCtorId {\n-    fn from(struct_id: StructId) -> Self {\n-        InternKey::from_intern_id(struct_id.0)\n+impl From<AdtId> for crate::TypeCtorId {\n+    fn from(struct_id: AdtId) -> Self {\n+        struct_id.0\n     }\n }\n \n-impl From<crate::TypeCtorId> for StructId {\n+impl From<crate::TypeCtorId> for AdtId {\n     fn from(type_ctor_id: crate::TypeCtorId) -> Self {\n-        chalk_ir::AdtId(type_ctor_id.as_intern_id())\n+        chalk_ir::AdtId(type_ctor_id)\n     }\n }\n "}, {"sha": "0603728197e44b2d4b80e1860b54a05c97537ca4", "filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=d4daca9f02ec46be1beef79e9ed647a3a24e2434", "patch": "@@ -0,0 +1,351 @@\n+//! Implementation of the Chalk `Interner` trait, which allows customizing the\n+//! representation of the various objects Chalk deals with (types, goals etc.).\n+\n+use super::tls;\n+use chalk_ir::{GenericArg, Goal, GoalData};\n+use hir_def::TypeAliasId;\n+use ra_db::salsa::InternId;\n+use std::{fmt, sync::Arc};\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct Interner;\n+\n+pub type AssocTypeId = chalk_ir::AssocTypeId<Interner>;\n+pub type AssociatedTyDatum = chalk_rust_ir::AssociatedTyDatum<Interner>;\n+pub type TraitId = chalk_ir::TraitId<Interner>;\n+pub type TraitDatum = chalk_rust_ir::TraitDatum<Interner>;\n+pub type AdtId = chalk_ir::AdtId<Interner>;\n+pub type StructDatum = chalk_rust_ir::AdtDatum<Interner>;\n+pub type ImplId = chalk_ir::ImplId<Interner>;\n+pub type ImplDatum = chalk_rust_ir::ImplDatum<Interner>;\n+pub type AssociatedTyValueId = chalk_rust_ir::AssociatedTyValueId<Interner>;\n+pub type AssociatedTyValue = chalk_rust_ir::AssociatedTyValue<Interner>;\n+\n+impl chalk_ir::interner::Interner for Interner {\n+    type InternedType = Box<chalk_ir::TyData<Self>>; // FIXME use Arc?\n+    type InternedLifetime = chalk_ir::LifetimeData<Self>;\n+    type InternedConst = Arc<chalk_ir::ConstData<Self>>;\n+    type InternedConcreteConst = ();\n+    type InternedGenericArg = chalk_ir::GenericArgData<Self>;\n+    type InternedGoal = Arc<GoalData<Self>>;\n+    type InternedGoals = Vec<Goal<Self>>;\n+    type InternedSubstitution = Vec<GenericArg<Self>>;\n+    type InternedProgramClause = chalk_ir::ProgramClauseData<Self>;\n+    type InternedProgramClauses = Arc<[chalk_ir::ProgramClause<Self>]>;\n+    type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n+    type InternedVariableKinds = Vec<chalk_ir::VariableKind<Self>>;\n+    type InternedCanonicalVarKinds = Vec<chalk_ir::CanonicalVarKind<Self>>;\n+    type DefId = InternId;\n+    type InternedAdtId = crate::TypeCtorId;\n+    type Identifier = TypeAliasId;\n+\n+    fn debug_adt_id(type_kind_id: AdtId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_struct_id(type_kind_id, fmt)))\n+    }\n+\n+    fn debug_trait_id(type_kind_id: TraitId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_trait_id(type_kind_id, fmt)))\n+    }\n+\n+    fn debug_assoc_type_id(id: AssocTypeId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_assoc_type_id(id, fmt)))\n+    }\n+\n+    fn debug_alias(\n+        alias: &chalk_ir::AliasTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_alias(alias, fmt)))\n+    }\n+\n+    fn debug_projection_ty(\n+        proj: &chalk_ir::ProjectionTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_projection_ty(proj, fmt)))\n+    }\n+\n+    fn debug_opaque_ty(\n+        opaque_ty: &chalk_ir::OpaqueTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty(opaque_ty, fmt)))\n+    }\n+\n+    fn debug_opaque_ty_id(\n+        opaque_ty_id: chalk_ir::OpaqueTyId<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty_id(opaque_ty_id, fmt)))\n+    }\n+\n+    fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_ty(ty, fmt)))\n+    }\n+\n+    fn debug_lifetime(\n+        lifetime: &chalk_ir::Lifetime<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_lifetime(lifetime, fmt)))\n+    }\n+\n+    fn debug_generic_arg(\n+        parameter: &GenericArg<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_generic_arg(parameter, fmt)))\n+    }\n+\n+    fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_goal(goal, fmt)))\n+    }\n+\n+    fn debug_goals(\n+        goals: &chalk_ir::Goals<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_goals(goals, fmt)))\n+    }\n+\n+    fn debug_program_clause_implication(\n+        pci: &chalk_ir::ProgramClauseImplication<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_program_clause_implication(pci, fmt)))\n+    }\n+\n+    fn debug_application_ty(\n+        application_ty: &chalk_ir::ApplicationTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_application_ty(application_ty, fmt)))\n+    }\n+\n+    fn debug_substitution(\n+        substitution: &chalk_ir::Substitution<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_substitution(substitution, fmt)))\n+    }\n+\n+    fn debug_separator_trait_ref(\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| {\n+            Some(prog?.debug_separator_trait_ref(separator_trait_ref, fmt))\n+        })\n+    }\n+\n+    fn debug_fn_def_id(\n+        fn_def_id: chalk_ir::FnDefId<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_fn_def_id(fn_def_id, fmt)))\n+    }\n+    fn debug_const(\n+        constant: &chalk_ir::Const<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_const(constant, fmt)))\n+    }\n+    fn debug_variable_kinds(\n+        variable_kinds: &chalk_ir::VariableKinds<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_variable_kinds(variable_kinds, fmt)))\n+    }\n+    fn debug_variable_kinds_with_angles(\n+        variable_kinds: &chalk_ir::VariableKinds<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| {\n+            Some(prog?.debug_variable_kinds_with_angles(variable_kinds, fmt))\n+        })\n+    }\n+    fn debug_canonical_var_kinds(\n+        canonical_var_kinds: &chalk_ir::CanonicalVarKinds<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| {\n+            Some(prog?.debug_canonical_var_kinds(canonical_var_kinds, fmt))\n+        })\n+    }\n+    fn debug_program_clause(\n+        clause: &chalk_ir::ProgramClause<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_program_clause(clause, fmt)))\n+    }\n+    fn debug_program_clauses(\n+        clauses: &chalk_ir::ProgramClauses<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_program_clauses(clauses, fmt)))\n+    }\n+    fn debug_quantified_where_clauses(\n+        clauses: &chalk_ir::QuantifiedWhereClauses<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_quantified_where_clauses(clauses, fmt)))\n+    }\n+\n+    fn intern_ty(&self, ty: chalk_ir::TyData<Self>) -> Box<chalk_ir::TyData<Self>> {\n+        Box::new(ty)\n+    }\n+\n+    fn ty_data<'a>(&self, ty: &'a Box<chalk_ir::TyData<Self>>) -> &'a chalk_ir::TyData<Self> {\n+        ty\n+    }\n+\n+    fn intern_lifetime(\n+        &self,\n+        lifetime: chalk_ir::LifetimeData<Self>,\n+    ) -> chalk_ir::LifetimeData<Self> {\n+        lifetime\n+    }\n+\n+    fn lifetime_data<'a>(\n+        &self,\n+        lifetime: &'a chalk_ir::LifetimeData<Self>,\n+    ) -> &'a chalk_ir::LifetimeData<Self> {\n+        lifetime\n+    }\n+\n+    fn intern_const(&self, constant: chalk_ir::ConstData<Self>) -> Arc<chalk_ir::ConstData<Self>> {\n+        Arc::new(constant)\n+    }\n+\n+    fn const_data<'a>(\n+        &self,\n+        constant: &'a Arc<chalk_ir::ConstData<Self>>,\n+    ) -> &'a chalk_ir::ConstData<Self> {\n+        constant\n+    }\n+\n+    fn const_eq(&self, _ty: &Box<chalk_ir::TyData<Self>>, _c1: &(), _c2: &()) -> bool {\n+        true\n+    }\n+\n+    fn intern_generic_arg(\n+        &self,\n+        parameter: chalk_ir::GenericArgData<Self>,\n+    ) -> chalk_ir::GenericArgData<Self> {\n+        parameter\n+    }\n+\n+    fn generic_arg_data<'a>(\n+        &self,\n+        parameter: &'a chalk_ir::GenericArgData<Self>,\n+    ) -> &'a chalk_ir::GenericArgData<Self> {\n+        parameter\n+    }\n+\n+    fn intern_goal(&self, goal: GoalData<Self>) -> Arc<GoalData<Self>> {\n+        Arc::new(goal)\n+    }\n+\n+    fn intern_goals<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<Goal<Self>, E>>,\n+    ) -> Result<Self::InternedGoals, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn goal_data<'a>(&self, goal: &'a Arc<GoalData<Self>>) -> &'a GoalData<Self> {\n+        goal\n+    }\n+\n+    fn goals_data<'a>(&self, goals: &'a Vec<Goal<Interner>>) -> &'a [Goal<Interner>] {\n+        goals\n+    }\n+\n+    fn intern_substitution<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<GenericArg<Self>, E>>,\n+    ) -> Result<Vec<GenericArg<Self>>, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn substitution_data<'a>(\n+        &self,\n+        substitution: &'a Vec<GenericArg<Self>>,\n+    ) -> &'a [GenericArg<Self>] {\n+        substitution\n+    }\n+\n+    fn intern_program_clause(\n+        &self,\n+        data: chalk_ir::ProgramClauseData<Self>,\n+    ) -> chalk_ir::ProgramClauseData<Self> {\n+        data\n+    }\n+\n+    fn program_clause_data<'a>(\n+        &self,\n+        clause: &'a chalk_ir::ProgramClauseData<Self>,\n+    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n+        clause\n+    }\n+\n+    fn intern_program_clauses<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ProgramClause<Self>, E>>,\n+    ) -> Result<Arc<[chalk_ir::ProgramClause<Self>]>, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn program_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Arc<[chalk_ir::ProgramClause<Self>]>,\n+    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n+        &clauses\n+    }\n+\n+    fn intern_quantified_where_clauses<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::QuantifiedWhereClause<Self>, E>>,\n+    ) -> Result<Self::InternedQuantifiedWhereClauses, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn quantified_where_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Self::InternedQuantifiedWhereClauses,\n+    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n+        clauses\n+    }\n+\n+    fn intern_generic_arg_kinds<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::VariableKind<Self>, E>>,\n+    ) -> Result<Self::InternedVariableKinds, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn variable_kinds_data<'a>(\n+        &self,\n+        parameter_kinds: &'a Self::InternedVariableKinds,\n+    ) -> &'a [chalk_ir::VariableKind<Self>] {\n+        &parameter_kinds\n+    }\n+\n+    fn intern_canonical_var_kinds<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::CanonicalVarKind<Self>, E>>,\n+    ) -> Result<Self::InternedCanonicalVarKinds, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn canonical_var_kinds_data<'a>(\n+        &self,\n+        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n+    ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n+        &canonical_var_kinds\n+    }\n+}\n+\n+impl chalk_ir::interner::HasInterner for Interner {\n+    type Interner = Self;\n+}"}, {"sha": "a83d82fd8bf4e79b60c59aeabfce69720a94028d", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=d4daca9f02ec46be1beef79e9ed647a3a24e2434", "patch": "@@ -0,0 +1,672 @@\n+//! This module contains the implementations of the `ToChalk` trait, which\n+//! handles conversion between our data types and their corresponding types in\n+//! Chalk (in both directions); plus some helper functions for more specialized\n+//! conversions.\n+\n+use chalk_ir::{\n+    cast::Cast, fold::shift::Shift, interner::HasInterner, PlaceholderIndex, Scalar, TypeName,\n+    UniverseIndex,\n+};\n+\n+use hir_def::{type_ref::Mutability, AssocContainerId, GenericDefId, Lookup, TypeAliasId};\n+use ra_db::salsa::InternKey;\n+\n+use crate::{\n+    db::HirDatabase,\n+    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n+    traits::{builtin, AssocTyValue, Canonical, Impl, Obligation},\n+    ApplicationTy, GenericPredicate, InEnvironment, ProjectionPredicate, ProjectionTy, Substs,\n+    TraitEnvironment, TraitRef, Ty, TypeCtor,\n+};\n+\n+use super::interner::*;\n+use super::*;\n+\n+impl ToChalk for Ty {\n+    type Chalk = chalk_ir::Ty<Interner>;\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n+        match self {\n+            Ty::Apply(apply_ty) => {\n+                if let TypeCtor::Ref(m) = apply_ty.ctor {\n+                    return ref_to_chalk(db, m, apply_ty.parameters);\n+                }\n+                let name = apply_ty.ctor.to_chalk(db);\n+                let substitution = apply_ty.parameters.to_chalk(db);\n+                chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n+            }\n+            Ty::Projection(proj_ty) => {\n+                let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n+                let substitution = proj_ty.parameters.to_chalk(db);\n+                chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n+                    associated_ty_id,\n+                    substitution,\n+                })\n+                .cast(&Interner)\n+                .intern(&Interner)\n+            }\n+            Ty::Placeholder(id) => {\n+                let interned_id = db.intern_type_param_id(id);\n+                PlaceholderIndex {\n+                    ui: UniverseIndex::ROOT,\n+                    idx: interned_id.as_intern_id().as_usize(),\n+                }\n+                .to_ty::<Interner>(&Interner)\n+            }\n+            Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx).intern(&Interner),\n+            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n+            Ty::Dyn(predicates) => {\n+                let where_clauses = chalk_ir::QuantifiedWhereClauses::from(\n+                    &Interner,\n+                    predicates.iter().filter(|p| !p.is_error()).cloned().map(|p| p.to_chalk(db)),\n+                );\n+                let bounded_ty = chalk_ir::DynTy { bounds: make_binders(where_clauses, 1) };\n+                chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n+            }\n+            Ty::Opaque(_) | Ty::Unknown => {\n+                let substitution = chalk_ir::Substitution::empty(&Interner);\n+                let name = TypeName::Error;\n+                chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n+            }\n+        }\n+    }\n+    fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n+        match chalk.data(&Interner).clone() {\n+            chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n+                TypeName::Error => Ty::Unknown,\n+                TypeName::Ref(m) => ref_from_chalk(db, m, apply_ty.substitution),\n+                _ => {\n+                    let ctor = from_chalk(db, apply_ty.name);\n+                    let parameters = from_chalk(db, apply_ty.substitution);\n+                    Ty::Apply(ApplicationTy { ctor, parameters })\n+                }\n+            },\n+            chalk_ir::TyData::Placeholder(idx) => {\n+                assert_eq!(idx.ui, UniverseIndex::ROOT);\n+                let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n+                    crate::salsa::InternId::from(idx.idx),\n+                );\n+                Ty::Placeholder(db.lookup_intern_type_param_id(interned_id))\n+            }\n+            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n+                let associated_ty = from_chalk(db, proj.associated_ty_id);\n+                let parameters = from_chalk(db, proj.substitution);\n+                Ty::Projection(ProjectionTy { associated_ty, parameters })\n+            }\n+            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(_)) => unimplemented!(),\n+            chalk_ir::TyData::Function(_) => unimplemented!(),\n+            chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx),\n+            chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n+            chalk_ir::TyData::Dyn(where_clauses) => {\n+                assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n+                let predicates = where_clauses\n+                    .bounds\n+                    .skip_binders()\n+                    .iter(&Interner)\n+                    .map(|c| from_chalk(db, c.clone()))\n+                    .collect();\n+                Ty::Dyn(predicates)\n+            }\n+        }\n+    }\n+}\n+\n+const LIFETIME_PLACEHOLDER: PlaceholderIndex =\n+    PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::MAX };\n+\n+/// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n+/// fake lifetime here, because Chalks built-in logic may expect it to be there.\n+fn ref_to_chalk(\n+    db: &dyn HirDatabase,\n+    mutability: Mutability,\n+    subst: Substs,\n+) -> chalk_ir::Ty<Interner> {\n+    let arg = subst[0].clone().to_chalk(db);\n+    let lifetime = LIFETIME_PLACEHOLDER.to_lifetime(&Interner);\n+    chalk_ir::ApplicationTy {\n+        name: TypeName::Ref(mutability.to_chalk(db)),\n+        substitution: chalk_ir::Substitution::from(\n+            &Interner,\n+            vec![lifetime.cast(&Interner), arg.cast(&Interner)],\n+        ),\n+    }\n+    .intern(&Interner)\n+}\n+\n+/// Here we remove the lifetime from the type we got from Chalk.\n+fn ref_from_chalk(\n+    db: &dyn HirDatabase,\n+    mutability: chalk_ir::Mutability,\n+    subst: chalk_ir::Substitution<Interner>,\n+) -> Ty {\n+    let tys = subst\n+        .iter(&Interner)\n+        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n+        .collect();\n+    Ty::apply(TypeCtor::Ref(from_chalk(db, mutability)), Substs(tys))\n+}\n+\n+impl ToChalk for Substs {\n+    type Chalk = chalk_ir::Substitution<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n+        chalk_ir::Substitution::from(&Interner, self.iter().map(|ty| ty.clone().to_chalk(db)))\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, parameters: chalk_ir::Substitution<Interner>) -> Substs {\n+        let tys = parameters\n+            .iter(&Interner)\n+            .map(|p| match p.ty(&Interner) {\n+                Some(ty) => from_chalk(db, ty.clone()),\n+                None => unimplemented!(),\n+            })\n+            .collect();\n+        Substs(tys)\n+    }\n+}\n+\n+impl ToChalk for TraitRef {\n+    type Chalk = chalk_ir::TraitRef<Interner>;\n+\n+    fn to_chalk(self: TraitRef, db: &dyn HirDatabase) -> chalk_ir::TraitRef<Interner> {\n+        let trait_id = self.trait_.to_chalk(db);\n+        let substitution = self.substs.to_chalk(db);\n+        chalk_ir::TraitRef { trait_id, substitution }\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, trait_ref: chalk_ir::TraitRef<Interner>) -> Self {\n+        let trait_ = from_chalk(db, trait_ref.trait_id);\n+        let substs = from_chalk(db, trait_ref.substitution);\n+        TraitRef { trait_, substs }\n+    }\n+}\n+\n+impl ToChalk for hir_def::TraitId {\n+    type Chalk = TraitId;\n+\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> TraitId {\n+        chalk_ir::TraitId(self.as_intern_id())\n+    }\n+\n+    fn from_chalk(_db: &dyn HirDatabase, trait_id: TraitId) -> hir_def::TraitId {\n+        InternKey::from_intern_id(trait_id.0)\n+    }\n+}\n+\n+impl ToChalk for TypeCtor {\n+    type Chalk = TypeName<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> TypeName<Interner> {\n+        match self {\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let type_id = type_alias.to_chalk(db);\n+                TypeName::AssociatedType(type_id)\n+            }\n+\n+            TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n+            TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n+            TypeCtor::Int(Uncertain::Known(int_ty)) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n+            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 })) => {\n+                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n+            }\n+            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 })) => {\n+                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n+            }\n+\n+            TypeCtor::Tuple { cardinality } => TypeName::Tuple(cardinality.into()),\n+            TypeCtor::RawPtr(mutability) => TypeName::Raw(mutability.to_chalk(db)),\n+            TypeCtor::Slice => TypeName::Slice,\n+            TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n+            TypeCtor::Str => TypeName::Str,\n+            TypeCtor::Int(Uncertain::Unknown)\n+            | TypeCtor::Float(Uncertain::Unknown)\n+            | TypeCtor::Adt(_)\n+            | TypeCtor::Array\n+            | TypeCtor::FnDef(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Never\n+            | TypeCtor::Closure { .. } => {\n+                // other TypeCtors get interned and turned into a chalk StructId\n+                let struct_id = db.intern_type_ctor(self).into();\n+                TypeName::Adt(struct_id)\n+            }\n+        }\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, type_name: TypeName<Interner>) -> TypeCtor {\n+        match type_name {\n+            TypeName::Adt(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n+            TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n+            TypeName::OpaqueType(_) => unreachable!(),\n+\n+            TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n+            TypeName::Scalar(Scalar::Char) => TypeCtor::Char,\n+            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+                signedness: Signedness::Signed,\n+                bitness: bitness_from_chalk_int(int_ty),\n+            })),\n+            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+                signedness: Signedness::Unsigned,\n+                bitness: bitness_from_chalk_uint(uint_ty),\n+            })),\n+            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n+                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 }))\n+            }\n+            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n+                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 }))\n+            }\n+            TypeName::Tuple(cardinality) => TypeCtor::Tuple { cardinality: cardinality as u16 },\n+            TypeName::Raw(mutability) => TypeCtor::RawPtr(from_chalk(db, mutability)),\n+            TypeName::Slice => TypeCtor::Slice,\n+            TypeName::Ref(mutability) => TypeCtor::Ref(from_chalk(db, mutability)),\n+            TypeName::Str => TypeCtor::Str,\n+\n+            TypeName::FnDef(_) => unreachable!(),\n+\n+            TypeName::Error => {\n+                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n+                unreachable!()\n+            }\n+        }\n+    }\n+}\n+\n+fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n+    use chalk_ir::UintTy;\n+\n+    match uint_ty {\n+        UintTy::Usize => IntBitness::Xsize,\n+        UintTy::U8 => IntBitness::X8,\n+        UintTy::U16 => IntBitness::X16,\n+        UintTy::U32 => IntBitness::X32,\n+        UintTy::U64 => IntBitness::X64,\n+        UintTy::U128 => IntBitness::X128,\n+    }\n+}\n+\n+fn bitness_from_chalk_int(int_ty: chalk_ir::IntTy) -> IntBitness {\n+    use chalk_ir::IntTy;\n+\n+    match int_ty {\n+        IntTy::Isize => IntBitness::Xsize,\n+        IntTy::I8 => IntBitness::X8,\n+        IntTy::I16 => IntBitness::X16,\n+        IntTy::I32 => IntBitness::X32,\n+        IntTy::I64 => IntBitness::X64,\n+        IntTy::I128 => IntBitness::X128,\n+    }\n+}\n+\n+fn int_ty_to_chalk(int_ty: IntTy) -> Scalar {\n+    use chalk_ir::{IntTy, UintTy};\n+\n+    match int_ty.signedness {\n+        Signedness::Signed => Scalar::Int(match int_ty.bitness {\n+            IntBitness::Xsize => IntTy::Isize,\n+            IntBitness::X8 => IntTy::I8,\n+            IntBitness::X16 => IntTy::I16,\n+            IntBitness::X32 => IntTy::I32,\n+            IntBitness::X64 => IntTy::I64,\n+            IntBitness::X128 => IntTy::I128,\n+        }),\n+        Signedness::Unsigned => Scalar::Uint(match int_ty.bitness {\n+            IntBitness::Xsize => UintTy::Usize,\n+            IntBitness::X8 => UintTy::U8,\n+            IntBitness::X16 => UintTy::U16,\n+            IntBitness::X32 => UintTy::U32,\n+            IntBitness::X64 => UintTy::U64,\n+            IntBitness::X128 => UintTy::U128,\n+        }),\n+    }\n+}\n+\n+impl ToChalk for Mutability {\n+    type Chalk = chalk_ir::Mutability;\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {\n+        match self {\n+            Mutability::Shared => chalk_ir::Mutability::Not,\n+            Mutability::Mut => chalk_ir::Mutability::Mut,\n+        }\n+    }\n+    fn from_chalk(_db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n+        match chalk {\n+            chalk_ir::Mutability::Mut => Mutability::Mut,\n+            chalk_ir::Mutability::Not => Mutability::Shared,\n+        }\n+    }\n+}\n+\n+impl ToChalk for Impl {\n+    type Chalk = ImplId;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> ImplId {\n+        db.intern_chalk_impl(self).into()\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, impl_id: ImplId) -> Impl {\n+        db.lookup_intern_chalk_impl(impl_id.into())\n+    }\n+}\n+\n+impl ToChalk for TypeAliasId {\n+    type Chalk = AssocTypeId;\n+\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> AssocTypeId {\n+        chalk_ir::AssocTypeId(self.as_intern_id())\n+    }\n+\n+    fn from_chalk(_db: &dyn HirDatabase, type_alias_id: AssocTypeId) -> TypeAliasId {\n+        InternKey::from_intern_id(type_alias_id.0)\n+    }\n+}\n+\n+impl ToChalk for AssocTyValue {\n+    type Chalk = AssociatedTyValueId;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValueId {\n+        db.intern_assoc_ty_value(self).into()\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, assoc_ty_value_id: AssociatedTyValueId) -> AssocTyValue {\n+        db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n+    }\n+}\n+\n+impl ToChalk for GenericPredicate {\n+    type Chalk = chalk_ir::QuantifiedWhereClause<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::QuantifiedWhereClause<Interner> {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                let chalk_trait_ref = trait_ref.to_chalk(db);\n+                let chalk_trait_ref = chalk_trait_ref.shifted_in(&Interner);\n+                make_binders(chalk_ir::WhereClause::Implemented(chalk_trait_ref), 0)\n+            }\n+            GenericPredicate::Projection(projection_pred) => {\n+                let ty = projection_pred.ty.to_chalk(db).shifted_in(&Interner);\n+                let projection = projection_pred.projection_ty.to_chalk(db).shifted_in(&Interner);\n+                let alias = chalk_ir::AliasTy::Projection(projection);\n+                make_binders(chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq { alias, ty }), 0)\n+            }\n+            GenericPredicate::Error => panic!(\"tried passing GenericPredicate::Error to Chalk\"),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        db: &dyn HirDatabase,\n+        where_clause: chalk_ir::QuantifiedWhereClause<Interner>,\n+    ) -> GenericPredicate {\n+        // we don't produce any where clauses with binders and can't currently deal with them\n+        match where_clause\n+            .skip_binders()\n+            .shifted_out(&Interner)\n+            .expect(\"unexpected bound vars in where clause\")\n+        {\n+            chalk_ir::WhereClause::Implemented(tr) => {\n+                GenericPredicate::Implemented(from_chalk(db, tr))\n+            }\n+            chalk_ir::WhereClause::AliasEq(projection_eq) => {\n+                let projection_ty = from_chalk(\n+                    db,\n+                    match projection_eq.alias {\n+                        chalk_ir::AliasTy::Projection(p) => p,\n+                        _ => unimplemented!(),\n+                    },\n+                );\n+                let ty = from_chalk(db, projection_eq.ty);\n+                GenericPredicate::Projection(ProjectionPredicate { projection_ty, ty })\n+            }\n+        }\n+    }\n+}\n+\n+impl ToChalk for ProjectionTy {\n+    type Chalk = chalk_ir::ProjectionTy<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::ProjectionTy<Interner> {\n+        chalk_ir::ProjectionTy {\n+            associated_ty_id: self.associated_ty.to_chalk(db),\n+            substitution: self.parameters.to_chalk(db),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        db: &dyn HirDatabase,\n+        projection_ty: chalk_ir::ProjectionTy<Interner>,\n+    ) -> ProjectionTy {\n+        ProjectionTy {\n+            associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n+            parameters: from_chalk(db, projection_ty.substitution),\n+        }\n+    }\n+}\n+\n+impl ToChalk for ProjectionPredicate {\n+    type Chalk = chalk_ir::AliasEq<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n+        chalk_ir::AliasEq {\n+            alias: chalk_ir::AliasTy::Projection(self.projection_ty.to_chalk(db)),\n+            ty: self.ty.to_chalk(db),\n+        }\n+    }\n+\n+    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::AliasEq<Interner>) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl ToChalk for Obligation {\n+    type Chalk = chalk_ir::DomainGoal<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::DomainGoal<Interner> {\n+        match self {\n+            Obligation::Trait(tr) => tr.to_chalk(db).cast(&Interner),\n+            Obligation::Projection(pr) => pr.to_chalk(db).cast(&Interner),\n+        }\n+    }\n+\n+    fn from_chalk(_db: &dyn HirDatabase, _goal: chalk_ir::DomainGoal<Interner>) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<T> ToChalk for Canonical<T>\n+where\n+    T: ToChalk,\n+    T::Chalk: HasInterner<Interner = Interner>,\n+{\n+    type Chalk = chalk_ir::Canonical<T::Chalk>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n+        let parameter = chalk_ir::CanonicalVarKind::new(\n+            chalk_ir::VariableKind::Ty,\n+            chalk_ir::UniverseIndex::ROOT,\n+        );\n+        let value = self.value.to_chalk(db);\n+        chalk_ir::Canonical {\n+            value,\n+            binders: chalk_ir::CanonicalVarKinds::from(&Interner, vec![parameter; self.num_vars]),\n+        }\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n+        Canonical {\n+            num_vars: canonical.binders.len(&Interner),\n+            value: from_chalk(db, canonical.value),\n+        }\n+    }\n+}\n+\n+impl ToChalk for Arc<TraitEnvironment> {\n+    type Chalk = chalk_ir::Environment<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Environment<Interner> {\n+        let mut clauses = Vec::new();\n+        for pred in &self.predicates {\n+            if pred.is_error() {\n+                // for env, we just ignore errors\n+                continue;\n+            }\n+            let program_clause: chalk_ir::ProgramClause<Interner> =\n+                pred.clone().to_chalk(db).cast(&Interner);\n+            clauses.push(program_clause.into_from_env_clause(&Interner));\n+        }\n+        chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses)\n+    }\n+\n+    fn from_chalk(\n+        _db: &dyn HirDatabase,\n+        _env: chalk_ir::Environment<Interner>,\n+    ) -> Arc<TraitEnvironment> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<T: ToChalk> ToChalk for InEnvironment<T>\n+where\n+    T::Chalk: chalk_ir::interner::HasInterner<Interner = Interner>,\n+{\n+    type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n+        chalk_ir::InEnvironment {\n+            environment: self.environment.to_chalk(db),\n+            goal: self.value.to_chalk(db),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        db: &dyn HirDatabase,\n+        in_env: chalk_ir::InEnvironment<T::Chalk>,\n+    ) -> InEnvironment<T> {\n+        InEnvironment {\n+            environment: from_chalk(db, in_env.environment),\n+            value: from_chalk(db, in_env.goal),\n+        }\n+    }\n+}\n+\n+impl ToChalk for builtin::BuiltinImplData {\n+    type Chalk = ImplDatum;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> ImplDatum {\n+        let impl_type = chalk_rust_ir::ImplType::External;\n+        let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n+\n+        let impl_datum_bound =\n+            chalk_rust_ir::ImplDatumBound { trait_ref: self.trait_ref.to_chalk(db), where_clauses };\n+        let associated_ty_value_ids =\n+            self.assoc_ty_values.into_iter().map(|v| v.to_chalk(db)).collect();\n+        chalk_rust_ir::ImplDatum {\n+            binders: make_binders(impl_datum_bound, self.num_vars),\n+            impl_type,\n+            polarity: chalk_rust_ir::Polarity::Positive,\n+            associated_ty_value_ids,\n+        }\n+    }\n+\n+    fn from_chalk(_db: &dyn HirDatabase, _data: ImplDatum) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n+    type Chalk = AssociatedTyValue;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValue {\n+        let ty = self.value.to_chalk(db);\n+        let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty };\n+\n+        chalk_rust_ir::AssociatedTyValue {\n+            associated_ty_id: self.assoc_ty_id.to_chalk(db),\n+            impl_id: self.impl_.to_chalk(db),\n+            value: make_binders(value_bound, self.num_vars),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        _db: &dyn HirDatabase,\n+        _data: AssociatedTyValue,\n+    ) -> builtin::BuiltinImplAssocTyValueData {\n+        unimplemented!()\n+    }\n+}\n+\n+pub(super) fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n+where\n+    T: HasInterner<Interner = Interner>,\n+{\n+    chalk_ir::Binders::new(\n+        chalk_ir::VariableKinds::from(\n+            &Interner,\n+            std::iter::repeat(chalk_ir::VariableKind::Ty).take(num_vars),\n+        ),\n+        value,\n+    )\n+}\n+\n+pub(super) fn convert_where_clauses(\n+    db: &dyn HirDatabase,\n+    def: GenericDefId,\n+    substs: &Substs,\n+) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n+    let generic_predicates = db.generic_predicates(def);\n+    let mut result = Vec::with_capacity(generic_predicates.len());\n+    for pred in generic_predicates.iter() {\n+        if pred.value.is_error() {\n+            // skip errored predicates completely\n+            continue;\n+        }\n+        result.push(pred.clone().subst(substs).to_chalk(db));\n+    }\n+    result\n+}\n+\n+pub(super) fn generic_predicate_to_inline_bound(\n+    db: &dyn HirDatabase,\n+    pred: &GenericPredicate,\n+    self_ty: &Ty,\n+) -> Option<chalk_rust_ir::InlineBound<Interner>> {\n+    // An InlineBound is like a GenericPredicate, except the self type is left out.\n+    // We don't have a special type for this, but Chalk does.\n+    match pred {\n+        GenericPredicate::Implemented(trait_ref) => {\n+            if &trait_ref.substs[0] != self_ty {\n+                // we can only convert predicates back to type bounds if they\n+                // have the expected self type\n+                return None;\n+            }\n+            let args_no_self = trait_ref.substs[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let trait_bound =\n+                chalk_rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n+            Some(chalk_rust_ir::InlineBound::TraitBound(trait_bound))\n+        }\n+        GenericPredicate::Projection(proj) => {\n+            if &proj.projection_ty.parameters[0] != self_ty {\n+                return None;\n+            }\n+            let trait_ = match proj.projection_ty.associated_ty.lookup(db.upcast()).container {\n+                AssocContainerId::TraitId(t) => t,\n+                _ => panic!(\"associated type not in trait\"),\n+            };\n+            let args_no_self = proj.projection_ty.parameters[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let alias_eq_bound = chalk_rust_ir::AliasEqBound {\n+                value: proj.ty.clone().to_chalk(db),\n+                trait_bound: chalk_rust_ir::TraitBound {\n+                    trait_id: trait_.to_chalk(db),\n+                    args_no_self,\n+                },\n+                associated_ty_id: proj.projection_ty.associated_ty.to_chalk(db),\n+                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n+            };\n+            Some(chalk_rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n+        }\n+        GenericPredicate::Error => None,\n+    }\n+}"}, {"sha": "ebf402a0793acb9c6a14b71076f97ac560bfbb19", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4daca9f02ec46be1beef79e9ed647a3a24e2434/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=d4daca9f02ec46be1beef79e9ed647a3a24e2434", "patch": "@@ -15,7 +15,7 @@ pub struct DebugContext<'a>(&'a (dyn HirDatabase + 'a));\n impl DebugContext<'_> {\n     pub fn debug_struct_id(\n         &self,\n-        id: super::StructId,\n+        id: super::AdtId,\n         f: &mut fmt::Formatter<'_>,\n     ) -> Result<(), fmt::Error> {\n         let type_ctor: TypeCtor = from_chalk(self.0, TypeName::Adt(id));\n@@ -244,6 +244,65 @@ impl DebugContext<'_> {\n     ) -> Result<(), fmt::Error> {\n         write!(fmt, \"{:?}\", separator_trait_ref.debug(&Interner))\n     }\n+\n+    pub fn debug_fn_def_id(\n+        &self,\n+        _fn_def_id: chalk_ir::FnDefId<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"fn\")\n+    }\n+\n+    pub fn debug_const(\n+        &self,\n+        _constant: &chalk_ir::Const<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"const\")\n+    }\n+\n+    pub fn debug_variable_kinds(\n+        &self,\n+        variable_kinds: &chalk_ir::VariableKinds<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"{:?}\", variable_kinds.as_slice(&Interner))\n+    }\n+    pub fn debug_variable_kinds_with_angles(\n+        &self,\n+        variable_kinds: &chalk_ir::VariableKinds<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"{:?}\", variable_kinds.inner_debug(&Interner))\n+    }\n+    pub fn debug_canonical_var_kinds(\n+        &self,\n+        canonical_var_kinds: &chalk_ir::CanonicalVarKinds<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"{:?}\", canonical_var_kinds.as_slice(&Interner))\n+    }\n+    pub fn debug_program_clause(\n+        &self,\n+        clause: &chalk_ir::ProgramClause<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"{:?}\", clause.data(&Interner))\n+    }\n+    pub fn debug_program_clauses(\n+        &self,\n+        clauses: &chalk_ir::ProgramClauses<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"{:?}\", clauses.as_slice(&Interner))\n+    }\n+    pub fn debug_quantified_where_clauses(\n+        &self,\n+        clauses: &chalk_ir::QuantifiedWhereClauses<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        write!(fmt, \"{:?}\", clauses.as_slice(&Interner))\n+    }\n }\n \n mod unsafe_tls {"}]}