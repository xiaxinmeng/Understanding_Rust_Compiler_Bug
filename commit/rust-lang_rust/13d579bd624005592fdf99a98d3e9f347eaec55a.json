{"sha": "13d579bd624005592fdf99a98d3e9f347eaec55a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZDU3OWJkNjI0MDA1NTkyZmRmOTlhOThkM2U5ZjM0N2VhZWM1NWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-17T17:28:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "introduce the idea of an \"approximate match\"\n\nIn fact, however, we currently always give back the same exact answers\nas ever. But we don't rely on them being exact anymore.", "tree": {"sha": "c79063e0fc504c3573c6609418e39297c18f5d77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c79063e0fc504c3573c6609418e39297c18f5d77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13d579bd624005592fdf99a98d3e9f347eaec55a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13d579bd624005592fdf99a98d3e9f347eaec55a", "html_url": "https://github.com/rust-lang/rust/commit/13d579bd624005592fdf99a98d3e9f347eaec55a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13d579bd624005592fdf99a98d3e9f347eaec55a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db0e62692eed43a5efb7024a69e36c6288fff859", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0e62692eed43a5efb7024a69e36c6288fff859", "html_url": "https://github.com/rust-lang/rust/commit/db0e62692eed43a5efb7024a69e36c6288fff859"}], "stats": {"total": 95, "additions": 56, "deletions": 39}, "files": [{"sha": "88ac1e8590d12f4e68fc02d9d9f96032c74b408a", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/13d579bd624005592fdf99a98d3e9f347eaec55a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d579bd624005592fdf99a98d3e9f347eaec55a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=13d579bd624005592fdf99a98d3e9f347eaec55a", "patch": "@@ -388,20 +388,24 @@ where\n         // rule might not apply (but another rule might). For now, we err\n         // on the side of adding too few edges into the graph.\n \n-        // Compute the bounds we can derive from the environment or trait\n-        // definition.  We know that the projection outlives all the\n-        // regions in this list.\n-        let mut declared_bounds = self.verify_bound\n-            .projection_declared_bounds_from_env(projection_ty);\n-\n-        declared_bounds.extend(\n-            self.verify_bound\n-                .projection_declared_bounds_from_trait(projection_ty),\n+        // Compute the bounds we can derive from the environment. This\n+        // is an \"approximate\" match -- in some cases, these bounds\n+        // may not apply.\n+        let approx_env_bounds = self.verify_bound\n+            .projection_approx_declared_bounds_from_env(projection_ty);\n+        debug!(\n+            \"projection_must_outlive: approx_env_bounds={:?}\",\n+            approx_env_bounds\n         );\n \n+        // Compute the bounds we can derive from the trait definition.\n+        // These are guaranteed to apply, no matter the inference\n+        // results.\n+        let trait_bounds = self.verify_bound\n+            .projection_declared_bounds_from_trait(projection_ty);\n         debug!(\n-            \"projection_must_outlive: declared_bounds={:?}\",\n-            declared_bounds\n+            \"projection_must_outlive: trait_bounds={:?}\",\n+            trait_bounds\n         );\n \n         // If declared bounds list is empty, the only applicable rule is\n@@ -419,7 +423,7 @@ where\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n         let needs_infer = projection_ty.needs_infer();\n-        if declared_bounds.is_empty() && needs_infer {\n+        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n             for component_ty in projection_ty.substs.types() {\n@@ -434,34 +438,31 @@ where\n             return;\n         }\n \n-        // If we find that there is a unique declared bound `'b`, and this bound\n-        // appears in the trait reference, then the best action is to require that `'b:'r`,\n-        // so do that. This is best no matter what rule we use:\n+        // If we found a unique bound `'b` from the trait, and we\n+        // found nothing else from the environment, then the best\n+        // action is to require that `'b: 'r`, so do that.\n+        //\n+        // This is best no matter what rule we use:\n         //\n-        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n-        // the requirement that `'b:'r`\n-        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n-        // other conditions\n-        if !declared_bounds.is_empty()\n-            && declared_bounds[1..]\n+        // - OutlivesProjectionEnv: these would translate to the requirement that `'b:'r`\n+        // - OutlivesProjectionTraitDef: these would translate to the requirement that `'b:'r`\n+        // - OutlivesProjectionComponent: this would require `'b:'r`\n+        //   in addition to other conditions\n+        if !trait_bounds.is_empty()\n+            && trait_bounds[1..]\n                 .iter()\n-                .all(|b| *b == declared_bounds[0])\n+                .chain(&approx_env_bounds)\n+                .all(|b| *b == trait_bounds[0])\n         {\n-            let unique_bound = declared_bounds[0];\n+            let unique_bound = trait_bounds[0];\n             debug!(\n-                \"projection_must_outlive: unique declared bound = {:?}\",\n+                \"projection_must_outlive: unique trait bound = {:?}\",\n                 unique_bound\n             );\n-            if projection_ty\n-                .substs\n-                .regions()\n-                .any(|r| declared_bounds.contains(&r))\n-            {\n-                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.delegate\n-                    .push_sub_region_constraint(origin.clone(), region, unique_bound);\n-                return;\n-            }\n+            debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+            self.delegate\n+                .push_sub_region_constraint(origin.clone(), region, unique_bound);\n+            return;\n         }\n \n         // Fallback to verifying after the fact that there exists a"}, {"sha": "2390ea55c4475b1cc1b3fa5a12385de694b6b1fc", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/13d579bd624005592fdf99a98d3e9f347eaec55a/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d579bd624005592fdf99a98d3e9f347eaec55a/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=13d579bd624005592fdf99a98d3e9f347eaec55a", "patch": "@@ -74,10 +74,18 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n \n     /// Given a projection like `T::Item`, searches the environment\n     /// for where-clauses like `T::Item: 'a`. Returns the set of\n-    /// regions `'a` that it finds.  This is a \"conservative\" check --\n-    /// it may not find all applicable bounds, but all the bounds it\n-    /// returns can be relied upon.\n-    pub fn projection_declared_bounds_from_env(\n+    /// regions `'a` that it finds.\n+    ///\n+    /// This is an \"approximate\" check -- it may not find all\n+    /// applicable bounds, and not all the bounds it returns can be\n+    /// relied upon. In particular, this check ignores region\n+    /// identity.  So, for example, if we have `<T as\n+    /// Trait<'0>>::Item` where `'0` is a region variable, and the\n+    /// user has `<T as Trait<'a>>::Item: 'b` in the environment, then\n+    /// the clause from the environment only applies if `'0 = 'a`,\n+    /// which we don't know yet. But we would still include `'b` in\n+    /// this list.\n+    pub fn projection_approx_declared_bounds_from_env(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) -> Vec<ty::Region<'tcx>> {\n@@ -103,9 +111,11 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             projection_ty\n         );\n \n+        // Search the env for where clauses like `P: 'a`.\n         let mut declared_bounds =\n-            self.projection_declared_bounds_from_env(projection_ty);\n+            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n \n+        // Extend with bounds that we can find from the trait.\n         declared_bounds.extend(\n             self.projection_declared_bounds_from_trait(projection_ty)\n         );\n@@ -139,6 +149,12 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Searches the environment for where-clauses like `G: 'a` where\n+    /// `G` is either some type parameter `T` or a projection like\n+    /// `T::Item`. Returns a vector of the `'a` bounds it can find.\n+    ///\n+    /// This is a conservative check -- it may not find all applicable\n+    /// bounds, but all the bounds it returns can be relied upon.\n     fn declared_generic_bounds_from_env(\n         &self,\n         generic: GenericKind<'tcx>,"}]}