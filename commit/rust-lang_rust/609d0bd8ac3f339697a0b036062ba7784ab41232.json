{"sha": "609d0bd8ac3f339697a0b036062ba7784ab41232", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwOWQwYmQ4YWMzZjMzOTY5N2EwYjAzNjA2MmJhNzc4NGFiNDEyMzI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-09-10T03:26:47Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-25T20:48:44Z"}, "message": "dump data for prefix path segments", "tree": {"sha": "19b083facd69937e1a8988e519ed7b65716d4c76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b083facd69937e1a8988e519ed7b65716d4c76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/609d0bd8ac3f339697a0b036062ba7784ab41232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/609d0bd8ac3f339697a0b036062ba7784ab41232", "html_url": "https://github.com/rust-lang/rust/commit/609d0bd8ac3f339697a0b036062ba7784ab41232", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/609d0bd8ac3f339697a0b036062ba7784ab41232/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2bb7cadf24e82b80f403c09e800fe5fad504caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bb7cadf24e82b80f403c09e800fe5fad504caf", "html_url": "https://github.com/rust-lang/rust/commit/c2bb7cadf24e82b80f403c09e800fe5fad504caf"}], "stats": {"total": 153, "additions": 22, "deletions": 131}, "files": [{"sha": "49b871e767783e005e4e7cab17a162706c2ee813", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 106, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/609d0bd8ac3f339697a0b036062ba7784ab41232/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609d0bd8ac3f339697a0b036062ba7784ab41232/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=609d0bd8ac3f339697a0b036062ba7784ab41232", "patch": "@@ -38,7 +38,6 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{\n     bounds_to_string,\n     generic_params_to_string,\n-    path_to_string,\n     ty_to_string\n };\n use syntax::ptr::P;\n@@ -218,95 +217,21 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.dumper.compilation_opts(data);\n     }\n \n-    // Return all non-empty prefixes of a path.\n-    // For each prefix, we return the span for the last segment in the prefix and\n-    // a str representation of the entire prefix.\n-    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n-        let segments = &path.segments[if path.is_global() { 1 } else { 0 }..];\n-\n-        let mut result = Vec::with_capacity(segments.len());\n-        let mut segs = Vec::with_capacity(segments.len());\n-\n-        for (i, seg) in segments.iter().enumerate() {\n-            segs.push(seg.clone());\n-            let sub_path = ast::Path {\n-                span: seg.ident.span, // span for the last segment\n-                segments: segs,\n-            };\n-            let qualname = if i == 0 && path.is_global() {\n-                format!(\"::{}\", path_to_string(&sub_path))\n-            } else {\n-                path_to_string(&sub_path)\n-            };\n-            result.push((seg.ident.span, qualname));\n-            segs = sub_path.segments;\n-        }\n-\n-        result\n-    }\n-\n     fn write_sub_paths(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        for (span, _) in sub_paths {\n-            let span = self.span_from_span(span);\n-            self.dumper.dump_ref(Ref {\n-                kind: RefKind::Mod,\n-                span,\n-                ref_id: ::null_id(),\n-            });\n+        for seg in &path.segments {\n+            if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n+                self.dumper.dump_ref(data);\n+            }\n         }\n     }\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n     fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-\n-        for (span, _) in sub_paths.into_iter().take(len - 1) {\n-            let span = self.span_from_span(span);\n-            self.dumper.dump_ref(Ref {\n-                kind: RefKind::Mod,\n-                span,\n-                ref_id: ::null_id(),\n-            });\n-        }\n-    }\n-\n-    // As write_sub_paths, but expects a path of the form module_path::trait::method\n-    // Where trait could actually be a struct too.\n-    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[..(len - 1)];\n-\n-        // write the trait part of the sub-path\n-        let (ref span, _) = sub_paths[len - 2];\n-        let span = self.span_from_span(*span);\n-        self.dumper.dump_ref(Ref {\n-            kind: RefKind::Type,\n-            ref_id: ::null_id(),\n-            span,\n-        });\n-\n-        // write the other sub-paths\n-        if len <= 2 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[..len - 2];\n-        for &(ref span, _) in sub_paths {\n-            let span = self.span_from_span(*span);\n-            self.dumper.dump_ref(Ref {\n-                kind: RefKind::Mod,\n-                span,\n-                ref_id: ::null_id(),\n-            });\n+        for seg in &path.segments[..path.segments.len() - 1] {\n+            if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n+                self.dumper.dump_ref(data);\n+            }\n         }\n     }\n \n@@ -876,29 +801,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             }\n         }\n \n-        // Modules or types in the path prefix.\n-        match self.save_ctxt.get_path_def(id) {\n-            HirDef::Method(did) => {\n-                let ti = self.tcx.associated_item(did);\n-                if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n-                    self.write_sub_path_trait_truncated(path);\n-                }\n-            }\n-            HirDef::Fn(..) |\n-            HirDef::Const(..) |\n-            HirDef::Static(..) |\n-            HirDef::StructCtor(..) |\n-            HirDef::VariantCtor(..) |\n-            HirDef::AssociatedConst(..) |\n-            HirDef::Local(..) |\n-            HirDef::Upvar(..) |\n-            HirDef::Struct(..) |\n-            HirDef::Union(..) |\n-            HirDef::Variant(..) |\n-            HirDef::TyAlias(..) |\n-            HirDef::AssociatedTy(..) => self.write_sub_paths_truncated(path),\n-            _ => {}\n-        }\n+        self.write_sub_paths_truncated(path);\n     }\n \n     fn process_struct_lit("}, {"sha": "c4777393a9897dfb3ec0818f31d403eda0558b2a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/609d0bd8ac3f339697a0b036062ba7784ab41232/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609d0bd8ac3f339697a0b036062ba7784ab41232/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=609d0bd8ac3f339697a0b036062ba7784ab41232", "patch": "@@ -684,31 +684,28 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Ref> {\n+    pub fn get_path_data(&self, _id: NodeId, path: &ast::Path) -> Option<Ref> {\n+        path.segments.last().and_then(|seg| self.get_path_segment_data(seg))\n+    }\n+\n+    pub fn get_path_segment_data(&self, path_seg: &ast::PathSegment) -> Option<Ref> {\n         // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n-        fn fn_type(path: &ast::Path) -> bool {\n-            if path.segments.len() != 1 {\n-                return false;\n-            }\n-            if let Some(ref generic_args) = path.segments[0].args {\n+        fn fn_type(seg: &ast::PathSegment) -> bool {\n+            if let Some(ref generic_args) = seg.args {\n                 if let ast::GenericArgs::Parenthesized(_) = **generic_args {\n                     return true;\n                 }\n             }\n             false\n         }\n \n-        if path.segments.is_empty() {\n-            return None;\n-        }\n+        let def = self.get_path_def(path_seg.id);\n+        let span = path_seg.ident.span;\n+        filter!(self.span_utils, span);\n+        let span = self.span_from_span(span);\n \n-        let def = self.get_path_def(id);\n-        let last_seg = &path.segments[path.segments.len() - 1];\n-        let sub_span = last_seg.ident.span;\n-        filter!(self.span_utils, sub_span);\n         match def {\n             HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n@@ -719,20 +716,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Const(..) |\n             HirDef::AssociatedConst(..) |\n             HirDef::VariantCtor(..) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n                     ref_id: id_from_def_id(def.def_id()),\n                 })\n             }\n-            HirDef::Trait(def_id) if fn_type(path) => {\n-                // Function type bounds are desugared in the parser, so we have to\n-                // special case them here.\n-                let fn_span = path.segments.first().unwrap().ident.span;\n+            HirDef::Trait(def_id) if fn_type(path_seg) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n-                    span: self.span_from_span(fn_span),\n+                    span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n@@ -748,7 +741,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Trait(def_id) |\n             HirDef::Existential(def_id) |\n             HirDef::TyParam(def_id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n@@ -759,7 +751,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n-                let span = self.span_from_span(sub_span);\n                 let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n                 Some(Ref {\n                     kind: RefKind::Type,\n@@ -778,23 +769,20 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n                 })\n             }\n             HirDef::Fn(def_id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n             HirDef::Mod(def_id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Mod,\n                     span,"}]}