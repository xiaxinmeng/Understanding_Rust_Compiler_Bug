{"sha": "6234a898287fc2241f81373d9ad289788b49ebf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMzRhODk4Mjg3ZmMyMjQxZjgxMzczZDlhZDI4OTc4OGI0OWViZjE=", "commit": {"author": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-02-07T18:47:57Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-05-02T13:36:11Z"}, "message": "store RegionVariableInfo and not just RegionVariableOrigin", "tree": {"sha": "96e4aba188a272e33d8365f9a2111fed69cb2762", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96e4aba188a272e33d8365f9a2111fed69cb2762"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6234a898287fc2241f81373d9ad289788b49ebf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6234a898287fc2241f81373d9ad289788b49ebf1", "html_url": "https://github.com/rust-lang/rust/commit/6234a898287fc2241f81373d9ad289788b49ebf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6234a898287fc2241f81373d9ad289788b49ebf1/comments", "author": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "360cbf2f486dea1c89253187e431f414ecbaa20d", "url": "https://api.github.com/repos/rust-lang/rust/commits/360cbf2f486dea1c89253187e431f414ecbaa20d", "html_url": "https://github.com/rust-lang/rust/commit/360cbf2f486dea1c89253187e431f414ecbaa20d"}], "stats": {"total": 77, "additions": 42, "deletions": 35}, "files": [{"sha": "5984a831e6fa0eeb4028a539040af99763d2de31", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6234a898287fc2241f81373d9ad289788b49ebf1", "patch": "@@ -15,7 +15,7 @@ use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n-use infer::region_constraints::VarOrigins;\n+use infer::region_constraints::VarInfos;\n use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -37,7 +37,7 @@ mod graphviz;\n /// all the variables as well as a set of errors that must be reported.\n pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, '_, 'tcx>,\n-    var_origins: VarOrigins,\n+    var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n ) -> (\n     LexicalRegionResolutions<'tcx>,\n@@ -47,7 +47,7 @@ pub fn resolve<'tcx>(\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver {\n         region_rels,\n-        var_origins,\n+        var_infos,\n         data,\n     };\n     let values = resolver.infer_variable_values(&mut errors);\n@@ -103,7 +103,7 @@ type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n-    var_origins: VarOrigins,\n+    var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n }\n \n@@ -132,7 +132,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     }\n \n     fn num_vars(&self) -> usize {\n-        self.var_origins.len()\n+        self.var_infos.len()\n     }\n \n     /// Initially, the value for all variables is set to `'empty`, the\n@@ -279,7 +279,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n-                    self.var_origins[v_id].span(),\n+                    self.var_infos[v_id].origin.span(),\n                     \"lub_concrete_regions invoked with non-concrete \\\n                      regions: {:?}, {:?}\",\n                     a,\n@@ -576,7 +576,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 if !self.region_rels\n                     .is_subregion_of(lower_bound.region, upper_bound.region)\n                 {\n-                    let origin = self.var_origins[node_idx].clone();\n+                    let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n@@ -598,7 +598,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         }\n \n         span_bug!(\n-            self.var_origins[node_idx].span(),\n+            self.var_infos[node_idx].origin.span(),\n             \"collect_error_for_expanding_node() could not find \\\n              error for var {:?}, lower_bounds={:?}, \\\n              upper_bounds={:?}\","}, {"sha": "6e455f1e9739fdac9cada50ac2f2d906a4c7c6ce", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6234a898287fc2241f81373d9ad289788b49ebf1", "patch": "@@ -42,7 +42,7 @@ use arena::SyncDroplessArena;\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarOrigins};\n+use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarInfos};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n@@ -889,7 +889,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().var_origins().len()\n+        self.borrow_region_constraints().num_region_vars()\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n@@ -1017,12 +1017,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 region_context,\n                                                 region_map,\n                                                 outlives_env.free_region_map());\n-        let (var_origins, data) = self.region_constraints.borrow_mut()\n+        let (var_infos, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")\n-                                                         .into_origins_and_data();\n+                                                         .into_infos_and_data();\n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_origins, data);\n+            lexical_region_resolve::resolve(region_rels, var_infos, data);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n@@ -1070,13 +1070,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// hence that `resolve_regions_and_report_errors` can never be\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region vairables into the NLL region context.\n-    pub fn take_region_var_origins(&self) -> VarOrigins {\n-        let (var_origins, data) = self.region_constraints.borrow_mut()\n+    pub fn take_region_var_origins(&self) -> VarInfos {\n+        let (var_infos, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")\n-                                                         .into_origins_and_data();\n+                                                         .into_infos_and_data();\n         assert!(data.is_empty());\n-        var_origins\n+        var_infos\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {"}, {"sha": "4d5f8b2b11e708ca0ef251af20f12764434146e4", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=6234a898287fc2241f81373d9ad289788b49ebf1", "patch": "@@ -33,7 +33,7 @@ mod taint;\n \n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n-    var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n+    var_infos: IndexVec<RegionVid, RegionVariableInfo>,\n \n     data: RegionConstraintData<'tcx>,\n \n@@ -76,7 +76,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n }\n \n-pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n+pub type VarInfos = IndexVec<RegionVid, RegionVariableInfo>;\n \n /// The full set of region constraints gathered up by the collector.\n /// Describes constraints between the region variables and other\n@@ -230,6 +230,11 @@ enum CombineMapType {\n \n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n+#[derive(Debug, Clone, Copy)]\n+pub struct RegionVariableInfo {\n+    pub origin: RegionVariableOrigin,\n+}\n+\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n@@ -273,7 +278,7 @@ impl TaintDirections {\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> RegionConstraintCollector<'tcx> {\n         RegionConstraintCollector {\n-            var_origins: VarOrigins::default(),\n+            var_infos: VarInfos::default(),\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n@@ -284,8 +289,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn var_origins(&self) -> &VarOrigins {\n-        &self.var_origins\n+    pub fn num_region_vars(&self) -> usize {\n+        self.var_infos.len()\n     }\n \n     pub fn region_constraint_data(&self) -> &RegionConstraintData<'tcx> {\n@@ -295,9 +300,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// Once all the constraints have been gathered, extract out the final data.\n     ///\n     /// Not legal during a snapshot.\n-    pub fn into_origins_and_data(self) -> (VarOrigins, RegionConstraintData<'tcx>) {\n+    pub fn into_infos_and_data(self) -> (VarInfos, RegionConstraintData<'tcx>) {\n         assert!(!self.in_snapshot());\n-        (self.var_origins, self.data)\n+        (self.var_infos, self.data)\n     }\n \n     /// Takes (and clears) the current set of constraints. Note that\n@@ -319,7 +324,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // should think carefully about whether it needs to be cleared\n         // or updated in some way.\n         let RegionConstraintCollector {\n-            var_origins,\n+            var_infos,\n             data,\n             lubs,\n             glbs,\n@@ -343,7 +348,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n         *unification_table = ut::UnificationTable::new();\n-        for vid in var_origins.indices() {\n+        for vid in var_infos.indices() {\n             unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n         }\n \n@@ -411,8 +416,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n-                self.var_origins.pop().unwrap();\n-                assert_eq!(self.var_origins.len(), vid.index() as usize);\n+                self.var_infos.pop().unwrap();\n+                assert_eq!(self.var_infos.len(), vid.index() as usize);\n             }\n             AddConstraint(ref constraint) => {\n                 self.data.constraints.remove(constraint);\n@@ -434,7 +439,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = self.var_origins.push(origin.clone());\n+        let vid = self.var_infos.push(RegionVariableInfo {\n+            origin,\n+        });\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -452,7 +459,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     /// Returns the origin for the given variable.\n     pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_origins[vid].clone()\n+        self.var_infos[vid].origin\n     }\n \n     /// Creates a new skolemized region. Skolemized regions are fresh"}, {"sha": "4d1f3e2b4300ab30a8ed6927cfe0029b6f78bca9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6234a898287fc2241f81373d9ad289788b49ebf1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=6234a898287fc2241f81373d9ad289788b49ebf1", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n+use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n                  Local, Location, Mir};\n use rustc::traits::ObligationCause;\n@@ -256,19 +256,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// of those will be constant regions representing the free\n     /// regions defined in `universal_regions`.\n     pub(crate) fn new(\n-        var_origins: VarOrigins,\n+        var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n     ) -> Self {\n-        let num_region_variables = var_origins.len();\n+        let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n         let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n-        let definitions = var_origins\n+        let definitions = var_infos\n             .into_iter()\n-            .map(|origin| RegionDefinition::new(origin))\n+            .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n         let mut result = Self {"}]}