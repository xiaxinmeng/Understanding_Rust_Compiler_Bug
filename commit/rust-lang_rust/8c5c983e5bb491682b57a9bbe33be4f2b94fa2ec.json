{"sha": "8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "node_id": "C_kwDOAAsO6NoAKDhjNWM5ODNlNWJiNDkxNjgyYjU3YTliYmUzM2JlNGYyYjk0ZmEyZWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-14T13:54:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-14T13:54:03Z"}, "message": "Rollup merge of #98580 - PrestonFrom:issue_98466, r=estebank\n\nEmit warning when named arguments are used positionally in format\n\nAddresses Issue 98466 by emitting an error if a named argument\nis used like a position argument (i.e. the name is not used in\nthe string to be formatted).\n\nFixes rust-lang#98466", "tree": {"sha": "c4f2bbc777a276d0394cb3912e9f9a72aac49373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4f2bbc777a276d0394cb3912e9f9a72aac49373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi0B/7CRBK7hj4Ov3rIwAA+zcIAGjGEU9dFFVFSpU/f9fIUHCL\ngxFFQZZme2w19bKU8H97CGsl+XtyikSXV3xyHNKD0VdX4tbEyYL5z3Bkoeeqt7IM\nrp3vUP7A3R6UYoiPwHYLEEXunDm4pRw9bjy3WrQH3u3Po98WCDHTmeyx66kj4i6O\nUd/3xspcG5vyOAk1g7p7dgaQeWr4uZQdU+GEUf1tl64TPa9yC88BR9GylCxtgRpP\nLtncdOVTzQkjeSQBdZeH9Q9v+zb3VIK0z1avmVTQhregebb9xJEILfEHP7h4JMK/\nVGy4e8FfkN61goEsppLJUb8wBPQWLDRYudjr+hF4xuQ1n/QlH7Bxzshsfo9o8aQ=\n=Z/Ik\n-----END PGP SIGNATURE-----\n", "payload": "tree c4f2bbc777a276d0394cb3912e9f9a72aac49373\nparent 2b17aa67fc91b233bcca7ee91d55ee37706b01c7\nparent 1219f72f9049817cf5933112f75bbddf360a7a1f\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657806843 +0530\ncommitter GitHub <noreply@github.com> 1657806843 +0530\n\nRollup merge of #98580 - PrestonFrom:issue_98466, r=estebank\n\nEmit warning when named arguments are used positionally in format\n\nAddresses Issue 98466 by emitting an error if a named argument\nis used like a position argument (i.e. the name is not used in\nthe string to be formatted).\n\nFixes rust-lang#98466\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "html_url": "https://github.com/rust-lang/rust/commit/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b17aa67fc91b233bcca7ee91d55ee37706b01c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b17aa67fc91b233bcca7ee91d55ee37706b01c7", "html_url": "https://github.com/rust-lang/rust/commit/2b17aa67fc91b233bcca7ee91d55ee37706b01c7"}, {"sha": "1219f72f9049817cf5933112f75bbddf360a7a1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1219f72f9049817cf5933112f75bbddf360a7a1f", "html_url": "https://github.com/rust-lang/rust/commit/1219f72f9049817cf5933112f75bbddf360a7a1f"}], "stats": {"total": 340, "additions": 324, "deletions": 16}, "files": [{"sha": "4791151c7d3095e18205dd26986d5703642edf18", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 72, "deletions": 13, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -14,6 +14,9 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{InnerSpan, Span};\n use smallvec::SmallVec;\n \n+use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n+use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n+use rustc_parse_format::{Count, FormatSpec};\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n \n@@ -57,7 +60,7 @@ struct Context<'a, 'b> {\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<Symbol, usize>,\n+    names: FxHashMap<Symbol, (usize, Span)>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -130,9 +133,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>)> {\n+) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, (usize, Span)>)> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n-    let mut names = FxHashMap::<Symbol, usize>::default();\n+    let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -197,7 +200,7 @@ fn parse_args<'a>(\n                 p.bump();\n                 p.expect(&token::Eq)?;\n                 let e = p.parse_expr()?;\n-                if let Some(prev) = names.get(&ident.name) {\n+                if let Some((prev, _)) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n                         .span_label(args[*prev].span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n@@ -210,7 +213,7 @@ fn parse_args<'a>(\n                 // if the input is valid, we can simply append to the positional\n                 // args. And remember the names.\n                 let slot = args.len();\n-                names.insert(ident.name, slot);\n+                names.insert(ident.name, (slot, ident.span));\n                 args.push(e);\n             }\n             _ => {\n@@ -222,7 +225,7 @@ fn parse_args<'a>(\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n                     for pos in names.values() {\n-                        err.span_label(args[*pos].span, \"named argument\");\n+                        err.span_label(args[pos.0].span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n@@ -242,7 +245,8 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s: &str| *self.names.get(&Symbol::intern(s)).unwrap_or(&0);\n+        let lookup =\n+            |s: &str| self.names.get(&Symbol::intern(s)).unwrap_or(&(0, Span::default())).0;\n \n         match *p {\n             parse::String(_) => {}\n@@ -548,7 +552,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 match self.names.get(&name) {\n                     Some(&idx) => {\n                         // Treat as positional arg.\n-                        self.verify_arg_type(Capture(idx), ty)\n+                        self.verify_arg_type(Capture(idx.0), ty)\n                     }\n                     None => {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -565,7 +569,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             };\n                             self.num_captured_args += 1;\n                             self.args.push(self.ecx.expr_ident(span, Ident::new(name, span)));\n-                            self.names.insert(name, idx);\n+                            self.names.insert(name, (idx, span));\n                             self.verify_arg_type(Capture(idx), ty)\n                         } else {\n                             let msg = format!(\"there is no argument named `{}`\", name);\n@@ -967,14 +971,57 @@ pub fn expand_format_args_nl<'cx>(\n     expand_format_args_impl(ecx, sp, tts, true)\n }\n \n+fn lint_named_arguments_used_positionally(\n+    names: FxHashMap<Symbol, (usize, Span)>,\n+    cx: &mut Context<'_, '_>,\n+    unverified_pieces: Vec<parse::Piece<'_>>,\n+) {\n+    let mut used_argument_names = FxHashSet::<&str>::default();\n+    for piece in unverified_pieces {\n+        if let rustc_parse_format::Piece::NextArgument(a) = piece {\n+            match a.position {\n+                rustc_parse_format::Position::ArgumentNamed(arg_name, _) => {\n+                    used_argument_names.insert(arg_name);\n+                }\n+                _ => {}\n+            };\n+            match a.format {\n+                FormatSpec { width: Count::CountIsName(s, _), .. }\n+                | FormatSpec { precision: Count::CountIsName(s, _), .. } => {\n+                    used_argument_names.insert(s);\n+                }\n+                _ => {}\n+            };\n+        }\n+    }\n+\n+    for (symbol, (index, span)) in names {\n+        if !used_argument_names.contains(symbol.as_str()) {\n+            let msg = format!(\"named argument `{}` is not used by name\", symbol.as_str());\n+            let arg_span = cx.arg_spans[index];\n+            cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n+                span: MultiSpan::from_span(span),\n+                msg: msg.clone(),\n+                node_id: ast::CRATE_NODE_ID,\n+                lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n+                diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally(\n+                    arg_span,\n+                    span,\n+                    symbol.to_string(),\n+                ),\n+            });\n+        }\n+    }\n+}\n+\n /// Take the various parts of `format_args!(efmt, args..., name=names...)`\n /// and construct the appropriate formatting expression.\n pub fn expand_preparsed_format_args(\n     ecx: &mut ExtCtxt<'_>,\n     sp: Span,\n     efmt: P<ast::Expr>,\n     args: Vec<P<ast::Expr>>,\n-    names: FxHashMap<Symbol, usize>,\n+    names: FxHashMap<Symbol, (usize, Span)>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n@@ -1073,7 +1120,12 @@ pub fn expand_preparsed_format_args(\n         .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n         .collect();\n \n-    let named_pos: FxHashSet<usize> = names.values().cloned().collect();\n+    let named_pos: FxHashSet<usize> = names.values().cloned().map(|(i, _)| i).collect();\n+\n+    // Clone `names` because `names` in Context get updated by verify_piece, which includes usages\n+    // of the names of named arguments, resulting in incorrect errors if a name argument is used\n+    // but not declared, such as: `println!(\"x = {x}\");`\n+    let named_arguments = names.clone();\n \n     let mut cx = Context {\n         ecx,\n@@ -1101,9 +1153,11 @@ pub fn expand_preparsed_format_args(\n         is_literal: parser.is_literal,\n     };\n \n-    // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n+    // This needs to happen *after* the Parser has consumed all pieces to create all the spans.\n+    // unverified_pieces is used later to check named argument names are used, so clone each piece.\n     let pieces = unverified_pieces\n-        .into_iter()\n+        .iter()\n+        .cloned()\n         .map(|mut piece| {\n             cx.verify_piece(&piece);\n             cx.resolve_name_inplace(&mut piece);\n@@ -1265,6 +1319,11 @@ pub fn expand_preparsed_format_args(\n         }\n \n         diag.emit();\n+    } else if cx.invalid_refs.is_empty() && !named_arguments.is_empty() {\n+        // Only check for unused named argument names if there are no other errors to avoid causing\n+        // too much noise in output errors, such as when a named argument is entirely unused.\n+        // We also only need to perform this check if there are actually named arguments.\n+        lint_named_arguments_used_positionally(named_arguments, &mut cx, unverified_pieces);\n     }\n \n     cx.into_expr()"}, {"sha": "e1f19064d522fb0cdae76e32de9871b032b88471", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n-use rustc_lint_defs::BuiltinLintDiagnostics;\n+use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit, Session, SessionDiagnostic};\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId};\n@@ -988,6 +988,8 @@ pub struct ExtCtxt<'a> {\n     pub expansions: FxHashMap<Span, Vec<String>>,\n     /// Used for running pre-expansion lints on freshly loaded modules.\n     pub(super) lint_store: LintStoreExpandDyn<'a>,\n+    /// Used for storing lints generated during expansion, like `NAMED_ARGUMENTS_USED_POSITIONALLY`\n+    pub buffered_early_lint: Vec<BufferedEarlyLint>,\n     /// When we 'expand' an inert attribute, we leave it\n     /// in the AST, but insert it here so that we know\n     /// not to expand it again.\n@@ -1020,6 +1022,7 @@ impl<'a> ExtCtxt<'a> {\n             force_mode: false,\n             expansions: FxHashMap::default(),\n             expanded_inert_attrs: MarkedAttrs::new(),\n+            buffered_early_lint: vec![],\n         }\n     }\n "}, {"sha": "0529fff5a6b47d9e5501d35e83fae7a89f926965", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -14,7 +14,7 @@ use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n-use rustc_lint::{EarlyCheckNode, LintStore};\n+use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_metadata::{encode_metadata, EncodedMetadata};\n use rustc_middle::arena::Arena;\n@@ -336,12 +336,15 @@ pub fn configure_and_expand(\n \n         let lint_store = LintStoreExpandImpl(lint_store);\n         let mut ecx = ExtCtxt::new(sess, cfg, resolver, Some(&lint_store));\n-\n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n \n         // The rest is error reporting\n \n+        sess.parse_sess.buffered_lints.with_lock(|buffered_lints: &mut Vec<BufferedEarlyLint>| {\n+            buffered_lints.append(&mut ecx.buffered_early_lint);\n+        });\n+\n         sess.time(\"check_unused_macros\", || {\n             ecx.check_unused_macros();\n         });"}, {"sha": "13e3bb9a36341d5c901c93076027c2010fb41f73", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -857,6 +857,18 @@ pub trait LintContext: Sized {\n                         Applicability::MachineApplicable,\n                     );\n                 },\n+                BuiltinLintDiagnostics::NamedArgumentUsedPositionally(positional_arg, named_arg, name) => {\n+                    db.span_label(named_arg, \"this named argument is only referred to by position in formatting string\");\n+                    let msg = format!(\"this formatting argument uses named argument `{}` by position\", name);\n+                    db.span_label(positional_arg, msg);\n+                    db.span_suggestion_verbose(\n+                        positional_arg,\n+                        \"use the named argument by name to avoid ambiguity\",\n+                        format!(\"{{{}}}\", name),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "39690851d1ea831589a35723a5db416b1ec5da7c", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -3292,6 +3292,7 @@ declare_lint_pass! {\n         TEST_UNSTABLE_LINT,\n         FFI_UNWIND_CALLS,\n         REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n+        NAMED_ARGUMENTS_USED_POSITIONALLY,\n     ]\n }\n \n@@ -3996,3 +3997,33 @@ declare_lint! {\n     \"call to foreign functions or function pointers with FFI-unwind ABI\",\n     @feature_gate = sym::c_unwind;\n }\n+\n+declare_lint! {\n+    /// The `named_arguments_used_positionally` lint detects cases where named arguments are only\n+    /// used positionally in format strings. This usage is valid but potentially very confusing.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(named_arguments_used_positionally)]\n+    /// fn main() {\n+    ///     let _x = 5;\n+    ///     println!(\"{}\", _x = 1); // Prints 1, will trigger lint\n+    ///\n+    ///     println!(\"{}\", _x); // Prints 5, no lint emitted\n+    ///     println!(\"{_x}\", _x = _x); // Prints 5, no lint emitted\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Rust formatting strings can refer to named arguments by their position, but this usage is\n+    /// potentially confusing. In particular, readers can incorrectly assume that the declaration\n+    /// of named arguments is an assignment (which would produce the unit type).\n+    /// For backwards compatibility, this is not a hard error.\n+    pub NAMED_ARGUMENTS_USED_POSITIONALLY,\n+    Warn,\n+    \"named arguments in format used positionally\"\n+}"}, {"sha": "1bc7e7de66040e91a528d77b6df20a5abbc98608", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -467,6 +467,7 @@ pub enum BuiltinLintDiagnostics {\n         /// If true, the lifetime will be fully elided.\n         use_span: Option<(Span, bool)>,\n     },\n+    NamedArgumentUsedPositionally(Span, Span, String),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "c260148c148d0c4f959de4bff80feaaab7d7e724", "filename": "src/test/ui/macros/issue-98466-allow.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466-allow.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+#![allow(named_arguments_used_positionally)]\n+\n+fn main() {\n+    let mut _x: usize;\n+    _x = 1;\n+    println!(\"_x is {}\", _x = 5);\n+    println!(\"_x is {}\", y = _x);\n+    println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+\n+    let mut _x: usize;\n+    _x = 1;\n+    let _f = format!(\"_x is {}\", _x = 5);\n+    let _f = format!(\"_x is {}\", y = _x);\n+    let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+}"}, {"sha": "e46e22f001fe3c7536b66bf5d133eb1538041eae", "filename": "src/test/ui/macros/issue-98466.fixed", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.fixed?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -0,0 +1,51 @@\n+// check-pass\n+// run-rustfix\n+\n+fn main() {\n+    let mut _x: usize;\n+    _x = 1;\n+    println!(\"_x is {_x}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"_x is {y}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let mut _x: usize;\n+    _x = 1;\n+    let _f = format!(\"_x is {_x}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"_x is {y}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let s = \"0.009\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\".{:0<width$}\", s, width = _x);\n+\n+    let region = \"abc\";\n+    let width = 8;\n+    let ls = \"abcde\";\n+    let full = \"abcde\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\n+        \"| {r:rw$?} | {ui:4?} | {v}\",\n+        r = region,\n+        rw = width,\n+        ui = ls,\n+        v = full,\n+    );\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a = 4);\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a = 4);\n+}"}, {"sha": "2c3b099afdeafeb4cef830a1a35af04b983f9eb8", "filename": "src/test/ui/macros/issue-98466.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -0,0 +1,51 @@\n+// check-pass\n+// run-rustfix\n+\n+fn main() {\n+    let mut _x: usize;\n+    _x = 1;\n+    println!(\"_x is {}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"_x is {}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let mut _x: usize;\n+    _x = 1;\n+    let _f = format!(\"_x is {}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"_x is {}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let s = \"0.009\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\".{:0<width$}\", s, width = _x);\n+\n+    let region = \"abc\";\n+    let width = 8;\n+    let ls = \"abcde\";\n+    let full = \"abcde\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\n+        \"| {r:rw$?} | {ui:4?} | {v}\",\n+        r = region,\n+        rw = width,\n+        ui = ls,\n+        v = full,\n+    );\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a = 4);\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a = 4);\n+}"}, {"sha": "ad11d181b6218608049f9cfc581136e257a6f211", "filename": "src/test/ui/macros/issue-98466.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -0,0 +1,81 @@\n+warning: named argument `_x` is not used by name\n+  --> $DIR/issue-98466.rs:7:26\n+   |\n+LL |     println!(\"_x is {}\", _x = 5);\n+   |                     --   ^^ this named argument is only referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `_x` by position\n+   |\n+   = note: `#[warn(named_arguments_used_positionally)]` on by default\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"_x is {_x}\", _x = 5);\n+   |                     ~~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:10:26\n+   |\n+LL |     println!(\"_x is {}\", y = _x);\n+   |                     --   ^ this named argument is only referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"_x is {y}\", y = _x);\n+   |                     ~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:13:83\n+   |\n+LL |     println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+   |                                                                        --         ^ this named argument is only referred to by position in formatting string\n+   |                                                                        |\n+   |                                                                        this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+   |                                                                        ~~~\n+\n+warning: named argument `_x` is not used by name\n+  --> $DIR/issue-98466.rs:19:34\n+   |\n+LL |     let _f = format!(\"_x is {}\", _x = 5);\n+   |                             --   ^^ this named argument is only referred to by position in formatting string\n+   |                             |\n+   |                             this formatting argument uses named argument `_x` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     let _f = format!(\"_x is {_x}\", _x = 5);\n+   |                             ~~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:22:34\n+   |\n+LL |     let _f = format!(\"_x is {}\", y = _x);\n+   |                             --   ^ this named argument is only referred to by position in formatting string\n+   |                             |\n+   |                             this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     let _f = format!(\"_x is {y}\", y = _x);\n+   |                             ~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:25:91\n+   |\n+LL |     let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+   |                                                                                --         ^ this named argument is only referred to by position in formatting string\n+   |                                                                                |\n+   |                                                                                this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     let _f = format!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+   |                                                                                ~~~\n+\n+warning: 6 warnings emitted\n+"}]}