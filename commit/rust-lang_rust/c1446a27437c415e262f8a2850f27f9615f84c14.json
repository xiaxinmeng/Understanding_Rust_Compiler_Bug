{"sha": "c1446a27437c415e262f8a2850f27f9615f84c14", "node_id": "C_kwDOAAsO6NoAKGMxNDQ2YTI3NDM3YzQxNWUyNjJmOGEyODUwZjI3Zjk2MTVmODRjMTQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-18T08:45:53Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-18T08:45:53Z"}, "message": "Move `CompletionContext::impl_def` into corresponding entities", "tree": {"sha": "ce6ec33d546174879aa81e53aa740dba5e19f518", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce6ec33d546174879aa81e53aa740dba5e19f518"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1446a27437c415e262f8a2850f27f9615f84c14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1446a27437c415e262f8a2850f27f9615f84c14", "html_url": "https://github.com/rust-lang/rust/commit/c1446a27437c415e262f8a2850f27f9615f84c14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1446a27437c415e262f8a2850f27f9615f84c14/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83e8f3ac308aab3c51158c6a27491a4e8796f361", "url": "https://api.github.com/repos/rust-lang/rust/commits/83e8f3ac308aab3c51158c6a27491a4e8796f361", "html_url": "https://github.com/rust-lang/rust/commit/83e8f3ac308aab3c51158c6a27491a4e8796f361"}], "stats": {"total": 145, "additions": 97, "deletions": 48}, "files": [{"sha": "284372f7fc516025ae1f2bb8b28377a4d351570b", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -24,6 +24,7 @@ use std::iter;\n \n use hir::{db::HirDatabase, known, ScopeDef};\n use ide_db::SymbolKind;\n+use syntax::ast;\n \n use crate::{\n     context::Visible,\n@@ -409,11 +410,12 @@ fn enum_variants_with_paths(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     enum_: hir::Enum,\n+    impl_: &Option<ast::Impl>,\n     cb: impl Fn(&mut Completions, &CompletionContext, hir::Variant, hir::ModPath),\n ) {\n     let variants = enum_.variants(ctx.db);\n \n-    if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n+    if let Some(impl_) = impl_.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n         if impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_)) {\n             for &variant in &variants {\n                 let self_path = hir::ModPath::from_segments("}, {"sha": "83ecb51aaabd34139c373d97e159fd7e02484b38", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -27,6 +27,7 @@ pub(crate) fn complete_expr_path(\n         in_condition,\n         ty,\n         incomplete_let,\n+        impl_,\n     ) = match path_ctx {\n         &PathCompletionCtx {\n             kind:\n@@ -39,6 +40,7 @@ pub(crate) fn complete_expr_path(\n                     ref ref_expr_parent,\n                     ref is_func_update,\n                     ref innermost_ret_ty,\n+                    ref impl_,\n                     ..\n                 },\n             ref qualified,\n@@ -53,6 +55,7 @@ pub(crate) fn complete_expr_path(\n             in_condition,\n             innermost_ret_ty,\n             incomplete_let,\n+            impl_,\n         ),\n         _ => return,\n     };\n@@ -181,8 +184,7 @@ pub(crate) fn complete_expr_path(\n             if let Some(adt) =\n                 ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n             {\n-                let self_ty =\n-                    (|| ctx.sema.to_def(ctx.impl_def.as_ref()?)?.self_ty(ctx.db).as_adt())();\n+                let self_ty = (|| ctx.sema.to_def(impl_.as_ref()?)?.self_ty(ctx.db).as_adt())();\n                 let complete_self = self_ty == Some(adt);\n \n                 match adt {\n@@ -210,9 +212,15 @@ pub(crate) fn complete_expr_path(\n                         }\n                     }\n                     hir::Adt::Enum(e) => {\n-                        super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                            acc.add_qualified_enum_variant(ctx, variant, path)\n-                        });\n+                        super::enum_variants_with_paths(\n+                            acc,\n+                            ctx,\n+                            e,\n+                            impl_,\n+                            |acc, ctx, variant, path| {\n+                                acc.add_qualified_enum_variant(ctx, variant, path)\n+                            },\n+                        );\n                     }\n                 }\n             }"}, {"sha": "94e2f489f57fa3b260685062d57f229a67b0ff30", "filename": "crates/ide-completion/src/completions/fn_param.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -24,8 +24,8 @@ pub(crate) fn complete_fn_param(\n     ctx: &CompletionContext,\n     pattern_ctx: &PatternContext,\n ) -> Option<()> {\n-    let (param_list, _, param_kind) = match pattern_ctx {\n-        PatternContext { param_ctx: Some(kind), .. } => kind,\n+    let ((param_list, _, param_kind), impl_) = match pattern_ctx {\n+        PatternContext { param_ctx: Some(kind), impl_, .. } => (kind, impl_),\n         _ => return None,\n     };\n \n@@ -45,7 +45,7 @@ pub(crate) fn complete_fn_param(\n \n     match param_kind {\n         ParamKind::Function(function) => {\n-            fill_fn_params(ctx, function, param_list, add_new_item_to_acc);\n+            fill_fn_params(ctx, function, param_list, impl_, add_new_item_to_acc);\n         }\n         ParamKind::Closure(closure) => {\n             let stmt_list = closure.syntax().ancestors().find_map(ast::StmtList::cast)?;\n@@ -62,6 +62,7 @@ fn fill_fn_params(\n     ctx: &CompletionContext,\n     function: &ast::Fn,\n     param_list: &ast::ParamList,\n+    impl_: &Option<ast::Impl>,\n     mut add_new_item_to_acc: impl FnMut(&str),\n ) {\n     let mut file_params = FxHashMap::default();\n@@ -104,7 +105,7 @@ fn fill_fn_params(\n     }\n     remove_duplicated(&mut file_params, param_list.params());\n     let self_completion_items = [\"self\", \"&self\", \"mut self\", \"&mut self\"];\n-    if should_add_self_completions(ctx, param_list) {\n+    if should_add_self_completions(param_list, impl_) {\n         self_completion_items.into_iter().for_each(|self_item| add_new_item_to_acc(self_item));\n     }\n \n@@ -155,11 +156,10 @@ fn remove_duplicated(\n     })\n }\n \n-fn should_add_self_completions(ctx: &CompletionContext, param_list: &ast::ParamList) -> bool {\n-    let inside_impl = ctx.impl_def.is_some();\n+fn should_add_self_completions(param_list: &ast::ParamList, impl_: &Option<ast::Impl>) -> bool {\n     let no_params = param_list.params().next().is_none() && param_list.self_param().is_none();\n \n-    inside_impl && no_params\n+    impl_.is_some() && no_params\n }\n \n fn comma_wrapper(ctx: &CompletionContext) -> Option<(impl Fn(&str) -> String, TextRange)> {"}, {"sha": "941273fa971c10767d6ce0f2453c8c30fd17deb5", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -66,7 +66,7 @@ fn add_keywords(acc: &mut Completions, ctx: &CompletionContext, kind: Option<&It\n     let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n     let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock));\n     let in_trait = matches!(kind, Some(ItemListKind::Trait));\n-    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl));\n+    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl(_)));\n     let in_inherent_impl = matches!(kind, Some(ItemListKind::Impl));\n     let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n     let in_block = matches!(kind, None);"}, {"sha": "58b894bdd4320ea0b7159712716c9837416082bc", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -81,7 +81,7 @@ pub(crate) fn complete_trait_impl_name(\n         kind,\n         replacement_range(ctx, &item),\n         // item -> ASSOC_ITEM_LIST -> IMPL\n-        ast::Impl::cast(item.parent()?.parent()?)?,\n+        &ast::Impl::cast(item.parent()?.parent()?)?,\n     );\n     Some(())\n }\n@@ -97,7 +97,7 @@ pub(crate) fn complete_trait_impl_name_ref(\n             kind:\n                 NameRefKind::Path(\n                     path_ctx @ PathCompletionCtx {\n-                        kind: PathKind::Item { kind: ItemListKind::TraitImpl },\n+                        kind: PathKind::Item { kind: ItemListKind::TraitImpl(Some(impl_)) },\n                         ..\n                     },\n                 ),\n@@ -109,7 +109,7 @@ pub(crate) fn complete_trait_impl_name_ref(\n                 Some(name) => name.syntax().text_range(),\n                 None => ctx.source_range(),\n             },\n-            ctx.impl_def.clone()?,\n+            impl_,\n         ),\n         _ => (),\n     }\n@@ -121,10 +121,10 @@ fn complete_trait_impl(\n     ctx: &CompletionContext,\n     kind: ImplCompletionKind,\n     replacement_range: TextRange,\n-    impl_def: ast::Impl,\n+    impl_def: &ast::Impl,\n ) {\n-    if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n-        get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| {\n+    if let Some(hir_impl) = ctx.sema.to_def(impl_def) {\n+        get_missing_assoc_items(&ctx.sema, impl_def).into_iter().for_each(|item| {\n             use self::ImplCompletionKind::*;\n             match (item, kind) {\n                 (hir::AssocItem::Function(func), All | Fn) => {"}, {"sha": "149acb3c1becadeb4301aa82d1911b7cf5720e42", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -51,9 +51,15 @@ pub(crate) fn complete_pattern(\n         ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n     {\n         if refutable || single_variant_enum(e) {\n-            super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                acc.add_qualified_variant_pat(ctx, variant, path);\n-            });\n+            super::enum_variants_with_paths(\n+                acc,\n+                ctx,\n+                e,\n+                &patctx.impl_,\n+                |acc, ctx, variant, path| {\n+                    acc.add_qualified_variant_pat(ctx, variant, path);\n+                },\n+            );\n         }\n     }\n "}, {"sha": "0c7c6ab5af6cd4203d03e64e4cd5bf4a8121ae03", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -98,6 +98,7 @@ pub(super) enum PathKind {\n         is_func_update: Option<ast::RecordExpr>,\n         self_param: Option<hir::SelfParam>,\n         innermost_ret_ty: Option<hir::Type>,\n+        impl_: Option<ast::Impl>,\n     },\n     Type {\n         location: TypeLocation,\n@@ -143,12 +144,12 @@ pub(crate) enum TypeAscriptionTarget {\n }\n \n /// The kind of item list a [`PathKind::Item`] belongs to.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(super) enum ItemListKind {\n     SourceFile,\n     Module,\n     Impl,\n-    TraitImpl,\n+    TraitImpl(Option<ast::Impl>),\n     Trait,\n     ExternBlock,\n }\n@@ -179,6 +180,7 @@ pub(super) struct PatternContext {\n     pub(super) mut_token: Option<SyntaxToken>,\n     /// The record pattern this name or ref is a field of\n     pub(super) record_pat: Option<ast::RecordPat>,\n+    pub(super) impl_: Option<ast::Impl>,\n }\n \n /// The state of the lifetime we are completing.\n@@ -320,10 +322,6 @@ pub(crate) struct CompletionContext<'a> {\n     /// The expected type of what we are completing.\n     pub(super) expected_type: Option<Type>,\n \n-    /// The parent impl of the cursor position if it exists.\n-    // FIXME: This probably doesn't belong here\n-    pub(super) impl_def: Option<ast::Impl>,\n-\n     // FIXME: This shouldn't exist\n     pub(super) previous_token: Option<SyntaxToken>,\n \n@@ -497,7 +495,6 @@ impl<'a> CompletionContext<'a> {\n             module,\n             expected_name: None,\n             expected_type: None,\n-            impl_def: None,\n             previous_token: None,\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },"}, {"sha": "e08fa6bdd35634bb64e6a8fcf660483ec8ca8139", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1446a27437c415e262f8a2850f27f9615f84c14/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=c1446a27437c415e262f8a2850f27f9615f84c14", "patch": "@@ -389,16 +389,6 @@ impl<'a> CompletionContext<'a> {\n                 return Some(());\n             }\n         };\n-        self.impl_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SyntaxKind::SOURCE_FILE)\n-            .filter_map(ast::Item::cast)\n-            .take(2)\n-            .find_map(|it| match it {\n-                ast::Item::Impl(impl_) => Some(impl_),\n-                _ => None,\n-            });\n \n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n@@ -452,7 +442,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name(\n-        _sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name: ast::Name,\n     ) -> Option<NameContext> {\n@@ -464,7 +454,7 @@ impl<'a> CompletionContext<'a> {\n                 ast::Enum(_) => NameKind::Enum,\n                 ast::Fn(_) => NameKind::Function,\n                 ast::IdentPat(bind_pat) => {\n-                    let mut pat_ctx = pattern_context_for(original_file, bind_pat.into());\n+                    let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n                     if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n                         pat_ctx.record_pat = find_node_in_file_compensated(original_file, &record_field.parent_record_pat());\n                     }\n@@ -518,6 +508,7 @@ impl<'a> CompletionContext<'a> {\n                     &record_field.parent_record_pat(),\n                 ),\n                 ..pattern_context_for(\n+                    sema,\n                     original_file,\n                     record_field.parent_record_pat().clone().into(),\n                 )\n@@ -766,6 +757,7 @@ impl<'a> CompletionContext<'a> {\n                 .parent()\n                 .and_then(ast::LetStmt::cast)\n                 .map_or(false, |it| it.semicolon_token().is_none());\n+            let impl_ = fetch_immediate_impl(sema, original_file, &expr);\n \n             PathKind::Expr {\n                 in_block_expr,\n@@ -777,6 +769,7 @@ impl<'a> CompletionContext<'a> {\n                 innermost_ret_ty,\n                 self_param,\n                 incomplete_let,\n+                impl_,\n             }\n         };\n         let make_path_kind_type = |ty: ast::Type| {\n@@ -804,14 +797,14 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())}\n+                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n                     },\n                     ast::RecordPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())}\n+                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n                     },\n                     ast::PathPat(it) => {\n-                        PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())}\n+                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n                     },\n                     ast::MacroCall(it) => {\n                         // A macro call in this position is usually a result of parsing recovery, so check that\n@@ -825,15 +818,15 @@ impl<'a> CompletionContext<'a> {\n                         match_ast! {\n                             match parent {\n                                 ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())},\n+                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n                                 ast::MacroType(ty) => make_path_kind_type(ty.into()),\n                                 ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n                                 ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n                                     Some(it) => match_ast! {\n                                         match it {\n                                             ast::Trait(_) => ItemListKind::Trait,\n                                             ast::Impl(it) => if it.trait_().is_some() {\n-                                                ItemListKind::TraitImpl\n+                                                ItemListKind::TraitImpl(find_node_in_file_compensated(original_file, &it))\n                                             } else {\n                                                 ItemListKind::Impl\n                                             },\n@@ -970,7 +963,11 @@ impl<'a> CompletionContext<'a> {\n     }\n }\n \n-fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternContext {\n+fn pattern_context_for(\n+    sema: &Semantics<RootDatabase>,\n+    original_file: &SyntaxNode,\n+    pat: ast::Pat,\n+) -> PatternContext {\n     let mut is_param = None;\n     let (refutability, has_type_ascription) =\n     pat\n@@ -1011,6 +1008,7 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n         ast::Pat::IdentPat(it) => (it.ref_token(), it.mut_token()),\n         _ => (None, None),\n     };\n+\n     PatternContext {\n         refutability,\n         param_ctx: is_param,\n@@ -1019,6 +1017,44 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n         mut_token,\n         ref_token,\n         record_pat: None,\n+        impl_: fetch_immediate_impl(sema, original_file, &pat),\n+    }\n+}\n+\n+fn fetch_immediate_impl(\n+    sema: &Semantics<RootDatabase>,\n+    original_file: &SyntaxNode,\n+    node: &impl AstNode,\n+) -> Option<ast::Impl> {\n+    // FIXME: The fallback here could be done better\n+    let (f, s) = match find_node_in_file_compensated(original_file, node) {\n+        Some(node) => {\n+            let mut items = sema\n+                .ancestors_with_macros(node.syntax().clone())\n+                .filter_map(ast::Item::cast)\n+                .filter(|it| !matches!(it, ast::Item::MacroCall(_)))\n+                .take(2);\n+            (items.next(), items.next())\n+        }\n+        None => {\n+            let mut items = node\n+                .syntax()\n+                .ancestors()\n+                .filter_map(ast::Item::cast)\n+                .filter(|it| !matches!(it, ast::Item::MacroCall(_)))\n+                .take(2);\n+            (items.next(), items.next())\n+        }\n+    };\n+\n+    match f? {\n+        ast::Item::Const(_) | ast::Item::Fn(_) | ast::Item::TypeAlias(_) => (),\n+        ast::Item::Impl(it) => return Some(it),\n+        _ => return None,\n+    }\n+    match s? {\n+        ast::Item::Impl(it) => Some(it),\n+        _ => None,\n     }\n }\n "}]}