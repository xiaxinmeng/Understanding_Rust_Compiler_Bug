{"sha": "778b631ff06c463fad290ea8ff8f2817ab62a5fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3OGI2MzFmZjA2YzQ2M2ZhZDI5MGVhOGZmOGYyODE3YWI2MmE1ZmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-29T00:10:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-29T00:10:52Z"}, "message": "Rollup merge of #62809 - alexcrichton:wasm-llvm-9, r=nikic\n\nrustc: Update wasm32 support for LLVM 9\n\nThis commit brings in a number of minor updates for rustc's support for\nthe wasm target which has changed in the LLVM 9 update. Notable updates\ninclude:\n\n* The compiler now no longer manually inserts the `producers` section,\n  instead relying on LLVM to do so. LLVM uses the `llvm.ident` metadata\n  for the `processed-by` directive (which is now emitted on the wasm\n  target in this PR) and it uses debuginfo to figure out what `language`\n  to put in the `producers` section.\n\n* Threaded WebAssembly code now requires different flags to be passed\n  with LLD. In LLD we now pass:\n\n  * `--shared-memory` - required since objects are compiled with\n    atomics. This also means that the generated memory will be marked as\n    `shared`.\n  * `--max-memory=1GB` - required with the `--shared-memory` argument\n    since shared memories in WebAssembly must have a maximum size. The\n    1GB number is intended to be a conservative estimate for rustc, but\n    it should be overridable with `-C link-arg` if necessary.\n  * `--passive-segments` - this has become the default for multithreaded\n    memory, but when compiling a threaded module all data segments need\n    to be marked as passive to ensure they don't re-initialize memory\n    for each thread. This will also cause LLD to emit a synthetic\n    function to initialize memory which users will have to arrange to\n    call.\n  * The `__heap_base` and `__data_end` globals are explicitly exported\n    since they're now hidden by default due to the `--export` flags we\n    pass to LLD.", "tree": {"sha": "45b3e2a9c745e5c6956b9556c011c899285a6bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45b3e2a9c745e5c6956b9556c011c899285a6bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/778b631ff06c463fad290ea8ff8f2817ab62a5fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdPjmMCRBK7hj4Ov3rIwAAdHIIABPLKth2IP6kA9MRqeBvfvbc\nWbhEWbnCPJeN2g91joGwf0jhLZz8j1zQP6+Oox2uieWiL83LBnMZ/YSQ/7vGZOw9\nWETa50OVdDWo8U8SH7eGa4Jj235Hxl5fK0yhwfAqyEX3ZU7e/LPjeNx7ZP926wk5\n3JTL8jX0jxJ4ye7qgVQdyNe57oKYPx7RnyhMjNtxyZBI8GMuniQK6KN7eF2yDcsK\nvM2ENwUsx/XzBVfKkkotCT4bjGfb7qP2NgZJM5QGYR2IqjCvoV9Ak/EMo7kRfsMZ\nOjdkneZfAU00NjWQyTmgusnWyoGpWKvIdBtxs7FiYr/F+N3tYXODYcZH5Pv3Ev8=\n=/rBw\n-----END PGP SIGNATURE-----\n", "payload": "tree 45b3e2a9c745e5c6956b9556c011c899285a6bdc\nparent c7312fe4ff85ada30103cea58db25d83e0bec4b0\nparent dc50a633f3260a3aeb79a4ca9800587be7f732e7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564359052 +0200\ncommitter GitHub <noreply@github.com> 1564359052 +0200\n\nRollup merge of #62809 - alexcrichton:wasm-llvm-9, r=nikic\n\nrustc: Update wasm32 support for LLVM 9\n\nThis commit brings in a number of minor updates for rustc's support for\nthe wasm target which has changed in the LLVM 9 update. Notable updates\ninclude:\n\n* The compiler now no longer manually inserts the `producers` section,\n  instead relying on LLVM to do so. LLVM uses the `llvm.ident` metadata\n  for the `processed-by` directive (which is now emitted on the wasm\n  target in this PR) and it uses debuginfo to figure out what `language`\n  to put in the `producers` section.\n\n* Threaded WebAssembly code now requires different flags to be passed\n  with LLD. In LLD we now pass:\n\n  * `--shared-memory` - required since objects are compiled with\n    atomics. This also means that the generated memory will be marked as\n    `shared`.\n  * `--max-memory=1GB` - required with the `--shared-memory` argument\n    since shared memories in WebAssembly must have a maximum size. The\n    1GB number is intended to be a conservative estimate for rustc, but\n    it should be overridable with `-C link-arg` if necessary.\n  * `--passive-segments` - this has become the default for multithreaded\n    memory, but when compiling a threaded module all data segments need\n    to be marked as passive to ensure they don't re-initialize memory\n    for each thread. This will also cause LLD to emit a synthetic\n    function to initialize memory which users will have to arrange to\n    call.\n  * The `__heap_base` and `__data_end` globals are explicitly exported\n    since they're now hidden by default due to the `--export` flags we\n    pass to LLD.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/778b631ff06c463fad290ea8ff8f2817ab62a5fd", "html_url": "https://github.com/rust-lang/rust/commit/778b631ff06c463fad290ea8ff8f2817ab62a5fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/778b631ff06c463fad290ea8ff8f2817ab62a5fd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7312fe4ff85ada30103cea58db25d83e0bec4b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7312fe4ff85ada30103cea58db25d83e0bec4b0", "html_url": "https://github.com/rust-lang/rust/commit/c7312fe4ff85ada30103cea58db25d83e0bec4b0"}, {"sha": "dc50a633f3260a3aeb79a4ca9800587be7f732e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc50a633f3260a3aeb79a4ca9800587be7f732e7", "html_url": "https://github.com/rust-lang/rust/commit/dc50a633f3260a3aeb79a4ca9800587be7f732e7"}], "stats": {"total": 469, "additions": 131, "deletions": 338}, "files": [{"sha": "f0bdb0018efe7f71fc415390eb4c7a6697640edd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -913,9 +913,12 @@ pub fn compile_unit_metadata(\n     }\n \n     debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n+    let rustc_producer = format!(\n+        \"rustc version {}\",\n+        option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),\n+    );\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n-    let producer = format!(\"clang LLVM (rustc version {})\",\n-                           (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n+    let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n     let name_in_debuginfo = SmallCStr::new(&name_in_debuginfo);\n@@ -980,6 +983,21 @@ pub fn compile_unit_metadata(\n                                               gcov_metadata);\n         }\n \n+        // Insert `llvm.ident` metadata on the wasm32 targets since that will\n+        // get hooked up to the \"producer\" sections `processed-by` information.\n+        if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+            let name_metadata = llvm::LLVMMDStringInContext(\n+                debug_context.llcontext,\n+                rustc_producer.as_ptr() as *const _,\n+                rustc_producer.as_bytes().len() as c_uint,\n+            );\n+            llvm::LLVMAddNamedMetadataOperand(\n+                debug_context.llmod,\n+                const_cstr!(\"llvm.ident\").as_ptr(),\n+                llvm::LLVMMDNodeInContext(debug_context.llcontext, &name_metadata, 1),\n+            );\n+        }\n+\n         return unit_metadata;\n     };\n "}, {"sha": "3f6a1a72ea61ebb674fe212b29665e2520ab5ec2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -678,14 +678,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n         }\n     }\n-\n-    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n-        super::wasm::add_producer_section(\n-            &out_filename,\n-            &sess.edition().to_string(),\n-            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n-        );\n-    }\n }\n \n /// Returns a boolean indicating whether the specified crate should be ignored"}, {"sha": "26091005f25aa72fca26efa45df8de1367482442", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -901,7 +901,45 @@ pub struct WasmLd<'a> {\n }\n \n impl<'a> WasmLd<'a> {\n-    fn new(cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+    fn new(mut cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+        // If the atomics feature is enabled for wasm then we need a whole bunch\n+        // of flags:\n+        //\n+        // * `--shared-memory` - the link won't even succeed without this, flags\n+        //   the one linear memory as `shared`\n+        //\n+        // * `--max-memory=1G` - when specifying a shared memory this must also\n+        //   be specified. We conservatively choose 1GB but users should be able\n+        //   to override this with `-C link-arg`.\n+        //\n+        // * `--import-memory` - it doesn't make much sense for memory to be\n+        //   exported in a threaded module because typically you're\n+        //   sharing memory and instantiating the module multiple times. As a\n+        //   result if it were exported then we'd just have no sharing.\n+        //\n+        // * `--passive-segments` - all memory segments should be passive to\n+        //   prevent each module instantiation from reinitializing memory.\n+        //\n+        // * `--export=__wasm_init_memory` - when using `--passive-segments` the\n+        //   linker will synthesize this function, and so we need to make sure\n+        //   that our usage of `--export` below won't accidentally cause this\n+        //   function to get deleted.\n+        //\n+        // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n+        //   symbols are how the TLS segments are initialized and configured.\n+        let atomics = sess.opts.cg.target_feature.contains(\"+atomics\") ||\n+            sess.target.target.options.features.contains(\"+atomics\");\n+        if atomics {\n+            cmd.arg(\"--shared-memory\");\n+            cmd.arg(\"--max-memory=1073741824\");\n+            cmd.arg(\"--import-memory\");\n+            cmd.arg(\"--passive-segments\");\n+            cmd.arg(\"--export=__wasm_init_memory\");\n+            cmd.arg(\"--export=__wasm_init_tls\");\n+            cmd.arg(\"--export=__tls_size\");\n+            cmd.arg(\"--export=__tls_align\");\n+            cmd.arg(\"--export=__tls_base\");\n+        }\n         WasmLd { cmd, sess, info }\n     }\n }\n@@ -1004,6 +1042,13 @@ impl<'a> Linker for WasmLd<'a> {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n         }\n+\n+        // LLD will hide these otherwise-internal symbols since our `--export`\n+        // list above is a whitelist of what to export. Various bits and pieces\n+        // of tooling use this, so be sure these symbols make their way out of\n+        // the linker as well.\n+        self.cmd.arg(\"--export=__heap_base\");\n+        self.cmd.arg(\"--export=__data_end\");\n     }\n \n     fn subsystem(&mut self, _subsystem: &str) {"}, {"sha": "901891d85a465f397b921c2332a59fe218e53260", "filename": "src/librustc_codegen_ssa/back/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -6,4 +6,3 @@ pub mod command;\n pub mod symbol_export;\n pub mod archive;\n pub mod rpath;\n-pub mod wasm;"}, {"sha": "2a9e81a788e52fad48c3d9a107283cffd17240b6", "filename": "src/librustc_codegen_ssa/back/wasm.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,191 +0,0 @@\n-use std::fs;\n-use std::path::Path;\n-use std::str;\n-\n-use rustc_serialize::leb128;\n-\n-// https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n-const WASM_CUSTOM_SECTION_ID: u8 = 0;\n-\n-/// Adds or augment the existing `producers` section to encode information about\n-/// the Rust compiler used to produce the wasm file.\n-pub fn add_producer_section(\n-    path: &Path,\n-    rust_version: &str,\n-    rustc_version: &str,\n-) {\n-    struct Field<'a> {\n-        name: &'a str,\n-        values: Vec<FieldValue<'a>>,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    struct FieldValue<'a> {\n-        name: &'a str,\n-        version: &'a str,\n-    }\n-\n-    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n-    let mut ret = WasmEncoder::new();\n-    ret.data.extend(&wasm[..8]);\n-\n-    // skip the 8 byte wasm/version header\n-    let rustc_value = FieldValue {\n-        name: \"rustc\",\n-        version: rustc_version,\n-    };\n-    let rust_value = FieldValue {\n-        name: \"Rust\",\n-        version: rust_version,\n-    };\n-    let mut fields = Vec::new();\n-    let mut wrote_rustc = false;\n-    let mut wrote_rust = false;\n-\n-    // Move all sections from the original wasm file to our output, skipping\n-    // everything except the producers section\n-    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n-        if id != WASM_CUSTOM_SECTION_ID {\n-            ret.byte(id);\n-            ret.bytes(raw);\n-            continue\n-        }\n-        let mut decoder = WasmDecoder::new(raw);\n-        if decoder.str() != \"producers\" {\n-            ret.byte(id);\n-            ret.bytes(raw);\n-            continue\n-        }\n-\n-        // Read off the producers section into our fields outside the loop,\n-        // we'll re-encode the producers section when we're done (to handle an\n-        // entirely missing producers section as well).\n-        info!(\"rewriting existing producers section\");\n-\n-        for _ in 0..decoder.u32() {\n-            let name = decoder.str();\n-            let mut values = Vec::new();\n-            for _ in 0..decoder.u32() {\n-                let name = decoder.str();\n-                let version = decoder.str();\n-                values.push(FieldValue { name, version });\n-            }\n-\n-            if name == \"language\" {\n-                values.push(rust_value);\n-                wrote_rust = true;\n-            } else if name == \"processed-by\" {\n-                values.push(rustc_value);\n-                wrote_rustc = true;\n-            }\n-            fields.push(Field { name, values });\n-        }\n-    }\n-\n-    if !wrote_rust {\n-        fields.push(Field {\n-            name: \"language\",\n-            values: vec![rust_value],\n-        });\n-    }\n-    if !wrote_rustc {\n-        fields.push(Field {\n-            name: \"processed-by\",\n-            values: vec![rustc_value],\n-        });\n-    }\n-\n-    // Append the producers section to the end of the wasm file.\n-    let mut section = WasmEncoder::new();\n-    section.str(\"producers\");\n-    section.u32(fields.len() as u32);\n-    for field in fields {\n-        section.str(field.name);\n-        section.u32(field.values.len() as u32);\n-        for value in field.values {\n-            section.str(value.name);\n-            section.str(value.version);\n-        }\n-    }\n-    ret.byte(WASM_CUSTOM_SECTION_ID);\n-    ret.bytes(&section.data);\n-\n-    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n-}\n-\n-struct WasmSections<'a>(WasmDecoder<'a>);\n-\n-impl<'a> Iterator for WasmSections<'a> {\n-    type Item = (u8, &'a [u8]);\n-\n-    fn next(&mut self) -> Option<(u8, &'a [u8])> {\n-        if self.0.data.is_empty() {\n-            return None\n-        }\n-\n-        // see https://webassembly.github.io/spec/core/binary/modules.html#sections\n-        let id = self.0.byte();\n-        let section_len = self.0.u32();\n-        info!(\"new section {} / {} bytes\", id, section_len);\n-        let section = self.0.skip(section_len as usize);\n-        Some((id, section))\n-    }\n-}\n-\n-struct WasmDecoder<'a> {\n-    data: &'a [u8],\n-}\n-\n-impl<'a> WasmDecoder<'a> {\n-    fn new(data: &'a [u8]) -> WasmDecoder<'a> {\n-        WasmDecoder { data }\n-    }\n-\n-    fn byte(&mut self) -> u8 {\n-        self.skip(1)[0]\n-    }\n-\n-    fn u32(&mut self) -> u32 {\n-        let (n, l1) = leb128::read_u32_leb128(self.data);\n-        self.data = &self.data[l1..];\n-        return n\n-    }\n-\n-    fn skip(&mut self, amt: usize) -> &'a [u8] {\n-        let (data, rest) = self.data.split_at(amt);\n-        self.data = rest;\n-        data\n-    }\n-\n-    fn str(&mut self) -> &'a str {\n-        let len = self.u32();\n-        str::from_utf8(self.skip(len as usize)).unwrap()\n-    }\n-}\n-\n-struct WasmEncoder {\n-    data: Vec<u8>,\n-}\n-\n-impl WasmEncoder {\n-    fn new() -> WasmEncoder {\n-        WasmEncoder { data: Vec::new() }\n-    }\n-\n-    fn u32(&mut self, val: u32) {\n-        leb128::write_u32_leb128(&mut self.data, val);\n-    }\n-\n-    fn byte(&mut self, val: u8) {\n-        self.data.push(val);\n-    }\n-\n-    fn bytes(&mut self, val: &[u8]) {\n-        self.u32(val.len() as u32);\n-        self.data.extend_from_slice(val);\n-    }\n-\n-    fn str(&mut self, val: &str) {\n-        self.bytes(val.as_bytes())\n-    }\n-}"}, {"sha": "6f00245b009411e738c31a597efa6483ce025d06", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -132,6 +132,14 @@ pub fn options() -> TargetOptions {\n         // non-relative calls and such later on).\n         relocation_model: \"static\".to_string(),\n \n+        // When the atomics feature is activated then these two keys matter,\n+        // otherwise they're basically ignored by the standard library. In this\n+        // mode, however, the `#[thread_local]` attribute works (i.e.\n+        // `has_elf_tls`) and we need to get it to work by specifying\n+        // `local-exec` as that's all that's implemented in LLVM today for wasm.\n+        has_elf_tls: true,\n+        tls_model: \"local-exec\".to_string(),\n+\n         .. Default::default()\n     }\n }"}, {"sha": "2e0da0409eb09766c9594455fb7a51484ec8ef73", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -75,11 +75,6 @@ panic_immediate_abort = [\"core/panic_immediate_abort\"]\n # requires rebuilding the standard library to use it.\n wasm_syscall = []\n \n-# An off-by-default features to enable libstd to assume that wasm-bindgen is in\n-# the environment for hooking up some thread-related information like the\n-# current thread id and accessing/getting the current thread's TCB\n-wasm-bindgen-threads = []\n-\n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []"}, {"sha": "f842869e08ee69e0c628a99dccceb7f662e5df38", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -47,6 +47,8 @@ pub mod stdio;\n pub mod thread;\n #[path = \"../wasm/thread_local.rs\"]\n pub mod thread_local;\n+#[path = \"../wasm/fast_thread_local.rs\"]\n+pub mod fast_thread_local;\n pub mod time;\n pub mod ext;\n "}, {"sha": "ff2198175f0a9682b7c6d6c9773aa9e1e4dbc8e2", "filename": "src/libstd/sys/wasm/fast_thread_local.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -0,0 +1,9 @@\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+pub unsafe fn register_dtor(_t: *mut u8, _dtor: unsafe extern fn(*mut u8)) {\n+    // FIXME: right now there is no concept of \"thread exit\", but this is likely\n+    // going to show up at some point in the form of an exported symbol that the\n+    // wasm runtime is oging to be expected to call. For now we basically just\n+    // ignore the arguments, but if such a function starts to exist it will\n+    // likely look like the OSX implementation in `unix/fast_thread_local.rs`\n+}"}, {"sha": "56cbafcfdb8a2af1196c8d38ae24c61ce695d646", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -37,6 +37,8 @@ pub mod stack_overflow;\n pub mod thread;\n pub mod time;\n pub mod stdio;\n+pub mod thread_local;\n+pub mod fast_thread_local;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n@@ -48,13 +50,10 @@ cfg_if::cfg_if! {\n         pub mod mutex;\n         #[path = \"rwlock_atomics.rs\"]\n         pub mod rwlock;\n-        #[path = \"thread_local_atomics.rs\"]\n-        pub mod thread_local;\n     } else {\n         pub mod condvar;\n         pub mod mutex;\n         pub mod rwlock;\n-        pub mod thread_local;\n     }\n }\n "}, {"sha": "d06965f3278498eda3a5924a0cb3e60251855a3e", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -59,48 +59,40 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n }\n \n-cfg_if::cfg_if! {\n-    if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n-        #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n-        extern {\n-            fn __wbindgen_current_id() -> u32;\n-            fn __wbindgen_tcb_get() -> u32;\n-            fn __wbindgen_tcb_set(ptr: u32);\n+// This is only used by atomics primitives when the `atomics` feature is\n+// enabled. In that mode we currently just use our own thread-local to store our\n+// current thread's ID, and then we lazily initialize it to something allocated\n+// from a global counter.\n+#[cfg(target_feature = \"atomics\")]\n+pub fn my_id() -> u32 {\n+    use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n+\n+    static NEXT_ID: AtomicU32 = AtomicU32::new(0);\n+\n+    #[thread_local]\n+    static mut MY_ID: u32 = 0;\n+\n+    unsafe {\n+        // If our thread ID isn't set yet then we need to allocate one. Do so\n+        // with with a simple \"atomically add to a global counter\" strategy.\n+        // This strategy doesn't handled what happens when the counter\n+        // overflows, however, so just abort everything once the counter\n+        // overflows and eventually we could have some sort of recycling scheme\n+        // (or maybe this is all totally irrelevant by that point!). In any case\n+        // though we're using a CAS loop instead of a `fetch_add` to ensure that\n+        // the global counter never overflows.\n+        if MY_ID == 0 {\n+            let mut cur = NEXT_ID.load(SeqCst);\n+            MY_ID = loop {\n+                let next = cur.checked_add(1).unwrap_or_else(|| {\n+                    crate::arch::wasm32::unreachable()\n+                });\n+                match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n+                    Ok(_) => break next,\n+                    Err(i) => cur = i,\n+                }\n+            };\n         }\n-        pub fn my_id() -> u32 {\n-            unsafe { __wbindgen_current_id() }\n-        }\n-\n-        // These are currently only ever used in `thread_local_atomics.rs`, if\n-        // you'd like to use them be sure to update that and make sure everyone\n-        // agrees what's what.\n-        pub fn tcb_get() -> *mut u8 {\n-            use crate::mem;\n-            assert_eq!(mem::size_of::<*mut u8>(), mem::size_of::<u32>());\n-            unsafe { __wbindgen_tcb_get() as *mut u8 }\n-        }\n-\n-        pub fn tcb_set(ptr: *mut u8) {\n-            unsafe { __wbindgen_tcb_set(ptr as u32); }\n-        }\n-\n-        // FIXME: still need something for hooking exiting a thread to free\n-        // data...\n-\n-    } else if #[cfg(target_feature = \"atomics\")] {\n-        pub fn my_id() -> u32 {\n-            panic!(\"thread ids not implemented on wasm with atomics yet\")\n-        }\n-\n-        pub fn tcb_get() -> *mut u8 {\n-            panic!(\"thread local data not implemented on wasm with atomics yet\")\n-        }\n-\n-        pub fn tcb_set(_ptr: *mut u8) {\n-            panic!(\"thread local data not implemented on wasm with atomics yet\")\n-        }\n-    } else {\n-        // stubbed out because no functions actually access these intrinsics\n-        // unless atomics are enabled\n+        MY_ID\n     }\n }"}, {"sha": "8a0ca6f3d25a8f47cf88ab90c19d9a04a2d42037", "filename": "src/libstd/sys/wasm/thread_local.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778b631ff06c463fad290ea8ff8f2817ab62a5fd/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -1,40 +1,26 @@\n-use crate::boxed::Box;\n-use crate::ptr;\n-\n pub type Key = usize;\n \n-struct Allocated {\n-    value: *mut u8,\n-    dtor: Option<unsafe extern fn(*mut u8)>,\n-}\n-\n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    Box::into_raw(Box::new(Allocated {\n-        value: ptr::null_mut(),\n-        dtor,\n-    })) as usize\n+pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*(key as *mut Allocated)).value = value;\n+pub unsafe fn set(_key: Key, _value: *mut u8) {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*(key as *mut Allocated)).value\n+pub unsafe fn get(_key: Key) -> *mut u8 {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn destroy(key: Key) {\n-    let key = Box::from_raw(key as *mut Allocated);\n-    if let Some(f) = key.dtor {\n-        f(key.value);\n-    }\n+pub unsafe fn destroy(_key: Key) {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n pub fn requires_synchronized_create() -> bool {\n-    false\n+    panic!(\"should not be used on the wasm target\");\n }"}, {"sha": "3dc0bb24553fd644450b36c29a148d26a30fdbad", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,61 +0,0 @@\n-use crate::sys::thread;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-\n-const MAX_KEYS: usize = 128;\n-static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n-\n-struct ThreadControlBlock {\n-    keys: [*mut u8; MAX_KEYS],\n-}\n-\n-impl ThreadControlBlock {\n-    fn new() -> ThreadControlBlock {\n-        ThreadControlBlock {\n-            keys: [core::ptr::null_mut(); MAX_KEYS],\n-        }\n-    }\n-\n-    fn get() -> *mut ThreadControlBlock {\n-        let ptr = thread::tcb_get();\n-        if !ptr.is_null() {\n-            return ptr as *mut ThreadControlBlock\n-        }\n-        let tcb = Box::into_raw(Box::new(ThreadControlBlock::new()));\n-        thread::tcb_set(tcb as *mut u8);\n-        tcb\n-    }\n-}\n-\n-pub type Key = usize;\n-\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    drop(dtor); // FIXME: need to figure out how to hook thread exit to run this\n-    let key = NEXT_KEY.fetch_add(1, SeqCst);\n-    if key >= MAX_KEYS {\n-        NEXT_KEY.store(MAX_KEYS, SeqCst);\n-        panic!(\"cannot allocate space for more TLS keys\");\n-    }\n-    // offset by 1 so we never hand out 0. This is currently required by\n-    // `sys_common/thread_local.rs` where it can't cope with keys of value 0\n-    // because it messes up the atomic management.\n-    return key + 1\n-}\n-\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*ThreadControlBlock::get()).keys[key - 1] = value;\n-}\n-\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*ThreadControlBlock::get()).keys[key - 1]\n-}\n-\n-pub unsafe fn destroy(_key: Key) {\n-    // FIXME: should implement this somehow, this isn't typically called but it\n-    // can be called if two threads race to initialize a TLS slot and one ends\n-    // up not being needed.\n-}\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "9b64ca5b7e1e3583978f9ac8af6d93b220a13d90", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=778b631ff06c463fad290ea8ff8f2817ab62a5fd", "patch": "@@ -1 +1 @@\n-Subproject commit f6446fa8e9629ffb1861303f17930c3aa83ef660\n+Subproject commit 9b64ca5b7e1e3583978f9ac8af6d93b220a13d90"}]}