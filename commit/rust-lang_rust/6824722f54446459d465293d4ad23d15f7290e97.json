{"sha": "6824722f54446459d465293d4ad23d15f7290e97", "node_id": "C_kwDOAAsO6NoAKDY4MjQ3MjJmNTQ0NDY0NTlkNDY1MjkzZDRhZDIzZDE1ZjcyOTBlOTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-11T13:36:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-11T13:36:53Z"}, "message": "Merge #11257\n\n11257: feat: Report `DefDiagnostic`s from inside item bodies r=jonas-schievink a=jonas-schievink\n\nReports diagnostics from all block-level `DefMap`s, and adds some code to avoid adding duplicate diagnostics to the body's `SourceMap`.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "fc61c0b674dc76c0c5cb551cd35571279a9b8d18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc61c0b674dc76c0c5cb551cd35571279a9b8d18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6824722f54446459d465293d4ad23d15f7290e97", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh3Yf1CRBK7hj4Ov3rIwAAD9AIADmGR1dHEj7FYg6XXnQj0Xjm\nWw8A0jpa9kAocHQ/BxOy/JaqAInKlkNtjxLFuz32KdwnxweEODzAJuq3uIMnn2An\naM0S4h0LQH9OrvhgOiZ3FZCjmENlAFYpGRbfZ46JHQzkVRP9FMf6siwnCZr0QNYW\nNNimJ8GcgIwO4F6Cv3TO/0wAVXvM/KVfIvabG+RcyE3OeUO7B3wfL7fuPBVl8xni\nZRVcZYPGWRQQV60NG/esIYbWXi6T7UI7wqLRT0rosNbHNJQsA9BDwuufh1h3JPiE\n1Zv7d3YbmlsKvNGXl1azBzgD+neBRksZUffjQUm8xbLSQIkEixzKRvi/9UPYwPs=\n=Bfod\n-----END PGP SIGNATURE-----\n", "payload": "tree fc61c0b674dc76c0c5cb551cd35571279a9b8d18\nparent 5a711d4f3a2b95bfe2b365244c6ae96670df65fd\nparent 0706de94bb70847e9c57df42c115220aea77e1fc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641908213 +0000\ncommitter GitHub <noreply@github.com> 1641908213 +0000\n\nMerge #11257\n\n11257: feat: Report `DefDiagnostic`s from inside item bodies r=jonas-schievink a=jonas-schievink\n\nReports diagnostics from all block-level `DefMap`s, and adds some code to avoid adding duplicate diagnostics to the body's `SourceMap`.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6824722f54446459d465293d4ad23d15f7290e97", "html_url": "https://github.com/rust-lang/rust/commit/6824722f54446459d465293d4ad23d15f7290e97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6824722f54446459d465293d4ad23d15f7290e97/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a711d4f3a2b95bfe2b365244c6ae96670df65fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a711d4f3a2b95bfe2b365244c6ae96670df65fd", "html_url": "https://github.com/rust-lang/rust/commit/5a711d4f3a2b95bfe2b365244c6ae96670df65fd"}, {"sha": "0706de94bb70847e9c57df42c115220aea77e1fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0706de94bb70847e9c57df42c115220aea77e1fc", "html_url": "https://github.com/rust-lang/rust/commit/0706de94bb70847e9c57df42c115220aea77e1fc"}], "stats": {"total": 448, "additions": 227, "deletions": 221}, "files": [{"sha": "95696936b8ad1c64b089b388da51798d04aadcb4", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 184, "deletions": 187, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/6824722f54446459d465293d4ad23d15f7290e97/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6824722f54446459d465293d4ad23d15f7290e97/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6824722f54446459d465293d4ad23d15f7290e97", "patch": "@@ -41,7 +41,7 @@ use hir_def::{\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     lang_item::LangItemTarget,\n-    nameres,\n+    nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     AttrDefId, ConstId, ConstParamId, EnumId, FunctionId, GenericDefId, HasModule, LifetimeParamId,\n@@ -523,191 +523,7 @@ impl Module {\n                 // FIXME: This is accidentally quadratic.\n                 continue;\n             }\n-            match &diag.kind {\n-                DefDiagnosticKind::UnresolvedModule { ast: declaration, candidate } => {\n-                    let decl = declaration.to_node(db.upcast());\n-                    acc.push(\n-                        UnresolvedModule {\n-                            decl: InFile::new(declaration.file_id, AstPtr::new(&decl)),\n-                            candidate: candidate.clone(),\n-                        }\n-                        .into(),\n-                    )\n-                }\n-                DefDiagnosticKind::UnresolvedExternCrate { ast } => {\n-                    let item = ast.to_node(db.upcast());\n-                    acc.push(\n-                        UnresolvedExternCrate {\n-                            decl: InFile::new(ast.file_id, AstPtr::new(&item)),\n-                        }\n-                        .into(),\n-                    );\n-                }\n-\n-                DefDiagnosticKind::UnresolvedImport { id, index } => {\n-                    let file_id = id.file_id();\n-                    let item_tree = id.item_tree(db.upcast());\n-                    let import = &item_tree[id.value];\n-\n-                    let use_tree = import.use_tree_to_ast(db.upcast(), file_id, *index);\n-                    acc.push(\n-                        UnresolvedImport { decl: InFile::new(file_id, AstPtr::new(&use_tree)) }\n-                            .into(),\n-                    );\n-                }\n-\n-                DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n-                    let item = ast.to_node(db.upcast());\n-                    acc.push(\n-                        InactiveCode {\n-                            node: ast.with_value(AstPtr::new(&item).into()),\n-                            cfg: cfg.clone(),\n-                            opts: opts.clone(),\n-                        }\n-                        .into(),\n-                    );\n-                }\n-\n-                DefDiagnosticKind::UnresolvedProcMacro { ast } => {\n-                    let mut precise_location = None;\n-                    let (node, name) = match ast {\n-                        MacroCallKind::FnLike { ast_id, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-                            (ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))), None)\n-                        }\n-                        MacroCallKind::Derive { ast_id, derive_name, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-\n-                            // Compute the precise location of the macro name's token in the derive\n-                            // list.\n-                            // FIXME: This does not handle paths to the macro, but neither does the\n-                            // rest of r-a.\n-                            let derive_attrs =\n-                                node.attrs().filter_map(|attr| match attr.as_simple_call() {\n-                                    Some((name, args)) if name == \"derive\" => Some(args),\n-                                    _ => None,\n-                                });\n-                            'outer: for attr in derive_attrs {\n-                                let tokens =\n-                                    attr.syntax().children_with_tokens().filter_map(|elem| {\n-                                        match elem {\n-                                            syntax::NodeOrToken::Node(_) => None,\n-                                            syntax::NodeOrToken::Token(tok) => Some(tok),\n-                                        }\n-                                    });\n-                                for token in tokens {\n-                                    if token.kind() == SyntaxKind::IDENT\n-                                        && token.text() == &**derive_name\n-                                    {\n-                                        precise_location = Some(token.text_range());\n-                                        break 'outer;\n-                                    }\n-                                }\n-                            }\n-\n-                            (\n-                                ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n-                                Some(derive_name.clone()),\n-                            )\n-                        }\n-                        MacroCallKind::Attr { ast_id, invoc_attr_index, attr_name, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-                            let attr = node\n-                                .doc_comments_and_attrs()\n-                                .nth((*invoc_attr_index) as usize)\n-                                .and_then(Either::right)\n-                                .unwrap_or_else(|| {\n-                                    panic!(\"cannot find attribute #{}\", invoc_attr_index)\n-                                });\n-                            (\n-                                ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n-                                Some(attr_name.clone()),\n-                            )\n-                        }\n-                    };\n-                    acc.push(\n-                        UnresolvedProcMacro {\n-                            node,\n-                            precise_location,\n-                            macro_name: name.map(Into::into),\n-                        }\n-                        .into(),\n-                    );\n-                }\n-\n-                DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {\n-                    let node = ast.to_node(db.upcast());\n-                    acc.push(\n-                        UnresolvedMacroCall {\n-                            macro_call: InFile::new(ast.file_id, AstPtr::new(&node)),\n-                            path: path.clone(),\n-                        }\n-                        .into(),\n-                    );\n-                }\n-\n-                DefDiagnosticKind::MacroError { ast, message } => {\n-                    let node = match ast {\n-                        MacroCallKind::FnLike { ast_id, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-                            ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n-                        }\n-                        MacroCallKind::Derive { ast_id, .. } => {\n-                            // FIXME: point to the attribute instead, this creates very large diagnostics\n-                            let node = ast_id.to_node(db.upcast());\n-                            ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n-                        }\n-                        MacroCallKind::Attr { ast_id, .. } => {\n-                            // FIXME: point to the attribute instead, this creates very large diagnostics\n-                            let node = ast_id.to_node(db.upcast());\n-                            ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n-                        }\n-                    };\n-                    acc.push(MacroError { node, message: message.clone() }.into());\n-                }\n-\n-                DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {\n-                    let node = ast.to_node(db.upcast());\n-                    // Must have a name, otherwise we wouldn't emit it.\n-                    let name = node.name().expect(\"unimplemented builtin macro with no name\");\n-                    acc.push(\n-                        UnimplementedBuiltinMacro {\n-                            node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&name))),\n-                        }\n-                        .into(),\n-                    );\n-                }\n-                DefDiagnosticKind::InvalidDeriveTarget { ast, id } => {\n-                    let node = ast.to_node(db.upcast());\n-                    let derive = node.attrs().nth(*id as usize);\n-                    match derive {\n-                        Some(derive) => {\n-                            acc.push(\n-                                InvalidDeriveTarget {\n-                                    node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&derive))),\n-                                }\n-                                .into(),\n-                            );\n-                        }\n-                        None => stdx::never!(\"derive diagnostic on item without derive attribute\"),\n-                    }\n-                }\n-                DefDiagnosticKind::MalformedDerive { ast, id } => {\n-                    let node = ast.to_node(db.upcast());\n-                    let derive = node.attrs().nth(*id as usize);\n-                    match derive {\n-                        Some(derive) => {\n-                            acc.push(\n-                                MalformedDerive {\n-                                    node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&derive))),\n-                                }\n-                                .into(),\n-                            );\n-                        }\n-                        None => stdx::never!(\"derive diagnostic on item without derive attribute\"),\n-                    }\n-                }\n-            }\n+            emit_def_diagnostic(db, acc, diag);\n         }\n         for decl in self.declarations(db) {\n             match decl {\n@@ -767,6 +583,180 @@ impl Module {\n     }\n }\n \n+fn emit_def_diagnostic(db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>, diag: &DefDiagnostic) {\n+    match &diag.kind {\n+        DefDiagnosticKind::UnresolvedModule { ast: declaration, candidate } => {\n+            let decl = declaration.to_node(db.upcast());\n+            acc.push(\n+                UnresolvedModule {\n+                    decl: InFile::new(declaration.file_id, AstPtr::new(&decl)),\n+                    candidate: candidate.clone(),\n+                }\n+                .into(),\n+            )\n+        }\n+        DefDiagnosticKind::UnresolvedExternCrate { ast } => {\n+            let item = ast.to_node(db.upcast());\n+            acc.push(\n+                UnresolvedExternCrate { decl: InFile::new(ast.file_id, AstPtr::new(&item)) }.into(),\n+            );\n+        }\n+\n+        DefDiagnosticKind::UnresolvedImport { id, index } => {\n+            let file_id = id.file_id();\n+            let item_tree = id.item_tree(db.upcast());\n+            let import = &item_tree[id.value];\n+\n+            let use_tree = import.use_tree_to_ast(db.upcast(), file_id, *index);\n+            acc.push(\n+                UnresolvedImport { decl: InFile::new(file_id, AstPtr::new(&use_tree)) }.into(),\n+            );\n+        }\n+\n+        DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n+            let item = ast.to_node(db.upcast());\n+            acc.push(\n+                InactiveCode {\n+                    node: ast.with_value(AstPtr::new(&item).into()),\n+                    cfg: cfg.clone(),\n+                    opts: opts.clone(),\n+                }\n+                .into(),\n+            );\n+        }\n+\n+        DefDiagnosticKind::UnresolvedProcMacro { ast } => {\n+            let mut precise_location = None;\n+            let (node, name) = match ast {\n+                MacroCallKind::FnLike { ast_id, .. } => {\n+                    let node = ast_id.to_node(db.upcast());\n+                    (ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))), None)\n+                }\n+                MacroCallKind::Derive { ast_id, derive_name, .. } => {\n+                    let node = ast_id.to_node(db.upcast());\n+\n+                    // Compute the precise location of the macro name's token in the derive\n+                    // list.\n+                    // FIXME: This does not handle paths to the macro, but neither does the\n+                    // rest of r-a.\n+                    let derive_attrs =\n+                        node.attrs().filter_map(|attr| match attr.as_simple_call() {\n+                            Some((name, args)) if name == \"derive\" => Some(args),\n+                            _ => None,\n+                        });\n+                    'outer: for attr in derive_attrs {\n+                        let tokens =\n+                            attr.syntax().children_with_tokens().filter_map(|elem| match elem {\n+                                syntax::NodeOrToken::Node(_) => None,\n+                                syntax::NodeOrToken::Token(tok) => Some(tok),\n+                            });\n+                        for token in tokens {\n+                            if token.kind() == SyntaxKind::IDENT && token.text() == &**derive_name {\n+                                precise_location = Some(token.text_range());\n+                                break 'outer;\n+                            }\n+                        }\n+                    }\n+\n+                    (\n+                        ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n+                        Some(derive_name.clone()),\n+                    )\n+                }\n+                MacroCallKind::Attr { ast_id, invoc_attr_index, attr_name, .. } => {\n+                    let node = ast_id.to_node(db.upcast());\n+                    let attr = node\n+                        .doc_comments_and_attrs()\n+                        .nth((*invoc_attr_index) as usize)\n+                        .and_then(Either::right)\n+                        .unwrap_or_else(|| panic!(\"cannot find attribute #{}\", invoc_attr_index));\n+                    (\n+                        ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n+                        Some(attr_name.clone()),\n+                    )\n+                }\n+            };\n+            acc.push(\n+                UnresolvedProcMacro { node, precise_location, macro_name: name.map(Into::into) }\n+                    .into(),\n+            );\n+        }\n+\n+        DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {\n+            let node = ast.to_node(db.upcast());\n+            acc.push(\n+                UnresolvedMacroCall {\n+                    macro_call: InFile::new(ast.file_id, AstPtr::new(&node)),\n+                    path: path.clone(),\n+                }\n+                .into(),\n+            );\n+        }\n+\n+        DefDiagnosticKind::MacroError { ast, message } => {\n+            let node = match ast {\n+                MacroCallKind::FnLike { ast_id, .. } => {\n+                    let node = ast_id.to_node(db.upcast());\n+                    ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n+                }\n+                MacroCallKind::Derive { ast_id, .. } => {\n+                    // FIXME: point to the attribute instead, this creates very large diagnostics\n+                    let node = ast_id.to_node(db.upcast());\n+                    ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n+                }\n+                MacroCallKind::Attr { ast_id, .. } => {\n+                    // FIXME: point to the attribute instead, this creates very large diagnostics\n+                    let node = ast_id.to_node(db.upcast());\n+                    ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n+                }\n+            };\n+            acc.push(MacroError { node, message: message.clone() }.into());\n+        }\n+\n+        DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {\n+            let node = ast.to_node(db.upcast());\n+            // Must have a name, otherwise we wouldn't emit it.\n+            let name = node.name().expect(\"unimplemented builtin macro with no name\");\n+            acc.push(\n+                UnimplementedBuiltinMacro {\n+                    node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&name))),\n+                }\n+                .into(),\n+            );\n+        }\n+        DefDiagnosticKind::InvalidDeriveTarget { ast, id } => {\n+            let node = ast.to_node(db.upcast());\n+            let derive = node.attrs().nth(*id as usize);\n+            match derive {\n+                Some(derive) => {\n+                    acc.push(\n+                        InvalidDeriveTarget {\n+                            node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&derive))),\n+                        }\n+                        .into(),\n+                    );\n+                }\n+                None => stdx::never!(\"derive diagnostic on item without derive attribute\"),\n+            }\n+        }\n+        DefDiagnosticKind::MalformedDerive { ast, id } => {\n+            let node = ast.to_node(db.upcast());\n+            let derive = node.attrs().nth(*id as usize);\n+            match derive {\n+                Some(derive) => {\n+                    acc.push(\n+                        MalformedDerive {\n+                            node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&derive))),\n+                        }\n+                        .into(),\n+                    );\n+                }\n+                None => stdx::never!(\"derive diagnostic on item without derive attribute\"),\n+            }\n+        }\n+    }\n+}\n+\n impl HasVisibility for Module {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let def_map = self.id.def_map(db.upcast());\n@@ -1107,7 +1097,14 @@ impl DefWithBody {\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n-        let source_map = db.body_with_source_map(self.into()).1;\n+        let (body, source_map) = db.body_with_source_map(self.into());\n+\n+        for (_, def_map) in body.blocks(db.upcast()) {\n+            for diag in def_map.diagnostics() {\n+                emit_def_diagnostic(db, acc, diag);\n+            }\n+        }\n+\n         for diag in source_map.diagnostics() {\n             match diag {\n                 BodyDiagnostic::InactiveCode { node, cfg, opts } => acc.push("}, {"sha": "7cbeef1488a05cb802a43bcbdf55f8f510e912f1", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6824722f54446459d465293d4ad23d15f7290e97/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6824722f54446459d465293d4ad23d15f7290e97/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=6824722f54446459d465293d4ad23d15f7290e97", "patch": "@@ -552,7 +552,7 @@ impl ExprCollector<'_> {\n             ast::Expr::MacroCall(e) => {\n                 let macro_ptr = AstPtr::new(&e);\n                 let mut ids = vec![];\n-                self.collect_macro_call(e, macro_ptr, |this, expansion| {\n+                self.collect_macro_call(e, macro_ptr, true, |this, expansion| {\n                     ids.push(match expansion {\n                         Some(it) => this.collect_expr(it),\n                         None => this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n@@ -576,6 +576,7 @@ impl ExprCollector<'_> {\n         &mut self,\n         e: ast::MacroCall,\n         syntax_ptr: AstPtr<ast::MacroCall>,\n+        record_diagnostics: bool,\n         mut collector: F,\n     ) {\n         // File containing the macro call. Expansion errors will be attached here.\n@@ -587,28 +588,32 @@ impl ExprCollector<'_> {\n         let res = match res {\n             Ok(res) => res,\n             Err(UnresolvedMacro { path }) => {\n-                self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedMacroCall {\n-                    node: InFile::new(outer_file, syntax_ptr),\n-                    path,\n-                });\n+                if record_diagnostics {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedMacroCall {\n+                        node: InFile::new(outer_file, syntax_ptr),\n+                        path,\n+                    });\n+                }\n                 collector(self, None);\n                 return;\n             }\n         };\n \n-        match &res.err {\n-            Some(ExpandError::UnresolvedProcMacro) => {\n-                self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro {\n-                    node: InFile::new(outer_file, syntax_ptr),\n-                });\n-            }\n-            Some(err) => {\n-                self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n-                    node: InFile::new(outer_file, syntax_ptr),\n-                    message: err.to_string(),\n-                });\n+        if record_diagnostics {\n+            match &res.err {\n+                Some(ExpandError::UnresolvedProcMacro) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro {\n+                        node: InFile::new(outer_file, syntax_ptr),\n+                    });\n+                }\n+                Some(err) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n+                        node: InFile::new(outer_file, syntax_ptr),\n+                        message: err.to_string(),\n+                    });\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n \n         match res.value {\n@@ -663,29 +668,33 @@ impl ExprCollector<'_> {\n                     let macro_ptr = AstPtr::new(&m);\n                     let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n \n-                    self.collect_macro_call(m, macro_ptr, |this, expansion| match expansion {\n-                        Some(expansion) => {\n-                            let statements: ast::MacroStmts = expansion;\n-\n-                            statements.statements().for_each(|stmt| this.collect_stmt(stmt));\n-                            if let Some(expr) = statements.expr() {\n-                                let expr = this.collect_expr(expr);\n+                    self.collect_macro_call(\n+                        m,\n+                        macro_ptr,\n+                        false,\n+                        |this, expansion| match expansion {\n+                            Some(expansion) => {\n+                                let statements: ast::MacroStmts = expansion;\n+\n+                                statements.statements().for_each(|stmt| this.collect_stmt(stmt));\n+                                if let Some(expr) = statements.expr() {\n+                                    let expr = this.collect_expr(expr);\n+                                    this.statements_in_scope\n+                                        .push(Statement::Expr { expr, has_semi });\n+                                }\n+                            }\n+                            None => {\n+                                let expr = this.alloc_expr(Expr::Missing, syntax_ptr.clone());\n                                 this.statements_in_scope.push(Statement::Expr { expr, has_semi });\n                             }\n-                        }\n-                        None => {\n-                            let expr = this.alloc_expr(Expr::Missing, syntax_ptr.clone());\n-                            this.statements_in_scope.push(Statement::Expr { expr, has_semi });\n-                        }\n-                    });\n+                        },\n+                    );\n                 } else {\n                     let expr = self.collect_expr_opt(stmt.expr());\n                     self.statements_in_scope.push(Statement::Expr { expr, has_semi });\n                 }\n             }\n-            ast::Stmt::Item(item) => {\n-                self.check_cfg(&item);\n-            }\n+            ast::Stmt::Item(_item) => {}\n         }\n     }\n \n@@ -878,7 +887,7 @@ impl ExprCollector<'_> {\n                 Some(call) => {\n                     let macro_ptr = AstPtr::new(&call);\n                     let mut pat = None;\n-                    self.collect_macro_call(call, macro_ptr, |this, expanded_pat| {\n+                    self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n                         pat = Some(this.collect_pat_opt(expanded_pat));\n                     });\n "}]}