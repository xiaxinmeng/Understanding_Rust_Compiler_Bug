{"sha": "361c599feeefaf6e50efd90658fc9c2222154684", "node_id": "C_kwDOAAsO6NoAKDM2MWM1OTlmZWVlZmFmNmU1MGVmZDkwNjU4ZmM5YzIyMjIxNTQ2ODQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-18T10:11:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-18T10:11:11Z"}, "message": "Auto merge of #98655 - nnethercote:dont-derive-PartialEq-ne, r=dtolnay\n\nDon't derive `PartialEq::ne`.\n\nCurrently we skip deriving `PartialEq::ne` for C-like (fieldless) enums\nand empty structs, thus reyling on the default `ne`. This behaviour is\nunnecessarily conservative, because the `PartialEq` docs say this:\n\n> Implementations must ensure that eq and ne are consistent with each other:\n>\n> `a != b` if and only if `!(a == b)` (ensured by the default\n> implementation).\n\nThis means that the default implementation (`!(a == b)`) is always good\nenough. So this commit changes things such that `ne` is never derived.\n\nThe motivation for this change is that not deriving `ne` reduces compile\ntimes and binary sizes.\n\nObservable behaviour may change if a user has defined a type `A` with an\ninconsistent `PartialEq` and then defines a type `B` that contains an\n`A` and also derives `PartialEq`. Such code is already buggy and\npreserving bug-for-bug compatibility isn't necessary.\n\nTwo side-effects of the change:\n- There is only one error message produced for types where `PartialEq`\n  cannot be derived, instead of two.\n- For coverage reports, some warnings about generated `ne` methods not\n  being executed have disappeared.\n\nBoth side-effects seem fine, and possibly preferable.", "tree": {"sha": "4db3cd0ce9547ceaba845cd670ac8c7c71acd430", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4db3cd0ce9547ceaba845cd670ac8c7c71acd430"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/361c599feeefaf6e50efd90658fc9c2222154684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/361c599feeefaf6e50efd90658fc9c2222154684", "html_url": "https://github.com/rust-lang/rust/commit/361c599feeefaf6e50efd90658fc9c2222154684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/361c599feeefaf6e50efd90658fc9c2222154684/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f241c0c43d71960f078b897e9b8721d4b452ce5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f241c0c43d71960f078b897e9b8721d4b452ce5e", "html_url": "https://github.com/rust-lang/rust/commit/f241c0c43d71960f078b897e9b8721d4b452ce5e"}, {"sha": "d4a5b034b75c7ea3d9a7955857f56ecc7d7b9cca", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a5b034b75c7ea3d9a7955857f56ecc7d7b9cca", "html_url": "https://github.com/rust-lang/rust/commit/d4a5b034b75c7ea3d9a7955857f56ecc7d7b9cca"}], "stats": {"total": 290, "additions": 38, "deletions": 252}, "files": [{"sha": "6f86092ba491b653ad8e92d1fcafbac16a68eee5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -15,14 +15,8 @@ pub fn expand_deriving_partial_eq(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    fn cs_op(\n-        cx: &mut ExtCtxt<'_>,\n-        span: Span,\n-        substr: &Substructure<'_>,\n-        op: BinOpKind,\n-        combiner: BinOpKind,\n-        base: bool,\n-    ) -> BlockOrExpr {\n+    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+        let base = true;\n         let expr = cs_fold(\n             true, // use foldl\n             cx,\n@@ -47,39 +41,22 @@ pub fn expand_deriving_partial_eq(\n                             cx.expr_deref(field.span, expr.clone())\n                         }\n                     };\n-                    cx.expr_binary(field.span, op, convert(&field.self_expr), convert(other_expr))\n+                    cx.expr_binary(\n+                        field.span,\n+                        BinOpKind::Eq,\n+                        convert(&field.self_expr),\n+                        convert(other_expr),\n+                    )\n+                }\n+                CsFold::Combine(span, expr1, expr2) => {\n+                    cx.expr_binary(span, BinOpKind::And, expr1, expr2)\n                 }\n-                CsFold::Combine(span, expr1, expr2) => cx.expr_binary(span, combiner, expr1, expr2),\n                 CsFold::Fieldless => cx.expr_bool(span, base),\n             },\n         );\n         BlockOrExpr::new_expr(expr)\n     }\n \n-    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n-        cs_op(cx, span, substr, BinOpKind::Eq, BinOpKind::And, true)\n-    }\n-    fn cs_ne(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n-        cs_op(cx, span, substr, BinOpKind::Ne, BinOpKind::Or, false)\n-    }\n-\n-    macro_rules! md {\n-        ($name:expr, $f:ident) => {{\n-            let inline = cx.meta_word(span, sym::inline);\n-            let attrs = vec![cx.attribute(inline)];\n-            MethodDef {\n-                name: $name,\n-                generics: Bounds::empty(),\n-                explicit_self: true,\n-                nonself_args: vec![(self_ref(), sym::other)],\n-                ret_ty: Path(path_local!(bool)),\n-                attributes: attrs,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| $f(a, b, c))),\n-            }\n-        }};\n-    }\n-\n     super::inject_impl_of_structural_trait(\n         cx,\n         span,\n@@ -88,13 +65,20 @@ pub fn expand_deriving_partial_eq(\n         push,\n     );\n \n-    // avoid defining `ne` if we can\n-    // c-like enums, enums without any fields and structs without fields\n-    // can safely define only `eq`.\n-    let mut methods = vec![md!(sym::eq, cs_eq)];\n-    if !is_type_without_fields(item) {\n-        methods.push(md!(sym::ne, cs_ne));\n-    }\n+    // No need to generate `ne`, the default suffices, and not generating it is\n+    // faster.\n+    let inline = cx.meta_word(span, sym::inline);\n+    let attrs = vec![cx.attribute(inline)];\n+    let methods = vec![MethodDef {\n+        name: sym::eq,\n+        generics: Bounds::empty(),\n+        explicit_self: true,\n+        nonself_args: vec![(self_ref(), sym::other)],\n+        ret_ty: Path(path_local!(bool)),\n+        attributes: attrs,\n+        unify_fieldless_variants: true,\n+        combine_substructure: combine_substructure(Box::new(|a, b, c| cs_eq(a, b, c))),\n+    }];\n \n     let trait_def = TraitDef {\n         span,"}, {"sha": "a39b97d07ef0a8d5d9368ff35169b402c53122a7", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -1625,19 +1625,3 @@ where\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }\n-\n-/// Returns `true` if the type has no value fields\n-/// (for an enum, no variant has any fields)\n-pub fn is_type_without_fields(item: &Annotatable) -> bool {\n-    if let Annotatable::Item(ref item) = *item {\n-        match item.kind {\n-            ast::ItemKind::Enum(ref enum_def, _) => {\n-                enum_def.variants.iter().all(|v| v.data.fields().is_empty())\n-            }\n-            ast::ItemKind::Struct(ref variant_data, _) => variant_data.fields().is_empty(),\n-            _ => false,\n-        }\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "5ca5b5fde16048d6d41dab32b2ad7553bdd2aaee", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -38,8 +38,10 @@ use self::Ordering::*;\n ///\n /// Implementations must ensure that `eq` and `ne` are consistent with each other:\n ///\n-/// - `a != b` if and only if `!(a == b)`\n-///   (ensured by the default implementation).\n+/// - `a != b` if and only if `!(a == b)`.\n+///\n+/// The default implementation of `ne` provides this consistency and is almost\n+/// always sufficient. It should not be overridden without very good reason.\n ///\n /// If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\n /// be consistent with `PartialEq` (see the documentation of those traits for the exact\n@@ -225,7 +227,8 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n-    /// This method tests for `!=`.\n+    /// This method tests for `!=`. The default implementation is almost always\n+    /// sufficient, and should not be overridden without very good reason.\n     #[inline]\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "732de6526279105e3e81dddc33cab855c3992e22", "filename": "src/test/run-make/coverage-reports/expected_show_coverage.doctest.txt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.doctest.txt", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.doctest.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.doctest.txt?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -23,12 +23,6 @@\n    22|      1|//! ```\n    23|      2|//! #[derive(Debug, PartialEq)]\n                        ^1\n-  ------------------\n-  | Unexecuted instantiation: <rust_out::main::_doctest_main____coverage_doctest_rs_22_0::SomeError as core::cmp::PartialEq>::ne\n-  ------------------\n-  | <rust_out::main::_doctest_main____coverage_doctest_rs_22_0::SomeError as core::cmp::PartialEq>::eq:\n-  |   23|      2|//! #[derive(Debug, PartialEq)]\n-  ------------------\n    24|      1|//! struct SomeError {\n    25|      1|//!     msg: String,\n    26|      1|//! }"}, {"sha": "25c74ab2e70bc66b86fa0a17ea396006ea3ae100", "filename": "src/test/run-make/coverage-reports/expected_show_coverage.issue-83601.txt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -2,12 +2,6 @@\n     2|       |\n     3|      3|#[derive(Debug, PartialEq, Eq)]\n                               ^2\n-  ------------------\n-  | <issue_83601::Foo as core::cmp::PartialEq>::eq:\n-  |    3|      2|#[derive(Debug, PartialEq, Eq)]\n-  ------------------\n-  | Unexecuted instantiation: <issue_83601::Foo as core::cmp::PartialEq>::ne\n-  ------------------\n     4|       |struct Foo(u32);\n     5|       |\n     6|      1|fn main() {"}, {"sha": "4a60432c14c18592e1f6c2c8799ee21bae7e32fd", "filename": "src/test/run-make/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -2,12 +2,6 @@\n     2|       |\n     3|       |// expect-exit-status-101\n     4|     21|#[derive(PartialEq, Eq)]\n-  ------------------\n-  | <issue_84561::Foo as core::cmp::PartialEq>::eq:\n-  |    4|     21|#[derive(PartialEq, Eq)]\n-  ------------------\n-  | Unexecuted instantiation: <issue_84561::Foo as core::cmp::PartialEq>::ne\n-  ------------------\n     5|       |struct Foo(u32);\n     6|      1|fn test3() {\n     7|      1|    let is_true = std::env::args().len() == 1;"}, {"sha": "a77175af6636061dc9860330b9d608243e6706cc", "filename": "src/test/run-make/coverage-reports/expected_show_coverage.partial_eq.txt", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.partial_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.partial_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.partial_eq.txt?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -3,11 +3,6 @@\n     3|       |\n     4|      2|#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n                        ^0            ^0      ^0     ^1       ^1 ^0^0\n-  ------------------\n-  | Unexecuted instantiation: <partial_eq::Version as core::cmp::PartialEq>::ne\n-  ------------------\n-  | Unexecuted instantiation: <partial_eq::Version as core::cmp::PartialEq>::eq\n-  ------------------\n     5|       |pub struct Version {\n     6|       |    major: usize,\n     7|       |    minor: usize,"}, {"sha": "67a27729db7e4679c62206f1499503b5542194f1", "filename": "src/test/ui/derives/derives-span-PartialEq-enum-struct-variant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -7,7 +7,6 @@ struct Error;\n enum Enum {\n    A {\n      x: Error //~ ERROR\n-//~^ ERROR\n    }\n }\n "}, {"sha": "9953154fd4b71610f8ebad53f212295acde1185b", "filename": "src/test/ui/derives/derives-span-PartialEq-enum-struct-variant.stderr", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -18,26 +18,6 @@ help: consider annotating `Error` with `#[derive(PartialEq)]`\n LL | #[derive(PartialEq)]\n    |\n \n-error[E0369]: binary operation `!=` cannot be applied to type `Error`\n-  --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:9:6\n-   |\n-LL | #[derive(PartialEq)]\n-   |          --------- in this derive macro expansion\n-...\n-LL |      x: Error\n-   |      ^^^^^^^^\n-   |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n-  --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:4:1\n-   |\n-LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `Error` with `#[derive(PartialEq)]`\n-   |\n-LL | #[derive(PartialEq)]\n-   |\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0369`."}, {"sha": "0becc7e0d10f732790b8e02098df00e82077d9fd", "filename": "src/test/ui/derives/derives-span-PartialEq-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -7,8 +7,7 @@ struct Error;\n enum Enum {\n    A(\n      Error //~ ERROR\n-//~^ ERROR\n-     )\n+   )\n }\n \n fn main() {}"}, {"sha": "7c130452301d3802d69942800d40e72665fe5eaf", "filename": "src/test/ui/derives/derives-span-PartialEq-enum.stderr", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -18,26 +18,6 @@ help: consider annotating `Error` with `#[derive(PartialEq)]`\n LL | #[derive(PartialEq)]\n    |\n \n-error[E0369]: binary operation `!=` cannot be applied to type `Error`\n-  --> $DIR/derives-span-PartialEq-enum.rs:9:6\n-   |\n-LL | #[derive(PartialEq)]\n-   |          --------- in this derive macro expansion\n-...\n-LL |      Error\n-   |      ^^^^^\n-   |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n-  --> $DIR/derives-span-PartialEq-enum.rs:4:1\n-   |\n-LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `Error` with `#[derive(PartialEq)]`\n-   |\n-LL | #[derive(PartialEq)]\n-   |\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0369`."}, {"sha": "c92ef5fadf735b430f605b8365fe117ade1d7742", "filename": "src/test/ui/derives/derives-span-PartialEq-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -6,7 +6,6 @@ struct Error;\n #[derive(PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n-//~^ ERROR\n }\n \n fn main() {}"}, {"sha": "ba3d6ced3f49d79e05628a3499aa1c478fdc8ae2", "filename": "src/test/ui/derives/derives-span-PartialEq-struct.stderr", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -18,26 +18,6 @@ help: consider annotating `Error` with `#[derive(PartialEq)]`\n LL | #[derive(PartialEq)]\n    |\n \n-error[E0369]: binary operation `!=` cannot be applied to type `Error`\n-  --> $DIR/derives-span-PartialEq-struct.rs:8:5\n-   |\n-LL | #[derive(PartialEq)]\n-   |          --------- in this derive macro expansion\n-LL | struct Struct {\n-LL |     x: Error\n-   |     ^^^^^^^^\n-   |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n-  --> $DIR/derives-span-PartialEq-struct.rs:4:1\n-   |\n-LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `Error` with `#[derive(PartialEq)]`\n-   |\n-LL | #[derive(PartialEq)]\n-   |\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0369`."}, {"sha": "10ac347aa0bee0b6a4c1cec2c949f56a1f2283c3", "filename": "src/test/ui/derives/derives-span-PartialEq-tuple-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -6,7 +6,6 @@ struct Error;\n #[derive(PartialEq)]\n struct Struct(\n     Error //~ ERROR\n-//~^ ERROR\n );\n \n fn main() {}"}, {"sha": "ab0b56a9eefbbe03a3e5244cd9a94a3295ff44cb", "filename": "src/test/ui/derives/derives-span-PartialEq-tuple-struct.stderr", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -18,26 +18,6 @@ help: consider annotating `Error` with `#[derive(PartialEq)]`\n LL | #[derive(PartialEq)]\n    |\n \n-error[E0369]: binary operation `!=` cannot be applied to type `Error`\n-  --> $DIR/derives-span-PartialEq-tuple-struct.rs:8:5\n-   |\n-LL | #[derive(PartialEq)]\n-   |          --------- in this derive macro expansion\n-LL | struct Struct(\n-LL |     Error\n-   |     ^^^^^\n-   |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n-  --> $DIR/derives-span-PartialEq-tuple-struct.rs:4:1\n-   |\n-LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `Error` with `#[derive(PartialEq)]`\n-   |\n-LL | #[derive(PartialEq)]\n-   |\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0369`."}, {"sha": "b3ce31bf0d356bb2df64ec92bee2718180fa11a3", "filename": "src/test/ui/derives/deriving-no-inner-impl-error-message.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.rs?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -3,7 +3,6 @@ struct NoCloneOrEq;\n #[derive(PartialEq)]\n struct E {\n     x: NoCloneOrEq //~ ERROR binary operation `==` cannot be applied to type `NoCloneOrEq`\n-         //~^ ERROR binary operation `!=` cannot be applied to type `NoCloneOrEq`\n }\n #[derive(Clone)]\n struct C {"}, {"sha": "ef8c44caacfa10a551e27a82c6f51b451f453b10", "filename": "src/test/ui/derives/deriving-no-inner-impl-error-message.stderr", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -18,28 +18,8 @@ help: consider annotating `NoCloneOrEq` with `#[derive(PartialEq)]`\n LL | #[derive(PartialEq)]\n    |\n \n-error[E0369]: binary operation `!=` cannot be applied to type `NoCloneOrEq`\n-  --> $DIR/deriving-no-inner-impl-error-message.rs:5:5\n-   |\n-LL | #[derive(PartialEq)]\n-   |          --------- in this derive macro expansion\n-LL | struct E {\n-LL |     x: NoCloneOrEq\n-   |     ^^^^^^^^^^^^^^\n-   |\n-note: an implementation of `PartialEq<_>` might be missing for `NoCloneOrEq`\n-  --> $DIR/deriving-no-inner-impl-error-message.rs:1:1\n-   |\n-LL | struct NoCloneOrEq;\n-   | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `NoCloneOrEq` with `#[derive(PartialEq)]`\n-   |\n-LL | #[derive(PartialEq)]\n-   |\n-\n error[E0277]: the trait bound `NoCloneOrEq: Clone` is not satisfied\n-  --> $DIR/deriving-no-inner-impl-error-message.rs:10:5\n+  --> $DIR/deriving-no-inner-impl-error-message.rs:9:5\n    |\n LL | #[derive(Clone)]\n    |          ----- in this derive macro expansion\n@@ -53,7 +33,7 @@ help: consider annotating `NoCloneOrEq` with `#[derive(Clone)]`\n LL | #[derive(Clone)]\n    |\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0369.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "65f7dec84080276f6f9e50bc9821e023a6371577", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/361c599feeefaf6e50efd90658fc9c2222154684/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=361c599feeefaf6e50efd90658fc9c2222154684", "patch": "@@ -122,10 +122,6 @@ impl ::core::cmp::PartialEq for Point {\n     fn eq(&self, other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n     }\n-    #[inline]\n-    fn ne(&self, other: &Point) -> bool {\n-        self.x != other.x || self.y != other.y\n-    }\n }\n impl ::core::marker::StructuralEq for Point {}\n #[automatically_derived]\n@@ -239,13 +235,6 @@ impl ::core::cmp::PartialEq for Big {\n                     self.b6 == other.b6 && self.b7 == other.b7 &&\n             self.b8 == other.b8\n     }\n-    #[inline]\n-    fn ne(&self, other: &Big) -> bool {\n-        self.b1 != other.b1 || self.b2 != other.b2 || self.b3 != other.b3 ||\n-                            self.b4 != other.b4 || self.b5 != other.b5 ||\n-                    self.b6 != other.b6 || self.b7 != other.b7 ||\n-            self.b8 != other.b8\n-    }\n }\n impl ::core::marker::StructuralEq for Big {}\n #[automatically_derived]\n@@ -361,8 +350,6 @@ impl ::core::marker::StructuralPartialEq for Unsized {}\n impl ::core::cmp::PartialEq for Unsized {\n     #[inline]\n     fn eq(&self, other: &Unsized) -> bool { self.0 == other.0 }\n-    #[inline]\n-    fn ne(&self, other: &Unsized) -> bool { self.0 != other.0 }\n }\n impl ::core::marker::StructuralEq for Unsized {}\n #[automatically_derived]\n@@ -428,8 +415,6 @@ impl ::core::marker::StructuralPartialEq for PackedCopy {}\n impl ::core::cmp::PartialEq for PackedCopy {\n     #[inline]\n     fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n-    #[inline]\n-    fn ne(&self, other: &PackedCopy) -> bool { { self.0 } != { other.0 } }\n }\n impl ::core::marker::StructuralEq for PackedCopy {}\n #[automatically_derived]\n@@ -503,12 +488,6 @@ impl ::core::cmp::PartialEq for PackedNonCopy {\n         let Self(ref __self_1_0) = *other;\n         *__self_0_0 == *__self_1_0\n     }\n-    #[inline]\n-    fn ne(&self, other: &PackedNonCopy) -> bool {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        *__self_0_0 != *__self_1_0\n-    }\n }\n impl ::core::marker::StructuralEq for PackedNonCopy {}\n #[automatically_derived]\n@@ -638,13 +617,6 @@ impl ::core::cmp::PartialEq for Enum1 {\n                 *__self_0 == *__arg1_0,\n         }\n     }\n-    #[inline]\n-    fn ne(&self, other: &Enum1) -> bool {\n-        match (self, other) {\n-            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg1_0 }) =>\n-                *__self_0 != *__arg1_0,\n-        }\n-    }\n }\n impl ::core::marker::StructuralEq for Enum1 {}\n #[automatically_derived]\n@@ -883,20 +855,6 @@ impl ::core::cmp::PartialEq for Mixed {\n                 _ => true,\n             }\n     }\n-    #[inline]\n-    fn ne(&self, other: &Mixed) -> bool {\n-        let __self_tag = ::core::intrinsics::discriminant_value(self);\n-        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        __self_tag != __arg1_tag ||\n-            match (self, other) {\n-                (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n-                    *__self_0 != *__arg1_0,\n-                (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                    d1: __arg1_0, d2: __arg1_1 }) =>\n-                    *__self_0 != *__arg1_0 || *__self_1 != *__arg1_1,\n-                _ => false,\n-            }\n-    }\n }\n impl ::core::marker::StructuralEq for Mixed {}\n #[automatically_derived]\n@@ -1023,21 +981,6 @@ impl ::core::cmp::PartialEq for Fielded {\n                 _ => unsafe { ::core::intrinsics::unreachable() }\n             }\n     }\n-    #[inline]\n-    fn ne(&self, other: &Fielded) -> bool {\n-        let __self_tag = ::core::intrinsics::discriminant_value(self);\n-        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        __self_tag != __arg1_tag ||\n-            match (self, other) {\n-                (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n-                    *__self_0 != *__arg1_0,\n-                (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n-                    *__self_0 != *__arg1_0,\n-                (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n-                    *__self_0 != *__arg1_0,\n-                _ => unsafe { ::core::intrinsics::unreachable() }\n-            }\n-    }\n }\n impl ::core::marker::StructuralEq for Fielded {}\n #[automatically_derived]"}]}