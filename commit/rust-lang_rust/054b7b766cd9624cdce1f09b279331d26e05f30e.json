{"sha": "054b7b766cd9624cdce1f09b279331d26e05f30e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NGI3Yjc2NmNkOTYyNGNkY2UxZjA5YjI3OTMzMWQyNmUwNWYzMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-23T02:41:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-23T02:41:01Z"}, "message": "Auto merge of #27912 - DiamondLovesYou:backtrace-refactor, r=alexcrichton", "tree": {"sha": "77a7becd8052870302b19681f53758bbc8d42a92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77a7becd8052870302b19681f53758bbc8d42a92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/054b7b766cd9624cdce1f09b279331d26e05f30e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/054b7b766cd9624cdce1f09b279331d26e05f30e", "html_url": "https://github.com/rust-lang/rust/commit/054b7b766cd9624cdce1f09b279331d26e05f30e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/054b7b766cd9624cdce1f09b279331d26e05f30e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d69db0a8ea5f2825170dfec789b4d4eb4581f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/10d69db0a8ea5f2825170dfec789b4d4eb4581f9", "html_url": "https://github.com/rust-lang/rust/commit/10d69db0a8ea5f2825170dfec789b4d4eb4581f9"}, {"sha": "deff8781f1c6fd608f468a7e42246750c8c39ee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/deff8781f1c6fd608f468a7e42246750c8c39ee8", "html_url": "https://github.com/rust-lang/rust/commit/deff8781f1c6fd608f468a7e42246750c8c39ee8"}], "stats": {"total": 1274, "additions": 688, "deletions": 586}, "files": [{"sha": "853e745b8a190ad57fbef1b4faeef464019dca1f", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "removed", "additions": 0, "deletions": 586, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/10d69db0a8ea5f2825170dfec789b4d4eb4581f9/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d69db0a8ea5f2825170dfec789b4d4eb4581f9/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=10d69db0a8ea5f2825170dfec789b4d4eb4581f9", "patch": "@@ -1,586 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on OSX, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering thread\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not OSX, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n-\n-use io::prelude::*;\n-\n-use ffi::CStr;\n-use io;\n-use libc;\n-use str;\n-use sync::StaticMutex;\n-\n-use sys_common::backtrace::*;\n-\n-/// As always - iOS on arm uses SjLj exceptions and\n-/// _Unwind_Backtrace is even not available there. Still,\n-/// backtraces could be extracted using a backtrace function,\n-/// which thanks god is public\n-///\n-/// As mentioned in a huge comment block above, backtrace doesn't\n-/// play well with green threads, so while it is extremely nice\n-/// and simple to use it should be used only on iOS devices as the\n-/// only viable option.\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[inline(never)]\n-pub fn write(w: &mut Write) -> io::Result<()> {\n-    use mem;\n-\n-    extern {\n-        fn backtrace(buf: *mut *mut libc::c_void,\n-                     sz: libc::c_int) -> libc::c_int;\n-    }\n-\n-    // while it doesn't requires lock for work as everything is\n-    // local, it still displays much nicer backtraces when a\n-    // couple of threads panic simultaneously\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    let _g = LOCK.lock();\n-\n-    try!(writeln!(w, \"stack backtrace:\"));\n-    // 100 lines should be enough\n-    const SIZE: usize = 100;\n-    let mut buf: [*mut libc::c_void; SIZE] = unsafe { mem::zeroed() };\n-    let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as usize};\n-\n-    // skipping the first one as it is write itself\n-    for i in 1..cnt {\n-        try!(print(w, i as isize, buf[i], buf[i]))\n-    }\n-    Ok(())\n-}\n-\n-#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn write(w: &mut Write) -> io::Result<()> {\n-    struct Context<'a> {\n-        idx: isize,\n-        writer: &'a mut (Write+'a),\n-        last_error: Option<io::Error>,\n-    }\n-\n-    // When using libbacktrace, we use some necessary global state, so we\n-    // need to prevent more than one thread from entering this block. This\n-    // is semi-reasonable in terms of printing anyway, and we know that all\n-    // I/O done here is blocking I/O, not green I/O, so we don't have to\n-    // worry about this being a native vs green mutex.\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    let _g = LOCK.lock();\n-\n-    try!(writeln!(w, \"stack backtrace:\"));\n-\n-    let mut cx = Context { writer: w, last_error: None, idx: 0 };\n-    return match unsafe {\n-        uw::_Unwind_Backtrace(trace_fn,\n-                              &mut cx as *mut Context as *mut libc::c_void)\n-    } {\n-        uw::_URC_NO_REASON => {\n-            match cx.last_error {\n-                Some(err) => Err(err),\n-                None => Ok(())\n-            }\n-        }\n-        _ => Ok(()),\n-    };\n-\n-    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                       arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-        let cx: &mut Context = unsafe { &mut *(arg as *mut Context) };\n-        let mut ip_before_insn = 0;\n-        let mut ip = unsafe {\n-            uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n-        };\n-        if !ip.is_null() && ip_before_insn == 0 {\n-            // this is a non-signaling frame, so `ip` refers to the address\n-            // after the calling instruction. account for that.\n-            ip = (ip as usize - 1) as *mut _;\n-        }\n-\n-        // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-        // it appears to work fine without it, so we only use\n-        // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-        // slightly more accurate stack trace in the process.\n-        //\n-        // This is often because panic involves the last instruction of a\n-        // function being \"call std::rt::begin_unwind\", with no ret\n-        // instructions after it. This means that the return instruction\n-        // pointer points *outside* of the calling function, and by\n-        // unwinding it we go back to the original function.\n-        let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-            ip\n-        } else {\n-            unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-        };\n-\n-        // Don't print out the first few frames (they're not user frames)\n-        cx.idx += 1;\n-        if cx.idx <= 0 { return uw::_URC_NO_REASON }\n-        // Don't print ginormous backtraces\n-        if cx.idx > 100 {\n-            match write!(cx.writer, \" ... <frames omitted>\\n\") {\n-                Ok(()) => {}\n-                Err(e) => { cx.last_error = Some(e); }\n-            }\n-            return uw::_URC_FAILURE\n-        }\n-\n-        // Once we hit an error, stop trying to print more frames\n-        if cx.last_error.is_some() { return uw::_URC_FAILURE }\n-\n-        match print(cx.writer, cx.idx, ip, symaddr) {\n-            Ok(()) => {}\n-            Err(e) => { cx.last_error = Some(e); }\n-        }\n-\n-        // keep going\n-        return uw::_URC_NO_REASON\n-    }\n-}\n-\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-         _symaddr: *mut libc::c_void) -> io::Result<()> {\n-    use intrinsics;\n-    #[repr(C)]\n-    struct Dl_info {\n-        dli_fname: *const libc::c_char,\n-        dli_fbase: *mut libc::c_void,\n-        dli_sname: *const libc::c_char,\n-        dli_saddr: *mut libc::c_void,\n-    }\n-    extern {\n-        fn dladdr(addr: *const libc::c_void,\n-                  info: *mut Dl_info) -> libc::c_int;\n-    }\n-\n-    let mut info: Dl_info = unsafe { intrinsics::init() };\n-    if unsafe { dladdr(addr, &mut info) == 0 } {\n-        output(w, idx,addr, None)\n-    } else {\n-        output(w, idx, addr, Some(unsafe {\n-            CStr::from_ptr(info.dli_sname).to_bytes()\n-        }))\n-    }\n-}\n-\n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-         symaddr: *mut libc::c_void) -> io::Result<()> {\n-    use env;\n-    use os::unix::prelude::*;\n-    use ptr;\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // libbacktrace.h API\n-    ////////////////////////////////////////////////////////////////////////\n-    type backtrace_syminfo_callback =\n-        extern \"C\" fn(data: *mut libc::c_void,\n-                      pc: libc::uintptr_t,\n-                      symname: *const libc::c_char,\n-                      symval: libc::uintptr_t,\n-                      symsize: libc::uintptr_t);\n-    type backtrace_full_callback =\n-        extern \"C\" fn(data: *mut libc::c_void,\n-                      pc: libc::uintptr_t,\n-                      filename: *const libc::c_char,\n-                      lineno: libc::c_int,\n-                      function: *const libc::c_char) -> libc::c_int;\n-    type backtrace_error_callback =\n-        extern \"C\" fn(data: *mut libc::c_void,\n-                      msg: *const libc::c_char,\n-                      errnum: libc::c_int);\n-    enum backtrace_state {}\n-    #[link(name = \"backtrace\", kind = \"static\")]\n-    #[cfg(not(test))]\n-    extern {}\n-\n-    extern {\n-        fn backtrace_create_state(filename: *const libc::c_char,\n-                                  threaded: libc::c_int,\n-                                  error: backtrace_error_callback,\n-                                  data: *mut libc::c_void)\n-                                        -> *mut backtrace_state;\n-        fn backtrace_syminfo(state: *mut backtrace_state,\n-                             addr: libc::uintptr_t,\n-                             cb: backtrace_syminfo_callback,\n-                             error: backtrace_error_callback,\n-                             data: *mut libc::c_void) -> libc::c_int;\n-        fn backtrace_pcinfo(state: *mut backtrace_state,\n-                            addr: libc::uintptr_t,\n-                            cb: backtrace_full_callback,\n-                            error: backtrace_error_callback,\n-                            data: *mut libc::c_void) -> libc::c_int;\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // helper callbacks\n-    ////////////////////////////////////////////////////////////////////////\n-\n-    type FileLine = (*const libc::c_char, libc::c_int);\n-\n-    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n-                       _errnum: libc::c_int) {\n-        // do nothing for now\n-    }\n-    extern fn syminfo_cb(data: *mut libc::c_void,\n-                         _pc: libc::uintptr_t,\n-                         symname: *const libc::c_char,\n-                         _symval: libc::uintptr_t,\n-                         _symsize: libc::uintptr_t) {\n-        let slot = data as *mut *const libc::c_char;\n-        unsafe { *slot = symname; }\n-    }\n-    extern fn pcinfo_cb(data: *mut libc::c_void,\n-                        _pc: libc::uintptr_t,\n-                        filename: *const libc::c_char,\n-                        lineno: libc::c_int,\n-                        _function: *const libc::c_char) -> libc::c_int {\n-        if !filename.is_null() {\n-            let slot = data as *mut &mut [FileLine];\n-            let buffer = unsafe {ptr::read(slot)};\n-\n-            // if the buffer is not full, add file:line to the buffer\n-            // and adjust the buffer for next possible calls to pcinfo_cb.\n-            if !buffer.is_empty() {\n-                buffer[0] = (filename, lineno);\n-                unsafe { ptr::write(slot, &mut buffer[1..]); }\n-            }\n-        }\n-\n-        0\n-    }\n-\n-    // The libbacktrace API supports creating a state, but it does not\n-    // support destroying a state. I personally take this to mean that a\n-    // state is meant to be created and then live forever.\n-    //\n-    // I would love to register an at_exit() handler which cleans up this\n-    // state, but libbacktrace provides no way to do so.\n-    //\n-    // With these constraints, this function has a statically cached state\n-    // that is calculated the first time this is requested. Remember that\n-    // backtracing all happens serially (one global lock).\n-    //\n-    // An additionally oddity in this function is that we initialize the\n-    // filename via self_exe_name() to pass to libbacktrace. It turns out\n-    // that on Linux libbacktrace seamlessly gets the filename of the\n-    // current executable, but this fails on freebsd. by always providing\n-    // it, we make sure that libbacktrace never has a reason to not look up\n-    // the symbols. The libbacktrace API also states that the filename must\n-    // be in \"permanent memory\", so we copy it to a static and then use the\n-    // static as the pointer.\n-    //\n-    // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n-    //        tested if this is required or not.\n-    unsafe fn init_state() -> *mut backtrace_state {\n-        static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n-        static mut LAST_FILENAME: [libc::c_char; 256] = [0; 256];\n-        if !STATE.is_null() { return STATE }\n-        let selfname = if cfg!(target_os = \"freebsd\") ||\n-                          cfg!(target_os = \"dragonfly\") ||\n-                          cfg!(target_os = \"bitrig\") ||\n-                          cfg!(target_os = \"netbsd\") ||\n-                          cfg!(target_os = \"openbsd\") {\n-            env::current_exe().ok()\n-        } else {\n-            None\n-        };\n-        let filename = match selfname {\n-            Some(path) => {\n-                let bytes = path.as_os_str().as_bytes();\n-                if bytes.len() < LAST_FILENAME.len() {\n-                    let i = bytes.iter();\n-                    for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n-                        *slot = *val as libc::c_char;\n-                    }\n-                    LAST_FILENAME.as_ptr()\n-                } else {\n-                    ptr::null()\n-                }\n-            }\n-            None => ptr::null(),\n-        };\n-        STATE = backtrace_create_state(filename, 0, error_cb,\n-                                       ptr::null_mut());\n-        return STATE\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // translation\n-    ////////////////////////////////////////////////////////////////////////\n-\n-    // backtrace errors are currently swept under the rug, only I/O\n-    // errors are reported\n-    let state = unsafe { init_state() };\n-    if state.is_null() {\n-        return output(w, idx, addr, None)\n-    }\n-    let mut data = ptr::null();\n-    let data_addr = &mut data as *mut *const libc::c_char;\n-    let ret = unsafe {\n-        backtrace_syminfo(state, symaddr as libc::uintptr_t,\n-                          syminfo_cb, error_cb,\n-                          data_addr as *mut libc::c_void)\n-    };\n-    if ret == 0 || data.is_null() {\n-        try!(output(w, idx, addr, None));\n-    } else {\n-        try!(output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() })));\n-    }\n-\n-    // pcinfo may return an arbitrary number of file:line pairs,\n-    // in the order of stack trace (i.e. inlined calls first).\n-    // in order to avoid allocation, we stack-allocate a fixed size of entries.\n-    const FILELINE_SIZE: usize = 32;\n-    let mut fileline_buf = [(ptr::null(), -1); FILELINE_SIZE];\n-    let ret;\n-    let fileline_count;\n-    {\n-        let mut fileline_win: &mut [FileLine] = &mut fileline_buf;\n-        let fileline_addr = &mut fileline_win as *mut &mut [FileLine];\n-        ret = unsafe {\n-            backtrace_pcinfo(state, addr as libc::uintptr_t,\n-                             pcinfo_cb, error_cb,\n-                             fileline_addr as *mut libc::c_void)\n-        };\n-        fileline_count = FILELINE_SIZE - fileline_win.len();\n-    }\n-    if ret == 0 {\n-        for (i, &(file, line)) in fileline_buf[..fileline_count].iter().enumerate() {\n-            if file.is_null() { continue; } // just to be sure\n-            let file = unsafe { CStr::from_ptr(file).to_bytes() };\n-            try!(output_fileline(w, file, line, i == FILELINE_SIZE - 1));\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-// Finally, after all that work above, we can emit a symbol.\n-fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-          s: Option<&[u8]>) -> io::Result<()> {\n-    try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n-    match s.and_then(|s| str::from_utf8(s).ok()) {\n-        Some(string) => try!(demangle(w, string)),\n-        None => try!(write!(w, \"<unknown>\")),\n-    }\n-    w.write_all(&['\\n' as u8])\n-}\n-\n-#[allow(dead_code)]\n-fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n-                   more: bool) -> io::Result<()> {\n-    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n-    // prior line: \"  ##: {:2$} - func\"\n-    try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));\n-    if more {\n-        try!(write!(w, \" <... and possibly more>\"));\n-    }\n-    w.write_all(&['\\n' as u8])\n-}\n-\n-/// Unwind library interface used for backtraces\n-///\n-/// Note that dead code is allowed as here are just bindings\n-/// iOS doesn't use all of them it but adding more\n-/// platform-specific configs pollutes the code too much\n-#[allow(non_camel_case_types)]\n-#[allow(non_snake_case)]\n-#[allow(dead_code)]\n-mod uw {\n-    pub use self::_Unwind_Reason_Code::*;\n-\n-    use libc;\n-\n-    #[repr(C)]\n-    pub enum _Unwind_Reason_Code {\n-        _URC_NO_REASON = 0,\n-        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-        _URC_FATAL_PHASE2_ERROR = 2,\n-        _URC_FATAL_PHASE1_ERROR = 3,\n-        _URC_NORMAL_STOP = 4,\n-        _URC_END_OF_STACK = 5,\n-        _URC_HANDLER_FOUND = 6,\n-        _URC_INSTALL_CONTEXT = 7,\n-        _URC_CONTINUE_UNWIND = 8,\n-        _URC_FAILURE = 9, // used only by ARM EABI\n-    }\n-\n-    pub enum _Unwind_Context {}\n-\n-    pub type _Unwind_Trace_Fn =\n-            extern fn(ctx: *mut _Unwind_Context,\n-                      arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n-\n-    extern {\n-        // No native _Unwind_Backtrace on iOS\n-        #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                                 trace_argument: *mut libc::c_void)\n-                    -> _Unwind_Reason_Code;\n-\n-        // available since GCC 4.2.0, should be fine for our purpose\n-        #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n-                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n-                                 ip_before_insn: *mut libc::c_int)\n-                    -> libc::uintptr_t;\n-\n-        #[cfg(all(not(target_os = \"android\"),\n-                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-            -> *mut libc::c_void;\n-    }\n-\n-    // On android, the function _Unwind_GetIP is a macro, and this is the\n-    // expansion of the macro. This is all copy/pasted directly from the\n-    // header file with the definition of _Unwind_GetIP.\n-    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n-              all(target_os = \"linux\", target_arch = \"arm\")))]\n-    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n-        #[repr(C)]\n-        enum _Unwind_VRS_Result {\n-            _UVRSR_OK = 0,\n-            _UVRSR_NOT_IMPLEMENTED = 1,\n-            _UVRSR_FAILED = 2,\n-        }\n-        #[repr(C)]\n-        enum _Unwind_VRS_RegClass {\n-            _UVRSC_CORE = 0,\n-            _UVRSC_VFP = 1,\n-            _UVRSC_FPA = 2,\n-            _UVRSC_WMMXD = 3,\n-            _UVRSC_WMMXC = 4,\n-        }\n-        #[repr(C)]\n-        enum _Unwind_VRS_DataRepresentation {\n-            _UVRSD_UINT32 = 0,\n-            _UVRSD_VFPX = 1,\n-            _UVRSD_FPAX = 2,\n-            _UVRSD_UINT64 = 3,\n-            _UVRSD_FLOAT = 4,\n-            _UVRSD_DOUBLE = 5,\n-        }\n-\n-        type _Unwind_Word = libc::c_uint;\n-        extern {\n-            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n-                               klass: _Unwind_VRS_RegClass,\n-                               word: _Unwind_Word,\n-                               repr: _Unwind_VRS_DataRepresentation,\n-                               data: *mut libc::c_void)\n-                -> _Unwind_VRS_Result;\n-        }\n-\n-        let mut val: _Unwind_Word = 0;\n-        let ptr = &mut val as *mut _Unwind_Word;\n-        let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n-                                _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n-                                ptr as *mut libc::c_void);\n-        (val & !1) as libc::uintptr_t\n-    }\n-\n-    // This function doesn't exist on Android or ARM/Linux, so make it same\n-    // to _Unwind_GetIP\n-    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n-              all(target_os = \"linux\", target_arch = \"arm\")))]\n-    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n-                                    ip_before_insn: *mut libc::c_int)\n-        -> libc::uintptr_t\n-    {\n-        *ip_before_insn = 0;\n-        _Unwind_GetIP(ctx)\n-    }\n-\n-    // This function also doesn't exist on Android or ARM/Linux, so make it\n-    // a no-op\n-    #[cfg(any(target_os = \"android\",\n-              all(target_os = \"linux\", target_arch = \"arm\")))]\n-    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n-        -> *mut libc::c_void\n-    {\n-        pc\n-    }\n-}"}, {"sha": "79833c1cacb18b28b5db2eb5b33f50b6d8dafdb3", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on OSX, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering thread\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not OSX, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+\n+pub use self::tracing::write;\n+\n+use io;\n+use io::prelude::*;\n+use libc;\n+use str;\n+\n+use sys_common::backtrace::{demangle, HEX_WIDTH};\n+\n+// tracing impls:\n+mod tracing;\n+// symbol resolvers:\n+mod printing;\n+\n+pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n+              s: Option<&[u8]>) -> io::Result<()> {\n+    try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n+    match s.and_then(|s| str::from_utf8(s).ok()) {\n+        Some(string) => try!(demangle(w, string)),\n+        None => try!(write!(w, \"<unknown>\")),\n+    }\n+    w.write_all(&['\\n' as u8])\n+}\n+\n+#[allow(dead_code)]\n+pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n+                       more: bool) -> io::Result<()> {\n+    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n+    // prior line: \"  ##: {:2$} - func\"\n+    try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));\n+    if more {\n+        try!(write!(w, \" <... and possibly more>\"));\n+    }\n+    w.write_all(&['\\n' as u8])\n+}"}, {"sha": "2bca56921d51750eb328a2c4b888eb6da1bb0e39", "filename": "src/libstd/sys/unix/backtrace/printing/dladdr.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use io::prelude::*;\n+use libc;\n+\n+pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n+             _symaddr: *mut libc::c_void) -> io::Result<()> {\n+    use sys::backtrace::{output};\n+    use intrinsics;\n+    use ffi::CStr;\n+\n+    #[repr(C)]\n+    struct Dl_info {\n+        dli_fname: *const libc::c_char,\n+        dli_fbase: *mut libc::c_void,\n+        dli_sname: *const libc::c_char,\n+        dli_saddr: *mut libc::c_void,\n+    }\n+    extern {\n+        fn dladdr(addr: *const libc::c_void,\n+                  info: *mut Dl_info) -> libc::c_int;\n+    }\n+\n+    let mut info: Dl_info = unsafe { intrinsics::init() };\n+    if unsafe { dladdr(addr, &mut info) == 0 } {\n+        output(w, idx,addr, None)\n+    } else {\n+        output(w, idx, addr, Some(unsafe {\n+            CStr::from_ptr(info.dli_sname).to_bytes()\n+        }))\n+    }\n+}"}, {"sha": "711e241161dd778d0bef4d8b4744f5c186f6fca3", "filename": "src/libstd/sys/unix/backtrace/printing/libbacktrace.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Flibbacktrace.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,206 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use io::prelude::*;\n+use libc;\n+\n+use sys::backtrace::{output, output_fileline};\n+pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n+             symaddr: *mut libc::c_void) -> io::Result<()> {\n+    use env;\n+    use ffi::CStr;\n+    use os::unix::prelude::*;\n+    use ptr;\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // libbacktrace.h API\n+    ////////////////////////////////////////////////////////////////////////\n+    type backtrace_syminfo_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      pc: libc::uintptr_t,\n+                      symname: *const libc::c_char,\n+                      symval: libc::uintptr_t,\n+                      symsize: libc::uintptr_t);\n+    type backtrace_full_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      pc: libc::uintptr_t,\n+                      filename: *const libc::c_char,\n+                      lineno: libc::c_int,\n+                      function: *const libc::c_char) -> libc::c_int;\n+    type backtrace_error_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      msg: *const libc::c_char,\n+                      errnum: libc::c_int);\n+    enum backtrace_state {}\n+    #[link(name = \"backtrace\", kind = \"static\")]\n+    #[cfg(not(test))]\n+    extern {}\n+\n+    extern {\n+        fn backtrace_create_state(filename: *const libc::c_char,\n+                                  threaded: libc::c_int,\n+                                  error: backtrace_error_callback,\n+                                  data: *mut libc::c_void)\n+                                  -> *mut backtrace_state;\n+        fn backtrace_syminfo(state: *mut backtrace_state,\n+                             addr: libc::uintptr_t,\n+                             cb: backtrace_syminfo_callback,\n+                             error: backtrace_error_callback,\n+                             data: *mut libc::c_void) -> libc::c_int;\n+        fn backtrace_pcinfo(state: *mut backtrace_state,\n+                            addr: libc::uintptr_t,\n+                            cb: backtrace_full_callback,\n+                            error: backtrace_error_callback,\n+                            data: *mut libc::c_void) -> libc::c_int;\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // helper callbacks\n+    ////////////////////////////////////////////////////////////////////////\n+\n+    type FileLine = (*const libc::c_char, libc::c_int);\n+\n+    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n+                       _errnum: libc::c_int) {\n+        // do nothing for now\n+    }\n+    extern fn syminfo_cb(data: *mut libc::c_void,\n+                         _pc: libc::uintptr_t,\n+                         symname: *const libc::c_char,\n+                         _symval: libc::uintptr_t,\n+                         _symsize: libc::uintptr_t) {\n+        let slot = data as *mut *const libc::c_char;\n+        unsafe { *slot = symname; }\n+    }\n+    extern fn pcinfo_cb(data: *mut libc::c_void,\n+                        _pc: libc::uintptr_t,\n+                        filename: *const libc::c_char,\n+                        lineno: libc::c_int,\n+                        _function: *const libc::c_char) -> libc::c_int {\n+        if !filename.is_null() {\n+            let slot = data as *mut &mut [FileLine];\n+            let buffer = unsafe {ptr::read(slot)};\n+\n+            // if the buffer is not full, add file:line to the buffer\n+            // and adjust the buffer for next possible calls to pcinfo_cb.\n+            if !buffer.is_empty() {\n+                buffer[0] = (filename, lineno);\n+                unsafe { ptr::write(slot, &mut buffer[1..]); }\n+            }\n+        }\n+\n+        0\n+    }\n+\n+    // The libbacktrace API supports creating a state, but it does not\n+    // support destroying a state. I personally take this to mean that a\n+    // state is meant to be created and then live forever.\n+    //\n+    // I would love to register an at_exit() handler which cleans up this\n+    // state, but libbacktrace provides no way to do so.\n+    //\n+    // With these constraints, this function has a statically cached state\n+    // that is calculated the first time this is requested. Remember that\n+    // backtracing all happens serially (one global lock).\n+    //\n+    // An additionally oddity in this function is that we initialize the\n+    // filename via self_exe_name() to pass to libbacktrace. It turns out\n+    // that on Linux libbacktrace seamlessly gets the filename of the\n+    // current executable, but this fails on freebsd. by always providing\n+    // it, we make sure that libbacktrace never has a reason to not look up\n+    // the symbols. The libbacktrace API also states that the filename must\n+    // be in \"permanent memory\", so we copy it to a static and then use the\n+    // static as the pointer.\n+    //\n+    // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n+    //        tested if this is required or not.\n+    unsafe fn init_state() -> *mut backtrace_state {\n+        static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n+        static mut LAST_FILENAME: [libc::c_char; 256] = [0; 256];\n+        if !STATE.is_null() { return STATE }\n+        let selfname = if cfg!(target_os = \"freebsd\") ||\n+            cfg!(target_os = \"dragonfly\") ||\n+            cfg!(target_os = \"bitrig\") ||\n+            cfg!(target_os = \"openbsd\") {\n+                env::current_exe().ok()\n+            } else {\n+                None\n+            };\n+        let filename = match selfname {\n+            Some(path) => {\n+                let bytes = path.as_os_str().as_bytes();\n+                if bytes.len() < LAST_FILENAME.len() {\n+                    let i = bytes.iter();\n+                    for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n+                        *slot = *val as libc::c_char;\n+                    }\n+                    LAST_FILENAME.as_ptr()\n+                } else {\n+                    ptr::null()\n+                }\n+            }\n+            None => ptr::null(),\n+        };\n+        STATE = backtrace_create_state(filename, 0, error_cb,\n+                                       ptr::null_mut());\n+        return STATE\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // translation\n+    ////////////////////////////////////////////////////////////////////////\n+\n+    // backtrace errors are currently swept under the rug, only I/O\n+    // errors are reported\n+    let state = unsafe { init_state() };\n+    if state.is_null() {\n+        return output(w, idx, addr, None)\n+    }\n+    let mut data = ptr::null();\n+    let data_addr = &mut data as *mut *const libc::c_char;\n+    let ret = unsafe {\n+        backtrace_syminfo(state, symaddr as libc::uintptr_t,\n+                          syminfo_cb, error_cb,\n+                          data_addr as *mut libc::c_void)\n+    };\n+    if ret == 0 || data.is_null() {\n+        try!(output(w, idx, addr, None));\n+    } else {\n+        try!(output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() })));\n+    }\n+\n+    // pcinfo may return an arbitrary number of file:line pairs,\n+    // in the order of stack trace (i.e. inlined calls first).\n+    // in order to avoid allocation, we stack-allocate a fixed size of entries.\n+    const FILELINE_SIZE: usize = 32;\n+    let mut fileline_buf = [(ptr::null(), -1); FILELINE_SIZE];\n+    let ret;\n+    let fileline_count;\n+    {\n+        let mut fileline_win: &mut [FileLine] = &mut fileline_buf;\n+        let fileline_addr = &mut fileline_win as *mut &mut [FileLine];\n+        ret = unsafe {\n+            backtrace_pcinfo(state, addr as libc::uintptr_t,\n+                             pcinfo_cb, error_cb,\n+                             fileline_addr as *mut libc::c_void)\n+        };\n+        fileline_count = FILELINE_SIZE - fileline_win.len();\n+    }\n+    if ret == 0 {\n+        for (i, &(file, line)) in fileline_buf[..fileline_count].iter().enumerate() {\n+            if file.is_null() { continue; } // just to be sure\n+            let file = unsafe { CStr::from_ptr(file).to_bytes() };\n+            try!(output_fileline(w, file, line, i == FILELINE_SIZE - 1));\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "a3bd45566f1c752e22c0b2a36420d03a021ece7c", "filename": "src/libstd/sys/unix/backtrace/printing/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::imp::*;\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[path = \"dladdr.rs\"]\n+mod imp;\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+#[path = \"libbacktrace.rs\"]\n+mod imp;"}, {"sha": "2865abb254c89ebad5c8c9c908e4457694c7567b", "filename": "src/libstd/sys/unix/backtrace/tracing/backtrace_fn.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// As always - iOS on arm uses SjLj exceptions and\n+/// _Unwind_Backtrace is even not available there. Still,\n+/// backtraces could be extracted using a backtrace function,\n+/// which thanks god is public\n+///\n+/// As mentioned in a huge comment block in `super::super`, backtrace\n+/// doesn't play well with green threads, so while it is extremely nice and\n+/// simple to use it should be used only on iOS devices as the only viable\n+/// option.\n+\n+use io;\n+use io::prelude::*;\n+use iter::Iterator;\n+use libc;\n+use mem;\n+use result::Result::Ok;\n+use sync::StaticMutex;\n+\n+use super::printer::print;\n+\n+#[inline(never)]\n+pub fn write(w: &mut Write) -> io::Result<()> {\n+    use mem;\n+\n+    extern {\n+        fn backtrace(buf: *mut *mut libc::c_void,\n+                     sz: libc::c_int) -> libc::c_int;\n+    }\n+\n+    // while it doesn't requires lock for work as everything is\n+    // local, it still displays much nicer backtraces when a\n+    // couple of threads panic simultaneously\n+    static LOCK: StaticMutex = StaticMutex::new();\n+    let _g = LOCK.lock();\n+\n+    try!(writeln!(w, \"stack backtrace:\"));\n+    // 100 lines should be enough\n+    const SIZE: usize = 100;\n+    let mut buf: [*mut libc::c_void; SIZE] = unsafe { mem::zeroed() };\n+    let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as usize};\n+\n+    // skipping the first one as it is write itself\n+    for i in 1..cnt {\n+        try!(print(w, i as isize, buf[i], buf[i]))\n+    }\n+    Ok(())\n+}"}, {"sha": "cdaf69c48825334c19731419179d1f80a05b36f0", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use io::prelude::*;\n+use libc;\n+use mem;\n+use sync::StaticMutex;\n+\n+use super::super::printing::print;\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn write(w: &mut Write) -> io::Result<()> {\n+    struct Context<'a> {\n+        idx: isize,\n+        writer: &'a mut (Write+'a),\n+        last_error: Option<io::Error>,\n+    }\n+\n+    // When using libbacktrace, we use some necessary global state, so we\n+    // need to prevent more than one thread from entering this block. This\n+    // is semi-reasonable in terms of printing anyway, and we know that all\n+    // I/O done here is blocking I/O, not green I/O, so we don't have to\n+    // worry about this being a native vs green mutex.\n+    static LOCK: StaticMutex = StaticMutex::new();\n+    let _g = LOCK.lock();\n+\n+    try!(writeln!(w, \"stack backtrace:\"));\n+\n+    let mut cx = Context { writer: w, last_error: None, idx: 0 };\n+    return match unsafe {\n+        uw::_Unwind_Backtrace(trace_fn,\n+                              &mut cx as *mut Context as *mut libc::c_void)\n+    } {\n+        uw::_URC_NO_REASON => {\n+            match cx.last_error {\n+                Some(err) => Err(err),\n+                None => Ok(())\n+            }\n+        }\n+        _ => Ok(()),\n+    };\n+\n+    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                       arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n+        let cx: &mut Context = unsafe { mem::transmute(arg) };\n+        let mut ip_before_insn = 0;\n+        let mut ip = unsafe {\n+            uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n+        };\n+        if !ip.is_null() && ip_before_insn == 0 {\n+            // this is a non-signaling frame, so `ip` refers to the address\n+            // after the calling instruction. account for that.\n+            ip = (ip as usize - 1) as *mut _;\n+        }\n+\n+        // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+        // it appears to work fine without it, so we only use\n+        // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+        // slightly more accurate stack trace in the process.\n+        //\n+        // This is often because panic involves the last instruction of a\n+        // function being \"call std::rt::begin_unwind\", with no ret\n+        // instructions after it. This means that the return instruction\n+        // pointer points *outside* of the calling function, and by\n+        // unwinding it we go back to the original function.\n+        let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+            ip\n+        } else {\n+            unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+        };\n+\n+        // Don't print out the first few frames (they're not user frames)\n+        cx.idx += 1;\n+        if cx.idx <= 0 { return uw::_URC_NO_REASON }\n+        // Don't print ginormous backtraces\n+        if cx.idx > 100 {\n+            match write!(cx.writer, \" ... <frames omitted>\\n\") {\n+                Ok(()) => {}\n+                Err(e) => { cx.last_error = Some(e); }\n+            }\n+            return uw::_URC_FAILURE\n+        }\n+\n+        // Once we hit an error, stop trying to print more frames\n+        if cx.last_error.is_some() { return uw::_URC_FAILURE }\n+\n+        match print(cx.writer, cx.idx, ip, symaddr) {\n+            Ok(()) => {}\n+            Err(e) => { cx.last_error = Some(e); }\n+        }\n+\n+        // keep going\n+        return uw::_URC_NO_REASON\n+    }\n+}\n+\n+/// Unwind library interface used for backtraces\n+///\n+/// Note that dead code is allowed as here are just bindings\n+/// iOS doesn't use all of them it but adding more\n+/// platform-specific configs pollutes the code too much\n+#[allow(non_camel_case_types)]\n+#[allow(non_snake_case)]\n+mod uw {\n+    pub use self::_Unwind_Reason_Code::*;\n+\n+    use libc;\n+\n+    #[repr(C)]\n+    pub enum _Unwind_Reason_Code {\n+        _URC_NO_REASON = 0,\n+        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+        _URC_FATAL_PHASE2_ERROR = 2,\n+        _URC_FATAL_PHASE1_ERROR = 3,\n+        _URC_NORMAL_STOP = 4,\n+        _URC_END_OF_STACK = 5,\n+        _URC_HANDLER_FOUND = 6,\n+        _URC_INSTALL_CONTEXT = 7,\n+        _URC_CONTINUE_UNWIND = 8,\n+        _URC_FAILURE = 9, // used only by ARM EABI\n+    }\n+\n+    pub enum _Unwind_Context {}\n+\n+    pub type _Unwind_Trace_Fn =\n+            extern fn(ctx: *mut _Unwind_Context,\n+                      arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n+\n+    extern {\n+        // No native _Unwind_Backtrace on iOS\n+        #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                                 trace_argument: *mut libc::c_void)\n+                    -> _Unwind_Reason_Code;\n+\n+        // available since GCC 4.2.0, should be fine for our purpose\n+        #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n+                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                                 ip_before_insn: *mut libc::c_int)\n+                    -> libc::uintptr_t;\n+\n+        #[cfg(all(not(target_os = \"android\"),\n+                  not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+            -> *mut libc::c_void;\n+    }\n+\n+    // On android, the function _Unwind_GetIP is a macro, and this is the\n+    // expansion of the macro. This is all copy/pasted directly from the\n+    // header file with the definition of _Unwind_GetIP.\n+    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n+        #[repr(C)]\n+        enum _Unwind_VRS_Result {\n+            _UVRSR_OK = 0,\n+            _UVRSR_NOT_IMPLEMENTED = 1,\n+            _UVRSR_FAILED = 2,\n+        }\n+        #[repr(C)]\n+        enum _Unwind_VRS_RegClass {\n+            _UVRSC_CORE = 0,\n+            _UVRSC_VFP = 1,\n+            _UVRSC_FPA = 2,\n+            _UVRSC_WMMXD = 3,\n+            _UVRSC_WMMXC = 4,\n+        }\n+        #[repr(C)]\n+        enum _Unwind_VRS_DataRepresentation {\n+            _UVRSD_UINT32 = 0,\n+            _UVRSD_VFPX = 1,\n+            _UVRSD_FPAX = 2,\n+            _UVRSD_UINT64 = 3,\n+            _UVRSD_FLOAT = 4,\n+            _UVRSD_DOUBLE = 5,\n+        }\n+\n+        type _Unwind_Word = libc::c_uint;\n+        extern {\n+            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n+                               klass: _Unwind_VRS_RegClass,\n+                               word: _Unwind_Word,\n+                               repr: _Unwind_VRS_DataRepresentation,\n+                               data: *mut libc::c_void)\n+                -> _Unwind_VRS_Result;\n+        }\n+\n+        let mut val: _Unwind_Word = 0;\n+        let ptr = &mut val as *mut _Unwind_Word;\n+        let _ = _Unwind_VRS_Get(ctx, _Unwind_VRS_RegClass::_UVRSC_CORE, 15,\n+                                _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n+                                ptr as *mut libc::c_void);\n+        (val & !1) as libc::uintptr_t\n+    }\n+\n+    // This function doesn't exist on Android or ARM/Linux, so make it same\n+    // to _Unwind_GetIP\n+    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                                    ip_before_insn: *mut libc::c_int)\n+        -> libc::uintptr_t\n+    {\n+        *ip_before_insn = 0;\n+        _Unwind_GetIP(ctx)\n+    }\n+\n+    // This function also doesn't exist on Android or ARM/Linux, so make it\n+    // a no-op\n+    #[cfg(any(target_os = \"android\",\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+        -> *mut libc::c_void\n+    {\n+        pc\n+    }\n+}"}, {"sha": "c9c8e260d2f6336390144234d86c9cb12f533744", "filename": "src/libstd/sys/unix/backtrace/tracing/mod.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054b7b766cd9624cdce1f09b279331d26e05f30e/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fmod.rs?ref=054b7b766cd9624cdce1f09b279331d26e05f30e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::imp::*;\n+\n+#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+#[path = \"gcc_s.rs\"]\n+mod imp;\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n+#[path = \"backtrace_fn.rs\"]\n+mod imp;"}]}