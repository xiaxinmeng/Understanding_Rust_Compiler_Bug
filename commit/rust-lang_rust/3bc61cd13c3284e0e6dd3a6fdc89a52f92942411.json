{"sha": "3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYzYxY2QxM2MzMjg0ZTBlNmRkM2E2ZmRjODlhNTJmOTI5NDI0MTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-19T18:41:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-19T18:41:21Z"}, "message": "Rollup merge of #57689 - nnethercote:redo-hir-Stmt, r=petrochenkov\n\nRedo `hir::Stmt`\n\nA couple of changes that make things simpler and more consistent.\n\nThis should probably wait until after 1.32 lands to land, to avoid late breakage for tools.", "tree": {"sha": "6a413a84e9091fa4d8a1eeeb143e734b5376e11b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a413a84e9091fa4d8a1eeeb143e734b5376e11b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcQ29RCRBK7hj4Ov3rIwAAdHIIAGX0tgbhfUIq3lgjtsxlIb/a\nB6JnJdiuPLh4fFHeaKgrscEaNgh8APtvd3D/tMcy6p8wEB2JFONKwXNs60VKVula\nyrepMVlm+V1jfFMedIc6Hwr0OFGcWb8TRROnDi1g0dj9Qs79qsG0FyawdDKTftZs\nIh2xnUDUTcDVGxLxvEtxdcT0GG1/kMEVdT3f0h/W2tdi89MdgyVv57/Ip9x5sZUG\nRO70tgWNH9klhkx/B4Z/bDB7f08jBM4/imvtA8O0+wBPKiNbkstTMjmo15Onme46\n8yWtIFAfcSOQXxTDP9wrCChbCoG+hNQik/IHXwdzpS6GYvJImWDxPNjgkOyM2YU=\n=LZzG\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a413a84e9091fa4d8a1eeeb143e734b5376e11b\nparent 286ce3c36a408093208659e8b1777d06385d4e2e\nparent afbd004d696063adf1301ae461c41565f2f1921a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547923281 +0100\ncommitter GitHub <noreply@github.com> 1547923281 +0100\n\nRollup merge of #57689 - nnethercote:redo-hir-Stmt, r=petrochenkov\n\nRedo `hir::Stmt`\n\nA couple of changes that make things simpler and more consistent.\n\nThis should probably wait until after 1.32 lands to land, to avoid late breakage for tools.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "html_url": "https://github.com/rust-lang/rust/commit/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "286ce3c36a408093208659e8b1777d06385d4e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/286ce3c36a408093208659e8b1777d06385d4e2e", "html_url": "https://github.com/rust-lang/rust/commit/286ce3c36a408093208659e8b1777d06385d4e2e"}, {"sha": "afbd004d696063adf1301ae461c41565f2f1921a", "url": "https://api.github.com/repos/rust-lang/rust/commits/afbd004d696063adf1301ae461c41565f2f1921a", "html_url": "https://github.com/rust-lang/rust/commit/afbd004d696063adf1301ae461c41565f2f1921a"}], "stats": {"total": 563, "additions": 223, "deletions": 340}, "files": [{"sha": "6122fe6370940cd9d2d89e19e8b86daa7fee58e7", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -99,30 +99,21 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let hir_id = self.tcx.hir().node_to_hir_id(stmt.node.id());\n-        match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                let exit = self.decl(&decl, pred);\n-                self.add_ast_node(hir_id.local_id, &[exit])\n-            }\n-\n-            hir::StmtKind::Expr(ref expr, _) |\n-            hir::StmtKind::Semi(ref expr, _) => {\n-                let exit = self.expr(&expr, pred);\n-                self.add_ast_node(hir_id.local_id, &[exit])\n-            }\n-        }\n-    }\n-\n-    fn decl(&mut self, decl: &hir::Decl, pred: CFGIndex) -> CFGIndex {\n-        match decl.node {\n-            hir::DeclKind::Local(ref local) => {\n+        let hir_id = self.tcx.hir().node_to_hir_id(stmt.id);\n+        let exit = match stmt.node {\n+            hir::StmtKind::Local(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&local.pat, init_exit)\n             }\n-\n-            hir::DeclKind::Item(_) => pred,\n-        }\n+            hir::StmtKind::Item(_) => {\n+                pred\n+            }\n+            hir::StmtKind::Expr(ref expr) |\n+            hir::StmtKind::Semi(ref expr) => {\n+                self.expr(&expr, pred)\n+            }\n+        };\n+        self.add_ast_node(hir_id.local_id, &[exit])\n     }\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {"}, {"sha": "df111b2be319f8bab3e36644215a4cbae44fb1a3", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -283,8 +283,8 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n         // When checking statements ignore expressions, they will be checked later\n-        if let hir::StmtKind::Decl(_, _) = stmt.node {\n-            for attr in stmt.node.attrs() {\n+        if let hir::StmtKind::Local(ref l) = stmt.node {\n+            for attr in l.attrs.iter() {\n                 if attr.check_name(\"inline\") {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n                 }"}, {"sha": "592fb7898f3e60a05f35b1a626fc3420ff5e2d44", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -258,9 +258,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_pat(&mut self, p: &'v Pat) {\n         walk_pat(self, p)\n     }\n-    fn visit_decl(&mut self, d: &'v Decl) {\n-        walk_decl(self, d)\n-    }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n@@ -951,26 +948,17 @@ pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+    visitor.visit_id(statement.id);\n     match statement.node {\n-        StmtKind::Decl(ref declaration, id) => {\n-            visitor.visit_id(id);\n-            visitor.visit_decl(declaration)\n-        }\n-        StmtKind::Expr(ref expression, id) |\n-        StmtKind::Semi(ref expression, id) => {\n-            visitor.visit_id(id);\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(ref item) => visitor.visit_nested_item(**item),\n+        StmtKind::Expr(ref expression) |\n+        StmtKind::Semi(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n     }\n }\n \n-pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n-    match declaration.node {\n-        DeclKind::Local(ref local) => visitor.visit_local(local),\n-        DeclKind::Item(item) => visitor.visit_nested_item(item),\n-    }\n-}\n-\n pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n     visitor.visit_id(constant.id);\n     visitor.visit_nested_body(constant.body);"}, {"sha": "2f7d8f0984e6f439d2c5d72b2c98e60da1dac999", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -1957,7 +1957,7 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (P<hir::Local>, SmallVec<[hir::ItemId; 1]>) {\n+    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[hir::ItemId; 1]>) {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n         let mut ids = SmallVec::<[hir::ItemId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n@@ -1967,7 +1967,7 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n-        (P(hir::Local {\n+        (hir::Local {\n             id: node_id,\n             hir_id,\n             ty: l.ty\n@@ -1984,7 +1984,7 @@ impl<'a> LoweringContext<'a> {\n             span: l.span,\n             attrs: l.attrs.clone(),\n             source: hir::LocalSource::Normal,\n-        }), ids)\n+        }, ids)\n     }\n \n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n@@ -4331,10 +4331,11 @@ impl<'a> LoweringContext<'a> {\n                         ThinVec::new(),\n                     ))\n                 };\n-                let match_stmt = respan(\n-                    head_sp,\n-                    hir::StmtKind::Expr(match_expr, self.next_id().node_id)\n-                );\n+                let match_stmt = hir::Stmt {\n+                    id: self.next_id().node_id,\n+                    node: hir::StmtKind::Expr(match_expr),\n+                    span: head_sp,\n+                };\n \n                 let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n \n@@ -4357,10 +4358,11 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = respan(\n-                    body.span,\n-                    hir::StmtKind::Expr(body_expr, self.next_id().node_id)\n-                );\n+                let body_stmt = hir::Stmt {\n+                    id: self.next_id().node_id,\n+                    node: hir::StmtKind::Expr(body_expr),\n+                    span: body.span,\n+                };\n \n                 let loop_block = P(self.block_all(\n                     e.span,\n@@ -4533,25 +4535,15 @@ impl<'a> LoweringContext<'a> {\n                 let (l, item_ids) = self.lower_local(l);\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n                     .into_iter()\n-                    .map(|item_id| Spanned {\n-                        node: hir::StmtKind::Decl(\n-                            P(Spanned {\n-                                node: hir::DeclKind::Item(item_id),\n-                                span: s.span,\n-                            }),\n-                            self.next_id().node_id,\n-                        ),\n+                    .map(|item_id| hir::Stmt {\n+                        id: self.next_id().node_id,\n+                        node: hir::StmtKind::Item(P(item_id)),\n                         span: s.span,\n                     })\n                     .collect();\n-                ids.push(Spanned {\n-                    node: hir::StmtKind::Decl(\n-                        P(Spanned {\n-                            node: hir::DeclKind::Local(l),\n-                            span: s.span,\n-                        }),\n-                        self.lower_node_id(s.id).node_id,\n-                    ),\n+                ids.push(hir::Stmt {\n+                    id: self.lower_node_id(s.id).node_id,\n+                    node: hir::StmtKind::Local(P(l)),\n                     span: s.span,\n                 });\n                 return ids;\n@@ -4561,26 +4553,23 @@ impl<'a> LoweringContext<'a> {\n                 let mut id = Some(s.id);\n                 return self.lower_item_id(it)\n                     .into_iter()\n-                    .map(|item_id| Spanned {\n-                        node: hir::StmtKind::Decl(\n-                            P(Spanned {\n-                                node: hir::DeclKind::Item(item_id),\n-                                span: s.span,\n-                            }),\n-                            id.take()\n+                    .map(|item_id| hir::Stmt {\n+                        id: id.take()\n                               .map(|id| self.lower_node_id(id).node_id)\n                               .unwrap_or_else(|| self.next_id().node_id),\n-                        ),\n+                        node: hir::StmtKind::Item(P(item_id)),\n                         span: s.span,\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => Spanned {\n-                node: hir::StmtKind::Expr(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n+            StmtKind::Expr(ref e) => hir::Stmt {\n+                id: self.lower_node_id(s.id).node_id,\n+                node: hir::StmtKind::Expr(P(self.lower_expr(e))),\n                 span: s.span,\n             },\n-            StmtKind::Semi(ref e) => Spanned {\n-                node: hir::StmtKind::Semi(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n+            StmtKind::Semi(ref e) => hir::Stmt {\n+                id: self.lower_node_id(s.id).node_id,\n+                node: hir::StmtKind::Semi(P(self.lower_expr(e))),\n                 span: s.span,\n             },\n             StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n@@ -4795,7 +4784,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::Stmt {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n-        let local = P(hir::Local {\n+        let local = hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n@@ -4804,9 +4793,12 @@ impl<'a> LoweringContext<'a> {\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n-        });\n-        let decl = respan(sp, hir::DeclKind::Local(local));\n-        respan(sp, hir::StmtKind::Decl(P(decl), self.next_id().node_id))\n+        };\n+        hir::Stmt {\n+            id: self.next_id().node_id,\n+            node: hir::StmtKind::Local(P(local)),\n+            span: sp\n+        }\n     }\n \n     fn stmt_let("}, {"sha": "7cc5d756ff311730fc4d3e77af2e84e515b9910e", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n-        let id = stmt.node.id();\n+        let id = stmt.id;\n         self.insert(stmt.span, id, Node::Stmt(stmt));\n \n         self.with_parent(id, |this| {"}, {"sha": "65d9d5a4f363f43dc83e1608859688702d1b3d92", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 20, "deletions": 50, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -17,7 +17,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n-use syntax::source_map::{self, Spanned};\n+use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Label, Lit, StrStyle, FloatTy, IntTy, UintTy};\n@@ -1134,45 +1134,41 @@ impl UnOp {\n }\n \n /// A statement\n-pub type Stmt = Spanned<StmtKind>;\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub struct Stmt {\n+    pub id: NodeId,\n+    pub node: StmtKind,\n+    pub span: Span,\n+}\n \n-impl fmt::Debug for StmtKind {\n+impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Sadness.\n-        let spanned = source_map::dummy_spanned(self.clone());\n-        write!(f,\n-               \"stmt({}: {})\",\n-               spanned.node.id(),\n-               print::to_string(print::NO_ANN, |s| s.print_stmt(&spanned)))\n+        write!(f, \"stmt({}: {})\", self.id,\n+               print::to_string(print::NO_ANN, |s| s.print_stmt(self)))\n     }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum StmtKind {\n-    /// Could be an item or a local (let) binding:\n-    Decl(P<Decl>, NodeId),\n+    /// A local (let) binding:\n+    Local(P<Local>),\n+    /// An item binding:\n+    Item(P<ItemId>),\n \n     /// Expr without trailing semi-colon (must have unit type):\n-    Expr(P<Expr>, NodeId),\n+    Expr(P<Expr>),\n \n     /// Expr with trailing semi-colon (may have any type):\n-    Semi(P<Expr>, NodeId),\n+    Semi(P<Expr>),\n }\n \n impl StmtKind {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtKind::Decl(ref d, _) => d.node.attrs(),\n-            StmtKind::Expr(ref e, _) |\n-            StmtKind::Semi(ref e, _) => &e.attrs,\n-        }\n-    }\n-\n-    pub fn id(&self) -> NodeId {\n-        match *self {\n-            StmtKind::Decl(_, id) |\n-            StmtKind::Expr(_, id) |\n-            StmtKind::Semi(_, id) => id,\n+            StmtKind::Local(ref l) => &l.attrs,\n+            StmtKind::Item(_) => &[],\n+            StmtKind::Expr(ref e) |\n+            StmtKind::Semi(ref e) => &e.attrs,\n         }\n     }\n }\n@@ -1191,32 +1187,6 @@ pub struct Local {\n     pub source: LocalSource,\n }\n \n-pub type Decl = Spanned<DeclKind>;\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum DeclKind {\n-    /// A local (let) binding:\n-    Local(P<Local>),\n-    /// An item binding:\n-    Item(ItemId),\n-}\n-\n-impl DeclKind {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            DeclKind::Local(ref l) => &l.attrs,\n-            DeclKind::Item(_) => &[]\n-        }\n-    }\n-\n-    pub fn is_local(&self) -> bool {\n-        match *self {\n-            DeclKind::Local(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n /// represents one arm of a 'match'\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {"}, {"sha": "e950f25c2ac9ae8697dbc969d91dc54ea30c9625", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -992,14 +992,29 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n         self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                self.print_decl(&decl)?;\n+            hir::StmtKind::Local(ref loc) => {\n+                self.space_if_not_bol()?;\n+                self.ibox(indent_unit)?;\n+                self.word_nbsp(\"let\")?;\n+\n+                self.ibox(indent_unit)?;\n+                self.print_local_decl(&loc)?;\n+                self.end()?;\n+                if let Some(ref init) = loc.init {\n+                    self.nbsp()?;\n+                    self.word_space(\"=\")?;\n+                    self.print_expr(&init)?;\n+                }\n+                self.end()?\n+            }\n+            hir::StmtKind::Item(ref item) => {\n+                self.ann.nested(self, Nested::Item(**item))?\n             }\n-            hir::StmtKind::Expr(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n             }\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n                 self.s.word(\";\")?;\n@@ -1562,30 +1577,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_decl(&mut self, decl: &hir::Decl) -> io::Result<()> {\n-        self.maybe_print_comment(decl.span.lo())?;\n-        match decl.node {\n-            hir::DeclKind::Local(ref loc) => {\n-                self.space_if_not_bol()?;\n-                self.ibox(indent_unit)?;\n-                self.word_nbsp(\"let\")?;\n-\n-                self.ibox(indent_unit)?;\n-                self.print_local_decl(&loc)?;\n-                self.end()?;\n-                if let Some(ref init) = loc.init {\n-                    self.nbsp()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_expr(&init)?;\n-                }\n-                self.end()\n-            }\n-            hir::DeclKind::Item(item) => {\n-                self.ann.nested(self, Nested::Item(item))\n-            }\n-        }\n-    }\n-\n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n         self.s.word(i.to_string())\n     }\n@@ -2401,18 +2392,10 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n /// seen the semicolon, and thus don't need another.\n fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n     match *stmt {\n-        hir::StmtKind::Decl(ref d, _) => {\n-            match d.node {\n-                hir::DeclKind::Local(_) => true,\n-                hir::DeclKind::Item(_) => false,\n-            }\n-        }\n-        hir::StmtKind::Expr(ref e, _) => {\n-            expr_requires_semi_to_be_stmt(&e)\n-        }\n-        hir::StmtKind::Semi(..) => {\n-            false\n-        }\n+        hir::StmtKind::Local(_) => true,\n+        hir::StmtKind::Item(_) => false,\n+        hir::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(&e),\n+        hir::StmtKind::Semi(..) => false,\n     }\n }\n "}, {"sha": "159067663d42e1402e5ee6f77e296c61a2cae8b0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -483,7 +483,12 @@ impl_stable_hash_for!(enum hir::UnOp {\n     UnNeg\n });\n \n-impl_stable_hash_for_spanned!(hir::StmtKind);\n+impl_stable_hash_for!(struct hir::Stmt {\n+    id,\n+    node,\n+    span,\n+});\n+\n \n impl_stable_hash_for!(struct hir::Local {\n     pat,\n@@ -496,12 +501,6 @@ impl_stable_hash_for!(struct hir::Local {\n     source\n });\n \n-impl_stable_hash_for_spanned!(hir::DeclKind);\n-impl_stable_hash_for!(enum hir::DeclKind {\n-    Local(local),\n-    Item(item_id)\n-});\n-\n impl_stable_hash_for!(struct hir::Arm {\n     attrs,\n     pats,\n@@ -941,9 +940,10 @@ impl_stable_hash_for!(enum hir::ForeignItemKind {\n });\n \n impl_stable_hash_for!(enum hir::StmtKind {\n-    Decl(decl, id),\n-    Expr(expr, id),\n-    Semi(expr, id)\n+    Local(local),\n+    Item(item_id),\n+    Expr(expr),\n+    Semi(expr)\n });\n \n impl_stable_hash_for!(struct hir::Arg {"}, {"sha": "837a3645d1c94d3c455bcb2c8523e827875ad69e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -941,11 +941,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &'tcx hir::Decl) {\n-        run_lints!(self, check_decl, d);\n-        hir_visit::walk_decl(self, d);\n-    }\n-\n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n         run_lints!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);"}, {"sha": "e83ba7402b5791cdbcac62f5853742367e8b8e73", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -192,7 +192,6 @@ macro_rules! late_lint_methods {\n             fn check_stmt(a: &$hir hir::Stmt);\n             fn check_arm(a: &$hir hir::Arm);\n             fn check_pat(a: &$hir hir::Pat);\n-            fn check_decl(a: &$hir hir::Decl);\n             fn check_expr(a: &$hir hir::Expr);\n             fn check_expr_post(a: &$hir hir::Expr);\n             fn check_ty(a: &$hir hir::Ty);"}, {"sha": "08210c3f075ce453e3a5fc4c06a80e8207ecee6d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -589,21 +589,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Local(ref local) => {\n-                        self.walk_local(&local);\n-                    }\n+            hir::StmtKind::Local(ref local) => {\n+                self.walk_local(&local);\n+            }\n \n-                    hir::DeclKind::Item(_) => {\n-                        // we don't visit nested items in this visitor,\n-                        // only the fn body we were given.\n-                    }\n-                }\n+            hir::StmtKind::Item(_) => {\n+                // we don't visit nested items in this visitor,\n+                // only the fn body we were given.\n             }\n \n-            hir::StmtKind::Expr(ref expr, _) |\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr) |\n+            hir::StmtKind::Semi(ref expr) => {\n                 self.consume_expr(&expr);\n             }\n         }"}, {"sha": "220bec735a47360b828ed4482c24f8d183181717", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -962,46 +962,31 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                self.propagate_through_decl(&decl, succ)\n-            }\n+            hir::StmtKind::Local(ref local) => {\n+                // Note: we mark the variable as defined regardless of whether\n+                // there is an initializer.  Initially I had thought to only mark\n+                // the live variable as defined if it was initialized, and then we\n+                // could check for uninit variables just by scanning what is live\n+                // at the start of the function. But that doesn't work so well for\n+                // immutable variables defined in a loop:\n+                //     loop { let x; x = 5; }\n+                // because the \"assignment\" loops back around and generates an error.\n+                //\n+                // So now we just check that variables defined w/o an\n+                // initializer are not live at the point of their\n+                // initialization, which is mildly more complex than checking\n+                // once at the func header but otherwise equivalent.\n \n-            hir::StmtKind::Expr(ref expr, _) | hir::StmtKind::Semi(ref expr, _) => {\n-                self.propagate_through_expr(&expr, succ)\n+                let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n+                self.define_bindings_in_pat(&local.pat, succ)\n             }\n-        }\n-    }\n-\n-    fn propagate_through_decl(&mut self, decl: &hir::Decl, succ: LiveNode)\n-                              -> LiveNode {\n-        match decl.node {\n-            hir::DeclKind::Local(ref local) => {\n-                self.propagate_through_local(&local, succ)\n+            hir::StmtKind::Item(..) => succ,\n+            hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n+                self.propagate_through_expr(&expr, succ)\n             }\n-            hir::DeclKind::Item(_) => succ,\n         }\n     }\n \n-    fn propagate_through_local(&mut self, local: &hir::Local, succ: LiveNode)\n-                               -> LiveNode {\n-        // Note: we mark the variable as defined regardless of whether\n-        // there is an initializer.  Initially I had thought to only mark\n-        // the live variable as defined if it was initialized, and then we\n-        // could check for uninit variables just by scanning what is live\n-        // at the start of the function. But that doesn't work so well for\n-        // immutable variables defined in a loop:\n-        //     loop { let x; x = 5; }\n-        // because the \"assignment\" loops back around and generates an error.\n-        //\n-        // So now we just check that variables defined w/o an\n-        // initializer are not live at the point of their\n-        // initialization, which is mildly more complex than checking\n-        // once at the func header but otherwise equivalent.\n-\n-        let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n-        self.define_bindings_in_pat(&local.pat, succ)\n-    }\n-\n     fn propagate_through_exprs(&mut self, exprs: &[Expr], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {"}, {"sha": "819dd8aa7d53e43f4c1671d561411b6ebb57a744", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -784,20 +784,25 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n         // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            if let hir::StmtKind::Decl(..) = statement.node {\n-                // Each StmtKind::Decl introduces a subscope for bindings\n-                // introduced by the declaration; this subscope covers\n-                // a suffix of the block . Each subscope in a block\n-                // has the previous subscope in the block as a parent,\n-                // except for the first such subscope, which has the\n-                // block itself as a parent.\n-                visitor.enter_scope(\n-                    Scope {\n-                        id: blk.hir_id.local_id,\n-                        data: ScopeData::Remainder(FirstStatementIndex::new(i))\n-                    }\n-                );\n-                visitor.cx.var_parent = visitor.cx.parent;\n+            match statement.node {\n+                hir::StmtKind::Local(..) |\n+                hir::StmtKind::Item(..) => {\n+                    // Each declaration introduces a subscope for bindings\n+                    // introduced by the declaration; this subscope covers a\n+                    // suffix of the block. Each subscope in a block has the\n+                    // previous subscope in the block as a parent, except for\n+                    // the first such subscope, which has the block itself as a\n+                    // parent.\n+                    visitor.enter_scope(\n+                        Scope {\n+                            id: blk.hir_id.local_id,\n+                            data: ScopeData::Remainder(FirstStatementIndex::new(i))\n+                        }\n+                    );\n+                    visitor.cx.var_parent = visitor.cx.parent;\n+                }\n+                hir::StmtKind::Expr(..) |\n+                hir::StmtKind::Semi(..) => {}\n             }\n             visitor.visit_stmt(statement)\n         }\n@@ -835,7 +840,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.node.id()).local_id;\n+    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.id).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during"}, {"sha": "8a68f1bb9d085e8512ee9a38708ba1da70457376", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -41,7 +41,7 @@ impl LintPass for UnusedResults {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n-            hir::StmtKind::Semi(ref expr, _) => &**expr,\n+            hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n         };\n \n@@ -205,7 +205,7 @@ impl LintPass for PathStatements {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        if let hir::StmtKind::Semi(ref expr, _) = s.node {\n+        if let hir::StmtKind::Semi(ref expr) = s.node {\n             if let hir::ExprKind::Path(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }"}, {"sha": "c50d9ddcb152e95a228817ef5fc7bfe54f4e7c96", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -46,12 +46,12 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n-        let hir_id = cx.tcx.hir().node_to_hir_id(stmt.node.id());\n+        let hir_id = cx.tcx.hir().node_to_hir_id(stmt.id);\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        let stmt_span = StatementSpan(cx.tcx.hir().span(stmt.node.id()));\n+        let stmt_span = StatementSpan(cx.tcx.hir().span(stmt.id));\n         match stmt.node {\n-            hir::StmtKind::Expr(ref expr, _) |\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr) |\n+            hir::StmtKind::Semi(ref expr) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Expr {\n                         scope: region::Scope {\n@@ -64,52 +64,48 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span: stmt_span,\n                 })))\n             }\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Item(..) => {\n-                        // ignore for purposes of the MIR\n-                    }\n-                    hir::DeclKind::Local(ref local) => {\n-                        let remainder_scope = region::Scope {\n-                            id: block_id,\n-                            data: region::ScopeData::Remainder(\n-                                region::FirstStatementIndex::new(index)),\n-                        };\n-\n-                        let mut pattern = cx.pattern_from_hir(&local.pat);\n+            hir::StmtKind::Item(..) => {\n+                // ignore for purposes of the MIR\n+            }\n+            hir::StmtKind::Local(ref local) => {\n+                let remainder_scope = region::Scope {\n+                    id: block_id,\n+                    data: region::ScopeData::Remainder(\n+                        region::FirstStatementIndex::new(index)),\n+                };\n \n-                        if let Some(ty) = &local.ty {\n-                            if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n-                                debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                                pattern = Pattern {\n-                                    ty: pattern.ty,\n-                                    span: pattern.span,\n-                                    kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: PatternTypeProjection::from_user_type(user_ty),\n-                                        user_ty_span: ty.span,\n-                                        subpattern: pattern,\n-                                        variance: ty::Variance::Covariant,\n-                                    })\n-                                };\n-                            }\n-                        }\n+                let mut pattern = cx.pattern_from_hir(&local.pat);\n \n-                        result.push(StmtRef::Mirror(Box::new(Stmt {\n-                            kind: StmtKind::Let {\n-                                remainder_scope: remainder_scope,\n-                                init_scope: region::Scope {\n-                                    id: hir_id.local_id,\n-                                    data: region::ScopeData::Node\n-                                },\n-                                pattern,\n-                                initializer: local.init.to_ref(),\n-                                lint_level: cx.lint_level_of(local.id),\n-                            },\n-                            opt_destruction_scope: opt_dxn_ext,\n-                            span: stmt_span,\n-                        })));\n+                if let Some(ty) = &local.ty {\n+                    if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n+                        debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n+                        pattern = Pattern {\n+                            ty: pattern.ty,\n+                            span: pattern.span,\n+                            kind: Box::new(PatternKind::AscribeUserType {\n+                                user_ty: PatternTypeProjection::from_user_type(user_ty),\n+                                user_ty_span: ty.span,\n+                                subpattern: pattern,\n+                                variance: ty::Variance::Covariant,\n+                            })\n+                        };\n                     }\n                 }\n+\n+                result.push(StmtRef::Mirror(Box::new(Stmt {\n+                    kind: StmtKind::Let {\n+                        remainder_scope: remainder_scope,\n+                        init_scope: region::Scope {\n+                            id: hir_id.local_id,\n+                            data: region::ScopeData::Node\n+                        },\n+                        pattern,\n+                        initializer: local.init.to_ref(),\n+                        lint_level: cx.lint_level_of(local.id),\n+                    },\n+                    opt_destruction_scope: opt_dxn_ext,\n+                    span: stmt_span,\n+                })));\n             }\n         }\n     }"}, {"sha": "74d6d75a7f528ad9ef403b8406af5676aa05cebf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -144,7 +144,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n-        self.record(\"Stmt\", Id::Node(s.node.id()), s);\n+        self.record(\"Stmt\", Id::Node(s.id), s);\n         hir_visit::walk_stmt(self, s)\n     }\n \n@@ -158,11 +158,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_pat(self, p)\n     }\n \n-    fn visit_decl(&mut self, d: &'v hir::Decl) {\n-        self.record(\"Decl\", Id::None, d);\n-        hir_visit::walk_decl(self, d)\n-    }\n-\n     fn visit_expr(&mut self, ex: &'v hir::Expr) {\n         self.record(\"Expr\", Id::Node(ex.id), ex);\n         hir_visit::walk_expr(self, ex)"}, {"sha": "49914dc7078fdbc2159cbbb84b5e05088a289391", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -220,26 +220,22 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _node_id) => {\n-                match &decl.node {\n-                    hir::DeclKind::Local(local) => {\n-                        if self.remove_mut_rvalue_borrow(&local.pat) {\n-                            if let Some(init) = &local.init {\n-                                self.mut_rvalue_borrows.insert(init.id);\n-                            }\n-                        }\n-\n-                        if let Some(ref expr) = local.init {\n-                            let _ = self.check_expr(&expr);\n-                        }\n-                        NotPromotable\n+            hir::StmtKind::Local(ref local) => {\n+                if self.remove_mut_rvalue_borrow(&local.pat) {\n+                    if let Some(init) = &local.init {\n+                        self.mut_rvalue_borrows.insert(init.id);\n                     }\n-                    // Item statements are allowed\n-                    hir::DeclKind::Item(_) => Promotable\n                 }\n+\n+                if let Some(ref expr) = local.init {\n+                    let _ = self.check_expr(&expr);\n+                }\n+                NotPromotable\n             }\n-            hir::StmtKind::Expr(ref box_expr, _node_id) |\n-            hir::StmtKind::Semi(ref box_expr, _node_id) => {\n+            // Item statements are allowed\n+            hir::StmtKind::Item(..) => Promotable,\n+            hir::StmtKind::Expr(ref box_expr) |\n+            hir::StmtKind::Semi(ref box_expr) => {\n                 let _ = self.check_expr(box_expr);\n                 NotPromotable\n             }"}, {"sha": "4957a12e61e0f532699f1748c69a4b0f99b01c2a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc61cd13c3284e0e6dd3a6fdc89a52f92942411/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3bc61cd13c3284e0e6dd3a6fdc89a52f92942411", "patch": "@@ -4840,15 +4840,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                if let hir::DeclKind::Item(_) = decl.node {\n-                    return\n-                }\n-            }\n-            hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+            hir::StmtKind::Item(..) => return,\n+            hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n         }\n \n-        self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n+        self.warn_if_unreachable(stmt.id, stmt.span, \"statement\");\n \n         // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.get();\n@@ -4857,20 +4853,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.has_errors.set(false);\n \n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Local(ref l) => {\n-                        self.check_decl_local(&l);\n-                    }\n-                    // Ignore for now.\n-                    hir::DeclKind::Item(_) => ()\n-                }\n+            hir::StmtKind::Local(ref l) => {\n+                self.check_decl_local(&l);\n             }\n-            hir::StmtKind::Expr(ref expr, _) => {\n+            // Ignore for now.\n+            hir::StmtKind::Item(_) => {}\n+            hir::StmtKind::Expr(ref expr) => {\n                 // Check with expected type of `()`.\n                 self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit());\n             }\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Semi(ref expr) => {\n                 self.check_expr(&expr);\n             }\n         }\n@@ -5273,7 +5265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None => return None,\n         };\n         let last_expr = match last_stmt.node {\n-            hir::StmtKind::Semi(ref e, _) => e,\n+            hir::StmtKind::Semi(ref e) => e,\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);"}]}