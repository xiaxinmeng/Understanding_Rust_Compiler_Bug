{"sha": "915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNWJiZGFjNTgwYjI2ZTJkNDdiYWExY2EzZmQyMTM0OWM0ZjRiMGI=", "commit": {"author": {"name": "Piotr Jawniak", "email": "sawyer47@gmail.com", "date": "2016-09-04T16:35:35Z"}, "committer": {"name": "Piotr Jawniak", "email": "sawyer47@gmail.com", "date": "2016-09-05T18:24:55Z"}, "message": "rustdoc: Filter more incorrect methods inherited through Deref\n\nOld code filtered out only static methods. This code also excludes\n&mut self methods if there is no DerefMut implementation", "tree": {"sha": "b9b8971a3b7e4615ea0c34529500a2afc9059c0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9b8971a3b7e4615ea0c34529500a2afc9059c0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "html_url": "https://github.com/rust-lang/rust/commit/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/comments", "author": {"login": "Sawyer47", "id": 1534302, "node_id": "MDQ6VXNlcjE1MzQzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1534302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sawyer47", "html_url": "https://github.com/Sawyer47", "followers_url": "https://api.github.com/users/Sawyer47/followers", "following_url": "https://api.github.com/users/Sawyer47/following{/other_user}", "gists_url": "https://api.github.com/users/Sawyer47/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sawyer47/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sawyer47/subscriptions", "organizations_url": "https://api.github.com/users/Sawyer47/orgs", "repos_url": "https://api.github.com/users/Sawyer47/repos", "events_url": "https://api.github.com/users/Sawyer47/events{/privacy}", "received_events_url": "https://api.github.com/users/Sawyer47/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sawyer47", "id": 1534302, "node_id": "MDQ6VXNlcjE1MzQzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1534302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sawyer47", "html_url": "https://github.com/Sawyer47", "followers_url": "https://api.github.com/users/Sawyer47/followers", "following_url": "https://api.github.com/users/Sawyer47/following{/other_user}", "gists_url": "https://api.github.com/users/Sawyer47/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sawyer47/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sawyer47/subscriptions", "organizations_url": "https://api.github.com/users/Sawyer47/orgs", "repos_url": "https://api.github.com/users/Sawyer47/repos", "events_url": "https://api.github.com/users/Sawyer47/events{/privacy}", "received_events_url": "https://api.github.com/users/Sawyer47/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "987b47549eae03e4d9699336f5e30f787161acaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/987b47549eae03e4d9699336f5e30f787161acaa", "html_url": "https://github.com/rust-lang/rust/commit/987b47549eae03e4d9699336f5e30f787161acaa"}], "stats": {"total": 181, "additions": 154, "deletions": 27}, "files": [{"sha": "36b03ce8a2da78393e3131f27eedfda8003c7ad3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "patch": "@@ -134,6 +134,8 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n         if let Some(t) = cx.tcx_opt() {\n             cx.deref_trait_did.set(t.lang_items.deref_trait());\n             cx.renderinfo.borrow_mut().deref_trait_did = cx.deref_trait_did.get();\n+            cx.deref_mut_trait_did.set(t.lang_items.deref_mut_trait());\n+            cx.renderinfo.borrow_mut().deref_mut_trait_did = cx.deref_mut_trait_did.get();\n         }\n \n         let mut externs = Vec::new();\n@@ -1117,6 +1119,10 @@ impl FnDecl {\n     pub fn has_self(&self) -> bool {\n         return self.inputs.values.len() > 0 && self.inputs.values[0].name == \"self\";\n     }\n+\n+    pub fn self_type(&self) -> Option<SelfTy> {\n+        self.inputs.values.get(0).and_then(|v| v.to_self())\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]"}, {"sha": "8c5bd9fe3e62b4c78d236bec2a1ed6a5e9c4c7dd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "patch": "@@ -53,6 +53,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub input: Input,\n     pub populated_crate_impls: RefCell<FnvHashSet<ast::CrateNum>>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n+    pub deref_mut_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n@@ -180,6 +181,7 @@ pub fn run_core(search_paths: SearchPaths,\n             input: input,\n             populated_crate_impls: RefCell::new(FnvHashSet()),\n             deref_trait_did: Cell::new(None),\n+            deref_mut_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),\n             external_traits: RefCell::new(FnvHashMap()),\n             renderinfo: RefCell::new(Default::default()),"}, {"sha": "c38f0a9584b1496b4aa74119b09119431354ce90", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "patch": "@@ -64,7 +64,7 @@ use rustc::hir;\n use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc_data_structures::flock;\n \n-use clean::{self, Attributes, GetDefId};\n+use clean::{self, Attributes, GetDefId, SelfTy, Mutability};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -266,6 +266,7 @@ pub struct Cache {\n     seen_mod: bool,\n     stripped_mod: bool,\n     deref_trait_did: Option<DefId>,\n+    deref_mut_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n@@ -283,6 +284,7 @@ pub struct RenderInfo {\n     pub external_paths: ::core::ExternalPaths,\n     pub external_typarams: FnvHashMap<DefId, String>,\n     pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n }\n \n /// Helper struct to render all source code to HTML pages\n@@ -508,6 +510,7 @@ pub fn run(mut krate: clean::Crate,\n         external_paths,\n         external_typarams,\n         deref_trait_did,\n+        deref_mut_trait_did,\n     } = renderinfo;\n \n     let external_paths = external_paths.into_iter()\n@@ -532,6 +535,7 @@ pub fn run(mut krate: clean::Crate,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, FnvHashMap()),\n         deref_trait_did: deref_trait_did,\n+        deref_mut_trait_did: deref_mut_trait_did,\n         typarams: external_typarams,\n     };\n \n@@ -2604,7 +2608,13 @@ impl<'a> AssocItemLink<'a> {\n \n enum AssocItemRender<'a> {\n     All,\n-    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type },\n+    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool }\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+enum RenderMode {\n+    Normal,\n+    ForDeref { mut_: bool },\n }\n \n fn render_assoc_items(w: &mut fmt::Formatter,\n@@ -2621,19 +2631,19 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         i.inner_impl().trait_.is_none()\n     });\n     if !non_trait.is_empty() {\n-        let render_header = match what {\n+        let render_mode = match what {\n             AssocItemRender::All => {\n                 write!(w, \"<h2 id='methods'>Methods</h2>\")?;\n-                true\n+                RenderMode::Normal\n             }\n-            AssocItemRender::DerefFor { trait_, type_ } => {\n+            AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n                 write!(w, \"<h2 id='deref-methods'>Methods from \\\n                                {}&lt;Target={}&gt;</h2>\", trait_, type_)?;\n-                false\n+                RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n         for i in &non_trait {\n-            render_impl(w, cx, i, AssocItemLink::Anchor(None), render_header,\n+            render_impl(w, cx, i, AssocItemLink::Anchor(None), render_mode,\n                         containing_item.stable_since())?;\n         }\n     }\n@@ -2645,29 +2655,34 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             t.inner_impl().trait_.def_id() == c.deref_trait_did\n         });\n         if let Some(impl_) = deref_impl {\n-            render_deref_methods(w, cx, impl_, containing_item)?;\n+            let has_deref_mut = traits.iter().find(|t| {\n+                t.inner_impl().trait_.def_id() == c.deref_mut_trait_did\n+            }).is_some();\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut)?;\n         }\n         write!(w, \"<h2 id='implementations'>Trait \\\n                    Implementations</h2>\")?;\n         for i in &traits {\n             let did = i.trait_did().unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n-            render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n+            render_impl(w, cx, i, assoc_link,\n+                        RenderMode::Normal, containing_item.stable_since())?;\n         }\n     }\n     Ok(())\n }\n \n fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n-                        container_item: &clean::Item) -> fmt::Result {\n+                        container_item: &clean::Item, deref_mut: bool) -> fmt::Result {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let target = impl_.inner_impl().items.iter().filter_map(|item| {\n         match item.inner {\n             clean::TypedefItem(ref t, true) => Some(&t.type_),\n             _ => None,\n         }\n     }).next().expect(\"Expected associated type binding\");\n-    let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n+    let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target,\n+                                           deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n@@ -2681,12 +2696,9 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n     }\n }\n \n-// Render_header is false when we are rendering a `Deref` impl and true\n-// otherwise. If render_header is false, we will avoid rendering static\n-// methods, since they are not accessible for the type implementing `Deref`\n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n-               render_header: bool, outer_version: Option<&str>) -> fmt::Result {\n-    if render_header {\n+               render_mode: RenderMode, outer_version: Option<&str>) -> fmt::Result {\n+    if render_mode == RenderMode::Normal {\n         write!(w, \"<h3 class='impl'><span class='in-band'><code>{}</code>\", i.inner_impl())?;\n         write!(w, \"</span><span class='out-of-band'>\")?;\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n@@ -2707,22 +2719,43 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     }\n \n     fn doc_impl_item(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n-                     link: AssocItemLink, render_static: bool,\n+                     link: AssocItemLink, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n                      trait_: Option<&clean::Trait>) -> fmt::Result {\n         let item_type = item_type(item);\n         let name = item.name.as_ref().unwrap();\n \n-        let is_static = match item.inner {\n-            clean::MethodItem(ref method) => !method.decl.has_self(),\n-            clean::TyMethodItem(ref method) => !method.decl.has_self(),\n-            _ => false\n+        let render_method_item: bool = match render_mode {\n+            RenderMode::Normal => true,\n+            RenderMode::ForDeref { mut_: deref_mut_ } => {\n+                let self_type_opt = match item.inner {\n+                    clean::MethodItem(ref method) => method.decl.self_type(),\n+                    clean::TyMethodItem(ref method) => method.decl.self_type(),\n+                    _ => None\n+                };\n+\n+                if let Some(self_ty) = self_type_opt {\n+                    let by_mut_ref = match self_ty {\n+                        SelfTy::SelfBorrowed(_lifetime, mutability) => {\n+                            mutability == Mutability::Mutable\n+                        },\n+                        SelfTy::SelfExplicit(clean::BorrowedRef { mutability, .. }) => {\n+                            mutability == Mutability::Mutable\n+                        },\n+                        _ => false,\n+                    };\n+\n+                    deref_mut_ || !by_mut_ref\n+                } else {\n+                    false\n+                }\n+            },\n         };\n \n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n-                if !is_static || render_static {\n+                if render_method_item {\n                     let id = derive_id(format!(\"{}.{}\", item_type, name));\n                     let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                     write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n@@ -2770,7 +2803,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n-        if !is_static || render_static {\n+        if render_method_item || render_mode == RenderMode::Normal {\n             if !is_default_item {\n                 if let Some(t) = trait_ {\n                     // The trait item may have been stripped so we might not\n@@ -2803,15 +2836,15 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     write!(w, \"<div class='impl-items'>\")?;\n     for trait_item in &i.inner_impl().items {\n-        doc_impl_item(w, cx, trait_item, link, render_header,\n+        doc_impl_item(w, cx, trait_item, link, render_mode,\n                       false, outer_version, trait_)?;\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n                             cx: &Context,\n                             t: &clean::Trait,\n                             i: &clean::Impl,\n-                            render_static: bool,\n+                            render_mode: RenderMode,\n                             outer_version: Option<&str>) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n@@ -2821,7 +2854,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             let did = i.trait_.as_ref().unwrap().def_id().unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n-            doc_impl_item(w, cx, trait_item, assoc_link, render_static, true,\n+            doc_impl_item(w, cx, trait_item, assoc_link, render_mode, true,\n                           outer_version, None)?;\n         }\n         Ok(())\n@@ -2830,7 +2863,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     // If we've implemented a trait, then also emit documentation for all\n     // default items which weren't overridden in the implementation block.\n     if let Some(t) = trait_ {\n-        render_default_items(w, cx, t, &i.inner_impl(), render_header, outer_version)?;\n+        render_default_items(w, cx, t, &i.inner_impl(), render_mode, outer_version)?;\n     }\n     write!(w, \"</div>\")?;\n     Ok(())"}, {"sha": "73278ad9fac4e6d0dcb7e8cc2073a9aabb79a80a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "patch": "@@ -110,6 +110,7 @@ pub fn run(input: &str,\n         external_traits: RefCell::new(FnvHashMap()),\n         populated_crate_impls: RefCell::new(FnvHashSet()),\n         deref_trait_did: Cell::new(None),\n+        deref_mut_trait_did: Cell::new(None),\n         access_levels: Default::default(),\n         renderinfo: Default::default(),\n     };"}, {"sha": "d738fb2925964cc539726df6aaf409347119b5e1", "filename": "src/test/rustdoc/issue-35169-2.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Ftest%2Frustdoc%2Fissue-35169-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Ftest%2Frustdoc%2Fissue-35169-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-35169-2.rs?ref=915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+use std::ops::DerefMut;\n+\n+pub struct Foo;\n+pub struct Bar;\n+\n+impl Foo {\n+    pub fn by_ref(&self) {}\n+    pub fn by_explicit_ref(self: &Foo) {}\n+    pub fn by_mut_ref(&mut self) {}\n+    pub fn by_explicit_mut_ref(self: &mut Foo) {}\n+    pub fn static_foo() {}\n+}\n+\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Foo { loop {} }\n+}\n+\n+impl DerefMut for Bar {\n+    fn deref_mut(&mut self) -> &mut Foo { loop {} }\n+}\n+\n+// @has issue_35169_2/Bar.t.html\n+// @has issue_35169_2/struct.Bar.html\n+// @has - '//*[@id=\"by_ref.v\"]' 'fn by_ref(&self)'\n+// @has - '//*[@id=\"method.by_ref\"]' 'fn by_ref(&self)'\n+// @has - '//*[@id=\"by_explicit_ref.v\"]' 'fn by_explicit_ref(self: &Foo)'\n+// @has - '//*[@id=\"method.by_explicit_ref\"]' 'fn by_explicit_ref(self: &Foo)'\n+// @has - '//*[@id=\"by_mut_ref.v\"]' 'fn by_mut_ref(&mut self)'\n+// @has - '//*[@id=\"method.by_mut_ref\"]' 'fn by_mut_ref(&mut self)'\n+// @has - '//*[@id=\"by_explicit_mut_ref.v\"]' 'fn by_explicit_mut_ref(self: &mut Foo)'\n+// @has - '//*[@id=\"method.by_explicit_mut_ref\"]' 'fn by_explicit_mut_ref(self: &mut Foo)'\n+// @!has - '//*[@id=\"static_foo.v\"]' 'fn static_foo()'\n+// @!has - '//*[@id=\"method.static_foo\"]' 'fn static_foo()'"}, {"sha": "8764e4a390f763616e3c7cff2fdd9be037685901", "filename": "src/test/rustdoc/issue-35169.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Ftest%2Frustdoc%2Fissue-35169.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915bbdac580b26e2d47baa1ca3fd21349c4f4b0b/src%2Ftest%2Frustdoc%2Fissue-35169.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-35169.rs?ref=915bbdac580b26e2d47baa1ca3fd21349c4f4b0b", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Foo;\n+pub struct Bar;\n+\n+impl Foo {\n+    pub fn by_ref(&self) {}\n+    pub fn by_explicit_ref(self: &Foo) {}\n+    pub fn by_mut_ref(&mut self) {}\n+    pub fn by_explicit_mut_ref(self: &mut Foo) {}\n+    pub fn static_foo() {}\n+}\n+\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Foo { loop {} }\n+}\n+\n+// @has issue_35169/Bar.t.html\n+// @has issue_35169/struct.Bar.html\n+// @has - '//*[@id=\"by_ref.v\"]' 'fn by_ref(&self)'\n+// @has - '//*[@id=\"method.by_ref\"]' 'fn by_ref(&self)'\n+// @has - '//*[@id=\"by_explicit_ref.v\"]' 'fn by_explicit_ref(self: &Foo)'\n+// @has - '//*[@id=\"method.by_explicit_ref\"]' 'fn by_explicit_ref(self: &Foo)'\n+// @!has - '//*[@id=\"by_mut_ref.v\"]' 'fn by_mut_ref(&mut self)'\n+// @!has - '//*[@id=\"method.by_mut_ref\"]' 'fn by_mut_ref(&mut self)'\n+// @!has - '//*[@id=\"by_explicit_mut_ref.v\"]' 'fn by_explicit_mut_ref(self: &mut Foo)'\n+// @!has - '//*[@id=\"method.by_explicit_mut_ref\"]' 'fn by_explicit_mut_ref(self: &mut Foo)'\n+// @!has - '//*[@id=\"static_foo.v\"]' 'fn static_foo()'\n+// @!has - '//*[@id=\"method.static_foo\"]' 'fn static_foo()'"}]}