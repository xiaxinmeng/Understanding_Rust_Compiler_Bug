{"sha": "bb09ae28c03d7357f22dd1683e9c78393b5c1e43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMDlhZTI4YzAzZDczNTdmMjJkZDE2ODNlOWM3ODM5M2I1YzFlNDM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-12T08:17:56Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-26T18:23:45Z"}, "message": "Refactor away `resolve_name_in_lexical_scope` and `resolve_identifier_in_local_ribs`.", "tree": {"sha": "04f627d1b4d43ffee60ecdb3631c230f7aa66e71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04f627d1b4d43ffee60ecdb3631c230f7aa66e71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb09ae28c03d7357f22dd1683e9c78393b5c1e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb09ae28c03d7357f22dd1683e9c78393b5c1e43", "html_url": "https://github.com/rust-lang/rust/commit/bb09ae28c03d7357f22dd1683e9c78393b5c1e43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb09ae28c03d7357f22dd1683e9c78393b5c1e43/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73417853e40646406a82ea39e606fb6199fa6b5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/73417853e40646406a82ea39e606fb6199fa6b5d", "html_url": "https://github.com/rust-lang/rust/commit/73417853e40646406a82ea39e606fb6199fa6b5d"}], "stats": {"total": 123, "additions": 42, "deletions": 81}, "files": [{"sha": "a1b21da7cfc92f8fba5f11fb9a2504ae125e3f7a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 42, "deletions": 81, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/bb09ae28c03d7357f22dd1683e9c78393b5c1e43/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb09ae28c03d7357f22dd1683e9c78393b5c1e43/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bb09ae28c03d7357f22dd1683e9c78393b5c1e43", "patch": "@@ -789,6 +789,26 @@ enum LexicalScopeBinding<'a> {\n     LocalDef(LocalDef),\n }\n \n+impl<'a> LexicalScopeBinding<'a> {\n+    fn local_def(self) -> LocalDef {\n+        match self {\n+            LexicalScopeBinding::LocalDef(local_def) => local_def,\n+            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def().unwrap()),\n+        }\n+    }\n+\n+    fn def(self) -> Def {\n+        self.local_def().def\n+    }\n+\n+    fn module(self) -> Option<Module<'a>> {\n+        match self {\n+            LexicalScopeBinding::Item(binding) => binding.module(),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n enum ParentLink<'a> {\n@@ -1404,20 +1424,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_item_in_lexical_scope(module_path[0],\n-                                                                 TypeNS,\n-                                                                 true) {\n-                            Failed(err) => return Failed(err),\n-                            Indeterminate => {\n-                                debug!(\"(resolving module path for import) indeterminate; bailing\");\n-                                return Indeterminate;\n-                            }\n-                            Success(binding) => match binding.module() {\n-                                Some(containing_module) => {\n-                                    search_module = containing_module;\n-                                    start_index = 1;\n-                                }\n-                                None => return Failed(None),\n+                        let ident = hir::Ident::from_name(module_path[0]);\n+                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, true)\n+                                  .and_then(LexicalScopeBinding::module) {\n+                            None => return Failed(None),\n+                            Some(containing_module) => {\n+                                search_module = containing_module;\n+                                start_index = 1;\n                             }\n                         }\n                     }\n@@ -1485,18 +1498,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_item_in_lexical_scope(&mut self,\n-                                     name: Name,\n-                                     namespace: Namespace,\n-                                     record_used: bool)\n-                                     -> ResolveResult<&'a NameBinding<'a>> {\n-        let ident = hir::Ident::from_name(name);\n-        match self.resolve_ident_in_lexical_scope(ident, namespace, record_used) {\n-            Some(LexicalScopeBinding::Item(binding)) => Success(binding),\n-            _ => Failed(None),\n-        }\n-    }\n-\n     /// Returns the nearest normal module parent of the given module.\n     fn get_nearest_normal_module_parent(&mut self, module_: Module<'a>) -> Option<Module<'a>> {\n         let mut module_ = module_;\n@@ -2288,8 +2289,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let ident = path1.node;\n                     let renamed = ident.name;\n \n-                    match self.resolve_bare_identifier_pattern(ident.unhygienic_name,\n-                                                               pattern.span) {\n+                    match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n                         FoundStructOrEnumVariant(def) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n                                    renamed);\n@@ -2540,49 +2540,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         });\n     }\n \n-    fn resolve_bare_identifier_pattern(&mut self,\n-                                       name: Name,\n-                                       span: Span)\n+    fn resolve_bare_identifier_pattern(&mut self, ident: hir::Ident, span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        match self.resolve_item_in_lexical_scope(name, ValueNS, true) {\n-            Success(binding) => {\n-                debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n-                       name,\n-                       binding);\n-                match binding.def() {\n-                    None => {\n-                        panic!(\"resolved name in the value namespace to a set of name bindings \\\n-                                with no def?!\");\n-                    }\n-                    // For the two success cases, this lookup can be\n-                    // considered as not having a private component because\n-                    // the lookup happened only within the current module.\n-                    Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n-                        return FoundStructOrEnumVariant(def);\n-                    }\n-                    Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n-                        return FoundConst(def, name);\n-                    }\n-                    Some(Def::Static(..)) => {\n-                        resolve_error(self, span, ResolutionError::StaticVariableReference);\n-                        return BareIdentifierPatternUnresolved;\n-                    }\n-                    _ => return BareIdentifierPatternUnresolved\n-                }\n+        match self.resolve_ident_in_lexical_scope(ident, ValueNS, true)\n+                  .map(LexicalScopeBinding::def) {\n+            Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n+                FoundStructOrEnumVariant(def)\n             }\n-\n-            Indeterminate => return BareIdentifierPatternUnresolved,\n-            Failed(err) => {\n-                match err {\n-                    Some((span, msg)) => {\n-                        resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                    }\n-                    None => (),\n-                }\n-\n-                debug!(\"(resolve bare identifier pattern) failed to find {}\", name);\n-                return BareIdentifierPatternUnresolved;\n+            Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n+                FoundConst(def, ident.unhygienic_name)\n             }\n+            Some(Def::Static(..)) => {\n+                resolve_error(self, span, ResolutionError::StaticVariableReference);\n+                BareIdentifierPatternUnresolved\n+            }\n+            _ => BareIdentifierPatternUnresolved,\n         }\n     }\n \n@@ -2703,7 +2675,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n-        self.resolve_identifier_in_local_ribs(identifier, namespace, record_used)\n+        self.resolve_ident_in_lexical_scope(identifier, namespace, record_used)\n+            .map(LexicalScopeBinding::local_def)\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -2887,18 +2860,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         })\n     }\n \n-    fn resolve_identifier_in_local_ribs(&mut self,\n-                                        ident: hir::Ident,\n-                                        namespace: Namespace,\n-                                        record_used: bool)\n-                                        -> Option<LocalDef> {\n-        Some(match self.resolve_ident_in_lexical_scope(ident, namespace, record_used) {\n-            Some(LexicalScopeBinding::LocalDef(local_def)) => local_def,\n-            Some(LexicalScopeBinding::Item(binding)) => LocalDef::from_def(binding.def().unwrap()),\n-            None => return None,\n-        })\n-    }\n-\n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver) -> T\n     {"}]}