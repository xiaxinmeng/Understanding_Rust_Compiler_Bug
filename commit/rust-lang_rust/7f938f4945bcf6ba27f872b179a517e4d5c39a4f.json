{"sha": "7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOTM4ZjQ5NDViY2Y2YmEyN2Y4NzJiMTc5YTUxN2U0ZDVjMzlhNGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-20T00:21:21Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-20T00:21:36Z"}, "message": "Move the ty_item_table into ty::ctxt.items, move variant_info to ty, and start sketching the contains_pointer property on types.", "tree": {"sha": "e6633d8c144f43f1d3dd4a5b2a2c17024f46ae0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6633d8c144f43f1d3dd4a5b2a2c17024f46ae0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "html_url": "https://github.com/rust-lang/rust/commit/7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d67ee0e88540871af028707163cf8b087837f25", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d67ee0e88540871af028707163cf8b087837f25", "html_url": "https://github.com/rust-lang/rust/commit/1d67ee0e88540871af028707163cf8b087837f25"}], "stats": {"total": 578, "additions": 296, "deletions": 282}, "files": [{"sha": "068c548798f15d507234090d7928bff982521401", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "patch": "@@ -512,10 +512,9 @@ fn lookup_def(int cnum, vec[u8] data, &ast::def_id did) -> ast::def {\n     ret def;\n }\n \n-fn get_type(session::session sess, ty::ctxt tcx, ast::def_id def)\n-        -> ty::ty_param_count_and_ty {\n+fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n     auto external_crate_id = def._0;\n-    auto data = sess.get_external_crate(external_crate_id).data;\n+    auto data = tcx.sess.get_external_crate(external_crate_id).data;\n     auto item = lookup_item(def._1, data);\n     auto t = item_type(item, external_crate_id, tcx);\n \n@@ -537,14 +536,14 @@ fn get_symbol(session::session sess, ast::def_id def) -> str {\n     ret item_symbol(lookup_item(def._1, data));\n }\n \n-fn get_tag_variants(session::session sess, ty::ctxt tcx, ast::def_id def)\n-        -> vec[trans::variant_info] {\n+fn get_tag_variants(ty::ctxt tcx, ast::def_id def)\n+    -> vec[ty::variant_info] {\n     auto external_crate_id = def._0;\n-    auto data = sess.get_external_crate(external_crate_id).data;\n+    auto data = tcx.sess.get_external_crate(external_crate_id).data;\n     auto items = ebml::get_doc(ebml::new_doc(data), metadata::tag_items);\n     auto item = find_item(def._1, items);\n \n-    let vec[trans::variant_info] infos = [];\n+    let vec[ty::variant_info] infos = [];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n         auto item = find_item(did._1, items);"}, {"sha": "06285de81214c70a433b61b2ad83b640f9fa703c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 20, "deletions": 97, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "patch": "@@ -1272,8 +1272,8 @@ fn static_size_of_tag(&@crate_ctxt cx, &ast::span sp, &ty::t t) -> uint {\n \n     // Compute max(variant sizes).\n     auto max_size = 0u;\n-    auto variants = tag_variants(cx, tid);\n-    for (variant_info variant in variants) {\n+    auto variants = ty::tag_variants(cx.tcx, tid);\n+    for (ty::variant_info variant in variants) {\n         auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, variant.args));\n \n         // Perform any type parameter substitutions.\n@@ -1345,8 +1345,8 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n             let ValueRef max_size = alloca(bcx, T_int());\n             bcx.build.Store(C_int(0), max_size);\n \n-            auto variants = tag_variants(bcx.fcx.lcx.ccx, tid);\n-            for (variant_info variant in variants) {\n+            auto variants = ty::tag_variants(bcx.fcx.lcx.ccx.tcx, tid);\n+            for (ty::variant_info variant in variants) {\n                 // Perform type substitution on the raw argument types.\n                 let vec[ty::t] raw_tys = variant.args;\n                 let vec[ty::t] tys = [];\n@@ -1521,7 +1521,8 @@ fn GEP_tag(@block_ctxt cx,\n            &vec[ty::t] ty_substs,\n            int ix)\n         -> result {\n-    auto variant = tag_variant_with_id(cx.fcx.lcx.ccx, tag_id, variant_id);\n+    auto variant = ty::tag_variant_with_id(cx.fcx.lcx.ccx.tcx,\n+                                           tag_id, variant_id);\n \n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n@@ -2213,14 +2214,10 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n         }\n \n         case (_) {\n-            if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n+            if (ty::type_contains_pointers(cx.fcx.lcx.ccx.tcx, t) &&\n+                ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n                 rslt = iter_structural_ty(cx, v0, t,\n                                           bind drop_ty(_, _, _));\n-\n-            } else if (ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n-                       ty::type_is_native(cx.fcx.lcx.ccx.tcx, t) ||\n-                       ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n-                rslt = res(cx, C_nil());\n             } else {\n                 rslt = res(cx, C_nil());\n             }\n@@ -2543,58 +2540,6 @@ fn make_integral_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n     r.bcx.build.RetVoid();\n }\n \n-\n-// Tag information\n-\n-type variant_info = rec(vec[ty::t] args, ty::t ctor_ty, ast::def_id id);\n-\n-// Returns information about the variants in a tag.\n-fn tag_variants(&@crate_ctxt cx, &ast::def_id id) -> vec[variant_info] {\n-    if (cx.sess.get_targ_crate_num() != id._0) {\n-        ret creader::get_tag_variants(cx.sess, cx.tcx, id);\n-    }\n-\n-    assert (cx.items.contains_key(id));\n-    alt (cx.items.get(id).node) {\n-        case (ast::item_tag(_, ?variants, _, _, _)) {\n-            let vec[variant_info] result = [];\n-            for (ast::variant variant in variants) {\n-                auto ctor_ty = node_ann_type(cx, variant.node.ann);\n-                let vec[ty::t] arg_tys = [];\n-                if (vec::len[ast::variant_arg](variant.node.args) > 0u) {\n-                    for (ty::arg a in ty::ty_fn_args(cx.tcx, ctor_ty)) {\n-                        arg_tys += [a.ty];\n-                    }\n-                }\n-                auto did = variant.node.id;\n-                result += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n-            }\n-            ret result;\n-        }\n-    }\n-    fail;   // not reached\n-}\n-\n-// Returns information about the tag variant with the given ID:\n-fn tag_variant_with_id(&@crate_ctxt cx,\n-                       &ast::def_id tag_id,\n-                       &ast::def_id variant_id) -> variant_info {\n-    auto variants = tag_variants(cx, tag_id);\n-\n-    auto i = 0u;\n-    while (i < vec::len[variant_info](variants)) {\n-        auto variant = variants.(i);\n-        if (common::def_eq(variant.id, variant_id)) {\n-            ret variant;\n-        }\n-        i += 1u;\n-    }\n-\n-    log_err \"tag_variant_with_id(): no variant exists with that ID\";\n-    fail;\n-}\n-\n-\n type val_pair_fn = fn(&@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n type val_and_ty_fn = fn(&@block_ctxt cx, ValueRef v, ty::t t) -> result;\n@@ -2677,8 +2622,8 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n             }\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n-            auto variants = tag_variants(cx.fcx.lcx.ccx, tid);\n-            auto n_variants = vec::len[variant_info](variants);\n+            auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, tid);\n+            auto n_variants = vec::len[ty::variant_info](variants);\n \n             // Cast the tags to types we can GEP into.\n             auto lltagty = T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn);\n@@ -2712,7 +2657,7 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n             auto next_cx = new_sub_block_ctxt(bcx, \"tag-iter-next\");\n \n             auto i = 0u;\n-            for (variant_info variant in variants) {\n+            for (ty::variant_info variant in variants) {\n                 auto variant_cx = new_sub_block_ctxt(bcx,\n                                                      \"tag-iter-variant-\" +\n                                                      uint::to_str(i, 10u));\n@@ -3167,7 +3112,7 @@ fn drop_ty(&@block_ctxt cx,\n            ValueRef v,\n            ty::t t) -> result {\n \n-    if (!ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n+    if (ty::type_contains_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, false, abi::tydesc_field_drop_glue);\n     }\n     ret res(cx, C_nil());\n@@ -3177,7 +3122,7 @@ fn free_ty(&@block_ctxt cx,\n            ValueRef v,\n            ty::t t) -> result {\n \n-    if (!ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n+    if (ty::type_contains_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, false, abi::tydesc_field_free_glue);\n     }\n     ret res(cx, C_nil());\n@@ -3335,27 +3280,9 @@ fn trans_lit(&@crate_ctxt cx, &ast::lit lit, &ast::ann ann) -> ValueRef {\n     }\n }\n \n-fn target_type(&@crate_ctxt cx, &ty::t t) -> ty::t {\n-    alt (ty::struct(cx.tcx, t)) {\n-        case (ty::ty_int) {\n-            auto struct_ty = ty::mk_mach(cx.tcx,\n-                                        cx.sess.get_targ_cfg().int_type);\n-            ret ty::copy_cname(cx.tcx, struct_ty, t);\n-        }\n-        case (ty::ty_uint) {\n-            auto struct_ty = ty::mk_mach(cx.tcx,\n-                                        cx.sess.get_targ_cfg().uint_type);\n-            ret ty::copy_cname(cx.tcx, struct_ty, t);\n-        }\n-        case (_) { /* fall through */ }\n-    }\n-    ret t;\n-}\n-\n-\n // Converts an annotation to a type\n fn node_ann_type(&@crate_ctxt cx, &ast::ann a) -> ty::t {\n-    ret target_type(cx, ty::ann_to_monotype(cx.tcx, a));\n+    ret ty::ann_to_monotype(cx.tcx, a);\n }\n \n fn node_type(&@crate_ctxt cx, &ast::span sp, &ast::ann a) -> TypeRef {\n@@ -4197,9 +4124,9 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                 (cx.fcx.lcx.ccx.tcx.def_map.get(ann.id));\n             auto variant_tag = 0;\n \n-            auto variants = tag_variants(cx.fcx.lcx.ccx, vdef._0);\n+            auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0);\n             auto i = 0;\n-            for (variant_info v in variants) {\n+            for (ty::variant_info v in variants) {\n                 auto this_variant_id = v.id;\n                 if (vdef._1._0 == this_variant_id._0 &&\n                     vdef._1._1 == this_variant_id._1) {\n@@ -4467,18 +4394,15 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n             ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n         }\n         case (ast::def_fn(?did)) {\n-            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                            cx.fcx.lcx.ccx.tcx, did);\n+            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (ast::def_obj(?did)) {\n-            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                           cx.fcx.lcx.ccx.tcx, did);\n+            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (ast::def_variant(?tid, ?vid)) {\n-            auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                             cx.fcx.lcx.ccx.tcx, vid);\n+            auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, vid);\n             alt (ty::struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n                 case (ty::ty_fn(_, _, _)) {\n                     // N-ary variant.\n@@ -4519,8 +4443,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n             ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n         }\n         case (ast::def_native_fn(?did)) {\n-            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                                           cx.fcx.lcx.ccx.tcx, did);\n+            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (_) {"}, {"sha": "523b91449d7e7214d330c8d7191a191b76cb53ce", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 188, "deletions": 78, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "patch": "@@ -51,6 +51,13 @@ type method = rec(ast::proto proto,\n                   vec[arg] inputs,\n                   t output);\n \n+tag any_item {\n+    any_item_rust(@ast::item);\n+    any_item_native(@ast::native_item, ast::native_abi);\n+}\n+\n+type item_table = hashmap[ast::def_id,any_item];\n+\n type mt = rec(t ty, ast::mutability mut);\n \n // Contains information needed to resolve types and (in the future) look up\n@@ -60,6 +67,7 @@ type ctxt = rec(@type_store ts,\n                 session::session sess,\n                 resolve::def_map def_map,\n                 node_type_table node_types,\n+                item_table items,\n                 type_cache tcache,\n                 creader_cache rcache,\n                 hashmap[t,str] short_names_cache);\n@@ -81,7 +89,8 @@ type raw_t = rec(sty struct,\n                  bool has_params,\n                  bool has_bound_params,\n                  bool has_vars,\n-                 bool has_locals);\n+                 bool has_locals,\n+                 bool has_pointers);\n \n type t = uint;\n \n@@ -172,34 +181,31 @@ type ty_param_substs_opt_and_ty = tup(option::t[vec[ty::t]], ty::t);\n type node_type_table =\n     @mutable vec[mutable option::t[ty::ty_param_substs_opt_and_ty]];\n \n-fn mk_type_store() -> @type_store {\n-    auto ts = @interner::mk_interner[raw_t](hash_raw_ty, eq_raw_ty);\n-\n-    intern(ts, ty_nil, none[str]);\n-    intern(ts, ty_bool, none[str]);\n-    intern(ts, ty_int, none[str]);\n-    intern(ts, ty_float, none[str]);\n-    intern(ts, ty_uint, none[str]);\n-    intern(ts, ty_machine(ty_i8), none[str]);\n-    intern(ts, ty_machine(ty_i16), none[str]);\n-    intern(ts, ty_machine(ty_i32), none[str]);\n-    intern(ts, ty_machine(ty_i64), none[str]);\n-    intern(ts, ty_machine(ty_u8), none[str]);\n-    intern(ts, ty_machine(ty_u16), none[str]);\n-    intern(ts, ty_machine(ty_u32), none[str]);\n-    intern(ts, ty_machine(ty_u64), none[str]);\n-    intern(ts, ty_machine(ty_f32), none[str]);\n-    intern(ts, ty_machine(ty_f64), none[str]);\n-    intern(ts, ty_char, none[str]);\n-    intern(ts, ty_str, none[str]);\n-    intern(ts, ty_task, none[str]);\n-    intern(ts, ty_native, none[str]);\n-    intern(ts, ty_type, none[str]);\n-    intern(ts, ty_bot, none[str]);\n-\n-    assert vec::len(ts.vect) == idx_first_others;\n-\n-    ret ts;\n+fn populate_type_store(&ctxt cx) {\n+\n+    intern(cx, ty_nil, none[str]);\n+    intern(cx, ty_bool, none[str]);\n+    intern(cx, ty_int, none[str]);\n+    intern(cx, ty_float, none[str]);\n+    intern(cx, ty_uint, none[str]);\n+    intern(cx, ty_machine(ty_i8), none[str]);\n+    intern(cx, ty_machine(ty_i16), none[str]);\n+    intern(cx, ty_machine(ty_i32), none[str]);\n+    intern(cx, ty_machine(ty_i64), none[str]);\n+    intern(cx, ty_machine(ty_u8), none[str]);\n+    intern(cx, ty_machine(ty_u16), none[str]);\n+    intern(cx, ty_machine(ty_u32), none[str]);\n+    intern(cx, ty_machine(ty_u64), none[str]);\n+    intern(cx, ty_machine(ty_f32), none[str]);\n+    intern(cx, ty_machine(ty_f64), none[str]);\n+    intern(cx, ty_char, none[str]);\n+    intern(cx, ty_str, none[str]);\n+    intern(cx, ty_task, none[str]);\n+    intern(cx, ty_native, none[str]);\n+    intern(cx, ty_type, none[str]);\n+    intern(cx, ty_bot, none[str]);\n+\n+    assert vec::len(cx.ts.vect) == idx_first_others;\n }\n \n fn mk_rcache() -> creader_cache {\n@@ -226,135 +232,162 @@ fn mk_ctxt(session::session s, resolve::def_map dm) -> ctxt {\n     auto tcache =\n         common::new_def_hash[ty::ty_param_count_and_ty]();\n \n-    ret rec(ts = mk_type_store(),\n+    auto items = common::new_def_hash[any_item]();\n+    auto ts = @interner::mk_interner[raw_t](hash_raw_ty, eq_raw_ty);\n+\n+    auto cx =\n+        rec(ts = ts,\n             sess = s,\n             def_map = dm,\n             node_types = ntt,\n+            items = items,\n             tcache = tcache,\n             rcache = mk_rcache(),\n             short_names_cache =\n-                map::mk_hashmap[ty::t,str](ty::hash_ty, ty::eq_ty));\n+            map::mk_hashmap[ty::t,str](ty::hash_ty, ty::eq_ty));\n+\n+    populate_type_store(cx);\n+    ret cx;\n }\n \n \n // Type constructors\n \n-fn mk_raw_ty(&@type_store ts, &sty st, &option::t[str] cname) -> raw_t {\n+fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n     auto h = hash_type_info(st, cname);\n \n     let bool has_params = false;\n     let bool has_bound_params = false;\n     let bool has_vars = false;\n     let bool has_locals = false;\n+    let bool has_pointers = false;\n \n-    fn derive_flags_t(@type_store ts,\n+    fn derive_flags_t(&ctxt cx,\n                       &mutable bool has_params,\n                       &mutable bool has_bound_params,\n                       &mutable bool has_vars,\n                       &mutable bool has_locals,\n+                      &mutable bool has_pointers,\n                       &t tt) {\n-        auto rt = interner::get[raw_t](*ts, tt);\n+        auto rt = interner::get[raw_t](*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n         has_bound_params = has_bound_params || rt.has_bound_params;\n         has_vars = has_vars || rt.has_vars;\n         has_locals = has_locals || rt.has_locals;\n+        has_pointers = has_pointers || rt.has_pointers;\n     }\n \n-    fn derive_flags_mt(@type_store ts,\n+    fn derive_flags_mt(&ctxt cx,\n                        &mutable bool has_params,\n                        &mutable bool has_bound_params,\n                        &mutable bool has_vars,\n                        &mutable bool has_locals,\n+                       &mutable bool has_pointers,\n                        &mt m) {\n-        derive_flags_t(ts, has_params, has_bound_params,\n-                       has_vars, has_locals, m.ty);\n+        derive_flags_t(cx, has_params, has_bound_params,\n+                       has_vars, has_locals, has_pointers, m.ty);\n     }\n \n \n-    fn derive_flags_arg(@type_store ts,\n+    fn derive_flags_arg(&ctxt cx,\n                         &mutable bool has_params,\n                         &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n                         &mutable bool has_locals,\n+                        &mutable bool has_pointers,\n                         &arg a) {\n-        derive_flags_t(ts, has_params, has_bound_params,\n-                       has_vars, has_locals, a.ty);\n+        derive_flags_t(cx, has_params, has_bound_params,\n+                       has_vars, has_locals, has_pointers, a.ty);\n     }\n \n-    fn derive_flags_sig(@type_store ts,\n+    fn derive_flags_sig(&ctxt cx,\n                         &mutable bool has_params,\n                         &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n                         &mutable bool has_locals,\n+                        &mutable bool has_pointers,\n                         &vec[arg] args,\n                         &t tt) {\n         for (arg a in args) {\n-            derive_flags_arg(ts, has_params, has_bound_params,\n-                             has_vars, has_locals, a);\n+            derive_flags_arg(cx, has_params, has_bound_params,\n+                             has_vars, has_locals, has_pointers, a);\n         }\n-        derive_flags_t(ts, has_params, has_bound_params,\n-                       has_vars, has_locals, tt);\n+        derive_flags_t(cx, has_params, has_bound_params,\n+                       has_vars, has_locals, has_pointers, tt);\n     }\n \n     alt (st) {\n-        case (ty_param(_)) { has_params = true; }\n-        case (ty_bound_param(_)) { has_bound_params = true; }\n+        case (ty_param(_)) {\n+            has_params = true;\n+            has_pointers = true;\n+        }\n+        case (ty_bound_param(_)) {\n+            has_bound_params = true;\n+            has_pointers = true;\n+        }\n         case (ty_var(_)) { has_vars = true; }\n         case (ty_local(_)) { has_locals = true; }\n-        case (ty_tag(_, ?tys)) {\n+        case (ty_tag(?did, ?tys)) {\n             for (t tt in tys) {\n-                derive_flags_t(ts, has_params, has_bound_params,\n-                               has_vars, has_locals, tt);\n+                derive_flags_t(cx, has_params, has_bound_params,\n+                               has_vars, has_locals, has_pointers, tt);\n             }\n         }\n         case (ty_box(?m)) {\n-            derive_flags_mt(ts, has_params, has_bound_params,\n-                            has_vars, has_locals, m);\n+            has_pointers = true;\n+            derive_flags_mt(cx, has_params, has_bound_params,\n+                            has_vars, has_locals, has_pointers, m);\n         }\n \n         case (ty_vec(?m)) {\n-            derive_flags_mt(ts, has_params, has_bound_params,\n-                            has_vars, has_locals, m);\n+            has_pointers = true;\n+            derive_flags_mt(cx, has_params, has_bound_params,\n+                            has_vars, has_locals, has_pointers, m);\n         }\n \n         case (ty_port(?tt)) {\n-            derive_flags_t(ts, has_params, has_bound_params,\n-                           has_vars, has_locals, tt);\n+            has_pointers = true;\n+            derive_flags_t(cx, has_params, has_bound_params,\n+                           has_vars, has_locals, has_pointers, tt);\n         }\n \n         case (ty_chan(?tt)) {\n-            derive_flags_t(ts, has_params, has_bound_params,\n-                           has_vars, has_locals, tt);\n+            has_pointers = true;\n+            derive_flags_t(cx, has_params, has_bound_params,\n+                           has_vars, has_locals, has_pointers, tt);\n         }\n \n         case (ty_tup(?mts)) {\n             for (mt m in mts) {\n-                derive_flags_mt(ts, has_params, has_bound_params,\n-                                has_vars, has_locals, m);\n+                derive_flags_mt(cx, has_params, has_bound_params,\n+                                has_vars, has_locals, has_pointers, m);\n             }\n         }\n \n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n-                derive_flags_mt(ts, has_params, has_bound_params,\n-                                has_vars, has_locals, f.mt);\n+                derive_flags_mt(cx, has_params, has_bound_params,\n+                                has_vars, has_locals, has_pointers, f.mt);\n             }\n         }\n \n         case (ty_fn(_, ?args, ?tt)) {\n-            derive_flags_sig(ts, has_params, has_bound_params,\n-                             has_vars, has_locals, args, tt);\n+            has_pointers = true;\n+            derive_flags_sig(cx, has_params, has_bound_params,\n+                             has_vars, has_locals, has_pointers, args, tt);\n         }\n \n         case (ty_native_fn(_, ?args, ?tt)) {\n-            derive_flags_sig(ts, has_params, has_bound_params,\n-                             has_vars, has_locals, args, tt);\n+            has_pointers = true;\n+            derive_flags_sig(cx, has_params, has_bound_params,\n+                             has_vars, has_locals, has_pointers, args, tt);\n         }\n \n         case (ty_obj(?meths)) {\n+            has_pointers = true;\n             for (method m in meths) {\n-                derive_flags_sig(ts, has_params, has_bound_params,\n-                                 has_vars, has_locals,\n+                derive_flags_sig(cx, has_params, has_bound_params,\n+                                 has_vars, has_locals, has_pointers,\n                                  m.inputs, m.output);\n             }\n         }\n@@ -365,16 +398,26 @@ fn mk_raw_ty(&@type_store ts, &sty st, &option::t[str] cname) -> raw_t {\n             has_params = has_params,\n             has_bound_params = has_bound_params,\n             has_vars = has_vars,\n-            has_locals = has_locals);\n+            has_locals = has_locals,\n+            has_pointers = has_pointers);\n }\n \n-fn intern(&@type_store ts, &sty st, &option::t[str] cname) {\n-    interner::intern[raw_t](*ts, mk_raw_ty(ts, st, cname));\n+fn intern(&ctxt cx, &sty st, &option::t[str] cname) {\n+    interner::intern[raw_t](*cx.ts, mk_raw_ty(cx, st, cname));\n }\n \n fn gen_ty_full(&ctxt cx, &sty st, &option::t[str] cname) -> t {\n-    auto raw_type = mk_raw_ty(cx.ts, st, cname);\n-    ret interner::intern[raw_t](*cx.ts, raw_type);\n+    auto raw_type = mk_raw_ty(cx, st, cname);\n+    auto t = interner::intern[raw_t](*cx.ts, raw_type);\n+\n+    /*\n+    if (raw_type.has_pointers) {\n+        log_err \"type has pointers: \" + ty_to_str(cx, t);\n+    } else {\n+        log_err \"type has no pointers: \" + ty_to_str(cx, t);\n+    }\n+    */\n+    ret t;\n }\n \n // These are private constructors to this module. External users should always\n@@ -954,6 +997,7 @@ fn type_is_scalar(&ctxt cx, &t ty) -> bool {\n     fail;\n }\n \n+\n // FIXME: should we just return true for native types in\n // type_is_scalar?\n fn type_is_native(&ctxt cx, &t ty) -> bool {\n@@ -1572,6 +1616,15 @@ fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n     ret interner::get[raw_t](*cx.ts, typ).has_bound_params;\n }\n \n+fn type_contains_pointers(&ctxt cx, &t typ) -> bool {\n+    // FIXME: this is currently incorrect, pending an improved\n+    // version of the \"contains pointers\" derived property.\n+    //\n+    // ret interner::get[raw_t](*cx.ts, typ).has_pointers;\n+\n+    ret (!type_is_scalar(cx, typ));\n+}\n+\n // Type accessors for substructures of types\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n@@ -2774,11 +2827,68 @@ fn def_has_ty_params(&ast::def def) -> bool {\n     }\n }\n \n+\n+// Tag information\n+\n+type variant_info = rec(vec[ty::t] args, ty::t ctor_ty, ast::def_id id);\n+\n+// Returns information about the variants in a tag.\n+fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n+    if (cx.sess.get_targ_crate_num() != id._0) {\n+        ret creader::get_tag_variants(cx, id);\n+    }\n+\n+    assert (cx.items.contains_key(id));\n+    alt (cx.items.get(id)) {\n+        case (any_item_rust(?item)) {\n+            alt (item.node) {\n+                case (ast::item_tag(_, ?variants, _, _, _)) {\n+                    let vec[variant_info] result = [];\n+                    for (ast::variant variant in variants) {\n+                        auto ctor_ty = ann_to_monotype(cx, variant.node.ann);\n+                        let vec[t] arg_tys = [];\n+                        if (vec::len[ast::variant_arg](variant.node.args)\n+                            > 0u) {\n+                            for (arg a in ty_fn_args(cx, ctor_ty)) {\n+                                arg_tys += [a.ty];\n+                            }\n+                        }\n+                        auto did = variant.node.id;\n+                        result += [rec(args=arg_tys,\n+                                       ctor_ty=ctor_ty,\n+                                       id=did)];\n+                    }\n+                    ret result;\n+                }\n+            }\n+        }\n+    }\n+    fail;   // not reached\n+}\n+\n+// Returns information about the tag variant with the given ID:\n+fn tag_variant_with_id(&ctxt cx,\n+                       &ast::def_id tag_id,\n+                       &ast::def_id variant_id) -> variant_info {\n+    auto variants = tag_variants(cx, tag_id);\n+\n+    auto i = 0u;\n+    while (i < vec::len[variant_info](variants)) {\n+        auto variant = variants.(i);\n+        if (common::def_eq(variant.id, variant_id)) {\n+            ret variant;\n+        }\n+        i += 1u;\n+    }\n+\n+    log_err \"tag_variant_with_id(): no variant exists with that ID\";\n+    fail;\n+}\n+\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-fn lookup_item_type(session::session sess,\n-                    ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n-    if (did._0 == sess.get_targ_crate_num()) {\n+fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n+    if (did._0 == cx.sess.get_targ_crate_num()) {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n         ret cx.tcache.get(did);\n@@ -2787,7 +2897,7 @@ fn lookup_item_type(session::session sess,\n     alt (cx.tcache.find(did)) {\n         case (some[ty_param_count_and_ty](?tpt)) { ret tpt; }\n         case (none[ty_param_count_and_ty]) {\n-            auto tyt = creader::get_type(sess, cx, did);\n+            auto tyt = creader::get_type(cx, did);\n             cx.tcache.insert(did, tyt);\n             ret tyt;\n         }\n@@ -2799,7 +2909,7 @@ fn ret_ty_of_fn_ty(ty_ctxt tcx, t a_ty) -> t {\n         case (ty::ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n         }\n-        case (_) { \n+        case (_) {\n             fail;\n         }\n     }"}, {"sha": "5427e5f3b0595254f5bbf2cb5401cfd55d78e117", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 82, "deletions": 100, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f938f4945bcf6ba27f872b179a517e4d5c39a4f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7f938f4945bcf6ba27f872b179a517e4d5c39a4f", "patch": "@@ -51,23 +51,14 @@ import std::option::from_maybe;\n import middle::tstate::ann::ts_ann;\n \n type ty_table = hashmap[ast::def_id, ty::t];\n-\n-tag any_item {\n-    any_item_rust(@ast::item);\n-    any_item_native(@ast::native_item, ast::native_abi);\n-}\n-\n-type ty_item_table = hashmap[ast::def_id,any_item];\n type fn_purity_table = hashmap[ast::def_id, ast::purity];\n \n type unify_cache_entry = tup(ty::t,ty::t,vec[mutable ty::t]);\n type unify_cache = hashmap[unify_cache_entry,ty::unify::result];\n \n type obj_info = rec(vec[ast::obj_field] obj_fields, ast::def_id this_obj);\n \n-type crate_ctxt = rec(session::session sess,\n-                      @ty_item_table item_items,\n-                      mutable vec[obj_info] obj_infos,\n+type crate_ctxt = rec(mutable vec[obj_info] obj_infos,\n                       @fn_purity_table fn_purity_table,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n@@ -112,7 +103,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n \n     auto supplied_len = vec::len[ty::t](supplied);\n     if (ty_param_count != supplied_len) {\n-        ccx.sess.span_err(sp, \"expected \" +\n+        ccx.tcx.sess.span_err(sp, \"expected \" +\n                           uint::to_str(ty_param_count, 10u) +\n                           \" type parameter(s) but found \" +\n                           uint::to_str(supplied_len, 10u) + \" parameter(s)\");\n@@ -149,23 +140,23 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast::span sp, &ast::def defn)\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast::def_fn(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n+            ret ty::lookup_item_type(fcx.ccx.tcx, id);\n         }\n         case (ast::def_native_fn(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n+            ret ty::lookup_item_type(fcx.ccx.tcx, id);\n         }\n         case (ast::def_const(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n+            ret ty::lookup_item_type(fcx.ccx.tcx, id);\n         }\n         case (ast::def_variant(_, ?vid)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, vid);\n+            ret ty::lookup_item_type(fcx.ccx.tcx, vid);\n         }\n         case (ast::def_binding(?id)) {\n             // assert (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast::def_obj(?id)) {\n-            ret ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx, id);\n+            ret ty::lookup_item_type(fcx.ccx.tcx, id);\n         }\n \n         case (ast::def_mod(_)) {\n@@ -175,13 +166,13 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast::span sp, &ast::def defn)\n         }\n \n         case (ast::def_ty(_)) {\n-            fcx.ccx.sess.span_err(sp, \"expected value but found type\");\n+            fcx.ccx.tcx.sess.span_err(sp, \"expected value but found type\");\n             fail;\n         }\n \n         case (_) {\n             // FIXME: handle other names.\n-            fcx.ccx.sess.unimpl(\"definition variant\");\n+            fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n             fail;\n         }\n     }\n@@ -209,8 +200,9 @@ fn instantiate_path(&@stmt_ctxt scx,\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n \n         if (ty_param_count == 0u) {\n-            scx.fcx.ccx.sess.span_err(sp, \"this item does not take type \" +\n-                                      \"parameters\");\n+            scx.fcx.ccx.tcx.sess.span_err(sp,\n+                                          \"this item does not take type \" +\n+                                          \"parameters\");\n             fail;\n         }\n     } else {\n@@ -378,7 +370,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n     fn getter(@crate_ctxt ccx, &ast::def_id id) -> ty::ty_param_count_and_ty {\n-        ret ty::lookup_item_type(ccx.sess, ccx.tcx, id);\n+        ret ty::lookup_item_type(ccx.tcx, id);\n     }\n     auto f = bind getter(ccx, _);\n     ret ast_ty_to_ty(ccx.tcx, f, ast_ty);\n@@ -455,10 +447,7 @@ mod write {\n // Could use some cleanup. Consider topologically sorting in phase (1) above.\n \n mod collect {\n-    type ctxt = rec(session::session sess,\n-                    @ty_item_table id_to_ty_item,\n-                    ty::ctxt tcx);\n-    type env = rec(@ctxt cx, ast::native_abi abi);\n+    type ctxt = rec(ty::ctxt tcx);\n \n     fn ty_of_fn_decl(&@ctxt cx,\n                      &fn(&@ast::ty ast_ty) -> ty::t convert,\n@@ -494,16 +483,16 @@ mod collect {\n \n     fn getter(@ctxt cx, &ast::def_id id) -> ty::ty_param_count_and_ty {\n \n-        if (id._0 != cx.sess.get_targ_crate_num()) {\n+        if (id._0 != cx.tcx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n-            ret creader::get_type(cx.sess, cx.tcx, id);\n+            ret creader::get_type(cx.tcx, id);\n         }\n \n-        auto it = cx.id_to_ty_item.get(id);\n+        auto it = cx.tcx.items.get(id);\n         auto tpt;\n         alt (it) {\n-            case (any_item_rust(?item)) { tpt = ty_of_item(cx, item); }\n-            case (any_item_native(?native_item, ?abi)) {\n+            case (ty::any_item_rust(?item)) { tpt = ty_of_item(cx, item); }\n+            case (ty::any_item_native(?native_item, ?abi)) {\n                 tpt = ty_of_native_item(cx, native_item, abi);\n             }\n         }\n@@ -707,27 +696,27 @@ mod collect {\n                                            object.methods);\n     }\n \n-    fn collect(&@ty_item_table id_to_ty_item, &@ast::item i) {\n+    fn collect(ty::item_table id_to_ty_item, &@ast::item i) {\n         alt (i.node) {\n             case (ast::item_ty(_, _, _, ?def_id, _)) {\n-                id_to_ty_item.insert(def_id, any_item_rust(i));\n+                id_to_ty_item.insert(def_id, ty::any_item_rust(i));\n             }\n             case (ast::item_tag(_, _, _, ?def_id, _)) {\n-                id_to_ty_item.insert(def_id, any_item_rust(i));\n+                id_to_ty_item.insert(def_id, ty::any_item_rust(i));\n             }\n             case (ast::item_obj(_, _, _, ?odid, _)) {\n-                id_to_ty_item.insert(odid.ty, any_item_rust(i));\n+                id_to_ty_item.insert(odid.ty, ty::any_item_rust(i));\n             }\n             case (_) { /* empty */ }\n         }\n     }\n \n-    fn collect_native(&@ty_item_table id_to_ty_item, &@ast::native_item i) {\n+    fn collect_native(ty::item_table id_to_ty_item, &@ast::native_item i) {\n         alt (i.node) {\n             case (ast::native_item_ty(_, ?def_id)) {\n                 // The abi of types is not used.\n                 id_to_ty_item.insert(def_id,\n-                    any_item_native(i, ast::native_abi_cdecl));\n+                    ty::any_item_native(i, ast::native_abi_cdecl));\n             }\n             case (_) { /* no-op */ }\n         }\n@@ -826,15 +815,13 @@ mod collect {\n         }\n     }\n \n-    fn collect_item_types(&session::session sess, &ty::ctxt tcx,\n-                          &@ast::crate crate) -> @ty_item_table {\n+    fn collect_item_types(&ty::ctxt tcx, &@ast::crate crate) {\n         // First pass: collect all type item IDs.\n         auto module = crate.node.module;\n-        auto id_to_ty_item = @common::new_def_hash[any_item]();\n \n         auto visit = rec(\n-            visit_item_pre = bind collect(id_to_ty_item, _),\n-            visit_native_item_pre = bind collect_native(id_to_ty_item, _)\n+            visit_item_pre = bind collect(tcx.items, _),\n+            visit_native_item_pre = bind collect_native(tcx.items, _)\n             with walk::default_visitor()\n         );\n         walk::walk_crate(visit, *crate);\n@@ -843,18 +830,13 @@ mod collect {\n         // contained within the native module.\n         auto abi = @mutable none[ast::native_abi];\n \n-        auto cx = @rec(sess=sess,\n-                       id_to_ty_item=id_to_ty_item,\n-                       tcx=tcx);\n-\n+        auto cx = @rec(tcx=tcx);\n         visit = rec(\n             visit_item_pre = bind convert(cx,abi,_),\n             visit_native_item_pre = bind convert_native(cx,abi,_)\n             with walk::default_visitor()\n         );\n         walk::walk_crate(visit, *crate);\n-\n-        ret id_to_ty_item;\n     }\n }\n \n@@ -1059,10 +1041,11 @@ mod Demand {\n             }\n \n             case (ures_err(?err, ?expected, ?actual)) {\n-                scx.fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n-                    + ty_to_str(scx.fcx.ccx.tcx, expected) + \" but found \"\n-                    + ty_to_str(scx.fcx.ccx.tcx, actual) + \" (\"\n-                    + ty::type_err_to_str(err) + \")\");\n+                scx.fcx.ccx.tcx.sess.span_err\n+                    (sp, \"mismatched types: expected \"\n+                     + ty_to_str(scx.fcx.ccx.tcx, expected) + \" but found \"\n+                     + ty_to_str(scx.fcx.ccx.tcx, actual) + \" (\"\n+                     + ty::type_err_to_str(err) + \")\");\n \n                 // TODO: In the future, try returning \"expected\", reporting\n                 // the error, and continue.\n@@ -1088,7 +1071,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n \n     let vec[ty::t] result = [];\n \n-    auto tpt = ty::lookup_item_type(ccx.sess, ccx.tcx, vid);\n+    auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (struct(ccx.tcx, tpt._1)) {\n         case (ty::ty_fn(_, ?ins, _)) {\n             // N-ary variant.\n@@ -1499,7 +1482,7 @@ mod Pushdown {\n             }\n \n             case (_) {\n-                scx.fcx.ccx.sess.span_unimpl(e.span,\n+                scx.fcx.ccx.tcx.sess.span_unimpl(e.span,\n                     #fmt(\"type unification for expression variant: %s\",\n                          util::common::expr_to_str(e)));\n                 fail;\n@@ -1532,7 +1515,7 @@ mod writeback {\n         auto local_ty;\n         alt (fcx.locals.find(local.id)) {\n             case (none[ty::t]) {\n-                fcx.ccx.sess.span_err(sp,\n+                fcx.ccx.tcx.sess.span_err(sp,\n                     \"unable to determine type of local: \" + local.ident);\n                 fail;\n             }\n@@ -1665,12 +1648,12 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n             auto vdef = ast::variant_def_ids\n                 (scx.fcx.ccx.tcx.def_map.get(old_ann.id));\n-            auto t = ty::lookup_item_type(scx.fcx.ccx.sess, scx.fcx.ccx.tcx,\n+            auto t = ty::lookup_item_type(scx.fcx.ccx.tcx,\n                                           vdef._1)._1;\n             auto len = vec::len[ast::ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n-            auto tpt = ty::lookup_item_type(scx.fcx.ccx.sess, scx.fcx.ccx.tcx,\n+            auto tpt = ty::lookup_item_type(scx.fcx.ccx.tcx,\n                                             vdef._0);\n \n             auto path_tpot = instantiate_path(scx, p, tpt, pat.span);\n@@ -1688,7 +1671,7 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n                                        uint::to_str(subpats_len, 10u) +\n                                        \" field(s)\";\n \n-                        scx.fcx.ccx.sess.span_err(pat.span, err_msg);\n+                        scx.fcx.ccx.tcx.sess.span_err(pat.span, err_msg);\n                         fail;   // TODO: recover\n                     }\n \n@@ -1710,7 +1693,7 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n                                        uint::to_str(subpats_len, 10u) +\n                                        \" field(s)\";\n \n-                        scx.fcx.ccx.sess.span_err(pat.span, err_msg);\n+                        scx.fcx.ccx.tcx.sess.span_err(pat.span, err_msg);\n                         fail;   // TODO: recover\n                     }\n \n@@ -1758,14 +1741,14 @@ fn require_pure_call(@crate_ctxt ccx,\n                                 ret;\n                             }\n                             case (_) {\n-                                ccx.sess.span_err(sp,\n+                                ccx.tcx.sess.span_err(sp,\n                                   \"Pure function calls impure function\");\n \n                             }\n                         }\n                 }\n                 case (_) {\n-                    ccx.sess.span_err(sp,\n+                    ccx.tcx.sess.span_err(sp,\n                       \"Pure function calls unknown function\");\n                 }\n             }\n@@ -1776,14 +1759,15 @@ fn require_pure_call(@crate_ctxt ccx,\n fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) -> () {\n     alt (get_function_purity(ccx, d_id)) {\n         case (ast::impure_fn) {\n-            ccx.sess.span_err(sp, \"Found non-predicate in check expression\");\n+            ccx.tcx.sess.span_err(sp,\n+                                  \"Found non-predicate in check expression\");\n         }\n         case (_) { ret; }\n     }\n }\n \n fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n-    //fcx.ccx.sess.span_warn(expr.span, \"typechecking expr \" +\n+    //fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                       util::common::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n@@ -1821,7 +1805,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 t_0 = ty::mk_native_fn(scx.fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n             }\n             case (?u) {\n-                scx.fcx.ccx.sess.span_err(f.span,\n+                scx.fcx.ccx.tcx.sess.span_err(f.span,\n                     \"check_call_or_bind(): fn expr doesn't have fn type,\"\n                     + \" instead having: \" +\n                     ty_to_str(scx.fcx.ccx.tcx,\n@@ -1909,7 +1893,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     alt (struct(scx.fcx.ccx.tcx, oper_t)) {\n                         case (ty::ty_box(?inner)) { oper_t = inner.ty; }\n                         case (_) {\n-                            scx.fcx.ccx.sess.span_err\n+                            scx.fcx.ccx.tcx.sess.span_err\n                                 (expr.span,\n                                  \"dereferencing non-box type: \"\n                                  + ty_to_str(scx.fcx.ccx.tcx, oper_t));\n@@ -1938,7 +1922,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n             if (vec::len[@ast::ty](pth.node.types) > 0u) {\n-                scx.fcx.ccx.sess.span_err(expr.span,\n+                scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                     \"this kind of value does not take type parameters\");\n                 fail;\n             }\n@@ -1970,7 +1954,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n                     if (!are_compatible(scx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n-                        scx.fcx.ccx.sess.err(\"ret; in function \" +\n+                        scx.fcx.ccx.tcx.sess.err(\"ret; in function \" +\n                             \"returning non-nil\");\n                     }\n \n@@ -1987,14 +1971,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         }\n \n         case (ast::expr_put(?expr_opt, ?a)) {\n-            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n \n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n                     auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n                     if (!are_compatible(scx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n-                        scx.fcx.ccx.sess.span_err(expr.span,\n+                        scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                             \"put; in iterator yielding non-nil\");\n                     }\n \n@@ -2041,7 +2025,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             }\n                             for (@ast::expr operand in operands) {\n                                 if (! ast::is_constraint_arg(operand)) {\n-                                    scx.fcx.ccx.sess.span_err(expr.span,\n+                                    scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                                        \"Constraint args must be \"\n                                      + \"slot variables or literals\");\n                                 }\n@@ -2053,14 +2037,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             write::nil_ty(scx.fcx.ccx.tcx, a.id);\n                         }\n                         case (_) {\n-                           scx.fcx.ccx.sess.span_err(expr.span,\n+                           scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                              \"In a constraint, expected the constraint name \"\n                            + \"to be an explicit name\");\n                         }\n                     }\n                 }\n                 case (_) {\n-                    scx.fcx.ccx.sess.span_err(expr.span,\n+                    scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                         \"check on non-predicate\");\n                 }\n             }\n@@ -2075,17 +2059,17 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n-            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n             check_assignment(scx, lhs, rhs, a);\n         }\n \n         case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n-            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n             check_assignment(scx, lhs, rhs, a);\n         }\n \n         case (ast::expr_send(?lhs, ?rhs, ?a)) {\n-            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n \n             check_expr(scx, lhs);\n             check_expr(scx, rhs);\n@@ -2105,7 +2089,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         }\n \n         case (ast::expr_recv(?lhs, ?rhs, ?a)) {\n-            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n \n             check_expr(scx, lhs);\n             check_expr(scx, rhs);\n@@ -2310,8 +2294,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             auto oinfo_opt = get_obj_info(scx.fcx.ccx);\n             auto this_obj_id = option::get[obj_info](oinfo_opt).this_obj;\n-            this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.sess,\n-                                               scx.fcx.ccx.tcx,\n+            this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.tcx,\n                                                this_obj_id)._1;\n \n             // Grab this method's type out of the current object type.\n@@ -2329,7 +2312,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             write::ty_only_fixup(scx, a.id, t);\n \n-            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n         }\n \n         case (ast::expr_spawn(_, _, ?f, ?args, ?a)) {\n@@ -2346,7 +2329,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         case (_) {\n                             auto err = \"non-nil return type in \"\n                                 + \"spawned function\";\n-                            scx.fcx.ccx.sess.span_err(expr.span, err);\n+                            scx.fcx.ccx.tcx.sess.span_err(expr.span, err);\n                             fail;\n                         }\n                     }\n@@ -2366,7 +2349,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             if (! (type_is_scalar(scx.fcx.ccx.tcx,\n                     expr_ty(scx.fcx.ccx.tcx, e)) &&\n                     type_is_scalar(scx.fcx.ccx.tcx, t_1))) {\n-                scx.fcx.ccx.sess.span_err(expr.span,\n+                scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n                     ty_to_str(scx.fcx.ccx.tcx,\n                         expr_ty(scx.fcx.ccx.tcx, e)) +\n@@ -2440,7 +2423,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     alt (struct(scx.fcx.ccx.tcx, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n-                            scx.fcx.ccx.sess.span_err\n+                            scx.fcx.ccx.tcx.sess.span_err\n                                 (expr.span,\n                                  \"record update non-record base\");\n                         }\n@@ -2458,7 +2441,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             }\n                         }\n                         if (!found) {\n-                            scx.fcx.ccx.sess.span_err\n+                            scx.fcx.ccx.tcx.sess.span_err\n                                 (expr.span,\n                                  \"unknown field in record update: \"\n                                  + f.ident);\n@@ -2474,30 +2457,30 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             base_t = strip_boxes(scx.fcx.ccx.tcx, base_t);\n             alt (struct(scx.fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_tup(?args)) {\n-                    let uint ix = ty::field_num(scx.fcx.ccx.sess,\n+                    let uint ix = ty::field_num(scx.fcx.ccx.tcx.sess,\n                                                 expr.span, field);\n                     if (ix >= vec::len[ty::mt](args)) {\n-                        scx.fcx.ccx.sess.span_err(expr.span,\n+                        scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"bad index on tuple\");\n                     }\n                     write::ty_only_fixup(scx, a.id, args.(ix).ty);\n                 }\n \n                 case (ty::ty_rec(?fields)) {\n-                    let uint ix = ty::field_idx(scx.fcx.ccx.sess,\n+                    let uint ix = ty::field_idx(scx.fcx.ccx.tcx.sess,\n                                                 expr.span, field, fields);\n                     if (ix >= vec::len[typeck::field](fields)) {\n-                        scx.fcx.ccx.sess.span_err(expr.span,\n+                        scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n                     write::ty_only_fixup(scx, a.id, fields.(ix).mt.ty);\n                 }\n \n                 case (ty::ty_obj(?methods)) {\n-                    let uint ix = ty::method_idx(scx.fcx.ccx.sess,\n+                    let uint ix = ty::method_idx(scx.fcx.ccx.tcx.sess,\n                                                  expr.span, field, methods);\n                     if (ix >= vec::len[typeck::method](methods)) {\n-                        scx.fcx.ccx.sess.span_err(expr.span,\n+                        scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n@@ -2507,7 +2490,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 }\n \n                 case (_) {\n-                    scx.fcx.ccx.sess.span_unimpl(expr.span,\n+                    scx.fcx.ccx.tcx.sess.span_unimpl(expr.span,\n                         \"base type for expr_field in typeck::check_expr: \" +\n                         ty_to_str(scx.fcx.ccx.tcx, base_t));\n                 }\n@@ -2524,7 +2507,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             alt (struct(scx.fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n                     if (! type_is_integral(scx.fcx.ccx.tcx, idx_t)) {\n-                        scx.fcx.ccx.sess.span_err\n+                        scx.fcx.ccx.tcx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(scx.fcx.ccx.tcx, idx_t));\n@@ -2533,7 +2516,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 }\n                 case (ty::ty_str) {\n                     if (! type_is_integral(scx.fcx.ccx.tcx, idx_t)) {\n-                        scx.fcx.ccx.sess.span_err\n+                        scx.fcx.ccx.tcx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of str index: \"\n                              + ty_to_str(scx.fcx.ccx.tcx, idx_t));\n@@ -2542,7 +2525,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     write::ty_only_fixup(scx, a.id, typ);\n                 }\n                 case (_) {\n-                    scx.fcx.ccx.sess.span_err\n+                    scx.fcx.ccx.tcx.sess.span_err\n                         (expr.span,\n                          \"vector-indexing bad type: \"\n                          + ty_to_str(scx.fcx.ccx.tcx, base_t));\n@@ -2565,15 +2548,15 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     write::ty_only_fixup(scx, a.id, ct);\n                 }\n                 case (_) {\n-                    scx.fcx.ccx.sess.span_err(expr.span,\n+                    scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                         \"bad port type: \" +\n                         ty_to_str(scx.fcx.ccx.tcx, port_t));\n                 }\n             }\n         }\n \n         case (_) {\n-            scx.fcx.ccx.sess.unimpl(\"expr type in typeck::check_expr\");\n+            scx.fcx.ccx.tcx.sess.unimpl(\"expr type in typeck::check_expr\");\n         }\n     }\n }\n@@ -2727,7 +2710,8 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n             // per the previous comment, this just checks that the declared\n             // type is bool, and trusts that that's the actual return type.\n             if (!ty::type_is_bool(ccx.tcx, fcx.ret_ty)) {\n-              ccx.sess.span_err(body.span, \"Non-boolean return type in pred\");\n+              ccx.tcx.sess.span_err(body.span,\n+                                    \"Non-boolean return type in pred\");\n             }\n         }\n         case (_) {}\n@@ -2822,8 +2806,8 @@ fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n }\n \n fn check_crate(&ty::ctxt tcx, &@ast::crate crate) {\n-    auto sess = tcx.sess;\n-    auto all_items = collect::collect_item_types(sess, tcx, crate);\n+\n+    collect::collect_item_types(tcx, crate);\n \n     let vec[obj_info] obj_infos = [];\n \n@@ -2833,9 +2817,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) {\n         map::mk_hashmap[unify_cache_entry,ty::unify::result](hasher, eqer);\n     auto fpt = mk_fn_purity_table(crate); // use a variation on collect\n \n-    auto ccx = @rec(sess=sess,\n-                    item_items=all_items,\n-                    mutable obj_infos=obj_infos,\n+    auto ccx = @rec(mutable obj_infos=obj_infos,\n                     fn_purity_table=fpt,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,"}]}