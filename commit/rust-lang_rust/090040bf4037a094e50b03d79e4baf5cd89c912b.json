{"sha": "090040bf4037a094e50b03d79e4baf5cd89c912b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MDA0MGJmNDAzN2EwOTRlNTBiMDNkNzllNGJhZjVjZDg5YzkxMmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-06T01:56:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-07T06:12:54Z"}, "message": "librustc: Remove `~EXPR`, `~TYPE`, and `~PAT` from the language, except\nfor `~str`/`~[]`.\n\nNote that `~self` still remains, since I forgot to add support for\n`Box<self>` before the snapshot.\n\nHow to update your code:\n\n* Instead of `~EXPR`, you should write `box EXPR`.\n\n* Instead of `~TYPE`, you should write `Box<Type>`.\n\n* Instead of `~PATTERN`, you should write `box PATTERN`.\n\n[breaking-change]", "tree": {"sha": "27fa91d623889d59260d3db167abdfa8c4288849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27fa91d623889d59260d3db167abdfa8c4288849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/090040bf4037a094e50b03d79e4baf5cd89c912b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/090040bf4037a094e50b03d79e4baf5cd89c912b", "html_url": "https://github.com/rust-lang/rust/commit/090040bf4037a094e50b03d79e4baf5cd89c912b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/090040bf4037a094e50b03d79e4baf5cd89c912b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24f6f26e633e50b5b59f9d0f6cca0b1e49e215d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/24f6f26e633e50b5b59f9d0f6cca0b1e49e215d9", "html_url": "https://github.com/rust-lang/rust/commit/24f6f26e633e50b5b59f9d0f6cca0b1e49e215d9"}], "stats": {"total": 4139, "additions": 2247, "deletions": 1892}, "files": [{"sha": "059ae4cb308e998ea26463547f081a3010deb39d", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -293,7 +293,7 @@ extern {\n \n fn main() {\n     // Create the object that will be referenced in the callback\n-    let mut rust_object = ~RustObject{ a: 5 };\n+    let mut rust_object = box RustObject { a: 5 };\n \n     unsafe {\n         register_callback(&mut *rust_object, callback);"}, {"sha": "48c50471c25f5e459b47ecfccfbd2f8fc2d7baa2", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -41,9 +41,9 @@ point, but allocated in a different place:\n \n ~~~\n # struct Point {x: f64, y: f64}\n-let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\n-let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\n-let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\n+let on_the_stack :  Point     =     Point {x: 3.0, y: 4.0};\n+let managed_box  : @Point     =    @Point {x: 5.0, y: 1.0};\n+let owned_box    : Box<Point> = box Point {x: 7.0, y: 9.0};\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance between any\n@@ -72,9 +72,9 @@ Now we can call `compute_distance()` in various ways:\n \n ~~~\n # struct Point {x: f64, y: f64}\n-# let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\n-# let managed_box  : @Point = @Point{x: 5.0, y: 1.0};\n-# let owned_box    : ~Point = ~Point{x: 7.0, y: 9.0};\n+# let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n+# let managed_box  :    @Point  =    @Point{x: 5.0, y: 1.0};\n+# let owned_box    : Box<Point> = box Point{x: 7.0, y: 9.0};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n compute_distance(&on_the_stack, managed_box);\n compute_distance(managed_box, owned_box);\n@@ -151,12 +151,12 @@ Now, as before, we can define rectangles in a few different ways:\n # struct Point {x: f64, y: f64}\n # struct Size {w: f64, h: f64} // as before\n # struct Rectangle {origin: Point, size: Size}\n-let rect_stack   = &Rectangle {origin: Point {x: 1.0, y: 2.0},\n-                               size: Size {w: 3.0, h: 4.0}};\n-let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0},\n-                               size: Size {w: 3.0, h: 4.0}};\n-let rect_owned   = ~Rectangle {origin: Point {x: 5.0, y: 6.0},\n-                               size: Size {w: 3.0, h: 4.0}};\n+let rect_stack   =    &Rectangle {origin: Point {x: 1.0, y: 2.0},\n+                                  size: Size {w: 3.0, h: 4.0}};\n+let rect_managed =    @Rectangle {origin: Point {x: 3.0, y: 4.0},\n+                                  size: Size {w: 3.0, h: 4.0}};\n+let rect_owned   = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n+                                  size: Size {w: 3.0, h: 4.0}};\n ~~~\n \n In each case, we can extract out individual subcomponents with the `&`\n@@ -168,7 +168,7 @@ operator. For example, I could write:\n # struct Rectangle {origin: Point, size: Size}\n # let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n # let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_owned = ~Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n+# let rect_owned = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n@@ -276,12 +276,12 @@ the following function is legal:\n # fn some_condition() -> bool { true }\n # struct Foo { f: int }\n fn example3() -> int {\n-    let mut x = ~Foo {f: 3};\n+    let mut x = box Foo {f: 3};\n     if some_condition() {\n         let y = &x.f;      // -+ L\n         return *y;         //  |\n     }                      // -+\n-    x = ~Foo {f: 4};\n+    x = box Foo {f: 4};\n     // ...\n # return 0;\n }\n@@ -301,9 +301,9 @@ rejected by the compiler):\n \n ~~~ {.ignore}\n fn example3() -> int {\n-    let mut x = ~X {f: 3};\n+    let mut x = box X {f: 3};\n     let y = &x.f;\n-    x = ~X {f: 4};  // Error reported here.\n+    x = box X {f: 4};  // Error reported here.\n     *y\n }\n ~~~\n@@ -314,27 +314,27 @@ memory immediately before the re-assignment of `x`:\n ~~~ {.notrust}\n     Stack               Exchange Heap\n \n-  x +----------+\n-    | ~{f:int} | ----+\n-  y +----------+     |\n-    | &int     | ----+\n-    +----------+     |    +---------+\n-                     +--> |  f: 3   |\n-                          +---------+\n+  x +-------------+\n+    | box {f:int} | ----+\n+  y +-------------+     |\n+    | &int        | ----+\n+    +-------------+     |    +---------+\n+                        +--> |  f: 3   |\n+                             +---------+\n ~~~\n \n Once the reassignment occurs, the memory will look like this:\n \n ~~~ {.notrust}\n     Stack               Exchange Heap\n \n-  x +----------+          +---------+\n-    | ~{f:int} | -------> |  f: 4   |\n-  y +----------+          +---------+\n-    | &int     | ----+\n-    +----------+     |    +---------+\n-                     +--> | (freed) |\n-                          +---------+\n+  x +-------------+          +---------+\n+    | box {f:int} | -------> |  f: 4   |\n+  y +-------------+          +---------+\n+    | &int        | ----+\n+    +-------------+     |    +---------+\n+                        +--> | (freed) |\n+                             +---------+\n ~~~\n \n Here you can see that the variable `y` still points at the old box,\n@@ -349,12 +349,12 @@ mutations:\n ~~~ {.ignore}\n fn example3() -> int {\n     struct R { g: int }\n-    struct S { f: ~R }\n+    struct S { f: Box<R> }\n \n-    let mut x = ~S {f: ~R {g: 3}};\n+    let mut x = box S {f: box R {g: 3}};\n     let y = &x.f.g;\n-    x = ~S {f: ~R {g: 4}};  // Error reported here.\n-    x.f = ~R {g: 5};        // Error reported here.\n+    x = box S {f: box R {g: 4}};  // Error reported here.\n+    x.f = box R {g: 5};           // Error reported here.\n     *y\n }\n ~~~"}, {"sha": "46564e67128963f90f15f005cd24158fda738d5e", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -182,21 +182,22 @@ trait. Therefore, unboxed traits don't make any sense, and aren't allowed.\n Sometimes, you need a recursive data structure. The simplest is known as a 'cons list':\n \n ~~~rust\n+\n enum List<T> {\n     Nil,\n-    Cons(T, ~List<T>),\n+    Cons(T, Box<List<T>>),\n }\n \n fn main() {\n-    let list: List<int> = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n+    let list: List<int> = Cons(1, box Cons(2, box Cons(3, box Nil)));\n     println!(\"{:?}\", list);\n }\n ~~~\n \n This prints:\n \n ~~~ {.notrust}\n-Cons(1, ~Cons(2, ~Cons(3, ~Nil)))\n+Cons(1, box Cons(2, box Cons(3, box Nil)))\n ~~~\n \n The inner lists _must_ be an owned pointer, because we can't know how many\n@@ -237,7 +238,7 @@ struct Point {\n }\n \n fn main() {\n-    let a = ~Point { x: 10, y: 20 };\n+    let a = box Point { x: 10, y: 20 };\n     spawn(proc() {\n         println!(\"{}\", a.x);\n     });\n@@ -268,7 +269,7 @@ struct Point {\n }\n \n fn main() {\n-    let a = ~Point { x: 10, y: 20 };\n+    let a = box Point { x: 10, y: 20 };\n     let b = a;\n     println!(\"{}\", b.x);\n     println!(\"{}\", a.x);\n@@ -285,7 +286,7 @@ note: in expansion of format_args!\n <std-macros>:158:27: 158:81 note: expansion site\n <std-macros>:157:5: 159:6 note: in expansion of println!\n test.rs:10:5: 10:25 note: expansion site\n-test.rs:8:9: 8:10 note: `a` moved here because it has type `~Point`, which is moved by default (use `ref` to override)\n+test.rs:8:9: 8:10 note: `a` moved here because it has type `Box<Point>`, which is moved by default (use `ref` to override)\n test.rs:8     let b = a;\n                   ^\n ~~~\n@@ -345,8 +346,8 @@ fn compute_distance(p1: &Point, p2: &Point) -> f32 {\n }\n \n fn main() {\n-    let origin = @Point { x: 0.0, y: 0.0 };\n-    let p1     = ~Point { x: 5.0, y: 3.0 };\n+    let origin =    @Point { x: 0.0, y: 0.0 };\n+    let p1     = box Point { x: 5.0, y: 3.0 };\n \n     println!(\"{:?}\", compute_distance(origin, p1));\n }\n@@ -381,7 +382,7 @@ duration a 'lifetime'. Let's try a more complex example:\n \n ~~~rust\n fn main() {\n-    let mut x = ~5;\n+    let mut x = box 5;\n     if *x < 10 {\n         let y = &x;\n         println!(\"Oh no: {:?}\", y);\n@@ -398,7 +399,7 @@ mutated, and therefore, lets us pass. This wouldn't work:\n \n ~~~rust{.ignore}\n fn main() {\n-    let mut x = ~5;\n+    let mut x = box 5;\n     if *x < 10 {\n         let y = &x;\n         *x -= 1;\n@@ -437,39 +438,39 @@ is best.\n What does that mean? Don't do this:\n \n ~~~rust\n-fn foo(x: ~int) -> ~int {\n-    return ~*x;\n+fn foo(x: Box<int>) -> Box<int> {\n+    return box *x;\n }\n \n fn main() {\n-    let x = ~5;\n+    let x = box 5;\n     let y = foo(x);\n }\n ~~~\n \n Do this:\n \n ~~~rust\n-fn foo(x: ~int) -> int {\n+fn foo(x: Box<int>) -> int {\n     return *x;\n }\n \n fn main() {\n-    let x = ~5;\n-    let y = ~foo(x);\n+    let x = box 5;\n+    let y = box foo(x);\n }\n ~~~\n \n This gives you flexibility, without sacrificing performance. For example, this will\n also work:\n \n ~~~rust\n-fn foo(x: ~int) -> int {\n+fn foo(x: Box<int>) -> int {\n     return *x;\n }\n \n fn main() {\n-    let x = ~5;\n+    let x = box 5;\n     let y = @foo(x);\n }\n ~~~"}, {"sha": "fc6a12b495e2eb4ceb8d8368a365adcd8f463635", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -258,10 +258,10 @@ impl<T: Send> Drop for Unique<T> {\n     }\n }\n \n-// A comparison between the built-in ~ and this reimplementation\n+// A comparison between the built-in `Box` and this reimplementation\n fn main() {\n     {\n-        let mut x = ~5;\n+        let mut x = box 5;\n         *x = 10;\n     } // `x` is freed here\n "}, {"sha": "71356eba6d91e07cec29cb04ba971ec66eea6ffa", "filename": "src/doc/intro.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -127,12 +127,13 @@ That's a great example for stack memory,\n but what about heap memory?\n Rust has a second kind of pointer,\n an 'owned box',\n-that you can create with a `~`.\n+that you can create with the `box` operator.\n Check it out:\n \n ```\n-fn dangling() -> ~int {\n-    let i = ~1234;\n+\n+fn dangling() -> Box<int> {\n+    let i = box 1234;\n     return i;\n }\n \n@@ -143,15 +144,15 @@ fn add_one() -> int {\n ```\n \n Now instead of a stack allocated `1234`,\n-we have a heap allocated `~1234`.\n+we have a heap allocated `box 1234`.\n Whereas `&` borrows a pointer to existing memory,\n creating an owned box allocates memory on the heap and places a value in it,\n giving you the sole pointer to that memory.\n You can roughly compare these two lines:\n \n ```\n // Rust\n-let i = ~1234;\n+let i = box 1234;\n ```\n \n ```notrust"}, {"sha": "a954a49a9ba3df5b9e5a0016ed736ac2683bf697", "filename": "src/doc/rust.md", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -1393,7 +1393,7 @@ to pointers to the trait name, used as a type.\n # trait Shape { }\n # impl Shape for int { }\n # let mycircle = 0;\n-let myshape: ~Shape = ~mycircle as ~Shape;\n+let myshape: Box<Shape> = box mycircle as Box<Shape>;\n ~~~~\n \n The resulting value is a managed box containing the value that was cast,\n@@ -3041,19 +3041,19 @@ stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n fields of a particular variant. For example:\n \n ~~~~\n-enum List<X> { Nil, Cons(X, ~List<X>) }\n+enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n-let x: List<int> = Cons(10, ~Cons(11, ~Nil));\n+let x: List<int> = Cons(10, box Cons(11, box Nil));\n \n match x {\n-    Cons(_, ~Nil) => fail!(\"singleton list\"),\n-    Cons(..)      => return,\n-    Nil           => fail!(\"empty list\")\n+    Cons(_, box Nil) => fail!(\"singleton list\"),\n+    Cons(..)         => return,\n+    Nil              => fail!(\"empty list\")\n }\n ~~~~\n \n The first pattern matches lists constructed by applying `Cons` to any head\n-value, and a tail value of `~Nil`. The second pattern matches _any_ list\n+value, and a tail value of `box Nil`. The second pattern matches _any_ list\n constructed with `Cons`, ignoring the values of its arguments. The difference\n between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n exactly one argument, while the pattern `C(..)` is type-correct for any enum\n@@ -3103,12 +3103,12 @@ An example of a `match` expression:\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n \n-enum List<X> { Nil, Cons(X, ~List<X>) }\n+enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n-let x: List<int> = Cons(10, ~Cons(11, ~Nil));\n+let x: List<int> = Cons(10, box Cons(11, box Nil));\n \n match x {\n-    Cons(a, ~Cons(b, _)) => {\n+    Cons(a, box Cons(b, _)) => {\n         process_pair(a,b);\n     }\n     Cons(10, _) => {\n@@ -3135,17 +3135,17 @@ Subpatterns can also be bound to variables by the use of the syntax\n For example:\n \n ~~~~\n-enum List { Nil, Cons(uint, ~List) }\n+enum List { Nil, Cons(uint, Box<List>) }\n \n fn is_sorted(list: &List) -> bool {\n     match *list {\n-        Nil | Cons(_, ~Nil) => true,\n-        Cons(x, ref r @ ~Cons(y, _)) => (x <= y) && is_sorted(*r)\n+        Nil | Cons(_, box Nil) => true,\n+        Cons(x, ref r @ box Cons(y, _)) => (x <= y) && is_sorted(*r)\n     }\n }\n \n fn main() {\n-    let a = Cons(6, ~Cons(7, ~Cons(42, ~Nil)));\n+    let a = Cons(6, box Cons(7, box Cons(42, box Nil)));\n     assert!(is_sorted(&a));\n }\n \n@@ -3411,10 +3411,10 @@ An example of a *recursive* type and its use:\n ~~~~\n enum List<T> {\n   Nil,\n-  Cons(T, ~List<T>)\n+  Cons(T, Box<List<T>>)\n }\n \n-let a: List<int> = Cons(7, ~Cons(13, ~Nil));\n+let a: List<int> = Cons(7, box Cons(13, box Nil));\n ~~~~\n \n ### Pointer types\n@@ -3563,12 +3563,12 @@ impl Printable for int {\n   fn to_string(&self) -> ~str { self.to_str() }\n }\n \n-fn print(a: ~Printable) {\n+fn print(a: Box<Printable>) {\n    println!(\"{}\", a.to_string());\n }\n \n fn main() {\n-   print(~10 as ~Printable);\n+   print(box 10 as Box<Printable>);\n }\n ~~~~\n \n@@ -3755,7 +3755,7 @@ mutable slot by prefixing them with `mut` (similar to regular arguments):\n ~~~\n trait Changer {\n     fn change(mut self) -> Self;\n-    fn modify(mut ~self) -> ~Self;\n+    fn modify(mut ~self) -> Box<Self>;\n }\n ~~~\n \n@@ -3768,20 +3768,22 @@ initialized; this is enforced by the compiler.\n ### Owned boxes\n \n An  _owned box_ is a reference to a heap allocation holding another value, which is constructed\n-by the prefix *tilde* sigil `~`.\n+by the prefix operator `box`. When the standard library is in use, the type of an owned box is\n+`std::owned::Box<T>`.\n \n An example of an owned box type and value:\n \n ~~~~\n-let x: ~int = ~10;\n+\n+let x: Box<int> = box 10;\n ~~~~\n \n Owned box values exist in 1:1 correspondence with their heap allocation\n copying an owned box value makes a shallow copy of the pointer\n Rust will consider a shallow copy of an owned box to move ownership of the value. After a value has been moved, the source location cannot be used unless it is reinitialized.\n \n ~~~~\n-let x: ~int = ~10;\n+let x: Box<int> = box 10;\n let y = x;\n // attempting to use `x` will result in an error here\n ~~~~"}, {"sha": "e1e6d5a0e15764bd70f9cf691f99a1690f4752ce", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -911,12 +911,12 @@ Objects are never accessible after their destructor has been called, so no\n dynamic failures are possible from accessing freed resources. When a task\n fails, destructors of all objects in the task are called.\n \n-The `~` sigil represents a unique handle for a memory allocation on the heap:\n+The `box` operator performs memory allocation on the heap:\n \n ~~~~\n {\n     // an integer allocated on the heap\n-    let y = ~10;\n+    let y = box 10;\n }\n // the destructor frees the heap memory as soon as `y` goes out of scope\n ~~~~\n@@ -938,17 +938,17 @@ and destroy the contained object when they go out of scope.\n \n ~~~~\n // the struct owns the objects contained in the `x` and `y` fields\n-struct Foo { x: int, y: ~int }\n+struct Foo { x: int, y: Box<int> }\n \n {\n     // `a` is the owner of the struct, and thus the owner of the struct's fields\n-    let a = Foo { x: 5, y: ~10 };\n+    let a = Foo { x: 5, y: box 10 };\n }\n // when `a` goes out of scope, the destructor for the `~int` in the struct's\n // field is called\n \n // `b` is mutable, and the mutability is inherited by the objects it owns\n-let mut b = Foo { x: 5, y: ~10 };\n+let mut b = Foo { x: 5, y: box 10 };\n b.x = 10;\n ~~~~\n \n@@ -1021,13 +1021,15 @@ Our previous attempt at defining the `List` type included an `u32` and a `List`\n directly inside `Cons`, making it at least as big as the sum of both types. The\n type was invalid because the size was infinite!\n \n-An *owned box* (`~`) uses a dynamic memory allocation to provide the invariant\n-of always being the size of a pointer, regardless of the contained type. This\n-can be leveraged to create a valid `List` definition:\n+An *owned box* (`Box`, located in the `std::owned` module) uses a dynamic memory\n+allocation to provide the invariant of always being the size of a pointer,\n+regardless of the contained type. This can be leveraged to create a valid `List`\n+definition:\n \n ~~~\n+\n enum List {\n-    Cons(u32, ~List),\n+    Cons(u32, Box<List>),\n     Nil\n }\n ~~~\n@@ -1040,10 +1042,10 @@ Consider an instance of our `List` type:\n \n ~~~\n # enum List {\n-#     Cons(u32, ~List),\n+#     Cons(u32, Box<List>),\n #     Nil\n # }\n-let list = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n+let list = Cons(1, box Cons(2, box Cons(3, box Nil)));\n ~~~\n \n It represents an owned tree of values, inheriting mutability down the tree and\n@@ -1054,7 +1056,7 @@ box, while the owner holds onto a pointer to it:\n ~~~ {.notrust}\n             List box            List box            List box          List box\n         +--------------+    +--------------+    +--------------+    +----------+\n-list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil      |\n+list -> | Cons | 1 |   | -> | Cons | 2 |   | -> | Cons | 3 |   | -> | Nil      |\n         +--------------+    +--------------+    +--------------+    +----------+\n ~~~\n \n@@ -1074,10 +1076,10 @@ the box rather than doing an implicit heap allocation.\n \n ~~~\n # enum List {\n-#     Cons(u32, ~List),\n+#     Cons(u32, Box<List>),\n #     Nil\n # }\n-let xs = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n+let xs = Cons(1, box Cons(2, box Cons(3, box Nil)));\n let ys = xs; // copies `Cons(u32, pointer)` shallowly\n ~~~\n \n@@ -1087,7 +1089,7 @@ location cannot be used unless it is reinitialized.\n \n ~~~\n # enum List {\n-#     Cons(u32, ~List),\n+#     Cons(u32, Box<List>),\n #     Nil\n # }\n let mut xs = Nil;\n@@ -1107,7 +1109,7 @@ as it is only called a single time.\n Avoiding a move can be done with the library-defined `clone` method:\n \n ~~~~\n-let x = ~5;\n+let x = box 5;\n let y = x.clone(); // `y` is a newly allocated box\n let z = x; // no new memory allocated, `x` can no longer be used\n ~~~~\n@@ -1118,11 +1120,11 @@ our `List` type. Traits will be explained in detail [later](#traits).\n ~~~{.ignore}\n #[deriving(Clone)]\n enum List {\n-    Cons(u32, ~List),\n+    Cons(u32, Box<List>),\n     Nil\n }\n \n-let x = Cons(5, ~Nil);\n+let x = Cons(5, box Nil);\n let y = x.clone();\n \n // `x` can still be used!\n@@ -1135,7 +1137,7 @@ let z = x;\n The mutability of a value may be changed by moving it to a new owner:\n \n ~~~~\n-let r = ~13;\n+let r = box 13;\n let mut s = r; // box becomes mutable\n *s += 1;\n let t = s; // box becomes immutable\n@@ -1146,12 +1148,12 @@ advantage of moves:\n \n ~~~\n enum List {\n-    Cons(u32, ~List),\n+    Cons(u32, Box<List>),\n     Nil\n }\n \n fn prepend(xs: List, value: u32) -> List {\n-    Cons(value, ~xs)\n+    Cons(value, box xs)\n }\n \n let mut xs = Nil;\n@@ -1186,7 +1188,7 @@ by-value. A recursive definition of equality using references is as follows:\n \n ~~~\n # enum List {\n-#     Cons(u32, ~List),\n+#     Cons(u32, Box<List>),\n #     Nil\n # }\n fn eq(xs: &List, ys: &List) -> bool {\n@@ -1195,15 +1197,15 @@ fn eq(xs: &List, ys: &List) -> bool {\n         // If we have reached the end of both lists, they are equal.\n         (&Nil, &Nil) => true,\n         // If the current elements of both lists are equal, keep going.\n-        (&Cons(x, ~ref next_xs), &Cons(y, ~ref next_ys))\n+        (&Cons(x, box ref next_xs), &Cons(y, box ref next_ys))\n                 if x == y => eq(next_xs, next_ys),\n         // If the current elements are not equal, the lists are not equal.\n         _ => false\n     }\n }\n \n-let xs = Cons(5, ~Cons(10, ~Nil));\n-let ys = Cons(5, ~Cons(10, ~Nil));\n+let xs = Cons(5, box Cons(10, box Nil));\n+let ys = Cons(5, box Cons(10, box Nil));\n assert!(eq(&xs, &ys));\n ~~~\n \n@@ -1223,7 +1225,7 @@ The `u32` in the previous definition can be substituted with a type parameter:\n \n ~~~\n enum List<T> {\n-    Cons(T, ~List<T>),\n+    Cons(T, Box<List<T>>),\n     Nil\n }\n ~~~\n@@ -1233,11 +1235,11 @@ definition has to be updated too:\n \n ~~~\n # enum List<T> {\n-#     Cons(T, ~List<T>),\n+#     Cons(T, Box<List<T>>),\n #     Nil\n # }\n fn prepend<T>(xs: List<T>, value: T) -> List<T> {\n-    Cons(value, ~xs)\n+    Cons(value, box xs)\n }\n ~~~\n \n@@ -1248,11 +1250,11 @@ Using the generic `List<T>` works much like before, thanks to type inference:\n \n ~~~\n # enum List<T> {\n-#     Cons(T, ~List<T>),\n+#     Cons(T, Box<List<T>>),\n #     Nil\n # }\n # fn prepend<T>(xs: List<T>, value: T) -> List<T> {\n-#     Cons(value, ~xs)\n+#     Cons(value, box xs)\n # }\n let mut xs = Nil; // Unknown type! This is a `List<T>`, but `T` can be anything.\n xs = prepend(xs, 10); // Here the compiler infers `xs`'s type as `List<int>`.\n@@ -1265,11 +1267,11 @@ equivalent to the following type-annotated code:\n \n ~~~\n # enum List<T> {\n-#     Cons(T, ~List<T>),\n+#     Cons(T, Box<List<T>>),\n #     Nil\n # }\n # fn prepend<T>(xs: List<T>, value: T) -> List<T> {\n-#     Cons(value, ~xs)\n+#     Cons(value, box xs)\n # }\n let mut xs: List<int> = Nil::<int>;\n xs = prepend::<int>(xs, 10);\n@@ -1293,7 +1295,7 @@ Two more `ref` annotations need to be added to avoid attempting to move out the\n \n ~~~\n # enum List<T> {\n-#     Cons(T, ~List<T>),\n+#     Cons(T, Box<List<T>>),\n #     Nil\n # }\n fn eq<T: Eq>(xs: &List<T>, ys: &List<T>) -> bool {\n@@ -1302,15 +1304,15 @@ fn eq<T: Eq>(xs: &List<T>, ys: &List<T>) -> bool {\n         // If we have reached the end of both lists, they are equal.\n         (&Nil, &Nil) => true,\n         // If the current elements of both lists are equal, keep going.\n-        (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys))\n+        (&Cons(ref x, box ref next_xs), &Cons(ref y, box ref next_ys))\n                 if x == y => eq(next_xs, next_ys),\n         // If the current elements are not equal, the lists are not equal.\n         _ => false\n     }\n }\n \n-let xs = Cons('c', ~Cons('a', ~Cons('t', ~Nil)));\n-let ys = Cons('c', ~Cons('a', ~Cons('t', ~Nil)));\n+let xs = Cons('c', box Cons('a', box Cons('t', box Nil)));\n+let ys = Cons('c', box Cons('a', box Cons('t', box Nil)));\n assert!(eq(&xs, &ys));\n ~~~\n \n@@ -1321,7 +1323,7 @@ on.\n \n ~~~\n # enum List<T> {\n-#     Cons(T, ~List<T>),\n+#     Cons(T, Box<List<T>>),\n #     Nil\n # }\n impl<T: Eq> Eq for List<T> {\n@@ -1331,16 +1333,16 @@ impl<T: Eq> Eq for List<T> {\n             // If we have reached the end of both lists, they are equal.\n             (&Nil, &Nil) => true,\n             // If the current elements of both lists are equal, keep going.\n-            (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys))\n+            (&Cons(ref x, box ref next_xs), &Cons(ref y, box ref next_ys))\n                     if x == y => next_xs == next_ys,\n             // If the current elements are not equal, the lists are not equal.\n             _ => false\n         }\n     }\n }\n \n-let xs = Cons(5, ~Cons(10, ~Nil));\n-let ys = Cons(5, ~Cons(10, ~Nil));\n+let xs = Cons(5, box Cons(10, box Nil));\n+let ys = Cons(5, box Cons(10, box Nil));\n // The methods below are part of the Eq trait,\n // which we implemented on our linked list.\n assert!(xs.eq(&ys));\n@@ -1373,7 +1375,7 @@ fn foo() -> (u64, u64, u64, u64, u64, u64) {\n     (5, 5, 5, 5, 5, 5)\n }\n \n-let x = ~foo(); // allocates a `~` box, and writes the integers directly to it\n+let x = box foo(); // allocates a box, and writes the integers directly to it\n ~~~~\n \n Beyond the properties granted by the size, an owned box behaves as a regular\n@@ -1384,8 +1386,8 @@ let x = 5; // immutable\n let mut y = 5; // mutable\n y += 2;\n \n-let x = ~5; // immutable\n-let mut y = ~5; // mutable\n+let x = box 5; // immutable\n+let mut y = box 5; // mutable\n *y += 2; // the `*` operator is needed to access the contained value\n ~~~~\n \n@@ -1413,8 +1415,8 @@ contains a point, but allocated in a different location:\n \n ~~~\n # struct Point { x: f64, y: f64 }\n-let on_the_stack :  Point =  Point { x: 3.0, y: 4.0 };\n-let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n+let on_the_stack :     Point  =     Point { x: 3.0, y: 4.0 };\n+let owned_box    : Box<Point> = box Point { x: 7.0, y: 9.0 };\n ~~~\n \n Suppose we want to write a procedure that computes the distance\n@@ -1438,8 +1440,8 @@ Now we can call `compute_distance()` in various ways:\n \n ~~~\n # struct Point{ x: f64, y: f64 };\n-# let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n-# let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n+# let on_the_stack :     Point  =     Point { x: 3.0, y: 4.0 };\n+# let owned_box    : Box<Point> = box Point { x: 7.0, y: 9.0 };\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n compute_distance(&on_the_stack, owned_box);\n ~~~\n@@ -1453,7 +1455,7 @@ route to the same data.\n \n In the case of `owned_box`, however, no\n explicit action is necessary. The compiler will automatically convert\n-a box `~point` to a reference like\n+a box `box point` to a reference like\n `&point`. This is another form of borrowing; in this case, the\n contents of the owned box are being lent out.\n \n@@ -1492,7 +1494,7 @@ Rust uses the unary star operator (`*`) to access the contents of a\n box or pointer, similarly to C.\n \n ~~~\n-let owned = ~10;\n+let owned = box 10;\n let borrowed = &20;\n \n let sum = *owned + *borrowed;\n@@ -1503,7 +1505,7 @@ assignments. Such an assignment modifies the value that the pointer\n points to.\n \n ~~~\n-let mut owned = ~10;\n+let mut owned = box 10;\n \n let mut value = 20;\n let borrowed = &mut value;\n@@ -1520,8 +1522,8 @@ can sometimes make code awkward and parenthesis-filled.\n # struct Point { x: f64, y: f64 }\n # enum Shape { Rectangle(Point, Point) }\n # impl Shape { fn area(&self) -> int { 0 } }\n-let start = ~Point { x: 10.0, y: 20.0 };\n-let end = ~Point { x: (*start).x + 100.0, y: (*start).y + 100.0 };\n+let start = box Point { x: 10.0, y: 20.0 };\n+let end = box Point { x: (*start).x + 100.0, y: (*start).y + 100.0 };\n let rect = &Rectangle(*start, *end);\n let area = (*rect).area();\n ~~~\n@@ -1534,8 +1536,8 @@ dot), so in most cases, explicitly dereferencing the receiver is not necessary.\n # struct Point { x: f64, y: f64 }\n # enum Shape { Rectangle(Point, Point) }\n # impl Shape { fn area(&self) -> int { 0 } }\n-let start = ~Point { x: 10.0, y: 20.0 };\n-let end = ~Point { x: start.x + 100.0, y: start.y + 100.0 };\n+let start = box Point { x: 10.0, y: 20.0 };\n+let end = box Point { x: start.x + 100.0, y: start.y + 100.0 };\n let rect = &Rectangle(*start, *end);\n let area = rect.area();\n ~~~\n@@ -1546,7 +1548,7 @@ something silly like\n \n ~~~\n # struct Point { x: f64, y: f64 }\n-let point = &~Point { x: 10.0, y: 20.0 };\n+let point = &box Point { x: 10.0, y: 20.0 };\n println!(\"{:f}\", point.x);\n ~~~\n \n@@ -1944,7 +1946,7 @@ impl Shape {\n let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n \n (&s).draw_reference();\n-(~s).draw_owned();\n+(box s).draw_owned();\n s.draw_value();\n ~~~\n \n@@ -1969,7 +1971,7 @@ to a reference.\n // As with typical function arguments, owned pointers\n // are automatically converted to references\n \n-(~s).draw_reference();\n+(box s).draw_reference();\n \n // Unlike typical function arguments, the self value will\n // automatically be referenced ...\n@@ -1979,7 +1981,7 @@ s.draw_reference();\n (& &s).draw_reference();\n \n // ... and dereferenced and borrowed\n-(&~s).draw_reference();\n+(&box s).draw_reference();\n ~~~\n \n Implementations may also define standalone (sometimes called \"static\")\n@@ -2433,7 +2435,7 @@ an _object_.\n \n ~~~~\n # trait Drawable { fn draw(&self); }\n-fn draw_all(shapes: &[~Drawable]) {\n+fn draw_all(shapes: &[Box<Drawable>]) {\n     for shape in shapes.iter() { shape.draw(); }\n }\n ~~~~\n@@ -2448,14 +2450,14 @@ to an object:\n # trait Drawable { fn draw(&self); }\n # fn new_circle() -> Circle { 1 }\n # fn new_rectangle() -> Rectangle { true }\n-# fn draw_all(shapes: &[~Drawable]) {}\n+# fn draw_all(shapes: &[Box<Drawable>]) {}\n \n impl Drawable for Circle { fn draw(&self) { /* ... */ } }\n impl Drawable for Rectangle { fn draw(&self) { /* ... */ } }\n \n-let c: ~Circle = ~new_circle();\n-let r: ~Rectangle = ~new_rectangle();\n-draw_all([c as ~Drawable, r as ~Drawable]);\n+let c: Box<Circle> = box new_circle();\n+let r: Box<Rectangle> = box new_rectangle();\n+draw_all([c as Box<Drawable>, r as Box<Drawable>]);\n ~~~~\n \n We omit the code for `new_circle` and `new_rectangle`; imagine that\n@@ -2464,7 +2466,7 @@ that, like strings and vectors, objects have dynamic size and may\n only be referred to via one of the pointer types.\n Other pointer types work as well.\n Casts to traits may only be done with compatible pointers so,\n-for example, an `&Circle` may not be cast to an `~Drawable`.\n+for example, an `&Circle` may not be cast to a `Box<Drawable>`.\n \n ~~~\n # type Circle = int; type Rectangle = int;\n@@ -2473,7 +2475,7 @@ for example, an `&Circle` may not be cast to an `~Drawable`.\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n // An owned object\n-let owny: ~Drawable = ~new_circle() as ~Drawable;\n+let owny: Box<Drawable> = box new_circle() as Box<Drawable>;\n // A borrowed object\n let stacky: &Drawable = &new_circle() as &Drawable;\n ~~~\n@@ -2497,7 +2499,7 @@ valid types:\n trait Foo {}\n trait Bar<T> {}\n \n-fn sendable_foo(f: ~Foo:Send) { /* ... */ }\n+fn sendable_foo(f: Box<Foo:Send>) { /* ... */ }\n fn shareable_bar<T: Share>(b: &Bar<T>: Share) { /* ... */ }\n ~~~\n "}, {"sha": "24e7a65e02a0ab73ce44c51c72b078b5510bf86f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -29,14 +29,14 @@ extern crate collections;\n use std::cast::{transmute, transmute_mut_lifetime};\n use std::cast;\n use std::cell::{Cell, RefCell};\n-use std::mem;\n-use std::ptr::read;\n use std::cmp;\n+use std::intrinsics::{TyDesc, get_tydesc};\n+use std::intrinsics;\n+use std::mem;\n use std::num;\n+use std::ptr::read;\n use std::rc::Rc;\n use std::rt::global_heap;\n-use std::intrinsics::{TyDesc, get_tydesc};\n-use std::intrinsics;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -339,12 +339,12 @@ pub struct TypedArena<T> {\n     end: *T,\n \n     /// A pointer to the first arena segment.\n-    first: Option<~TypedArenaChunk<T>>,\n+    first: Option<Box<TypedArenaChunk<T>>>,\n }\n \n struct TypedArenaChunk<T> {\n     /// Pointer to the next arena segment.\n-    next: Option<~TypedArenaChunk<T>>,\n+    next: Option<Box<TypedArenaChunk<T>>>,\n \n     /// The number of elements that this chunk can hold.\n     capacity: uint,\n@@ -354,7 +354,8 @@ struct TypedArenaChunk<T> {\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    fn new(next: Option<~TypedArenaChunk<T>>, capacity: uint) -> ~TypedArenaChunk<T> {\n+    fn new(next: Option<Box<TypedArenaChunk<T>>>, capacity: uint)\n+           -> Box<TypedArenaChunk<T>> {\n         let mut size = mem::size_of::<TypedArenaChunk<T>>();\n         size = round_up(size, mem::min_align_of::<T>());\n         let elem_size = mem::size_of::<T>();\n@@ -363,7 +364,7 @@ impl<T> TypedArenaChunk<T> {\n \n         let mut chunk = unsafe {\n             let chunk = global_heap::exchange_malloc(size);\n-            let mut chunk: ~TypedArenaChunk<T> = cast::transmute(chunk);\n+            let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk\n         };"}, {"sha": "245040d791cff1cd3cee12c9c448a460588c018e", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -140,7 +140,8 @@ impl<K: TotalOrd, V> Node<K, V> {\n     }\n \n     ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n-    fn new_branch(vec: Vec<BranchElt<K, V>>, right: ~Node<K, V>) -> Node<K, V> {\n+    fn new_branch(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n+                  -> Node<K, V> {\n         BranchNode(Branch::new(vec, right))\n     }\n \n@@ -270,7 +271,7 @@ struct Leaf<K, V> {\n //Vector of values with children, plus a rightmost child (greater than all)\n struct Branch<K, V> {\n     elts: Vec<BranchElt<K,V>>,\n-    rightmost_child: ~Node<K, V>\n+    rightmost_child: Box<Node<K, V>>,\n }\n \n \n@@ -434,7 +435,8 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n \n impl<K: TotalOrd, V> Branch<K, V> {\n     ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n-    fn new(vec: Vec<BranchElt<K, V>>, right: ~Node<K, V>) -> Branch<K, V> {\n+    fn new(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n+           -> Branch<K, V> {\n         Branch {\n             elts: vec,\n             rightmost_child: right\n@@ -667,7 +669,7 @@ struct LeafElt<K, V> {\n \n //A BranchElt has a left child in insertion to a key-value pair.\n struct BranchElt<K, V> {\n-    left: ~Node<K, V>,\n+    left: Box<Node<K, V>>,\n     key: K,\n     value: V\n }\n@@ -719,7 +721,7 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n \n impl<K: TotalOrd, V> BranchElt<K, V> {\n     ///Creates a new BranchElt from a supplied key, value, and left child.\n-    fn new(k: K, v: V, n: ~Node<K, V>) -> BranchElt<K, V> {\n+    fn new(k: K, v: V, n: Box<Node<K, V>>) -> BranchElt<K, V> {\n         BranchElt {\n             left: n,\n             key: k,"}, {"sha": "6763b32afd03b31f73ea928142d967526f66da70", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,18 +15,17 @@\n //! DList implements the trait Deque. It should be imported with `use\n //! collections::deque::Deque`.\n \n-\n // DList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n //\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n use std::cast;\n-use std::mem::{replace, swap};\n-use std::ptr;\n use std::iter::Rev;\n use std::iter;\n+use std::mem::{replace, swap};\n+use std::ptr;\n \n use deque::Deque;\n \n@@ -37,7 +36,7 @@ pub struct DList<T> {\n     list_tail: Rawlink<Node<T>>,\n }\n \n-type Link<T> = Option<~Node<T>>;\n+type Link<T> = Option<Box<Node<T>>>;\n struct Rawlink<T> { p: *mut T }\n \n struct Node<T> {\n@@ -118,7 +117,8 @@ impl<T> Node<T> {\n }\n \n /// Set the .prev field on `next`, then return `Some(next)`\n-fn link_with_prev<T>(mut next: ~Node<T>, prev: Rawlink<Node<T>>) -> Link<T> {\n+fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n+                  -> Link<T> {\n     next.prev = prev;\n     Some(next)\n }\n@@ -150,7 +150,7 @@ impl<T> Mutable for DList<T> {\n impl<T> DList<T> {\n     /// Add a Node first in the list\n     #[inline]\n-    fn push_front_node(&mut self, mut new_head: ~Node<T>) {\n+    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n         match self.list_head {\n             None => {\n                 self.list_tail = Rawlink::some(new_head);\n@@ -168,7 +168,7 @@ impl<T> DList<T> {\n \n     /// Remove the first Node and return it, or None if the list is empty\n     #[inline]\n-    fn pop_front_node(&mut self) -> Option<~Node<T>> {\n+    fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n         self.list_head.take().map(|mut front_node| {\n             self.length -= 1;\n             match front_node.next.take() {\n@@ -181,7 +181,7 @@ impl<T> DList<T> {\n \n     /// Add a Node last in the list\n     #[inline]\n-    fn push_back_node(&mut self, mut new_tail: ~Node<T>) {\n+    fn push_back_node(&mut self, mut new_tail: Box<Node<T>>) {\n         match self.list_tail.resolve() {\n             None => return self.push_front_node(new_tail),\n             Some(tail) => {\n@@ -194,7 +194,7 @@ impl<T> DList<T> {\n \n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n-    fn pop_back_node(&mut self) -> Option<~Node<T>> {\n+    fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n         self.list_tail.resolve().map_or(None, |tail| {\n             self.length -= 1;\n             self.list_tail = tail.prev;\n@@ -245,7 +245,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|~Node{value, ..}| value)\n+        self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n \n     /// Add an element last in the list\n@@ -259,7 +259,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|~Node{value, ..}| value)\n+        self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n }\n \n@@ -432,7 +432,7 @@ impl<T> Drop for DList<T> {\n             match tail.resolve() {\n                 None => break,\n                 Some(prev) => {\n-                    prev.next.take(); // release ~Node<T>\n+                    prev.next.take(); // release Box<Node<T>>\n                     tail = prev.prev;\n                 }\n             }\n@@ -531,7 +531,7 @@ pub trait ListInsertion<A> {\n \n // private methods for MutItems\n impl<'a, A> MutItems<'a, A> {\n-    fn insert_next_node(&mut self, mut ins_node: ~Node<A>) {\n+    fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n         //\n@@ -671,24 +671,24 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m: DList<~int> = DList::new();\n+        let mut m: DList<Box<int>> = DList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n         m.push_front(box 1);\n-        assert_eq!(m.pop_front(), Some(~1));\n+        assert_eq!(m.pop_front(), Some(box 1));\n         m.push_back(box 2);\n         m.push_back(box 3);\n         assert_eq!(m.len(), 2);\n-        assert_eq!(m.pop_front(), Some(~2));\n-        assert_eq!(m.pop_front(), Some(~3));\n+        assert_eq!(m.pop_front(), Some(box 2));\n+        assert_eq!(m.pop_front(), Some(box 3));\n         assert_eq!(m.len(), 0);\n         assert_eq!(m.pop_front(), None);\n         m.push_back(box 1);\n         m.push_back(box 3);\n         m.push_back(box 5);\n         m.push_back(box 7);\n-        assert_eq!(m.pop_front(), Some(~1));\n+        assert_eq!(m.pop_front(), Some(box 1));\n \n         let mut n = DList::new();\n         n.push_front(2);"}, {"sha": "13297df902a077c8e407d7245d35ad4c35b6377a", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -57,7 +57,7 @@ struct LruEntry<K, V> {\n \n /// An LRU Cache.\n pub struct LruCache<K, V> {\n-    map: HashMap<KeyRef<K>, ~LruEntry<K, V>>,\n+    map: HashMap<KeyRef<K>, Box<LruEntry<K, V>>>,\n     max_size: uint,\n     head: *mut LruEntry<K, V>,\n }\n@@ -241,9 +241,9 @@ impl<K: Hash + TotalEq, V> Mutable for LruCache<K, V> {\n impl<K, V> Drop for LruCache<K, V> {\n     fn drop(&mut self) {\n         unsafe {\n-            let node: ~LruEntry<K, V> = cast::transmute(self.head);\n+            let node: Box<LruEntry<K, V>> = cast::transmute(self.head);\n             // Prevent compiler from trying to drop the un-initialized field in the sigil node.\n-            let ~LruEntry { key: k, value: v, .. } = node;\n+            let box LruEntry { key: k, value: v, .. } = node;\n             cast::forget(k);\n             cast::forget(v);\n         }"}, {"sha": "f9f4945efc789a876989a82ed171bebf72824297", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -270,24 +270,24 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = PriorityQueue::from_vec(vec!(~2, ~4, ~9));\n+        let mut heap = PriorityQueue::from_vec(vec!(box 2, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top() == ~9);\n+        assert!(*heap.top() == box 9);\n         heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top() == ~11);\n+        assert!(*heap.top() == box 11);\n         heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top() == ~11);\n+        assert!(*heap.top() == box 11);\n         heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top() == ~27);\n+        assert!(*heap.top() == box 27);\n         heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top() == ~27);\n+        assert!(*heap.top() == box 27);\n         heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top() == ~103);\n+        assert!(*heap.top() == box 103);\n     }\n \n     #[test]"}, {"sha": "fb02ddd6224c483719efb2a6ec209f4f509051be", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -465,7 +465,7 @@ mod test_map {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);\n-            assert_eq!(v, ~2);\n+            assert_eq!(v, box 2);\n         }\n         assert!(called);\n         m.insert(2, box 1);"}, {"sha": "eff20d309068fd864ca2dbdfdf6dcaed8ed5fbf8", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -36,7 +36,7 @@ use std::ptr;\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub struct TreeMap<K, V> {\n-    root: Option<~TreeNode<K, V>>,\n+    root: Option<Box<TreeNode<K, V>>>,\n     length: uint\n }\n \n@@ -79,7 +79,7 @@ impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n \n impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n-        let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n+        let mut current: &'a Option<Box<TreeNode<K, V>>> = &self.root;\n         loop {\n             match *current {\n               Some(ref r) => {\n@@ -157,7 +157,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n         let TreeMap { root: root, length: length } = self;\n         let stk = match root {\n             None => vec!(),\n-            Some(~tn) => vec!(tn)\n+            Some(box tn) => vec!(tn)\n         };\n         MoveEntries {\n             stack: stk,\n@@ -317,7 +317,7 @@ macro_rules! define_iterator {\n     ($name:ident,\n      $rev_name:ident,\n \n-     // the function to go from &m Option<~TreeNode> to *m TreeNode\n+     // the function to go from &m Option<Box<TreeNode>> to *m TreeNode\n      deref = $deref:ident,\n \n      // see comment on `addr!`, this is just an optional `mut`, but\n@@ -441,7 +441,7 @@ define_iterator! {\n     addr_mut = mut\n }\n \n-fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> *TreeNode<K, V> {\n+fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *TreeNode<K, V> {\n     match *node {\n         Some(ref n) => {\n             let n: &TreeNode<K, V> = *n;\n@@ -451,7 +451,8 @@ fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> *TreeNode<K, V> {\n     }\n }\n \n-fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n+fn mut_deref<K, V>(x: &mut Option<Box<TreeNode<K, V>>>)\n+             -> *mut TreeNode<K, V> {\n     match *x {\n         Some(ref mut n) => {\n             let n: &mut TreeNode<K, V> = *n;\n@@ -482,7 +483,7 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n             } = self.stack.pop().unwrap();\n \n             match left {\n-                Some(~left) => {\n+                Some(box left) => {\n                     let n = TreeNode {\n                         key: key,\n                         value: value,\n@@ -495,7 +496,7 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n                 }\n                 None => {\n                     match right {\n-                        Some(~right) => self.stack.push(right),\n+                        Some(box right) => self.stack.push(right),\n                         None => ()\n                     }\n                     self.remaining -= 1;\n@@ -759,8 +760,8 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for UnionItems<'a, T> {\n struct TreeNode<K, V> {\n     key: K,\n     value: V,\n-    left: Option<~TreeNode<K, V>>,\n-    right: Option<~TreeNode<K, V>>,\n+    left: Option<Box<TreeNode<K, V>>>,\n+    right: Option<Box<TreeNode<K, V>>>,\n     level: uint\n }\n \n@@ -773,7 +774,7 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n }\n \n // Remove left horizontal link by rotating right\n-fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n+fn skew<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.left.as_ref().map_or(false, |x| x.level == node.level) {\n         let mut save = node.left.take_unwrap();\n         swap(&mut node.left, &mut save.right); // save.right now None\n@@ -784,7 +785,7 @@ fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n \n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n-fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n+fn split<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.right.as_ref().map_or(false,\n       |x| x.right.as_ref().map_or(false, |y| y.level == node.level)) {\n         let mut save = node.right.take_unwrap();\n@@ -795,7 +796,7 @@ fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     }\n }\n \n-fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n+fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n                                 key: &K)\n                              -> Option<&'r mut V> {\n     match *node {\n@@ -810,7 +811,7 @@ fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n     }\n }\n \n-fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n+fn insert<K: TotalOrd, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                           key: K, value: V) -> Option<V> {\n     match *node {\n       Some(ref mut save) => {\n@@ -840,10 +841,10 @@ fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n     }\n }\n \n-fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n+fn remove<K: TotalOrd, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                           key: &K) -> Option<V> {\n-    fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n-                                 child: &mut Option<~TreeNode<K, V>>) {\n+    fn heir_swap<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>,\n+                                 child: &mut Option<Box<TreeNode<K, V>>>) {\n         // *could* be done without recursion, but it won't borrow check\n         for x in child.mut_iter() {\n             if x.right.is_some() {\n@@ -877,13 +878,13 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                     (remove(&mut save.left, key), true)\n                 } else {\n                     let new = save.left.take_unwrap();\n-                    let ~TreeNode{value, ..} = replace(save, new);\n+                    let box TreeNode{value, ..} = replace(save, new);\n                     *save = save.left.take_unwrap();\n                     (Some(value), true)\n                 }\n             } else if save.right.is_some() {\n                 let new = save.right.take_unwrap();\n-                let ~TreeNode{value, ..} = replace(save, new);\n+                let box TreeNode{value, ..} = replace(save, new);\n                 (Some(value), true)\n             } else {\n                 (None, false)\n@@ -919,7 +920,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n       }\n     }\n     return match node.take() {\n-        Some(~TreeNode{value, ..}) => Some(value), None => fail!()\n+        Some(box TreeNode{value, ..}) => Some(value), None => fail!()\n     };\n }\n \n@@ -959,7 +960,6 @@ impl<T: TotalOrd> Extendable<T> for TreeSet<T> {\n \n #[cfg(test)]\n mod test_treemap {\n-\n     use super::{TreeMap, TreeNode};\n \n     use rand::Rng;\n@@ -1053,8 +1053,8 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n-                                  parent: &~TreeNode<K, V>) {\n+    fn check_left<K: TotalOrd, V>(node: &Option<Box<TreeNode<K, V>>>,\n+                                  parent: &Box<TreeNode<K, V>>) {\n         match *node {\n           Some(ref r) => {\n             assert_eq!(r.key.cmp(&parent.key), Less);\n@@ -1066,8 +1066,8 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_right<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n-                                   parent: &~TreeNode<K, V>,\n+    fn check_right<K: TotalOrd, V>(node: &Option<Box<TreeNode<K, V>>>,\n+                                   parent: &Box<TreeNode<K, V>>,\n                                    parent_red: bool) {\n         match *node {\n           Some(ref r) => {"}, {"sha": "ce69ba00787cca52db503c382d30a27b75fbc9da", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,11 +10,11 @@\n \n //! Ordered containers with integer keys, implemented as radix tries (`TrieSet` and `TrieMap` types)\n \n-use std::mem;\n-use std::uint;\n use std::mem::init;\n-use std::slice;\n+use std::mem;\n use std::slice::{Items, MutItems};\n+use std::slice;\n+use std::uint;\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n@@ -23,7 +23,7 @@ static MASK: uint = SIZE - 1;\n static NUM_CHUNKS: uint = uint::BITS / SHIFT;\n \n enum Child<T> {\n-    Internal(~TrieNode<T>),\n+    Internal(Box<TrieNode<T>>),\n     External(uint, T),\n     Nothing\n }"}, {"sha": "478634c6ddafdbee5e92565a4407181e0d02f211", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -66,14 +66,15 @@ use syntax::parse::token::InternedString;\n #[macro_registrar]\n pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n     register(token::intern(\"fourcc\"),\n-        NormalTT(~BasicMacroExpander {\n+        NormalTT(box BasicMacroExpander {\n             expander: expand_syntax_ext,\n             span: None,\n         },\n         None));\n }\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     let (expr, endian) = parse_tts(cx, tts);\n \n     let little = match endian {"}, {"sha": "817f6348361390cf532af933d3ae4890cb8eca84", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -18,7 +18,7 @@ use std::slice;\n \n // Note 2: Once Dynamically Sized Types (DST) lands, it might be\n // reasonable to replace this with something like `enum MaybeOwned<'a,\n-// Sized? U>{ Owned(~U), Borrowed(&'a U) }`; and then `U` could be\n+// Sized? U>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n // instantiated with `[T]` or `str`, etc.  Of course, that would imply\n // removing the `Growable` variant, which relates to note 1 above.\n // Alternatively, we might add `MaybeOwned` for the general case but"}, {"sha": "eba15e6e6d5a8eaa568c916a8c4ab48c97361fcf", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,19 +17,19 @@\n \n use std::cast;\n use std::mem::replace;\n-use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausableIdleCallback,\n-                    Callback};\n+use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback};\n+use std::rt::rtio::{PausableIdleCallback, Callback};\n use std::unstable::sync::Exclusive;\n \n /// This is the only exported function from this module.\n-pub fn event_loop() -> ~EventLoop:Send {\n-    box BasicLoop::new() as ~EventLoop:Send\n+pub fn event_loop() -> Box<EventLoop:Send> {\n+    box BasicLoop::new() as Box<EventLoop:Send>\n }\n \n struct BasicLoop {\n     work: Vec<proc():Send>,             // pending work\n     idle: Option<*mut BasicPausable>, // only one is allowed\n-    remotes: Vec<(uint, ~Callback:Send)>,\n+    remotes: Vec<(uint, Box<Callback:Send>)>,\n     next_remote: uint,\n     messages: Exclusive<Vec<Message>>,\n }\n@@ -140,23 +140,24 @@ impl EventLoop for BasicLoop {\n     }\n \n     // FIXME: Seems like a really weird requirement to have an event loop provide.\n-    fn pausable_idle_callback(&mut self, cb: ~Callback:Send)\n-        -> ~PausableIdleCallback:Send\n-    {\n+    fn pausable_idle_callback(&mut self, cb: Box<Callback:Send>)\n+                              -> Box<PausableIdleCallback:Send> {\n         let callback = box BasicPausable::new(self, cb);\n         rtassert!(self.idle.is_none());\n         unsafe {\n             let cb_ptr: &*mut BasicPausable = cast::transmute(&callback);\n             self.idle = Some(*cb_ptr);\n         }\n-        callback as ~PausableIdleCallback:Send\n+        callback as Box<PausableIdleCallback:Send>\n     }\n \n-    fn remote_callback(&mut self, f: ~Callback:Send) -> ~RemoteCallback:Send {\n+    fn remote_callback(&mut self, f: Box<Callback:Send>)\n+                       -> Box<RemoteCallback:Send> {\n         let id = self.next_remote;\n         self.next_remote += 1;\n         self.remotes.push((id, f));\n-        box BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback:Send\n+        box BasicRemote::new(self.messages.clone(), id) as\n+            Box<RemoteCallback:Send>\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n@@ -197,12 +198,12 @@ impl Drop for BasicRemote {\n \n struct BasicPausable {\n     eloop: *mut BasicLoop,\n-    work: ~Callback:Send,\n+    work: Box<Callback:Send>,\n     active: bool,\n }\n \n impl BasicPausable {\n-    fn new(eloop: &mut BasicLoop, cb: ~Callback:Send) -> BasicPausable {\n+    fn new(eloop: &mut BasicLoop, cb: Box<Callback:Send>) -> BasicPausable {\n         BasicPausable {\n             active: false,\n             work: cb,"}, {"sha": "e5dd9c92358f0df0c65bec1612a33add63317309", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use stack::Stack;\n use std::uint;\n use std::cast::{transmute, transmute_mut_unsafe};\n-use stack::Stack;\n use std::rt::stack;\n use std::raw;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n-// FIXME #7761: It would be nice to define regs as `~Option<Registers>` since\n-// the registers are sometimes empty, but the discriminant would\n+// FIXME #7761: It would be nice to define regs as `Box<Option<Registers>>`\n+// since the registers are sometimes empty, but the discriminant would\n // then misalign the regs again.\n pub struct Context {\n     /// Hold the registers while the task or scheduler is suspended\n-    regs: ~Registers,\n+    regs: Box<Registers>,\n     /// Lower bound and upper bound for the stack\n     stack_bounds: Option<(uint, uint)>,\n }\n@@ -87,10 +87,10 @@ impl Context {\n     pub fn swap(out_context: &mut Context, in_context: &Context) {\n         rtdebug!(\"swapping contexts\");\n         let out_regs: &mut Registers = match out_context {\n-            &Context { regs: ~ref mut r, .. } => r\n+            &Context { regs: box ref mut r, .. } => r\n         };\n         let in_regs: &Registers = match in_context {\n-            &Context { regs: ~ref r, .. } => r\n+            &Context { regs: box ref r, .. } => r\n         };\n \n         rtdebug!(\"noting the stack limit and doing raw swap\");\n@@ -151,7 +151,7 @@ struct Registers {\n }\n \n #[cfg(target_arch = \"x86\")]\n-fn new_regs() -> ~Registers {\n+fn new_regs() -> Box<Registers> {\n     box Registers {\n         eax: 0, ebx: 0, ecx: 0, edx: 0,\n         ebp: 0, esi: 0, edi: 0, esp: 0,\n@@ -190,9 +190,9 @@ type Registers = [uint, ..34];\n type Registers = [uint, ..22];\n \n #[cfg(windows, target_arch = \"x86_64\")]\n-fn new_regs() -> ~Registers { box [0, .. 34] }\n+fn new_regs() -> Box<Registers> { box [0, .. 34] }\n #[cfg(not(windows), target_arch = \"x86_64\")]\n-fn new_regs() -> ~Registers { box {let v = [0, .. 22]; v} }\n+fn new_regs() -> Box<Registers> { box {let v = [0, .. 22]; v} }\n \n #[cfg(target_arch = \"x86_64\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n@@ -241,7 +241,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n type Registers = [uint, ..32];\n \n #[cfg(target_arch = \"arm\")]\n-fn new_regs() -> ~Registers { box {[0, .. 32]} }\n+fn new_regs() -> Box<Registers> { box {[0, .. 32]} }\n \n #[cfg(target_arch = \"arm\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n@@ -270,7 +270,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n type Registers = [uint, ..32];\n \n #[cfg(target_arch = \"mips\")]\n-fn new_regs() -> ~Registers { box [0, .. 32] }\n+fn new_regs() -> Box<Registers> { box [0, .. 32] }\n \n #[cfg(target_arch = \"mips\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,"}, {"sha": "cd598346fc3e4cf47d28d3f55bc86299cbbf73ae", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -288,7 +288,7 @@ macro_rules! green_start( ($f:ident) => (\n /// The return value is used as the process return code. 0 on success, 101 on\n /// error.\n pub fn start(argc: int, argv: **u8,\n-             event_loop_factory: fn() -> ~rtio::EventLoop:Send,\n+             event_loop_factory: fn() -> Box<rtio::EventLoop:Send>,\n              main: proc():Send) -> int {\n     rt::init(argc, argv);\n     let mut main = Some(main);\n@@ -309,7 +309,7 @@ pub fn start(argc: int, argv: **u8,\n ///\n /// This function will not return until all schedulers in the associated pool\n /// have returned.\n-pub fn run(event_loop_factory: fn() -> ~rtio::EventLoop:Send,\n+pub fn run(event_loop_factory: fn() -> Box<rtio::EventLoop:Send>,\n            main: proc():Send) -> int {\n     // Create a scheduler pool and spawn the main task into this pool. We will\n     // get notified over a channel when the main task exits.\n@@ -340,7 +340,7 @@ pub struct PoolConfig {\n     pub threads: uint,\n     /// A factory function used to create new event loops. If this is not\n     /// specified then the default event loop factory is used.\n-    pub event_loop_factory: fn() -> ~rtio::EventLoop:Send,\n+    pub event_loop_factory: fn() -> Box<rtio::EventLoop:Send>,\n }\n \n impl PoolConfig {\n@@ -360,12 +360,12 @@ pub struct SchedPool {\n     id: uint,\n     threads: Vec<Thread<()>>,\n     handles: Vec<SchedHandle>,\n-    stealers: Vec<deque::Stealer<~task::GreenTask>>,\n+    stealers: Vec<deque::Stealer<Box<task::GreenTask>>>,\n     next_friend: uint,\n     stack_pool: StackPool,\n-    deque_pool: deque::BufferPool<~task::GreenTask>,\n+    deque_pool: deque::BufferPool<Box<task::GreenTask>>,\n     sleepers: SleeperList,\n-    factory: fn() -> ~rtio::EventLoop:Send,\n+    factory: fn() -> Box<rtio::EventLoop:Send>,\n     task_state: TaskState,\n     tasks_done: Receiver<()>,\n }\n@@ -445,7 +445,7 @@ impl SchedPool {\n     /// This is useful to create a task which can then be sent to a specific\n     /// scheduler created by `spawn_sched` (and possibly pin it to that\n     /// scheduler).\n-    pub fn task(&mut self, opts: TaskOpts, f: proc():Send) -> ~GreenTask {\n+    pub fn task(&mut self, opts: TaskOpts, f: proc():Send) -> Box<GreenTask> {\n         GreenTask::configure(&mut self.stack_pool, opts, f)\n     }\n "}, {"sha": "301198a0676400caf2e61ca8a30310c877623611", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 69, "deletions": 61, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -46,10 +46,10 @@ pub struct Scheduler {\n     /// inside this pool of schedulers\n     pub task_state: TaskState,\n     /// There are N work queues, one per scheduler.\n-    work_queue: deque::Worker<~GreenTask>,\n+    work_queue: deque::Worker<Box<GreenTask>>,\n     /// Work queues for the other schedulers. These are created by\n     /// cloning the core work queues.\n-    work_queues: Vec<deque::Stealer<~GreenTask>>,\n+    work_queues: Vec<deque::Stealer<Box<GreenTask>>>,\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n@@ -71,7 +71,7 @@ pub struct Scheduler {\n     no_sleep: bool,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n-    sched_task: Option<~GreenTask>,\n+    sched_task: Option<Box<GreenTask>>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     cleanup_job: Option<CleanupJob>,\n@@ -83,7 +83,7 @@ pub struct Scheduler {\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A togglable idle callback\n-    idle_callback: Option<~PausableIdleCallback:Send>,\n+    idle_callback: Option<Box<PausableIdleCallback:Send>>,\n     /// A countdown that starts at a random value and is decremented\n     /// every time a yield check is performed. When it hits 0 a task\n     /// will yield.\n@@ -100,7 +100,7 @@ pub struct Scheduler {\n     //      destroyed before it's actually destroyed.\n \n     /// The event loop used to drive the scheduler and perform I/O\n-    pub event_loop: ~EventLoop:Send,\n+    pub event_loop: Box<EventLoop:Send>,\n }\n \n /// An indication of how hard to work on a given operation, the difference\n@@ -123,9 +123,9 @@ impl Scheduler {\n     // * Initialization Functions\n \n     pub fn new(pool_id: uint,\n-               event_loop: ~EventLoop:Send,\n-               work_queue: deque::Worker<~GreenTask>,\n-               work_queues: Vec<deque::Stealer<~GreenTask>>,\n+               event_loop: Box<EventLoop:Send>,\n+               work_queue: deque::Worker<Box<GreenTask>>,\n+               work_queues: Vec<deque::Stealer<Box<GreenTask>>>,\n                sleeper_list: SleeperList,\n                state: TaskState)\n         -> Scheduler {\n@@ -136,9 +136,9 @@ impl Scheduler {\n     }\n \n     pub fn new_special(pool_id: uint,\n-                       event_loop: ~EventLoop:Send,\n-                       work_queue: deque::Worker<~GreenTask>,\n-                       work_queues: Vec<deque::Stealer<~GreenTask>>,\n+                       event_loop: Box<EventLoop:Send>,\n+                       work_queue: deque::Worker<Box<GreenTask>>,\n+                       work_queues: Vec<deque::Stealer<Box<GreenTask>>>,\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>,\n@@ -183,7 +183,7 @@ impl Scheduler {\n     pub fn bootstrap(mut ~self) {\n \n         // Build an Idle callback.\n-        let cb = box SchedRunner as ~Callback:Send;\n+        let cb = box SchedRunner as Box<Callback:Send>;\n         self.idle_callback = Some(self.event_loop.pausable_idle_callback(cb));\n \n         // Create a task for the scheduler with an empty context.\n@@ -224,14 +224,14 @@ impl Scheduler {\n \n     // This does not return a scheduler, as the scheduler is placed\n     // inside the task.\n-    pub fn run(mut ~self, stask: ~GreenTask) -> ~GreenTask {\n+    pub fn run(mut ~self, stask: Box<GreenTask>) -> Box<GreenTask> {\n \n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n         // mutable reference to the event_loop to give it the \"run\"\n         // command.\n         unsafe {\n-            let event_loop: *mut ~EventLoop:Send = &mut self.event_loop;\n+            let event_loop: *mut Box<EventLoop:Send> = &mut self.event_loop;\n             // Our scheduler must be in the task before the event loop\n             // is started.\n             stask.put_with_sched(self);\n@@ -271,7 +271,7 @@ impl Scheduler {\n     // If we try really hard to do some work, but no work is available to be\n     // done, then we fall back to epoll() to block this thread waiting for more\n     // work (instead of busy waiting).\n-    fn run_sched_once(mut ~self, stask: ~GreenTask) {\n+    fn run_sched_once(mut ~self, stask: Box<GreenTask>) {\n         // Make sure that we're not lying in that the `stask` argument is indeed\n         // the scheduler task for this scheduler.\n         assert!(self.sched_task.is_none());\n@@ -349,9 +349,9 @@ impl Scheduler {\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(mut ~self, stask: ~GreenTask,\n+    fn interpret_message_queue(mut ~self, stask: Box<GreenTask>,\n                                effort: EffortLevel)\n-            -> (~Scheduler, ~GreenTask, bool)\n+            -> (Box<Scheduler>, Box<GreenTask>, bool)\n     {\n \n         let msg = if effort == DontTryTooHard {\n@@ -432,8 +432,8 @@ impl Scheduler {\n         }\n     }\n \n-    fn do_work(mut ~self,\n-               stask: ~GreenTask) -> (~Scheduler, ~GreenTask, bool) {\n+    fn do_work(mut ~self, stask: Box<GreenTask>)\n+               -> (Box<Scheduler>, Box<GreenTask>, bool) {\n         rtdebug!(\"scheduler calling do work\");\n         match self.find_work() {\n             Some(task) => {\n@@ -459,7 +459,7 @@ impl Scheduler {\n     // First step in the process is to find a task. This function does\n     // that by first checking the local queue, and if there is no work\n     // there, trying to steal from the remote work queues.\n-    fn find_work(&mut self) -> Option<~GreenTask> {\n+    fn find_work(&mut self) -> Option<Box<GreenTask>> {\n         rtdebug!(\"scheduler looking for work\");\n         if !self.steal_for_yield {\n             match self.work_queue.pop() {\n@@ -497,7 +497,7 @@ impl Scheduler {\n     // Try stealing from all queues the scheduler knows about. This\n     // naive implementation can steal from our own queue or from other\n     // special schedulers.\n-    fn try_steals(&mut self) -> Option<~GreenTask> {\n+    fn try_steals(&mut self) -> Option<Box<GreenTask>> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n         let start_index = self.rng.gen_range(0, len);\n@@ -517,9 +517,11 @@ impl Scheduler {\n     // * Task Routing Functions - Make sure tasks send up in the right\n     // place.\n \n-    fn process_task(mut ~self, cur: ~GreenTask,\n-                    mut next: ~GreenTask,\n-                    schedule_fn: SchedulingFn) -> (~Scheduler, ~GreenTask) {\n+    fn process_task(mut ~self,\n+                    cur: Box<GreenTask>,\n+                    mut next: Box<GreenTask>,\n+                    schedule_fn: SchedulingFn)\n+                    -> (Box<Scheduler>, Box<GreenTask>) {\n         rtdebug!(\"processing a task\");\n \n         match next.take_unwrap_home() {\n@@ -549,7 +551,7 @@ impl Scheduler {\n         }\n     }\n \n-    fn send_task_home(task: ~GreenTask) {\n+    fn send_task_home(task: Box<GreenTask>) {\n         let mut task = task;\n         match task.take_unwrap_home() {\n             HomeSched(mut home_handle) => home_handle.send(PinnedTask(task)),\n@@ -559,7 +561,7 @@ impl Scheduler {\n \n     /// Take a non-homed task we aren't allowed to run here and send\n     /// it to the designated friend scheduler to execute.\n-    fn send_to_friend(&mut self, task: ~GreenTask) {\n+    fn send_to_friend(&mut self, task: Box<GreenTask>) {\n         rtdebug!(\"sending a task to friend\");\n         match self.friend_handle {\n             Some(ref mut handle) => {\n@@ -576,7 +578,7 @@ impl Scheduler {\n     /// Pushes the task onto the work stealing queue and tells the\n     /// event loop to run it later. Always use this instead of pushing\n     /// to the work queue directly.\n-    pub fn enqueue_task(&mut self, task: ~GreenTask) {\n+    pub fn enqueue_task(&mut self, task: Box<GreenTask>) {\n \n         // We push the task onto our local queue clone.\n         assert!(!task.is_sched());\n@@ -609,9 +611,10 @@ impl Scheduler {\n     // old task as inputs.\n \n     pub fn change_task_context(mut ~self,\n-                               current_task: ~GreenTask,\n-                               mut next_task: ~GreenTask,\n-                               f: |&mut Scheduler, ~GreenTask|) -> ~GreenTask {\n+                               current_task: Box<GreenTask>,\n+                               mut next_task: Box<GreenTask>,\n+                               f: |&mut Scheduler, Box<GreenTask>|)\n+                               -> Box<GreenTask> {\n         let f_opaque = ClosureConverter::from_fn(f);\n \n         let current_task_dupe = &*current_task as *GreenTask;\n@@ -655,7 +658,7 @@ impl Scheduler {\n         // When the context swaps back to this task we immediately\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n-        let mut current_task: ~GreenTask = unsafe {\n+        let mut current_task: Box<GreenTask> = unsafe {\n             cast::transmute(current_task_dupe)\n         };\n         current_task.sched.get_mut_ref().run_cleanup_job();\n@@ -688,8 +691,10 @@ impl Scheduler {\n \n     // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self, cur: ~GreenTask,\n-                                   next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+    pub fn resume_task_immediately(~self,\n+                                   cur: Box<GreenTask>,\n+                                   next: Box<GreenTask>)\n+                                   -> (Box<Scheduler>, Box<GreenTask>) {\n         assert!(cur.is_sched());\n         let mut cur = self.change_task_context(cur, next, |sched, stask| {\n             assert!(sched.sched_task.is_none());\n@@ -698,9 +703,10 @@ impl Scheduler {\n         (cur.sched.take_unwrap(), cur)\n     }\n \n-    fn resume_task_immediately_cl(sched: ~Scheduler,\n-                                  cur: ~GreenTask,\n-                                  next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+    fn resume_task_immediately_cl(sched: Box<Scheduler>,\n+                                  cur: Box<GreenTask>,\n+                                  next: Box<GreenTask>)\n+                                  -> (Box<Scheduler>, Box<GreenTask>) {\n         sched.resume_task_immediately(cur, next)\n     }\n \n@@ -726,7 +732,7 @@ impl Scheduler {\n     /// guaranteed that this function will not return before the given closure\n     /// has returned.\n     pub fn deschedule_running_task_and_then(mut ~self,\n-                                            cur: ~GreenTask,\n+                                            cur: Box<GreenTask>,\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n@@ -736,8 +742,8 @@ impl Scheduler {\n     }\n \n     pub fn switch_running_tasks_and_then(~self,\n-                                         cur: ~GreenTask,\n-                                         next: ~GreenTask,\n+                                         cur: Box<GreenTask>,\n+                                         next: Box<GreenTask>,\n                                          f: |&mut Scheduler, BlockedTask|) {\n         // And here comes one of the sad moments in which a lock is used in a\n         // core portion of the rust runtime. As always, this is highly\n@@ -768,8 +774,10 @@ impl Scheduler {\n         cur.put();\n     }\n \n-    fn switch_task(sched: ~Scheduler, cur: ~GreenTask,\n-                   next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+    fn switch_task(sched: Box<Scheduler>,\n+                   cur: Box<GreenTask>,\n+                   next: Box<GreenTask>)\n+                   -> (Box<Scheduler>, Box<GreenTask>) {\n         let mut cur = sched.change_task_context(cur, next, |sched, last_task| {\n             if last_task.is_sched() {\n                 assert!(sched.sched_task.is_none());\n@@ -785,7 +793,7 @@ impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(mut ~self, cur: ~GreenTask) -> ! {\n+    pub fn terminate_current_task(mut ~self, cur: Box<GreenTask>) -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();\n@@ -797,13 +805,13 @@ impl Scheduler {\n         fail!(\"should never return!\");\n     }\n \n-    pub fn run_task(~self, cur: ~GreenTask, next: ~GreenTask) {\n+    pub fn run_task(~self, cur: Box<GreenTask>, next: Box<GreenTask>) {\n         let (sched, task) =\n             self.process_task(cur, next, Scheduler::switch_task);\n         task.put_with_sched(sched);\n     }\n \n-    pub fn run_task_later(mut cur: ~GreenTask, next: ~GreenTask) {\n+    pub fn run_task_later(mut cur: Box<GreenTask>, next: Box<GreenTask>) {\n         let mut sched = cur.sched.take_unwrap();\n         sched.enqueue_task(next);\n         cur.put_with_sched(sched);\n@@ -813,7 +821,7 @@ impl Scheduler {\n     /// to introduce some amount of randomness to the scheduler. Currently the\n     /// randomness is a result of performing a round of work stealing (which\n     /// may end up stealing from the current scheduler).\n-    pub fn yield_now(mut ~self, cur: ~GreenTask) {\n+    pub fn yield_now(mut ~self, cur: Box<GreenTask>) {\n         // Async handles trigger the scheduler by calling yield_now on the local\n         // task, which eventually gets us to here. See comments in SchedRunner\n         // for more info on this.\n@@ -832,7 +840,7 @@ impl Scheduler {\n         }\n     }\n \n-    pub fn maybe_yield(mut ~self, cur: ~GreenTask) {\n+    pub fn maybe_yield(mut ~self, cur: Box<GreenTask>) {\n         // It's possible for sched tasks to possibly call this function, and it\n         // just means that they're likely sending on channels (which\n         // occasionally call this function). Sched tasks follow different paths\n@@ -881,20 +889,20 @@ impl Scheduler {\n \n // Supporting types\n \n-type SchedulingFn = fn (~Scheduler, ~GreenTask, ~GreenTask)\n-                            -> (~Scheduler, ~GreenTask);\n+type SchedulingFn = fn(Box<Scheduler>, Box<GreenTask>, Box<GreenTask>)\n+                       -> (Box<Scheduler>, Box<GreenTask>);\n \n pub enum SchedMessage {\n     Wake,\n     Shutdown,\n-    NewNeighbor(deque::Stealer<~GreenTask>),\n-    PinnedTask(~GreenTask),\n-    TaskFromFriend(~GreenTask),\n-    RunOnce(~GreenTask),\n+    NewNeighbor(deque::Stealer<Box<GreenTask>>),\n+    PinnedTask(Box<GreenTask>),\n+    TaskFromFriend(Box<GreenTask>),\n+    RunOnce(Box<GreenTask>),\n }\n \n pub struct SchedHandle {\n-    remote: ~RemoteCallback:Send,\n+    remote: Box<RemoteCallback:Send>,\n     queue: msgq::Producer<SchedMessage>,\n     pub sched_id: uint\n }\n@@ -920,18 +928,18 @@ impl Callback for SchedRunner {\n         // This function could be converted to `GreenTask::convert` if\n         // absolutely necessary, but for cleanliness it is much better to not\n         // use the conversion function.\n-        let task: ~Task = Local::take();\n+        let task: Box<Task> = Local::take();\n         task.yield_now();\n     }\n }\n \n struct CleanupJob {\n-    task: ~GreenTask,\n+    task: Box<GreenTask>,\n     f: UnsafeTaskReceiver\n }\n \n impl CleanupJob {\n-    pub fn new(task: ~GreenTask, f: UnsafeTaskReceiver) -> CleanupJob {\n+    pub fn new(task: Box<GreenTask>, f: UnsafeTaskReceiver) -> CleanupJob {\n         CleanupJob {\n             task: task,\n             f: f\n@@ -948,14 +956,14 @@ impl CleanupJob {\n // complaining\n type UnsafeTaskReceiver = raw::Closure;\n trait ClosureConverter {\n-    fn from_fn(|&mut Scheduler, ~GreenTask|) -> Self;\n-    fn to_fn(self) -> |&mut Scheduler, ~GreenTask|;\n+    fn from_fn(|&mut Scheduler, Box<GreenTask>|) -> Self;\n+    fn to_fn(self) -> |&mut Scheduler, Box<GreenTask>|;\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: |&mut Scheduler, ~GreenTask|) -> UnsafeTaskReceiver {\n+    fn from_fn(f: |&mut Scheduler, Box<GreenTask>|) -> UnsafeTaskReceiver {\n         unsafe { cast::transmute(f) }\n     }\n-    fn to_fn(self) -> |&mut Scheduler, ~GreenTask| {\n+    fn to_fn(self) -> |&mut Scheduler, Box<GreenTask>| {\n         unsafe { cast::transmute(self) }\n     }\n }\n@@ -1218,7 +1226,7 @@ mod test {\n             // Signal from the special task that we are done.\n             let (tx, rx) = channel::<()>();\n \n-            fn run(next: ~GreenTask) {\n+            fn run(next: Box<GreenTask>) {\n                 let mut task = GreenTask::convert(Local::take());\n                 let sched = task.sched.take_unwrap();\n                 sched.run_task(task, next)"}, {"sha": "007084fa14d783c15a3ace318f286084482c7f5c", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -28,7 +28,7 @@ struct SimpleTask {\n impl Runtime for SimpleTask {\n     // Implement the simple tasks of descheduling and rescheduling, but only in\n     // a simple number of cases.\n-    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n+    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         assert!(times == 1);\n \n@@ -55,7 +55,7 @@ impl Runtime for SimpleTask {\n         }\n         Local::put(cur_task);\n     }\n-    fn reawaken(mut ~self, mut to_wake: ~Task) {\n+    fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n         let me = &mut *self as *mut SimpleTask;\n         to_wake.put_runtime(self);\n         unsafe {\n@@ -70,18 +70,21 @@ impl Runtime for SimpleTask {\n     // purpose. A \"simple task\" is just that, a very simple task that can't\n     // really do a whole lot. The only purpose of the task is to get us off our\n     // feet and running.\n-    fn yield_now(~self, _cur_task: ~Task) { fail!() }\n-    fn maybe_yield(~self, _cur_task: ~Task) { fail!() }\n-    fn spawn_sibling(~self, _cur_task: ~Task, _opts: TaskOpts, _f: proc():Send) {\n+    fn yield_now(~self, _cur_task: Box<Task>) { fail!() }\n+    fn maybe_yield(~self, _cur_task: Box<Task>) { fail!() }\n+    fn spawn_sibling(~self,\n+                     _cur_task: Box<Task>,\n+                     _opts: TaskOpts,\n+                     _f: proc():Send) {\n         fail!()\n     }\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n     fn stack_bounds(&self) -> (uint, uint) { fail!() }\n     fn can_block(&self) -> bool { true }\n-    fn wrap(~self) -> ~Any { fail!() }\n+    fn wrap(~self) -> Box<Any> { fail!() }\n }\n \n-pub fn task() -> ~Task {\n+pub fn task() -> Box<Task> {\n     let mut task = box Task::new();\n     task.put_runtime(box SimpleTask {\n         lock: unsafe {NativeMutex::new()},"}, {"sha": "bc7752e98ea5ef7e855b0e5dbc49b133ddd33f3f", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -50,12 +50,12 @@ pub struct GreenTask {\n \n     /// Slot for maintaining ownership of a scheduler. If a task is running,\n     /// this value will be Some(sched) where the task is running on \"sched\".\n-    pub sched: Option<~Scheduler>,\n+    pub sched: Option<Box<Scheduler>>,\n \n     /// Temporary ownership slot of a std::rt::task::Task object. This is used\n     /// to squirrel that libstd task away while we're performing green task\n     /// operations.\n-    pub task: Option<~Task>,\n+    pub task: Option<Box<Task>>,\n \n     /// Dictates whether this is a sched task or a normal green task\n     pub task_type: TaskType,\n@@ -85,8 +85,8 @@ pub enum Home {\n /// for all green tasks. This code is actually called after the initial context\n /// switch onto a green thread.\n ///\n-/// The first argument to this function is the `~GreenTask` pointer, and the\n-/// next two arguments are the user-provided procedure for running code.\n+/// The first argument to this function is the `Box<GreenTask>` pointer, and\n+/// the next two arguments are the user-provided procedure for running code.\n ///\n /// The goal for having this weird-looking function is to reduce the number of\n /// allocations done on a green-task startup as much as possible.\n@@ -96,8 +96,8 @@ extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n         cast::transmute(raw::Procedure { code: code, env: env })\n     };\n \n-    // Acquire ownership of the `~GreenTask`\n-    let mut task: ~GreenTask = unsafe { cast::transmute(task) };\n+    // Acquire ownership of the `Box<GreenTask>`\n+    let mut task: Box<GreenTask> = unsafe { cast::transmute(task) };\n \n     // First code after swap to this new context. Run our cleanup job\n     task.pool_id = {\n@@ -129,15 +129,15 @@ impl GreenTask {\n     /// and will not have any contained Task structure.\n     pub fn new(stack_pool: &mut StackPool,\n                stack_size: Option<uint>,\n-               start: proc():Send) -> ~GreenTask {\n+               start: proc():Send) -> Box<GreenTask> {\n         GreenTask::new_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     /// Creates a new task (like `new`), but specifies the home for new task.\n     pub fn new_homed(stack_pool: &mut StackPool,\n                      stack_size: Option<uint>,\n                      home: Home,\n-                     start: proc():Send) -> ~GreenTask {\n+                     start: proc():Send) -> Box<GreenTask> {\n         // Allocate ourselves a GreenTask structure\n         let mut ops = GreenTask::new_typed(None, TypeGreen(Some(home)));\n \n@@ -158,7 +158,7 @@ impl GreenTask {\n     /// Creates a new green task with the specified coroutine and type, this is\n     /// useful when creating scheduler tasks.\n     pub fn new_typed(coroutine: Option<Coroutine>,\n-                     task_type: TaskType) -> ~GreenTask {\n+                     task_type: TaskType) -> Box<GreenTask> {\n         box GreenTask {\n             pool_id: 0,\n             coroutine: coroutine,\n@@ -175,7 +175,7 @@ impl GreenTask {\n     /// new stack for this task.\n     pub fn configure(pool: &mut StackPool,\n                      opts: TaskOpts,\n-                     f: proc():Send) -> ~GreenTask {\n+                     f: proc():Send) -> Box<GreenTask> {\n         let TaskOpts {\n             notify_chan, name, stack_size,\n             stderr, stdout,\n@@ -204,7 +204,7 @@ impl GreenTask {\n     ///\n     /// This function will assert that the task is indeed a green task before\n     /// returning (and will kill the entire process if this is wrong).\n-    pub fn convert(mut task: ~Task) -> ~GreenTask {\n+    pub fn convert(mut task: Box<Task>) -> Box<GreenTask> {\n         match task.maybe_take_runtime::<GreenTask>() {\n             Some(mut green) => {\n                 green.put_task(task);\n@@ -270,22 +270,24 @@ impl GreenTask {\n         self as *GreenTask as uint\n     }\n \n-    pub unsafe fn from_uint(val: uint) -> ~GreenTask { cast::transmute(val) }\n+    pub unsafe fn from_uint(val: uint) -> Box<GreenTask> {\n+        cast::transmute(val)\n+    }\n \n     // Runtime glue functions and helpers\n \n-    pub fn put_with_sched(mut ~self, sched: ~Scheduler) {\n+    pub fn put_with_sched(mut ~self, sched: Box<Scheduler>) {\n         assert!(self.sched.is_none());\n         self.sched = Some(sched);\n         self.put();\n     }\n \n-    pub fn put_task(&mut self, task: ~Task) {\n+    pub fn put_task(&mut self, task: Box<Task>) {\n         assert!(self.task.is_none());\n         self.task = Some(task);\n     }\n \n-    pub fn swap(mut ~self) -> ~Task {\n+    pub fn swap(mut ~self) -> Box<Task> {\n         let mut task = self.task.take_unwrap();\n         task.put_runtime(self);\n         return task;\n@@ -331,19 +333,19 @@ impl GreenTask {\n }\n \n impl Runtime for GreenTask {\n-    fn yield_now(mut ~self, cur_task: ~Task) {\n+    fn yield_now(mut ~self, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n         let sched = self.sched.take_unwrap();\n         sched.yield_now(self);\n     }\n \n-    fn maybe_yield(mut ~self, cur_task: ~Task) {\n+    fn maybe_yield(mut ~self, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n         let sched = self.sched.take_unwrap();\n         sched.maybe_yield(self);\n     }\n \n-    fn deschedule(mut ~self, times: uint, cur_task: ~Task,\n+    fn deschedule(mut ~self, times: uint, cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         self.put_task(cur_task);\n         let mut sched = self.sched.take_unwrap();\n@@ -392,14 +394,14 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn reawaken(mut ~self, to_wake: ~Task) {\n+    fn reawaken(mut ~self, to_wake: Box<Task>) {\n         self.put_task(to_wake);\n         assert!(self.sched.is_none());\n \n         // Optimistically look for a local task, but if one's not available to\n         // inspect (in order to see if it's in the same sched pool as we are),\n         // then just use our remote wakeup routine and carry on!\n-        let mut running_task: ~Task = match Local::try_take() {\n+        let mut running_task: Box<Task> = match Local::try_take() {\n             Some(task) => task,\n             None => return self.reawaken_remotely()\n         };\n@@ -443,7 +445,10 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn spawn_sibling(mut ~self, cur_task: ~Task, opts: TaskOpts, f: proc():Send) {\n+    fn spawn_sibling(mut ~self,\n+                     cur_task: Box<Task>,\n+                     opts: TaskOpts,\n+                     f: proc():Send) {\n         self.put_task(cur_task);\n \n         // Spawns a task into the current scheduler. We allocate the new task's\n@@ -477,7 +482,7 @@ impl Runtime for GreenTask {\n \n     fn can_block(&self) -> bool { false }\n \n-    fn wrap(~self) -> ~Any { self as ~Any }\n+    fn wrap(~self) -> Box<Any> { self as Box<Any> }\n }\n \n #[cfg(test)]\n@@ -572,7 +577,7 @@ mod tests {\n         let (tx, rx) = channel();\n         spawn_opts(TaskOpts::new(), proc() {\n             spawn(proc() {\n-                let mut task: ~Task = Local::take();\n+                let mut task: Box<Task> = Local::take();\n                 match task.maybe_take_runtime::<GreenTask>() {\n                     Some(ops) => {\n                         task.put_runtime(ops);"}, {"sha": "aea8a358f7ffbf80bc002d2f037c3cc310a4c988", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -61,7 +61,7 @@ use syntax::parse::token;\n #[macro_registrar]\n pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n     register(token::intern(\"hexfloat\"),\n-        NormalTT(~BasicMacroExpander {\n+        NormalTT(box BasicMacroExpander {\n             expander: expand_syntax_ext,\n             span: None,\n         },\n@@ -97,7 +97,8 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, ~str)> {\n     }\n }\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     let (expr, ty_lit) = parse_tts(cx, tts);\n \n     let ty = match ty_lit {"}, {"sha": "035a81f414369c03e696e26027b99429c3441faf", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -158,7 +158,7 @@ pub static WARN: u32 = 2;\n /// Error log level\n pub static ERROR: u32 = 1;\n \n-local_data_key!(local_logger: ~Logger:Send)\n+local_data_key!(local_logger: Box<Logger:Send>)\n \n /// A trait used to represent an interface to a task-local logger. Each task\n /// can have its own custom logger which can respond to logging messages\n@@ -229,7 +229,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n     let mut logger = local_data::pop(local_logger).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() } as ~Logger:Send\n+        box DefaultLogger { handle: io::stderr() } as Box<Logger:Send>\n     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),\n@@ -249,7 +249,7 @@ pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n \n /// Replaces the task-local logger with the specified logger, returning the old\n /// logger.\n-pub fn set_logger(logger: ~Logger:Send) -> Option<~Logger:Send> {\n+pub fn set_logger(logger: Box<Logger:Send>) -> Option<Box<Logger:Send>> {\n     let prev = local_data::pop(local_logger);\n     local_data::set(local_logger, logger);\n     return prev;\n@@ -351,7 +351,7 @@ fn init() {\n         // Schedule the cleanup for this global for when the runtime exits.\n         rt::at_exit(proc() {\n             assert!(!DIRECTIVES.is_null());\n-            let _directives: ~Vec<directive::LogDirective> =\n+            let _directives: Box<Vec<directive::LogDirective>> =\n                 cast::transmute(DIRECTIVES);\n             DIRECTIVES = 0 as *Vec<directive::LogDirective>;\n         });"}, {"sha": "2727f9a0b095a012834496859ac8a1425247cc21", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,12 +10,12 @@\n \n //! Blocking posix-based file I/O\n \n+use libc::{c_int, c_void};\n+use libc;\n use std::sync::arc::UnsafeArc;\n use std::c_str::CString;\n use std::io::IoError;\n use std::io;\n-use libc::{c_int, c_void};\n-use libc;\n use std::mem;\n use std::rt::rtio;\n \n@@ -175,8 +175,8 @@ impl rtio::RtioPipe for FileDesc {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         self.inner_write(buf)\n     }\n-    fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        box FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n+    fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n+        box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe:Send>\n     }\n }\n "}, {"sha": "018907303b84e351944bd6311355cdc39d39196b", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -207,8 +207,8 @@ impl rtio::RtioPipe for FileDesc {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         self.inner_write(buf)\n     }\n-    fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        box FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n+    fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n+        box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe:Send>\n     }\n }\n "}, {"sha": "58fcd60f13815495f7ba58b4ff9e34269f31b467", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -21,19 +21,19 @@\n //! play. The only dependencies of these modules are the normal system libraries\n //! that you would find on the respective platform.\n \n+use libc::c_int;\n+use libc;\n use std::c_str::CString;\n use std::io;\n use std::io::IoError;\n use std::io::net::ip::SocketAddr;\n use std::io::process::ProcessConfig;\n use std::io::signal::Signum;\n-use libc::c_int;\n-use libc;\n use std::os;\n use std::rt::rtio;\n-use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket,\n-                    RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess,\n-                    RtioSignal, RtioTTY, CloseBehavior, RtioTimer};\n+use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket};\n+use std::rt::rtio::{RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess};\n+use std::rt::rtio::{RtioSignal, RtioTTY, CloseBehavior, RtioTimer};\n use ai = std::io::net::addrinfo;\n \n // Local re-exports\n@@ -166,39 +166,50 @@ impl IoFactory {\n impl rtio::IoFactory for IoFactory {\n     // networking\n     fn tcp_connect(&mut self, addr: SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<~RtioTcpStream:Send> {\n-        net::TcpStream::connect(addr, timeout).map(|s| box s as ~RtioTcpStream:Send)\n+                   timeout: Option<u64>) -> IoResult<Box<RtioTcpStream:Send>> {\n+        net::TcpStream::connect(addr, timeout).map(|s| {\n+            box s as Box<RtioTcpStream:Send>\n+        })\n     }\n-    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send> {\n-        net::TcpListener::bind(addr).map(|s| box s as ~RtioTcpListener:Send)\n+    fn tcp_bind(&mut self, addr: SocketAddr)\n+                -> IoResult<Box<RtioTcpListener:Send>> {\n+        net::TcpListener::bind(addr).map(|s| {\n+            box s as Box<RtioTcpListener:Send>\n+        })\n     }\n-    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send> {\n-        net::UdpSocket::bind(addr).map(|u| box u as ~RtioUdpSocket:Send)\n+    fn udp_bind(&mut self, addr: SocketAddr)\n+                -> IoResult<Box<RtioUdpSocket:Send>> {\n+        net::UdpSocket::bind(addr).map(|u| box u as Box<RtioUdpSocket:Send>)\n     }\n-    fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener:Send> {\n-        pipe::UnixListener::bind(path).map(|s| box s as ~RtioUnixListener:Send)\n+    fn unix_bind(&mut self, path: &CString)\n+                 -> IoResult<Box<RtioUnixListener:Send>> {\n+        pipe::UnixListener::bind(path).map(|s| {\n+            box s as Box<RtioUnixListener:Send>\n+        })\n     }\n     fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<~RtioPipe:Send> {\n-        pipe::UnixStream::connect(path, timeout).map(|s| box s as ~RtioPipe:Send)\n+                    timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>> {\n+        pipe::UnixStream::connect(path, timeout).map(|s| {\n+            box s as Box<RtioPipe:Send>\n+        })\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {\n         addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n     }\n \n     // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: CloseBehavior) -> ~RtioFileStream:Send {\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n+                      -> Box<RtioFileStream:Send> {\n         let close = match close {\n             rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n             rtio::DontClose => false\n         };\n-        box file::FileDesc::new(fd, close) as ~RtioFileStream:Send\n+        box file::FileDesc::new(fd, close) as Box<RtioFileStream:Send>\n     }\n     fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<~RtioFileStream:Send> {\n-        file::open(path, fm, fa).map(|fd| box fd as ~RtioFileStream:Send)\n+        -> IoResult<Box<RtioFileStream:Send>> {\n+        file::open(path, fm, fa).map(|fd| box fd as Box<RtioFileStream:Send>)\n     }\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         file::unlink(path)\n@@ -244,27 +255,29 @@ impl rtio::IoFactory for IoFactory {\n     }\n \n     // misc\n-    fn timer_init(&mut self) -> IoResult<~RtioTimer:Send> {\n-        timer::Timer::new().map(|t| box t as ~RtioTimer:Send)\n+    fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>> {\n+        timer::Timer::new().map(|t| box t as Box<RtioTimer:Send>)\n     }\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> IoResult<(~RtioProcess:Send, ~[Option<~RtioPipe:Send>])> {\n+            -> IoResult<(Box<RtioProcess:Send>,\n+                         ~[Option<Box<RtioPipe:Send>>])> {\n         process::Process::spawn(config).map(|(p, io)| {\n-            (box p as ~RtioProcess:Send,\n-             io.move_iter().map(|p| p.map(|p| box p as ~RtioPipe:Send)).collect())\n+            (box p as Box<RtioProcess:Send>,\n+             io.move_iter().map(|p| p.map(|p| {\n+                 box p as Box<RtioPipe:Send>\n+             })).collect())\n         })\n     }\n     fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         process::Process::kill(pid, signum)\n     }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send> {\n-        Ok(box file::FileDesc::new(fd, true) as ~RtioPipe:Send)\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>> {\n+        Ok(box file::FileDesc::new(fd, true) as Box<RtioPipe:Send>)\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n-        -> IoResult<~RtioTTY:Send>\n-    {\n+                -> IoResult<Box<RtioTTY:Send>> {\n         if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(box file::FileDesc::new(fd, true) as ~RtioTTY:Send)\n+            Ok(box file::FileDesc::new(fd, true) as Box<RtioTTY:Send>)\n         } else {\n             Err(IoError {\n                 kind: io::MismatchedFileTypeForOperation,\n@@ -274,7 +287,7 @@ impl rtio::IoFactory for IoFactory {\n         }\n     }\n     fn signal(&mut self, _signal: Signum, _channel: Sender<Signum>)\n-        -> IoResult<~RtioSignal:Send> {\n+              -> IoResult<Box<RtioSignal:Send>> {\n         Err(unimpl())\n     }\n }"}, {"sha": "880cbaabaf80e6f90535feefdd2ac3ca77a61a4f", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -351,8 +351,10 @@ impl rtio::RtioTcpStream for TcpStream {\n         self.set_keepalive(None)\n     }\n \n-    fn clone(&self) -> ~rtio::RtioTcpStream:Send {\n-        box TcpStream { inner: self.inner.clone() } as ~rtio::RtioTcpStream:Send\n+    fn clone(&self) -> Box<rtio::RtioTcpStream:Send> {\n+        box TcpStream {\n+            inner: self.inner.clone(),\n+        } as Box<rtio::RtioTcpStream:Send>\n     }\n     fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe {\n@@ -418,8 +420,10 @@ impl TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor:Send> {\n-        self.native_listen(128).map(|a| box a as ~rtio::RtioTcpAcceptor:Send)\n+    fn listen(~self) -> IoResult<Box<rtio::RtioTcpAcceptor:Send>> {\n+        self.native_listen(128).map(|a| {\n+            box a as Box<rtio::RtioTcpAcceptor:Send>\n+        })\n     }\n }\n \n@@ -465,8 +469,8 @@ impl rtio::RtioSocket for TcpAcceptor {\n }\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream:Send> {\n-        self.native_accept().map(|s| box s as ~rtio::RtioTcpStream:Send)\n+    fn accept(&mut self) -> IoResult<Box<rtio::RtioTcpStream:Send>> {\n+        self.native_accept().map(|s| box s as Box<rtio::RtioTcpStream:Send>)\n     }\n \n     fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n@@ -637,7 +641,9 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         self.set_broadcast(false)\n     }\n \n-    fn clone(&self) -> ~rtio::RtioUdpSocket:Send {\n-        box UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket:Send\n+    fn clone(&self) -> Box<rtio::RtioUdpSocket:Send> {\n+        box UdpSocket {\n+            inner: self.inner.clone(),\n+        } as Box<rtio::RtioUdpSocket:Send>\n     }\n }"}, {"sha": "65e9c7448c2d51f33049f548c9db14f847651bf3", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -144,8 +144,10 @@ impl rtio::RtioPipe for UnixStream {\n         }\n     }\n \n-    fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        box UnixStream { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n+    fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n+        box UnixStream {\n+            inner: self.inner.clone(),\n+        } as Box<rtio::RtioPipe:Send>\n     }\n }\n \n@@ -176,8 +178,10 @@ impl UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> {\n-        self.native_listen(128).map(|a| box a as ~rtio::RtioUnixAcceptor:Send)\n+    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor:Send>> {\n+        self.native_listen(128).map(|a| {\n+            box a as Box<rtio::RtioUnixAcceptor:Send>\n+        })\n     }\n }\n \n@@ -209,8 +213,8 @@ impl UnixAcceptor {\n }\n \n impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n-        self.native_accept().map(|s| box s as ~rtio::RtioPipe:Send)\n+    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe:Send>> {\n+        self.native_accept().map(|s| box s as Box<rtio::RtioPipe:Send>)\n     }\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);"}, {"sha": "f1239285434faa8bb36af080050d20cc3bf98d21", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -353,12 +353,12 @@ impl rtio::RtioPipe for UnixStream {\n         Ok(())\n     }\n \n-    fn clone(&self) -> ~rtio::RtioPipe:Send {\n+    fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n         box UnixStream {\n             inner: self.inner.clone(),\n             read: None,\n             write: None,\n-        } as ~rtio::RtioPipe:Send\n+        } as Box<rtio::RtioPipe:Send>\n     }\n }\n \n@@ -402,8 +402,10 @@ impl Drop for UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> {\n-        self.native_listen().map(|a| box a as ~rtio::RtioUnixAcceptor:Send)\n+    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor:Send>> {\n+        self.native_listen().map(|a| {\n+            box a as Box<rtio::RtioUnixAcceptor:Send>\n+        })\n     }\n }\n \n@@ -526,8 +528,8 @@ impl UnixAcceptor {\n }\n \n impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n-        self.native_accept().map(|s| box s as ~rtio::RtioPipe:Send)\n+    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe:Send>> {\n+        self.native_accept().map(|s| box s as Box<rtio::RtioPipe:Send>)\n     }\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);"}, {"sha": "3bf967cb4263c0de9ac474f75902bf61743f68e6", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -86,7 +86,7 @@ fn shutdown() {\n     // Clean up after ther helper thread\n     unsafe {\n         imp::close(HELPER_SIGNAL);\n-        let _chan: ~Sender<Req> = cast::transmute(HELPER_CHAN);\n+        let _chan: Box<Sender<Req>> = cast::transmute(HELPER_CHAN);\n         HELPER_CHAN = 0 as *mut Sender<Req>;\n         HELPER_SIGNAL = 0 as imp::signal;\n     }"}, {"sha": "e008e6fb9e9057184f2f99d68e10731df97fd9aa", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -60,7 +60,7 @@ use io::timer_helper;\n \n pub struct Timer {\n     id: uint,\n-    inner: Option<~Inner>,\n+    inner: Option<Box<Inner>>,\n }\n \n struct Inner {\n@@ -74,11 +74,11 @@ struct Inner {\n #[allow(visible_private_types)]\n pub enum Req {\n     // Add a new timer to the helper thread.\n-    NewTimer(~Inner),\n+    NewTimer(Box<Inner>),\n \n     // Remove a timer based on its id and then send it back on the channel\n     // provided\n-    RemoveTimer(uint, Sender<~Inner>),\n+    RemoveTimer(uint, Sender<Box<Inner>>),\n \n     // Shut down the loop and then ACK this channel once it's shut down\n     Shutdown,\n@@ -102,19 +102,20 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n     // active timers are those which are able to be selected upon (and it's a\n     // sorted list, and dead timers are those which have expired, but ownership\n     // hasn't yet been transferred back to the timer itself.\n-    let mut active: Vec<~Inner> = vec![];\n+    let mut active: Vec<Box<Inner>> = vec![];\n     let mut dead = vec![];\n \n     // inserts a timer into an array of timers (sorted by firing time)\n-    fn insert(t: ~Inner, active: &mut Vec<~Inner>) {\n+    fn insert(t: Box<Inner>, active: &mut Vec<Box<Inner>>) {\n         match active.iter().position(|tm| tm.target > t.target) {\n             Some(pos) => { active.insert(pos, t); }\n             None => { active.push(t); }\n         }\n     }\n \n     // signals the first requests in the queue, possible re-enqueueing it.\n-    fn signal(active: &mut Vec<~Inner>, dead: &mut Vec<(uint, ~Inner)>) {\n+    fn signal(active: &mut Vec<Box<Inner>>,\n+              dead: &mut Vec<(uint, Box<Inner>)>) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n@@ -229,7 +230,7 @@ impl Timer {\n         }\n     }\n \n-    fn inner(&mut self) -> ~Inner {\n+    fn inner(&mut self) -> Box<Inner> {\n         match self.inner.take() {\n             Some(i) => i,\n             None => {"}, {"sha": "d5b02dc007b901474b84b0338e441f0835438a26", "filename": "src/libnative/task.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -31,15 +31,15 @@ use io;\n use task;\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n-pub fn new(stack_bounds: (uint, uint)) -> ~Task {\n+pub fn new(stack_bounds: (uint, uint)) -> Box<Task> {\n     let mut task = box Task::new();\n     let mut ops = ops();\n     ops.stack_bounds = stack_bounds;\n     task.put_runtime(ops);\n     return task;\n }\n \n-fn ops() -> ~Ops {\n+fn ops() -> Box<Ops> {\n     box Ops {\n         lock: unsafe { NativeMutex::new() },\n         awoken: false,\n@@ -119,22 +119,22 @@ struct Ops {\n }\n \n impl rt::Runtime for Ops {\n-    fn yield_now(~self, mut cur_task: ~Task) {\n+    fn yield_now(~self, mut cur_task: Box<Task>) {\n         // put the task back in TLS and then invoke the OS thread yield\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n         Thread::yield_now();\n     }\n \n-    fn maybe_yield(~self, mut cur_task: ~Task) {\n+    fn maybe_yield(~self, mut cur_task: Box<Task>) {\n         // just put the task back in TLS, on OS threads we never need to\n         // opportunistically yield b/c the OS will do that for us (preemption)\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n     }\n \n-    fn wrap(~self) -> ~Any {\n-        self as ~Any\n+    fn wrap(~self) -> Box<Any> {\n+        self as Box<Any>\n     }\n \n     fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }\n@@ -159,8 +159,8 @@ impl rt::Runtime for Ops {\n     // from the wakeup thread back to this thread about the task pointer, and\n     // there's really no need to. In order to get around this, we cast the task\n     // to a `uint` which is then used at the end of this function to cast back\n-    // to a `~Task` object. Naturally, this looks like it violates ownership\n-    // semantics in that there may be two `~Task` objects.\n+    // to a `Box<Task>` object. Naturally, this looks like it violates\n+    // ownership semantics in that there may be two `Box<Task>` objects.\n     //\n     // The fun part is that the wakeup half of this implementation knows to\n     // \"forget\" the task on the other end. This means that the awakening half of\n@@ -180,7 +180,7 @@ impl rt::Runtime for Ops {\n     // `awoken` field which indicates whether we were actually woken up via some\n     // invocation of `reawaken`. This flag is only ever accessed inside the\n     // lock, so there's no need to make it atomic.\n-    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n+    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         let me = &mut *self as *mut Ops;\n         cur_task.put_runtime(self);\n@@ -238,7 +238,7 @@ impl rt::Runtime for Ops {\n \n     // See the comments on `deschedule` for why the task is forgotten here, and\n     // why it's valid to do so.\n-    fn reawaken(mut ~self, mut to_wake: ~Task) {\n+    fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n         unsafe {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self);\n@@ -249,7 +249,10 @@ impl rt::Runtime for Ops {\n         }\n     }\n \n-    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc():Send) {\n+    fn spawn_sibling(~self,\n+                     mut cur_task: Box<Task>,\n+                     opts: TaskOpts,\n+                     f: proc():Send) {\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n \n@@ -342,7 +345,7 @@ mod tests {\n         let (tx, rx) = channel();\n         spawn(proc() {\n             spawn(proc() {\n-                let mut task: ~Task = Local::take();\n+                let mut task: Box<Task> = Local::take();\n                 match task.maybe_take_runtime::<Ops>() {\n                     Some(ops) => {\n                         task.put_runtime(ops);"}, {"sha": "d5a2c163a90d104da87e2ac1fdf9056e22c174b7", "filename": "src/librand/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -57,7 +57,7 @@ if rng.gen() { // bool\n ```\n \n ```rust\n-let tuple_ptr = rand::random::<~(f64, char)>();\n+let tuple_ptr = rand::random::<Box<(f64, char)>>();\n println!(\"{:?}\", tuple_ptr)\n ```\n */\n@@ -569,7 +569,7 @@ type TaskRngInner = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n /// The task-local RNG.\n pub struct TaskRng {\n     // This points into TLS (specifically, it points to the endpoint\n-    // of a ~ stored in TLS, to make it robust against TLS moving\n+    // of a Box stored in TLS, to make it robust against TLS moving\n     // things internally) and so this struct cannot be legally\n     // transferred between tasks *and* it's unsafe to deallocate the\n     // RNG other than when a task is finished.\n@@ -582,7 +582,7 @@ pub struct TaskRng {\n }\n \n // used to make space in TLS for a random number generator\n-local_data_key!(TASK_RNG_KEY: ~TaskRngInner)\n+local_data_key!(TASK_RNG_KEY: Box<TaskRngInner>)\n \n /// Retrieve the lazily-initialized task-local random number\n /// generator, seeded by the system. Intended to be used in method\n@@ -833,7 +833,9 @@ mod test {\n         let _f : f32 = random();\n         let _o : Option<Option<i8>> = random();\n         let _many : ((),\n-                     (~uint, @int, ~Option<~(@u32, ~(@bool,))>),\n+                     (Box<uint>,\n+                      @int,\n+                      Box<Option<Box<(@u32, Box<(@bool,)>)>>>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n                      (f32, (f64, (f64,)))) = random();\n     }"}, {"sha": "5846cb5f312cad42c0ebc0c1ea0148d6e47209b5", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -214,9 +214,9 @@ impl<T:Rand> Rand for Option<T> {\n     }\n }\n \n-impl<T: Rand> Rand for ~T {\n+impl<T: Rand> Rand for Box<T> {\n     #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> ~T { box rng.gen() }\n+    fn rand<R: Rng>(rng: &mut R) -> Box<T> { box rng.gen() }\n }\n \n impl<T: Rand + 'static> Rand for @T {"}, {"sha": "3a28f0d1ed5c213e3ff50bca006dfd267cca8e49", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -59,12 +59,12 @@ pub enum Ast {\n     Begin(Flags),\n     End(Flags),\n     WordBoundary(Flags),\n-    Capture(uint, Option<~str>, ~Ast),\n+    Capture(uint, Option<~str>, Box<Ast>),\n     // Represent concatenation as a flat vector to avoid blowing the\n     // stack in the compiler.\n     Cat(Vec<Ast>),\n-    Alt(~Ast, ~Ast),\n-    Rep(~Ast, Repeater, Greed),\n+    Alt(Box<Ast>, Box<Ast>),\n+    Rep(Box<Ast>, Repeater, Greed),\n }\n \n #[deriving(Show, Eq, Clone)]\n@@ -245,7 +245,7 @@ impl<'a> Parser<'a> {\n                     // alternate and make it a capture.\n                     if cap.is_some() {\n                         let ast = try!(self.pop_ast());\n-                        self.push(Capture(cap.unwrap(), cap_name, ~ast));\n+                        self.push(Capture(cap.unwrap(), cap_name, box ast));\n                     }\n                 }\n                 '|' => {\n@@ -331,7 +331,7 @@ impl<'a> Parser<'a> {\n             _ => {}\n         }\n         let greed = try!(self.get_next_greedy());\n-        self.push(Rep(~ast, rep, greed));\n+        self.push(Rep(box ast, rep, greed));\n         Ok(())\n     }\n \n@@ -411,13 +411,13 @@ impl<'a> Parser<'a> {\n                         let flags = negated | (self.flags & FLAG_NOCASE);\n                         let mut ast = Class(combine_ranges(ranges), flags);\n                         for alt in alts.move_iter() {\n-                            ast = Alt(~alt, ~ast)\n+                            ast = Alt(box alt, box ast)\n                         }\n                         self.push(ast);\n                     } else if alts.len() > 0 {\n                         let mut ast = alts.pop().unwrap();\n                         for alt in alts.move_iter() {\n-                            ast = Alt(~alt, ~ast)\n+                            ast = Alt(box alt, box ast)\n                         }\n                         self.push(ast);\n                     }\n@@ -548,7 +548,7 @@ impl<'a> Parser<'a> {\n             for _ in iter::range(0, min) {\n                 self.push(ast.clone())\n             }\n-            self.push(Rep(~ast, ZeroMore, greed));\n+            self.push(Rep(box ast, ZeroMore, greed));\n         } else {\n             // Require N copies of what's on the stack and then repeat it\n             // up to M times optionally.\n@@ -558,7 +558,7 @@ impl<'a> Parser<'a> {\n             }\n             if max.is_some() {\n                 for _ in iter::range(min, max.unwrap()) {\n-                    self.push(Rep(~ast.clone(), ZeroOne, greed))\n+                    self.push(Rep(box ast.clone(), ZeroOne, greed))\n                 }\n             }\n             // It's possible that we popped something off the stack but\n@@ -842,7 +842,7 @@ impl<'a> Parser<'a> {\n         // thrown away). But be careful with overflow---we can't count on the\n         // open paren to be there.\n         if from > 0 { from = from - 1}\n-        let ast = try!(self.build_from(from, |l,r| Alt(~l, ~r)));\n+        let ast = try!(self.build_from(from, |l,r| Alt(box l, box r)));\n         self.push(ast);\n         Ok(())\n     }"}, {"sha": "c2d3872950f0b8c52d5b51bd21319a0205b17177", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -49,7 +49,7 @@ use regex::native::{\n #[macro_registrar]\n #[doc(hidden)]\n pub fn macro_registrar(register: |ast::Name, SyntaxExtension|) {\n-    let expander = ~BasicMacroExpander { expander: native, span: None };\n+    let expander = box BasicMacroExpander { expander: native, span: None };\n     register(token::intern(\"regex\"), NormalTT(expander, None))\n }\n \n@@ -76,7 +76,7 @@ pub fn macro_registrar(register: |ast::Name, SyntaxExtension|) {\n /// first before trying to understand the code generator. The implementation\n /// strategy is identical and vm.rs has comments and will be easier to follow.\n fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n-         -> ~MacResult {\n+          -> Box<MacResult> {\n     let regex = match parse(cx, tts) {\n         Some(r) => r,\n         // error is logged in 'parse' with cx.span_err"}, {"sha": "fc903db6d041ad3655b3e4671ba51dfceb4ae7e3", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -677,11 +677,11 @@ pub fn pretty_print_input(sess: Session,\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {\n-        None => box io::stdout() as ~Writer,\n+        None => box io::stdout() as Box<Writer>,\n         Some(p) => {\n             let r = io::File::create(&p);\n             match r {\n-                Ok(w) => box w as ~Writer,\n+                Ok(w) => box w as Box<Writer>,\n                 Err(e) => fail!(\"print-print failed to open {} due to {}\",\n                                 p.display(), e),\n             }"}, {"sha": "900fba831d9c187e32fcd89d2e730c2a0f9d3d75", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -229,7 +229,12 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, bounds }) => {\n+        ty::ty_trait(box ty::TyTrait {\n+                def_id,\n+                ref substs,\n+                store,\n+                bounds\n+            }) => {\n             mywrite!(w, \"x[{}|\", (cx.ds)(def_id));\n             enc_substs(w, cx, substs);\n             enc_trait_store(w, cx, store);"}, {"sha": "886876f82b3084908942477454bf133962e6534f", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -68,13 +68,13 @@ niceties. This means that if you have a type like:\n struct S { f: uint }\n ```\n \n-and a variable `a: ~S`, then the rust expression `a.f` would correspond\n+and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n to an `LV` of `(*a).f`.\n \n Here is the formal grammar for the types we'll consider:\n \n ```notrust\n-TY = () | S<'LT...> | ~TY | & 'LT MQ TY | @ MQ TY\n+TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY | @ MQ TY\n MQ = mut | imm | const\n ```\n \n@@ -97,7 +97,7 @@ Now, imagine we had a program like this:\n struct Foo { f: uint, g: uint }\n ...\n 'a: {\n-  let mut x: ~Foo = ...;\n+  let mut x: Box<Foo> = ...;\n   let y = &mut (*x).f;\n   x = ...;\n }\n@@ -310,7 +310,7 @@ MUTABILITY(LV.f, MQ)                // M-Field\n   MUTABILITY(LV, MQ)\n \n MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n-  TYPE(LV) = ~Ty\n+  TYPE(LV) = Box<Ty>\n   MUTABILITY(LV, MQ)\n ```\n \n@@ -420,7 +420,7 @@ The scope of a unique referent is the scope of the pointer, since\n the pointer itself `LV` goes out of scope:\n \n ```notrust\n-  SCOPE(*LV) = SCOPE(LV) if LV has type ~T\n+  SCOPE(*LV) = SCOPE(LV) if LV has type Box<T>\n ```\n \n The scope of a managed referent is also the scope of the pointer.  This\n@@ -459,7 +459,7 @@ LIFETIME(LV.f, LT, MQ)              // L-Field\n   LIFETIME(LV, LT, MQ)\n \n LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n-  TYPE(LV) = ~Ty\n+  TYPE(LV) = Box<Ty>\n   LIFETIME(LV, LT, MQ)\n ```\n \n@@ -595,7 +595,7 @@ on `LV`:\n \n ```notrust\n RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n-  TYPE(LV) = ~Ty\n+  TYPE(LV) = Box<Ty>\n   RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n ```\n \n@@ -967,8 +967,8 @@ moves/uninitializations of the variable that is being used.\n Let's look at a simple example:\n \n ```\n-fn foo(a: ~int) {\n-    let b: ~int;       // Gen bit 0.\n+fn foo(a: Box<int>) {\n+    let b: Box<int>;   // Gen bit 0.\n \n     if cond {          // Bits: 0\n         use(&*a);"}, {"sha": "96d0d0eaa2ff034b675c2cc0e717e0452584ca32", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -533,7 +533,10 @@ impl<'a> BorrowckCtxt<'a> {\n         fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msg: &'static str)\n                           -> &'static str {\n             match ty::get(ty).sty {\n-                ty::ty_closure(~ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) =>\n+                ty::ty_closure(box ty::ClosureTy {\n+                        store: ty::RegionTraitStore(..),\n+                        ..\n+                    }) =>\n                     \"a non-copyable stack closure (capture it in a new closure, \\\n                      e.g. `|x| f(x)`, to override)\",\n                 _ if ty::type_moves_by_default(tcx, ty) =>"}, {"sha": "169a7d32032bc81d8b75c4157b006df261ef87bd", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -321,7 +321,7 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n         });\n     }\n \n-    fn pretty_print_to(&self, wr: ~io::Writer,\n+    fn pretty_print_to(&self, wr: Box<io::Writer>,\n                        blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n         try!(ps.cbox(pprust::indent_unit));"}, {"sha": "f3a8b9d20d5f7e0b4328a994ca2385fbe18f52a2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -51,7 +51,7 @@ fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n struct MarkSymbolVisitor<'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: &'a ty::ctxt,\n-    live_symbols: ~HashSet<ast::NodeId>,\n+    live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n impl<'a> MarkSymbolVisitor<'a> {\n@@ -285,7 +285,7 @@ fn find_live(tcx: &ty::ctxt,\n              exported_items: &privacy::ExportedItems,\n              reachable_symbols: &NodeSet,\n              krate: &ast::Crate)\n-             -> ~HashSet<ast::NodeId> {\n+             -> Box<HashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, exported_items,\n                                             reachable_symbols, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n@@ -312,7 +312,7 @@ fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n \n struct DeadVisitor<'a> {\n     tcx: &'a ty::ctxt,\n-    live_symbols: ~HashSet<ast::NodeId>,\n+    live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n impl<'a> DeadVisitor<'a> {"}, {"sha": "402fe822661541bebac03d98a1fa5be26e777128", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -198,11 +198,11 @@ fn with_appropriate_checker(cx: &Context,\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_closure(~ty::ClosureTy {\n+        ty::ty_closure(box ty::ClosureTy {\n             store: ty::UniqTraitStore, bounds, ..\n         }) => b(|cx, fv| check_for_uniq(cx, fv, bounds)),\n \n-        ty::ty_closure(~ty::ClosureTy {\n+        ty::ty_closure(box ty::ClosureTy {\n             store: ty::RegionTraitStore(region, _), bounds, ..\n         }) => b(|cx, fv| check_for_block(cx, fv, bounds, region)),\n \n@@ -331,7 +331,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span: Span) {\n     check_cast_for_escaping_regions(cx, source_ty, target_ty, span);\n     match ty::get(target_ty).sty {\n-        ty::ty_trait(~ty::TyTrait { bounds, .. }) => {\n+        ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n             check_trait_cast_bounds(cx, span, source_ty, bounds);\n         }\n         _ => {}"}, {"sha": "3c8ce77fa873ee4ddbe5196431ebd44f42c81191", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -240,14 +240,14 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n     (\"owned_heap_memory\",\n      LintSpec {\n         lint: OwnedHeapMemory,\n-        desc: \"use of owned (~ type) heap memory\",\n+        desc: \"use of owned (Box type) heap memory\",\n         default: allow\n      }),\n \n     (\"heap_memory\",\n      LintSpec {\n         lint: HeapMemory,\n-        desc: \"use of any (~ type or @ type) heap memory\",\n+        desc: \"use of any (Box type or @ type) heap memory\",\n         default: allow\n      }),\n \n@@ -943,8 +943,13 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n                     n_box += 1;\n                 }\n                 ty::ty_uniq(_) |\n-                ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n-                ty::ty_closure(~ty::ClosureTy { store: ty::UniqTraitStore, .. }) => {\n+                ty::ty_trait(box ty::TyTrait {\n+                    store: ty::UniqTraitStore, ..\n+                }) |\n+                ty::ty_closure(box ty::ClosureTy {\n+                    store: ty::UniqTraitStore,\n+                    ..\n+                }) => {\n                     n_uniq += 1;\n                 }\n \n@@ -955,7 +960,7 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n \n         if n_uniq > 0 && lint != ManagedHeapMemory {\n             let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses owned (~ type) pointers: {}\", s);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n             cx.span_lint(lint, span, m);\n         }\n "}, {"sha": "8ff4430a65b6f2caa6daded1c2470dbe1b035591", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -173,21 +173,27 @@ pub enum deref_kind {\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n-        ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n-        ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n+        ty::ty_trait(box ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n+        ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n         }\n \n         ty::ty_rptr(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n-        ty::ty_trait(~ty::TyTrait { store: ty::RegionTraitStore(r, mutbl), .. }) => {\n+        ty::ty_trait(box ty::TyTrait {\n+                store: ty::RegionTraitStore(r, mutbl),\n+                ..\n+            }) => {\n             let kind = ty::BorrowKind::from_mutbl(mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n-        ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(r, _), ..}) => {\n+        ty::ty_closure(box ty::ClosureTy {\n+                store: ty::RegionTraitStore(r, _),\n+                ..\n+            }) => {\n             Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n "}, {"sha": "6f42769891ea5131d3cdf329ee8e3e85e8243f71", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -650,7 +650,6 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n          *        | VariantName(..., P&, ...)\n          *        | [ ..., P&, ... ]\n          *        | ( ..., P&, ... )\n-         *        | ~P&\n          *        | box P&\n          */\n \n@@ -704,7 +703,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n          *        | [ ..., E&, ... ]\n          *        | ( ..., E&, ... )\n          *        | {...; E&}\n-         *        | ~E&\n+         *        | box E&\n          *        | E& as ...\n          *        | ( E& )\n          */"}, {"sha": "b456ec224fe7e8e94fbdab35764d79e6f285d002", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -1155,7 +1155,7 @@ impl<'a> DynamicFailureHandler<'a> {\n enum FailureHandler<'a> {\n     Infallible,\n     JumpToBasicBlock(BasicBlockRef),\n-    DynamicFailureHandlerClass(~DynamicFailureHandler<'a>),\n+    DynamicFailureHandlerClass(Box<DynamicFailureHandler<'a>>),\n }\n \n impl<'a> FailureHandler<'a> {"}, {"sha": "1c955f52037e6ada5201f8a608058d6c18fbe2d1", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -248,9 +248,10 @@ pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n             if hint.is_ffi_safe() {\n                 return true;\n             }\n-            // Option<~T> and similar are used in FFI.  Rather than try to resolve type parameters\n-            // and recognize this case exactly, this overapproximates -- assuming that if a\n-            // non-C-like enum is being used in FFI then the user knows what they're doing.\n+            // Option<Box<T>> and similar are used in FFI.  Rather than try to\n+            // resolve type parameters and recognize this case exactly, this\n+            // overapproximates -- assuming that if a non-C-like enum is being\n+            // used in FFI then the user knows what they're doing.\n             if variants.iter().any(|vi| !vi.args.is_empty()) {\n                 return true;\n             }"}, {"sha": "b9b44b72b10da63649ba9ce40f34abe8deb0ed2b", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,6 +26,7 @@ use middle::ty;\n use syntax::ast;\n use util::ppaux::Repr;\n \n+\n pub struct CleanupScope<'a> {\n     // The id of this cleanup scope. If the id is None,\n     // this is a *temporary scope* that is pushed during trans to\n@@ -35,7 +36,7 @@ pub struct CleanupScope<'a> {\n     kind: CleanupScopeKind<'a>,\n \n     // Cleanups to run upon scope exit.\n-    cleanups: Vec<~Cleanup>,\n+    cleanups: Vec<Box<Cleanup>>,\n \n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n@@ -248,7 +249,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                self.ccx.tn.val_to_str(val),\n                ty.repr(self.ccx.tcx()));\n \n-        self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n+        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n     }\n \n     fn schedule_drop_immediate(&self,\n@@ -272,7 +273,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                self.ccx.tn.val_to_str(val),\n                ty.repr(self.ccx.tcx()));\n \n-        self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n+        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n     }\n \n     fn schedule_free_value(&self,\n@@ -291,12 +292,12 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                self.ccx.tn.val_to_str(val),\n                heap);\n \n-        self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n+        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n     }\n \n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: ~Cleanup) {\n+                      cleanup: Box<Cleanup>) {\n         match cleanup_scope {\n             AstScope(id) => self.schedule_clean_in_ast_scope(id, cleanup),\n             CustomScope(id) => self.schedule_clean_in_custom_scope(id, cleanup),\n@@ -305,7 +306,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: ~Cleanup) {\n+                                   cleanup: Box<Cleanup>) {\n         /*!\n          * Schedules a cleanup to occur upon exit from `cleanup_scope`.\n          * If `cleanup_scope` is not provided, then the cleanup is scheduled\n@@ -333,7 +334,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n     fn schedule_clean_in_custom_scope(&self,\n                                       custom_scope: CustomScopeIndex,\n-                                      cleanup: ~Cleanup) {\n+                                      cleanup: Box<Cleanup>) {\n         /*!\n          * Schedules a cleanup to occur in the top-most scope,\n          * which must be a temporary scope.\n@@ -909,13 +910,13 @@ pub trait CleanupMethods<'a> {\n                            heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: ~Cleanup);\n+                      cleanup: Box<Cleanup>);\n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: ~Cleanup);\n+                                   cleanup: Box<Cleanup>);\n     fn schedule_clean_in_custom_scope(&self,\n                                     custom_scope: CustomScopeIndex,\n-                                    cleanup: ~Cleanup);\n+                                    cleanup: Box<Cleanup>);\n     fn needs_invoke(&self) -> bool;\n     fn get_landing_pad(&'a self) -> BasicBlockRef;\n }"}, {"sha": "049a6930ab9fc832150c16154d72e375c7d5472b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -57,7 +57,7 @@ For example, the following simple type for a singly-linked list...\n ```\n struct List {\n     value: int,\n-    tail: Option<~List>,\n+    tail: Option<Box<List>>,\n }\n ```\n \n@@ -66,8 +66,8 @@ will generate the following callstack with a naive DFS algorithm:\n ```\n describe(t = List)\n   describe(t = int)\n-  describe(t = Option<~List>)\n-    describe(t = ~List)\n+  describe(t = Option<Box<List>>)\n+    describe(t = Box<List>)\n       describe(t = List) // at the beginning again...\n       ...\n ```\n@@ -211,15 +211,15 @@ pub struct FunctionDebugContext {\n }\n \n enum FunctionDebugContextRepr {\n-    FunctionDebugContext(~FunctionDebugContextData),\n+    FunctionDebugContext(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n \n impl FunctionDebugContext {\n     fn get_ref<'a>(&'a self, cx: &CrateContext, span: Span) -> &'a FunctionDebugContextData {\n         match self.repr {\n-            FunctionDebugContext(~ref data) => data,\n+            FunctionDebugContext(box ref data) => data,\n             DebugInfoDisabled => {\n                 cx.sess().span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n             }\n@@ -560,7 +560,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext(~ref function_debug_context) => {\n+        FunctionDebugContext(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_str(span));\n@@ -596,7 +596,7 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n     match fcx.debug_context.repr {\n-        FunctionDebugContext(~ref data) => {\n+        FunctionDebugContext(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -2227,7 +2227,12 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n         }\n-        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, ref bounds }) => {\n+        ty::ty_trait(box ty::TyTrait {\n+                def_id,\n+                ref substs,\n+                store,\n+                ref bounds\n+            }) => {\n             trait_metadata(cx, def_id, t, substs, store, bounds)\n         }\n         ty::ty_struct(def_id, ref substs) => {"}, {"sha": "56bf25613382c3df5a4045f47afde92c15da21f7", "filename": "src/librustc/middle/trans/doc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -31,7 +31,7 @@ expression functions depending on the kind of expression. We divide\n up expressions into:\n \n - **Datum expressions:** Those that most naturally yield values.\n-  Examples would be `22`, `~x`, or `a + b` (when not overloaded).\n+  Examples would be `22`, `box x`, or `a + b` (when not overloaded).\n - **DPS expressions:** Those that most naturally write into a location\n   in memory. Examples would be `foo()` or `Point { x: 3, y: 4 }`.\n - **Statement expressions:** That that do not generate a meaningful\n@@ -107,7 +107,7 @@ Somewhat surprisingly, not all lvalue expressions yield lvalue datums\n when trans'd. Ultimately the reason for this is to micro-optimize\n the resulting LLVM. For example, consider the following code:\n \n-    fn foo() -> ~int { ... }\n+    fn foo() -> Box<int> { ... }\n     let x = *foo();\n \n The expression `*foo()` is an lvalue, but if you invoke `expr::trans`,\n@@ -169,7 +169,7 @@ is fully initialized, then the cleanup will run and try to free or\n drop uninitialized memory. If the initialization itself produces\n byproducts that need to be freed, then you should use temporary custom\n scopes to ensure that those byproducts will get freed on unwind.  For\n-example, an expression like `~foo()` will first allocate a box in the\n+example, an expression like `box foo()` will first allocate a box in the\n heap and then call `foo()` -- if `foo()` should fail, this box needs\n to be *shallowly* freed.\n \n@@ -219,11 +219,11 @@ unwind, and only up until the point where execution succeeded, at\n which time the complete value should be stored in an lvalue or some\n other place where normal cleanup applies.\n \n-To spell it out, here is an example. Imagine an expression `~expr`.\n+To spell it out, here is an example. Imagine an expression `box expr`.\n We would basically:\n \n 1. Push a custom cleanup scope C.\n-2. Allocate the `~` box.\n+2. Allocate the box.\n 3. Schedule a shallow free in the scope C.\n 4. Trans `expr` into the box.\n 5. Pop the scope C."}, {"sha": "806fb3e125d8987bd7f3da31b8ea2bdbdddf6139", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -397,8 +397,8 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             DatumBlock(bcx, datum)\n         }\n         ast::ExprBox(_, contents) => {\n-            // Special case for `~T`. (The other case, for GC, is handled in\n-            // `trans_rvalue_dps_unadjusted`.)\n+            // Special case for `box T`. (The other case, for GC, is handled\n+            // in `trans_rvalue_dps_unadjusted`.)\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, contents);\n             trans_uniq_expr(bcx, box_ty, contents, contents_ty)\n@@ -1171,11 +1171,12 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n     // We need to a make a pointer type because box_ty is ty_bot\n-    // if content_ty is, e.g. ~fail!().\n+    // if content_ty is, e.g. box fail!().\n     let real_box_ty = ty::mk_uniq(bcx.tcx(), contents_ty);\n     let Result { bcx, val } = malloc_raw_dyn(bcx, real_box_ty, size);\n-    // Unique boxes do not allocate for zero-size types. The standard library may assume\n-    // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n+    // Unique boxes do not allocate for zero-size types. The standard library\n+    // may assume that `free` is never called on the pointer returned for\n+    // `Box<ZeroSizeType>`.\n     let bcx = if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n         trans_into(bcx, contents, SaveIn(val))\n     } else {\n@@ -1774,8 +1775,8 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n          * Basically, the idea is to make the deref of an rvalue\n          * result in an rvalue. This helps to avoid intermediate stack\n          * slots in the resulting LLVM. The idea here is that, if the\n-         * `~T` pointer is an rvalue, then we can schedule a *shallow*\n-         * free of the `~T` pointer, and then return a ByRef rvalue\n+         * `Box<T>` pointer is an rvalue, then we can schedule a *shallow*\n+         * free of the `Box<T>` pointer, and then return a ByRef rvalue\n          * into the pointer. Because the free is shallow, it is legit\n          * to return an rvalue, because we know that the contents are\n          * not yet scheduled to be freed. The language rules ensure that the"}, {"sha": "1bde80815c33f5c27db145d727df5296fad2644b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -89,7 +89,7 @@ fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n                     let llty = sizing_type_of(ccx, typ);\n                     // Unique boxes do not allocate for zero-size types. The standard\n                     // library may assume that `free` is never called on the pointer\n-                    // returned for `~ZeroSizeType`.\n+                    // returned for `Box<ZeroSizeType>`.\n                     if llsize_of_alloc(ccx, llty) == 0 {\n                         ty::mk_i8()\n                     } else {\n@@ -318,7 +318,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 }\n             }\n         }\n-        ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) => {\n+        ty::ty_trait(box ty::TyTrait { store: ty::UniqTraitStore, .. }) => {\n             let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n             // Only drop the value when it is non-null\n             with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {"}, {"sha": "b13444a4410aed6d5a9529dfad36e82b9aad32bb", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -344,7 +344,7 @@ fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n                           -> Callee<'a> {\n     /*!\n      * Create a method callee where the method is coming from a trait\n-     * object (e.g., ~Trait type).  In this case, we must pull the fn\n+     * object (e.g., Box<Trait> type).  In this case, we must pull the fn\n      * pointer out of the vtable that is packaged up with the object.\n      * Objects are represented as a pair, so we first evaluate the self\n      * expression and then extract the self data and vtable out of the\n@@ -401,7 +401,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n-    // Replace the self type (&Self or ~Self) with an opaque pointer.\n+    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref f) if f.abi == Rust => {\n             type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n@@ -527,8 +527,8 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n                             dest: expr::Dest)\n                             -> &'a Block<'a> {\n     /*!\n-     * Generates the code to convert from a pointer (`~T`, `&T`, etc)\n-     * into an object (`~Trait`, `&Trait`, etc). This means creating a\n+     * Generates the code to convert from a pointer (`Box<T>`, `&T`, etc)\n+     * into an object (`Box<Trait>`, `&Trait`, etc). This means creating a\n      * pair where the first word is the vtable and the second word is\n      * the pointer.\n      */"}, {"sha": "461d39240e8f73b2e7b7a5eb7bfbe8b7cb4b2921", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -128,7 +128,7 @@ pub struct mt {\n \n #[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum TraitStore {\n-    /// ~Trait\n+    /// Box<Trait>\n     UniqTraitStore,\n     /// &Trait and &mut Trait\n     RegionTraitStore(Region, ast::Mutability),\n@@ -229,7 +229,7 @@ pub enum AutoRef {\n     /// Convert from T to *T\n     AutoUnsafe(ast::Mutability),\n \n-    /// Convert from ~Trait/&Trait to &Trait\n+    /// Convert from Box<Trait>/&Trait to &Trait\n     AutoBorrowObj(Region, ast::Mutability),\n }\n \n@@ -239,7 +239,7 @@ pub enum AutoRef {\n pub struct ctxt {\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n-    pub interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n+    pub interner: RefCell<FnvHashMap<intern_key, Box<t_box_>>>,\n     pub next_id: Cell<uint>,\n     pub sess: Session,\n     pub def_map: resolve::DefMap,\n@@ -735,8 +735,8 @@ pub enum sty {\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n-    ty_closure(~ClosureTy),\n-    ty_trait(~TyTrait),\n+    ty_closure(Box<ClosureTy>),\n+    ty_trait(Box<TyTrait>),\n     ty_struct(DefId, substs),\n     ty_tup(Vec<t>),\n \n@@ -1195,7 +1195,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n       }\n-      &ty_trait(~ty::TyTrait { ref substs, store, .. }) => {\n+      &ty_trait(box ty::TyTrait { ref substs, store, .. }) => {\n           flags |= sflags(substs);\n           match store {\n               RegionTraitStore(r, _) => {\n@@ -1482,7 +1482,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n-        ty_trait(~TyTrait { ref substs, .. }) => {\n+        ty_trait(box TyTrait { ref substs, .. }) => {\n             for subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n         }\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n@@ -1951,7 +1951,7 @@ impl TypeContents {\n     pub fn owned_pointer(&self) -> TypeContents {\n         /*!\n          * Includes only those bits that still apply\n-         * when indirected through a `~` pointer\n+         * when indirected through a `Box` pointer\n          */\n         TC::OwnsOwned | (\n             *self & (TC::OwnsAll | TC::ReachesAll))\n@@ -2050,7 +2050,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // private cache for this walk.  This is needed in the case of cyclic\n         // types like:\n         //\n-        //     struct List { next: ~Option<List>, ... }\n+        //     struct List { next: Box<Option<List>>, ... }\n         //\n         // When computing the type contents of such a type, we wind up deeply\n         // recursing as we go.  So when we encounter the recursive reference\n@@ -2100,7 +2100,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_trait(~ty::TyTrait { store, bounds, .. }) => {\n+            ty_trait(box ty::TyTrait { store, bounds, .. }) => {\n                 object_contents(cx, store, bounds)\n             }\n \n@@ -2965,7 +2965,7 @@ pub fn adjust_ty(cx: &ctxt,\n     fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n                   m: ast::Mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_trait(~ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n+            ty_trait(box ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n                 ty::mk_trait(cx, def_id, substs.clone(),\n                              RegionTraitStore(r, m), bounds)\n             }\n@@ -3164,7 +3164,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                     // writing) it's not easy to distinguish casts to traits\n                     // from other casts based on the AST.  This should be\n                     // easier in the future, when casts to traits\n-                    // would like @Foo, ~Foo, or &Foo.\n+                    // would like @Foo, Box<Foo>, or &Foo.\n                     RvalueDatumExpr\n                 }\n             }\n@@ -3192,7 +3192,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         }\n \n         ast::ExprBox(place, _) => {\n-            // Special case `~T` for now:\n+            // Special case `Box<T>` for now:\n             let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n                 None => fail!(\"no def for place\"),\n@@ -3264,7 +3264,7 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> ~str {\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n         ty_box(_) => \"@-ptr\".to_owned(),\n-        ty_uniq(_) => \"~-ptr\".to_owned(),\n+        ty_uniq(_) => \"box\".to_owned(),\n         ty_vec(_, _) => \"vector\".to_owned(),\n         ty_ptr(_) => \"*-ptr\".to_owned(),\n         ty_rptr(_, _) => \"&-ptr\".to_owned(),\n@@ -3614,7 +3614,9 @@ pub fn try_add_builtin_trait(tcx: &ctxt,\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     match get(ty).sty {\n-        ty_trait(~TyTrait { def_id: id, .. }) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n+        ty_trait(box TyTrait { def_id: id, .. }) |\n+        ty_struct(id, _) |\n+        ty_enum(id, _) => Some(id),\n         _ => None\n     }\n }\n@@ -4575,7 +4577,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                     }\n                 }\n             }\n-            ty_trait(~ty::TyTrait { def_id: d, store, bounds, .. }) => {\n+            ty_trait(box ty::TyTrait { def_id: d, store, bounds, .. }) => {\n                 byte!(17);\n                 did(&mut state, d);\n                 match store {"}, {"sha": "4b0153b67fff493d1804f0275e44e0627af33c3d", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -149,8 +149,13 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, this.fold_substs(substs))\n         }\n-        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, bounds }) => {\n-            ty::ty_trait(box ty::TyTrait{\n+        ty::ty_trait(box ty::TyTrait {\n+                def_id,\n+                ref substs,\n+                store,\n+                bounds\n+            }) => {\n+            ty::ty_trait(box ty::TyTrait {\n                 def_id: def_id,\n                 substs: this.fold_substs(substs),\n                 store: this.fold_trait_store(store),"}, {"sha": "e3591af6440f7c275745601106e9de3f1b23d9cb", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -876,7 +876,8 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n     //! legal.\n     //! If no bounds were specified, we choose a \"default\" bound based on\n     //! the allocation type of the fn/trait, as per issue #7264. The user can\n-    //! override this with an empty bounds list, e.g. \"~fn:()\" or \"~Trait:\".\n+    //! override this with an empty bounds list, e.g. \"Box<fn:()>\" or\n+    //! \"Box<Trait:>\".\n \n     match (ast_bounds, store) {\n         (&Some(ref bound_vec), _) => {"}, {"sha": "e6a6a370b1330326b642d820fabc71c1e0b04fd6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -691,7 +691,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n     }\n }\n \n-// Helper function to check @, ~ and & patterns\n+// Helper function to check @, box and & patterns\n pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n                          inner: &ast::Pat,\n@@ -721,7 +721,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                              e, actual)})},\n                 Some(expected),\n                 format!(\"{} pattern\", match pointer_kind {\n-                    Send => \"a `~`-box\",\n+                    Send => \"a box\",\n                     Borrowed => \"an `&`-pointer\"\n                 }),\n                 None);"}, {"sha": "17a432d2b5d76c301b375b4d1997b8abb03c5e2a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -30,7 +30,7 @@ itself (note that inherent impls can only be defined in the same\n module as the type itself).\n \n Inherent candidates are not always derived from impls.  If you have a\n-trait instance, such as a value of type `~ToStr`, then the trait\n+trait instance, such as a value of type `Box<ToStr>`, then the trait\n methods (`to_str()`, in this case) are inherently associated with it.\n Another case is type parameters, in which case the methods of their\n bounds are inherent.\n@@ -72,9 +72,9 @@ Both the inherent candidate collection and the candidate selection\n proceed by progressively deref'ing the receiver type, after all.  The\n answer is that two phases are needed to elegantly deal with explicit\n self.  After all, if there is an impl for the type `Foo`, it can\n-define a method with the type `~self`, which means that it expects a\n-receiver of type `~Foo`.  If we have a receiver of type `~Foo`, but we\n-waited to search for that impl until we have deref'd the `~` away and\n+define a method with the type `Box<self>`, which means that it expects a\n+receiver of type `Box<Foo>`.  If we have a receiver of type `Box<Foo>`, but we\n+waited to search for that impl until we have deref'd the `Box` away and\n obtained the type `Foo`, we would never match this method.\n \n */\n@@ -243,15 +243,15 @@ fn construct_transformed_self_ty_for_object(\n         *\n         *     trait Foo {\n         *         fn r_method<'a>(&'a self);\n-        *         fn u_method(~self);\n+        *         fn u_method(Box<self>);\n         *     }\n         *\n         * Now, assuming that `r_method` is being called, we want the\n         * result to be `&'a Foo`. Assuming that `u_method` is being\n-        * called, we want the result to be `~Foo`. Of course,\n+        * called, we want the result to be `Box<Foo>`. Of course,\n         * this transformation has already been done as part of\n         * `method_ty.fty.sig.inputs[0]`, but there the type\n-        * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n+        * is expressed in terms of `Self` (i.e., `&'a Self`, `Box<Self>`).\n         * Because objects are not standalone types, we can't just substitute\n         * `s/Self/Foo/`, so we must instead perform this kind of hokey\n         * match below.\n@@ -328,8 +328,8 @@ struct Candidate {\n /// considered to \"match\" a given method candidate. Typically the test\n /// is whether the receiver is of a particular type. However, this\n /// type is the type of the receiver *after accounting for the\n-/// method's self type* (e.g., if the method is an `~self` method, we\n-/// have *already verified* that the receiver is of some type `~T` and\n+/// method's self type* (e.g., if the method is an `Box<self>` method, we\n+/// have *already verified* that the receiver is of some type `Box<T>` and\n /// now we must check that the type `T` is correct).  Unfortunately,\n /// because traits are not types, this is a pain to do.\n #[deriving(Clone)]\n@@ -421,14 +421,14 @@ impl<'a> LookupContext<'a> {\n          * `self.inherent_candidates`.  See comment at the start of\n          * the file.  To find the inherent candidates, we repeatedly\n          * deref the self-ty to find the \"base-type\".  So, for\n-         * example, if the receiver is ~~C where `C` is a struct type,\n+         * example, if the receiver is Box<Box<C>> where `C` is a struct type,\n          * we'll want to find the inherent impls for `C`.\n          */\n \n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n-                ty_trait(~TyTrait { def_id, ref substs, .. }) => {\n+                ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n                     self.push_inherent_candidates_from_object(def_id, substs);\n                     self.push_inherent_impl_candidates_for_type(def_id);\n                 }\n@@ -767,9 +767,9 @@ impl<'a> LookupContext<'a> {\n          * consuming the original pointer.\n          *\n          * You might think that this would be a natural byproduct of\n-         * the auto-deref/auto-ref process.  This is true for `~T`\n-         * but not for an `&mut T` receiver.  With `~T`, we would\n-         * begin by testing for methods with a self type `~T`,\n+         * the auto-deref/auto-ref process.  This is true for `Box<T>`\n+         * but not for an `&mut T` receiver.  With `Box<T>`, we would\n+         * begin by testing for methods with a self type `Box<T>`,\n          * then autoderef to `T`, then autoref to `&mut T`.  But with\n          * an `&mut T` receiver the process begins with `&mut T`, only\n          * without any autoadjustments.\n@@ -797,7 +797,7 @@ impl<'a> LookupContext<'a> {\n                      autoref: Some(auto)})\n             }\n \n-            ty::ty_trait(~ty::TyTrait {\n+            ty::ty_trait(box ty::TyTrait {\n                 def_id, ref substs, store: ty::RegionTraitStore(_, mutbl), bounds\n             }) => {\n                 let region =\n@@ -902,8 +902,13 @@ impl<'a> LookupContext<'a> {\n             },\n             ty_vec(mt, Some(_)) => self.auto_slice_vec(mt, autoderefs),\n \n-            ty_trait(~ty::TyTrait { def_id: trt_did, substs: trt_substs, bounds: b, .. }) => {\n-                // Coerce ~/&Trait instances to &Trait.\n+            ty_trait(box ty::TyTrait {\n+                    def_id: trt_did,\n+                    substs: trt_substs,\n+                    bounds: b,\n+                    ..\n+                }) => {\n+                // Coerce Box/&Trait instances to &Trait.\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n@@ -1361,7 +1366,7 @@ impl<'a> LookupContext<'a> {\n                         }\n                     }\n \n-                    ty::ty_trait(~ty::TyTrait {\n+                    ty::ty_trait(box ty::TyTrait {\n                         def_id: self_did, store: RegionTraitStore(_, self_m), ..\n                     }) => {\n                         mutability_matches(self_m, m) &&\n@@ -1382,7 +1387,7 @@ impl<'a> LookupContext<'a> {\n                         }\n                     }\n \n-                    ty::ty_trait(~ty::TyTrait {\n+                    ty::ty_trait(box ty::TyTrait {\n                         def_id: self_did, store: UniqTraitStore, ..\n                     }) => {\n                         rcvr_matches_object(self_did, candidate)"}, {"sha": "c352ba7e3a5c81defc73fb691566a75e3bf950ac", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -1912,7 +1912,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         let fn_sig = match *fn_sty {\n             ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, ..}) |\n-            ty::ty_closure(~ty::ClosureTy {sig: ref sig, ..}) => sig,\n+            ty::ty_closure(box ty::ClosureTy {sig: ref sig, ..}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n                     format!(\"expected function but \\"}, {"sha": "4c36a935dee334bb3cc4c8804b62acd6dfe44803", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -367,7 +367,7 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         // accessed. We must be wary of loops like this:\n         //\n         //     // from src/test/compile-fail/borrowck-lend-flow.rs\n-        //     let mut v = ~3, w = ~4;\n+        //     let mut v = box 3, w = box 4;\n         //     let mut x = &mut w;\n         //     loop {\n         //         **x += 1;   // (2)\n@@ -539,7 +539,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // explaining how it goes about doing that.\n             let target_ty = rcx.resolve_node_type(expr.id);\n             match ty::get(target_ty).sty {\n-                ty::ty_trait(~ty::TyTrait {\n+                ty::ty_trait(box ty::TyTrait {\n                     store: ty::RegionTraitStore(trait_region, _), ..\n                 }) => {\n                     let source_ty = rcx.resolve_expr_type_adjusted(source);\n@@ -609,7 +609,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let function_type = rcx.resolve_node_type(expr.id);\n     match ty::get(function_type).sty {\n-        ty::ty_closure(~ty::ClosureTy {\n+        ty::ty_closure(box ty::ClosureTy {\n                 store: ty::RegionTraitStore(region, _), ..}) => {\n             freevars::with_freevars(tcx, expr.id, |freevars| {\n                 if freevars.is_empty() {\n@@ -635,7 +635,10 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     rcx.set_repeating_scope(repeating_scope);\n \n     match ty::get(function_type).sty {\n-        ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n+        ty::ty_closure(box ty::ClosureTy {\n+                store: ty::RegionTraitStore(..),\n+                ..\n+            }) => {\n             freevars::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n             })"}, {"sha": "192c67eb8d1d9cfc7beae210f926e132f6b7119d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -532,7 +532,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t| {\n       match ty::get(target_ty).sty {\n           // Bounds of type's contents are not checked here, but in kind.rs.\n-          ty::ty_trait(~ty::TyTrait {\n+          ty::ty_trait(box ty::TyTrait {\n               def_id: target_def_id, substs: ref target_substs, store, ..\n           }) => {\n               fn mutability_allowed(a_mutbl: ast::Mutability,\n@@ -543,7 +543,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n               // Look up vtables for the type we're casting to,\n               // passing in the source and target type.  The source\n               // must be a pointer type suitable to the object sigil,\n-              // e.g.: `&x as &Trait` or `~x as ~Trait`\n+              // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n               let ty = structurally_resolved_type(fcx, ex.span,\n                                                   fcx.expr_ty(src));\n               match (&ty::get(ty).sty, store) {\n@@ -606,8 +606,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   (_, ty::UniqTraitStore) => {\n                       fcx.ccx.tcx.sess.span_err(\n                           ex.span,\n-                          format!(\"can only cast an ~-pointer \\\n-                                to a ~-object, not a {}\",\n+                          format!(\"can only cast an boxed pointer \\\n+                                   to a boxed object, not a {}\",\n                                ty::ty_sort_str(fcx.tcx(), ty)));\n                   }\n "}, {"sha": "c15c30656adcd4f959877865b645958ab8835d26", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -103,7 +103,7 @@ fn type_is_defined_in_local_crate(original_type: t) -> bool {\n     ty::walk_ty(original_type, |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n-            ty_trait(~ty::TyTrait { def_id, .. }) |\n+            ty_trait(box ty::TyTrait { def_id, .. }) |\n             ty_struct(def_id, _) => {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n@@ -129,7 +129,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n-                ty_trait(~ty::TyTrait { def_id, .. }) => {\n+                ty_trait(box ty::TyTrait { def_id, .. }) => {\n                     return Some(def_id);\n                 }\n                 _ => {"}, {"sha": "d50e36c31a0376c8c3da6f9bd5e92781e13104d7", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -121,7 +121,10 @@ impl<'f> Coerce<'f> {\n                 };\n             }\n \n-            ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n+            ty::ty_closure(box ty::ClosureTy {\n+                    store: ty::RegionTraitStore(..),\n+                    ..\n+                }) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n                 });\n@@ -133,7 +136,7 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_trait(~ty::TyTrait {\n+            ty::ty_trait(box ty::TyTrait {\n                 def_id, ref substs, store: ty::UniqTraitStore, bounds\n             }) => {\n                 let result = self.unpack_actual_value(a, |sty_a| {\n@@ -152,7 +155,7 @@ impl<'f> Coerce<'f> {\n                 }\n             }\n \n-            ty::ty_trait(~ty::TyTrait {\n+            ty::ty_trait(box ty::TyTrait {\n                 def_id, ref substs, store: ty::RegionTraitStore(region, m), bounds\n             }) => {\n                 let result = self.unpack_actual_value(a, |sty_a| {\n@@ -332,7 +335,12 @@ impl<'f> Coerce<'f> {\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         let a_borrowed = match *sty_a {\n-            ty::ty_trait(~ty::TyTrait { def_id, ref substs, bounds, .. }) => {\n+            ty::ty_trait(box ty::TyTrait {\n+                    def_id,\n+                    ref substs,\n+                    bounds,\n+                    ..\n+                }) => {\n                 ty::mk_trait(tcx, def_id, substs.clone(),\n                              ty::RegionTraitStore(r_a, b_mutbl), bounds)\n             }"}, {"sha": "20bd47b3022a2bba6069d91d1f2e9364e9e632a3", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -683,7 +683,7 @@ impl<'a> InferCtxt<'a> {\n                                   ty::EmptyBuiltinBounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n-            ty::ty_trait(~ty::TyTrait { ref def_id, ref substs, .. }) => {\n+            ty::ty_trait(box ty::TyTrait { ref def_id, ref substs, .. }) => {\n                 ty::TraitRef {\n                     def_id: *def_id,\n                     substs: (*substs).clone(),"}, {"sha": "1170244fbec7d2629dbab48c36da0ae443163a71", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -190,7 +190,7 @@ going on:\n         *p += 1; *p\n     }\n     fn weird() {\n-        let mut x: ~Foo = ~Foo { ... };\n+        let mut x: Box<Foo> = box Foo { ... };\n         'a: add(&mut (*x).f,\n                 'b: inc(&mut (*x).f)) // (..)\n     }\n@@ -243,11 +243,11 @@ this similar but unsound example:\n         *p += v;\n     }\n     ...\n-    fn consume(x: ~Foo) -> uint {\n+    fn consume(x: Box<Foo>) -> uint {\n         x.f + x.g\n     }\n     fn weird() {\n-        let mut x: ~Foo = ~Foo { ... };\n+        let mut x: Box<Foo> = box Foo { ... };\n         'a: add(&mut (*x).f, consume(x)) // (..)\n     }\n "}, {"sha": "df3af87b0f824f807d8bf2e8051f6a476f011e5a", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -741,7 +741,7 @@ impl<'a> ConstraintContext<'a> {\n                                                  substs, variance);\n             }\n \n-            ty::ty_trait(~ty::TyTrait { def_id, ref substs, .. }) => {\n+            ty::ty_trait(box ty::TyTrait { def_id, ref substs, .. }) => {\n                 let trait_def = ty::lookup_trait_def(self.tcx(), def_id);\n                 self.add_constraints_from_substs(def_id, &trait_def.generics,\n                                                  substs, variance);\n@@ -768,11 +768,15 @@ impl<'a> ConstraintContext<'a> {\n             }\n \n             ty::ty_bare_fn(ty::BareFnTy { ref sig, .. }) |\n-            ty::ty_closure(~ty::ClosureTy { ref sig, store: ty::UniqTraitStore, .. }) => {\n+            ty::ty_closure(box ty::ClosureTy {\n+                    ref sig,\n+                    store: ty::UniqTraitStore,\n+                    ..\n+                }) => {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_closure(~ty::ClosureTy { ref sig,\n+            ty::ty_closure(box ty::ClosureTy { ref sig,\n                     store: ty::RegionTraitStore(region, _), .. }) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(region, contra);"}, {"sha": "cf6466faba6f9ac3006a7172f1e4f104c08bbff2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -203,7 +203,7 @@ pub fn mt_to_str(cx: &ctxt, m: &mt) -> ~str {\n \n pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n-        ty::UniqTraitStore => \"~\".to_owned(),\n+        ty::UniqTraitStore => \"Box \".to_owned(),\n         ty::RegionTraitStore(r, m) => {\n             format!(\"{}{}\", region_ptr_to_str(cx, r), mutability_to_str(m))\n         }\n@@ -385,7 +385,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n                       did,\n                       false)\n       }\n-      ty_trait(~ty::TyTrait {\n+      ty_trait(box ty::TyTrait {\n           def_id: did, ref substs, store, ref bounds\n       }) => {\n         let base = ty::item_path_str(cx, did);\n@@ -500,7 +500,7 @@ impl<T:Repr> Repr for @T {\n     }\n }\n \n-impl<T:Repr> Repr for ~T {\n+impl<T:Repr> Repr for Box<T> {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n     }"}, {"sha": "f143b80338a3acf6c4a738bd8ab7e9bf9a55215e", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -684,26 +684,26 @@ pub enum Type {\n     Self(ast::NodeId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n     Primitive(ast::PrimTy),\n-    Closure(~ClosureDecl, Option<Lifetime>),\n-    Proc(~ClosureDecl),\n+    Closure(Box<ClosureDecl>, Option<Lifetime>),\n+    Proc(Box<ClosureDecl>),\n     /// extern \"ABI\" fn\n-    BareFunction(~BareFunctionDecl),\n+    BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n-    Vector(~Type),\n-    FixedVector(~Type, ~str),\n+    Vector(Box<Type>),\n+    FixedVector(Box<Type>, ~str),\n     String,\n     Bool,\n     /// aka TyNil\n     Unit,\n     /// aka TyBot\n     Bottom,\n-    Unique(~Type),\n-    Managed(~Type),\n-    RawPointer(Mutability, ~Type),\n+    Unique(Box<Type>),\n+    Managed(Box<Type>),\n+    RawPointer(Mutability, Box<Type>),\n     BorrowedRef {\n         pub lifetime: Option<Lifetime>,\n         pub mutability: Mutability,\n-        pub type_: ~Type,\n+        pub type_: Box<Type>,\n     },\n     // region, raw, other boxes, mutable\n }"}, {"sha": "f452be3277871776a95345742747a87933707514", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -83,8 +83,8 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader, class: Option<&\n         let klass = match next.tok {\n             // If this '&' token is directly adjacent to another token, assume\n             // that it's the address-of operator instead of the and-operator.\n-            // This allows us to give all pointers their own class (~ and @ are\n-            // below).\n+            // This allows us to give all pointers their own class (`Box` and\n+            // `@` are below).\n             t::BINOP(t::AND) if lexer.peek().sp.lo == next.sp.hi => \"kw-2\",\n             t::AT | t::TILDE => \"kw-2\",\n "}, {"sha": "4187a348bde29b2b9331a74014a247c95e3b2e08", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -36,8 +36,11 @@ use html::markdown;\n use passes;\n use visit_ast::RustdocVisitor;\n \n-pub fn run(input: &str, cfgs: Vec<~str>,\n-           libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n+pub fn run(input: &str,\n+           cfgs: Vec<~str>,\n+           libs: HashSet<Path>,\n+           mut test_args: Vec<~str>)\n+           -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n \n@@ -126,7 +129,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let old = io::stdio::set_stderr(box w1);\n     spawn(proc() {\n         let mut p = io::ChanReader::new(rx);\n-        let mut err = old.unwrap_or(box io::stderr() as ~Writer:Send);\n+        let mut err = old.unwrap_or(box io::stderr() as Box<Writer:Send>);\n         io::util::copy(&mut p, &mut err).unwrap();\n     });\n     let emitter = diagnostic::EmitterWriter::new(box w2);"}, {"sha": "fbacf1ca314fcd0446b23f798a5c822f6b674015", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,9 +15,9 @@\n /// (the uv event loop).\n \n use std::cast;\n-use std::sync::arc::UnsafeArc;\n-use std::rt::task::{BlockedTask, Task};\n use std::rt::local::Local;\n+use std::rt::task::{BlockedTask, Task};\n+use std::sync::arc::UnsafeArc;\n \n use homing::HomingMissile;\n \n@@ -52,7 +52,7 @@ impl Access {\n         let inner: &mut Inner = unsafe { cast::transmute(self.inner.get()) };\n \n         if inner.held {\n-            let t: ~Task = Local::take();\n+            let t: Box<Task> = Local::take();\n             t.deschedule(1, |task| {\n                 inner.queue.push(task);\n                 Ok(())"}, {"sha": "155dee3cfa82c5b1a2bb683ac1b70f308811ce14", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,12 +26,12 @@ pub struct AsyncWatcher {\n }\n \n struct Payload {\n-    callback: ~Callback:Send,\n+    callback: Box<Callback:Send>,\n     exit_flag: Exclusive<bool>,\n }\n \n impl AsyncWatcher {\n-    pub fn new(loop_: &mut Loop, cb: ~Callback:Send) -> AsyncWatcher {\n+    pub fn new(loop_: &mut Loop, cb: Box<Callback:Send>) -> AsyncWatcher {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         assert_eq!(unsafe {\n             uvll::uv_async_init(loop_.handle, handle, async_cb)\n@@ -93,7 +93,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n \n extern fn close_cb(handle: *uvll::uv_handle_t) {\n     // drop the payload\n-    let _payload: ~Payload = unsafe {\n+    let _payload: Box<Payload> = unsafe {\n         cast::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n     // and then free the handle"}, {"sha": "50825bab493b3b70dce96fc2cb85aaf330a3a847", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -100,7 +100,7 @@ pub trait HomingIO {\n         // to go (remember we have no preemption, so we're guaranteed to stay on\n         // this event loop as long as we avoid the scheduler).\n         if cur_loop_id != destination {\n-            let cur_task: ~Task = Local::take();\n+            let cur_task: Box<Task> = Local::take();\n             cur_task.deschedule(1, |task| {\n                 self.home().send(task);\n                 Ok(())"}, {"sha": "ba72e5db2731977256c634aefe024a0fded1031b", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -19,11 +19,11 @@ pub struct IdleWatcher {\n     handle: *uvll::uv_idle_t,\n     idle_flag: bool,\n     closed: bool,\n-    callback: ~Callback:Send,\n+    callback: Box<Callback:Send>,\n }\n \n impl IdleWatcher {\n-    pub fn new(loop_: &mut Loop, cb: ~Callback:Send) -> ~IdleWatcher {\n+    pub fn new(loop_: &mut Loop, cb: Box<Callback:Send>) -> Box<IdleWatcher> {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         assert_eq!(unsafe {\n             uvll::uv_idle_init(loop_.handle, handle)\n@@ -49,7 +49,7 @@ impl IdleWatcher {\n         extern fn onetime_cb(handle: *uvll::uv_idle_t) {\n             unsafe {\n                 let data = uvll::get_data_for_uv_handle(handle);\n-                let f: ~proc() = cast::transmute(data);\n+                let f: Box<proc()> = cast::transmute(data);\n                 (*f)();\n                 assert_eq!(uvll::uv_idle_stop(handle), 0);\n                 uvll::uv_close(handle, close_cb);\n@@ -126,16 +126,16 @@ mod test {\n         }\n     }\n \n-    fn mk(v: uint) -> (~IdleWatcher, Chan) {\n+    fn mk(v: uint) -> (Box<IdleWatcher>, Chan) {\n         let rc = Rc::new(RefCell::new((None, 0)));\n         let cb = box MyCallback(rc.clone(), v);\n-        let cb = cb as ~Callback:;\n+        let cb = cb as Box<Callback:>;\n         let cb = unsafe { cast::transmute(cb) };\n         (IdleWatcher::new(&mut local_loop().loop_, cb), rc)\n     }\n \n     fn sleep(chan: &Chan) -> uint {\n-        let task: ~Task = Local::take();\n+        let task: Box<Task> = Local::take();\n         task.deschedule(1, |task| {\n             match *chan.borrow_mut().deref_mut() {\n                 (ref mut slot, _) => {"}, {"sha": "84d4b6b4702c3de93ba82fab9f4e6c60d3583489", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -47,11 +47,11 @@ via `close` and `delete` methods.\n #[cfg(test)] extern crate realrustuv = \"rustuv\";\n extern crate libc;\n \n+use libc::{c_int, c_void};\n use std::cast;\n use std::fmt;\n use std::io::IoError;\n use std::io;\n-use libc::{c_int, c_void};\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n@@ -124,8 +124,8 @@ pub mod stream;\n ///     // this code is running inside of a green task powered by libuv\n /// }\n /// ```\n-pub fn event_loop() -> ~rtio::EventLoop:Send {\n-    box uvio::UvEventLoop::new() as ~rtio::EventLoop:Send\n+pub fn event_loop() -> Box<rtio::EventLoop:Send> {\n+    box uvio::UvEventLoop::new() as Box<rtio::EventLoop:Send>\n }\n \n /// A type that wraps a uv handle\n@@ -149,9 +149,9 @@ pub trait UvHandle<T> {\n         cast::transmute(uvll::get_data_for_uv_handle(*h))\n     }\n \n-    fn install(~self) -> ~Self {\n+    fn install(~self) -> Box<Self> {\n         unsafe {\n-            let myptr = cast::transmute::<&~Self, &*u8>(&self);\n+            let myptr = cast::transmute::<&Box<Self>, &*u8>(&self);\n             uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);\n         }\n         self\n@@ -242,7 +242,7 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>,\n     let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n     unsafe {\n         assert!((*slot).is_none());\n-        let task: ~Task = Local::take();\n+        let task: Box<Task> = Local::take();\n         loop_.modify_blockers(1);\n         task.deschedule(1, |task| {\n             *slot = Some(task);"}, {"sha": "a2701a57ca91753caf57de8753d1ddc3a556390c", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n+use libc;\n use std::cast;\n use std::io::{IoError, IoResult};\n use std::io::net::ip;\n-use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n-use libc;\n use std::mem;\n use std::ptr;\n use std::rt::rtio;\n@@ -152,7 +152,7 @@ fn socket_name(sk: SocketNameKind,\n pub struct ConnectCtx {\n     pub status: c_int,\n     pub task: Option<BlockedTask>,\n-    pub timer: Option<~TimerWatcher>,\n+    pub timer: Option<Box<TimerWatcher>>,\n }\n \n pub struct AcceptTimeout {\n@@ -352,12 +352,12 @@ pub struct TcpListener {\n     home: HomeHandle,\n     handle: *uvll::uv_pipe_t,\n     closing_task: Option<BlockedTask>,\n-    outgoing: Sender<Result<~rtio::RtioTcpStream:Send, IoError>>,\n-    incoming: Receiver<Result<~rtio::RtioTcpStream:Send, IoError>>,\n+    outgoing: Sender<Result<Box<rtio::RtioTcpStream:Send>, IoError>>,\n+    incoming: Receiver<Result<Box<rtio::RtioTcpStream:Send>, IoError>>,\n }\n \n pub struct TcpAcceptor {\n-    listener: ~TcpListener,\n+    listener: Box<TcpListener>,\n     timeout: AcceptTimeout,\n }\n \n@@ -455,15 +455,15 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         })\n     }\n \n-    fn clone(&self) -> ~rtio::RtioTcpStream:Send {\n+    fn clone(&self) -> Box<rtio::RtioTcpStream:Send> {\n         box TcpWatcher {\n             handle: self.handle,\n             stream: StreamWatcher::new(self.handle),\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             write_access: self.write_access.clone(),\n             read_access: self.read_access.clone(),\n-        } as ~rtio::RtioTcpStream:Send\n+        } as Box<rtio::RtioTcpStream:Send>\n     }\n \n     fn close_write(&mut self) -> Result<(), IoError> {\n@@ -516,7 +516,7 @@ impl Drop for TcpWatcher {\n \n impl TcpListener {\n     pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n-                -> Result<~TcpListener, UvError> {\n+                -> Result<Box<TcpListener>, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(io.uv_loop(), handle)\n@@ -557,7 +557,7 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> Result<~rtio::RtioTcpAcceptor:Send, IoError> {\n+    fn listen(~self) -> Result<Box<rtio::RtioTcpAcceptor:Send>, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box TcpAcceptor {\n             listener: self,\n@@ -567,7 +567,7 @@ impl rtio::RtioTcpListener for TcpListener {\n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.handle, 128, listen_cb) } {\n-            0 => Ok(acceptor as ~rtio::RtioTcpAcceptor:Send),\n+            0 => Ok(acceptor as Box<rtio::RtioTcpAcceptor:Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n     }\n@@ -583,7 +583,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n             });\n             let client = TcpWatcher::new_home(&loop_, tcp.home().clone());\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n-            Ok(box client as ~rtio::RtioTcpStream:Send)\n+            Ok(box client as Box<rtio::RtioTcpStream:Send>)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -611,7 +611,7 @@ impl rtio::RtioSocket for TcpAcceptor {\n }\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> Result<~rtio::RtioTcpStream:Send, IoError> {\n+    fn accept(&mut self) -> Result<Box<rtio::RtioTcpStream:Send>, IoError> {\n         self.timeout.accept(&self.listener.incoming)\n     }\n \n@@ -879,14 +879,14 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         })\n     }\n \n-    fn clone(&self) -> ~rtio::RtioUdpSocket:Send {\n+    fn clone(&self) -> Box<rtio::RtioUdpSocket:Send> {\n         box UdpWatcher {\n             handle: self.handle,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             write_access: self.write_access.clone(),\n             read_access: self.read_access.clone(),\n-        } as ~rtio::RtioUdpSocket:Send\n+        } as Box<rtio::RtioUdpSocket:Send>\n     }\n }\n "}, {"sha": "0edc13afcf538f43cc2e64935e89e889b442d324", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc;\n use std::c_str::CString;\n use std::io::IoError;\n-use libc;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n \n use access::Access;\n@@ -36,12 +36,12 @@ pub struct PipeWatcher {\n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    outgoing: Sender<Result<~RtioPipe:Send, IoError>>,\n-    incoming: Receiver<Result<~RtioPipe:Send, IoError>>,\n+    outgoing: Sender<Result<Box<RtioPipe:Send>, IoError>>,\n+    incoming: Receiver<Result<Box<RtioPipe:Send>, IoError>>,\n }\n \n pub struct PipeAcceptor {\n-    listener: ~PipeListener,\n+    listener: Box<PipeListener>,\n     timeout: net::AcceptTimeout,\n }\n \n@@ -121,15 +121,15 @@ impl RtioPipe for PipeWatcher {\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn clone(&self) -> ~RtioPipe:Send {\n+    fn clone(&self) -> Box<RtioPipe:Send> {\n         box PipeWatcher {\n             stream: StreamWatcher::new(self.stream.handle),\n             defused: false,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             read_access: self.read_access.clone(),\n             write_access: self.write_access.clone(),\n-        } as ~RtioPipe:Send\n+        } as Box<RtioPipe:Send>\n     }\n }\n \n@@ -154,7 +154,7 @@ impl Drop for PipeWatcher {\n \n impl PipeListener {\n     pub fn bind(io: &mut UvIoFactory, name: &CString)\n-        -> Result<~PipeListener, UvError>\n+        -> Result<Box<PipeListener>, UvError>\n     {\n         let pipe = PipeWatcher::new(io, false);\n         match unsafe {\n@@ -179,7 +179,7 @@ impl PipeListener {\n }\n \n impl RtioUnixListener for PipeListener {\n-    fn listen(~self) -> Result<~RtioUnixAcceptor:Send, IoError> {\n+    fn listen(~self) -> Result<Box<RtioUnixAcceptor:Send>, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box PipeAcceptor {\n             listener: self,\n@@ -189,7 +189,7 @@ impl RtioUnixListener for PipeListener {\n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n-            0 => Ok(acceptor as ~RtioUnixAcceptor:Send),\n+            0 => Ok(acceptor as Box<RtioUnixAcceptor:Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n     }\n@@ -214,7 +214,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             });\n             let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n-            Ok(box client as ~RtioPipe:Send)\n+            Ok(box client as Box<RtioPipe:Send>)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -231,7 +231,7 @@ impl Drop for PipeListener {\n // PipeAcceptor implementation and traits\n \n impl RtioUnixAcceptor for PipeAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipe:Send, IoError> {\n+    fn accept(&mut self) -> Result<Box<RtioPipe:Send>, IoError> {\n         self.timeout.accept(&self.listener.incoming)\n     }\n "}, {"sha": "d744607050fc6583d750c8ea40517258f53bd10e", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::IoError;\n-use std::io::process;\n use libc::c_int;\n use libc;\n+use std::io::IoError;\n+use std::io::process;\n use std::ptr;\n use std::rt::rtio::RtioProcess;\n use std::rt::task::BlockedTask;\n@@ -40,8 +40,7 @@ impl Process {\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n     pub fn spawn(io_loop: &mut UvIoFactory, config: process::ProcessConfig)\n-                -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n-    {\n+                -> Result<(Box<Process>, ~[Option<PipeWatcher>]), UvError> {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n         let mut io = vec![config.stdin, config.stdout, config.stderr];\n         for slot in config.extra_io.iter() {"}, {"sha": "561c1f6f95f5c40f22d5ce9ec23072af2fe7e8be", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -20,8 +20,8 @@\n \n #![allow(dead_code)]\n \n-use std::cast;\n use libc::c_void;\n+use std::cast;\n use std::rt::task::BlockedTask;\n use std::unstable::mutex::NativeMutex;\n use std::sync::arc::UnsafeArc;\n@@ -107,7 +107,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n }\n \n impl QueuePool {\n-    pub fn new(loop_: &mut Loop) -> ~QueuePool {\n+    pub fn new(loop_: &mut Loop) -> Box<QueuePool> {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         let state = UnsafeArc::new(State {\n             handle: handle,"}, {"sha": "b2e1c7520128b761509cc0d7baf2043ff1151c25", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,8 +26,8 @@ pub struct SignalWatcher {\n }\n \n impl SignalWatcher {\n-    pub fn new(io: &mut UvIoFactory, signum: Signum,\n-               channel: Sender<Signum>) -> Result<~SignalWatcher, UvError> {\n+    pub fn new(io: &mut UvIoFactory, signum: Signum, channel: Sender<Signum>)\n+               -> Result<Box<SignalWatcher>, UvError> {\n         let s = box SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n             home: io.make_handle(),"}, {"sha": "216eb6001305e8d33a6e666881fbe1fb7d8c8dae", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -32,7 +32,7 @@ pub enum NextAction {\n }\n \n impl TimerWatcher {\n-    pub fn new(io: &mut UvIoFactory) -> ~TimerWatcher {\n+    pub fn new(io: &mut UvIoFactory) -> Box<TimerWatcher> {\n         let handle = io.make_handle();\n         let me = box TimerWatcher::new_home(&io.loop_, handle);\n         me.install()"}, {"sha": "17a64fdb51760740e729a079d2642251fdb37819", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -93,17 +93,16 @@ impl EventLoop for UvEventLoop {\n         IdleWatcher::onetime(&mut self.uvio.loop_, f);\n     }\n \n-    fn pausable_idle_callback(&mut self, cb: ~rtio::Callback:Send)\n-        -> ~rtio::PausableIdleCallback:Send\n-    {\n-        IdleWatcher::new(&mut self.uvio.loop_,\n-                         cb) as ~rtio::PausableIdleCallback:Send\n+    fn pausable_idle_callback(&mut self, cb: Box<rtio::Callback:Send>)\n+                              -> Box<rtio::PausableIdleCallback:Send> {\n+        IdleWatcher::new(&mut self.uvio.loop_, cb)\n+                         as Box<rtio::PausableIdleCallback:Send>\n     }\n \n-    fn remote_callback(&mut self, f: ~rtio::Callback:Send)\n-        -> ~rtio::RemoteCallback:Send\n-    {\n-        box AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback:Send\n+    fn remote_callback(&mut self, f: Box<rtio::Callback:Send>)\n+                       -> Box<rtio::RemoteCallback:Send> {\n+        box AsyncWatcher::new(&mut self.uvio.loop_, f) as\n+            Box<rtio::RemoteCallback:Send>\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> {\n@@ -132,7 +131,7 @@ fn test_callback_run_once() {\n \n pub struct UvIoFactory {\n     pub loop_: Loop,\n-    handle_pool: Option<~QueuePool>,\n+    handle_pool: Option<Box<QueuePool>>,\n }\n \n impl UvIoFactory {\n@@ -151,30 +150,31 @@ impl IoFactory for UvIoFactory {\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n     fn tcp_connect(&mut self, addr: SocketAddr, timeout: Option<u64>)\n-        -> Result<~rtio::RtioTcpStream:Send, IoError>\n-    {\n+                   -> Result<Box<rtio::RtioTcpStream:Send>, IoError> {\n         match TcpWatcher::connect(self, addr, timeout) {\n-            Ok(t) => Ok(box t as ~rtio::RtioTcpStream:Send),\n+            Ok(t) => Ok(box t as Box<rtio::RtioTcpStream:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioTcpListener:Send, IoError> {\n+    fn tcp_bind(&mut self, addr: SocketAddr)\n+                -> Result<Box<rtio::RtioTcpListener:Send>, IoError> {\n         match TcpListener::bind(self, addr) {\n-            Ok(t) => Ok(t as ~rtio::RtioTcpListener:Send),\n+            Ok(t) => Ok(t as Box<rtio::RtioTcpListener:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket:Send, IoError> {\n+    fn udp_bind(&mut self, addr: SocketAddr)\n+                -> Result<Box<rtio::RtioUdpSocket:Send>, IoError> {\n         match UdpWatcher::bind(self, addr) {\n-            Ok(u) => Ok(box u as ~rtio::RtioUdpSocket:Send),\n+            Ok(u) => Ok(box u as Box<rtio::RtioUdpSocket:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<~rtio::RtioTimer:Send, IoError> {\n-        Ok(TimerWatcher::new(self) as ~rtio::RtioTimer:Send)\n+    fn timer_init(&mut self) -> Result<Box<rtio::RtioTimer:Send>, IoError> {\n+        Ok(TimerWatcher::new(self) as Box<rtio::RtioTimer:Send>)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n@@ -183,13 +183,14 @@ impl IoFactory for UvIoFactory {\n         r.map_err(uv_error_to_io_error)\n     }\n \n-    fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: rtio::CloseBehavior) -> ~rtio::RtioFileStream:Send {\n-        box FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream:Send\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)\n+                      -> Box<rtio::RtioFileStream:Send> {\n+        box FileWatcher::new(self, fd, close) as\n+            Box<rtio::RtioFileStream:Send>\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> Result<~rtio::RtioFileStream:Send, IoError> {\n+               -> Result<Box<rtio::RtioFileStream:Send>, IoError> {\n         let flags = match fm {\n             io::Open => 0,\n             io::Append => libc::O_APPEND,\n@@ -205,7 +206,7 @@ impl IoFactory for UvIoFactory {\n         };\n \n         match FsRequest::open(self, path, flags as int, mode as int) {\n-            Ok(fs) => Ok(box fs as ~rtio::RtioFileStream:Send),\n+            Ok(fs) => Ok(box fs as Box<rtio::RtioFileStream:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n@@ -270,12 +271,16 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~rtio::RtioProcess:Send, ~[Option<~rtio::RtioPipe:Send>]), IoError>\n+            -> Result<(Box<rtio::RtioProcess:Send>,\n+                       ~[Option<Box<rtio::RtioPipe:Send>>]),\n+                      IoError>\n     {\n         match Process::spawn(self, config) {\n             Ok((p, io)) => {\n-                Ok((p as ~rtio::RtioProcess:Send,\n-                    io.move_iter().map(|i| i.map(|p| box p as ~rtio::RtioPipe:Send)).collect()))\n+                Ok((p as Box<rtio::RtioProcess:Send>,\n+                    io.move_iter().map(|i| i.map(|p| {\n+                        box p as Box<rtio::RtioPipe:Send>\n+                    })).collect()))\n             }\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n@@ -285,41 +290,42 @@ impl IoFactory for UvIoFactory {\n         Process::kill(pid, signum).map_err(uv_error_to_io_error)\n     }\n \n-    fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener:Send, IoError>\n-    {\n+    fn unix_bind(&mut self, path: &CString)\n+                 -> Result<Box<rtio::RtioUnixListener:Send>, IoError> {\n         match PipeListener::bind(self, path) {\n-            Ok(p) => Ok(p as ~rtio::RtioUnixListener:Send),\n+            Ok(p) => Ok(p as Box<rtio::RtioUnixListener:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> Result<~rtio::RtioPipe:Send, IoError> {\n+    fn unix_connect(&mut self, path: &CString, timeout: Option<u64>)\n+                    -> Result<Box<rtio::RtioPipe:Send>, IoError> {\n         match PipeWatcher::connect(self, path, timeout) {\n-            Ok(p) => Ok(box p as ~rtio::RtioPipe:Send),\n+            Ok(p) => Ok(box p as Box<rtio::RtioPipe:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<~rtio::RtioTTY:Send, IoError> {\n+            -> Result<Box<rtio::RtioTTY:Send>, IoError> {\n         match TtyWatcher::new(self, fd, readable) {\n-            Ok(tty) => Ok(box tty as ~rtio::RtioTTY:Send),\n+            Ok(tty) => Ok(box tty as Box<rtio::RtioTTY:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n-    fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe:Send, IoError> {\n+    fn pipe_open(&mut self, fd: c_int)\n+                 -> Result<Box<rtio::RtioPipe:Send>, IoError> {\n         match PipeWatcher::open(self, fd) {\n-            Ok(s) => Ok(box s as ~rtio::RtioPipe:Send),\n+            Ok(s) => Ok(box s as Box<rtio::RtioPipe:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn signal(&mut self, signum: Signum, channel: Sender<Signum>)\n-        -> Result<~rtio::RtioSignal:Send, IoError> {\n+        -> Result<Box<rtio::RtioSignal:Send>, IoError> {\n         match SignalWatcher::new(self, signum, channel) {\n-            Ok(s) => Ok(s as ~rtio::RtioSignal:Send),\n+            Ok(s) => Ok(s as Box<rtio::RtioSignal:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }"}, {"sha": "d1fe04bccf8f0036aedde2624c775eb4ea2ba6db", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -113,7 +113,7 @@ pub struct MyStruct  {\n \n impl ToJson for MyStruct {\n     fn to_json( &self ) -> json::Json {\n-        let mut d = ~TreeMap::new();\n+        let mut d = box TreeMap::new();\n         d.insert(\"attr1\".to_owned(), self.attr1.to_json());\n         d.insert(\"attr2\".to_owned(), self.attr2.to_json());\n         json::Object(d)\n@@ -206,7 +206,7 @@ pub struct TestStruct1  {\n \n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n-        let mut d = ~TreeMap::new();\n+        let mut d = box TreeMap::new();\n         d.insert(\"data_int\".to_owned(), self.data_int.to_json());\n         d.insert(\"data_str\".to_owned(), self.data_str.to_json());\n         d.insert(\"data_vector\".to_owned(), self.data_vector.to_json());\n@@ -232,21 +232,20 @@ fn main() {\n \n */\n \n-use collections::HashMap;\n use std::char;\n use std::f64;\n+use std::fmt;\n use std::io::MemWriter;\n use std::io;\n+use std::mem::swap;\n use std::num;\n-use std::str;\n use std::str::ScalarValue;\n+use std::str;\n use std::strbuf::StrBuf;\n-use std::fmt;\n use std::vec::Vec;\n-use std::mem::swap;\n \n use Encodable;\n-use collections::TreeMap;\n+use collections::{HashMap, TreeMap};\n \n /// Represents a json value\n #[deriving(Clone, Eq)]\n@@ -255,7 +254,7 @@ pub enum Json {\n     String(~str),\n     Boolean(bool),\n     List(List),\n-    Object(~Object),\n+    Object(Box<Object>),\n     Null,\n }\n "}, {"sha": "9d68705fca73f643ffe8c1fadcc94c053e67b1c6", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -391,14 +391,14 @@ impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a T {\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~T {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Box<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~T {\n-    fn decode(d: &mut D) -> Result<~T, E> {\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Box<T> {\n+    fn decode(d: &mut D) -> Result<Box<T>, E> {\n         Ok(box try!(Decodable::decode(d)))\n     }\n }"}, {"sha": "2c1ce9fa779a146e06baedbef025792fedd21114", "filename": "src/libstd/any.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,12 +17,13 @@\n //! As `&Any` (a borrowed trait object), it has the `is` and `as_ref` methods, to test if the\n //! contained value is of a given type, and to get a reference to the inner value as a type. As\n //! `&mut Any`, there is also the `as_mut` method, for getting a mutable reference to the inner\n-//! value. `~Any` adds the `move` method, which will unwrap a `~T` from the object.  See the\n-//! extension traits (`*Ext`) for the full details.\n+//! value. `Box<Any>` adds the `move` method, which will unwrap a `Box<T>` from the object.  See\n+//! the extension traits (`*Ext`) for the full details.\n \n use cast::{transmute, transmute_copy};\n use fmt;\n use option::{Option, Some, None};\n+use owned::Box;\n use raw::TraitObject;\n use result::{Result, Ok, Err};\n use intrinsics::TypeId;\n@@ -121,12 +122,12 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n pub trait AnyOwnExt {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n-    fn move<T: 'static>(self) -> Result<~T, Self>;\n+    fn move<T: 'static>(self) -> Result<Box<T>, Self>;\n }\n \n-impl AnyOwnExt for ~Any {\n+impl AnyOwnExt for Box<Any> {\n     #[inline]\n-    fn move<T: 'static>(self) -> Result<~T, ~Any> {\n+    fn move<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -148,9 +149,9 @@ impl AnyOwnExt for ~Any {\n // Trait implementations\n ///////////////////////////////////////////////////////////////////////////////\n \n-impl fmt::Show for ~Any {\n+impl fmt::Show for Box<Any> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"~Any\")\n+        f.pad(\"Box<Any>\")\n     }\n }\n \n@@ -164,6 +165,7 @@ impl<'a> fmt::Show for &'a Any {\n mod tests {\n     use prelude::*;\n     use super::*;\n+    use owned::Box;\n     use str::StrSlice;\n \n     #[deriving(Eq, Show)]\n@@ -190,7 +192,7 @@ mod tests {\n \n     #[test]\n     fn any_owning() {\n-        let (a, b, c) = (box 5u as ~Any, box TEST as ~Any, box Test as ~Any);\n+        let (a, b, c) = (box 5u as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n \n         assert!(a.is::<uint>());\n         assert!(!b.is::<uint>());\n@@ -268,8 +270,8 @@ mod tests {\n \n     #[test]\n     fn any_move() {\n-        let a = box 8u as ~Any;\n-        let b = box Test as ~Any;\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n \n         match a.move::<uint>() {\n             Ok(a) => { assert_eq!(a, box 8u); }\n@@ -280,19 +282,19 @@ mod tests {\n             Err(..) => fail!()\n         }\n \n-        let a = box 8u as ~Any;\n-        let b = box Test as ~Any;\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n \n-        assert!(a.move::<~Test>().is_err());\n-        assert!(b.move::<~uint>().is_err());\n+        assert!(a.move::<Box<Test>>().is_err());\n+        assert!(b.move::<Box<uint>>().is_err());\n     }\n \n     #[test]\n     fn test_show() {\n-        let a = box 8u as ~Any;\n-        let b = box Test as ~Any;\n-        assert_eq!(format!(\"{}\", a), \"~Any\".to_owned());\n-        assert_eq!(format!(\"{}\", b), \"~Any\".to_owned());\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+        assert_eq!(format!(\"{}\", a), \"Box<Any>\".to_owned());\n+        assert_eq!(format!(\"{}\", b), \"Box<Any>\".to_owned());\n \n         let a = &8u as &Any;\n         let b = &Test as &Any;"}, {"sha": "36d1cd9ba943b9547fb64d5d37a0ea71af53b073", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -21,6 +21,8 @@ the `clone` method.\n \n */\n \n+use owned::Box;\n+\n /// A common trait for cloning an object.\n pub trait Clone {\n     /// Returns a copy of the value. The contents of owned pointers\n@@ -39,14 +41,14 @@ pub trait Clone {\n     }\n }\n \n-impl<T: Clone> Clone for ~T {\n+impl<T: Clone> Clone for Box<T> {\n     /// Return a copy of the owned box.\n     #[inline]\n-    fn clone(&self) -> ~T { box {(**self).clone()} }\n+    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n \n     /// Perform copy-assignment from `source` by reusing the existing allocation.\n     #[inline]\n-    fn clone_from(&mut self, source: &~T) {\n+    fn clone_from(&mut self, source: &Box<T>) {\n         (**self).clone_from(&(**source));\n     }\n }\n@@ -127,7 +129,7 @@ extern_fn_clone!(A, B, C, D, E, F, G, H)\n #[test]\n fn test_owned_clone() {\n     let a = box 5i;\n-    let b: ~int = a.clone();\n+    let b: Box<int> = a.clone();\n     assert_eq!(a, b);\n }\n "}, {"sha": "bd1def518f0a929ab4518f0ea0f2cf92f245cc84", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -279,6 +279,7 @@ use kinds::marker;\n use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n+use owned::Box;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n@@ -297,6 +298,7 @@ macro_rules! test (\n             use prelude::*;\n             use super::*;\n             use super::super::*;\n+            use owned::Box;\n             use task;\n \n             fn f() $b\n@@ -549,7 +551,7 @@ impl<T: Send> Sender<T> {\n         let cnt = self.sends.get() + 1;\n         self.sends.set(cnt);\n         if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: Option<~Task> = Local::try_take();\n+            let task: Option<Box<Task>> = Local::try_take();\n             task.map(|t| t.maybe_yield());\n         }\n \n@@ -773,7 +775,7 @@ impl<T: Send> Receiver<T> {\n         let cnt = self.receives.get() + 1;\n         self.receives.set(cnt);\n         if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: Option<~Task> = Local::try_take();\n+            let task: Option<Box<Task>> = Local::try_take();\n             task.map(|t| t.maybe_yield());\n         }\n \n@@ -979,6 +981,7 @@ mod test {\n \n     use native;\n     use os;\n+    use owned::Box;\n     use super::*;\n \n     pub fn stress_factor() -> uint {\n@@ -1197,7 +1200,7 @@ mod test {\n \n     test!(fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = channel::<~int>();\n+        let (tx, rx) = channel::<Box<int>>();\n         drop(rx);\n         tx.send(box 0);\n     } #[should_fail])\n@@ -1214,7 +1217,7 @@ mod test {\n     })\n \n     test!(fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = channel::<~int>();\n+        let (tx, rx) = channel::<Box<int>>();\n         tx.send(box 10);\n         assert!(rx.recv() == box 10);\n     })\n@@ -1263,7 +1266,7 @@ mod test {\n     })\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = channel::<~int>();\n+        let (tx, rx) = channel::<Box<int>>();\n         spawn(proc() {\n             assert!(rx.recv() == box 10);\n         });\n@@ -1272,7 +1275,7 @@ mod test {\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = channel::<~int>();\n+        let (tx, rx) = channel::<Box<int>>();\n         spawn(proc() {\n             drop(tx);\n         });\n@@ -1340,7 +1343,7 @@ mod test {\n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: Sender<~int>, i: int) {\n+            fn send(tx: Sender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n@@ -1349,7 +1352,7 @@ mod test {\n                 });\n             }\n \n-            fn recv(rx: Receiver<~int>, i: int) {\n+            fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n@@ -1513,6 +1516,7 @@ mod test {\n mod sync_tests {\n     use prelude::*;\n     use os;\n+    use owned::Box;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n@@ -1657,7 +1661,7 @@ mod sync_tests {\n \n     test!(fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = sync_channel::<~int>(0);\n+        let (tx, rx) = sync_channel::<Box<int>>(0);\n         drop(rx);\n         tx.send(box 0);\n     } #[should_fail])\n@@ -1674,7 +1678,7 @@ mod sync_tests {\n     })\n \n     test!(fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = sync_channel::<~int>(1);\n+        let (tx, rx) = sync_channel::<Box<int>>(1);\n         tx.send(box 10);\n         assert!(rx.recv() == box 10);\n     })\n@@ -1728,7 +1732,7 @@ mod sync_tests {\n     })\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = sync_channel::<~int>(0);\n+        let (tx, rx) = sync_channel::<Box<int>>(0);\n         spawn(proc() {\n             assert!(rx.recv() == box 10);\n         });\n@@ -1737,7 +1741,7 @@ mod sync_tests {\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = sync_channel::<~int>(0);\n+        let (tx, rx) = sync_channel::<Box<int>>(0);\n         spawn(proc() {\n             drop(tx);\n         });\n@@ -1805,7 +1809,7 @@ mod sync_tests {\n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: SyncSender<~int>, i: int) {\n+            fn send(tx: SyncSender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n@@ -1814,7 +1818,7 @@ mod sync_tests {\n                 });\n             }\n \n-            fn recv(rx: Receiver<~int>, i: int) {\n+            fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n                 spawn(proc() {"}, {"sha": "a7124e50b663ed878f55c22bbb20ebafe0b20efa", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -37,6 +37,7 @@ use kinds::Send;\n use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n+use owned::Box;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n@@ -137,7 +138,7 @@ impl<T: Send> Packet<T> {\n         // Attempt to not block the task (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(atomics::SeqCst) == EMPTY {\n-            let t: ~Task = Local::take();\n+            let t: Box<Task> = Local::take();\n             t.deschedule(1, |task| {\n                 let n = unsafe { task.cast_to_uint() };\n                 match self.state.compare_and_swap(EMPTY, n, atomics::SeqCst) {"}, {"sha": "cebfeb5399e9d9f503696d4dee3b3bf3b424ea7d", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -52,6 +52,7 @@ use kinds::marker;\n use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n+use owned::Box;\n use ptr::RawPtr;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n@@ -176,7 +177,7 @@ impl Select {\n             // Acquire a number of blocking contexts, and block on each one\n             // sequentially until one fails. If one fails, then abort\n             // immediately so we can go unblock on all the other receivers.\n-            let task: ~Task = Local::take();\n+            let task: Box<Task> = Local::take();\n             task.deschedule(amt, |task| {\n                 // Prepare for the block\n                 let (i, handle) = iter.next().unwrap();"}, {"sha": "8aef2ec80a81c6c08cb5045fe6acb32c5a8ebe20", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -24,6 +24,7 @@ use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n+use owned::Box;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n@@ -223,7 +224,7 @@ impl<T: Send> Packet<T> {\n             data => return data,\n         }\n \n-        let task: ~Task = Local::take();\n+        let task: Box<Task> = Local::take();\n         task.deschedule(1, |task| {\n             self.decrement(task)\n         });"}, {"sha": "9fb22ef4508301cc2ca6fd97a530141d1b4d7ac7", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -24,6 +24,7 @@ use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n use option::{Some, None};\n+use owned::Box;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n@@ -181,7 +182,7 @@ impl<T: Send> Packet<T> {\n \n         // Welp, our channel has no data. Deschedule the current task and\n         // initiate the blocking protocol.\n-        let task: ~Task = Local::take();\n+        let task: Box<Task> = Local::take();\n         task.deschedule(1, |task| {\n             self.decrement(task)\n         });"}, {"sha": "db3f90cad5a04bd04433d8d2ddcabcd4262e11c6", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -40,6 +40,7 @@ use kinds::Send;\n use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n+use owned::Box;\n use ptr::RawPtr;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n@@ -111,7 +112,7 @@ pub enum Failure {\n /// in the meantime. This re-locks the mutex upon returning.\n fn wait(slot: &mut Blocker, f: fn(BlockedTask) -> Blocker,\n         lock: &NativeMutex) {\n-    let me: ~Task = Local::take();\n+    let me: Box<Task> = Local::take();\n     me.deschedule(1, |task| {\n         match mem::replace(slot, f(task)) {\n             NoneBlocked => {}\n@@ -445,7 +446,7 @@ impl<T> Buffer<T> {\n \n impl Queue {\n     fn enqueue(&mut self, lock: &NativeMutex) {\n-        let task: ~Task = Local::take();\n+        let task: Box<Task> = Local::take();\n         let mut node = Node {\n             task: None,\n             next: 0 as *mut Node,"}, {"sha": "9cf3a7636488749413980ce90e0c4c68f3454037", "filename": "src/libstd/default.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdefault.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,6 +10,8 @@\n \n //! The `Default` trait for types which may have meaningful default values\n \n+use owned::Box;\n+\n /// A trait that types which have a useful default value should implement.\n pub trait Default {\n     /// Return the \"default value\" for a type.\n@@ -20,6 +22,6 @@ impl<T: Default + 'static> Default for @T {\n     fn default() -> @T { @Default::default() }\n }\n \n-impl<T: Default> Default for ~T {\n-    fn default() -> ~T { box Default::default() }\n+impl<T: Default> Default for Box<T> {\n+    fn default() -> Box<T> { box Default::default() }\n }"}, {"sha": "38456e195e36a219273b4721f522f8c47d71d73a", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -492,6 +492,7 @@ use io;\n use iter::{Iterator, range};\n use num::Signed;\n use option::{Option,Some,None};\n+use owned::Box;\n use repr;\n use result::{Ok, Err};\n use str::StrSlice;\n@@ -1113,7 +1114,7 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n impl<T: Show> Show for @T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n }\n-impl<T: Show> Show for ~T {\n+impl<T: Show> Show for Box<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n }\n impl<'a, T: Show> Show for &'a T {"}, {"sha": "ba126e00153bcab19063bcdb6a057c581c412b9f", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,6 +17,7 @@\n use prelude::*;\n \n use char;\n+use owned::Box;\n use str;\n \n /// A piece is a portion of the format string which represents the next part\n@@ -41,7 +42,7 @@ pub struct Argument<'a> {\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n     /// If not `None`, what method to invoke on the argument\n-    pub method: Option<~Method<'a>>\n+    pub method: Option<Box<Method<'a>>>\n }\n \n /// Specification for the formatting of an argument in the format string.\n@@ -435,7 +436,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a method to be applied to the previously specified argument and\n     /// its format. The two current supported methods are 'plural' and 'select'\n-    fn method(&mut self) -> Option<~Method<'a>> {\n+    fn method(&mut self) -> Option<Box<Method<'a>>> {\n         if !self.wsconsume(',') {\n             return None;\n         }\n@@ -461,7 +462,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a 'select' statement (after the initial 'select' word)\n-    fn select(&mut self) -> ~Method<'a> {\n+    fn select(&mut self) -> Box<Method<'a>> {\n         let mut other = None;\n         let mut arms = vec!();\n         // Consume arms one at a time\n@@ -503,7 +504,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a 'plural' statement (after the initial 'plural' word)\n-    fn plural(&mut self) -> ~Method<'a> {\n+    fn plural(&mut self) -> Box<Method<'a>> {\n         let mut offset = None;\n         let mut other = None;\n         let mut arms = vec!();"}, {"sha": "748cf0eeed917dc119aa163c19f51623c571416a", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -67,6 +67,7 @@ use container::Container;\n use io::Writer;\n use iter::Iterator;\n use option::{Option, Some, None};\n+use owned::Box;\n use rc::Rc;\n use str::{Str, StrSlice};\n use slice::{Vector, ImmutableVector};\n@@ -229,7 +230,7 @@ impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a mut T {\n     }\n }\n \n-impl<S: Writer, T: Hash<S>> Hash<S> for ~T {\n+impl<S: Writer, T: Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);"}, {"sha": "3f66ecd5db343d6fd956e18b6a7a6d51d7626ed0", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -55,11 +55,12 @@ use container::Container;\n use iter::Iterator;\n use kinds::Send;\n use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n-            FileMode, FileAccess, FileStat, IoResult, FilePermission};\n+use super::{SeekStyle, Read, Write, Open, IoError, Truncate};\n+use super::{FileMode, FileAccess, FileStat, IoResult, FilePermission};\n use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n use io;\n use option::{Some, None, Option};\n+use owned::Box;\n use result::{Ok, Err};\n use path;\n use path::{Path, GenericPath};\n@@ -78,7 +79,7 @@ use vec::Vec;\n /// configured at creation time, via the `FileAccess` parameter to\n /// `File::open_mode()`.\n pub struct File {\n-    fd: ~RtioFileStream:Send,\n+    fd: Box<RtioFileStream:Send>,\n     path: Path,\n     last_nread: int,\n }"}, {"sha": "59a8c6f3439d697484d7642de44a119d3086b738", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -227,6 +227,7 @@ use libc;\n use ops::{BitOr, BitAnd, Sub};\n use os;\n use option::{Option, Some, None};\n+use owned::Box;\n use path::Path;\n use result::{Ok, Err, Result};\n use str::StrSlice;\n@@ -811,7 +812,7 @@ pub trait Reader {\n     }\n }\n \n-impl Reader for ~Reader {\n+impl Reader for Box<Reader> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n@@ -1052,7 +1053,7 @@ pub trait Writer {\n     }\n }\n \n-impl Writer for ~Writer {\n+impl Writer for Box<Writer> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n     fn flush(&mut self) -> IoResult<()> { self.flush() }\n }"}, {"sha": "69ccd2d28c9311ebf9f7749cb03b9f349a5ab18c", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -23,6 +23,7 @@ use io::net::ip::SocketAddr;\n use io::{Reader, Writer, Listener, Acceptor};\n use kinds::Send;\n use option::{None, Some, Option};\n+use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n@@ -45,11 +46,11 @@ use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n /// drop(stream); // close the connection\n /// ```\n pub struct TcpStream {\n-    obj: ~RtioTcpStream:Send\n+    obj: Box<RtioTcpStream:Send>,\n }\n \n impl TcpStream {\n-    fn new(s: ~RtioTcpStream:Send) -> TcpStream {\n+    fn new(s: Box<RtioTcpStream:Send>) -> TcpStream {\n         TcpStream { obj: s }\n     }\n \n@@ -148,7 +149,7 @@ impl Writer for TcpStream {\n /// # }\n /// ```\n pub struct TcpListener {\n-    obj: ~RtioTcpListener:Send\n+    obj: Box<RtioTcpListener:Send>,\n }\n \n impl TcpListener {\n@@ -181,7 +182,7 @@ impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n /// a `TcpListener`'s `listen` method, and this object can be used to accept new\n /// `TcpStream` instances.\n pub struct TcpAcceptor {\n-    obj: ~RtioTcpAcceptor:Send\n+    obj: Box<RtioTcpAcceptor:Send>,\n }\n \n impl TcpAcceptor {"}, {"sha": "2cc0f853e35929f66ce4aa1b8b0541721eb491ec", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -19,6 +19,7 @@ use clone::Clone;\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, IoResult};\n use kinds::Send;\n+use owned::Box;\n use result::{Ok, Err};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n@@ -54,7 +55,7 @@ use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n /// drop(socket); // close the socket\n /// ```\n pub struct UdpSocket {\n-    obj: ~RtioUdpSocket:Send\n+    obj: Box<RtioUdpSocket:Send>,\n }\n \n impl UdpSocket {"}, {"sha": "f6e985dc2780695352a409e305169805be96fec6", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -31,6 +31,7 @@ use clone::Clone;\n use io::pipe::PipeStream;\n use io::{Listener, Acceptor, Reader, Writer, IoResult};\n use kinds::Send;\n+use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n \n@@ -40,7 +41,7 @@ pub struct UnixStream {\n }\n \n impl UnixStream {\n-    fn new(obj: ~RtioPipe:Send) -> UnixStream {\n+    fn new(obj: Box<RtioPipe:Send>) -> UnixStream {\n         UnixStream { obj: PipeStream::new(obj) }\n     }\n \n@@ -107,7 +108,7 @@ impl Writer for UnixStream {\n /// A value that can listen for incoming named pipe connection requests.\n pub struct UnixListener {\n     /// The internal, opaque runtime Unix listener.\n-    obj: ~RtioUnixListener:Send,\n+    obj: Box<RtioUnixListener:Send>,\n }\n \n impl UnixListener {\n@@ -149,7 +150,7 @@ impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n /// A value that can accept named pipe connections, returned from `listen()`.\n pub struct UnixAcceptor {\n     /// The internal, opaque runtime Unix acceptor.\n-    obj: ~RtioUnixAcceptor:Send,\n+    obj: Box<RtioUnixAcceptor:Send>,\n }\n \n impl UnixAcceptor {"}, {"sha": "fbb0d5bc8d8ed0f8756652230d77a3b401dd99da", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -18,12 +18,13 @@\n use prelude::*;\n use io::IoResult;\n use libc;\n+use owned::Box;\n use rt::rtio::{RtioPipe, LocalIo};\n \n /// A synchronous, in-memory pipe.\n pub struct PipeStream {\n     /// The internal, opaque runtime pipe object.\n-    obj: ~RtioPipe:Send,\n+    obj: Box<RtioPipe:Send>,\n }\n \n impl PipeStream {\n@@ -54,7 +55,7 @@ impl PipeStream {\n     }\n \n     #[doc(hidden)]\n-    pub fn new(inner: ~RtioPipe:Send) -> PipeStream {\n+    pub fn new(inner: Box<RtioPipe:Send>) -> PipeStream {\n         PipeStream { obj: inner }\n     }\n }"}, {"sha": "1471a049bf317abc61ab2ce629cd756f464a40ec", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,6 +17,7 @@ use io::IoResult;\n use io;\n use libc;\n use mem;\n+use owned::Box;\n use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -52,7 +53,7 @@ use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n /// assert!(child.wait().success());\n /// ```\n pub struct Process {\n-    handle: ~RtioProcess:Send,\n+    handle: Box<RtioProcess:Send>,\n \n     /// Handle to the child's stdin, if the `stdin` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`."}, {"sha": "4d294e84070fc0c3c3feac4e7b0d4dfb13fa92e1", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,6 +26,7 @@ use iter::Iterator;\n use kinds::Send;\n use mem::drop;\n use option::{Some, None};\n+use owned::Box;\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n use slice::ImmutableVector;\n@@ -81,7 +82,7 @@ pub enum Signum {\n /// ```\n pub struct Listener {\n     /// A map from signums to handles to keep the handles in memory\n-    handles: Vec<(Signum, ~RtioSignal:Send)>,\n+    handles: Vec<(Signum, Box<RtioSignal:Send>)>,\n     /// This is where all the handles send signums, which are received by\n     /// the clients from the receiver.\n     tx: Sender<Signum>,"}, {"sha": "613e9f027a4d02904396fe9a628e36aa896b280e", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -34,6 +34,7 @@ use libc;\n use kinds::Send;\n use mem::replace;\n use option::{Option, Some, None};\n+use owned::Box;\n use prelude::drop;\n use result::{Ok, Err};\n use rt;\n@@ -71,8 +72,8 @@ use str::StrSlice;\n // tl;dr; TTY works on everything but when windows stdout is redirected, in that\n //        case pipe also doesn't work, but magically file does!\n enum StdSource {\n-    TTY(~RtioTTY:Send),\n-    File(~RtioFileStream:Send),\n+    TTY(Box<RtioTTY:Send>),\n+    File(Box<RtioFileStream:Send>),\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n@@ -153,10 +154,9 @@ pub fn stderr_raw() -> StdWriter {\n     src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n-fn reset_helper(w: ~Writer:Send,\n-                f: |&mut Task, ~Writer:Send| -> Option<~Writer:Send>)\n-    -> Option<~Writer:Send>\n-{\n+fn reset_helper(w: Box<Writer:Send>,\n+                f: |&mut Task, Box<Writer:Send>| -> Option<Box<Writer:Send>>)\n+                -> Option<Box<Writer:Send>> {\n     let mut t = Local::borrow(None::<Task>);\n     // Be sure to flush any pending output from the writer\n     match f(&mut *t, w) {\n@@ -178,7 +178,7 @@ fn reset_helper(w: ~Writer:Send,\n ///\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stdout stream.\n-pub fn set_stdout(stdout: ~Writer:Send) -> Option<~Writer:Send> {\n+pub fn set_stdout(stdout: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n     reset_helper(stdout, |t, w| replace(&mut t.stdout, Some(w)))\n }\n \n@@ -190,7 +190,7 @@ pub fn set_stdout(stdout: ~Writer:Send) -> Option<~Writer:Send> {\n ///\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n-pub fn set_stderr(stderr: ~Writer:Send) -> Option<~Writer:Send> {\n+pub fn set_stderr(stderr: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n     reset_helper(stderr, |t, w| replace(&mut t.stderr, Some(w)))\n }\n \n@@ -205,7 +205,7 @@ pub fn set_stderr(stderr: ~Writer:Send) -> Option<~Writer:Send> {\n //      })\n //  })\n fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n-    let task: Option<~Task> = Local::try_take();\n+    let task: Option<Box<Task>> = Local::try_take();\n     let result = match task {\n         Some(mut task) => {\n             // Printing may run arbitrary code, so ensure that the task is in\n@@ -216,7 +216,7 @@ fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n             Local::put(task);\n \n             if my_stdout.is_none() {\n-                my_stdout = Some(box stdout() as ~Writer:Send);\n+                my_stdout = Some(box stdout() as Box<Writer:Send>);\n             }\n             let ret = f(*my_stdout.get_mut_ref());\n "}, {"sha": "96c4083e7eded42643ce9d6d6072db11c40ef728", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -20,6 +20,7 @@ and create receivers which will receive notifications after a period of time.\n use comm::Receiver;\n use io::IoResult;\n use kinds::Send;\n+use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n /// A synchronous timer object\n@@ -63,7 +64,7 @@ use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n /// # }\n /// ```\n pub struct Timer {\n-    obj: ~RtioTimer:Send,\n+    obj: Box<RtioTimer:Send>,\n }\n \n /// Sleep the current task for `msecs` milliseconds."}, {"sha": "b2e6b27caabfe1fe441d605f3e9bb1a66ae05c77", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -13,6 +13,7 @@\n use prelude::*;\n use cmp;\n use io;\n+use owned::Box;\n use slice::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n@@ -85,12 +86,12 @@ impl Reader for NullReader {\n \n /// A `Writer` which multiplexes writes to a set of `Writers`.\n pub struct MultiWriter {\n-    writers: Vec<~Writer>\n+    writers: Vec<Box<Writer>>\n }\n \n impl MultiWriter {\n     /// Creates a new `MultiWriter`\n-    pub fn new(writers: Vec<~Writer>) -> MultiWriter {\n+    pub fn new(writers: Vec<Box<Writer>>) -> MultiWriter {\n         MultiWriter { writers: writers }\n     }\n }\n@@ -199,6 +200,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n mod test {\n     use io;\n     use io::{MemReader, MemWriter};\n+    use owned::Box;\n     use super::*;\n     use prelude::*;\n \n@@ -273,8 +275,8 @@ mod test {\n             }\n         }\n \n-        let mut multi = MultiWriter::new(vec!(box TestWriter as ~Writer,\n-                                              box TestWriter as ~Writer));\n+        let mut multi = MultiWriter::new(vec!(box TestWriter as Box<Writer>,\n+                                              box TestWriter as Box<Writer>));\n         multi.write([1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });"}, {"sha": "291507c1aaf3e00ff4cc5dcf11ab417a3d65d326", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -2333,6 +2333,7 @@ mod tests {\n     use prelude::*;\n \n     use cmp;\n+    use owned::Box;\n     use uint;\n     use num;\n \n@@ -2634,7 +2635,7 @@ mod tests {\n \n     #[test]\n     fn test_all() {\n-        let v: ~&[int] = box &[1, 2, 3, 4, 5];\n+        let v: Box<&[int]> = box &[1, 2, 3, 4, 5];\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x % 2 == 0));\n         assert!(!v.iter().all(|&x| x > 100));\n@@ -2643,7 +2644,7 @@ mod tests {\n \n     #[test]\n     fn test_any() {\n-        let v: ~&[int] = box &[1, 2, 3, 4, 5];\n+        let v: Box<&[int]> = box &[1, 2, 3, 4, 5];\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x % 2 == 0));\n         assert!(!v.iter().any(|&x| x > 100));"}, {"sha": "6ef71d3360a752b0cba79d22f38ab2e0d5402989", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -48,7 +48,7 @@ pub trait Copy {\n /// `Share`, and so are simple aggregate types containing them (like\n /// tuples, structs and enums). More instances of basic `Share` types\n /// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as `~T`, `Vec<T>` and most other\n+/// inherited mutability, such as `Box<T>`, `Vec<T>` and most other\n /// collection types. (Generic parameters need to be `Share` for their\n /// container to be `Share`.)\n ///"}, {"sha": "bf24bf405a043b64525bd70bc2e7c8dc2514af6e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -131,6 +131,7 @@ extern crate libc;\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;\n #[cfg(test)] pub use ty = realstd::ty;\n+#[cfg(test)] pub use owned = realstd::owned;\n \n // Run tests with libgreen instead of libnative.\n //\n@@ -188,7 +189,6 @@ pub mod strbuf;\n pub mod ascii;\n \n pub mod ptr;\n-pub mod owned;\n mod managed;\n mod reference;\n pub mod rc;\n@@ -201,6 +201,7 @@ pub mod gc;\n #[cfg(not(test))] pub mod ops;\n #[cfg(not(test))] pub mod cmp;\n #[cfg(not(test))] pub mod ty;\n+#[cfg(not(test))] pub mod owned;\n \n \n /* Common traits */"}, {"sha": "8855dabe353f60b38ac578031bf1f3656c94e868", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -45,6 +45,7 @@ use iter::{Iterator};\n use kinds::Send;\n use mem::replace;\n use option::{None, Option, Some};\n+use owned::Box;\n use rt::task::{Task, LocalStorage};\n use slice::{ImmutableVector, MutableVector};\n use vec::Vec;\n@@ -91,7 +92,7 @@ impl<T: 'static> LocalData for T {}\n //      a proper map.\n #[doc(hidden)]\n pub type Map = Vec<Option<(*u8, TLSValue, LoanState)>>;\n-type TLSValue = ~LocalData:Send;\n+type TLSValue = Box<LocalData:Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map() -> &mut Map {\n@@ -161,7 +162,7 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n \n                 // Move `data` into transmute to get out the memory that it\n                 // owns, we must free it manually later.\n-                let (_vtable, alloc): (uint, ~T) = unsafe {\n+                let (_vtable, alloc): (uint, Box<T>) = unsafe {\n                     cast::transmute(data)\n                 };\n \n@@ -252,11 +253,12 @@ fn get_with<T:'static,\n                                   want.describe(), cur.describe());\n                         }\n                     }\n-                    // data was created with `~T as ~LocalData`, so we extract\n-                    // pointer part of the trait, (as ~T), and then use\n-                    // compiler coercions to achieve a '&' pointer.\n+                    // data was created with `box T as Box<LocalData>`, so we\n+                    // extract pointer part of the trait, (as Box<T>), and\n+                    // then use compiler coercions to achieve a '&' pointer.\n                     unsafe {\n-                        match *cast::transmute::<&TLSValue, &(uint, ~T)>(data){\n+                        match *cast::transmute::<&TLSValue,\n+                                                 &(uint, Box<T>)>(data){\n                             (_vtable, ref alloc) => {\n                                 let value: &T = *alloc;\n                                 ret = f(Some(value));\n@@ -297,12 +299,12 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n     let keyval = key_to_key_value(key);\n \n     // When the task-local map is destroyed, all the data needs to be cleaned\n-    // up. For this reason we can't do some clever tricks to store '~T' as a\n-    // '*c_void' or something like that. To solve the problem, we cast\n+    // up. For this reason we can't do some clever tricks to store 'Box<T>' as\n+    // a '*c_void' or something like that. To solve the problem, we cast\n     // everything to a trait (LocalData) which is then stored inside the map.\n     // Upon destruction of the map, all the objects will be destroyed and the\n     // traits have enough information about them to destroy themselves.\n-    let data = box data as ~LocalData:;\n+    let data = box data as Box<LocalData:>;\n \n     fn insertion_position(map: &mut Map,\n                           key: *u8) -> Option<uint> {\n@@ -330,7 +332,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n     // transmute here to add the Send bound back on. This doesn't actually\n     // matter because TLS will always own the data (until its moved out) and\n     // we're not actually sending it to other schedulers or anything.\n-    let data: ~LocalData:Send = unsafe { cast::transmute(data) };\n+    let data: Box<LocalData:Send> = unsafe { cast::transmute(data) };\n     match insertion_position(map, keyval) {\n         Some(i) => { *map.get_mut(i) = Some((keyval, data, NoLoan)); }\n         None => { map.push(Some((keyval, data, NoLoan))); }\n@@ -353,6 +355,7 @@ pub fn modify<T: 'static>(key: Key<T>, f: |Option<T>| -> Option<T>) {\n mod tests {\n     use prelude::*;\n     use super::*;\n+    use owned::Box;\n     use task;\n     use str::StrSlice;\n \n@@ -485,7 +488,7 @@ mod tests {\n \n     #[test]\n     fn test_owned() {\n-        static key: Key<~int> = &Key;\n+        static key: Key<Box<int>> = &Key;\n         set(key, box 1);\n \n         get(key, |v| {"}, {"sha": "4ae3d453f03608791935dcf0c4cbf3575af8e5f1", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -19,9 +19,9 @@\n /// The entry point for failure of rust tasks.\n ///\n /// This macro is used to inject failure into a rust task, causing the task to\n-/// unwind and fail entirely. Each task's failure can be reaped as the `~Any`\n-/// type, and the single-argument form of the `fail!` macro will be the value\n-/// which is transmitted.\n+/// unwind and fail entirely. Each task's failure can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `fail!` macro will be\n+/// the value which is transmitted.\n ///\n /// The multi-argument form of this macro fails with a string and has the\n /// `format!` syntax for building a string."}, {"sha": "fa7b5c948571394db02bc48a2cdf92baa0085465", "filename": "src/libstd/option.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -54,7 +54,7 @@\n //!\n //! Rust's pointer types must always point to a valid location; there are\n //! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n-//! the optional owned box, `Option<~T>`.\n+//! the optional owned box, `Option<Box<T>>`.\n //!\n //! The following example uses `Option` to create an optional box of\n //! `int`. Notice that in order to use the inner `int` value first the\n@@ -63,13 +63,13 @@\n //! not (`None`).\n //!\n //! ```\n-//! let optional: Option<~int> = None;\n+//! let optional: Option<Box<int>> = None;\n //! check_optional(&optional);\n //!\n-//! let optional: Option<~int> = Some(~9000);\n+//! let optional: Option<Box<int>> = Some(box 9000);\n //! check_optional(&optional);\n //!\n-//! fn check_optional(optional: &Option<~int>) {\n+//! fn check_optional(optional: &Option<Box<int>>) {\n //!     match *optional {\n //!         Some(ref p) => println!(\"have value {}\", p),\n //!         None => println!(\"have no value\")\n@@ -79,7 +79,7 @@\n //!\n //! This usage of `Option` to create safe nullable pointers is so\n //! common that Rust does special optimizations to make the\n-//! representation of `Option<~T>` a single pointer. Optional pointers\n+//! representation of `Option<Box<T>>` a single pointer. Optional pointers\n //! in Rust are stored as efficiently as any other pointer type.\n //!\n //! # Examples"}, {"sha": "48b80e0ca8e4454afea2355d84a2d5a871b6f5d0", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -35,30 +35,30 @@ pub struct Box<T>(*T);\n pub struct Box<T>(*T);\n \n #[cfg(not(test))]\n-impl<T:Eq> Eq for ~T {\n+impl<T:Eq> Eq for Box<T> {\n     #[inline]\n-    fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n     #[inline]\n-    fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n-impl<T:Ord> Ord for ~T {\n+impl<T:Ord> Ord for Box<T> {\n     #[inline]\n-    fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n     #[inline]\n-    fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n     #[inline]\n-    fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n     #[inline]\n-    fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n }\n \n #[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for ~T {\n+impl<T: TotalOrd> TotalOrd for Box<T> {\n     #[inline]\n-    fn cmp(&self, other: &~T) -> Ordering { (**self).cmp(*other) }\n+    fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n }\n \n #[cfg(not(test))]\n-impl<T: TotalEq> TotalEq for ~T {}\n+impl<T: TotalEq> TotalEq for Box<T> {}"}, {"sha": "ee1d5d4a35ba49c6582e72bbb2dab31713065ebe", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -65,6 +65,7 @@ pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned};\n pub use num::{Primitive, Int, Float, ToPrimitive, FromPrimitive};\n+pub use owned::Box;\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};"}, {"sha": "dac727c2aa476182105b64c14b46b4b3836e8cdf", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -41,27 +41,27 @@\n //! and requires no resource management later,\n //! but you must not use the pointer after its lifetime.\n //!\n-//! ## 2. Transmute an owned box (`~T`).\n+//! ## 2. Transmute an owned box (`Box<T>`).\n //!\n //! The `transmute` function takes, by value, whatever it's given\n //! and returns it as whatever type is requested, as long as the\n-//! types are the same size. Because `~T` and `*T` have the same\n+//! types are the same size. Because `Box<T>` and `*T` have the same\n //! representation they can be trivially,\n //! though unsafely, transformed from one type to the other.\n //!\n //! ```\n //! use std::cast;\n //!\n //! unsafe {\n-//!     let my_num: ~int = ~10;\n+//!     let my_num: Box<int> = box 10;\n //!     let my_num: *int = cast::transmute(my_num);\n-//!     let my_speed: ~int = ~88;\n+//!     let my_speed: Box<int> = box 88;\n //!     let my_speed: *mut int = cast::transmute(my_speed);\n //!\n-//!     // By taking ownership of the original `~T` though\n+//!     // By taking ownership of the original `Box<T>` though\n //!     // we are obligated to transmute it back later to be destroyed.\n-//!     drop(cast::transmute::<_, ~int>(my_speed));\n-//!     drop(cast::transmute::<_, ~int>(my_num));\n+//!     drop(cast::transmute::<_, Box<int>>(my_speed));\n+//!     drop(cast::transmute::<_, Box<int>>(my_num));\n //! }\n //! ```\n //!"}, {"sha": "ec7b6cfa35545fde97f14d6bd9739463707b0b78", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -18,6 +18,7 @@ Runtime type reflection\n \n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n use mem;\n+use owned::Box;\n \n /**\n  * Trait for visitor that wishes to reflect on data. To use this, create a\n@@ -225,9 +226,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n+        self.align_to::<Box<u8>>();\n         if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n+        self.bump_past::<Box<u8>>();\n         true\n     }\n \n@@ -417,9 +418,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<~TyVisitor>();\n+        self.align_to::<Box<TyVisitor>>();\n         if ! self.inner.visit_trait(name) { return false; }\n-        self.bump_past::<~TyVisitor>();\n+        self.bump_past::<Box<TyVisitor>>();\n         true\n     }\n "}, {"sha": "79b927c8d7771b698a96314a5ff5e9584635a290", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -320,7 +320,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(['~' as u8]));\n+        try!(self, self.writer.write(\"box \".as_bytes()));\n         self.get::<*u8>(|this, b| {\n             this.visit_ptr_inner(*b, inner)\n         })\n@@ -353,7 +353,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Vec<()>>(|this, b| {\n-            try!(this, this.writer.write(['~' as u8]));\n+            try!(this, this.writer.write(\"box \".as_bytes()));\n             this.write_unboxed_vec_repr(mtbl, *b, inner)\n         })\n     }\n@@ -624,6 +624,7 @@ fn test_repr() {\n     use io::stdio::println;\n     use char::is_alphabetic;\n     use mem::swap;\n+    use owned::Box;\n \n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n@@ -641,7 +642,7 @@ fn test_repr() {\n     exact_test(&(\"he\\u10f3llo\".to_owned()), \"~\\\"he\\\\u10f3llo\\\"\");\n \n     exact_test(&(@10), \"@10\");\n-    exact_test(&(box 10), \"~10\");\n+    exact_test(&(box 10), \"box 10\");\n     exact_test(&(&10), \"&10\");\n     let mut x = 10;\n     exact_test(&(&mut x), \"&mut 10\");\n@@ -650,16 +651,14 @@ fn test_repr() {\n     exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n \n     exact_test(&(1,), \"(1,)\");\n-    exact_test(&(box [\"hi\", \"there\"]),\n-               \"~[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(&[\"hi\", \"there\"]),\n                \"&[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(P{a:10, b:1.234}),\n                \"repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(@P{a:10, b:1.234}),\n                \"@repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(box P{a:10, b:1.234}),\n-               \"~repr::P{a: 10, b: 1.234f64}\");\n+               \"box repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(10u8, \"hello\".to_owned()),\n                \"(10u8, ~\\\"hello\\\")\");\n     exact_test(&(10u16, \"hello\".to_owned()),\n@@ -680,10 +679,6 @@ fn test_repr() {\n     exact_test(&println, \"fn(&str)\");\n     exact_test(&swap::<int>, \"fn(&mut int, &mut int)\");\n     exact_test(&is_alphabetic, \"fn(char) -> bool\");\n-    exact_test(&(box 5 as ~ToStr), \"~to_str::ToStr<no-bounds>\");\n-\n-    struct Foo;\n-    exact_test(&(box [Foo, Foo]), \"~[repr::test_repr::Foo, repr::test_repr::Foo]\");\n \n     struct Bar(int, int);\n     exact_test(&(Bar(2, 2)), \"repr::test_repr::Bar(2, 2)\");"}, {"sha": "17e6f6b76980690d25e074267e68435d86ca9035", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -67,6 +67,7 @@ mod imp {\n     use clone::Clone;\n     use option::{Option, Some, None};\n     use iter::Iterator;\n+    use owned::Box;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n     #[cfg(not(test))] use str::StrSlice;\n@@ -91,7 +92,7 @@ mod imp {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             let val = mem::replace(&mut *ptr, None);\n-            val.as_ref().map(|s: &~~[~[u8]]| (**s).clone())\n+            val.as_ref().map(|s: &Box<~[~[u8]]>| (**s).clone())\n         })\n     }\n \n@@ -106,7 +107,7 @@ mod imp {\n     pub fn clone() -> Option<~[~[u8]]> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s: &~~[~[u8]]| (**s).clone())\n+            (*ptr).as_ref().map(|s: &Box<~[~[u8]]>| (**s).clone())\n         })\n     }\n \n@@ -117,7 +118,7 @@ mod imp {\n         }\n     }\n \n-    fn get_global_ptr() -> *mut Option<~~[~[u8]]> {\n+    fn get_global_ptr() -> *mut Option<Box<~[~[u8]]>> {\n         unsafe { cast::transmute(&global_args_ptr) }\n     }\n "}, {"sha": "051bc494adc7fbe0b7ec43b803159231e6a04f89", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,6 +17,7 @@ use iter::Iterator;\n use kinds::Send;\n use mem;\n use option::{Some, None};\n+use owned::Box;\n use ptr::RawPtr;\n use unstable::sync::Exclusive;\n use slice::OwnedVector;\n@@ -36,7 +37,7 @@ pub fn init() {\n     unsafe {\n         rtassert!(!RUNNING);\n         rtassert!(QUEUE.is_null());\n-        let state: ~Queue = box Exclusive::new(vec!());\n+        let state: Box<Queue> = box Exclusive::new(vec!());\n         QUEUE = cast::transmute(state);\n     }\n }\n@@ -58,7 +59,7 @@ pub fn run() {\n         rtassert!(!RUNNING);\n         rtassert!(!QUEUE.is_null());\n         RUNNING = true;\n-        let state: ~Queue = cast::transmute(QUEUE);\n+        let state: Box<Queue> = cast::transmute(QUEUE);\n         QUEUE = 0 as *mut Queue;\n         let mut vec = None;\n         state.with(|arr| {"}, {"sha": "ee8041f68802ce4db494ecb4b760c1612eb2cda9", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -129,7 +129,7 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                     // see src/librustc/back/link.rs for these mappings\n                     demangle! (\n                         \"$SP$\" => \"@\",\n-                        \"$UP$\" => \"~\",\n+                        \"$UP$\" => \"Box\",\n                         \"$RP$\" => \"*\",\n                         \"$BP$\" => \"&\",\n                         \"$LT$\" => \"<\",\n@@ -858,15 +858,15 @@ mod test {\n \n     #[test]\n     fn demangle_dollars() {\n-        t!(\"_ZN4$UP$E\", \"~\");\n-        t!(\"_ZN8$UP$testE\", \"~test\");\n-        t!(\"_ZN8$UP$test4foobE\", \"~test::foob\");\n+        t!(\"_ZN4$UP$E\", \"Box\");\n+        t!(\"_ZN8$UP$testE\", \"Boxtest\");\n+        t!(\"_ZN8$UP$test4foobE\", \"Boxtest::foob\");\n         t!(\"_ZN8$x20test4foobE\", \" test::foob\");\n     }\n \n     #[test]\n     fn demangle_many_dollars() {\n         t!(\"_ZN12test$x20test4foobE\", \"test test::foob\");\n-        t!(\"_ZN12test$UP$test4foobE\", \"test~test::foob\");\n+        t!(\"_ZN12test$UP$test4foobE\", \"testBoxtest::foob\");\n     }\n }"}, {"sha": "7d54c3faf4241c07841574befcd3b7732f792cb8", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -72,9 +72,10 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n #[lang=\"exchange_malloc\"]\n #[inline]\n pub unsafe fn exchange_malloc(size: uint) -> *mut u8 {\n-    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n-    // allocations can point to this `static`. It would be incorrect to use a null\n-    // pointer, due to enums assuming types like unique pointers are never null.\n+    // The compiler never calls `exchange_free` on Box<ZeroSizeType>, so\n+    // zero-size allocations can point to this `static`. It would be incorrect\n+    // to use a null pointer, due to enums assuming types like unique pointers\n+    // are never null.\n     static EMPTY: () = ();\n \n     if size == 0 {"}, {"sha": "05d1f1764b59f0d34bb8b1ae69cf0b7fc9e0d95d", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,29 +9,30 @@\n // except according to those terms.\n \n use option::Option;\n+use owned::Box;\n use rt::task::Task;\n use rt::local_ptr;\n \n /// Encapsulates some task-local data.\n pub trait Local<Borrowed> {\n-    fn put(value: ~Self);\n-    fn take() -> ~Self;\n-    fn try_take() -> Option<~Self>;\n+    fn put(value: Box<Self>);\n+    fn take() -> Box<Self>;\n+    fn try_take() -> Option<Box<Self>>;\n     fn exists(unused_value: Option<Self>) -> bool;\n     fn borrow(unused_value: Option<Self>) -> Borrowed;\n-    unsafe fn unsafe_take() -> ~Self;\n+    unsafe fn unsafe_take() -> Box<Self>;\n     unsafe fn unsafe_borrow() -> *mut Self;\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n }\n \n #[allow(visible_private_types)]\n impl Local<local_ptr::Borrowed<Task>> for Task {\n     #[inline]\n-    fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n+    fn put(value: Box<Task>) { unsafe { local_ptr::put(value) } }\n     #[inline]\n-    fn take() -> ~Task { unsafe { local_ptr::take() } }\n+    fn take() -> Box<Task> { unsafe { local_ptr::take() } }\n     #[inline]\n-    fn try_take() -> Option<~Task> { unsafe { local_ptr::try_take() } }\n+    fn try_take() -> Option<Box<Task>> { unsafe { local_ptr::try_take() } }\n     fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n     #[inline]\n     fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> {\n@@ -40,7 +41,7 @@ impl Local<local_ptr::Borrowed<Task>> for Task {\n         }\n     }\n     #[inline]\n-    unsafe fn unsafe_take() -> ~Task { local_ptr::unsafe_take() }\n+    unsafe fn unsafe_take() -> Box<Task> { local_ptr::unsafe_take() }\n     #[inline]\n     unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }\n     #[inline]\n@@ -54,14 +55,15 @@ mod test {\n     use option::{None, Option};\n     use unstable::run_in_bare_thread;\n     use super::*;\n+    use owned::Box;\n     use rt::task::Task;\n \n     #[test]\n     fn thread_local_task_smoke_test() {\n         run_in_bare_thread(proc() {\n             let task = box Task::new();\n             Local::put(task);\n-            let task: ~Task = Local::take();\n+            let task: Box<Task> = Local::take();\n             cleanup_task(task);\n         });\n     }\n@@ -71,11 +73,11 @@ mod test {\n         run_in_bare_thread(proc() {\n             let task = box Task::new();\n             Local::put(task);\n-            let task: ~Task = Local::take();\n+            let task: Box<Task> = Local::take();\n             cleanup_task(task);\n             let task = box Task::new();\n             Local::put(task);\n-            let task: ~Task = Local::take();\n+            let task: Box<Task> = Local::take();\n             cleanup_task(task);\n         });\n     }\n@@ -89,7 +91,7 @@ mod test {\n             unsafe {\n                 let _task: *mut Task = Local::unsafe_borrow();\n             }\n-            let task: ~Task = Local::take();\n+            let task: Box<Task> = Local::take();\n             cleanup_task(task);\n         });\n     }\n@@ -104,7 +106,7 @@ mod test {\n                 let _ = Local::borrow(None::<Task>);\n             }\n \n-            let task: ~Task = Local::take();\n+            let task: Box<Task> = Local::take();\n             cleanup_task(task);\n         });\n     }\n@@ -115,15 +117,15 @@ mod test {\n             let task = box Task::new();\n             Local::put(task);\n \n-            let t: ~Task = Local::try_take().unwrap();\n-            let u: Option<~Task> = Local::try_take();\n+            let t: Box<Task> = Local::try_take().unwrap();\n+            let u: Option<Box<Task>> = Local::try_take();\n             assert!(u.is_none());\n \n             cleanup_task(t);\n         });\n     }\n \n-    fn cleanup_task(mut t: ~Task) {\n+    fn cleanup_task(mut t: Box<Task>) {\n         t.destroyed = true;\n     }\n "}, {"sha": "39c0d9a54820744abc4c3615f8f2904bb6f653bc", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,7 +10,7 @@\n \n //! Access to a single thread-local pointer.\n //!\n-//! The runtime will use this for storing ~Task.\n+//! The runtime will use this for storing Box<Task>.\n //!\n //! FIXME: Add runtime checks for usage of inconsistent pointer types.\n //! and for overwriting an existing pointer.\n@@ -19,6 +19,7 @@\n \n use cast;\n use ops::{Drop, Deref, DerefMut};\n+use owned::Box;\n use ptr::RawPtr;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n@@ -43,7 +44,7 @@ impl<T> Drop for Borrowed<T> {\n             if self.val.is_null() {\n                 rtabort!(\"Aiee, returning null borrowed object!\");\n             }\n-            let val: ~T = cast::transmute(self.val);\n+            let val: Box<T> = cast::transmute(self.val);\n             put::<T>(val);\n             rtassert!(exists());\n         }\n@@ -84,6 +85,7 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n pub mod compiled {\n     use cast;\n     use option::{Option, Some, None};\n+    use owned::Box;\n     use ptr::RawPtr;\n \n     #[cfg(test)]\n@@ -154,7 +156,7 @@ pub mod compiled {\n     ///\n     /// Does not validate the pointer type.\n     #[inline(never)] // see comments above\n-    pub unsafe fn put<T>(sched: ~T) {\n+    pub unsafe fn put<T>(sched: Box<T>) {\n         RT_TLS_PTR = cast::transmute(sched)\n     }\n \n@@ -164,10 +166,10 @@ pub mod compiled {\n     ///\n     /// Does not validate the pointer type.\n     #[inline(never)] // see comments above\n-    pub unsafe fn take<T>() -> ~T {\n+    pub unsafe fn take<T>() -> Box<T> {\n         let ptr = RT_TLS_PTR;\n         rtassert!(!ptr.is_null());\n-        let ptr: ~T = cast::transmute(ptr);\n+        let ptr: Box<T> = cast::transmute(ptr);\n         // can't use `as`, due to type not matching with `cfg(test)`\n         RT_TLS_PTR = cast::transmute(0);\n         ptr\n@@ -179,12 +181,12 @@ pub mod compiled {\n     ///\n     /// Does not validate the pointer type.\n     #[inline(never)] // see comments above\n-    pub unsafe fn try_take<T>() -> Option<~T> {\n+    pub unsafe fn try_take<T>() -> Option<Box<T>> {\n         let ptr = RT_TLS_PTR;\n         if ptr.is_null() {\n             None\n         } else {\n-            let ptr: ~T = cast::transmute(ptr);\n+            let ptr: Box<T> = cast::transmute(ptr);\n             // can't use `as`, due to type not matching with `cfg(test)`\n             RT_TLS_PTR = cast::transmute(0);\n             Some(ptr)\n@@ -198,7 +200,7 @@ pub mod compiled {\n     /// Does not validate the pointer type.\n     /// Leaves the old pointer in TLS for speed.\n     #[inline(never)] // see comments above\n-    pub unsafe fn unsafe_take<T>() -> ~T {\n+    pub unsafe fn unsafe_take<T>() -> Box<T> {\n         cast::transmute(RT_TLS_PTR)\n     }\n \n@@ -234,6 +236,7 @@ pub mod compiled {\n pub mod native {\n     use cast;\n     use option::{Option, Some, None};\n+    use owned::Box;\n     use ptr;\n     use ptr::RawPtr;\n     use tls = rt::thread_local_storage;\n@@ -259,7 +262,7 @@ pub mod native {\n     ///\n     /// Does not validate the pointer type.\n     #[inline]\n-    pub unsafe fn put<T>(sched: ~T) {\n+    pub unsafe fn put<T>(sched: Box<T>) {\n         let key = tls_key();\n         let void_ptr: *mut u8 = cast::transmute(sched);\n         tls::set(key, void_ptr);\n@@ -271,13 +274,13 @@ pub mod native {\n     ///\n     /// Does not validate the pointer type.\n     #[inline]\n-    pub unsafe fn take<T>() -> ~T {\n+    pub unsafe fn take<T>() -> Box<T> {\n         let key = tls_key();\n         let void_ptr: *mut u8 = tls::get(key);\n         if void_ptr.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n-        let ptr: ~T = cast::transmute(void_ptr);\n+        let ptr: Box<T> = cast::transmute(void_ptr);\n         tls::set(key, ptr::mut_null());\n         return ptr;\n     }\n@@ -288,14 +291,14 @@ pub mod native {\n     ///\n     /// Does not validate the pointer type.\n     #[inline]\n-    pub unsafe fn try_take<T>() -> Option<~T> {\n+    pub unsafe fn try_take<T>() -> Option<Box<T>> {\n         match maybe_tls_key() {\n             Some(key) => {\n                 let void_ptr: *mut u8 = tls::get(key);\n                 if void_ptr.is_null() {\n                     None\n                 } else {\n-                    let ptr: ~T = cast::transmute(void_ptr);\n+                    let ptr: Box<T> = cast::transmute(void_ptr);\n                     tls::set(key, ptr::mut_null());\n                     Some(ptr)\n                 }\n@@ -311,13 +314,13 @@ pub mod native {\n     /// Does not validate the pointer type.\n     /// Leaves the old pointer in TLS for speed.\n     #[inline]\n-    pub unsafe fn unsafe_take<T>() -> ~T {\n+    pub unsafe fn unsafe_take<T>() -> Box<T> {\n         let key = tls_key();\n         let void_ptr: *mut u8 = tls::get(key);\n         if void_ptr.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n-        let ptr: ~T = cast::transmute(void_ptr);\n+        let ptr: Box<T> = cast::transmute(void_ptr);\n         return ptr;\n     }\n "}, {"sha": "e79e305683892a98ea4602766a2328f9e8fe9196", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -57,6 +57,7 @@ Several modules in `core` are clients of `rt`:\n use any::Any;\n use kinds::Send;\n use option::Option;\n+use owned::Box;\n use result::Result;\n use task::TaskOpts;\n \n@@ -151,22 +152,25 @@ pub static DEFAULT_ERROR_CODE: int = 101;\n pub trait Runtime {\n     // Necessary scheduling functions, used for channels and blocking I/O\n     // (sometimes).\n-    fn yield_now(~self, cur_task: ~Task);\n-    fn maybe_yield(~self, cur_task: ~Task);\n-    fn deschedule(~self, times: uint, cur_task: ~Task,\n+    fn yield_now(~self, cur_task: Box<Task>);\n+    fn maybe_yield(~self, cur_task: Box<Task>);\n+    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(~self, to_wake: ~Task);\n+    fn reawaken(~self, to_wake: Box<Task>);\n \n     // Miscellaneous calls which are very different depending on what context\n     // you're in.\n-    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc():Send);\n+    fn spawn_sibling(~self,\n+                     cur_task: Box<Task>,\n+                     opts: TaskOpts,\n+                     f: proc():Send);\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n     fn can_block(&self) -> bool;\n \n     // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(~self) -> ~Any;\n+    fn wrap(~self) -> Box<Any>;\n }\n \n /// One-time runtime initialization."}, {"sha": "fe9f4932a2a20d3dcc39be2cb3e0cb0e008b63f0", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -18,6 +18,7 @@ use libc;\n use kinds::Send;\n use ops::Drop;\n use option::{Option, Some, None};\n+use owned::Box;\n use path::Path;\n use result::Err;\n use rt::local::Local;\n@@ -40,9 +41,10 @@ pub trait Callback {\n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, arg: proc():Send);\n-    fn pausable_idle_callback(&mut self,\n-                              ~Callback:Send) -> ~PausableIdleCallback:Send;\n-    fn remote_callback(&mut self, ~Callback:Send) -> ~RemoteCallback:Send;\n+    fn pausable_idle_callback(&mut self, Box<Callback:Send>)\n+                              -> Box<PausableIdleCallback:Send>;\n+    fn remote_callback(&mut self, Box<Callback:Send>)\n+                       -> Box<RemoteCallback:Send>;\n \n     /// The asynchronous I/O services. Not all event loops may provide one.\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n@@ -114,7 +116,7 @@ impl<'a> LocalIo<'a> {\n         //\n         // In order to get around this, we just transmute a copy out of the task\n         // in order to have what is likely a static lifetime (bad).\n-        let mut t: ~Task = Local::take();\n+        let mut t: Box<Task> = Local::take();\n         let ret = t.local_io().map(|t| {\n             unsafe { cast::transmute_copy(&t) }\n         });\n@@ -149,21 +151,23 @@ impl<'a> LocalIo<'a> {\n pub trait IoFactory {\n     // networking\n     fn tcp_connect(&mut self, addr: SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<~RtioTcpStream:Send>;\n-    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send>;\n-    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send>;\n+                   timeout: Option<u64>) -> IoResult<Box<RtioTcpStream:Send>>;\n+    fn tcp_bind(&mut self, addr: SocketAddr)\n+                -> IoResult<Box<RtioTcpListener:Send>>;\n+    fn udp_bind(&mut self, addr: SocketAddr)\n+                -> IoResult<Box<RtioUdpSocket:Send>>;\n     fn unix_bind(&mut self, path: &CString)\n-        -> IoResult<~RtioUnixListener:Send>;\n+                 -> IoResult<Box<RtioUnixListener:Send>>;\n     fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<~RtioPipe:Send>;\n+                    timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]>;\n \n     // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n-        -> ~RtioFileStream:Send;\n+                      -> Box<RtioFileStream:Send>;\n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> IoResult<~RtioFileStream:Send>;\n+               -> IoResult<Box<RtioFileStream:Send>>;\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;\n     fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;\n     fn fs_mkdir(&mut self, path: &CString,\n@@ -184,23 +188,24 @@ pub trait IoFactory {\n         IoResult<()>;\n \n     // misc\n-    fn timer_init(&mut self) -> IoResult<~RtioTimer:Send>;\n+    fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>>;\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> IoResult<(~RtioProcess:Send, ~[Option<~RtioPipe:Send>])>;\n+            -> IoResult<(Box<RtioProcess:Send>,\n+                         ~[Option<Box<RtioPipe:Send>>])>;\n     fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send>;\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> IoResult<~RtioTTY:Send>;\n+            -> IoResult<Box<RtioTTY:Send>>;\n     fn signal(&mut self, signal: Signum, channel: Sender<Signum>)\n-        -> IoResult<~RtioSignal:Send>;\n+        -> IoResult<Box<RtioSignal:Send>>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n-    fn listen(~self) -> IoResult<~RtioTcpAcceptor:Send>;\n+    fn listen(~self) -> IoResult<Box<RtioTcpAcceptor:Send>>;\n }\n \n pub trait RtioTcpAcceptor : RtioSocket {\n-    fn accept(&mut self) -> IoResult<~RtioTcpStream:Send>;\n+    fn accept(&mut self) -> IoResult<Box<RtioTcpStream:Send>>;\n     fn accept_simultaneously(&mut self) -> IoResult<()>;\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n     fn set_timeout(&mut self, timeout: Option<u64>);\n@@ -214,7 +219,7 @@ pub trait RtioTcpStream : RtioSocket {\n     fn nodelay(&mut self) -> IoResult<()>;\n     fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()>;\n     fn letdie(&mut self) -> IoResult<()>;\n-    fn clone(&self) -> ~RtioTcpStream:Send;\n+    fn clone(&self) -> Box<RtioTcpStream:Send>;\n     fn close_write(&mut self) -> IoResult<()>;\n }\n \n@@ -238,7 +243,7 @@ pub trait RtioUdpSocket : RtioSocket {\n     fn hear_broadcasts(&mut self) -> IoResult<()>;\n     fn ignore_broadcasts(&mut self) -> IoResult<()>;\n \n-    fn clone(&self) -> ~RtioUdpSocket:Send;\n+    fn clone(&self) -> Box<RtioUdpSocket:Send>;\n }\n \n pub trait RtioTimer {\n@@ -268,15 +273,15 @@ pub trait RtioProcess {\n pub trait RtioPipe {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n     fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn clone(&self) -> ~RtioPipe:Send;\n+    fn clone(&self) -> Box<RtioPipe:Send>;\n }\n \n pub trait RtioUnixListener {\n-    fn listen(~self) -> IoResult<~RtioUnixAcceptor:Send>;\n+    fn listen(~self) -> IoResult<Box<RtioUnixAcceptor:Send>>;\n }\n \n pub trait RtioUnixAcceptor {\n-    fn accept(&mut self) -> IoResult<~RtioPipe:Send>;\n+    fn accept(&mut self) -> IoResult<Box<RtioPipe:Send>>;\n     fn set_timeout(&mut self, timeout: Option<u64>);\n }\n "}, {"sha": "b9bcd1de8fc25ce17df6012d309ac3604d5ce811", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -37,6 +37,7 @@ pub static RED_ZONE: uint = 20 * 1024;\n #[cfg(not(test))] // in testing, use the original libstd's version\n pub extern \"C\" fn rust_stack_exhausted() {\n     use option::{Option, None, Some};\n+    use owned::Box;\n     use rt::local::Local;\n     use rt::task::Task;\n     use str::Str;\n@@ -85,7 +86,7 @@ pub extern \"C\" fn rust_stack_exhausted() {\n         //  #9854 - unwinding on windows through __morestack has never worked\n         //  #2361 - possible implementation of not using landing pads\n \n-        let task: Option<~Task> = Local::try_take();\n+        let task: Option<Box<Task>> = Local::try_take();\n         let name = match task {\n             Some(ref task) => {\n                 task.name.as_ref().map(|n| n.as_slice())"}, {"sha": "5b29de5a8c1d3781d42ff51c7b16e296e4c2cc21", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -24,6 +24,7 @@ use kinds::Send;\n use local_data;\n use ops::Drop;\n use option::{Option, Some, None};\n+use owned::Box;\n use prelude::drop;\n use result::{Result, Ok, Err};\n use rt::Runtime;\n@@ -51,19 +52,20 @@ pub struct Task {\n     pub destroyed: bool,\n     pub name: Option<SendStr>,\n \n-    pub stdout: Option<~Writer:Send>,\n-    pub stderr: Option<~Writer:Send>,\n+    pub stdout: Option<Box<Writer:Send>>,\n+    pub stderr: Option<Box<Writer:Send>>,\n \n-    imp: Option<~Runtime:Send>,\n+    imp: Option<Box<Runtime:Send>>,\n }\n \n pub struct GarbageCollector;\n pub struct LocalStorage(pub Option<local_data::Map>);\n \n-/// A handle to a blocked task. Usually this means having the ~Task pointer by\n-/// ownership, but if the task is killable, a killer can steal it at any time.\n+/// A handle to a blocked task. Usually this means having the Box<Task>\n+/// pointer by ownership, but if the task is killable, a killer can steal it\n+/// at any time.\n pub enum BlockedTask {\n-    Owned(~Task),\n+    Owned(Box<Task>),\n     Shared(UnsafeArc<AtomicUint>),\n }\n \n@@ -109,12 +111,12 @@ impl Task {\n     /// This function is *not* meant to be abused as a \"try/catch\" block. This\n     /// is meant to be used at the absolute boundaries of a task's lifetime, and\n     /// only for that purpose.\n-    pub fn run(~self, mut f: ||) -> ~Task {\n+    pub fn run(~self, mut f: ||) -> Box<Task> {\n         // Need to put ourselves into TLS, but also need access to the unwinder.\n         // Unsafely get a handle to the task so we can continue to use it after\n         // putting it in tls (so we can invoke the unwinder).\n         let handle: *mut Task = unsafe {\n-            *cast::transmute::<&~Task, &*mut Task>(&self)\n+            *cast::transmute::<&Box<Task>, &*mut Task>(&self)\n         };\n         Local::put(self);\n \n@@ -187,15 +189,15 @@ impl Task {\n             let me: *mut Task = Local::unsafe_borrow();\n             (*me).death.collect_failure((*me).unwinder.result());\n         }\n-        let mut me: ~Task = Local::take();\n+        let mut me: Box<Task> = Local::take();\n         me.destroyed = true;\n         return me;\n     }\n \n     /// Inserts a runtime object into this task, transferring ownership to the\n     /// task. It is illegal to replace a previous runtime object in this task\n     /// with this argument.\n-    pub fn put_runtime(&mut self, ops: ~Runtime:Send) {\n+    pub fn put_runtime(&mut self, ops: Box<Runtime:Send>) {\n         assert!(self.imp.is_none());\n         self.imp = Some(ops);\n     }\n@@ -207,12 +209,12 @@ impl Task {\n     ///\n     /// It is recommended to only use this method when *absolutely necessary*.\n     /// This function may not be available in the future.\n-    pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<~T> {\n+    pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<Box<T>> {\n         // This is a terrible, terrible function. The general idea here is to\n-        // take the runtime, cast it to ~Any, check if it has the right type,\n-        // and then re-cast it back if necessary. The method of doing this is\n-        // pretty sketchy and involves shuffling vtables of trait objects\n-        // around, but it gets the job done.\n+        // take the runtime, cast it to Box<Any>, check if it has the right\n+        // type, and then re-cast it back if necessary. The method of doing\n+        // this is pretty sketchy and involves shuffling vtables of trait\n+        // objects around, but it gets the job done.\n         //\n         // FIXME: This function is a serious code smell and should be avoided at\n         //      all costs. I have yet to think of a method to avoid this\n@@ -225,7 +227,8 @@ impl Task {\n                 Ok(t) => Some(t),\n                 Err(t) => {\n                     let (_, obj): (uint, uint) = cast::transmute(t);\n-                    let obj: ~Runtime:Send = cast::transmute((vtable, obj));\n+                    let obj: Box<Runtime:Send> =\n+                        cast::transmute((vtable, obj));\n                     self.put_runtime(obj);\n                     None\n                 }\n@@ -308,7 +311,7 @@ impl Iterator<BlockedTask> for BlockedTasks {\n \n impl BlockedTask {\n     /// Returns Some if the task was successfully woken; None if already killed.\n-    pub fn wake(self) -> Option<~Task> {\n+    pub fn wake(self) -> Option<Box<Task>> {\n         match self {\n             Owned(task) => Some(task),\n             Shared(arc) => unsafe {\n@@ -326,7 +329,7 @@ impl BlockedTask {\n     #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n \n     /// Create a blocked task, unless the task was already killed.\n-    pub fn block(task: ~Task) -> BlockedTask {\n+    pub fn block(task: Box<Task>) -> BlockedTask {\n         Owned(task)\n     }\n \n@@ -367,7 +370,7 @@ impl BlockedTask {\n         if blocked_task_ptr & 0x1 == 0 {\n             Owned(cast::transmute(blocked_task_ptr))\n         } else {\n-            let ptr: ~UnsafeArc<AtomicUint> =\n+            let ptr: Box<UnsafeArc<AtomicUint>> =\n                 cast::transmute(blocked_task_ptr & !1);\n             Shared(*ptr)\n         }"}, {"sha": "bc9a0b3460ac6e3f071e1f25bf4305298c17b8dc", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -22,6 +22,7 @@ use kinds::Send;\n use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n+use owned::Box;\n use uint;\n \n type StartFn = extern \"C\" fn(*libc::c_void) -> imp::rust_thread_return;\n@@ -31,7 +32,7 @@ type StartFn = extern \"C\" fn(*libc::c_void) -> imp::rust_thread_return;\n pub struct Thread<T> {\n     native: imp::rust_thread,\n     joined: bool,\n-    packet: ~Option<T>,\n+    packet: Box<Option<T>>,\n }\n \n static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n@@ -45,7 +46,7 @@ extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n     use rt::stack;\n     unsafe {\n         stack::record_stack_bounds(0, uint::MAX);\n-        let f: ~proc() = cast::transmute(main);\n+        let f: Box<proc()> = cast::transmute(main);\n         (*f)();\n         cast::transmute(0 as imp::rust_thread_return)\n     }\n@@ -78,11 +79,11 @@ impl Thread<()> {\n     pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n \n         // We need the address of the packet to fill in to be stable so when\n-        // `main` fills it in it's still valid, so allocate an extra ~ box to do\n+        // `main` fills it in it's still valid, so allocate an extra box to do\n         // so.\n         let packet = box None;\n         let packet2: *mut Option<T> = unsafe {\n-            *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n+            *cast::transmute::<&Box<Option<T>>, **mut Option<T>>(&packet)\n         };\n         let main = proc() unsafe { *packet2 = Some(main()); };\n         let native = unsafe { imp::create(stack, box main) };\n@@ -152,13 +153,14 @@ mod imp {\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                        LPVOID, DWORD, LPDWORD, HANDLE};\n     use os;\n+    use owned::Box;\n     use ptr;\n     use rt::stack::RED_ZONE;\n \n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n \n-    pub unsafe fn create(stack: uint, p: ~proc():Send) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n         let arg: *mut libc::c_void = cast::transmute(p);\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -175,7 +177,7 @@ mod imp {\n \n         if ret as uint == 0 {\n             // be sure to not leak the closure\n-            let _p: ~proc():Send = cast::transmute(arg);\n+            let _p: Box<proc():Send> = cast::transmute(arg);\n             fail!(\"failed to spawn native thread: {}\", os::last_os_error());\n         }\n         return ret;\n@@ -218,13 +220,14 @@ mod imp {\n     use libc;\n     use mem;\n     use os;\n+    use owned::Box;\n     use ptr;\n     use rt::stack::RED_ZONE;\n \n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *u8;\n \n-    pub unsafe fn create(stack: uint, p: ~proc():Send) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n         let mut native: libc::pthread_t = mem::uninit();\n         let mut attr: libc::pthread_attr_t = mem::uninit();\n         assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -257,7 +260,7 @@ mod imp {\n \n         if ret != 0 {\n             // be sure to not leak the closure\n-            let _p: ~proc():Send = cast::transmute(arg);\n+            let _p: Box<proc():Send> = cast::transmute(arg);\n             fail!(\"failed to spawn native thread: {}\", os::last_os_error());\n         }\n         native"}, {"sha": "7706206863617528c9118e82c585d1ab2a2b0a1c", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,6 +10,8 @@\n \n #![allow(dead_code)]\n \n+#[cfg(test)]\n+use owned::Box;\n #[cfg(unix)]\n use libc::c_int;\n #[cfg(unix)]\n@@ -99,11 +101,11 @@ fn tls_smoke_test() {\n         let value = box 20;\n         create(&mut key);\n         set(key, transmute(value));\n-        let value: ~int = transmute(get(key));\n+        let value: Box<int> = transmute(get(key));\n         assert_eq!(value, box 20);\n         let value = box 30;\n         set(key, transmute(value));\n-        let value: ~int = transmute(get(key));\n+        let value: Box<int> = transmute(get(key));\n         assert_eq!(value, box 30);\n     }\n }"}, {"sha": "3ba97f381ab08b3b3a9f87ea53bb00c36b9d8b94", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -64,6 +64,7 @@ use fmt;\n use kinds::Send;\n use mem;\n use option::{Some, None, Option};\n+use owned::Box;\n use prelude::drop;\n use ptr::RawPtr;\n use result::{Err, Ok};\n@@ -78,7 +79,7 @@ use uw = rt::libunwind;\n \n pub struct Unwinder {\n     unwinding: bool,\n-    cause: Option<~Any:Send>\n+    cause: Option<Box<Any:Send>>\n }\n \n impl Unwinder {\n@@ -128,7 +129,7 @@ impl Unwinder {\n         }\n     }\n \n-    pub fn begin_unwind(&mut self, cause: ~Any:Send) -> ! {\n+    pub fn begin_unwind(&mut self, cause: Box<Any:Send>) -> ! {\n         rtdebug!(\"begin_unwind()\");\n \n         self.unwinding = true;\n@@ -154,7 +155,8 @@ impl Unwinder {\n                                             exception: *uw::_Unwind_Exception) {\n                 rtdebug!(\"exception_cleanup()\");\n                 unsafe {\n-                    let _: ~uw::_Unwind_Exception = cast::transmute(exception);\n+                    let _: Box<uw::_Unwind_Exception> =\n+                        cast::transmute(exception);\n                 }\n             }\n         }\n@@ -374,14 +376,16 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n /// Do this split took the LLVM IR line counts of `fn main() { fail!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: ~Any:Send, file: &'static str, line: uint) -> ! {\n+fn begin_unwind_inner(msg: Box<Any:Send>,\n+                      file: &'static str,\n+                      line: uint) -> ! {\n     let mut task;\n     {\n         let msg_s = match msg.as_ref::<&'static str>() {\n             Some(s) => *s,\n             None => match msg.as_ref::<~str>() {\n                 Some(s) => s.as_slice(),\n-                None => \"~Any\",\n+                None => \"Box<Any>\",\n             }\n         };\n \n@@ -392,7 +396,7 @@ fn begin_unwind_inner(msg: ~Any:Send, file: &'static str, line: uint) -> ! {\n         // order to get some better diagnostics, we print on failure and\n         // immediately abort the whole process if there is no local task\n         // available.\n-        let opt_task: Option<~Task> = Local::try_take();\n+        let opt_task: Option<Box<Task>> = Local::try_take();\n         task = match opt_task {\n             Some(t) => t,\n             None => {"}, {"sha": "2ea6dc1afe61384948c7522ea80c44f819e22400", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -2352,10 +2352,11 @@ impl<A> FromIterator<A> for ~[A] {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use mem;\n-    use slice::*;\n     use cmp::*;\n+    use mem;\n+    use owned::Box;\n     use rand::{Rng, task_rng};\n+    use slice::*;\n \n     fn square(n: uint) -> uint { n * n }\n \n@@ -2738,8 +2739,8 @@ mod tests {\n         let mut v2 = vec![box 1, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n-         * If the ~pointers were leaked or otherwise misused, valgrind and/or\n-         * rustrt should raise errors.\n+         * If the boxed pointers were leaked or otherwise misused, valgrind\n+         * and/or rustrt should raise errors.\n          */\n     }\n \n@@ -3117,7 +3118,7 @@ mod tests {\n \n         struct S {\n             f: Cell<int>,\n-            boxes: (~int, Rc<int>)\n+            boxes: (Box<int>, Rc<int>)\n         }\n \n         impl Clone for S {\n@@ -3566,13 +3567,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 11);\n \n-        let xs = vec![Foo, Foo, Foo];\n-        assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n-                   \"~[slice::tests::Foo, slice::tests::Foo]\".to_owned());\n-\n         let xs: [Foo, ..3] = [Foo, Foo, Foo];\n-        assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n-                   \"~[slice::tests::Foo, slice::tests::Foo]\".to_owned());\n         cnt = 0;\n         for f in xs.iter() {\n             assert!(*f == Foo);"}, {"sha": "2a51de7ce5ceaf0291b6fe841cd17b211ea51d11", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -20,9 +20,9 @@ Rust. Each string must also be decorated with its ownership. This means that\n there are two common kinds of strings in Rust:\n \n * `~str` - This is an owned string. This type obeys all of the normal semantics\n-           of the `~T` types, meaning that it has one, and only one, owner. This\n-           type cannot be implicitly copied, and is moved out of when passed to\n-           other functions.\n+           of the `Box<T>` types, meaning that it has one, and only one,\n+           owner. This type cannot be implicitly copied, and is moved out of\n+           when passed to other functions.\n \n * `&str` - This is the borrowed string type. This type of string can only be\n            created from the other kind of string. As the name \"borrowed\""}, {"sha": "d277c514e444f4e4591572426379b78571dec465", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,6 +26,7 @@ use clone::Clone;\n use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n+use owned::Box;\n use ptr::RawPtr;\n use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n use ty::Unsafe;\n@@ -157,7 +158,7 @@ impl<T> Drop for UnsafeArc<T>{\n                 //  happened before), and an \"acquire\" operation before deleting the object.\n                 // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n                 fence(Acquire);\n-                let _: ~ArcData<T> = cast::transmute(self.data);\n+                let _: Box<ArcData<T>> = cast::transmute(self.data);\n             }\n         }\n     }"}, {"sha": "2fba59c3233e264ba6dff6d1e55166506d09fcb4", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -88,7 +88,7 @@\n //!         }\n //!     });\n //!\n-//!     shared_big_object.swap(~BigObject, SeqCst);\n+//!     shared_big_object.swap(box BigObject, SeqCst);\n //! }\n //! ```\n //!\n@@ -112,6 +112,7 @@ use cast;\n use std::kinds::marker;\n use option::{Option,Some,None};\n use ops::Drop;\n+use owned::Box;\n use ty::Unsafe;\n \n /// An atomic boolean type.\n@@ -663,7 +664,7 @@ impl<T> AtomicPtr<T> {\n \n impl<T> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n-    pub fn new(p: ~T) -> AtomicOption<T> {\n+    pub fn new(p: Box<T>) -> AtomicOption<T> {\n         unsafe { AtomicOption { p: Unsafe::new(cast::transmute(p)) } }\n     }\n \n@@ -672,7 +673,7 @@ impl<T> AtomicOption<T> {\n \n     /// Store a value, returning the old value\n     #[inline]\n-    pub fn swap(&self, val: ~T, order: Ordering) -> Option<~T> {\n+    pub fn swap(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n         unsafe {\n             let val = cast::transmute(val);\n \n@@ -687,7 +688,7 @@ impl<T> AtomicOption<T> {\n \n     /// Remove the value, leaving the `AtomicOption` empty.\n     #[inline]\n-    pub fn take(&self, order: Ordering) -> Option<~T> {\n+    pub fn take(&self, order: Ordering) -> Option<Box<T>> {\n         unsafe { self.swap(cast::transmute(0), order) }\n     }\n \n@@ -697,7 +698,7 @@ impl<T> AtomicOption<T> {\n     /// the option was already `Some`, returns `Some` of the rejected\n     /// value.\n     #[inline]\n-    pub fn fill(&self, val: ~T, order: Ordering) -> Option<~T> {\n+    pub fn fill(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n         unsafe {\n             let val = cast::transmute(val);\n             let expected = cast::transmute(0);"}, {"sha": "d06062f02ac8adf4c22a7ca2f6484097e54635fa", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -56,6 +56,7 @@ use libc;\n use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n+use owned::Box;\n use ptr;\n use ptr::RawPtr;\n use sync::arc::UnsafeArc;\n@@ -117,7 +118,7 @@ pub enum Stolen<T> {\n /// will only use this structure when allocating a new buffer or deallocating a\n /// previous one.\n pub struct BufferPool<T> {\n-    pool: Exclusive<Vec<~Buffer<T>>>,\n+    pool: Exclusive<Vec<Box<Buffer<T>>>>,\n }\n \n /// An internal buffer used by the chase-lev deque. This structure is actually\n@@ -154,7 +155,7 @@ impl<T: Send> BufferPool<T> {\n         (Worker { deque: a }, Stealer { deque: b })\n     }\n \n-    fn alloc(&mut self, bits: int) -> ~Buffer<T> {\n+    fn alloc(&mut self, bits: int) -> Box<Buffer<T>> {\n         unsafe {\n             self.pool.with(|pool| {\n                 match pool.iter().position(|x| x.size() >= (1 << bits)) {\n@@ -165,7 +166,7 @@ impl<T: Send> BufferPool<T> {\n         }\n     }\n \n-    fn free(&mut self, buf: ~Buffer<T>) {\n+    fn free(&mut self, buf: Box<Buffer<T>>) {\n         unsafe {\n             let mut buf = Some(buf);\n             self.pool.with(|pool| {\n@@ -400,6 +401,7 @@ mod tests {\n     use super::{Data, BufferPool, Abort, Empty, Worker, Stealer};\n \n     use cast;\n+    use owned::Box;\n     use rt::thread::Thread;\n     use rand;\n     use rand::Rng;\n@@ -471,7 +473,7 @@ mod tests {\n         t.join();\n     }\n \n-    fn stampede(mut w: Worker<~int>, s: Stealer<~int>,\n+    fn stampede(mut w: Worker<Box<int>>, s: Stealer<Box<int>>,\n                 nthreads: int, amt: uint) {\n         for _ in range(0, amt) {\n             w.push(box 20);\n@@ -486,7 +488,7 @@ mod tests {\n                     let mut s = s;\n                     while (*unsafe_remaining).load(SeqCst) > 0 {\n                         match s.steal() {\n-                            Data(~20) => {\n+                            Data(box 20) => {\n                                 (*unsafe_remaining).fetch_sub(1, SeqCst);\n                             }\n                             Data(..) => fail!(),\n@@ -499,7 +501,7 @@ mod tests {\n \n         while remaining.load(SeqCst) > 0 {\n             match w.pop() {\n-                Some(~20) => { remaining.fetch_sub(1, SeqCst); }\n+                Some(box 20) => { remaining.fetch_sub(1, SeqCst); }\n                 Some(..) => fail!(),\n                 None => {}\n             }\n@@ -512,15 +514,15 @@ mod tests {\n \n     #[test]\n     fn run_stampede() {\n-        let mut pool = BufferPool::<~int>::new();\n+        let mut pool = BufferPool::<Box<int>>::new();\n         let (w, s) = pool.deque();\n         stampede(w, s, 8, 10000);\n     }\n \n     #[test]\n     fn many_stampede() {\n         static AMT: uint = 4;\n-        let mut pool = BufferPool::<~int>::new();\n+        let mut pool = BufferPool::<Box<int>>::new();\n         let threads = range(0, AMT).map(|_| {\n             let (w, s) = pool.deque();\n             Thread::start(proc() {\n@@ -605,7 +607,8 @@ mod tests {\n             let s = s.clone();\n             let unique_box = box AtomicUint::new(0);\n             let thread_box = unsafe {\n-                *cast::transmute::<&~AtomicUint,**mut AtomicUint>(&unique_box)\n+                *cast::transmute::<&Box<AtomicUint>,\n+                                   **mut AtomicUint>(&unique_box)\n             };\n             (Thread::start(proc() {\n                 unsafe {"}, {"sha": "e05959e25918ba7862cb4d5d84902ba251d72b62", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -42,6 +42,7 @@ use cast;\n use kinds::Send;\n use ops::Drop;\n use option::{Option, None, Some};\n+use owned::Box;\n use ptr::RawPtr;\n use sync::atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n \n@@ -120,7 +121,7 @@ impl<T: Send> Queue<T> {\n                 assert!((*tail).value.is_none());\n                 assert!((*next).value.is_some());\n                 let ret = (*next).value.take_unwrap();\n-                let _: ~Node<T> = cast::transmute(tail);\n+                let _: Box<Node<T>> = cast::transmute(tail);\n                 return Data(ret);\n             }\n \n@@ -145,7 +146,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = self.tail;\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Relaxed);\n-                let _: ~Node<T> = cast::transmute(cur);\n+                let _: Box<Node<T>> = cast::transmute(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "7854a0e168ebd95e71fb0dd0fb78008992ffc911", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -37,6 +37,7 @@ use cast;\n use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n+use owned::Box;\n use ptr::RawPtr;\n use sync::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n \n@@ -187,7 +188,7 @@ impl<T: Send> Queue<T> {\n                     (*self.tail_prev.load(Relaxed)).next.store(next, Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n-                    let _: ~Node<T> = cast::transmute(tail);\n+                    let _: Box<Node<T>> = cast::transmute(tail);\n                 }\n             }\n             return ret;\n@@ -215,7 +216,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = self.first;\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Relaxed);\n-                let _n: ~Node<T> = cast::transmute(cur);\n+                let _n: Box<Node<T>> = cast::transmute(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "7c5e984ad36757cccf4d1438649861d1abdb8a83", "filename": "src/libstd/task.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -41,6 +41,7 @@ use comm::{Sender, Receiver, channel};\n use io::Writer;\n use kinds::{Send, marker};\n use option::{None, Some, Option};\n+use owned::Box;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n use rt::task::Task;\n@@ -56,7 +57,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n ///\n /// If you wish for this result's delivery to block until all\n /// children tasks complete, recommend using a result future.\n-pub type TaskResult = Result<(), ~Any:Send>;\n+pub type TaskResult = Result<(), Box<Any:Send>>;\n \n /// Task configuration options\n pub struct TaskOpts {\n@@ -67,9 +68,9 @@ pub struct TaskOpts {\n     /// The size of the stack for the spawned task\n     pub stack_size: Option<uint>,\n     /// Task-local stdout\n-    pub stdout: Option<~Writer:Send>,\n+    pub stdout: Option<Box<Writer:Send>>,\n     /// Task-local stderr\n-    pub stderr: Option<~Writer:Send>,\n+    pub stderr: Option<Box<Writer:Send>>,\n }\n \n /**\n@@ -173,7 +174,7 @@ impl TaskBuilder {\n             Some(gen) => gen(f),\n             None => f\n         };\n-        let t: ~Task = Local::take();\n+        let t: Box<Task> = Local::take();\n         t.spawn_sibling(self.opts, f);\n     }\n \n@@ -190,7 +191,8 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(mut self, f: proc():Send -> T) -> Result<T, ~Any:Send> {\n+    pub fn try<T:Send>(mut self, f: proc():Send -> T)\n+               -> Result<T, Box<Any:Send>> {\n         let (tx, rx) = channel();\n \n         let result = self.future_result();\n@@ -240,7 +242,7 @@ pub fn spawn(f: proc():Send) {\n /// the function or an error if the task failed\n ///\n /// This is equivalent to TaskBuilder::new().try\n-pub fn try<T:Send>(f: proc():Send -> T) -> Result<T, ~Any:Send> {\n+pub fn try<T:Send>(f: proc():Send -> T) -> Result<T, Box<Any:Send>> {\n     TaskBuilder::new().try(f)\n }\n \n@@ -264,7 +266,7 @@ pub fn deschedule() {\n     use rt::local::Local;\n \n     // FIXME(#7544): Optimize this, since we know we won't block.\n-    let task: ~Task = Local::take();\n+    let task: Box<Task> = Local::take();\n     task.yield_now();\n }\n \n@@ -507,10 +509,10 @@ fn test_try_fail_message_owned_str() {\n #[test]\n fn test_try_fail_message_any() {\n     match try(proc() {\n-        fail!(box 413u16 as ~Any:Send);\n+        fail!(box 413u16 as Box<Any:Send>);\n     }) {\n         Err(e) => {\n-            type T = ~Any:Send;\n+            type T = Box<Any:Send>;\n             assert!(e.is::<T>());\n             let any = e.move::<T>().unwrap();\n             assert!(any.is::<u16>());"}, {"sha": "f0f126bcf16c21c87945123413e89e72badfb1f5", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -971,9 +971,9 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(~1);\n-    /// vec.push_all_move(vec!(~2, ~3, ~4));\n-    /// assert_eq!(vec, vec!(~1, ~2, ~3, ~4));\n+    /// let mut vec = vec!(box 1);\n+    /// vec.push_all_move(vec!(box 2, box 3, box 4));\n+    /// assert_eq!(vec, vec!(box 1, box 2, box 3, box 4));\n     /// ```\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n         self.extend(other.move_iter());"}, {"sha": "54c3a9c77f8161e6252b5e2b94de862426f46afe", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -208,7 +208,7 @@ impl StaticMutex {\n         // After we've failed the fast path, then we delegate to the differnet\n         // locking protocols for green/native tasks. This will select two tasks\n         // to continue further (one native, one green).\n-        let t: ~Task = Local::take();\n+        let t: Box<Task> = Local::take();\n         let can_block = t.can_block();\n         let native_bit;\n         if can_block {\n@@ -244,7 +244,7 @@ impl StaticMutex {\n         // regularly in native/green contention. Due to try_lock and the header\n         // of lock stealing the lock, it's also possible for native/native\n         // contention to hit this location, but as less common.\n-        let t: ~Task = Local::take();\n+        let t: Box<Task> = Local::take();\n         t.deschedule(1, |task| {\n             let task = unsafe { task.cast_to_uint() };\n \n@@ -308,7 +308,7 @@ impl StaticMutex {\n \n     // Tasks which can block are super easy. These tasks just call the blocking\n     // `lock()` function on an OS mutex\n-    fn native_lock(&self, t: ~Task) {\n+    fn native_lock(&self, t: Box<Task>) {\n         Local::put(t);\n         unsafe { self.lock.lock_noguard(); }\n     }\n@@ -317,7 +317,7 @@ impl StaticMutex {\n         unsafe { self.lock.unlock_noguard(); }\n     }\n \n-    fn green_lock(&self, t: ~Task) {\n+    fn green_lock(&self, t: Box<Task>) {\n         // Green threads flag their presence with an atomic counter, and if they\n         // fail to be the first to the mutex, they enqueue themselves on a\n         // concurrent internal queue with a stack-allocated node."}, {"sha": "313720fa932dce5a35fcd361fe375dfd174ea74d", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -167,7 +167,9 @@ impl<Q: Send> Sem<Q> {\n #[unsafe_destructor]\n impl<Q: Send> Drop for Sem<Q> {\n     fn drop(&mut self) {\n-        let _waiters: ~SemInner<Q> = unsafe { cast::transmute(self.inner) };\n+        let _waiters: Box<SemInner<Q>> = unsafe {\n+            cast::transmute(self.inner)\n+        };\n         self.inner = 0 as *();\n     }\n }\n@@ -835,7 +837,7 @@ mod tests {\n         let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n \n-        let result: result::Result<(), ~Any:Send> = task::try(proc() {\n+        let result: result::Result<(), Box<Any:Send>> = task::try(proc() {\n             let _lock = m2.lock();\n             fail!();\n         });\n@@ -1075,7 +1077,7 @@ mod tests {\n         let x = Arc::new(RWLock::new());\n         let x2 = x.clone();\n \n-        let result: result::Result<(), ~Any:Send> = task::try(proc() {\n+        let result: result::Result<(), Box<Any:Send>> = task::try(proc() {\n             lock_rwlock_in_mode(&x2, mode1, || {\n                 fail!();\n             })"}, {"sha": "ee61ce24c30f8521ce63b4a59448889c727059ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -121,7 +121,7 @@ pub fn is_shift_binop(b: BinOp) -> bool {\n pub fn unop_to_str(op: UnOp) -> &'static str {\n     match op {\n       UnBox => \"@\",\n-      UnUniq => \"~\",\n+      UnUniq => \"box() \",\n       UnDeref => \"*\",\n       UnNot => \"!\",\n       UnNeg => \"-\","}, {"sha": "ee03046b6d6897b893ee375e65d002af9c57ddc1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -111,7 +111,7 @@ impl SpanHandler {\n // others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<uint>,\n-    emit: RefCell<~Emitter:Send>,\n+    emit: RefCell<Box<Emitter:Send>>,\n }\n \n impl Handler {\n@@ -180,7 +180,7 @@ pub fn default_handler() -> Handler {\n     mk_handler(box EmitterWriter::stderr())\n }\n \n-pub fn mk_handler(e: ~Emitter:Send) -> Handler {\n+pub fn mk_handler(e: Box<Emitter:Send>) -> Handler {\n     Handler {\n         err_count: Cell::new(0),\n         emit: RefCell::new(e),\n@@ -253,7 +253,7 @@ pub struct EmitterWriter {\n \n enum Destination {\n     Terminal(term::Terminal<io::stdio::StdWriter>),\n-    Raw(~Writer:Send),\n+    Raw(Box<Writer:Send>),\n }\n \n impl EmitterWriter {\n@@ -270,7 +270,7 @@ impl EmitterWriter {\n         }\n     }\n \n-    pub fn new(dst: ~Writer:Send) -> EmitterWriter {\n+    pub fn new(dst: Box<Writer:Send>) -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst) }\n     }\n }"}, {"sha": "b9c8be290caac7bcd6047f164a30e096be0e9b95", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -20,6 +20,7 @@ use parse;\n use parse::token::InternedString;\n use parse::token;\n \n+\n enum State {\n     Asm,\n     Outputs,\n@@ -45,7 +46,7 @@ impl State {\n static OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-               -> ~base::MacResult {\n+                  -> Box<base::MacResult> {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.iter()"}, {"sha": "01ec4c84b683ec4b723f452827c2ca57d19f8f96", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -50,19 +50,19 @@ pub trait MacroExpander {\n               ecx: &mut ExtCtxt,\n               span: Span,\n               token_tree: &[ast::TokenTree])\n-              -> ~MacResult;\n+              -> Box<MacResult>;\n }\n \n pub type MacroExpanderFn =\n     fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::TokenTree])\n-       -> ~MacResult;\n+       -> Box<MacResult>;\n \n impl MacroExpander for BasicMacroExpander {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n               token_tree: &[ast::TokenTree])\n-              -> ~MacResult {\n+              -> Box<MacResult> {\n         (self.expander)(ecx, span, token_tree)\n     }\n }\n@@ -78,7 +78,7 @@ pub trait IdentMacroExpander {\n               sp: Span,\n               ident: ast::Ident,\n               token_tree: Vec<ast::TokenTree> )\n-              -> ~MacResult;\n+              -> Box<MacResult>;\n }\n \n impl IdentMacroExpander for BasicIdentMacroExpander {\n@@ -87,13 +87,13 @@ impl IdentMacroExpander for BasicIdentMacroExpander {\n               sp: Span,\n               ident: ast::Ident,\n               token_tree: Vec<ast::TokenTree> )\n-              -> ~MacResult {\n+              -> Box<MacResult> {\n         (self.expander)(cx, sp, ident, token_tree)\n     }\n }\n \n pub type IdentMacroExpanderFn =\n-    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree> ) -> ~MacResult;\n+    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree>) -> Box<MacResult>;\n \n pub type MacroCrateRegistrationFun =\n     fn(|ast::Name, SyntaxExtension|);\n@@ -130,8 +130,8 @@ pub struct MacExpr {\n     e: @ast::Expr\n }\n impl MacExpr {\n-    pub fn new(e: @ast::Expr) -> ~MacResult {\n-        box MacExpr { e: e } as ~MacResult\n+    pub fn new(e: @ast::Expr) -> Box<MacResult> {\n+        box MacExpr { e: e } as Box<MacResult>\n     }\n }\n impl MacResult for MacExpr {\n@@ -144,8 +144,8 @@ pub struct MacItem {\n     i: @ast::Item\n }\n impl MacItem {\n-    pub fn new(i: @ast::Item) -> ~MacResult {\n-        box MacItem { i: i } as ~MacResult\n+    pub fn new(i: @ast::Item) -> Box<MacResult> {\n+        box MacItem { i: i } as Box<MacResult>\n     }\n }\n impl MacResult for MacItem {\n@@ -173,17 +173,17 @@ impl DummyResult {\n     ///\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n-    pub fn any(sp: Span) -> ~MacResult {\n-        box DummyResult { expr_only: false, span: sp } as ~MacResult\n+    pub fn any(sp: Span) -> Box<MacResult> {\n+        box DummyResult { expr_only: false, span: sp } as Box<MacResult>\n     }\n \n     /// Create a default MacResult that can only be an expression.\n     ///\n     /// Use this for macros that must expand to an expression, so even\n     /// if an error is encountered internally, the user will recieve\n     /// an error that they also used it in the wrong place.\n-    pub fn expr(sp: Span) -> ~MacResult {\n-        box DummyResult { expr_only: true, span: sp } as ~MacResult\n+    pub fn expr(sp: Span) -> Box<MacResult> {\n+        box DummyResult { expr_only: true, span: sp } as Box<MacResult>\n     }\n \n     /// A plain dummy expression.\n@@ -229,13 +229,13 @@ pub enum SyntaxExtension {\n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n-    NormalTT(~MacroExpander:'static, Option<Span>),\n+    NormalTT(Box<MacroExpander:'static>, Option<Span>),\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n     /// `macro_rules!` is an `IdentTT`.\n-    IdentTT(~IdentMacroExpander:'static, Option<Span>),\n+    IdentTT(Box<IdentMacroExpander:'static>, Option<Span>),\n }\n \n pub struct BlockInfo {"}, {"sha": "06b50e37cbd9e1bbba8f5559fcca3c895008cd95", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -16,7 +16,9 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n+\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     // Gather all argument expressions\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         None => return DummyResult::expr(sp),"}, {"sha": "3e74b2680e060444117922a830cc6d38d03ffc6b", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,7 +26,9 @@ use parse::token::InternedString;\n use parse::token;\n use parse;\n \n-pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n+\n+pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                  -> Box<base::MacResult> {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.iter()"}, {"sha": "7c6c9892002c9327f38b8d15fb7bf583e4b684cb", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -18,7 +18,8 @@ use std::strbuf::StrBuf;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n-                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                         tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n         None => return base::DummyResult::expr(sp)"}, {"sha": "0e168e7b33b707aca6fea668fab6af0d02befa29", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -19,7 +19,7 @@ use parse::token::{str_to_ident};\n use std::strbuf::StrBuf;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                         -> Box<base::MacResult> {\n     let mut res_str = StrBuf::new();\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {"}, {"sha": "a3f9eaee892e73716b270af89ca7fea839f3ea5d", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -571,7 +571,7 @@ impl<'a> MethodDef<'a> {\n                 Self if nonstatic  => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(~Self, _) if nonstatic => {\n+                Ptr(box Self, _) if nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {"}, {"sha": "602245b4c470fc3c2eaf7e9ad5fd9c26c359df4a", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -20,6 +20,7 @@ use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n \n+\n /// The types of pointers\n pub enum PtrTy<'a> {\n     Send, // ~\n@@ -31,7 +32,7 @@ pub enum PtrTy<'a> {\n pub struct Path<'a> {\n     pub path: Vec<&'a str> ,\n     pub lifetime: Option<&'a str>,\n-    pub params: Vec<~Ty<'a>> ,\n+    pub params: Vec<Box<Ty<'a>>>,\n     pub global: bool,\n }\n \n@@ -44,7 +45,7 @@ impl<'a> Path<'a> {\n     }\n     pub fn new_<'r>(path: Vec<&'r str> ,\n                     lifetime: Option<&'r str>,\n-                    params: Vec<~Ty<'r>> ,\n+                    params: Vec<Box<Ty<'r>>>,\n                     global: bool)\n                     -> Path<'r> {\n         Path {\n@@ -80,8 +81,8 @@ impl<'a> Path<'a> {\n /// A type. Supports pointers (except for *), Self, and literals\n pub enum Ty<'a> {\n     Self,\n-    // &/~/@ Ty\n-    Ptr(~Ty<'a>, PtrTy<'a>),\n+    // &/Box/@ Ty\n+    Ptr(Box<Ty<'a>>, PtrTy<'a>),\n     // mod::mod::Type<[lifetime], [Params...]>, including a plain type\n     // parameter, and things like `int`\n     Literal(Path<'a>),\n@@ -92,7 +93,7 @@ pub enum Ty<'a> {\n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n     Borrowed(None, ast::MutImmutable)\n }\n-pub fn borrowed<'r>(ty: ~Ty<'r>) -> Ty<'r> {\n+pub fn borrowed<'r>(ty: Box<Ty<'r>>) -> Ty<'r> {\n     Ptr(ty, borrowed_ptrty())\n }\n "}, {"sha": "ea3fef352be67c4c19bb07c97df621cde6745988", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -24,7 +24,7 @@ use parse::token;\n use std::os;\n \n pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                         -> Box<base::MacResult> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n         None => return DummyResult::expr(sp),\n         Some(v) => v\n@@ -60,7 +60,7 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                  -> Box<base::MacResult> {\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.len() == 0 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");"}, {"sha": "0dc62728e5c95344838382d457281640c9d79b5d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -1100,12 +1100,6 @@ mod test {\n         }\n     }\n \n-    //fn fake_print_crate(krate: &ast::Crate) {\n-    //    let mut out = ~std::io::stderr() as ~std::io::Writer;\n-    //    let mut s = pprust::rust_printer(out, get_ident_interner());\n-    //    pprust::print_crate_(&mut s, krate);\n-    //}\n-\n     fn expand_crate_str(crate_str: ~str) -> ast::Crate {\n         let ps = parse::new_parse_sess();\n         let crate_ast = string_to_parser(&ps, crate_str).parse_crate_mod();"}, {"sha": "0907541eee0e0bad2ab0c48063f6596c8de8b01f", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,8 +15,11 @@ use codemap::Span;\n use ext::base;\n use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt, sp: Span,\n-                         _tts: &[ast::TokenTree]) -> ~base::MacResult {\n+\n+pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt,\n+                         sp: Span,\n+                         _tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n     ecx.parse_sess.span_diagnostic.span_note(sp,\n         \"see http://static.rust-lang.org/doc/master/std/fmt/index.html \\"}, {"sha": "fc3136996ae10afea89720d1447e76754cefd2fe", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -805,7 +805,7 @@ impl<'a, 'b> Context<'a, 'b> {\n }\n \n pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n-                   tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                   tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n \n     match parse_args(ecx, sp, tts) {\n         (extra, Some((efmt, args, order, names))) => {"}, {"sha": "486d060da77bedbefc596b6f70529a6cead6c517", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -18,7 +18,7 @@ use std::rc::Rc;\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n                          tt: &[ast::TokenTree])\n-                      -> ~base::MacResult {\n+                         -> Box<base::MacResult> {\n \n     cx.print_backtrace();\n     println!(\"{}\", print::pprust::tt_to_str(&ast::TTDelim("}, {"sha": "4d8be9bab7685847d36e2092cb3e268d1124f3ab", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,6 +17,7 @@ use parse::token::*;\n use parse::token;\n use parse;\n \n+\n /**\n *\n * Quasiquoting works via token trees.\n@@ -312,22 +313,24 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n                            sp: Span,\n-                           tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                           tts: &[ast::TokenTree])\n+                           -> Box<base::MacResult> {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n     base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_expr(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                         tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr\", Vec::new(), tts);\n     base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                         tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_item\",\n                                     vec!(e_attrs), tts);\n@@ -336,7 +339,8 @@ pub fn expand_quote_item(cx: &mut ExtCtxt,\n \n pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         sp: Span,\n-                        tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                        tts: &[ast::TokenTree])\n+                        -> Box<base::MacResult> {\n     let e_refutable = cx.expr_lit(sp, ast::LitBool(true));\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n                                     vec!(e_refutable), tts);\n@@ -345,7 +349,8 @@ pub fn expand_quote_pat(cx: &mut ExtCtxt,\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n-                       tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                       tts: &[ast::TokenTree])\n+                       -> Box<base::MacResult> {\n     let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n                                      vec!(e_param_colons), tts);\n@@ -354,7 +359,8 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n+                         tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult> {\n     let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n                                     vec!(e_attrs), tts);"}, {"sha": "e221ab80d7bbcab0b16b0b7df5afece1fc25b285", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -29,7 +29,7 @@ use std::str;\n \n /* line!(): expands to the current line number */\n pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                   -> Box<base::MacResult> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n@@ -40,7 +40,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n /* col!(): expands to the current column number */\n pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                  -> Box<base::MacResult> {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n@@ -52,7 +52,7 @@ pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                   -> Box<base::MacResult> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n@@ -62,13 +62,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                        -> Box<base::MacResult> {\n     let s = pprust::tts_to_str(tts);\n     base::MacExpr::new(cx.expr_str(sp, token::intern_and_get_ident(s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                  -> Box<base::MacResult> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n@@ -82,7 +82,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                      -> Box<base::MacResult> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp),\n@@ -100,7 +100,7 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~base::MacResult {\n+                          -> Box<base::MacResult> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n@@ -131,8 +131,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-        -> ~base::MacResult\n-{\n+                          -> Box<base::MacResult> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bin!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)"}, {"sha": "773246326648ae51e4afc41682526543c3a56ee5", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,10 +14,11 @@ use ext::base::ExtCtxt;\n use ext::base;\n use parse::token::{keywords, is_keyword};\n \n+\n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[ast::TokenTree])\n-                        -> ~base::MacResult {\n+                           -> Box<base::MacResult> {\n     match tt {\n         [ast::TTTok(_, ref tok)] if is_keyword(keywords::True, tok) => {\n             cx.set_trace_macros(true);"}, {"sha": "ee3ff0c389e2119388dfc5fe8b1e5215f4359fcf", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -102,7 +102,7 @@ pub struct MatcherPos {\n     elts: Vec<ast::Matcher> , // maybe should be <'>? Need to understand regions.\n     sep: Option<Token>,\n     idx: uint,\n-    up: Option<~MatcherPos>,\n+    up: Option<Box<MatcherPos>>,\n     matches: Vec<Vec<Rc<NamedMatch>>>,\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n@@ -120,7 +120,7 @@ pub fn count_names(ms: &[Matcher]) -> uint {\n }\n \n pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n-                        -> ~MatcherPos {\n+                           -> Box<MatcherPos> {\n     let mut match_idx_hi = 0u;\n     for elt in ms.iter() {\n         match elt.node {"}, {"sha": "5a02acdae1cea84f48ff5aad02a0d881b3ef35dc", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -95,7 +95,7 @@ impl MacroExpander for MacroRulesMacroExpander {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               arg: &[ast::TokenTree])\n-              -> ~MacResult {\n+              -> Box<MacResult> {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n@@ -121,7 +121,7 @@ fn generic_extension(cx: &ExtCtxt,\n                      arg: &[ast::TokenTree],\n                      lhses: &[Rc<NamedMatch>],\n                      rhses: &[Rc<NamedMatch>])\n-                     -> ~MacResult {\n+                     -> Box<MacResult> {\n     if cx.trace_macros() {\n         println!(\"{}! \\\\{ {} \\\\}\",\n                  token::get_ident(name),\n@@ -171,7 +171,7 @@ fn generic_extension(cx: &ExtCtxt,\n                 // Weird, but useful for X-macros.\n                 return box ParserAnyMacro {\n                     parser: RefCell::new(p),\n-                } as ~MacResult\n+                } as Box<MacResult>\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n@@ -193,7 +193,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n                          arg: Vec<ast::TokenTree> )\n-                         -> ~base::MacResult {\n+                         -> Box<base::MacResult> {\n     // these spans won't matter, anyways\n     fn ms(m: Matcher_) -> Matcher {\n         Spanned {\n@@ -250,5 +250,5 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n             name: token::get_ident(name).to_str(),\n             ext: NormalTT(exp, Some(sp))\n         }))\n-    } as ~MacResult\n+    } as Box<MacResult>\n }"}, {"sha": "f6bee0335533befcbf2ddf509d2e45e3edd126bd", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -254,7 +254,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     /* sidestep the interpolation tricks for ident because\n                        (a) idents can be in lots of places, so it'd be a pain\n                        (b) we actually can, since it's a token. */\n-                    MatchedNonterminal(NtIdent(~sn,b)) => {\n+                    MatchedNonterminal(NtIdent(box sn, b)) => {\n                         r.cur_span = sp;\n                         r.cur_tok = IDENT(sn,b);\n                         return ret_val;"}, {"sha": "b9157e0043d1e0a30c51d389f2b04cc97a625cb5", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -40,6 +40,9 @@ pub enum ObsoleteSyntax {\n     ObsoleteManagedPattern,\n     ObsoleteManagedString,\n     ObsoleteManagedVec,\n+    ObsoleteOwnedType,\n+    ObsoleteOwnedExpr,\n+    ObsoleteOwnedPattern,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -126,6 +129,18 @@ impl<'a> ParserObsoleteMethods for Parser<'a> {\n                 \"managed vector\",\n                 \"use `Rc<~[T]>` instead of a managed vector\"\n             ),\n+            ObsoleteOwnedType => (\n+                \"`~` notation for owned pointers\",\n+                \"use `Box<T>` in `std::owned` instead\"\n+            ),\n+            ObsoleteOwnedExpr => (\n+                \"`~` notation for owned pointer allocation\",\n+                \"use the `box` operator instead of `~`\"\n+            ),\n+            ObsoleteOwnedPattern => (\n+                \"`~` notation for owned pointer patterns\",\n+                \"use the `box` operator instead of `~`\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "74c2ab9c494d62a1b6e6f1756e36cbbbb8caf9dd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -273,7 +273,10 @@ struct ParsedItemsAndViewItems {\n \n /* ident is handled by common.rs */\n \n-pub fn Parser<'a>(sess: &'a ParseSess, cfg: ast::CrateConfig, mut rdr: ~Reader:)\n+pub fn Parser<'a>(\n+              sess: &'a ParseSess,\n+              cfg: ast::CrateConfig,\n+              mut rdr: Box<Reader:>)\n               -> Parser<'a> {\n     let tok0 = rdr.next_token();\n     let span = tok0.sp;\n@@ -318,14 +321,14 @@ pub struct Parser<'a> {\n     pub last_span: Span,\n     pub cfg: CrateConfig,\n     // the previous token or None (only stashed sometimes).\n-    pub last_token: Option<~token::Token>,\n+    pub last_token: Option<Box<token::Token>>,\n     pub buffer: [TokenAndSpan, ..4],\n     pub buffer_start: int,\n     pub buffer_end: int,\n     pub tokens_consumed: uint,\n     pub restriction: restriction,\n     pub quote_depth: uint, // not (yet) related to the quasiquoter\n-    pub reader: ~Reader:,\n+    pub reader: Box<Reader:>,\n     pub interner: Rc<token::IdentInterner>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n@@ -1221,6 +1224,14 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n+            match self.token {\n+                token::IDENT(ref ident, _)\n+                        if \"str\" == token::get_ident(*ident).get() => {\n+                    // This is OK (for now).\n+                }\n+                token::LBRACKET => {}   // Also OK.\n+                _ => self.obsolete(self.last_span, ObsoleteOwnedType),\n+            };\n             TyUniq(self.parse_ty(false))\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n@@ -1445,7 +1456,7 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n         match found {\n-            Some(INTERPOLATED(token::NtPath(~path))) => {\n+            Some(INTERPOLATED(token::NtPath(box path))) => {\n                 return PathAndBounds {\n                     path: path,\n                     bounds: None,\n@@ -2258,9 +2269,13 @@ impl<'a> Parser<'a> {\n             ex = match e.node {\n               ExprVec(..) | ExprRepeat(..) => ExprVstore(e, ExprVstoreUniq),\n               ExprLit(lit) if lit_is_str(lit) => {\n+                  self.obsolete(self.last_span, ObsoleteOwnedExpr);\n                   ExprVstore(e, ExprVstoreUniq)\n               }\n-              _ => self.mk_unary(UnUniq, e)\n+              _ => {\n+                  self.obsolete(self.last_span, ObsoleteOwnedExpr);\n+                  self.mk_unary(UnUniq, e)\n+              }\n             };\n           }\n           token::IDENT(_, _) if self.is_keyword(keywords::Box) => {\n@@ -2772,6 +2787,7 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatUniq(sub);\n             hi = self.last_span.hi;\n+            self.obsolete(self.last_span, ObsoleteOwnedPattern);\n             return @ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,"}, {"sha": "e4e71baad44eba7530022f8d85982108142c1732", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -113,9 +113,9 @@ pub enum Nonterminal {\n     NtPat( @ast::Pat),\n     NtExpr(@ast::Expr),\n     NtTy(  P<ast::Ty>),\n-    NtIdent(~ast::Ident, bool),\n+    NtIdent(Box<ast::Ident>, bool),\n     NtMeta(@ast::MetaItem), // stuff inside brackets for attributes\n-    NtPath(~ast::Path),\n+    NtPath(Box<ast::Path>),\n     NtTT(  @ast::TokenTree), // needs @ed to break a circularity\n     NtMatchers(Vec<ast::Matcher> )\n }"}, {"sha": "a32cad701754cbff86d771288e1dfda6e12c1878", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -155,7 +155,7 @@ pub struct PrintStackElem {\n \n static SIZE_INFINITY: int = 0xffff;\n \n-pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n+pub fn mk_printer(out: Box<io::Writer>, linewidth: uint) -> Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n@@ -262,7 +262,7 @@ pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n  * called 'print'.\n  */\n pub struct Printer {\n-    pub out: ~io::Writer,\n+    pub out: Box<io::Writer>,\n     buf_len: uint,\n     margin: int, // width of lines we're constrained to\n     space: int, // number of spaces left on line"}, {"sha": "310ca18e4faf0b5e20e8a83be9a0cff223eff1c8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -65,12 +65,12 @@ pub struct State<'a> {\n     ann: &'a PpAnn\n }\n \n-pub fn rust_printer(writer: ~io::Writer) -> State<'static> {\n+pub fn rust_printer(writer: Box<io::Writer>) -> State<'static> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: ~io::Writer,\n+pub fn rust_printer_annotated<'a>(writer: Box<io::Writer>,\n                                   ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n@@ -99,7 +99,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        krate: &ast::Crate,\n                        filename: ~str,\n                        input: &mut io::Reader,\n-                       out: ~io::Writer,\n+                       out: Box<io::Writer>,\n                        ann: &'a PpAnn,\n                        is_expanded: bool) -> IoResult<()> {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n@@ -140,7 +140,7 @@ pub fn to_str(f: |&mut State| -> IoResult<()>) -> ~str {\n         // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n         // that we \"know\" to be a `MemWriter` that works around the lack of checked\n         // downcasts.\n-        let (_, wr): (uint, ~MemWriter) = cast::transmute_copy(&s.s.out);\n+        let (_, wr): (uint, Box<MemWriter>) = cast::transmute_copy(&s.s.out);\n         let result = str::from_utf8_owned(wr.get_ref().to_owned()).unwrap();\n         cast::forget(wr);\n         result\n@@ -1113,7 +1113,7 @@ impl<'a> State<'a> {\n \n     pub fn print_expr_vstore(&mut self, t: ast::ExprVstore) -> IoResult<()> {\n         match t {\n-            ast::ExprVstoreUniq => word(&mut self.s, \"~\"),\n+            ast::ExprVstoreUniq => word(&mut self.s, \"box \"),\n             ast::ExprVstoreSlice => word(&mut self.s, \"&\"),\n             ast::ExprVstoreMutSlice => {\n                 try!(word(&mut self.s, \"&\"));\n@@ -1686,7 +1686,7 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             ast::PatUniq(inner) => {\n-                try!(word(&mut self.s, \"~\"));\n+                try!(word(&mut self.s, \"box \"));\n                 try!(self.print_pat(inner));\n             }\n             ast::PatRegion(inner) => {"}, {"sha": "416c924310627345eea2bbab8c8cda61ba33d930", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -114,7 +114,7 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n pub struct Terminal<T> {\n     num_colors: u16,\n     out: T,\n-    ti: ~TermInfo\n+    ti: Box<TermInfo>,\n }\n \n impl<T: Writer> Terminal<T> {"}, {"sha": "2b50a20ac6ae1517643314d157bfa14f9babc07c", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -159,8 +159,8 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: &mut io::Reader,\n-             longnames: bool) -> Result<~TermInfo, ~str> {\n+pub fn parse(file: &mut io::Reader, longnames: bool)\n+             -> Result<Box<TermInfo>, ~str> {\n     macro_rules! try( ($e:expr) => (\n         match $e { Ok(e) => e, Err(e) => return Err(format!(\"{}\", e)) }\n     ) )\n@@ -301,7 +301,7 @@ pub fn parse(file: &mut io::Reader,\n }\n \n /// Create a dummy TermInfo struct for msys terminals\n-pub fn msys_terminfo() -> ~TermInfo {\n+pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n     strings.insert(\"sgr0\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n     strings.insert(\"bold\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[1m\")));"}, {"sha": "a4be7ed51fbaf9e03c03a3490a452dd7a8f9b61d", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,7 +17,7 @@ use std::os::getenv;\n use std::{os, str};\n \n /// Return path to database entry for `term`\n-pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n+pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     if term.len() == 0 {\n         return None;\n     }"}, {"sha": "4040e079224fda04d92903f6db277a2b8efb5d09", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -132,7 +132,7 @@ pub enum TestFn {\n     StaticMetricFn(proc(&mut MetricMap)),\n     DynTestFn(proc():Send),\n     DynMetricFn(proc(&mut MetricMap)),\n-    DynBenchFn(~TDynBenchFn)\n+    DynBenchFn(Box<TDynBenchFn>)\n }\n \n impl TestFn {\n@@ -1001,8 +1001,8 @@ pub fn run_test(opts: &TestOpts,\n             if nocapture {\n                 drop((stdout, stderr));\n             } else {\n-                task.opts.stdout = Some(box stdout as ~Writer:Send);\n-                task.opts.stderr = Some(box stderr as ~Writer:Send);\n+                task.opts.stdout = Some(box stdout as Box<Writer:Send>);\n+                task.opts.stderr = Some(box stderr as Box<Writer:Send>);\n             }\n             let result_future = task.future_result();\n             task.spawn(testfn);"}, {"sha": "a6afd73c0935fb3f2e5f52191dd8141fd4296129", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -783,7 +783,7 @@ mod test {\n     #[test]\n     fn test_rand_rand() {\n         let mut rng = rand::task_rng();\n-        let u: ~Uuid = rand::Rand::rand(&mut rng);\n+        let u: Box<Uuid> = rand::Rand::rand(&mut rng);\n         let ub = u.as_bytes();\n \n         assert!(ub.len() == 16);"}, {"sha": "c617c1b2d03b4364b8040f7659587749944d9b95", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,10 +11,11 @@\n #![crate_id=\"a\"]\n #![crate_type = \"lib\"]\n \n+\n pub trait i<T> { }\n \n-pub fn f<T>() -> ~i<T> {\n+pub fn f<T>() -> Box<i<T>> {\n     impl<T> i<T> for () { }\n \n-    ~() as ~i<T>\n+    box() () as Box<i<T>>\n }"}, {"sha": "2b4df978cc8c5e90717c762622bf96cbafdb3615", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -59,7 +59,7 @@ pub mod testtypes {\n     // Skipping ty_box\n \n     // Tests ty_uniq (of u8)\n-    pub type FooUniq = ~u8;\n+    pub type FooUniq = Box<u8>;\n \n     // As with ty_str, what type should be used for ty_vec?\n "}, {"sha": "a2c7e3533d8a7794340a603487ce19439721272e", "filename": "src/test/auxiliary/macro_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -29,7 +29,7 @@ impl Drop for Foo {\n \n #[macro_registrar]\n pub fn registrar(_: |Name, SyntaxExtension|) {\n-    local_data_key!(foo: ~Any:Send);\n-    local_data::set(foo, ~Foo { foo: 10 } as ~Any:Send);\n+    local_data_key!(foo: Box<Any:Send>);\n+    local_data::set(foo, box Foo { foo: 10 } as Box<Any:Send>);\n }\n "}, {"sha": "95f2a8c1ca1522ea9a77c42a95ab9a0839a7740d", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -27,15 +27,16 @@ macro_rules! unexported_macro (() => (3))\n #[macro_registrar]\n pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n     register(token::intern(\"make_a_1\"),\n-        NormalTT(~BasicMacroExpander {\n+        NormalTT(box BasicMacroExpander {\n             expander: expand_make_a_1,\n             span: None,\n         },\n         None));\n     register(token::intern(\"into_foo\"), ItemModifier(expand_into_foo));\n }\n \n-fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> ~MacResult {\n+fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n+                   -> Box<MacResult> {\n     if !tts.is_empty() {\n         cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n     }"}, {"sha": "93b56a7600d09936f6859d4a124a24ae88477825", "filename": "src/test/auxiliary/syntax-extension-with-dll-deps-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -25,14 +25,15 @@ use syntax::parse::token;\n #[macro_registrar]\n pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n     register(token::intern(\"foo\"),\n-        NormalTT(~BasicMacroExpander {\n+        NormalTT(box BasicMacroExpander {\n             expander: expand_foo,\n             span: None,\n         },\n         None));\n }\n \n-fn expand_foo(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> ~MacResult {\n+fn expand_foo(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n+              -> Box<MacResult> {\n     let answer = other::the_answer();\n     MacExpr::new(quote_expr!(cx, $answer))\n }"}, {"sha": "659270b555427773ea941a367800e1ca2a0a04a8", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -147,9 +147,9 @@ fn main() {\n \n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         let foo = include_bin!(\"shootout-k-nucleotide.data\");\n-        ~MemReader::new(Vec::from_slice(foo)) as ~Reader\n+        box MemReader::new(Vec::from_slice(foo)) as Box<Reader>\n     } else {\n-        ~stdio::stdin() as ~Reader\n+        box stdio::stdin() as Box<Reader>\n     };\n     let mut rdr = BufferedReader::new(rdr);\n "}, {"sha": "dfa287459f33cc85acdcb1d146ba9bd5cb286f4b", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -91,16 +91,16 @@ impl TableCallback for PrintCallback {\n struct Entry {\n     code: Code,\n     count: uint,\n-    next: Option<~Entry>,\n+    next: Option<Box<Entry>>,\n }\n \n struct Table {\n     count: uint,\n-    items: Vec<Option<~Entry>> }\n+    items: Vec<Option<Box<Entry>>> }\n \n struct Items<'a> {\n     cur: Option<&'a Entry>,\n-    items: slice::Items<'a, Option<~Entry>>,\n+    items: slice::Items<'a, Option<Box<Entry>>>,\n }\n \n impl Table {\n@@ -114,7 +114,7 @@ impl Table {\n     fn search_remainder<C:TableCallback>(item: &mut Entry, key: Code, c: C) {\n         match item.next {\n             None => {\n-                let mut entry = ~Entry {\n+                let mut entry = box Entry {\n                     code: key,\n                     count: 0,\n                     next: None,\n@@ -138,7 +138,7 @@ impl Table {\n \n         {\n             if self.items.get(index as uint).is_none() {\n-                let mut entry = ~Entry {\n+                let mut entry = box Entry {\n                     code: key,\n                     count: 0,\n                     next: None,"}, {"sha": "f5409688bc6c4e1b60afebd3363b693997863cc8", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -34,9 +34,9 @@ fn count_matches(seq: &str, variant: &Regex) -> int {\n fn main() {\n     let mut rdr = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         let fd = io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n-        ~io::BufferedReader::new(fd) as ~io::Reader\n+        box io::BufferedReader::new(fd) as Box<io::Reader>\n     } else {\n-        ~io::stdin() as ~io::Reader\n+        box io::stdin() as Box<io::Reader>\n     };\n     let mut seq = StrBuf::from_str(rdr.read_to_str().unwrap());\n     let ilen = seq.len();"}, {"sha": "bd47734c3da8971a87b37c533b899252d0664dff", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,8 +15,8 @@\n use std::io;\n use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n-use std::os;\n use std::num::Bitwise;\n+use std::os;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -132,7 +132,7 @@ impl Sudoku {\n     fn next_color(&mut self, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n-            let mut avail = ~Colors::new(start_color);\n+            let mut avail = box Colors::new(start_color);\n \n             // drop colors already in use in neighbourhood\n             self.drop_colors(avail, row, col);"}, {"sha": "fc47269ef876ef9be2073680d72c61434d0e6f0b", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -24,7 +24,7 @@ enum List<T> {\n }\n \n enum UniqueList {\n-    ULNil, ULCons(~UniqueList)\n+    ULNil, ULCons(Box<UniqueList>)\n }\n \n fn main() {\n@@ -53,8 +53,8 @@ type nillist = List<()>;\n \n struct State {\n     managed: @nillist,\n-    unique: ~nillist,\n-    tuple: (@nillist, ~nillist),\n+    unique: Box<nillist>,\n+    tuple: (@nillist, Box<nillist>),\n     vec: Vec<@nillist>,\n     res: r\n }\n@@ -85,18 +85,18 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n           None => {\n             State {\n                 managed: @Nil,\n-                unique: ~Nil,\n-                tuple: (@Nil, ~Nil),\n+                unique: box Nil,\n+                tuple: (@Nil, box Nil),\n                 vec: vec!(@Nil),\n                 res: r(@Nil)\n             }\n           }\n           Some(st) => {\n             State {\n                 managed: @Cons((), st.managed),\n-                unique: ~Cons((), @*st.unique),\n+                unique: box Cons((), @*st.unique),\n                 tuple: (@Cons((), st.tuple.ref0().clone()),\n-                        ~Cons((), @*st.tuple.ref1().clone())),\n+                        box Cons((), @*st.tuple.ref1().clone())),\n                 vec: st.vec.clone().append(&[@Cons((), *st.vec.last().unwrap())]),\n                 res: r(@Cons((), st.res._l))\n             }"}, {"sha": "fd96b750fc16c3c9af9c4d37b11693210a0901c5", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-free.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,8 +11,9 @@\n // Test that we detect nested calls that could free pointers evaluated\n // for earlier arguments.\n \n-fn rewrite(v: &mut ~uint) -> uint {\n-    *v = ~22;\n+\n+fn rewrite(v: &mut Box<uint>) -> uint {\n+    *v = box 22;\n     **v\n }\n \n@@ -21,7 +22,7 @@ fn add(v: &uint, w: uint) -> uint {\n }\n \n fn implicit() {\n-    let mut a = ~1;\n+    let mut a = box 1;\n \n     // Note the danger here:\n     //\n@@ -34,7 +35,7 @@ fn implicit() {\n }\n \n fn explicit() {\n-    let mut a = ~1;\n+    let mut a = box 1;\n     add(\n         &*a,\n         rewrite(&mut a)); //~ ERROR cannot borrow"}, {"sha": "d1ab70e4aedcc0305839c2fcfa6708f6d707f21b", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-move.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,17 +11,18 @@\n // Test that we detect nested calls that could free pointers evaluated\n // for earlier arguments.\n \n-fn rewrite(v: &mut ~uint) -> uint {\n-    *v = ~22;\n+\n+fn rewrite(v: &mut Box<uint>) -> uint {\n+    *v = box 22;\n     **v\n }\n \n-fn add(v: &uint, w: ~uint) -> uint {\n+fn add(v: &uint, w: Box<uint>) -> uint {\n     *v + *w\n }\n \n fn implicit() {\n-    let mut a = ~1;\n+    let mut a = box 1;\n \n     // Note the danger here:\n     //\n@@ -34,7 +35,7 @@ fn implicit() {\n }\n \n fn explicit() {\n-    let mut a = ~1;\n+    let mut a = box 1;\n     add(\n         &*a,\n         a); //~ ERROR cannot move"}, {"sha": "c7695e0ff5fd80015bbb8c147bdff92aa2c027e2", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct Foo {\n   bar1: Bar,\n   bar2: Bar\n@@ -18,7 +19,7 @@ struct Bar {\n   int2: int,\n }\n \n-fn make_foo() -> ~Foo { fail!() }\n+fn make_foo() -> Box<Foo> { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();"}, {"sha": "1e04a3568c350fbe38cdef388e64b7942f3e7741", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -78,7 +78,7 @@ fn deref_extend_mut_field2<'a>(x: &'a mut Own<Point>) -> &'a mut int {\n }\n \n fn deref_extend_mut_field3<'a>(x: &'a mut Own<Point>) {\n-    // Hmm, this is unfortunate, because with ~ it would work,\n+    // Hmm, this is unfortunate, because with box it would work,\n     // but it's presently the expected outcome. See `deref_extend_mut_field4`\n     // for the workaround.\n "}, {"sha": "120223bbf60a9823e96611df269f8ba051eb110d", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,9 +15,9 @@ use collections::HashMap;\n \n fn main() {\n     let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n-    buggy_map.insert(42, &*~1); //~ ERROR borrowed value does not live long enough\n+    buggy_map.insert(42, &*box 1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary\n-    let tmp = ~2;\n+    let tmp = box 2;\n     buggy_map.insert(43, &*tmp);\n }"}, {"sha": "ce8b17ea40bc613a6d8fde024bade106c4189b90", "filename": "src/test/compile-fail/borrowck-closures-mut-and-imm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,6 +11,7 @@\n // Tests that two closures cannot simultaneously have mutable\n // and immutable access to the variable. Issue #6801.\n \n+\n fn get(x: &int) -> int {\n     *x\n }\n@@ -50,27 +51,27 @@ fn e() {\n }\n \n fn f() {\n-    let mut x = ~3;\n+    let mut x = box 3;\n     let c1 = || get(&*x);\n     *x = 5; //~ ERROR cannot assign\n }\n \n fn g() {\n     struct Foo {\n-        f: ~int\n+        f: Box<int>\n     }\n \n-    let mut x = ~Foo { f: ~3 };\n+    let mut x = box Foo { f: box 3 };\n     let c1 = || get(&*x.f);\n     *x.f = 5; //~ ERROR cannot assign to `*x.f`\n }\n \n fn h() {\n     struct Foo {\n-        f: ~int\n+        f: Box<int>\n     }\n \n-    let mut x = ~Foo { f: ~3 };\n+    let mut x = box Foo { f: box 3 };\n     let c1 = || get(&*x.f);\n     let c2 = || *x.f = 5; //~ ERROR cannot borrow `x` as mutable\n }"}, {"sha": "e1967d4e6df94c5d91d957704a431b8894660154", "filename": "src/test/compile-fail/borrowck-closures-two-mut.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -12,6 +12,7 @@\n // access to the variable, whether that mutable access be used\n // for direct assignment or for taking mutable ref. Issue #6801.\n \n+\n fn a() {\n     let mut x = 3;\n     let c1 = || x = 4;\n@@ -43,10 +44,10 @@ fn d() {\n \n fn g() {\n     struct Foo {\n-        f: ~int\n+        f: Box<int>\n     }\n \n-    let mut x = ~Foo { f: ~3 };\n+    let mut x = box Foo { f: box 3 };\n     let c1 = || set(&mut *x.f);\n     let c2 = || set(&mut *x.f);\n     //~^ ERROR cannot borrow `x` as mutable more than once"}, {"sha": "ec31160f0d535f8e9a7e8b69d4118a907e84e3a7", "filename": "src/test/compile-fail/borrowck-closures-use-after-free.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -12,6 +12,7 @@\n // cannot also be supplied a borrowed version of that\n // variable's contents. Issue #11192.\n \n+\n struct Foo {\n   x: int\n }\n@@ -23,9 +24,9 @@ impl Drop for Foo {\n }\n \n fn main() {\n-  let mut ptr = ~Foo { x: 0 };\n+  let mut ptr = box Foo { x: 0 };\n   let test = |foo: &Foo| {\n-    ptr = ~Foo { x: ptr.x + 1 };\n+    ptr = box Foo { x: ptr.x + 1 };\n   };\n   test(ptr); //~ ERROR cannot borrow `*ptr`\n }"}, {"sha": "9313473d6c916d334cdf13601da07b7c0acaa191", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-let x = Some(~1);\n+let x = Some(box 1);\n match x {\n   Some(ref _y) => {\n     let _a = x; //~ ERROR cannot move"}, {"sha": "39c3ae8fdfde0e3e4d9c1d797d3fe1850dc18979", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-let x = Some(~1);\n+let x = Some(box 1);\n match x {\n   Some(ref y) => {\n     let _b = *y; //~ ERROR cannot move out"}, {"sha": "b1ba057dc147a327aeeddda3b8240249225e57f9", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,21 +14,22 @@\n // either genuine or would require more advanced changes.  The latter\n // cases are noted.\n \n+\n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n fn cond() -> bool { fail!() }\n fn for_func(_f: || -> bool) { fail!() }\n fn produce<T>() -> T { fail!(); }\n \n-fn inc(v: &mut ~int) {\n-    *v = ~(**v + 1);\n+fn inc(v: &mut Box<int>) {\n+    *v = box() (**v + 1);\n }\n \n fn pre_freeze_cond() {\n     // In this instance, the freeze is conditional and starts before\n     // the mut borrow.\n \n-    let mut v = ~3;\n+    let mut v = box 3;\n     let _w;\n     if cond() {\n         _w = &v;\n@@ -40,7 +41,7 @@ fn pre_freeze_else() {\n     // In this instance, the freeze and mut borrow are on separate sides\n     // of the if.\n \n-    let mut v = ~3;\n+    let mut v = box 3;\n     let _w;\n     if cond() {\n         _w = &v;"}, {"sha": "831c4d3e824f5b2cdd920c23d8ce20a2067068af", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,19 +14,20 @@\n // either genuine or would require more advanced changes.  The latter\n // cases are noted.\n \n+\n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n fn cond() -> bool { fail!() }\n fn produce<T>() -> T { fail!(); }\n \n-fn inc(v: &mut ~int) {\n-    *v = ~(**v + 1);\n+fn inc(v: &mut Box<int>) {\n+    *v = box() (**v + 1);\n }\n \n fn loop_overarching_alias_mut() {\n     // In this instance, the borrow encompasses the entire loop.\n \n-    let mut v = ~3;\n+    let mut v = box 3;\n     let mut x = &mut v;\n     **x += 1;\n     loop {\n@@ -37,19 +38,19 @@ fn loop_overarching_alias_mut() {\n fn block_overarching_alias_mut() {\n     // In this instance, the borrow encompasses the entire closure call.\n \n-    let mut v = ~3;\n+    let mut v = box 3;\n     let mut x = &mut v;\n     for _ in range(0, 3) {\n         borrow(v); //~ ERROR cannot borrow\n     }\n-    *x = ~5;\n+    *x = box 5;\n }\n \n fn loop_aliased_mut() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let mut _x = &w;\n     loop {\n         borrow_mut(v); //~ ERROR cannot borrow\n@@ -60,8 +61,8 @@ fn loop_aliased_mut() {\n fn while_aliased_mut() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let mut _x = &w;\n     while cond() {\n         borrow_mut(v); //~ ERROR cannot borrow\n@@ -73,8 +74,8 @@ fn while_aliased_mut() {\n fn loop_aliased_mut_break() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let mut _x = &w;\n     loop {\n         borrow_mut(v);\n@@ -87,8 +88,8 @@ fn loop_aliased_mut_break() {\n fn while_aliased_mut_break() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let mut _x = &w;\n     while cond() {\n         borrow_mut(v);\n@@ -99,8 +100,8 @@ fn while_aliased_mut_break() {\n }\n \n fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let mut x = &mut w;\n     while cond {\n         **x += 1;"}, {"sha": "ea0f5d34b72e52578135807161b32aa296d44976", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -37,24 +37,24 @@ fn guard() {\n     // Here the guard performs a borrow. This borrow \"infects\" all\n     // subsequent arms (but not the prior ones).\n \n-    let mut a = ~3;\n-    let mut b = ~4;\n+    let mut a = box 3;\n+    let mut b = box 4;\n     let mut w = &*a;\n     match 22 {\n         _ if cond() => {\n-            b = ~5;\n+            b = box 5;\n         }\n \n         _ if link(&*b, &mut w) => {\n-            b = ~6; //~ ERROR cannot assign\n+            b = box 6; //~ ERROR cannot assign\n         }\n \n         _ => {\n-            b = ~7; //~ ERROR cannot assign\n+            b = box 7; //~ ERROR cannot assign\n         }\n     }\n \n-    b = ~8; //~ ERROR cannot assign\n+    b = box 8; //~ ERROR cannot assign\n }\n \n fn main() {}"}, {"sha": "54f326b479af8b118d515bbaa08f568e93c18658", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,28 +14,29 @@\n // either genuine or would require more advanced changes.  The latter\n // cases are noted.\n \n+\n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n fn cond() -> bool { fail!() }\n fn for_func(_f: || -> bool) { fail!() }\n fn produce<T>() -> T { fail!(); }\n \n-fn inc(v: &mut ~int) {\n-    *v = ~(**v + 1);\n+fn inc(v: &mut Box<int>) {\n+    *v = box() (**v + 1);\n }\n \n fn pre_freeze() {\n     // In this instance, the freeze starts before the mut borrow.\n \n-    let mut v = ~3;\n+    let mut v = box 3;\n     let _w = &v;\n     borrow_mut(v); //~ ERROR cannot borrow\n }\n \n fn post_freeze() {\n     // In this instance, the const alias starts after the borrow.\n \n-    let mut v = ~3;\n+    let mut v = box 3;\n     borrow_mut(v);\n     let _w = &v;\n }"}, {"sha": "d262bcee98317f83bc13aa6d027c1267f5086b94", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,7 +15,7 @@ fn borrow(v: &int, f: |x: &int|) {\n }\n \n fn box_imm() {\n-    let v = ~3;\n+    let v = box 3;\n     let _w = &v;\n     task::spawn(proc() {\n         println!(\"v={}\", *v);\n@@ -24,7 +24,7 @@ fn box_imm() {\n }\n \n fn box_imm_explicit() {\n-    let v = ~3;\n+    let v = box 3;\n     let _w = &v;\n     task::spawn(proc() {\n         println!(\"v={}\", *v);"}, {"sha": "3c284ede0c89c9cd4f0a69edaf2f6a0f0a57996a", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn take(_v: ~int) {\n+\n+fn take(_v: Box<int>) {\n }\n \n fn box_imm() {\n-    let v = ~3;\n+    let v = box 3;\n     let _w = &v;\n     take(v); //~ ERROR cannot move out of `v` because it is borrowed\n }"}, {"sha": "c11a08b254f1cacce9ddb20090c180bdb623dac1", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -13,10 +13,10 @@ fn borrow(v: &int, f: |x: &int|) {\n }\n \n fn box_imm() {\n-    let mut v = ~3;\n+    let mut v = box 3;\n     borrow(v,\n            |w| { //~ ERROR cannot borrow `v` as mutable\n-            v = ~4;\n+            v = box 4;\n             assert_eq!(*v, 3);\n             assert_eq!(*w, 4);\n         })"}, {"sha": "4a6c20079c17e8693774cf4efe8cade6456ff9a4", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,18 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct foo(~uint);\n+\n+struct foo(Box<uint>);\n \n impl Add<foo, foo> for foo {\n     fn add(&self, f: &foo) -> foo {\n-        let foo(~i) = *self;\n-        let foo(~j) = *f;\n-        foo(~(i + j))\n+        let foo(box i) = *self;\n+        let foo(box j) = *f;\n+        foo(box() (i + j))\n     }\n }\n \n fn main() {\n-    let x = foo(~3);\n+    let x = foo(box 3);\n     let _y = x + {x}; // the `{x}` forces a move to occur\n     //~^ ERROR cannot move out of `x`\n }"}, {"sha": "c52924ebdb789b3408556bb9ecdf424b7ad49b26", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let bar = ~3;\n+    let bar = box 3;\n     let _g = || {\n         let _h: proc() -> int = proc() *bar; //~ ERROR cannot move out of captured outer variable\n     };"}, {"sha": "72101d86960c29168c37bd1217d17003dc2b3500", "filename": "src/test/compile-fail/borrowck-move-error-with-note.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n enum Foo {\n-    Foo1(~u32, ~u32),\n-    Foo2(~u32),\n+    Foo1(Box<u32>, Box<u32>),\n+    Foo2(Box<u32>),\n     Foo3,\n }\n \n fn blah() {\n-    let f = &Foo1(~1u32, ~2u32);\n+    let f = &Foo1(box 1u32, box 2u32);\n     match *f {             //~ ERROR cannot move out of\n         Foo1(num1,         //~ NOTE attempting to move value to here\n              num2) => (),  //~ NOTE and here\n@@ -24,7 +25,10 @@ fn blah() {\n     }\n }\n \n-struct S {f:~str, g:~str}\n+struct S {\n+    f: ~str,\n+    g: ~str\n+}\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }\n }\n@@ -40,13 +44,13 @@ fn move_in_match() {\n \n // from issue-8064\n struct A {\n-    a: ~int\n+    a: Box<int>,\n }\n \n fn free<T>(_: T) {}\n \n fn blah2() {\n-    let a = &A { a: ~1 };\n+    let a = &A { a: box 1 };\n     match a.a {           //~ ERROR cannot move out of\n         n => {            //~ NOTE attempting to move value to here\n             free(n)"}, {"sha": "35106487f3475153ea03911e96d2b34027cb7fe4", "filename": "src/test/compile-fail/borrowck-move-from-subpath-of-borrowed-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-subpath-of-borrowed-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-subpath-of-borrowed-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-subpath-of-borrowed-path.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -12,7 +12,7 @@\n // borrowed path.\n \n fn main() {\n-    let a = ~~2;\n+    let a = box box 2;\n     let b = &a;\n \n     let z = *a; //~ ERROR: cannot move out of `*a` because it is borrowed"}, {"sha": "c507b636f15cf652eb1fba386a6cb23a976b61d2", "filename": "src/test/compile-fail/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x: *~int) -> ~int {\n+\n+fn foo(x: *Box<int>) -> Box<int> {\n     let y = *x; //~ ERROR dereference of unsafe pointer requires unsafe function or block\n     return y;\n }"}, {"sha": "b385305d74aaabf6eb03e544072fe59625a2b9c7", "filename": "src/test/compile-fail/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -13,7 +13,7 @@ fn call_f(f: proc() -> int) -> int {\n }\n \n fn main() {\n-    let t = ~3;\n+    let t = box 3;\n \n     call_f(proc() { *t + 1 });\n     call_f(proc() { *t + 1 }); //~ ERROR capture of moved value"}, {"sha": "a29a171e935ddb333f3a007b480af4759bfea89f", "filename": "src/test/compile-fail/borrowck-move-subcomponent.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-subcomponent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-subcomponent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-subcomponent.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,19 +11,15 @@\n // Tests that the borrow checker checks all components of a path when moving\n // out.\n \n-#![no_std]\n-\n-#[lang=\"sized\"]\n-pub trait Sized {}\n \n struct S {\n-  x : ~int\n+  x : Box<int>\n }\n \n fn f<T>(_: T) {}\n \n fn main() {\n-  let a : S = S { x : ~1 };\n+  let a : S = S { x : box 1 };\n   let pb = &a;\n   let S { x: ax } = a;  //~ ERROR cannot move out\n   f(pb);"}, {"sha": "ad90839b4bc43d7f96579d50a4543c01596bea9d", "filename": "src/test/compile-fail/borrowck-no-cycle-in-exchange-heap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct node_ {\n-    a: ~cycle\n+    a: Box<cycle>\n }\n \n enum cycle {\n     node(node_),\n     empty\n }\n fn main() {\n-    let mut x = ~node(node_ {a: ~empty});\n+    let mut x = box node(node_ {a: box empty});\n     // Create a cycle!\n     match *x {\n       node(ref mut y) => {"}, {"sha": "9466a78588c4555255f7f98d9e23e640108fae43", "filename": "src/test/compile-fail/borrowck-object-lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Foo {\n     fn borrowed<'a>(&'a self) -> &'a ();\n }\n@@ -16,16 +17,16 @@ fn borrowed_receiver<'a>(x: &'a Foo) -> &'a () {\n     x.borrowed()\n }\n \n-fn owned_receiver(x: ~Foo) -> &() {\n+fn owned_receiver(x: Box<Foo>) -> &() {\n     x.borrowed() //~ ERROR `*x` does not live long enough\n }\n \n-fn mut_owned_receiver(mut x: ~Foo) {\n+fn mut_owned_receiver(mut x: Box<Foo>) {\n     let _y = x.borrowed();\n     let _z = &mut x; //~ ERROR cannot borrow\n }\n \n-fn imm_owned_receiver(mut x: ~Foo) {\n+fn imm_owned_receiver(mut x: Box<Foo>) {\n     let _y = x.borrowed();\n     let _z = &x;\n }"}, {"sha": "9b5087bd7e0b741627c1ff8b66ee8fc462d84750", "filename": "src/test/compile-fail/borrowck-object-mutability.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Foo {\n     fn borrowed(&self);\n     fn borrowed_mut(&mut self);\n@@ -23,12 +24,12 @@ fn borrowed_mut_receiver(x: &mut Foo) {\n     x.borrowed_mut();\n }\n \n-fn owned_receiver(x: ~Foo) {\n+fn owned_receiver(x: Box<Foo>) {\n     x.borrowed();\n     x.borrowed_mut(); //~ ERROR cannot borrow\n }\n \n-fn mut_owned_receiver(mut x: ~Foo) {\n+fn mut_owned_receiver(mut x: Box<Foo>) {\n     x.borrowed();\n     x.borrowed_mut();\n }"}, {"sha": "168a331e9fe29bbc63bc361371d9ba08c27f8b6c", "filename": "src/test/compile-fail/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,23 +14,24 @@\n \n #![feature(managed_boxes)]\n \n+\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n     let after = *x;\n     assert_eq!(before, after);\n }\n \n-struct F { f: ~int }\n+struct F { f: Box<int> }\n \n pub fn main() {\n-    let mut x = @F {f: ~3};\n+    let mut x = @F {f: box 3};\n     borrow(x.f, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n         //~^ NOTE borrow occurs due to use of `x` in closure\n-        x = @F {f: ~4};\n+        x = @F {f: box 4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);"}, {"sha": "d79b7e040c769f88d0e73fce2fe4c81992ffa9ac", "filename": "src/test/compile-fail/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,23 +14,24 @@\n \n #![feature(managed_boxes)]\n \n+\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n     let after = *x;\n     assert_eq!(before, after);\n }\n \n-struct F { f: ~int }\n+struct F { f: Box<int> }\n \n pub fn main() {\n-    let mut x = ~@F{f: ~3};\n+    let mut x = box @F{f: box 3};\n     borrow(x.f, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n         //~^ NOTE  borrow occurs due to use of `x` in closure\n-        *x = @F{f: ~4};\n+        *x = @F{f: box 4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);"}, {"sha": "9b7966b0af05b9f58d298f998478537f5fd6db03", "filename": "src/test/compile-fail/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,23 +14,24 @@\n \n #![feature(managed_boxes)]\n \n+\n fn borrow(x: &int, f: |x: &int|) {\n     let before = *x;\n     f(x);\n     let after = *x;\n     assert_eq!(before, after);\n }\n \n-struct F { f: ~int }\n+struct F { f: Box<int> }\n \n pub fn main() {\n-    let mut x = @F {f: ~3};\n+    let mut x = @F {f: box 3};\n     borrow((*x).f, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n         //~^ NOTE borrow occurs due to use of `x` in closure\n-        x = @F {f: ~4};\n+        x = @F {f: box 4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);"}, {"sha": "b5d274a5584ab13ba42228e3608f88661827b25c", "filename": "src/test/compile-fail/borrowck-struct-update-with-dtor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-struct-update-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-struct-update-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-struct-update-with-dtor.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -13,10 +13,12 @@\n \n // NoCopy\n use NP = std::kinds::marker::NoCopy;\n+\n+\n struct S { a: int, np: NP }\n impl Drop for S { fn drop(&mut self) { } }\n \n-struct T { a: int, mv: ~int }\n+struct T { a: int, mv: Box<int> }\n impl Drop for T { fn drop(&mut self) { } }\n \n fn f(s0:S) {"}, {"sha": "72941f7721044bcc169af1bf7200d4c09d42d49e", "filename": "src/test/compile-fail/borrowck-unary-move.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x: ~int) -> int {\n+\n+fn foo(x: Box<int>) -> int {\n     let y = &*x;\n     free(x); //~ ERROR cannot move out of `x` because it is borrowed\n     *y\n }\n \n-fn free(_x: ~int) {\n+fn free(_x: Box<int>) {\n }\n \n fn main() {"}, {"sha": "fb03ad61f3d1ef8404029c3ac8413cd8cdc05d97", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,49 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n fn borrow(_v: &int) {}\n \n fn local() {\n-    let mut v = ~3;\n+    let mut v = box 3;\n     borrow(v);\n }\n \n fn local_rec() {\n-    struct F { f: ~int }\n-    let mut v = F {f: ~3};\n+    struct F { f: Box<int> }\n+    let mut v = F {f: box 3};\n     borrow(v.f);\n }\n \n fn local_recs() {\n     struct F { f: G }\n     struct G { g: H }\n-    struct H { h: ~int }\n-    let mut v = F {f: G {g: H {h: ~3}}};\n+    struct H { h: Box<int> }\n+    let mut v = F {f: G {g: H {h: box 3}}};\n     borrow(v.f.g.h);\n }\n \n fn aliased_imm() {\n-    let mut v = ~3;\n+    let mut v = box 3;\n     let _w = &v;\n     borrow(v);\n }\n \n fn aliased_mut() {\n-    let mut v = ~3;\n+    let mut v = box 3;\n     let _w = &mut v;\n     borrow(v); //~ ERROR cannot borrow `*v`\n }\n \n fn aliased_other() {\n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let _x = &mut w;\n     borrow(v);\n }\n \n fn aliased_other_reassign() {\n-    let mut v = ~3;\n-    let mut w = ~4;\n+    let mut v = box 3;\n+    let mut w = box 4;\n     let mut _x = &mut w;\n     _x = &mut v;\n     borrow(v); //~ ERROR cannot borrow `*v`"}, {"sha": "f41f74b166fd2346dc22f84845482946dd565add", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,28 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n fn a() {\n-    let mut vec = [~1, ~2, ~3];\n+    let mut vec = [box 1, box 2, box 3];\n     match vec {\n-        [~ref _a, _, _] => {\n-            vec[0] = ~4; //~ ERROR cannot assign\n+        [box ref _a, _, _] => {\n+            vec[0] = box 4; //~ ERROR cannot assign\n         }\n     }\n }\n \n fn b() {\n-    let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec.as_mut_slice();\n+    let mut vec = vec!(box 1, box 2, box 3);\n+    let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n         [.._b] => {\n-            vec[0] = ~4; //~ ERROR cannot assign\n+            vec[0] = box 4; //~ ERROR cannot assign\n         }\n     }\n }\n \n fn c() {\n-    let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec.as_mut_slice();\n+    let mut vec = vec!(box 1, box 2, box 3);\n+    let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n         [_a,         //~ ERROR cannot move out\n          .._b] => {  //~^ NOTE attempting to move value to here\n@@ -46,8 +47,8 @@ fn c() {\n }\n \n fn d() {\n-    let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec.as_mut_slice();\n+    let mut vec = vec!(box 1, box 2, box 3);\n+    let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n         [.._a,     //~ ERROR cannot move out\n          _b] => {} //~ NOTE attempting to move value to here\n@@ -57,8 +58,8 @@ fn d() {\n }\n \n fn e() {\n-    let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec.as_mut_slice();\n+    let mut vec = vec!(box 1, box 2, box 3);\n+    let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n         [_a, _b, _c] => {}  //~ ERROR cannot move out\n         //~^ NOTE attempting to move value to here"}, {"sha": "6c1e759cc2fa7cc042196069d254d9b1d5a1af94", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -94,7 +94,7 @@ static STATIC10: UnsafeStruct = UnsafeStruct;\n \n struct MyOwned;\n \n-static STATIC11: ~MyOwned = ~MyOwned;\n+static STATIC11: Box<MyOwned> = box MyOwned;\n //~^ ERROR static items are not allowed to have owned pointers\n \n // The following examples test that mutable structs are just forbidden\n@@ -109,11 +109,12 @@ static mut STATIC13: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(\n static mut STATIC14: SafeStruct = SafeStruct{field1: Variant1, field2: Variant4(\"str\".to_owned())};\n //~^ ERROR mutable static items are not allowed to have destructors\n \n-static STATIC15: &'static [~MyOwned] = &'static [~MyOwned, ~MyOwned];\n+static STATIC15: &'static [Box<MyOwned>] = &'static [box MyOwned, box MyOwned];\n //~^ ERROR static items are not allowed to have owned pointers\n //~^^ ERROR static items are not allowed to have owned pointers\n \n-static STATIC16: (&'static ~MyOwned, &'static ~MyOwned) = (&'static ~MyOwned, &'static ~MyOwned);\n+static STATIC16: (&'static Box<MyOwned>, &'static Box<MyOwned>) =\n+    (&'static box MyOwned, &'static box MyOwned);\n //~^ ERROR static items are not allowed to have owned pointers\n //~^^ ERROR static items are not allowed to have owned pointers\n \n@@ -123,10 +124,10 @@ static mut STATIC17: SafeEnum = Variant1;\n static STATIC18: @SafeStruct = @SafeStruct{field1: Variant1, field2: Variant2(0)};\n //~^ ERROR static items are not allowed to have managed pointers\n \n-static STATIC19: ~int = box 3;\n+static STATIC19: Box<int> = box 3;\n //~^ ERROR static items are not allowed to have owned pointers\n \n pub fn main() {\n-    let y = { static x: ~int = ~3; x };\n+    let y = { static x: Box<int> = box 3; x };\n     //~^ ERROR static items are not allowed to have owned pointers\n }"}, {"sha": "c4344db027baef5ad8908c0809fe75712e024b3b", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait noisy {\n   fn speak(&self);\n }\n@@ -57,6 +58,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n fn main() {\n-  let nyan: ~noisy = ~cat(0, 2, \"nyan\".to_owned()) as ~noisy;\n+  let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_owned()) as Box<noisy>;\n   nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n }"}, {"sha": "db86b5e092c52a047e0ec2a965c4fd396e245fc0", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,7 +17,7 @@ fn has_uniq(x: ~str) {\n }\n \n fn has_slice(x: &str) {\n-   wants_uniq(x); //~ ERROR mismatched types: expected `~str` but found `&str` (expected ~-ptr but f\n+   wants_uniq(x); //~ ERROR mismatched types: expected `~str` but found `&str` (expected box but f\n    wants_slice(x);\n }\n "}, {"sha": "71328acdd7017f406af5dbeafc876af001aa186b", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(y: ~int) {\n+\n+fn f(y: Box<int>) {\n     *y = 5; //~ ERROR cannot assign\n }\n \n fn g() {\n-    let _frob: |~int| = |q| { *q = 2; }; //~ ERROR cannot assign\n+    let _frob: |Box<int>| = |q| { *q = 2; }; //~ ERROR cannot assign\n \n }\n "}, {"sha": "b41797d0042fa6536c6bc856dfc5e26b9edf8c87", "filename": "src/test/compile-fail/infinite-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -23,7 +23,7 @@ impl Deref<Foo> for Foo {\n pub fn main() {\n     let mut x;\n     loop {\n-        x = ~x;\n+        x = box x;\n         x.foo;\n         x.bar();\n     }"}, {"sha": "47f2b291187020c7b73eb332ed13df2a59998b82", "filename": "src/test/compile-fail/inherit-struct1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Finherit-struct1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Finherit-struct1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherit-struct1.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,7 +11,8 @@\n // Test struct inheritance.\n #![feature(struct_inherit)]\n \n-struct S6 : ~S2; //~ ERROR not a struct\n+\n+struct S6 : int; //~ ERROR super-struct could not be resolved\n \n pub fn main() {\n }"}, {"sha": "97642377ba8f4d74696edafbb6aed616eb062ba2", "filename": "src/test/compile-fail/issue-10398.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-10398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-10398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10398.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = ~1;\n+    let x = box 1;\n     let f: proc() = proc() {\n         let _a = x;\n         drop(x);"}, {"sha": "e7fa8300bcb698467d07553842fe299b66b1455a", "filename": "src/test/compile-fail/issue-11192.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-11192.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-11192.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11192.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -19,10 +19,10 @@ impl Drop for Foo {\n }\n \n fn main() {\n-    let mut ptr = ~Foo { x: 0 };\n+    let mut ptr = box Foo { x: 0 };\n     let test = |foo: &Foo| {\n         println!(\"access {}\", foo.x);\n-        ptr = ~Foo { x: ptr.x + 1 };\n+        ptr = box Foo { x: ptr.x + 1 };\n         println!(\"access {}\", foo.x);\n     };\n     test(ptr);"}, {"sha": "4d520b570b725bd4afcd8146a27e6cb2b5dc8597", "filename": "src/test/compile-fail/issue-11515.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -13,6 +13,6 @@ struct Test<'s> {\n }\n \n fn main() {\n-    let test = ~Test { func: proc() {} };\n+    let test = box Test { func: proc() {} };\n     //~^ ERROR: expected `||` but found `proc()`\n }"}, {"sha": "a8d2c7509ce3fd6a265e89f6a884b3e9bc273116", "filename": "src/test/compile-fail/issue-11925.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let r = {\n-        let x = ~42;\n+        let x = box 42;\n         let f = proc() &x; //~ ERROR: `x` does not live long enough\n         f()\n     };"}, {"sha": "4a6219aafd0813fb35f05c7b777c3c08abb12c3c", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,7 +11,9 @@\n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n-struct t(~t); //~ ERROR this type cannot be instantiated\n+\n+\n+struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n trait to_str_2 {\n     fn my_to_str() -> ~str;"}, {"sha": "6ca4e22576ec43366c63d8ab88e3a4cb294bf8c8", "filename": "src/test/compile-fail/issue-3601.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct HTMLImageData {\n     image: Option<~str>\n }\n \n struct ElementData {\n-    kind: ~ElementKind\n+    kind: Box<ElementKind>\n }\n \n enum ElementKind {\n@@ -25,17 +26,17 @@ enum NodeKind {\n }\n \n struct NodeData {\n-    kind: ~NodeKind\n+    kind: Box<NodeKind>,\n }\n \n fn main() {\n     let mut id = HTMLImageData { image: None };\n-    let ed = ElementData { kind: ~HTMLImageElement(id) };\n-    let n = NodeData {kind : ~Element(ed)};\n+    let ed = ElementData { kind: box HTMLImageElement(id) };\n+    let n = NodeData {kind : box Element(ed)};\n     // n.b. span could be better\n     match n.kind {\n-        ~Element(ed) => match ed.kind { //~ ERROR non-exhaustive patterns\n-            ~HTMLImageElement(ref d) if d.image.is_some() => { true }\n+        box Element(ed) => match ed.kind { //~ ERROR non-exhaustive patterns\n+            box HTMLImageElement(ref d) if d.image.is_some() => { true }\n         },\n         _ => fail!(\"WAT\") //~ ERROR unreachable pattern\n     };"}, {"sha": "657d9c8f17ea5d630554cd4ee0474f78fd8bdf57", "filename": "src/test/compile-fail/issue-3763.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -26,12 +26,12 @@ fn main() {\n     let my_struct = my_mod::MyStruct();\n     let _woohoo = (&my_struct).priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private\n-    let _woohoo = (~my_struct).priv_field;\n+    let _woohoo = (box my_struct).priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private\n     let _woohoo = (@my_struct).priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private\n     (&my_struct).happyfun();               //~ ERROR method `happyfun` is private\n-    (~my_struct).happyfun();               //~ ERROR method `happyfun` is private\n+    (box my_struct).happyfun();            //~ ERROR method `happyfun` is private\n     (@my_struct).happyfun();               //~ ERROR method `happyfun` is private\n     let nope = my_struct.priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private"}, {"sha": "ffac6b499f4c1f9add5542404f1807081c1c44ca", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait MyTrait { }\n \n pub enum TraitWrapper {\n-    A(~MyTrait),\n+    A(Box<MyTrait>),\n }\n \n fn get_tw_map<'lt>(tw: &'lt TraitWrapper) -> &'lt MyTrait {\n     match *tw {\n-        A(~ref map) => map, //~ ERROR found a `~`-box pattern\n+        A(box ref map) => map, //~ ERROR found a box pattern\n     }\n }\n "}, {"sha": "6734a546be5fbc9371417109d774fc3d913a20a8", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -23,8 +23,8 @@ fn main() {\n     }\n \n     match (true, false) {\n-        ~(true, false) => ()\n-        //~^ ERROR mismatched types: expected `(bool,bool)` but found a `~`-box pattern\n+        box (true, false) => ()\n+        //~^ ERROR mismatched types: expected `(bool,bool)` but found a box pattern\n     }\n \n     match (true, false) {"}, {"sha": "55e3459a589222299476990c59f2d9658f364841", "filename": "src/test/compile-fail/issue-5439.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-5439.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-5439.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5439.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct Foo {\n     foo: int,\n }\n@@ -17,8 +18,8 @@ struct Bar {\n }\n \n impl Bar {\n-    fn make_foo (&self, i: int) -> ~Foo {\n-        return ~Foo { nonexistent: self, foo: i }; //~ ERROR: no field named\n+    fn make_foo (&self, i: int) -> Box<Foo> {\n+        return box Foo { nonexistent: self, foo: i }; //~ ERROR: no field named\n     }\n }\n "}, {"sha": "5925f6869391a1d4f6280a08567d8bac6e3a714c", "filename": "src/test/compile-fail/issue-6801.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-6801.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-6801.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6801.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -12,7 +12,8 @@\n // transferring ownership of the owned box before invoking the stack\n // closure results in a crash.\n \n-fn twice(x: ~uint) -> uint {\n+\n+fn twice(x: Box<uint>) -> uint {\n      *x * 2\n }\n \n@@ -21,7 +22,7 @@ fn invoke(f: || -> uint) {\n }\n \n fn main() {\n-      let x  : ~uint         = ~9;\n+      let x  : Box<uint>  = box 9;\n       let sq : || -> uint =  || { *x * *x };\n \n       twice(x); //~ ERROR: cannot move out of"}, {"sha": "1bc4e0765532381e03c82576d76b7eb7f8f32b78", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,35 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n use std::cell::RefCell;\n+use std::rc::Rc;\n \n-trait Foo\n-{\n+trait Foo {\n     fn set(&mut self, v: Rc<RefCell<A>>);\n }\n \n-struct B\n-{\n+struct B {\n     v: Option<Rc<RefCell<A>>>\n }\n \n-impl Foo for B\n-{\n+impl Foo for B {\n     fn set(&mut self, v: Rc<RefCell<A>>)\n     {\n         self.v = Some(v);\n     }\n }\n \n-struct A\n-{\n-    v: ~Foo:Send,\n+struct A {\n+    v: Box<Foo:Send>,\n }\n \n-fn main()\n-{\n-    let a = A {v: ~B{v: None} as ~Foo:Send};\n+fn main() {\n+    let a = A {v: box B{v: None} as Box<Foo:Send>};\n     //~^ ERROR cannot pack type `~B`, which does not fulfill `Send`\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();"}, {"sha": "e2790eb7b39d91140295baf9db5ed8816c8c7167", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -11,7 +11,8 @@\n // Verify the compiler fails with an error on infinite function\n // recursions.\n \n-struct Data(~Option<Data>);\n+\n+struct Data(Box<Option<Data>>);\n \n fn generic<T>( _ : Vec<(Data,T)> ) {\n     //~^ ERROR reached the recursion limit during monomorphization"}, {"sha": "694b0f1dbe27d5cea70d41e33566783741ce38ad", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -23,7 +23,7 @@ struct MyStruct {\n }\n \n struct MyNoncopyStruct {\n-    x: ~int,\n+    x: Box<int>,\n }\n \n fn test<'a,T,U:Copy>(_: &'a int) {\n@@ -38,19 +38,19 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n     assert_copy::<&'a mut int>();  //~ ERROR does not fulfill\n \n     // ~ pointers are not ok\n-    assert_copy::<~int>();   //~ ERROR does not fulfill\n+    assert_copy::<Box<int>>();   //~ ERROR does not fulfill\n     assert_copy::<~str>();   //~ ERROR does not fulfill\n     assert_copy::<Vec<int> >(); //~ ERROR does not fulfill\n-    assert_copy::<~&'a mut int>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<&'a mut int>>(); //~ ERROR does not fulfill\n \n     // borrowed object types are generally ok\n     assert_copy::<&'a Dummy>();\n     assert_copy::<&'a Dummy:Copy>();\n     assert_copy::<&'static Dummy:Copy>();\n \n     // owned object types are not ok\n-    assert_copy::<~Dummy>(); //~ ERROR does not fulfill\n-    assert_copy::<~Dummy:Copy>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<Dummy>>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<Dummy:Copy>>(); //~ ERROR does not fulfill\n \n     // mutable object types are not ok\n     assert_copy::<&'a mut Dummy:Copy>();  //~ ERROR does not fulfill"}, {"sha": "3f6c622dd0d6ed2a933fda237b82a5c2f081c119", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Repeat<A> { fn get(&self) -> A; }\n \n impl<A:Clone> Repeat<A> for A {\n     fn get(&self) -> A { self.clone() }\n }\n \n-fn repeater<A:Clone>(v: A) -> ~Repeat<A>: {\n-    ~v as ~Repeat<A>: // No\n+fn repeater<A:Clone>(v: A) -> Box<Repeat<A>:> {\n+    box v as Box<Repeat<A>:> // No\n }\n \n fn main() {"}, {"sha": "518e97515e799b4f434b109d7958d15a0586fcce", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -28,28 +28,28 @@ fn test<'a,T,U:Send>(_: &'a int) {\n     assert_send::<&'a str>(); //~ ERROR does not fulfill `Send`\n     assert_send::<&'a [int]>(); //~ ERROR does not fulfill `Send`\n \n-    // ~ pointers are ok\n-    assert_send::<~int>();\n+    // boxes are ok\n+    assert_send::<Box<int>>();\n     assert_send::<~str>();\n     assert_send::<Vec<int> >();\n \n     // but not if they own a bad thing\n-    assert_send::<~&'a int>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill `Send`\n \n     // careful with object types, who knows what they close over...\n     assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n     assert_send::<&'a Dummy>(); //~ ERROR does not fulfill `Send`\n     assert_send::<&'a Dummy:Send>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<~Dummy:>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<Box<Dummy:>>(); //~ ERROR does not fulfill `Send`\n \n     // ...unless they are properly bounded\n     assert_send::<&'static Dummy:Send>();\n-    assert_send::<~Dummy:Send>();\n+    assert_send::<Box<Dummy:Send>>();\n \n     // but closure and object types can have lifetime bounds which make\n     // them not ok (FIXME #5121)\n     // assert_send::<proc:'a()>(); // ERROR does not fulfill `Send`\n-    // assert_send::<~Dummy:'a>(); // ERROR does not fulfill `Send`\n+    // assert_send::<Box<Dummy:'a>>(); // ERROR does not fulfill `Send`\n \n     // unsafe ptrs are ok unless they point at unsendable things\n     assert_send::<*int>();"}, {"sha": "c898107f5e330dd8c21fd4f30dcf9ccc5c1cc7cb", "filename": "src/test/compile-fail/lint-allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-allocation.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,6 +14,6 @@ fn f(_: &int) {}\n fn g(_: &mut int) {}\n \n fn main() {\n-    f(~1); //~ ERROR unnecessary allocation, use & instead\n-    g(~1); //~ ERROR unnecessary allocation, use &mut instead\n+    f(box 1); //~ ERROR unnecessary allocation, use & instead\n+    g(box 1); //~ ERROR unnecessary allocation, use &mut instead\n }"}, {"sha": "10734f1f2430ae9ff323648bdb9438eb4d79c148", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -36,7 +36,7 @@ pub static used_static2: int = used_static;\n static USED_STATIC: int = 0;\n static STATIC_USED_IN_ENUM_DISCRIMINANT: uint = 10;\n \n-pub type typ = ~UsedStruct4;\n+pub type typ = *UsedStruct4;\n pub struct PubStruct();\n struct PrivStruct; //~ ERROR: code is never used\n struct UsedStruct1 { x: int }\n@@ -57,7 +57,7 @@ pub struct PubStruct2 {\n }\n \n pub enum pub_enum { foo1, bar1 }\n-pub enum pub_enum2 { a(~StructUsedInEnum) }\n+pub enum pub_enum2 { a(*StructUsedInEnum) }\n pub enum pub_enum3 { Foo = STATIC_USED_IN_ENUM_DISCRIMINANT }\n enum priv_enum { foo2, bar2 } //~ ERROR: code is never used\n enum used_enum { foo3, bar3 }"}, {"sha": "eaa1819bd53e5a4e9a6aac82a5fa311affecf6eb", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -13,19 +13,20 @@\n #![allow(dead_code)]\n #![allow(deprecated_owned_vector)]\n \n+\n struct Foo {\n     x: @int //~ ERROR type uses managed\n }\n \n-struct Bar { x: ~int } //~ ERROR type uses owned\n+struct Bar { x: Box<int> } //~ ERROR type uses owned\n \n fn main() {\n-    let _x : Bar = Bar {x : ~10}; //~ ERROR type uses owned\n+    let _x : Bar = Bar {x : box 10}; //~ ERROR type uses owned\n \n     @2; //~ ERROR type uses managed\n \n-    ~2; //~ ERROR type uses owned\n-    fn g(_: ~Clone) {} //~ ERROR type uses owned\n+    box 2; //~ ERROR type uses owned\n+    fn g(_: Box<Clone>) {} //~ ERROR type uses owned\n     \"\".to_owned(); //~ ERROR type uses owned\n     proc() {}; //~ ERROR type uses owned\n }"}, {"sha": "c9688ad49d77e3609eef7431c2fe2926c5bc2d20", "filename": "src/test/compile-fail/lint-owned-heap-memory.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-owned-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Flint-owned-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-owned-heap-memory.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,11 +10,12 @@\n \n #![forbid(owned_heap_memory)]\n \n+\n struct Foo {\n-    x: ~int //~ ERROR type uses owned\n+    x: Box<int> //~ ERROR type uses owned\n }\n \n fn main() {\n-    let _x : Foo = Foo {x : ~10};\n+    let _x : Foo = Foo {x : box 10};\n     //~^ ERROR type uses owned\n }"}, {"sha": "b9ad1c0fb65d93fe5d27d3e96fa20b1b56d8b3aa", "filename": "src/test/compile-fail/liveness-move-call-arg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-move-call-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-move-call-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-call-arg.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn take(_x: ~int) {}\n+\n+fn take(_x: Box<int>) {}\n \n fn main() {\n \n-    let x: ~int = ~25;\n+    let x: Box<int> = box 25;\n     loop {\n         take(x); //~ ERROR use of moved value: `x`\n     }"}, {"sha": "018b0aaecfda4f271cb6ced39add1a7164654813", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n fn main() {\n-    let y: ~int = ~42;\n-    let mut x: ~int;\n+    let y: Box<int> = box 42;\n+    let mut x: Box<int>;\n     loop {\n         println!(\"{:?}\", y);\n         loop {"}, {"sha": "e32d8a78585de2a6fa1e40a7892cbf76d0e69a77", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n \n-    let y: ~int = ~42;\n-    let mut x: ~int;\n+fn main() {\n+    let y: Box<int> = box 42;\n+    let mut x: Box<int>;\n     loop {\n         println!(\"{:?}\", y); //~ ERROR use of moved value: `y`\n         while true { while true { while true { x = y; x.clone(); } } }"}, {"sha": "f2b8976c61b930f52ef0c997e45dc687d47828f8", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = ~5;\n+    let x = box 5;\n     let y = x;\n     println!(\"{:?}\", *x); //~ ERROR use of moved value: `x`\n     y.clone();"}, {"sha": "2716d476c3a174ed4481661047b953692db94454", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n fn send<T:Send>(ch: _chan<T>, data: T) {\n     println!(\"{:?}\", ch);\n     println!(\"{:?}\", data);\n@@ -18,7 +19,7 @@ struct _chan<T>(int);\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it\n-fn test00_start(ch: _chan<~int>, message: ~int, _count: ~int) {\n+fn test00_start(ch: _chan<Box<int>>, message: Box<int>, _count: Box<int>) {\n     send(ch, message);\n     println!(\"{:?}\", message); //~ ERROR use of moved value: `message`\n }"}, {"sha": "eda4deba7527b51c75fa7e12ab77e5001365e02b", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,9 +15,9 @@ use collections::HashMap;\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: ~HashMap<~str, ~str> = ~HashMap::new();\n-    let x: ~Map<~str, ~str> = x;\n-    let y: ~Map<uint, ~str> = ~x;\n+    let x: Box<HashMap<~str, ~str>> = box HashMap::new();\n+    let x: Box<Map<~str, ~str>> = x;\n+    let y: Box<Map<uint, ~str>> = box x;\n     //~^ ERROR failed to find an implementation of trait std::container::Map<uint,~str>\n     //         for ~std::container::Map<~str,~str>:Send\n }"}, {"sha": "73323def28d78d09e3f1117869c4276a0362b23b", "filename": "src/test/compile-fail/moves-based-on-type-block-bad.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct S {\n-    x: ~E\n+    x: Box<E>\n }\n \n enum E {\n-    Foo(~S),\n-    Bar(~int),\n+    Foo(Box<S>),\n+    Bar(Box<int>),\n     Baz\n }\n \n@@ -23,13 +24,13 @@ fn f(s: &S, g: |&S|) {\n }\n \n fn main() {\n-    let s = S { x: ~Bar(~42) };\n+    let s = S { x: box Bar(box 42) };\n     loop {\n         f(&s, |hellothere| {\n             match hellothere.x { //~ ERROR cannot move out\n-                ~Foo(_) => {}\n-                ~Bar(x) => println!(\"{}\", x.to_str()), //~ NOTE attempting to move value to here\n-                ~Baz => {}\n+                box Foo(_) => {}\n+                box Bar(x) => println!(\"{}\", x.to_str()), //~ NOTE attempting to move value to here\n+                box Baz => {}\n             }\n         })\n     }"}, {"sha": "805c82f03f94cb4fdb6da717e8c5b0336e5c5658", "filename": "src/test/compile-fail/moves-based-on-type-cyclic-types-issue-4821.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-cyclic-types-issue-4821.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-cyclic-types-issue-4821.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-cyclic-types-issue-4821.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -12,17 +12,18 @@\n // temporary kinds wound up being stored in a cache and used later.\n // See middle::ty::type_contents() for more information.\n \n-struct List { key: int, next: Option<~List> }\n \n-fn foo(node: ~List) -> int {\n+struct List { key: int, next: Option<Box<List>> }\n+\n+fn foo(node: Box<List>) -> int {\n     let r = match node.next {\n         Some(right) => consume(right),\n         None => 0\n     };\n     consume(node) + r //~ ERROR use of partially moved value: `node`\n }\n \n-fn consume(v: ~List) -> int {\n+fn consume(v: Box<List>) -> int {\n     v.key\n }\n "}, {"sha": "f9614574abda970b749a44f43b6781085caa7e74", "filename": "src/test/compile-fail/moves-based-on-type-move-out-of-closure-env-issue-1965.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,9 +10,9 @@\n \n use std::uint;\n \n-fn test(_x: ~uint) {}\n+fn test(_x: Box<uint>) {}\n \n fn main() {\n-    let i = ~3;\n+    let i = box 3;\n     let _f = || test(i); //~ ERROR cannot move out\n }"}, {"sha": "85c435ef0db02a994477e4b6a165973befe88711", "filename": "src/test/compile-fail/moves-based-on-type-tuple.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-tuple.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn dup(x: ~int) -> ~(~int,~int) { ~(x, x) } //~ ERROR use of moved value\n+\n+fn dup(x: Box<int>) -> Box<(Box<int>,Box<int>)> { box() (x, x) } //~ ERROR use of moved value\n fn main() {\n-    dup(~3);\n+    dup(box 3);\n }"}, {"sha": "6f8353c61647f8251554e3fdcf7175f6495e0565", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,18 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n type Noncopyable = proc();\n \n struct Foo {\n     copied: int,\n-    moved: ~int,\n+    moved: Box<int>,\n     noncopyable: Noncopyable\n }\n \n fn test0(f: Foo, g: Noncopyable, h: Noncopyable) {\n     // just copy implicitly copyable fields from `f`, no moves:\n-    let _b = Foo {moved: ~1, noncopyable: g, ..f};\n-    let _c = Foo {moved: ~2, noncopyable: h, ..f};\n+    let _b = Foo {moved: box 1, noncopyable: g, ..f};\n+    let _c = Foo {moved: box 2, noncopyable: h, ..f};\n }\n \n fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n@@ -30,7 +31,7 @@ fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n \n fn test2(f: Foo, g: Noncopyable) {\n     // move non-copyable field\n-    let _b = Foo {copied: 22, moved: ~23, ..f};\n+    let _b = Foo {copied: 22, moved: box 23, ..f};\n     let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of partially moved value: `f`\n }\n "}, {"sha": "543902a7a5580128e18e43940ea3265048fd9906", "filename": "src/test/compile-fail/new-box-syntax-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fnew-box-syntax-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fnew-box-syntax-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnew-box-syntax-bad.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,11 +14,11 @@\n // Tests that the new `box` syntax works with unique pointers and GC pointers.\n \n use std::gc::Gc;\n-use std::owned::HEAP;\n+use std::owned::{Box, HEAP};\n \n pub fn main() {\n     let x: Gc<int> = box(HEAP) 2;  //~ ERROR mismatched types\n     let y: Gc<int> = box(HEAP)(1 + 2);  //~ ERROR mismatched types\n-    let z: ~int = box(GC)(4 + 5);   //~ ERROR mismatched types\n+    let z: Box<int> = box(GC)(4 + 5);   //~ ERROR mismatched types\n }\n "}, {"sha": "17083933afaadb7118b44bd30f7349e814dc3ffb", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that an object type `~Foo` is not considered to implement the\n+// Test that an object type `Box<Foo>` is not considered to implement the\n // trait `Foo`. Issue #5087.\n \n+\n trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n-fn take_object(f: ~Foo) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n+fn take_object(f: Box<Foo>) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n fn main() {}"}, {"sha": "8868ddd4dfa302f8ac20f6533314fc1c12d95b81", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Foo {\n     fn borrowed(&self);\n     fn borrowed_mut(&mut self);\n@@ -27,7 +28,7 @@ fn borrowed_mut_receiver(x: &mut Foo) {\n     x.owned(); //~ ERROR does not implement any method\n }\n \n-fn owned_receiver(x: ~Foo) {\n+fn owned_receiver(x: Box<Foo>) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n     x.managed();  //~ ERROR does not implement any method"}, {"sha": "48f04c334941ac4e1c8226c207e799938725b000", "filename": "src/test/compile-fail/owned-ptr-static-bound.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fowned-ptr-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fowned-ptr-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fowned-ptr-static-bound.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,22 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait A<T> {}\n struct B<'a, T>(&'a A<T>);\n \n trait X {}\n impl<'a, T> X for B<'a, T> {}\n \n-fn f<'a, T, U>(v: ~A<T>) -> ~X: {\n-    ~B(v) as ~X: //~ ERROR value may contain references; add `'static` bound to `T`\n+fn f<'a, T, U>(v: Box<A<T>>) -> Box<X:> {\n+    box B(v) as Box<X:> //~ ERROR value may contain references; add `'static` bound to `T`\n }\n \n-fn g<'a, T, U>(v: ~A<U>) -> ~X: {\n-    ~B(v) as ~X: //~ ERROR value may contain references; add `'static` bound to `U`\n+fn g<'a, T, U>(v: Box<A<U>>) -> Box<X:> {\n+    box B(v) as Box<X:> //~ ERROR value may contain references; add `'static` bound to `U`\n }\n \n-fn h<'a, T: 'static>(v: ~A<T>) -> ~X: {\n-    ~B(v) as ~X: // ok\n+fn h<'a, T: 'static>(v: Box<A<T>>) -> Box<X:> {\n+    box B(v) as Box<X:> // ok\n }\n \n fn main() {}"}, {"sha": "49f2f35d29dcdc7029e30f453f2bdf1fec309d53", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -39,7 +39,7 @@ fn main() {\n     let i = @Cell::new(0);\n     {\n         // Can't do this copy\n-        let x = ~~~A {y: r(i)};\n+        let x = box box box A {y: r(i)};\n         let _z = x.clone(); //~ ERROR failed to find an implementation\n         println!(\"{:?}\", x);\n     }"}, {"sha": "b7eee206b4074637130fe616ab242511cd785798", "filename": "src/test/compile-fail/privacy-ns1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,6 +15,7 @@\n #![allow(dead_code)]\n #![allow(unused_imports)]\n \n+\n // public type, private value\n pub mod foo1 {\n     pub trait Bar {\n@@ -42,7 +43,7 @@ pub mod foo2 {\n fn test_glob2() {\n     use foo2::*;\n \n-    let _x: ~Bar;  //~ ERROR use of undeclared type name `Bar`\n+    let _x: Box<Bar>;  //~ ERROR use of undeclared type name `Bar`\n }\n \n // neither public\n@@ -58,7 +59,7 @@ fn test_glob3() {\n     use foo3::*;\n \n     Bar();  //~ ERROR unresolved name `Bar`.\n-    let _x: ~Bar;  //~ ERROR  use of undeclared type name `Bar`\n+    let _x: Box<Bar>;  //~ ERROR  use of undeclared type name `Bar`\n }\n \n fn main() {"}, {"sha": "5ce0fb7e56a2ca884f5b5a376988f70bd15856c8", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -15,6 +15,7 @@\n #![allow(dead_code)]\n #![allow(unused_imports)]\n \n+\n // public type, private value\n pub mod foo1 {\n     pub trait Bar {\n@@ -49,13 +50,13 @@ pub mod foo2 {\n fn test_single2() {\n     use foo2::Bar;  //~ ERROR `Bar` is private\n \n-    let _x : ~Bar;\n+    let _x : Box<Bar>;\n }\n \n fn test_list2() {\n     use foo2::{Bar,Baz};  //~ ERROR `Bar` is private\n \n-    let _x: ~Bar;\n+    let _x: Box<Bar>;\n }\n \n // neither public\n@@ -76,14 +77,14 @@ fn test_single3() {\n     use foo3::Bar;  //~ ERROR `Bar` is private\n \n     Bar();\n-    let _x: ~Bar;\n+    let _x: Box<Bar>;\n }\n \n fn test_list3() {\n     use foo3::{Bar,Baz};  //~ ERROR `Bar` is private\n \n     Bar();\n-    let _x: ~Bar;\n+    let _x: Box<Bar>;\n }\n \n fn main() {"}, {"sha": "aa398bcd55746c9e09390ab6c22d85520d936f4a", "filename": "src/test/compile-fail/regions-bound-lists-feature-gate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fregions-bound-lists-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fregions-bound-lists-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-lists-feature-gate.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Foo { }\n \n-fn foo<'a>(x: ~Foo:'a) { //~ ERROR only the 'static lifetime is accepted here\n+fn foo<'a>(x: Box<Foo:'a>) { //~ ERROR only the 'static lifetime is accepted here\n }\n \n fn bar<'a, T:'a>() { //~ ERROR only the 'static lifetime is accepted here"}, {"sha": "47fca8bb8df2374e83395d5a46599afbf96441cd", "filename": "src/test/compile-fail/regions-ref-in-fn-arg.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn arg_item(~ref x: ~int) -> &'static int {\n+\n+fn arg_item(box ref x: Box<int>) -> &'static int {\n     x //~^ ERROR borrowed value does not live long enough\n }\n \n-fn with<R>(f: |~int| -> R) -> R { f(~3) }\n+fn with<R>(f: |Box<int>| -> R) -> R { f(box 3) }\n \n fn arg_closure() -> &'static int {\n-    with(|~ref x| x) //~ ERROR borrowed value does not live long enough\n+    with(|box ref x| x) //~ ERROR borrowed value does not live long enough\n }\n \n fn main() {}"}, {"sha": "7771a71c79bc07bc0de4f4bfafc75f9efeb004e5", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct ctxt { v: uint }\n \n trait get_ctxt {\n@@ -27,12 +28,12 @@ impl<'a> get_ctxt for has_ctxt<'a> {\n \n }\n \n-fn get_v(gc: ~get_ctxt) -> uint {\n+fn get_v(gc: Box<get_ctxt>) -> uint {\n     gc.get_ctxt().v\n }\n \n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    assert_eq!(get_v(~hc as ~get_ctxt), 22u);\n+    assert_eq!(get_v(box hc as Box<get_ctxt>), 22u);\n }"}, {"sha": "c5c8aa043f38f9bb9eeb0d9a366c3c1631d79df5", "filename": "src/test/compile-fail/removed-syntax-closure-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type closure = ~lt/fn(); //~ ERROR expected `;` but found `/`\n+type closure = Box<lt/fn()>; //~ ERROR expected `,` but found `/`"}, {"sha": "5603cd21f3b3119fc7a854ca04bcde6c69ce31c8", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn f() {\n-    let a_box = ~mut 42;\n+    let a_box = box mut 42;\n     //~^  ERROR found `mut` in ident position\n     //~^^ ERROR expected `;` but found `42`\n }"}, {"sha": "128dbbd9cabfc6dc37039db39ad07f7d22fc03d7", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type mut_box = ~mut int;\n+type mut_box = Box<mut int>;\n     //~^  ERROR found `mut` in ident position\n-    //~^^ ERROR expected `;` but found `int`\n+    //~^^ ERROR expected `,` but found `int`"}, {"sha": "8fb9c5e0e6f840b561f5edb348de210e47b1be94", "filename": "src/test/compile-fail/removed-syntax-uniq-self.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24f6f26e633e50b5b59f9d0f6cca0b1e49e215d9/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24f6f26e633e50b5b59f9d0f6cca0b1e49e215d9/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs?ref=24f6f26e633e50b5b59f9d0f6cca0b1e49e215d9", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct S;\n-\n-impl S {\n-    fn f(~mut self) {} //~ ERROR found `self` in ident position\n-    //~^ ERROR expected `:` but found `)`\n-}"}, {"sha": "3bf547e3affc3bfd110b551c177696d3d674b88c", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait add {\n     fn plus(&self, x: Self) -> Self;\n }\n \n-fn do_add(x: ~add, y: ~add) -> ~add {\n+fn do_add(x: Box<add>, y: Box<add>) -> Box<add> {\n     x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through an object\n }\n "}, {"sha": "927006adc9e265ca901b2aac91ac152893d1b221", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static mut a: ~int = ~3; //~ ERROR: mutable static items are not allowed to have owned pointers\n+\n+static mut a: Box<int> = box 3;\n+//~^ ERROR mutable static items are not allowed to have owned pointers\n \n fn main() {}"}, {"sha": "0afc84ee1b367483373d517ff7a902b158564788", "filename": "src/test/compile-fail/struct-fields-missing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fstruct-fields-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fstruct-fields-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-missing.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct BuildData {\n     foo: int,\n-    bar: ~int\n+    bar: Box<int>,\n }\n \n fn main() {"}, {"sha": "12205ef062da0877c1adfa4c99b79cac03d28a7c", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,17 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Foo {\n }\n \n-fn a(_x: ~Foo:Send) {\n+fn a(_x: Box<Foo:Send>) {\n }\n \n-fn c(x: ~Foo:Share+Send) {\n+fn c(x: Box<Foo:Share+Send>) {\n     a(x);\n }\n \n-fn d(x: ~Foo:) {\n+fn d(x: Box<Foo:>) {\n     a(x); //~ ERROR found no bounds\n }\n "}, {"sha": "be5375d29384d8568a949e1f5f47321fc00b93dc", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct Foo;\n \n-fn foo(_x: ~Foo:Send) { } //~ ERROR kind bounds can only be used on trait types\n+fn foo(_x: Box<Foo:Send>) { } //~ ERROR kind bounds can only be used on trait types\n \n fn main() { }"}, {"sha": "9447030a7f461aca92037bfb25dc19d66db3d0d6", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,15 +10,16 @@\n \n // Tests for \"default\" bounds inferred for traits with no bounds list.\n \n+\n trait Foo {}\n \n-fn a(_x: ~Foo:Send) {\n+fn a(_x: Box<Foo:Send>) {\n }\n \n fn b(_x: &'static Foo) { // should be same as &'static Foo:'static\n }\n \n-fn c(x: ~Foo:Share) {\n+fn c(x: Box<Foo:Share>) {\n     a(x); //~ ERROR expected bounds `Send`\n }\n "}, {"sha": "7c4b633fa9e2d100f8cbd538ea843574f3177740", "filename": "src/test/compile-fail/trait-coercion-generic-bad.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct Struct {\n     person: &'static str\n }\n@@ -23,7 +24,7 @@ impl Trait<&'static str> for Struct {\n }\n \n fn main() {\n-    let s: ~Trait<int> = ~Struct { person: \"Fred\" };\n+    let s: Box<Trait<int>> = box Struct { person: \"Fred\" };\n     //~^ ERROR expected Trait<int>, but found Trait<&'static str>\n     //~^^ ERROR expected Trait<int>, but found Trait<&'static str>\n     s.f(1);"}, {"sha": "04239de2a83cc44e258ecd5c61221b545da3e779", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct Struct {\n     person: &'static str\n }\n@@ -25,6 +26,6 @@ impl Trait<&'static str> for Struct {\n fn main() {\n     let person = \"Fred\".to_owned();\n     let person: &str = person;  //~ ERROR `person[..]` does not live long enough\n-    let s: ~Trait<&'static str> = ~Struct { person: person };\n+    let s: Box<Trait<&'static str>> = box Struct { person: person };\n }\n "}, {"sha": "5e0340ce4f5c16093af2806c7df21610538ba7e4", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait bar { fn dup(&self) -> Self; fn blah<X>(&self); }\n impl bar for int { fn dup(&self) -> int { *self } fn blah<X>(&self) {} }\n impl bar for uint { fn dup(&self) -> uint { *self } fn blah<X>(&self) {} }\n \n fn main() {\n     10i.dup::<int>(); //~ ERROR does not take type parameters\n     10i.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    (~10 as ~bar).dup(); //~ ERROR contains a self-type\n+    (box 10 as Box<bar>).dup(); //~ ERROR contains a self-type\n }"}, {"sha": "e237e2c8b75611f7c3100dcbdfab7dae6830a78f", "filename": "src/test/compile-fail/unique-object-noncopyable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n trait Foo {\n     fn f(&self);\n }\n@@ -27,7 +28,7 @@ impl Foo for Bar {\n }\n \n fn main() {\n-    let x = ~Bar { x: 10 };\n-    let y: ~Foo = x as ~Foo;\n+    let x = box Bar { x: 10 };\n+    let y: Box<Foo> = x as Box<Foo>;\n     let _z = y.clone(); //~ ERROR does not implement any method in scope\n }"}, {"sha": "04d8bc96a4717af69da4f9635b2a0ef9f242c569", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -17,7 +17,7 @@ impl Drop for r {\n }\n \n fn main() {\n-    let i = ~r { b: true };\n+    let i = box r { b: true };\n     let _j = i.clone(); //~ ERROR failed to find an implementation\n     println!(\"{:?}\", i);\n }"}, {"sha": "6a62256b881318019114bf9d50ba31a8ae2da386", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -14,6 +14,6 @@ fn f<T:Send>(_i: T) {\n }\n \n fn main() {\n-    let i = ~@100;\n+    let i = box @100;\n     f(i); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "adeecf2babf32c1041907cc4abe648b6adeb818e", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -31,8 +31,8 @@ fn f<T>(_i: Vec<T> , _j: Vec<T> ) {\n fn main() {\n     let i1 = @Cell::new(0);\n     let i2 = @Cell::new(1);\n-    let r1 = vec!(~r { i: i1 });\n-    let r2 = vec!(~r { i: i2 });\n+    let r1 = vec!(box r { i: i1 });\n+    let r2 = vec!(box r { i: i2 });\n     f(r1.clone(), r2.clone());\n     //~^ ERROR failed to find an implementation of\n     println!(\"{:?}\", (r2, i1.get()));"}, {"sha": "e356f87af69d58e090a121b922aa9f6df29ca121", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,6 +10,7 @@\n \n // error-pattern:unreachable pattern\n \n-enum foo { a(~foo, int), b(uint), }\n \n-fn main() { match b(1u) { b(_) | a(~_, 1) => { } a(_, 1) => { } } }\n+enum foo { a(Box<foo>, int), b(uint), }\n+\n+fn main() { match b(1u) { b(_) | a(box _, 1) => { } a(_, 1) => { } } }"}, {"sha": "c321871c40f2c29983502976eef41e3068d4de08", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,6 +10,7 @@\n \n // Test sized-ness checking in substitution.\n \n+\n // Unbounded.\n fn f1<type X>(x: &X) {\n     f2::<X>(x); //~ ERROR instantiating a type parameter with an incompatible type `X`, which does n\n@@ -49,7 +50,7 @@ fn f8<type X>(x1: &S<X>, x2: &S<X>) {\n }\n \n // Test some tuples.\n-fn f9<type X>(x1: ~S<X>, x2: ~E<X>) {\n+fn f9<type X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     f5(&(*x1, 34)); //~ERROR instantiating a type parameter with an incompatible type `(S<X>,int)`,\n     f5(&(32, *x2)); //~ERROR instantiating a type parameter with an incompatible type `(int,E<X>)`,\n }"}, {"sha": "9916fdba20f6ea82f1f3a94eb0032c614498a426", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -10,6 +10,7 @@\n \n // Test `type` local variables.\n \n+\n trait T for type {}\n \n fn f1<type X>(x: &X) {\n@@ -25,12 +26,12 @@ fn f2<type X: T>(x: &X) {\n     let y: (int, (X, int)); //~ERROR variable `y` has dynamically sized type `(int,(X,int))`\n }\n \n-fn f3<type X>(x1: ~X, x2: ~X, x3: ~X) {\n+fn f3<type X>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n     let y: X = *x1; //~ERROR variable `y` has dynamically sized type `X`\n     let y = *x2; //~ERROR variable `y` has dynamically sized type `X`\n     let (y, z) = (*x3, 4); //~ERROR variable `y` has dynamically sized type `X`\n }\n-fn f4<type X: T>(x1: ~X, x2: ~X, x3: ~X) {\n+fn f4<type X: T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n     let y: X = *x1;         //~ERROR variable `y` has dynamically sized type `X`\n     let y = *x2;            //~ERROR variable `y` has dynamically sized type `X`\n     let (y, z) = (*x3, 4); //~ERROR variable `y` has dynamically sized type `X`"}, {"sha": "e95ab71e5aaeae895c28ebaf5eb7b7a628b430b5", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -23,17 +23,17 @@ impl fmt::Show for Number {\n }\n \n struct List {\n-    list: Vec<~ToStr> }\n+    list: Vec<Box<ToStr>> }\n \n impl List {\n-    fn push(&mut self, n: ~ToStr) {\n+    fn push(&mut self, n: Box<ToStr>) {\n         self.list.push(n);\n     }\n }\n \n fn main() {\n-    let n = ~Number { n: 42 };\n-    let mut l = ~List { list: Vec::new() };\n+    let n = box Number { n: 42 };\n+    let mut l = box List { list: Vec::new() };\n     l.push(n);\n     let x = n.to_str();\n     //~^ ERROR: use of moved value: `n`"}, {"sha": "8d1ab1bcd947ca14f5677f7d132e03adee932b09", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n struct S {\n-    x: ~int\n+    x: Box<int>,\n }\n \n impl S {\n@@ -22,6 +23,6 @@ impl S {\n }\n \n fn main() {\n-    let x = S { x: ~1 };\n+    let x = S { x: box 1 };\n     println!(\"{}\", x.foo());\n }"}, {"sha": "e271a221611ae936c19d38cbebefd848dd664990", "filename": "src/test/debug-info/borrowed-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -65,7 +65,7 @@ fn main() {\n     let managed_val_interior_ref_1: &int = &managed_val.x;\n     let managed_val_interior_ref_2: &f64 = &managed_val.y;\n \n-    let unique_val = ~SomeStruct { x: 13, y: 26.5 };\n+    let unique_val = box SomeStruct { x: 13, y: 26.5 };\n     let unique_val_ref: &SomeStruct = unique_val;\n     let unique_val_interior_ref_1: &int = &unique_val.x;\n     let unique_val_interior_ref_2: &f64 = &unique_val.y;"}, {"sha": "b619f8e8ba12f05c68be6a94882a4288ef8ce348", "filename": "src/test/debug-info/borrowed-tuple.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -31,6 +31,7 @@\n \n #![allow(unused_variable)]\n \n+\n fn main() {\n     let stack_val: (i16, f32) = (-14, -19f32);\n     let stack_val_ref: &(i16, f32) = &stack_val;\n@@ -39,7 +40,7 @@ fn main() {\n     let managed_val: @(i16, f32) = @(-16, -21f32);\n     let managed_val_ref: &(i16, f32) = managed_val;\n \n-    let unique_val: ~(i16, f32) = ~(-17, -22f32);\n+    let unique_val: Box<(i16, f32)> = box() (-17, -22f32);\n     let unique_val_ref: &(i16, f32) = unique_val;\n \n     zzz();"}, {"sha": "eaa2679e698c4f67bfc528f71d0e4babd41c7afe", "filename": "src/test/debug-info/borrowed-unique-basic.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -63,46 +63,46 @@\n \n \n fn main() {\n-    let bool_box: ~bool = ~true;\n+    let bool_box: Box<bool> = box true;\n     let bool_ref: &bool = bool_box;\n \n-    let int_box: ~int = ~-1;\n+    let int_box: Box<int> = box -1;\n     let int_ref: &int = int_box;\n \n-    let char_box: ~char = ~'a';\n+    let char_box: Box<char> = box 'a';\n     let char_ref: &char = char_box;\n \n-    let i8_box: ~i8 = ~68;\n+    let i8_box: Box<i8> = box 68;\n     let i8_ref: &i8 = i8_box;\n \n-    let i16_box: ~i16 = ~-16;\n+    let i16_box: Box<i16> = box -16;\n     let i16_ref: &i16 = i16_box;\n \n-    let i32_box: ~i32 = ~-32;\n+    let i32_box: Box<i32> = box -32;\n     let i32_ref: &i32 = i32_box;\n \n-    let i64_box: ~i64 = ~-64;\n+    let i64_box: Box<i64> = box -64;\n     let i64_ref: &i64 = i64_box;\n \n-    let uint_box: ~uint = ~1;\n+    let uint_box: Box<uint> = box 1;\n     let uint_ref: &uint = uint_box;\n \n-    let u8_box: ~u8 = ~100;\n+    let u8_box: Box<u8> = box 100;\n     let u8_ref: &u8 = u8_box;\n \n-    let u16_box: ~u16 = ~16;\n+    let u16_box: Box<u16> = box 16;\n     let u16_ref: &u16 = u16_box;\n \n-    let u32_box: ~u32 = ~32;\n+    let u32_box: Box<u32> = box 32;\n     let u32_ref: &u32 = u32_box;\n \n-    let u64_box: ~u64 = ~64;\n+    let u64_box: Box<u64> = box 64;\n     let u64_ref: &u64 = u64_box;\n \n-    let f32_box: ~f32 = ~2.5;\n+    let f32_box: Box<f32> = box 2.5;\n     let f32_ref: &f32 = f32_box;\n \n-    let f64_box: ~f64 = ~3.5;\n+    let f64_box: Box<f64> = box 3.5;\n     let f64_ref: &f64 = f64_box;\n     zzz();\n }"}, {"sha": "a849a058332c3a8a16b4d762178ba16244cf8db3", "filename": "src/test/debug-info/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -28,8 +28,8 @@\n #![allow(unused_variable)]\n \n fn main() {\n-    let a = ~1;\n-    let b = ~(2, 3.5);\n+    let a = box 1;\n+    let b = box() (2, 3.5);\n     let c = @4;\n     let d = @false;\n     _zzz();"}, {"sha": "a286fca22c1c265bd3caee0217e4643978d7ffc3", "filename": "src/test/debug-info/boxed-struct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -30,6 +30,7 @@\n #![feature(managed_boxes)]\n #![allow(unused_variable)]\n \n+\n struct StructWithSomePadding {\n     x: i16,\n     y: i32,\n@@ -50,10 +51,10 @@ impl Drop for StructWithDestructor {\n \n fn main() {\n \n-    let unique = ~StructWithSomePadding { x: 99, y: 999, z: 9999, w: 99999 };\n+    let unique = box StructWithSomePadding { x: 99, y: 999, z: 9999, w: 99999 };\n     let managed = @StructWithSomePadding { x: 88, y: 888, z: 8888, w: 88888 };\n \n-    let unique_dtor = ~StructWithDestructor { x: 77, y: 777, z: 7777, w: 77777 };\n+    let unique_dtor = box StructWithDestructor { x: 77, y: 777, z: 7777, w: 77777 };\n     let managed_dtor = @StructWithDestructor { x: 33, y: 333, z: 3333, w: 33333 };\n \n     zzz();"}, {"sha": "f3692e7bf961aefed4547635a2f46e45d23e6e91", "filename": "src/test/debug-info/closure-in-generic-function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fclosure-in-generic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fclosure-in-generic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fclosure-in-generic-function.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -40,7 +40,7 @@ fn some_generic_fun<T1, T2>(a: T1, b: T2) -> (T2, T1) {\n \n fn main() {\n     some_generic_fun(0.5, 10);\n-    some_generic_fun(&29, ~110);\n+    some_generic_fun(&29, box 110);\n }\n \n fn zzz() {()}"}, {"sha": "2f7fc961cddb1e96ebfbaa6e5aee07bc4d3a435e", "filename": "src/test/debug-info/destructured-fn-argument.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -183,6 +183,7 @@\n \n #![allow(unused_variable)]\n \n+\n struct Struct {\n     a: i64,\n     b: i32\n@@ -249,7 +250,7 @@ fn contained_borrowed_pointer((&cc, _): (&int, int)) {\n     zzz();\n }\n \n-fn unique_pointer(~dd: ~(int, int, int)) {\n+fn unique_pointer(box dd: Box<(int, int, int)>) {\n     zzz();\n }\n \n@@ -299,7 +300,7 @@ fn main() {\n     managed_box(&(34, 35));\n     borrowed_pointer(&(36, 37));\n     contained_borrowed_pointer((&38, 39));\n-    unique_pointer(~(40, 41, 42));\n+    unique_pointer(box() (40, 41, 42));\n     ref_binding((43, 44, 45));\n     ref_binding_in_tuple((46, (47, 48)));\n     ref_binding_in_struct(Struct { a: 49, b: 50 });"}, {"sha": "3dab6ace9a82ac80b57a8cf0607934a39d1af2e2", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -181,7 +181,7 @@ fn main() {\n     let (&cc, _) = (&38, 39);\n \n     // unique pointer\n-    let ~dd = ~(40, 41, 42);\n+    let box dd = box() (40, 41, 42);\n \n     // ref binding\n     let ref ee = (43, 44, 45);"}, {"sha": "7afa89529989a0f2f610b1b821a7741753a2067b", "filename": "src/test/debug-info/generic-method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -91,7 +91,7 @@ fn main() {\n     let _ = stack.self_by_ref(-1, -2_i8);\n     let _ = stack.self_by_val(-3, -4_i16);\n \n-    let owned = ~Struct { x: 1234.5 };\n+    let owned = box Struct { x: 1234.5 };\n     let _ = owned.self_by_ref(-5, -6_i32);\n     let _ = owned.self_by_val(-7, -8_i64);\n     let _ = owned.self_owned(-9, -10.5_f32);"}, {"sha": "2207b3ef798eebf7d77fc7e8cbfa35594840a1ab", "filename": "src/test/debug-info/managed-pointer-within-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -35,9 +35,9 @@ struct ContainsManaged {\n }\n \n fn main() {\n-    let ordinary_unique = ~(-1, -2);\n+    let ordinary_unique = box() (-1, -2);\n \n-    let managed_within_unique = ~ContainsManaged { x: -3, y: @-4 };\n+    let managed_within_unique = box ContainsManaged { x: -3, y: @-4 };\n \n     zzz();\n }"}, {"sha": "9c8718a4295cd9318d1baa56724ea2eacebcaaf4", "filename": "src/test/debug-info/method-on-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090040bf4037a094e50b03d79e4baf5cd89c912b/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs?ref=090040bf4037a094e50b03d79e4baf5cd89c912b", "patch": "@@ -94,7 +94,7 @@ fn main() {\n     let _ = stack.self_by_ref(-1, -2);\n     let _ = stack.self_by_val(-3, -4);\n \n-    let owned = ~Variant1{ x: 1799, y: 1799 };\n+    let owned = box Variant1{ x: 1799, y: 1799 };\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);"}]}