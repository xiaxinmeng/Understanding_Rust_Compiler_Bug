{"sha": "5fc211accf9b08d2e5dd8edd3c52d484e3910499", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYzIxMWFjY2Y5YjA4ZDJlNWRkOGVkZDNjNTJkNDg0ZTM5MTA0OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T13:41:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T13:41:15Z"}, "message": "auto merge of #8749 : gifnksm/rust/bigint-cfg, r=pnkfelix\n\nThis also fixes #4393.", "tree": {"sha": "b85a0024f76d667597e78332706342b9e82d393d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b85a0024f76d667597e78332706342b9e82d393d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fc211accf9b08d2e5dd8edd3c52d484e3910499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc211accf9b08d2e5dd8edd3c52d484e3910499", "html_url": "https://github.com/rust-lang/rust/commit/5fc211accf9b08d2e5dd8edd3c52d484e3910499", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fc211accf9b08d2e5dd8edd3c52d484e3910499/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540d98e7fc145258371345c536c8e0ec987270f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/540d98e7fc145258371345c536c8e0ec987270f0", "html_url": "https://github.com/rust-lang/rust/commit/540d98e7fc145258371345c536c8e0ec987270f0"}, {"sha": "f8f17a39ceb74cbd55006c389f1925c0e9ed8eab", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f17a39ceb74cbd55006c389f1925c0e9ed8eab", "html_url": "https://github.com/rust-lang/rust/commit/f8f17a39ceb74cbd55006c389f1925c0e9ed8eab"}], "stats": {"total": 442, "additions": 210, "deletions": 232}, "files": [{"sha": "9222dea13c4d21490af12cad9fc3a3a07399bcb6", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 210, "deletions": 232, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/5fc211accf9b08d2e5dd8edd3c52d484e3910499/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc211accf9b08d2e5dd8edd3c52d484e3910499/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=5fc211accf9b08d2e5dd8edd3c52d484e3910499", "patch": "@@ -32,49 +32,45 @@ A BigDigit is a BigUint's composing element.\n \n A BigDigit is half the size of machine word size.\n */\n-#[cfg(target_arch = \"x86\")]\n-#[cfg(target_arch = \"arm\")]\n-#[cfg(target_arch = \"mips\")]\n+#[cfg(target_word_size = \"32\")]\n pub type BigDigit = u16;\n \n /**\n A BigDigit is a BigUint's composing element.\n \n A BigDigit is half the size of machine word size.\n */\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(target_word_size = \"64\")]\n pub type BigDigit = u32;\n \n pub static ZERO_BIG_DIGIT: BigDigit = 0;\n \n pub mod BigDigit {\n     use bigint::BigDigit;\n \n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_word_size = \"32\")]\n     pub static bits: uint = 16;\n \n-    #[cfg(target_arch = \"x86_64\")]\n+    #[cfg(target_word_size = \"64\")]\n     pub static bits: uint = 32;\n \n     pub static base: uint = 1 << bits;\n     static hi_mask: uint = (-1 as uint) << bits;\n     static lo_mask: uint = (-1 as uint) >> bits;\n \n-\n+    #[inline]\n     fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-\n+    #[inline]\n     fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n-\n+    #[inline]\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n-\n+    #[inline]\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n@@ -92,40 +88,26 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n-\n+    #[inline]\n     fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n-\n-    fn ne(&self, other: &BigUint) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigUint {\n-\n+    #[inline]\n     fn equals(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigUint {\n-\n+    #[inline]\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-\n-    fn le(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Less | Equal => true, _ => false }\n-    }\n-\n-    fn ge(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Greater | Equal => true, _ => false }\n-    }\n-\n-    fn gt(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Greater => true, _ => false }\n-    }\n }\n \n impl TotalOrd for BigUint {\n-\n+    #[inline]\n     fn cmp(&self, other: &BigUint) -> Ordering {\n         let (s_len, o_len) = (self.data.len(), other.data.len());\n         if s_len < o_len { return Less; }\n@@ -140,12 +122,12 @@ impl TotalOrd for BigUint {\n }\n \n impl ToStr for BigUint {\n-\n+    #[inline]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigUint {\n-\n+    #[inline]\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -154,25 +136,25 @@ impl FromStr for BigUint {\n impl Num for BigUint {}\n \n impl Orderable for BigUint {\n-\n+    #[inline]\n     fn min(&self, other: &BigUint) -> BigUint {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn max(&self, other: &BigUint) -> BigUint {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn clamp(&self, mn: &BigUint, mx: &BigUint) -> BigUint {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -181,7 +163,7 @@ impl Shl<uint, BigUint> for BigUint {\n }\n \n impl Shr<uint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -190,22 +172,21 @@ impl Shr<uint, BigUint> for BigUint {\n }\n \n impl Zero for BigUint {\n-\n+    #[inline]\n     fn zero() -> BigUint { BigUint::new(~[]) }\n \n-\n+    #[inline]\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n-\n+    #[inline]\n     fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n-\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n@@ -225,7 +206,6 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n-\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n@@ -298,14 +278,14 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod);\n         }\n \n-\n+        #[inline]\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = num::min(a.data.len(), n);\n             return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n                     BigUint::from_slice(a.data.slice(0, mid)));\n         }\n \n-\n+        #[inline]\n         fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n                 Less    => (Less,    b - a),\n@@ -317,45 +297,44 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Div<BigUint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn div(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n-\n+    #[inline]\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n impl Integer for BigUint {\n-\n+    #[inline]\n     fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.div_mod_floor(other)\n     }\n \n-\n+    #[inline]\n     fn div_floor(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-\n+    #[inline]\n     fn mod_floor(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-\n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n@@ -443,7 +422,7 @@ impl Integer for BigUint {\n      *\n      * The result is always positive\n      */\n-\n+    #[inline]\n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n         let mut m = (*self).clone();\n@@ -459,15 +438,15 @@ impl Integer for BigUint {\n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-\n+    #[inline]\n     fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-\n+    #[inline]\n     fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n \n     /// Returns `true` if the number is divisible by `2`\n-\n+    #[inline]\n     fn is_even(&self) -> bool {\n         // Considering only the last digit.\n         if self.data.is_empty() {\n@@ -478,24 +457,23 @@ impl Integer for BigUint {\n     }\n \n     /// Returns `true` if the number is not divisible by `2`\n-\n+    #[inline]\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl IntConvertible for BigUint {\n-\n+    #[inline]\n     fn to_int(&self) -> int {\n         num::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n-\n+    #[inline]\n     fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n impl ToStrRadix for BigUint {\n-\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n@@ -504,7 +482,6 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n \n-\n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n@@ -520,7 +497,6 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n-\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let mut s = str::with_capacity(v.len() * l);\n@@ -536,7 +512,7 @@ impl ToStrRadix for BigUint {\n \n impl FromStrRadix for BigUint {\n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(s.as_bytes(), radix)\n@@ -545,7 +521,7 @@ impl FromStrRadix for BigUint {\n \n impl BigUint {\n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_move_default(0, |p| p + 1);\n@@ -557,7 +533,7 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n@@ -567,13 +543,12 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(slice.to_owned());\n     }\n \n     /// Creates and initializes an BigUint.\n-\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -603,6 +578,7 @@ impl BigUint {\n \n     /// Converts this big integer into a uint, returning the uint::max_value if\n     /// it's too large to fit in a uint.\n+    #[inline]\n     pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n@@ -612,15 +588,15 @@ impl BigUint {\n         }\n     }\n \n-\n+    #[inline]\n     fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n \n         return BigUint::new(vec::from_elem(n_unit, ZERO_BIG_DIGIT)\n                             + self.data);\n     }\n \n-\n+    #[inline]\n     fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n@@ -636,7 +612,7 @@ impl BigUint {\n         return BigUint::new(shifted);\n     }\n \n-\n+    #[inline]\n     fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return (*self).clone(); }\n         if self.data.len() < n_unit { return Zero::zero(); }\n@@ -645,7 +621,7 @@ impl BigUint {\n         );\n     }\n \n-\n+    #[inline]\n     fn shr_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n@@ -659,8 +635,8 @@ impl BigUint {\n     }\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n-\n+#[cfg(target_word_size = \"64\")]\n+#[inline]\n fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -683,10 +659,8 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n     }\n }\n \n-#[cfg(target_arch = \"arm\")]\n-#[cfg(target_arch = \"x86\")]\n-#[cfg(target_arch = \"mips\")]\n-\n+#[cfg(target_word_size = \"32\")]\n+#[inline]\n fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -714,31 +688,18 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n-\n+    #[inline]\n     fn lt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-\n-    fn le(&self, other: &Sign) -> bool {\n-        match self.cmp(other) { Less | Equal => true, _ => false }\n-    }\n-\n-    fn ge(&self, other: &Sign) -> bool {\n-        match self.cmp(other) { Greater | Equal => true, _ => false }\n-    }\n-\n-    fn gt(&self, other: &Sign) -> bool {\n-        match self.cmp(other) { Greater => true, _ => false }\n-    }\n }\n \n impl TotalEq for Sign {\n-    fn equals(&self, other: &Sign) -> bool {\n-        *self == *other\n-    }\n+    #[inline]\n+    fn equals(&self, other: &Sign) -> bool { *self == *other }\n }\n impl TotalOrd for Sign {\n-\n+    #[inline]\n     fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n@@ -750,7 +711,7 @@ impl TotalOrd for Sign {\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n-\n+    #[inline]\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n@@ -768,40 +729,26 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-\n+    #[inline]\n     fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n-\n-    fn ne(&self, other: &BigInt) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigInt {\n-\n+    #[inline]\n     fn equals(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigInt {\n-\n+    #[inline]\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-\n-    fn le(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Less | Equal => true, _ => false }\n-    }\n-\n-    fn ge(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Greater | Equal => true, _ => false }\n-    }\n-\n-    fn gt(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Greater => true, _ => false }\n-    }\n }\n \n impl TotalOrd for BigInt {\n-\n+    #[inline]\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);\n         if scmp != Equal { return scmp; }\n@@ -815,12 +762,12 @@ impl TotalOrd for BigInt {\n }\n \n impl ToStr for BigInt {\n-\n+    #[inline]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigInt {\n-\n+    #[inline]\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -829,69 +776,69 @@ impl FromStr for BigInt {\n impl Num for BigInt {}\n \n impl Orderable for BigInt {\n-\n+    #[inline]\n     fn min(&self, other: &BigInt) -> BigInt {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn max(&self, other: &BigInt) -> BigInt {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn clamp(&self, mn: &BigInt, mx: &BigInt) -> BigInt {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n-\n+    #[inline]\n     fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n-\n+    #[inline]\n     fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-\n+    #[inline]\n     fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n-\n+    #[inline]\n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n-\n+    #[inline]\n     fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Signed for BigInt {\n-\n+    #[inline]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n             Plus | Zero => self.clone(),\n             Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n \n-\n+    #[inline]\n     fn abs_sub(&self, other: &BigInt) -> BigInt {\n         if *self <= *other { Zero::zero() } else { *self - *other }\n     }\n \n-\n+    #[inline]\n     fn signum(&self) -> BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n@@ -900,15 +847,15 @@ impl Signed for BigInt {\n         }\n     }\n \n-\n+    #[inline]\n     fn is_positive(&self) -> bool { self.sign == Plus }\n \n-\n+    #[inline]\n     fn is_negative(&self) -> bool { self.sign == Minus }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => other.clone(),\n@@ -923,7 +870,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -941,7 +888,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -956,30 +903,30 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Div<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn div(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n-\n+    #[inline]\n     fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), self.data.clone())\n     }\n }\n \n impl Integer for BigInt {\n-\n+    #[inline]\n     fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n@@ -994,19 +941,18 @@ impl Integer for BigInt {\n         }\n     }\n \n-\n+    #[inline]\n     fn div_floor(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-\n+    #[inline]\n     fn mod_floor(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-\n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.div_rem(&other.data);\n@@ -1034,34 +980,34 @@ impl Integer for BigInt {\n      *\n      * The result is always positive\n      */\n-\n+    #[inline]\n     fn gcd(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n     }\n \n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-\n+    #[inline]\n     fn lcm(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-\n+    #[inline]\n     fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n \n     /// Returns `true` if the number is divisible by `2`\n-\n+    #[inline]\n     fn is_even(&self) -> bool { self.data.is_even() }\n \n     /// Returns `true` if the number is not divisible by `2`\n-\n+    #[inline]\n     fn is_odd(&self) -> bool { self.data.is_odd() }\n }\n \n impl IntConvertible for BigInt {\n-\n+    #[inline]\n     fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => num::min(self.to_uint(), int::max_value as uint) as int,\n@@ -1071,7 +1017,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n-\n+    #[inline]\n     fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n@@ -1086,7 +1032,7 @@ impl IntConvertible for BigInt {\n }\n \n impl ToStrRadix for BigInt {\n-\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n@@ -1098,21 +1044,21 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n-\n-    fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigInt> {\n+    #[inline]\n+    fn from_str_radix(s: &str, radix: uint) -> Option<BigInt> {\n         BigInt::parse_bytes(s.as_bytes(), radix)\n     }\n }\n \n impl BigInt {\n     /// Creates and initializes an BigInt.\n+    #[inline]\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n-\n+    #[inline]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n@@ -1121,20 +1067,19 @@ impl BigInt {\n     }\n \n     /// Creates and initializes an BigInt.\n-\n+    #[inline]\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n-\n+    #[inline]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n-\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -1148,6 +1093,7 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n+    #[inline]\n     pub fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n@@ -1221,89 +1167,78 @@ mod biguint_tests {\n \n     #[test]\n     fn test_shl() {\n-        fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert_eq!(BigUint::new(v) << shift, BigUint::new(ans));\n-        }\n-\n-        check(~[], 3, ~[]);\n-        check(~[1, 1, 1], 3, ~[1 << 3, 1 << 3, 1 << 3]);\n-        check(~[1 << (BigDigit::bits - 2)], 2, ~[0, 1]);\n-        check(~[1 << (BigDigit::bits - 2)], 3, ~[0, 2]);\n-        check(~[1 << (BigDigit::bits - 2)], 3 + BigDigit::bits, ~[0, 0, 2]);\n-\n-        test_shl_bits();\n-\n-        #[cfg(target_arch = \"x86_64\")]\n-        fn test_shl_bits() {\n-            check(~[0x7654_3210, 0xfedc_ba98,\n-                    0x7654_3210, 0xfedc_ba98], 4,\n-                  ~[0x6543_2100, 0xedcb_a987,\n-                    0x6543_210f, 0xedcb_a987, 0xf]);\n-            check(~[0x2222_1111, 0x4444_3333,\n-                    0x6666_5555, 0x8888_7777], 16,\n-                  ~[0x1111_0000, 0x3333_2222,\n-                    0x5555_4444, 0x7777_6666, 0x8888]);\n-        }\n-\n-        #[cfg(target_arch = \"arm\")]\n-        #[cfg(target_arch = \"x86\")]\n-        #[cfg(target_arch = \"mips\")]\n-        fn test_shl_bits() {\n-            check(~[0x3210, 0x7654, 0xba98, 0xfedc,\n-                    0x3210, 0x7654, 0xba98, 0xfedc], 4,\n-                  ~[0x2100, 0x6543, 0xa987, 0xedcb,\n-                    0x210f, 0x6543, 0xa987, 0xedcb, 0xf]);\n-            check(~[0x1111, 0x2222, 0x3333, 0x4444,\n-                    0x5555, 0x6666, 0x7777, 0x8888], 16,\n-                  ~[0x0000, 0x1111, 0x2222, 0x3333,\n-                    0x4444, 0x5555, 0x6666, 0x7777, 0x8888]);\n-        }\n-\n+        fn check(s: &str, shift: uint, ans: &str) {\n+            let bu = (FromStrRadix::from_str_radix::<BigUint>(s, 16).unwrap() << shift)\n+                .to_str_radix(16);\n+            assert_eq!(bu.as_slice(), ans);\n+        }\n+\n+        check(\"0\", 3, \"0\");\n+        check(\"1\", 3, \"8\");\n+\n+        check(\"1\" + \"0000\" + \"0000\" + \"0000\" + \"0001\" + \"0000\" + \"0000\" + \"0000\" + \"0001\", 3,\n+              \"8\" + \"0000\" + \"0000\" + \"0000\" + \"0008\" + \"0000\" + \"0000\" + \"0000\" + \"0008\");\n+        check(\"1\" + \"0000\" + \"0001\" + \"0000\" + \"0001\", 2,\n+              \"4\" + \"0000\" + \"0004\" + \"0000\" + \"0004\");\n+        check(\"1\" + \"0001\" + \"0001\", 1,\n+              \"2\" + \"0002\" + \"0002\");\n+\n+        check(\"\"  + \"4000\" + \"0000\" + \"0000\" + \"0000\", 3,\n+              \"2\" + \"0000\" + \"0000\" + \"0000\" + \"0000\");\n+        check(\"\"  + \"4000\" + \"0000\", 2,\n+              \"1\" + \"0000\" + \"0000\");\n+        check(\"\"  + \"4000\", 2,\n+              \"1\" + \"0000\");\n+\n+        check(\"\"  + \"4000\" + \"0000\" + \"0000\" + \"0000\", 67,\n+              \"2\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\");\n+        check(\"\"  + \"4000\" + \"0000\", 35,\n+              \"2\" + \"0000\" + \"0000\" + \"0000\" + \"0000\");\n+        check(\"\"  + \"4000\", 19,\n+              \"2\" + \"0000\" + \"0000\");\n+\n+        check(\"\"  + \"fedc\" + \"ba98\" + \"7654\" + \"3210\" + \"fedc\" + \"ba98\" + \"7654\" + \"3210\", 4,\n+              \"f\" + \"edcb\" + \"a987\" + \"6543\" + \"210f\" + \"edcb\" + \"a987\" + \"6543\" + \"2100\");\n+        check(\"88887777666655554444333322221111\", 16,\n+              \"888877776666555544443333222211110000\");\n     }\n \n     #[test]\n-    #[ignore(cfg(target_arch = \"x86\"))]\n-    #[ignore(cfg(target_arch = \"arm\"))]\n-    #[ignore(cfg(target_arch = \"mips\"))]\n     fn test_shr() {\n-        fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert_eq!(BigUint::new(v) >> shift, BigUint::new(ans));\n-        }\n-\n-        check(~[], 3, ~[]);\n-        check(~[1, 1, 1], 3,\n-              ~[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]);\n-        check(~[1 << 2], 2, ~[1]);\n-        check(~[1, 2], 3, ~[1 << (BigDigit::bits - 2)]);\n-        check(~[1, 1, 2], 3 + BigDigit::bits, ~[1 << (BigDigit::bits - 2)]);\n-        check(~[0, 1], 1, ~[0x80000000]);\n-        test_shr_bits();\n-\n-        #[cfg(target_arch = \"x86_64\")]\n-        fn test_shr_bits() {\n-            check(~[0x6543_2100, 0xedcb_a987,\n-                    0x6543_210f, 0xedcb_a987, 0xf], 4,\n-                  ~[0x7654_3210, 0xfedc_ba98,\n-                    0x7654_3210, 0xfedc_ba98]);\n-            check(~[0x1111_0000, 0x3333_2222,\n-                    0x5555_4444, 0x7777_6666, 0x8888], 16,\n-                  ~[0x2222_1111, 0x4444_3333,\n-                    0x6666_5555, 0x8888_7777]);\n-        }\n-\n-        #[cfg(target_arch = \"arm\")]\n-        #[cfg(target_arch = \"x86\")]\n-        #[cfg(target_arch = \"mips\")]\n-        fn test_shr_bits() {\n-            check(~[0x2100, 0x6543, 0xa987, 0xedcb,\n-                    0x210f, 0x6543, 0xa987, 0xedcb, 0xf], 4,\n-                  ~[0x3210, 0x7654, 0xba98, 0xfedc,\n-                    0x3210, 0x7654, 0xba98, 0xfedc]);\n-            check(~[0x0000, 0x1111, 0x2222, 0x3333,\n-                    0x4444, 0x5555, 0x6666, 0x7777, 0x8888], 16,\n-                  ~[0x1111, 0x2222, 0x3333, 0x4444,\n-                    0x5555, 0x6666, 0x7777, 0x8888]);\n-        }\n+        fn check(s: &str, shift: uint, ans: &str) {\n+            let bu = (FromStrRadix::from_str_radix::<BigUint>(s, 16).unwrap() >> shift)\n+                .to_str_radix(16);\n+            assert_eq!(bu.as_slice(), ans);\n+        }\n+\n+        check(\"0\", 3, \"0\");\n+        check(\"f\", 3, \"1\");\n+\n+        check(\"1\" + \"0000\" + \"0000\" + \"0000\" + \"0001\" + \"0000\" + \"0000\" + \"0000\" + \"0001\", 3,\n+              \"\"  + \"2000\" + \"0000\" + \"0000\" + \"0000\" + \"2000\" + \"0000\" + \"0000\" + \"0000\");\n+        check(\"1\" + \"0000\" + \"0001\" + \"0000\" + \"0001\", 2,\n+              \"\"  + \"4000\" + \"0000\" + \"4000\" + \"0000\");\n+        check(\"1\" + \"0001\" + \"0001\", 1,\n+              \"\"  + \"8000\" + \"8000\");\n+\n+        check(\"2\" + \"0000\" + \"0000\" + \"0000\" + \"0001\" + \"0000\" + \"0000\" + \"0000\" + \"0001\", 67,\n+              \"\"  + \"4000\" + \"0000\" + \"0000\" + \"0000\");\n+        check(\"2\" + \"0000\" + \"0001\" + \"0000\" + \"0001\", 35,\n+              \"\"  + \"4000\" + \"0000\");\n+        check(\"2\" + \"0001\" + \"0001\", 19,\n+              \"\"  + \"4000\");\n+\n+        check(\"1\" + \"0000\" + \"0000\" + \"0000\" + \"0000\", 1,\n+              \"\"  + \"8000\" + \"0000\" + \"0000\" + \"0000\");\n+        check(\"1\" + \"0000\" + \"0000\", 1,\n+              \"\"  + \"8000\" + \"0000\");\n+        check(\"1\" + \"0000\", 1,\n+              \"\"  + \"8000\");\n+        check(\"f\" + \"edcb\" + \"a987\" + \"6543\" + \"210f\" + \"edcb\" + \"a987\" + \"6543\" + \"2100\", 4,\n+              \"\"  + \"fedc\" + \"ba98\" + \"7654\" + \"3210\" + \"fedc\" + \"ba98\" + \"7654\" + \"3210\");\n+\n+        check(\"888877776666555544443333222211110000\", 16,\n+              \"88887777666655554444333322221111\");\n     }\n \n     #[test]\n@@ -1633,7 +1568,6 @@ mod biguint_tests {\n \n #[cfg(test)]\n mod bigint_tests {\n-\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};\n@@ -2049,3 +1983,47 @@ mod bigint_tests {\n         assert_eq!(-Zero::zero::<BigInt>(), Zero::zero::<BigInt>());\n     }\n }\n+\n+#[cfg(test)]\n+mod bench {\n+    use super::*;\n+    use std::{iterator, util};\n+    use std::num::{Zero, One};\n+    use extra::test::BenchHarness;\n+\n+    fn factorial(n: uint) -> BigUint {\n+        let mut f = One::one::<BigUint>();\n+        for i in iterator::range_inclusive(1, n) {\n+            f = f * BigUint::from_uint(i);\n+        }\n+        f\n+    }\n+\n+    fn fib(n: uint) -> BigUint {\n+        let mut f0 = Zero::zero::<BigUint>();\n+        let mut f1 = One::one::<BigUint>();\n+        for _ in range(0, n) {\n+            let f2 = f0 + f1;\n+            f0 = util::replace(&mut f1, f2);\n+        }\n+        f0\n+    }\n+\n+    #[bench]\n+    fn factorial_100(bh: &mut BenchHarness) {\n+        do bh.iter { factorial(100);  }\n+    }\n+\n+    #[bench]\n+    fn fib_100(bh: &mut BenchHarness) {\n+        do bh.iter { fib(100); }\n+    }\n+\n+    #[bench]\n+    fn to_str(bh: &mut BenchHarness) {\n+        let fac = factorial(100);\n+        let fib = fib(100);\n+        do bh.iter { fac.to_str(); }\n+        do bh.iter { fib.to_str(); }\n+    }\n+}"}]}