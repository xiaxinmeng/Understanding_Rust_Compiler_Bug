{"sha": "6d1c6124f6c48af2d713a2004376c21c054fda0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMWM2MTI0ZjZjNDhhZjJkNzEzYTIwMDQzNzZjMjFjMDU0ZmRhMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-10T12:56:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-10T12:56:55Z"}, "message": "auto merge of #13436 : pongad/rust/lazyemit, r=thestinger\n\nFixes #11926", "tree": {"sha": "2eb386f2bd35640c35243a7161fdd5d2ec86f7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eb386f2bd35640c35243a7161fdd5d2ec86f7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d1c6124f6c48af2d713a2004376c21c054fda0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d1c6124f6c48af2d713a2004376c21c054fda0b", "html_url": "https://github.com/rust-lang/rust/commit/6d1c6124f6c48af2d713a2004376c21c054fda0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d1c6124f6c48af2d713a2004376c21c054fda0b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1", "html_url": "https://github.com/rust-lang/rust/commit/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1"}, {"sha": "a00be50e00bc244569cb8d660f96abdde10dc6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/a00be50e00bc244569cb8d660f96abdde10dc6ef", "html_url": "https://github.com/rust-lang/rust/commit/a00be50e00bc244569cb8d660f96abdde10dc6ef"}], "stats": {"total": 365, "additions": 189, "deletions": 176}, "files": [{"sha": "69155f3df8ea0ea3edce7d86cb7319d4877aa2b7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 164, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6d1c6124f6c48af2d713a2004376c21c054fda0b", "patch": "@@ -977,7 +977,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n         X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n-    let memcpy = ccx.intrinsics.get_copy(&key);\n+    let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n     let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n@@ -1022,7 +1022,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n         X86_64 => \"llvm.memset.p0i8.i64\"\n     };\n \n-    let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n+    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n     let llzeroval = C_u8(ccx, 0);\n     let size = machine::llsize_of(ccx, ty);\n@@ -2043,168 +2043,6 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-\n-pub fn declare_intrinsics(ccx: &mut CrateContext) {\n-    macro_rules! ifn (\n-        ($name:expr fn() -> $ret:expr) => ({\n-            let name = $name;\n-            // HACK(eddyb) dummy output type, shouln't affect anything.\n-            let f = decl_cdecl_fn(ccx.llmod, name, Type::func([], &$ret), ty::mk_nil());\n-            ccx.intrinsics.insert(name, f);\n-        });\n-        ($name:expr fn($($arg:expr),*) -> $ret:expr) => ({\n-            let name = $name;\n-            // HACK(eddyb) dummy output type, shouln't affect anything.\n-            let f = decl_cdecl_fn(ccx.llmod, name,\n-                                  Type::func([$($arg),*], &$ret), ty::mk_nil());\n-            ccx.intrinsics.insert(name, f);\n-        })\n-    )\n-    macro_rules! mk_struct (\n-        ($($field_ty:expr),*) => (Type::struct_(ccx, [$($field_ty),*], false))\n-    )\n-\n-    let i8p = Type::i8p(ccx);\n-    let void = Type::void(ccx);\n-    let i1 = Type::i1(ccx);\n-    let t_i8 = Type::i8(ccx);\n-    let t_i16 = Type::i16(ccx);\n-    let t_i32 = Type::i32(ccx);\n-    let t_i64 = Type::i64(ccx);\n-    let t_f32 = Type::f32(ccx);\n-    let t_f64 = Type::f64(ccx);\n-\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i32\" fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i64\" fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n-\n-    ifn!(\"llvm.trap\" fn() -> void);\n-    ifn!(\"llvm.debugtrap\" fn() -> void);\n-    ifn!(\"llvm.frameaddress\" fn(t_i32) -> i8p);\n-\n-    ifn!(\"llvm.powi.f32\" fn(t_f32, t_i32) -> t_f32);\n-    ifn!(\"llvm.powi.f64\" fn(t_f64, t_i32) -> t_f64);\n-    ifn!(\"llvm.pow.f32\" fn(t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.pow.f64\" fn(t_f64, t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.sqrt.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sqrt.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.sin.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sin.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.cos.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.cos.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp2.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp2.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log10.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log10.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log2.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log2.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.fma.f32\" fn(t_f32, t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.fma.f64\" fn(t_f64, t_f64, t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.fabs.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.fabs.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.floor.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.floor.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.ceil.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.ceil.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.trunc.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.trunc.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.rint.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.rint.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.nearbyint.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.nearbyint.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.ctpop.i8\" fn(t_i8) -> t_i8);\n-    ifn!(\"llvm.ctpop.i16\" fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.ctpop.i32\" fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.ctpop.i64\" fn(t_i64) -> t_i64);\n-\n-    ifn!(\"llvm.ctlz.i8\" fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.ctlz.i16\" fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.ctlz.i32\" fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.ctlz.i64\" fn(t_i64, i1) -> t_i64);\n-\n-    ifn!(\"llvm.cttz.i8\" fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.cttz.i16\" fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.cttz.i32\" fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.cttz.i64\" fn(t_i64, i1) -> t_i64);\n-\n-    ifn!(\"llvm.bswap.i16\" fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.bswap.i32\" fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.bswap.i64\" fn(t_i64) -> t_i64);\n-\n-    ifn!(\"llvm.sadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.uadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.ssub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.usub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.usub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.usub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.usub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.smul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.smul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.smul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.smul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.umul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.umul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.umul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.umul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.expect.i1\" fn(i1, i1) -> i1);\n-\n-    // Some intrinsics were introduced in later versions of LLVM, but they have\n-    // fallbacks in libc or libm and such. Currently, all of these intrinsics\n-    // were introduced in LLVM 3.4, so we case on that.\n-    macro_rules! compatible_ifn (\n-        ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => ({\n-            let name = $name;\n-            if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n-                ifn!(name fn($($arg),*) -> $ret);\n-            } else {\n-                let f = decl_cdecl_fn(ccx.llmod, stringify!($cname),\n-                                      Type::func([$($arg),*], &$ret),\n-                                      ty::mk_nil());\n-                ccx.intrinsics.insert(name, f);\n-            }\n-        })\n-    )\n-\n-    compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n-    compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);\n-    compatible_ifn!(\"llvm.round.f32\", roundf(t_f32) -> t_f32);\n-    compatible_ifn!(\"llvm.round.f64\", round(t_f64) -> t_f64);\n-\n-\n-    if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        ifn!(\"llvm.dbg.declare\" fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n-        ifn!(\"llvm.dbg.value\" fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n-    }\n-}\n-\n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n "}, {"sha": "4aad1cded1ea4786991dea200b0d8d5afbcb8a4f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 179, "deletions": 4, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6d1c6124f6c48af2d713a2004376c21c054fda0b", "patch": "@@ -41,7 +41,6 @@ pub struct CrateContext {\n     pub td: TargetData,\n     pub tn: TypeNames,\n     pub externs: RefCell<ExternMap>,\n-    pub intrinsics: HashMap<&'static str, ValueRef>,\n     pub item_vals: RefCell<NodeMap<ValueRef>>,\n     pub exp_map2: resolve::ExportMap2,\n     pub reachable: NodeSet,\n@@ -107,6 +106,8 @@ pub struct CrateContext {\n     /// is not emitted by LLVM's GC pass when no functions use GC.\n     pub uses_gc: bool,\n     pub dbg_cx: Option<debuginfo::CrateDebugContext>,\n+\n+    intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n }\n \n impl CrateContext {\n@@ -150,7 +151,6 @@ impl CrateContext {\n                 td: td,\n                 tn: TypeNames::new(),\n                 externs: RefCell::new(HashMap::new()),\n-                intrinsics: HashMap::new(),\n                 item_vals: RefCell::new(NodeMap::new()),\n                 exp_map2: emap2,\n                 reachable: reachable,\n@@ -197,6 +197,7 @@ impl CrateContext {\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 uses_gc: false,\n                 dbg_cx: dbg_cx,\n+                intrinsics: RefCell::new(HashMap::new()),\n             };\n \n             ccx.int_type = Type::int(&ccx);\n@@ -208,8 +209,6 @@ impl CrateContext {\n             str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type], false);\n             ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-            base::declare_intrinsics(&mut ccx);\n-\n             if ccx.sess().count_llvm_insns() {\n                 base::init_insn_ctxt()\n             }\n@@ -233,4 +232,180 @@ impl CrateContext {\n     pub fn tydesc_type(&self) -> Type {\n         self.tn.find_type(\"tydesc\").unwrap()\n     }\n+\n+    pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n+        match self.intrinsics.borrow().find_copy(key) {\n+            Some(v) => return v,\n+            _ => {}\n+        }\n+        match declare_intrinsic(self, key) {\n+            Some(v) => return v,\n+            None => fail!()\n+        }\n+    }\n+}\n+\n+fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n+    macro_rules! ifn (\n+        ($name:expr fn() -> $ret:expr) => (\n+            if *key == $name {\n+                let f = base::decl_cdecl_fn(ccx.llmod, $name, Type::func([], &$ret), ty::mk_nil());\n+                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                return Some(f);\n+            }\n+        );\n+        ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n+            if *key == $name {\n+                let f = base::decl_cdecl_fn(ccx.llmod, $name,\n+                                  Type::func([$($arg),*], &$ret), ty::mk_nil());\n+                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                return Some(f);\n+            }\n+        )\n+    )\n+    macro_rules! mk_struct (\n+        ($($field_ty:expr),*) => (Type::struct_(ccx, [$($field_ty),*], false))\n+    )\n+\n+    let i8p = Type::i8p(ccx);\n+    let void = Type::void(ccx);\n+    let i1 = Type::i1(ccx);\n+    let t_i8 = Type::i8(ccx);\n+    let t_i16 = Type::i16(ccx);\n+    let t_i32 = Type::i32(ccx);\n+    let t_i64 = Type::i64(ccx);\n+    let t_f32 = Type::f32(ccx);\n+    let t_f64 = Type::f64(ccx);\n+\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i32\" fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i64\" fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n+\n+    ifn!(\"llvm.trap\" fn() -> void);\n+    ifn!(\"llvm.debugtrap\" fn() -> void);\n+    ifn!(\"llvm.frameaddress\" fn(t_i32) -> i8p);\n+\n+    ifn!(\"llvm.powi.f32\" fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.f64\" fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.pow.f32\" fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.f64\" fn(t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.sqrt.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fma.f32\" fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.f64\" fn(t_f64, t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fabs.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.floor.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.trunc.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.trunc.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.rint.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.rint.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.nearbyint.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.nearbyint.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.ctpop.i8\" fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.ctpop.i16\" fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.ctpop.i32\" fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.ctpop.i64\" fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.ctlz.i8\" fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.ctlz.i16\" fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.ctlz.i32\" fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.ctlz.i64\" fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.cttz.i8\" fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.cttz.i16\" fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.cttz.i32\" fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.cttz.i64\" fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.bswap.i16\" fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bswap.i32\" fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bswap.i64\" fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.sadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.uadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.ssub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.usub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.usub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.usub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.usub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.smul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.smul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.smul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.smul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.umul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.umul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.umul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.umul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.expect.i1\" fn(i1, i1) -> i1);\n+\n+    // Some intrinsics were introduced in later versions of LLVM, but they have\n+    // fallbacks in libc or libm and such. Currently, all of these intrinsics\n+    // were introduced in LLVM 3.4, so we case on that.\n+    macro_rules! compatible_ifn (\n+        ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n+            if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n+                // The `if key == $name` is already in ifn!\n+                ifn!($name fn($($arg),*) -> $ret);\n+            } else if *key == $name {\n+                let f = base::decl_cdecl_fn(ccx.llmod, stringify!($cname),\n+                                      Type::func([$($arg),*], &$ret),\n+                                      ty::mk_nil());\n+                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                return Some(f);\n+            }\n+        )\n+    )\n+\n+    compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n+    compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);\n+    compatible_ifn!(\"llvm.round.f32\", roundf(t_f32) -> t_f32);\n+    compatible_ifn!(\"llvm.round.f64\", round(t_f64) -> t_f64);\n+\n+\n+    if ccx.sess().opts.debuginfo != NoDebugInfo {\n+        ifn!(\"llvm.dbg.declare\" fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.value\" fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+    }\n+    return None;\n }"}, {"sha": "c12c8c106cb4f5470e5cef2456a20132f180ca66", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=6d1c6124f6c48af2d713a2004376c21c054fda0b", "patch": "@@ -513,7 +513,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n-    let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n+    let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n     let expected = Call(bcx, expect, [bounds_check, C_i1(ccx, false)], []);\n     let bcx = with_cond(bcx, expected, |bcx| {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)"}, {"sha": "6f4b115ad86e5f196b2fea365010c446eebda735", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d1c6124f6c48af2d713a2004376c21c054fda0b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=6d1c6124f6c48af2d713a2004376c21c054fda0b", "patch": "@@ -79,7 +79,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n         \"bswap64\" => \"llvm.bswap.i64\",\n         _ => return None\n     };\n-    Some(ccx.intrinsics.get_copy(&name))\n+    Some(ccx.get_intrinsic(&name))\n }\n \n pub fn trans_intrinsic(ccx: &CrateContext,\n@@ -93,7 +93,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let a = get_param(bcx.fcx.llfn, first_real_arg);\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        let llfn = bcx.ccx().get_intrinsic(&name);\n \n         // convert `i1` to a `bool`, and write to the out parameter\n         let val = Call(bcx, llfn, [a, b], []);\n@@ -155,7 +155,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p(ccx));\n         let count = get_param(decl, first_real_arg + 2);\n         let volatile = C_i1(ccx, false);\n-        let llfn = ccx.intrinsics.get_copy(&name);\n+        let llfn = ccx.get_intrinsic(&name);\n         Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n@@ -177,15 +177,15 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let val = get_param(decl, first_real_arg + 1);\n         let count = get_param(decl, first_real_arg + 2);\n         let volatile = C_i1(ccx, false);\n-        let llfn = ccx.intrinsics.get_copy(&name);\n+        let llfn = ccx.get_intrinsic(&name);\n         Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n     fn count_zeros_intrinsic(bcx: &Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(bcx.ccx(), false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        let llfn = bcx.ccx().get_intrinsic(&name);\n         let llcall = Call(bcx, llfn, [x, y], []);\n         Ret(bcx, llcall);\n     }\n@@ -274,12 +274,12 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n     match name.get() {\n         \"abort\" => {\n-            let llfn = bcx.ccx().intrinsics.get_copy(&(\"llvm.trap\"));\n+            let llfn = bcx.ccx().get_intrinsic(&(\"llvm.trap\"));\n             Call(bcx, llfn, [], []);\n             Unreachable(bcx);\n         }\n         \"breakpoint\" => {\n-            let llfn = bcx.ccx().intrinsics.get_copy(&(\"llvm.debugtrap\"));\n+            let llfn = bcx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n             Call(bcx, llfn, [], []);\n             RetVoid(bcx);\n         }"}]}