{"sha": "449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0OWViZWVhMDhhM2UwYzUwYjM0ODdiYzZkNTYxZjQ5Y2FmNTdiN2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-28T00:09:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:58Z"}, "message": "librustc: De-`@mut` the AST map", "tree": {"sha": "3898e84510f8eebf2fa15e5fe815d5dee52afc2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3898e84510f8eebf2fa15e5fe815d5dee52afc2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "html_url": "https://github.com/rust-lang/rust/commit/449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12ad1b0662aed1f2f1b23d6c4a0a2cf43c92200a", "url": "https://api.github.com/repos/rust-lang/rust/commits/12ad1b0662aed1f2f1b23d6c4a0a2cf43c92200a", "html_url": "https://github.com/rust-lang/rust/commit/12ad1b0662aed1f2f1b23d6c4a0a2cf43c92200a"}], "stats": {"total": 792, "additions": 471, "deletions": 321}, "files": [{"sha": "4592b88a0fa083fc51a7a8dc2637152b0e0ee265", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -489,7 +489,8 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::path_elt],\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.items.find(&exp.def_id.node) {\n+    let items = ecx.tcx.items.borrow();\n+    match items.get().find(&exp.def_id.node) {\n         Some(&ast_map::node_item(item, path)) => {\n             let original_name = ecx.tcx.sess.str_of(item.ident);\n \n@@ -1338,7 +1339,8 @@ fn my_visit_item(i: @item,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n                  index: @RefCell<~[entry<i64>]>) {\n-    match items.get_copy(&i.id) {\n+    let items = items.borrow();\n+    match items.get().get_copy(&i.id) {\n         ast_map::node_item(_, pt) => {\n             let mut ebml_w = unsafe {\n                 ebml_w.unsafe_clone()\n@@ -1356,7 +1358,8 @@ fn my_visit_foreign_item(ni: @foreign_item,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n                          index: @RefCell<~[entry<i64>]>) {\n-    match items.get_copy(&ni.id) {\n+    let items = items.borrow();\n+    match items.get().get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str("}, {"sha": "44b967aade6773cb950a79df3b3723540ca06cea", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -788,7 +788,8 @@ impl BorrowckCtxt {\n                                    out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n-                match self.tcx.items.find(&id) {\n+                let items = self.tcx.items.borrow();\n+                match items.get().find(&id) {\n                     Some(&ast_map::node_local(ref ident)) => {\n                         out.push_str(token::ident_to_str(ident));\n                     }"}, {"sha": "a6a51e9508351862557c59d7e9c96ed942012a1e", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -266,13 +266,15 @@ impl Visitor<()> for CheckItemRecursionVisitor {\n                 let def_map = self.env.def_map.borrow();\n                 match def_map.get().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n-                            ast_util::is_local(def_id) =>\n-                        match self.env.ast_map.get_copy(&def_id.node) {\n+                            ast_util::is_local(def_id) => {\n+                        let ast_map = self.env.ast_map.borrow();\n+                        match ast_map.get().get_copy(&def_id.node) {\n                             ast_map::node_item(it, _) => {\n                                 self.visit_item(it, ());\n                             }\n                             _ => fail!(\"const not bound to an item\")\n-                        },\n+                        }\n+                    }\n                     _ => ()\n                 }\n             },"}, {"sha": "b9b0b807e6ed9ff03ff398eb76e98eaa1ed3de94", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -107,15 +107,18 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n     }\n \n     if ast_util::is_local(enum_def) {\n-        match tcx.items.find(&enum_def.node) {\n-            None => None,\n-            Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_enum(ast::enum_def { variants: ref variants }, _) => {\n-                    variant_expr(*variants, variant_def.node)\n-                }\n-                _ => None\n-            },\n-            Some(_) => None\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&enum_def.node) {\n+                None => None,\n+                Some(&ast_map::node_item(it, _)) => match it.node {\n+                    item_enum(ast::enum_def { variants: ref variants }, _) => {\n+                        variant_expr(*variants, variant_def.node)\n+                    }\n+                    _ => None\n+                },\n+                Some(_) => None\n+            }\n         }\n     } else {\n         {\n@@ -155,17 +158,21 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_const_by_id(tcx: ty::ctxt,\n-                          def_id: ast::DefId)\n-                       -> Option<@Expr> {\n+pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n+                          -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n-        match tcx.items.find(&def_id.node) {\n-            None => None,\n-            Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_static(_, ast::MutImmutable, const_expr) => Some(const_expr),\n-                _ => None\n-            },\n-            Some(_) => None\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&def_id.node) {\n+                None => None,\n+                Some(&ast_map::node_item(it, _)) => match it.node {\n+                    item_static(_, ast::MutImmutable, const_expr) => {\n+                        Some(const_expr)\n+                    }\n+                    _ => None\n+                },\n+                Some(_) => None\n+            }\n         }\n     } else {\n         {"}, {"sha": "2bdbce9b763c567a022e06f77e160886eca25e2c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -34,7 +34,9 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n     if !is_local(def_id) {\n         return false;\n     }\n-    match tcx.items.find(&def_id.node) {\n+\n+    let items = tcx.items.borrow();\n+    match items.get().find(&def_id.node) {\n         Some(&ast_map::node_item(..))\n         | Some(&ast_map::node_method(..))\n         | Some(&ast_map::node_foreign_item(..))\n@@ -130,7 +132,9 @@ impl MarkSymbolVisitor {\n                 continue\n             }\n             scanned.insert(id);\n-            match self.tcx.items.find(&id) {\n+\n+            let items = self.tcx.items.borrow();\n+            match items.get().find(&id) {\n                 Some(node) => {\n                     self.live_symbols.insert(id);\n                     self.visit_node(node);"}, {"sha": "89cb902cf1064c6c14ce15e99f1101e334e85efe", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -74,23 +74,26 @@ fn find_item(item: @item, ctxt: &mut EntryContext) {\n     match item.node {\n         item_fn(..) => {\n             if item.ident.name == special_idents::main.name {\n-                match ctxt.ast_map.find(&item.id) {\n-                    Some(&ast_map::node_item(_, path)) => {\n-                        if path.len() == 0 {\n-                            // This is a top-level function so can be 'main'\n-                            if ctxt.main_fn.is_none() {\n-                                ctxt.main_fn = Some((item.id, item.span));\n+                {\n+                    let ast_map = ctxt.ast_map.borrow();\n+                    match ast_map.get().find(&item.id) {\n+                        Some(&ast_map::node_item(_, path)) => {\n+                            if path.len() == 0 {\n+                                // This is a top-level function so can be 'main'\n+                                if ctxt.main_fn.is_none() {\n+                                    ctxt.main_fn = Some((item.id, item.span));\n+                                } else {\n+                                    ctxt.session.span_err(\n+                                        item.span,\n+                                        \"multiple 'main' functions\");\n+                                }\n                             } else {\n-                                ctxt.session.span_err(\n-                                    item.span,\n-                                    \"multiple 'main' functions\");\n+                                // This isn't main\n+                                ctxt.non_main_fns.push((item.id, item.span));\n                             }\n-                        } else {\n-                            // This isn't main\n-                            ctxt.non_main_fns.push((item.id, item.span));\n                         }\n+                        _ => unreachable!()\n                     }\n-                    _ => unreachable!()\n                 }\n             }\n "}, {"sha": "7503419f8b68876360768e9bd47ca1fc6183113e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -1238,7 +1238,8 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n     let stability = if ast_util::is_local(id) {\n         // this crate\n-        match cx.tcx.items.find(&id.node) {\n+        let items = cx.tcx.items.borrow();\n+        match items.get().find(&id.node) {\n             Some(ast_node) => {\n                 let s = ast_node.with_attrs(|attrs| {\n                     attrs.map(|a| {"}, {"sha": "435bdcc260747da1a660a48603358eaa5d983ae1", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -413,7 +413,8 @@ impl<'a> PrivacyVisitor<'a> {\n         let mut closest_private_id = did.node;\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let vis = match self.tcx.items.find(&closest_private_id) {\n+            let items = self.tcx.items.borrow();\n+            let vis = match items.get().find(&closest_private_id) {\n                 // If this item is a method, then we know for sure that it's an\n                 // actual method and not a static method. The reason for this is\n                 // that these cases are only hit in the ExprMethodCall\n@@ -519,7 +520,8 @@ impl<'a> PrivacyVisitor<'a> {\n                     self.tcx.sess.span_err(span, format!(\"{} is inaccessible\",\n                                                          msg));\n                 }\n-                match self.tcx.items.find(&id) {\n+                let items = self.tcx.items.borrow();\n+                match items.get().find(&id) {\n                     Some(&ast_map::node_item(item, _)) => {\n                         let desc = match item.node {\n                             ast::item_mod(..) => \"module\","}, {"sha": "5e50017b93edda7478c5ddd7da08f81396ab61f2", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -65,10 +65,15 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n         return true\n     }\n     if is_local(impl_src) {\n-        match tcx.items.find(&impl_src.node) {\n-            Some(&ast_map::node_item(item, _)) => item_might_be_inlined(item),\n-            Some(..) | None => {\n-                tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&impl_src.node) {\n+                Some(&ast_map::node_item(item, _)) => {\n+                    item_might_be_inlined(item)\n+                }\n+                Some(..) | None => {\n+                    tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+                }\n             }\n         }\n     } else {\n@@ -208,7 +213,8 @@ impl ReachableContext {\n         }\n \n         let node_id = def_id.node;\n-        match tcx.items.find(&node_id) {\n+        let items = tcx.items.borrow();\n+        match items.get().find(&node_id) {\n             Some(&ast_map::node_item(item, _)) => {\n                 match item.node {\n                     ast::item_fn(..) => item_might_be_inlined(item),\n@@ -229,7 +235,7 @@ impl ReachableContext {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.crate == ast::LOCAL_CRATE);\n-                    match tcx.items.find(&impl_did.node) {\n+                    match items.get().find(&impl_did.node) {\n                         Some(&ast_map::node_item(item, _)) => {\n                             match item.node {\n                                 ast::item_impl(ref generics, _, _, _) => {\n@@ -288,7 +294,8 @@ impl ReachableContext {\n             };\n \n             scanned.insert(search_item);\n-            match self.tcx.items.find(&search_item) {\n+            let items = self.tcx.items.borrow();\n+            match items.get().find(&search_item) {\n                 Some(item) => self.propagate_node(item, search_item,\n                                                   &mut visitor),\n                 None if search_item == ast::CRATE_NODE_ID => {}"}, {"sha": "59f6fede198c8250efcea18baae9b7dd704b9f57", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -2210,10 +2210,13 @@ impl Visitor<()> for TransItemVisitor {\n \n pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = push_ctxt(\"trans_item\");\n-    let path = match ccx.tcx.items.get_copy(&item.id) {\n-        ast_map::node_item(_, p) => p,\n-        // tjc: ?\n-        _ => fail!(\"trans_item\"),\n+    let path = {\n+        let items = ccx.tcx.items.borrow();\n+        match items.get().get_copy(&item.id) {\n+            ast_map::node_item(_, p) => p,\n+            // tjc: ?\n+            _ => fail!(\"trans_item\"),\n+        }\n     };\n     match item.node {\n       ast::item_fn(decl, purity, _abis, ref generics, body) => {\n@@ -2508,7 +2511,10 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n         Some(v) => v,\n         None => {\n             let mut foreign = false;\n-            let item = ccx.tcx.items.get_copy(&id);\n+            let item = {\n+                let items = ccx.tcx.items.borrow();\n+                items.get().get_copy(&id)\n+            };\n             let val = match item {\n                 ast_map::node_item(i, pth) => {\n "}, {"sha": "05b3e8275a3a49f4b9a0c2e703180f2d3aa2aabf", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -360,17 +360,20 @@ pub fn trans_fn_ref_with_vtables(\n     if type_params.len() > 0 || is_default {\n         must_monomorphise = true;\n     } else if def_id.crate == ast::LOCAL_CRATE {\n-        let map_node = session::expect(\n-            ccx.sess,\n-            ccx.tcx.items.find(&def_id.node),\n-            || format!(\"local item should be in ast map\"));\n-\n-        match *map_node {\n-            ast_map::node_foreign_item(_, abis, _, _) => {\n-                must_monomorphise = abis.is_intrinsic()\n-            }\n-            _ => {\n-                must_monomorphise = false;\n+        {\n+            let items = ccx.tcx.items.borrow();\n+            let map_node = session::expect(\n+                ccx.sess,\n+                items.get().find(&def_id.node),\n+                || format!(\"local item should be in ast map\"));\n+\n+            match *map_node {\n+                ast_map::node_foreign_item(_, abis, _, _) => {\n+                    must_monomorphise = abis.is_intrinsic()\n+                }\n+                _ => {\n+                    must_monomorphise = false;\n+                }\n             }\n         }\n     } else {"}, {"sha": "0dd8b841bcf427a2df9e31a95425e42fe3e3681a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -165,7 +165,13 @@ pub fn get_const_val(cx: @CrateContext,\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n-        match cx.tcx.items.get_copy(&def_id.node) {\n+\n+        let opt_item = {\n+            let items = cx.tcx.items.borrow();\n+            items.get().get_copy(&def_id.node)\n+        };\n+\n+        match opt_item {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_static(_, ast::MutImmutable, _), ..\n             }, _) => {"}, {"sha": "3170a290a41f4726997b484fb438515114dc8bf2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -323,7 +323,10 @@ pub fn create_captured_var_metadata(bcx: @Block,\n \n     let cx = bcx.ccx();\n \n-    let ast_item = cx.tcx.items.find_copy(&node_id);\n+    let ast_item = {\n+        let items = cx.tcx.items.borrow();\n+        items.get().find_copy(&node_id)\n+    };\n     let variable_ident = match ast_item {\n         None => {\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n@@ -422,7 +425,10 @@ pub fn create_self_argument_metadata(bcx: @Block,\n     }\n \n     // Extract the span of the self argument from the method's AST\n-    let fnitem = bcx.ccx().tcx.items.get_copy(&bcx.fcx.id);\n+    let fnitem = {\n+        let items = bcx.ccx().tcx.items.borrow();\n+        items.get().get_copy(&bcx.fcx.id)\n+    };\n     let span = match fnitem {\n         ast_map::node_method(@ast::method { explicit_self: explicit_self, .. }, _, _) => {\n             explicit_self.span\n@@ -609,7 +615,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n-    let fnitem = cx.tcx.items.get_copy(&fn_ast_id);\n+    let fnitem = {\n+        let items = cx.tcx.items.borrow();\n+        items.get().get_copy(&fn_ast_id)\n+    };\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n@@ -1092,7 +1101,8 @@ fn scope_metadata(fcx: &FunctionContext,\n     match scope_map.get().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n-            let node = fcx.ccx.tcx.items.get_copy(&node_id);\n+            let items = fcx.ccx.tcx.items.borrow();\n+            let node = items.get().get_copy(&node_id);\n \n             fcx.ccx.sess.span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n@@ -1411,13 +1421,17 @@ fn describe_enum_variant(cx: &CrateContext,\n \n     // Find the source code location of the variant's definition\n     let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n-        match cx.tcx.items.find(&variant_info.id.node) {\n-            Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n-            ref node => {\n-                cx.sess.span_warn(span,\n-                    format!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n-                          type: {:?}. This is a bug.\", node));\n-                codemap::DUMMY_SP\n+        {\n+            let items = cx.tcx.items.borrow();\n+            match items.get().find(&variant_info.id.node) {\n+                Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n+                ref node => {\n+                    cx.sess.span_warn(span,\n+                        format!(\"debuginfo::enum_metadata()::\\\n+                                 adt_struct_metadata() - Unexpected node \\\n+                                 type: {:?}. This is a bug.\", node));\n+                    codemap::DUMMY_SP\n+                }\n             }\n         }\n     } else {\n@@ -2296,16 +2310,20 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n                                 -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n     let definition_span = if def_id.crate == ast::LOCAL_CRATE {\n-        let definition_span = match cx.tcx.items.find(&def_id.node) {\n-            Some(&ast_map::node_item(@ast::item { span, .. }, _)) => span,\n-            ref node => {\n-                cx.sess.span_warn(warning_span,\n-                    format!(\"debuginfo::get_namespace_and_span_for_item() \\\n-                             - Unexpected node type: {:?}\", *node));\n-                codemap::DUMMY_SP\n-            }\n-        };\n-        definition_span\n+        {\n+            let items = cx.tcx.items.borrow();\n+            let definition_span = match items.get().find(&def_id.node) {\n+                Some(&ast_map::node_item(@ast::item { span, .. }, _)) => span,\n+                ref node => {\n+                    cx.sess.span_warn(warning_span,\n+                        format!(\"debuginfo::\\\n+                                 get_namespace_and_span_for_item() \\\n+                                 - Unexpected node type: {:?}\", *node));\n+                    codemap::DUMMY_SP\n+                }\n+            };\n+            definition_span\n+        }\n     } else {\n         // For external items there is no span information\n         codemap::DUMMY_SP"}, {"sha": "7c4c9f8937f05b0497f675989d50f1afb69958fd", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -355,10 +355,17 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::foreign_item_fn(..) => {\n-                let (abis, mut path) = match ccx.tcx.items.get_copy(&foreign_item.id) {\n-                    ast_map::node_foreign_item(_, abis, _, path) => (abis, (*path).clone()),\n-                    _ => fail!(\"Unable to find foreign item in tcx.items table.\")\n-                };\n+                let items = ccx.tcx.items.borrow();\n+                let (abis, mut path) =\n+                    match items.get().get_copy(&foreign_item.id) {\n+                        ast_map::node_foreign_item(_, abis, _, path) => {\n+                            (abis, (*path).clone())\n+                        }\n+                        _ => {\n+                            fail!(\"Unable to find foreign item in tcx.items \\\n+                                   table.\")\n+                        }\n+                    };\n                 if !(abis.is_rust() || abis.is_intrinsic()) {\n                     path.push(ast_map::path_name(foreign_item.ident));\n                     register_foreign_item_fn(ccx, abis, &path, foreign_item);"}, {"sha": "c1096f7332235d84f9c792f8ed644895f2971c64", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -346,9 +346,12 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n-                    ast_map::node_expr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n+                let sp = {\n+                    let items = ccx.tcx.items.borrow();\n+                    match items.get().get_copy(&ref_id.unwrap()) {\n+                        ast_map::node_expr(e) => e.span,\n+                        _ => fail!(\"transmute has non-expr arg\"),\n+                    }\n                 };\n                 let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,"}, {"sha": "d54dd23af96a68bd0ca68ce130a5d55dd17bb2ff", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -246,11 +246,14 @@ pub fn trans_static_method_callee(bcx: @Block,\n         generics.type_param_defs.len();\n \n     let mname = if method_id.crate == ast::LOCAL_CRATE {\n-        match bcx.tcx().items.get_copy(&method_id.node) {\n-            ast_map::node_trait_method(trait_method, _, _) => {\n-                ast_util::trait_method_to_ty_method(trait_method).ident\n+        {\n+            let items = bcx.tcx().items.borrow();\n+            match items.get().get_copy(&method_id.node) {\n+                ast_map::node_trait_method(trait_method, _, _) => {\n+                    ast_util::trait_method_to_ty_method(trait_method).ident\n+                }\n+                _ => fail!(\"callee is not a trait method\")\n             }\n-            _ => fail!(\"callee is not a trait method\")\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);"}, {"sha": "a60ddc9d8b61fc494ebbbefc0c559a092fdd8915", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -95,12 +95,16 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     // calling a static provided method. This is sort of unfortunate.\n     let mut is_static_provided = None;\n \n-    let map_node = session::expect(\n-        ccx.sess,\n-        ccx.tcx.items.find_copy(&fn_id.node),\n-        || format!(\"While monomorphizing {:?}, couldn't find it in the item map \\\n-                 (may have attempted to monomorphize an item \\\n-                 defined in a different crate?)\", fn_id));\n+    let map_node = {\n+        let items = ccx.tcx.items.borrow();\n+        session::expect(\n+            ccx.sess,\n+            items.get().find_copy(&fn_id.node),\n+            || format!(\"While monomorphizing {:?}, couldn't find it in the \\\n+                        item map (may have attempted to monomorphize an item \\\n+                        defined in a different crate?)\", fn_id))\n+    };\n+\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),"}, {"sha": "7abc2a34a1f7d38118cdb0b3aac0eb2d7854140b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 150, "deletions": 131, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -3556,16 +3556,19 @@ pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     if is_local(id) {\n-        match cx.items.find(&id.node) {\n-            Some(&ast_map::node_item(@ast::item {\n-                        node: item_trait(_, _, ref ms),\n-                        ..\n-                    }, _)) =>\n-                match ast_util::split_trait_methods(*ms) {\n-                   (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n-                },\n-            _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n-                                  id))\n+        {\n+            let items = cx.items.borrow();\n+            match items.get().find(&id.node) {\n+                Some(&ast_map::node_item(@ast::item {\n+                            node: item_trait(_, _, ref ms),\n+                            ..\n+                        }, _)) =>\n+                    match ast_util::split_trait_methods(*ms) {\n+                       (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n+                    },\n+                _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n+                                      id))\n+            }\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)\n@@ -3675,17 +3678,20 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n \n     let ret = if id.crate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-        match cx.items.find(&id.node) {\n-            Some(&ast_map::node_item(@ast::item {\n-                                     node: ast::item_impl(_, ref opt_trait, _, _),\n-                                     ..},\n-                                     _)) => {\n-                match opt_trait {\n-                    &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                    &None => None\n+        {\n+            let items = cx.items.borrow();\n+            match items.get().find(&id.node) {\n+                Some(&ast_map::node_item(@ast::item {\n+                     node: ast::item_impl(_, ref opt_trait, _, _),\n+                     ..},\n+                     _)) => {\n+                    match opt_trait {\n+                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                        &None => None\n+                    }\n                 }\n+                _ => None\n             }\n-            _ => None\n         }\n     } else {\n         csearch::get_impl_trait(cx, id)\n@@ -3857,54 +3863,55 @@ pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n \n pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n     if id.crate != ast::LOCAL_CRATE {\n-        csearch::get_item_path(cx, id)\n-    } else {\n-        // FIXME (#5521): uncomment this code and don't have a catch-all at the\n-        //                end of the match statement. Favor explicitly listing\n-        //                each variant.\n-        // let node = cx.items.get(&id.node);\n-        // match *node {\n-        match *cx.items.get(&id.node) {\n-          ast_map::node_item(item, path) => {\n-            let item_elt = match item.node {\n-              item_mod(_) | item_foreign_mod(_) => {\n-                ast_map::path_mod(item.ident)\n-              }\n-              _ => {\n-                ast_map::path_name(item.ident)\n-              }\n-            };\n-            vec::append_one((*path).clone(), item_elt)\n+        return csearch::get_item_path(cx, id)\n+    }\n+\n+    // FIXME (#5521): uncomment this code and don't have a catch-all at the\n+    //                end of the match statement. Favor explicitly listing\n+    //                each variant.\n+    // let node = cx.items.get(&id.node);\n+    // match *node {\n+    let items = cx.items.borrow();\n+    match *items.get().get(&id.node) {\n+      ast_map::node_item(item, path) => {\n+        let item_elt = match item.node {\n+          item_mod(_) | item_foreign_mod(_) => {\n+            ast_map::path_mod(item.ident)\n           }\n-\n-          ast_map::node_foreign_item(nitem, _, _, path) => {\n-            vec::append_one((*path).clone(),\n-                            ast_map::path_name(nitem.ident))\n+          _ => {\n+            ast_map::path_name(item.ident)\n           }\n+        };\n+        vec::append_one((*path).clone(), item_elt)\n+      }\n \n-          ast_map::node_method(method, _, path) => {\n-            vec::append_one((*path).clone(),\n-                            ast_map::path_name(method.ident))\n-          }\n-          ast_map::node_trait_method(trait_method, _, path) => {\n-            let method = ast_util::trait_method_to_ty_method(&*trait_method);\n-            vec::append_one((*path).clone(),\n-                            ast_map::path_name(method.ident))\n-          }\n+      ast_map::node_foreign_item(nitem, _, _, path) => {\n+        vec::append_one((*path).clone(),\n+                        ast_map::path_name(nitem.ident))\n+      }\n \n-          ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(path.init().to_owned(),\n-                            ast_map::path_name((*variant).node.name))\n-          }\n+      ast_map::node_method(method, _, path) => {\n+        vec::append_one((*path).clone(),\n+                        ast_map::path_name(method.ident))\n+      }\n+      ast_map::node_trait_method(trait_method, _, path) => {\n+        let method = ast_util::trait_method_to_ty_method(&*trait_method);\n+        vec::append_one((*path).clone(),\n+                        ast_map::path_name(method.ident))\n+      }\n \n-          ast_map::node_struct_ctor(_, item, path) => {\n-            vec::append_one((*path).clone(), ast_map::path_name(item.ident))\n-          }\n+      ast_map::node_variant(ref variant, _, path) => {\n+        vec::append_one(path.init().to_owned(),\n+                        ast_map::path_name((*variant).node.name))\n+      }\n \n-          ref node => {\n-            cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n-          }\n-        }\n+      ast_map::node_struct_ctor(_, item, path) => {\n+        vec::append_one((*path).clone(), ast_map::path_name(item.ident))\n+      }\n+\n+      ref node => {\n+        cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n+      }\n     }\n }\n \n@@ -3936,40 +3943,43 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        match cx.items.get_copy(&id.node) {\n-          ast_map::node_item(@ast::item {\n-                    node: ast::item_enum(ref enum_definition, _),\n-                    ..\n-                }, _) => {\n-            let mut last_discriminant: Option<Disr> = None;\n-            @enum_definition.variants.iter().map(|&variant| {\n-\n-                let mut discriminant = match last_discriminant {\n-                    Some(val) => val + 1,\n-                    None => INITIAL_DISCRIMINANT_VALUE\n-                };\n-\n-                match variant.node.disr_expr {\n-                    Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n-                        Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n-                        Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n-                        Ok(_) => {\n-                            cx.sess.span_err(e.span, \"expected signed integer constant\");\n-                        }\n-                        Err(ref err) => {\n-                            cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n-                        }\n-                    },\n-                    None => {}\n-                };\n-\n-                let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n-                last_discriminant = Some(discriminant);\n-                variant_info\n-\n-            }).collect()\n-          }\n-          _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+        {\n+            let items = cx.items.borrow();\n+            match items.get().get_copy(&id.node) {\n+              ast_map::node_item(@ast::item {\n+                        node: ast::item_enum(ref enum_definition, _),\n+                        ..\n+                    }, _) => {\n+                let mut last_discriminant: Option<Disr> = None;\n+                @enum_definition.variants.iter().map(|&variant| {\n+\n+                    let mut discriminant = match last_discriminant {\n+                        Some(val) => val + 1,\n+                        None => INITIAL_DISCRIMINANT_VALUE\n+                    };\n+\n+                    match variant.node.disr_expr {\n+                        Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n+                            Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n+                            Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n+                            Ok(_) => {\n+                                cx.sess.span_err(e.span, \"expected signed integer constant\");\n+                            }\n+                            Err(ref err) => {\n+                                cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n+                            }\n+                        },\n+                        None => {}\n+                    };\n+\n+                    let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n+                    last_discriminant = Some(discriminant);\n+                    variant_info\n+\n+                }).collect()\n+              }\n+              _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+            }\n         }\n     };\n \n@@ -4040,11 +4050,17 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n // decoder to use iterators instead of higher-order functions.)\n pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n-        match tcx.items.find(&did.node) {\n-            Some(&ast_map::node_item(@ast::item {attrs: ref attrs, ..}, _)) =>\n-                attrs.iter().advance(|attr| f(attr.node.value)),\n-            _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n-                                      did))\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&did.node) {\n+                Some(&ast_map::node_item(@ast::item {\n+                    attrs: ref attrs,\n+                    ..\n+                }, _)) =>\n+                    attrs.iter().advance(|attr| f(attr.node.value)),\n+                _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n+                                          did))\n+            }\n         }\n     } else {\n         let mut cont = true;\n@@ -4120,37 +4136,39 @@ pub fn lookup_field_type(tcx: ctxt,\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n   if did.crate == ast::LOCAL_CRATE {\n-    match cx.items.find(&did.node) {\n-       Some(&ast_map::node_item(i,_)) => {\n-         match i.node {\n-            ast::item_struct(struct_def, _) => {\n-               struct_field_tys(struct_def.fields)\n-            }\n-            _ => cx.sess.bug(\"struct ID bound to non-struct\")\n-         }\n-       }\n-       Some(&ast_map::node_variant(ref variant, _, _)) => {\n-          match (*variant).node.kind {\n-            ast::struct_variant_kind(struct_def) => {\n-              struct_field_tys(struct_def.fields)\n-            }\n-            _ => {\n-              cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n-                           struct-like\")\n-            }\n+      {\n+          let items = cx.items.borrow();\n+          match items.get().find(&did.node) {\n+           Some(&ast_map::node_item(i,_)) => {\n+             match i.node {\n+                ast::item_struct(struct_def, _) => {\n+                   struct_field_tys(struct_def.fields)\n+                }\n+                _ => cx.sess.bug(\"struct ID bound to non-struct\")\n+             }\n+           }\n+           Some(&ast_map::node_variant(ref variant, _, _)) => {\n+              match (*variant).node.kind {\n+                ast::struct_variant_kind(struct_def) => {\n+                  struct_field_tys(struct_def.fields)\n+                }\n+                _ => {\n+                  cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n+                               struct-like\")\n+                }\n+              }\n+           }\n+           _ => {\n+               cx.sess.bug(\n+                   format!(\"struct ID not bound to an item: {}\",\n+                        ast_map::node_id_to_str(cx.items, did.node,\n+                                                token::get_ident_interner())));\n+           }\n           }\n-       }\n-       _ => {\n-           cx.sess.bug(\n-               format!(\"struct ID not bound to an item: {}\",\n-                    ast_map::node_id_to_str(cx.items, did.node,\n-                                            token::get_ident_interner())));\n-       }\n-    }\n-        }\n-  else {\n-        return csearch::get_struct_fields(cx.sess.cstore, did);\n-    }\n+      }\n+  } else {\n+    return csearch::get_struct_fields(cx.sess.cstore, did);\n+  }\n }\n \n pub fn lookup_struct_field(cx: ctxt,\n@@ -4658,7 +4676,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n /// If it implements no trait, return `None`.\n pub fn trait_id_of_impl(tcx: ctxt,\n                         def_id: ast::DefId) -> Option<ast::DefId> {\n-    let node = match tcx.items.find(&def_id.node) {\n+    let items = tcx.items.borrow();\n+    let node = match items.get().find(&def_id.node) {\n         Some(node) => node,\n         None => return None\n     };"}, {"sha": "6e2afb1d2e7f786a9f810e3973e9fd92f22f347e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -1309,10 +1309,17 @@ impl<'a> LookupContext<'a> {\n \n     fn report_static_candidate(&self, idx: uint, did: DefId) {\n         let span = if did.crate == ast::LOCAL_CRATE {\n-            match self.tcx().items.find(&did.node) {\n-              Some(&ast_map::node_method(m, _, _))\n-              | Some(&ast_map::node_trait_method(@ast::provided(m), _, _)) => m.span,\n-              _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n+            {\n+                let items = self.tcx().items.borrow();\n+                match items.get().find(&did.node) {\n+                  Some(&ast_map::node_method(m, _, _))\n+                  | Some(&ast_map::node_trait_method(@ast::provided(m),\n+                                                     _,\n+                                                     _)) => {\n+                      m.span\n+                  }\n+                  _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n+                }\n             }\n         } else {\n             self.expr.span"}, {"sha": "d18c2419735d4770d9d4e1a67945a550dd0643c4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -568,10 +568,8 @@ impl CoherenceChecker {\n \n                         // Make sure that this type precisely names a nominal\n                         // type.\n-                        match self.crate_context\n-                                  .tcx\n-                                  .items\n-                                  .find(&def_id.node) {\n+                        let items = self.crate_context.tcx.items.borrow();\n+                        match items.get().find(&def_id.node) {\n                             None => {\n                                 self.crate_context.tcx.sess.span_bug(\n                                     original_type.span,\n@@ -628,7 +626,8 @@ impl CoherenceChecker {\n \n     pub fn span_of_impl(&self, implementation: @Impl) -> Span {\n         assert_eq!(implementation.did.crate, LOCAL_CRATE);\n-        match self.crate_context.tcx.items.find(&implementation.did.node) {\n+        let items = self.crate_context.tcx.items.borrow();\n+        match items.get().find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {\n                 return item.span;\n             }\n@@ -732,14 +731,19 @@ impl CoherenceChecker {\n                 _ => {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.crate == ast::LOCAL_CRATE {\n-                        match tcx.items.find(&impl_info.did.node) {\n-                            Some(&ast_map::node_item(@ref item, _)) => {\n-                                tcx.sess.span_err((*item).span,\n-                                                  \"the Drop trait may only be implemented on \\\n-                                                   structures\");\n-                            }\n-                            _ => {\n-                                tcx.sess.bug(\"didn't find impl in ast map\");\n+                        {\n+                            let items = tcx.items.borrow();\n+                            match items.get().find(&impl_info.did.node) {\n+                                Some(&ast_map::node_item(@ref item, _)) => {\n+                                    tcx.sess.span_err((*item).span,\n+                                                      \"the Drop trait may \\\n+                                                       only be implemented \\\n+                                                       on structures\");\n+                                }\n+                                _ => {\n+                                    tcx.sess.bug(\"didn't find impl in ast \\\n+                                                  map\");\n+                                }\n                             }\n                         }\n                     } else {"}, {"sha": "410c94a9a67f3676b187603596b18d566a2dcade", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -106,19 +106,18 @@ impl AstConv for CrateCtxt {\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         if id.crate != ast::LOCAL_CRATE {\n-            csearch::get_type(self.tcx, id)\n-        } else {\n-            match self.tcx.items.find(&id.node) {\n-              Some(&ast_map::node_item(item, _)) => {\n-                ty_of_item(self, item)\n-              }\n-              Some(&ast_map::node_foreign_item(foreign_item, abis, _, _)) => {\n+            return csearch::get_type(self.tcx, id)\n+        }\n+\n+        let items = self.tcx.items.borrow();\n+        match items.get().find(&id.node) {\n+            Some(&ast_map::node_item(item, _)) => ty_of_item(self, item),\n+            Some(&ast_map::node_foreign_item(foreign_item, abis, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item, abis)\n-              }\n-              ref x => {\n+            }\n+            ref x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of item \\\n-                                        in get_item_ty(): {:?}\", (*x)));\n-              }\n+                                           in get_item_ty(): {:?}\", (*x)));\n             }\n         }\n     }\n@@ -187,7 +186,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n-    match tcx.items.get_copy(&trait_id) {\n+    let items = tcx.items.borrow();\n+    match items.get().get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n             ..\n@@ -715,7 +715,8 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let abis = match ccx.tcx.items.find(&i.id) {\n+    let items = ccx.tcx.items.borrow();\n+    let abis = match items.get().find(&i.id) {\n         Some(&ast_map::node_foreign_item(_, abis, _, _)) => abis,\n         ref x => {\n             ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n@@ -765,13 +766,14 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n \n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     if trait_id.crate != ast::LOCAL_CRATE {\n-        ty::lookup_trait_def(ccx.tcx, trait_id)\n-    } else {\n-        match ccx.tcx.items.get(&trait_id.node) {\n-            &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n-            _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                       trait_id.node))\n-        }\n+        return ty::lookup_trait_def(ccx.tcx, trait_id)\n+    }\n+\n+    let items = ccx.tcx.items.borrow();\n+    match items.get().get(&trait_id.node) {\n+        &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n+        _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n+                                   trait_id.node))\n     }\n }\n "}, {"sha": "982e2ca0685b278cb3e91915ca79ca9785edb05a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -350,7 +350,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n         ty::ty_bare_fn(..) => {\n-            match tcx.items.find(&main_id) {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&main_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {\n                         ast::item_fn(_, _, _, ref ps, _)\n@@ -395,7 +396,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {\n         ty::ty_bare_fn(_) => {\n-            match tcx.items.find(&start_id) {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&start_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {\n                         ast::item_fn(_,_,_,ref ps,_)"}, {"sha": "ee77685cf5a127967cff08373aca237850f180e3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -72,7 +72,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n-        match cx.items.find(&node_id) {\n+        let items = cx.items.borrow();\n+        match items.get().find(&node_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n@@ -113,7 +114,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n-        match cx.items.find(&fr.scope_id) {\n+        let items = cx.items.borrow();\n+        match items.get().find(&fr.scope_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -172,7 +174,8 @@ pub fn bound_region_to_str(cx: ctxt,\n }\n \n pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n-    match cx.items.find(&node_id) {\n+    let items = cx.items.borrow();\n+    match items.get().find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n         format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n@@ -740,16 +743,21 @@ impl Repr for ast::DefId {\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n         if self.crate == ast::LOCAL_CRATE {\n-            match tcx.items.find(&self.node) {\n-                Some(&ast_map::node_item(..)) |\n-                Some(&ast_map::node_foreign_item(..)) |\n-                Some(&ast_map::node_method(..)) |\n-                Some(&ast_map::node_trait_method(..)) |\n-                Some(&ast_map::node_variant(..)) |\n-                Some(&ast_map::node_struct_ctor(..)) => {\n-                    return format!(\"{:?}:{}\", *self, ty::item_path_str(tcx, *self));\n+            {\n+                let items = tcx.items.borrow();\n+                match items.get().find(&self.node) {\n+                    Some(&ast_map::node_item(..)) |\n+                    Some(&ast_map::node_foreign_item(..)) |\n+                    Some(&ast_map::node_method(..)) |\n+                    Some(&ast_map::node_trait_method(..)) |\n+                    Some(&ast_map::node_variant(..)) |\n+                    Some(&ast_map::node_struct_ctor(..)) => {\n+                        return format!(\"{:?}:{}\",\n+                                       *self,\n+                                       ty::item_path_str(tcx, *self));\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n         }\n         return format!(\"{:?}\", *self);"}, {"sha": "3897c4c2854157812025b77564a43ec11fb909e7", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449ebeea08a3e0c50b3487bc6d561f49caf57b7e/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "patch": "@@ -23,6 +23,7 @@ use print::pprust;\n use visit::{Visitor, fn_kind};\n use visit;\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::vec;\n \n@@ -192,7 +193,7 @@ impl ast_node {\n     }\n }\n \n-pub type map = @mut HashMap<NodeId, ast_node>;\n+pub type map = @RefCell<HashMap<NodeId, ast_node>>;\n \n pub struct Ctx {\n     map: map,\n@@ -215,8 +216,10 @@ impl Ctx {\n         } else {\n             node_method(m, impl_did, impl_path)\n         };\n-        self.map.insert(m.id, entry);\n-        self.map.insert(m.self_id, node_local(special_idents::self_));\n+\n+        let mut map = self.map.borrow_mut();\n+        map.get().insert(m.id, entry);\n+        map.get().insert(m.self_id, node_local(special_idents::self_));\n     }\n \n     fn map_struct_def(&mut self,\n@@ -231,10 +234,11 @@ impl Ctx {\n             Some(ctor_id) => {\n                 match parent_node {\n                     node_item(item, _) => {\n-                        self.map.insert(ctor_id,\n-                                        node_struct_ctor(struct_def,\n-                                                         item,\n-                                                         p));\n+                        let mut map = self.map.borrow_mut();\n+                        map.get().insert(ctor_id,\n+                                         node_struct_ctor(struct_def,\n+                                                          item,\n+                                                          p));\n                     }\n                     _ => fail!(\"struct def parent wasn't an item\")\n                 }\n@@ -243,13 +247,17 @@ impl Ctx {\n     }\n \n     fn map_expr(&mut self, ex: @Expr) {\n-        self.map.insert(ex.id, node_expr(ex));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(ex.id, node_expr(ex));\n+        }\n \n         // Expressions which are or might be calls:\n         {\n             let r = ex.get_callee_id();\n             for callee_id in r.iter() {\n-                self.map.insert(*callee_id, node_callee_scope(ex));\n+                let mut map = self.map.borrow_mut();\n+                map.get().insert(*callee_id, node_callee_scope(ex));\n             }\n         }\n \n@@ -263,7 +271,8 @@ impl Ctx {\n               sp: codemap::Span,\n               id: NodeId) {\n         for a in decl.inputs.iter() {\n-            self.map.insert(a.id, node_arg(a.pat));\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(a.id, node_arg(a.pat));\n         }\n         match *fk {\n             visit::fk_method(name, _, _) => { self.path.push(path_name(name)) }\n@@ -277,21 +286,29 @@ impl Ctx {\n     }\n \n     fn map_stmt(&mut self, stmt: @Stmt) {\n-        self.map.insert(stmt_id(stmt), node_stmt(stmt));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(stmt_id(stmt), node_stmt(stmt));\n+        }\n         visit::walk_stmt(self, stmt, ());\n     }\n \n     fn map_block(&mut self, b: P<Block>) {\n-        self.map.insert(b.id, node_block(b));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(b.id, node_block(b));\n+        }\n+\n         visit::walk_block(self, b, ());\n     }\n \n     fn map_pat(&mut self, pat: &Pat) {\n         match pat.node {\n             PatIdent(_, ref path, _) => {\n                 // Note: this is at least *potentially* a pattern...\n-                self.map.insert(pat.id,\n-                                node_local(ast_util::path_to_ident(path)));\n+                let mut map = self.map.borrow_mut();\n+                map.get().insert(pat.id,\n+                                 node_local(ast_util::path_to_ident(path)));\n             }\n             _ => ()\n         }\n@@ -304,7 +321,10 @@ impl Visitor<()> for Ctx {\n     fn visit_item(&mut self, i: @item, _: ()) {\n         // clone is FIXME #2543\n         let item_path = @self.path.clone();\n-        self.map.insert(i.id, node_item(i, item_path));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(i.id, node_item(i, item_path));\n+        }\n         match i.node {\n             item_impl(_, ref maybe_trait, ty, ref ms) => {\n                 // Right now the ident on impls is __extensions__ which isn't\n@@ -323,8 +343,9 @@ impl Visitor<()> for Ctx {\n             item_enum(ref enum_definition, _) => {\n                 for &v in enum_definition.variants.iter() {\n                     let elt = path_name(i.ident);\n-                    self.map.insert(v.node.id,\n-                                    node_variant(v, i, self.extend(elt)));\n+                    let mut map = self.map.borrow_mut();\n+                    map.get().insert(v.node.id,\n+                                     node_variant(v, i, self.extend(elt)));\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n@@ -336,16 +357,17 @@ impl Visitor<()> for Ctx {\n                         inherited => i.vis\n                     };\n \n-                    self.map.insert(nitem.id,\n-                                    node_foreign_item(*nitem,\n-                                                      nm.abis,\n-                                                      visibility,\n-                                                      // FIXME (#2543)\n+                    let mut map = self.map.borrow_mut();\n+                    map.get().insert(nitem.id,\n+                                     node_foreign_item(*nitem,\n+                                                       nm.abis,\n+                                                       visibility,\n+                                                       // FIXME (#2543)\n                                                         // Anonymous extern\n                                                         // mods go in the\n                                                         // parent scope.\n                                                         @self.path.clone()\n-                                                      ));\n+                                                       ));\n                 }\n             }\n             item_struct(struct_def, _) => {\n@@ -355,7 +377,8 @@ impl Visitor<()> for Ctx {\n             }\n             item_trait(_, ref traits, ref methods) => {\n                 for p in traits.iter() {\n-                    self.map.insert(p.ref_id, node_item(i, item_path));\n+                    let mut map = self.map.borrow_mut();\n+                    map.get().insert(p.ref_id, node_item(i, item_path));\n                 }\n                 for tm in methods.iter() {\n                     let ext = { self.extend(path_name(i.ident)) };\n@@ -364,7 +387,8 @@ impl Visitor<()> for Ctx {\n                         required(ref m) => {\n                             let entry =\n                                 node_trait_method(@(*tm).clone(), d_id, ext);\n-                            self.map.insert(m.id, entry);\n+                            let mut map = self.map.borrow_mut();\n+                            map.get().insert(m.id, entry);\n                         }\n                         provided(m) => {\n                             self.map_method(d_id, ext, m, true);\n@@ -420,7 +444,7 @@ impl Visitor<()> for Ctx {\n \n pub fn map_crate(diag: @SpanHandler, c: &Crate) -> map {\n     let cx = @mut Ctx {\n-        map: @mut HashMap::new(),\n+        map: @RefCell::new(HashMap::new()),\n         path: ~[],\n         diag: diag,\n     };\n@@ -450,10 +474,11 @@ pub fn map_decoded_item(diag: @SpanHandler,\n     match *ii {\n         ii_item(..) => {} // fallthrough\n         ii_foreign(i) => {\n-            cx.map.insert(i.id, node_foreign_item(i,\n-                                                  AbiSet::Intrinsic(),\n-                                                  i.vis,    // Wrong but OK\n-                                                  @path));\n+            let mut map = cx.map.borrow_mut();\n+            map.get().insert(i.id, node_foreign_item(i,\n+                                                     AbiSet::Intrinsic(),\n+                                                     i.vis,    // Wrong but OK\n+                                                     @path));\n         }\n         ii_method(impl_did, is_provided, m) => {\n             cx.map_method(impl_did, @path, m, is_provided);\n@@ -465,7 +490,8 @@ pub fn map_decoded_item(diag: @SpanHandler,\n }\n \n pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n-    match map.find(&id) {\n+    let map = map.borrow();\n+    match map.get().find(&id) {\n       None => {\n         format!(\"unknown node (id={})\", id)\n       }\n@@ -529,7 +555,8 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n \n pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result, error_msg: ~str)\n                        -> Result {\n-    match items.find(&id) {\n+    let items = items.borrow();\n+    match items.get().find(&id) {\n         Some(&node_item(it, _)) => query(it),\n         _ => fail!(\"{}\", error_msg)\n     }\n@@ -538,7 +565,8 @@ pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result,\n pub fn node_span(items: map,\n                  id: ast::NodeId)\n                  -> Span {\n-    match items.find(&id) {\n+    let items = items.borrow();\n+    match items.get().find(&id) {\n         Some(&node_item(item, _)) => item.span,\n         Some(&node_foreign_item(foreign_item, _, _, _)) => foreign_item.span,\n         Some(&node_trait_method(@required(ref type_method), _, _)) => type_method.span,"}]}